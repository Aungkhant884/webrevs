{"files":[{"patch":"@@ -31,3 +31,11 @@\n-JPACKAGE_APPLAUNCHER_SRC := \\\n-    $(call FindSrcDirsForComponent, jdk.jpackage, applauncher) \\\n-    $(call FindSrcDirsForComponent, jdk.jpackage, common)\n+ifeq ($(call isTargetOs, linux), true)\n+  JPACKAGE_APPLAUNCHER_SRC := \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, applauncher)\n+  JPACKAGE_APPLAUNCHER_TOOLCHAIN := TOOLCHAIN_DEFAULT\n+  JPACKAGE_APPLAUNCHER_INCLUDE_FILES := %.c\n+else\n+  JPACKAGE_APPLAUNCHER_SRC := \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, applauncher) \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, common)\n+  JPACKAGE_APPLAUNCHER_TOOLCHAIN := TOOLCHAIN_LINK_CXX\n+endif\n@@ -47,0 +55,2 @@\n+JPACKAGE_CFLAGS_windows := -DUNICODE -D_UNICODE\n+JPACKAGE_APPLAUNCHER_INCLUDES := $(addprefix -I, $(JPACKAGE_APPLAUNCHER_SRC))\n@@ -54,1 +64,2 @@\n-    TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n+    INCLUDE_FILES := $(JPACKAGE_APPLAUNCHER_INCLUDE_FILES), \\\n+    TOOLCHAIN := $(JPACKAGE_APPLAUNCHER_TOOLCHAIN), \\\n@@ -57,1 +68,3 @@\n-        $(addprefix -I, $(JPACKAGE_APPLAUNCHER_SRC)), \\\n+        $(JPACKAGE_APPLAUNCHER_INCLUDES), \\\n+    CFLAGS := $(call JpackageWithStaticCrt, $(CFLAGS_JDKEXE)) \\\n+        $(JPACKAGE_APPLAUNCHER_INCLUDES), \\\n@@ -59,0 +72,1 @@\n+    CFLAGS_windows := $(JPACKAGE_CFLAGS_windows), \\\n@@ -60,3 +74,3 @@\n-    LIBS_macosx := -framework Cocoa, \\\n-    LIBS := $(LIBCXX), \\\n-    LIBS_linux := -ldl, \\\n+    LIBS_macosx := $(LIBCXX) -framework Cocoa, \\\n+    LIBS_windows := $(LIBCXX), \\\n+    LIBS_linux := -nodefaultlibs -lc -ldl, \\\n@@ -65,1 +79,31 @@\n-$(BUILD_JPACKAGE_APPLAUNCHEREXE): $(call FindLib, java.base, java)\n+JPACKAGE_TARGETS += $(BUILD_JPACKAGE_APPLAUNCHEREXE)\n+\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux), true)\n+\n+  JPACKAGE_LIBAPPLAUNCHER_SRC := \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, applauncher) \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, libapplauncher) \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, common)\n+\n+  JPACKAGE_LIBAPPLAUNCHER_INCLUDES := $(addprefix -I, $(JPACKAGE_LIBAPPLAUNCHER_SRC))\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_JPACKAGE_LIBAPPLAUNCHER, \\\n+      NAME := jpackageapplauncher, \\\n+      OUTPUT_DIR := $(JPACKAGE_OUTPUT_DIR), \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncher, \\\n+      SRC := $(JPACKAGE_LIBAPPLAUNCHER_SRC), \\\n+      EXCLUDE_FILES := LinuxLauncher.c LinuxPackage.c, \\\n+      TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n+      OPTIMIZATION := LOW, \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB) $(JPACKAGE_LIBAPPLAUNCHER_INCLUDES), \\\n+      CFLAGS := $(CFLAGS_JDKLIB) $(JPACKAGE_LIBAPPLAUNCHER_INCLUDES), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+      LIBS := $(LIBCXX) -ldl, \\\n+  ))\n+\n+  JPACKAGE_TARGETS += $(BUILD_JPACKAGE_LIBAPPLAUNCHER)\n+\n+endif\n@@ -67,1 +111,0 @@\n-TARGETS += $(BUILD_JPACKAGE_APPLAUNCHEREXE)\n@@ -83,1 +126,1 @@\n-  TARGETS += $(BUILD_LIB_JPACKAGE)\n+  JPACKAGE_TARGETS += $(BUILD_LIB_JPACKAGE)\n@@ -99,1 +142,1 @@\n-  TARGETS += $(BUILD_LIB_WIXHELPER)\n+  JPACKAGE_TARGETS += $(BUILD_LIB_WIXHELPER)\n@@ -117,1 +160,1 @@\n-  TARGETS += $(BUILD_JPACKAGE_MSIWRAPPER)\n+  JPACKAGE_TARGETS += $(BUILD_JPACKAGE_MSIWRAPPER)\n@@ -121,11 +164,14 @@\n-    NAME := jpackageapplauncherw, \\\n-    OUTPUT_DIR := $(JPACKAGE_OUTPUT_DIR), \\\n-    SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/jpackageapplauncherw, \\\n-    SRC := $(BUILD_JPACKAGE_APPLAUNCHEREXE_SRC), \\\n-    TOOLCHAIN := $(BUILD_JPACKAGE_APPLAUNCHEREXE_TOOLCHAIN), \\\n-    OPTIMIZATION := $(BUILD_JPACKAGE_APPLAUNCHEREXE_OPTIMIZATION), \\\n-    CXXFLAGS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CXXFLAGS), \\\n-    CXXFLAGS_windows := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CXXFLAGS_windows) -DJP_LAUNCHERW, \\\n-    LDFLAGS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_LDFLAGS), \\\n-    LIBS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_LIBS), \\\n-))\n+      NAME := jpackageapplauncherw, \\\n+      OUTPUT_DIR := $(JPACKAGE_OUTPUT_DIR), \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/jpackageapplauncherw, \\\n+      SRC := $(BUILD_JPACKAGE_APPLAUNCHEREXE_SRC), \\\n+      TOOLCHAIN := $(BUILD_JPACKAGE_APPLAUNCHEREXE_TOOLCHAIN), \\\n+      OPTIMIZATION := $(BUILD_JPACKAGE_APPLAUNCHEREXE_OPTIMIZATION), \\\n+      CXXFLAGS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CXXFLAGS), \\\n+      CXXFLAGS_windows := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CXXFLAGS_windows) -DJP_LAUNCHERW, \\\n+      CFLAGS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CFLAGS), \\\n+      CFLAGS_windows := $(BUILD_JPACKAGE_APPLAUNCHEREXE_CFLAGS_windows) -DJP_LAUNCHERW, \\\n+      LDFLAGS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_LDFLAGS), \\\n+      LIBS := $(BUILD_JPACKAGE_APPLAUNCHEREXE_LIBS), \\\n+      LIBS_windows := $(BUILD_JPACKAGE_APPLAUNCHEREXE_LIBS_windows), \\\n+  ))\n@@ -133,1 +179,1 @@\n-  TARGETS += $(BUILD_JPACKAGE_APPLAUNCHERWEXE)\n+  JPACKAGE_TARGETS += $(BUILD_JPACKAGE_APPLAUNCHERWEXE)\n@@ -136,0 +182,5 @@\n+\n+\n+TARGETS += $(JPACKAGE_TARGETS)\n+\n+$(JPACKAGE_TARGETS): $(call FindLib, java.base, java)\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":76,"deletions":25,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+        \/\/ create app launcher shared library\n+        createLauncherLib();\n+\n@@ -98,0 +101,11 @@\n+    private void createLauncherLib() throws IOException {\n+        Path path = appLayout.pathGroup().getPath(\n+                ApplicationLayout.PathRole.LINUX_APPLAUNCHER_LIB);\n+        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncher.so\")) {\n+            writeEntry(resource, path);\n+        }\n+\n+        path.toFile().setExecutable(true, false);\n+        path.toFile().setWritable(true, true);\n+    }\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <linux\/limits.h>\n+#include <unistd.h>\n+#include <libgen.h>\n+#include \"JvmLauncher.h\"\n+#include \"LinuxPackage.h\"\n+\n+\n+#define STATUS_FAILURE 1\n+\n+typedef JvmlLauncherHandle (*JvmlLauncherAPI_CreateFunType)(int argc, char *argv[]);\n+\n+static int appArgc;\n+static char **appArgv;\n+\n+\n+static JvmlLauncherData* initJvmlLauncherData(void) {\n+    char* launcherLibPath = 0;\n+    void* jvmLauncherLibHandle = 0;\n+    JvmlLauncherAPI_GetAPIFunc getApi = 0;\n+    JvmlLauncherAPI_CreateFunType createJvmlLauncher = 0;\n+    JvmlLauncherAPI* api = 0;\n+    JvmlLauncherHandle jvmLauncherHandle = 0;\n+    JvmlLauncherData* result = 0;\n+\n+    launcherLibPath = getJvmLauncherLibPath();\n+    if (!launcherLibPath) {\n+        goto cleanup;\n+    }\n+\n+    jvmLauncherLibHandle = dlopen(launcherLibPath, RTLD_NOW | RTLD_LOCAL);\n+    if (!jvmLauncherLibHandle) {\n+        JP_LOG_ERRMSG(dlerror());\n+        goto cleanup;\n+    }\n+\n+    getApi = dlsym(jvmLauncherLibHandle, \"jvmLauncherGetAPI\");\n+    if (!getApi) {\n+        JP_LOG_ERRMSG(dlerror());\n+        goto cleanup;\n+    }\n+\n+    api = (*getApi)();\n+    if (!api) {\n+        JP_LOG_ERRMSG(\"Failed to get JvmlLauncherAPI instance\");\n+        goto cleanup;\n+    }\n+\n+    createJvmlLauncher = dlsym(jvmLauncherLibHandle, \"jvmLauncherCreate\");\n+    if (!createJvmlLauncher) {\n+        JP_LOG_ERRMSG(dlerror());\n+        goto cleanup;\n+    }\n+\n+    jvmLauncherHandle = (*createJvmlLauncher)(appArgc, appArgv);\n+    if (!jvmLauncherHandle) {\n+        goto cleanup;\n+    }\n+\n+    result = jvmLauncherCreateJvmlLauncherData(api, jvmLauncherHandle);\n+    \/* Handle released in jvmLauncherCreateJvmlLauncherData() *\/\n+    jvmLauncherHandle = 0;\n+\n+cleanup:\n+    if (jvmLauncherHandle) {\n+        jvmLauncherCloseHandle(api, jvmLauncherHandle);\n+    }\n+    if (jvmLauncherLibHandle) {\n+        dlclose(jvmLauncherLibHandle);\n+    }\n+    free(launcherLibPath);\n+\n+    return result;\n+}\n+\n+\n+static int launchJvm(JvmlLauncherData* cfg) {\n+    void* jliLibHandle = 0;\n+    void* JLI_Launch;\n+    int exitCode = STATUS_FAILURE;\n+\n+    jliLibHandle = dlopen(cfg->jliLibPath, RTLD_NOW | RTLD_LOCAL);\n+    if (!jliLibHandle) {\n+        JP_LOG_ERRMSG(dlerror());\n+        goto cleanup;\n+    }\n+\n+    JLI_Launch = dlsym(jliLibHandle, \"JLI_Launch\");\n+    if (!JLI_Launch) {\n+        JP_LOG_ERRMSG(dlerror());\n+        goto cleanup;\n+    }\n+\n+    exitCode = jvmLauncherStartJvm(cfg, JLI_Launch);\n+\n+cleanup:\n+    if (jliLibHandle) {\n+        dlclose(jliLibHandle);\n+    }\n+\n+    return exitCode;\n+}\n+\n+\n+int main(int argc, char *argv[]) {\n+    int exitCode = STATUS_FAILURE;\n+    JvmlLauncherData* jvmLauncherData;\n+\n+    appArgc = argc;\n+    appArgv = argv;\n+\n+    jvmLauncherData = initJvmlLauncherData();\n+    if (jvmLauncherData) {\n+        exitCode = launchJvm(jvmLauncherData);\n+        free(jvmLauncherData);\n+    }\n+\n+    return exitCode;\n+}\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxLauncher.c","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"AppLauncher.h\"\n-#include \"FileUtils.h\"\n-#include \"UnixSysInfo.h\"\n-#include \"Package.h\"\n-#include \"Log.h\"\n-#include \"app.h\"\n-#include \"ErrorHandling.h\"\n-\n-\n-namespace {\n-\n-size_t hash(const std::string& str) {\n-    size_t h = 0;\n-    for(std::string::const_iterator it = str.begin(); it != str.end(); ++it) {\n-        h = 31 * h + (*it & 0xff);\n-    }\n-    return h;\n-}\n-\n-void launchApp() {\n-    const tstring launcherPath = SysInfo::getProcessModulePath();\n-\n-    const Package ownerPackage = Package::findOwnerOfFile(launcherPath);\n-\n-    AppLauncher appLauncher;\n-    appLauncher.addJvmLibName(_T(\"lib\/libjli.so\"));\n-\n-    if (ownerPackage.name().empty()) {\n-        \/\/ Launcher should be in \"bin\" subdirectory of app image.\n-        const tstring appImageRoot = FileUtils::dirname(\n-                FileUtils::dirname(launcherPath));\n-\n-        appLauncher\n-            .setImageRoot(appImageRoot)\n-            .setAppDir(FileUtils::mkpath() << appImageRoot << _T(\"lib\/app\"))\n-            .setDefaultRuntimePath(FileUtils::mkpath() << appImageRoot\n-                    << _T(\"lib\/runtime\"));\n-    } else {\n-        ownerPackage.initAppLauncher(appLauncher);\n-    }\n-\n-    const std::string _JPACKAGE_LAUNCHER = \"_JPACKAGE_LAUNCHER\";\n-\n-    std::string launchInfo = SysInfo::getEnvVariable(std::nothrow,\n-            _JPACKAGE_LAUNCHER, \"\");\n-\n-    const std::string thisLdLibraryPath = SysInfo::getEnvVariable(std::nothrow,\n-            \"LD_LIBRARY_PATH\", \"\");\n-\n-    const size_t thisHash = hash(thisLdLibraryPath);\n-\n-    if (!launchInfo.empty()) {\n-        LOG_TRACE(tstrings::any() << \"Found \"\n-                << _JPACKAGE_LAUNCHER << \"=[\" << launchInfo << \"]\");\n-\n-        tistringstream iss(launchInfo);\n-        iss.exceptions(std::ios::failbit | std::ios::badbit);\n-\n-        size_t hash = 0;\n-        iss >> hash;\n-\n-        launchInfo = \"\";\n-\n-        if (thisHash != hash) {\n-            \/\/ This launcher execution is the result of execve() call from\n-            \/\/ withing JVM.\n-            \/\/ This means all JVM arguments are already configured in launcher\n-            \/\/ process command line.\n-            \/\/ No need to construct command line for JVM.\n-            LOG_TRACE(\"Not building JVM arguments from cfg file\");\n-            appLauncher.setInitJvmFromCmdlineOnly(true);\n-        }\n-    } else {\n-        \/\/ Changed LD_LIBRARY_PATH environment variable might result in\n-        \/\/ execve() call from within JVM.\n-        \/\/ Set _JPACKAGE_LAUNCHER environment variable accordingly so that\n-        \/\/ restarted launcher process can detect a restart.\n-\n-        launchInfo = (tstrings::any() << thisHash).str();\n-    }\n-\n-    JP_TRY;\n-    if (0 != setenv(_JPACKAGE_LAUNCHER.c_str(), launchInfo.c_str(), 1)) {\n-        JP_THROW(tstrings::any() << \"setenv(\" << _JPACKAGE_LAUNCHER\n-                << \", \" << launchInfo << \") failed. Error: \" << lastCRTError());\n-    } else {\n-        LOG_TRACE(tstrings::any() << \"Set \"\n-                << _JPACKAGE_LAUNCHER << \"=[\" << launchInfo << \"]\");\n-    }\n-    JP_CATCH_ALL;\n-\n-    appLauncher.launch();\n-}\n-\n-} \/\/ namespace\n-\n-\n-int main(int argc, char *argv[]) {\n-    SysInfo::argc = argc;\n-    SysInfo::argv = argv;\n-    return app::launch(std::nothrow, launchApp);\n-}\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxLauncher.cpp","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <linux\/limits.h>\n+#include <unistd.h>\n+#include <libgen.h>\n+#include \"JvmLauncher.h\"\n+#include \"LinuxPackage.h\"\n+\n+\n+static char* getModulePath(void) {\n+    char modulePath[PATH_MAX] = { 0 };\n+    ssize_t modulePathLen = 0;\n+    char* result = 0;\n+\n+    modulePathLen = readlink(\"\/proc\/self\/exe\", modulePath,\n+                                                    sizeof(modulePath) - 1);\n+    if (modulePathLen < 0) {\n+        JP_LOG_ERRNO;\n+        return 0;\n+    }\n+    modulePath[modulePathLen] = '\\0';\n+    result = strdup(modulePath);\n+    if (!result) {\n+        JP_LOG_ERRNO;\n+    }\n+\n+    return result;\n+}\n+\n+\n+# define PACKAGE_TYPE_UNKNOWN 0\n+# define PACKAGE_TYPE_RPM 1\n+# define PACKAGE_TYPE_DEB 2\n+\n+typedef struct {\n+    char* name;\n+    int type;\n+} PackageDesc;\n+\n+\n+static void freePackageDesc(PackageDesc* desc) {\n+    if (desc) {\n+        free(desc->name);\n+        free(desc);\n+    }\n+}\n+\n+\n+static PackageDesc* createPackageDesc(void) {\n+    PackageDesc* result = 0;\n+\n+    result = malloc(sizeof(PackageDesc));\n+    if (!result) {\n+        JP_LOG_ERRNO;\n+        goto cleanup;\n+    }\n+\n+    result->type = PACKAGE_TYPE_UNKNOWN;\n+    result->name = 0;\n+\n+cleanup:\n+    return result;\n+}\n+\n+\n+static PackageDesc* initPackageDesc(PackageDesc* desc, const char* str,\n+                                                                int type) {\n+    char *newStr = strdup(str);\n+    if (!newStr) {\n+        JP_LOG_ERRNO;\n+        return 0;\n+    }\n+\n+    free(desc->name);\n+    desc->name = newStr;\n+    desc->type = type;\n+    return desc;\n+}\n+\n+\n+#define POPEN_CALLBACK_USE 1\n+#define POPEN_CALLBACK_IGNORE 0\n+\n+typedef int (*popenCallbackType)(void*, const char*);\n+\n+static int popenCommand(const char* cmdlineFormat, const char* arg,\n+                            popenCallbackType callback, void* callbackData) {\n+    char* cmdline = 0;\n+    FILE *stream = 0;\n+    const size_t cmdlineLenth = strlen(cmdlineFormat) + strlen(arg);\n+    char* strBufBegin = 0;\n+    char* strBufEnd = 0;\n+    char* strBufNextChar = 0;\n+    char* strNewBufBegin = 0;\n+    size_t strBufCapacity = 0;\n+    int callbackMode = POPEN_CALLBACK_USE;\n+    int exitCode = -1;\n+    int c;\n+\n+    cmdline = malloc(cmdlineLenth + 1 \/* \\0 *\/);\n+    if (!cmdline) {\n+        JP_LOG_ERRNO;\n+        goto cleanup;\n+    }\n+\n+#if defined(__GNUC__) && __GNUC__ >= 5\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    if (0 > snprintf(cmdline, cmdlineLenth, cmdlineFormat, arg)) {\n+        JP_LOG_ERRNO;\n+        goto cleanup;\n+    }\n+#if defined(__GNUC__) && __GNUC__ >= 5\n+#pragma GCC diagnostic pop\n+#endif\n+\n+    JP_LOG_TRACE(\"popen: (%s)\", cmdline);\n+\n+    stream = popen(cmdline, \"r\");\n+    if (!stream) {\n+        JP_LOG_ERRNO;\n+        goto cleanup;\n+    }\n+\n+    for (;;) {\n+        c = fgetc(stream);\n+        if((EOF == c || '\\n' == c)) {\n+            if (POPEN_CALLBACK_USE == callbackMode\n+                                            && strBufBegin != strBufNextChar) {\n+                *strBufNextChar = 0;\n+                JP_LOG_TRACE(\"popen: [%s]\", strBufBegin);\n+                callbackMode = (*callback)(callbackData, strBufBegin);\n+                strBufNextChar = strBufBegin;\n+            }\n+\n+            if (EOF == c) {\n+                break;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (strBufNextChar == strBufEnd) {\n+            \/* Double buffer size *\/\n+            strBufCapacity = strBufCapacity * 2 + 1;\n+            strNewBufBegin = realloc(strBufBegin, strBufCapacity);\n+            if (!strNewBufBegin) {\n+                JP_LOG_ERRNO;\n+                goto cleanup;\n+            }\n+\n+            strBufNextChar = strNewBufBegin + (strBufNextChar - strBufBegin);\n+            strBufEnd = strNewBufBegin + strBufCapacity;\n+            strBufBegin = strNewBufBegin;\n+        }\n+\n+        *strBufNextChar++ = (char)c;\n+    }\n+\n+cleanup:\n+    if (stream) {\n+        exitCode = pclose(stream);\n+    }\n+\n+    if (strBufBegin) {\n+        free(strBufBegin);\n+    }\n+\n+    free(cmdline);\n+\n+    JP_LOG_TRACE(\"popen: exit: %d\", exitCode);\n+    return exitCode;\n+}\n+\n+\n+static char* concat(const char *x, const char *y) {\n+    const size_t lenX = strlen(x);\n+    const size_t lenY = strlen(y);\n+\n+    char *result = malloc(lenX + lenY + 1 \/* \\0 *\/);\n+    if (!result) {\n+        JP_LOG_ERRNO;\n+    } else {\n+        strcpy(result, x);\n+        strcat(result, y);\n+    }\n+\n+    return result;\n+}\n+\n+\n+static int initRpmPackage(void* desc, const char* str) {\n+    initPackageDesc((PackageDesc*)desc, str, PACKAGE_TYPE_RPM);\n+    return POPEN_CALLBACK_IGNORE;\n+}\n+\n+\n+static int initDebPackage(void* desc, const char* str) {\n+    char* colonChrPos = strchr(str, ':');\n+    if (colonChrPos) {\n+        *colonChrPos = 0;\n+    }\n+    initPackageDesc((PackageDesc*)desc, str, PACKAGE_TYPE_DEB);\n+    return POPEN_CALLBACK_IGNORE;\n+}\n+\n+\n+#define LAUNCHER_LIB_NAME \"\/libapplauncher.so\"\n+\n+static int findLauncherLib(void* launcherLibPath, const char* str) {\n+    char* buf = 0;\n+    const size_t strLen = strlen(str);\n+    const size_t launcherLibNameLen = strlen(LAUNCHER_LIB_NAME);\n+\n+    if (launcherLibNameLen <= strLen\n+            && !strcmp(str + strLen - launcherLibNameLen, LAUNCHER_LIB_NAME)) {\n+        buf = strdup(str);\n+        if (!buf) {\n+            JP_LOG_ERRNO;\n+        } else {\n+            *(char**)launcherLibPath = buf;\n+        }\n+        return POPEN_CALLBACK_IGNORE;\n+    }\n+    return POPEN_CALLBACK_USE;\n+}\n+\n+\n+static PackageDesc* findOwnerOfFile(const char* path) {\n+    int popenStatus = -1;\n+    PackageDesc* pkg = 0;\n+\n+    pkg = createPackageDesc();\n+    if (!pkg) {\n+        return 0;\n+    }\n+\n+    popenStatus = popenCommand(\n+            \"rpm --queryformat '%{NAME}' -qf '%s' 2>\/dev\/null\", path,\n+            initRpmPackage, pkg);\n+    if (popenStatus) {\n+        pkg->type = PACKAGE_TYPE_UNKNOWN;\n+        popenStatus = popenCommand(\"dpkg -S '%s' 2>\/dev\/null\", path,\n+                                                        initDebPackage, pkg);\n+    }\n+\n+    if (popenStatus) {\n+        pkg->type = PACKAGE_TYPE_UNKNOWN;\n+    }\n+\n+    if (PACKAGE_TYPE_UNKNOWN == pkg->type || !pkg->name) {\n+        freePackageDesc(pkg);\n+        pkg = 0;\n+    }\n+\n+    if (pkg) {\n+        JP_LOG_TRACE(\"owner pkg: (%s|%d)\", pkg->name, pkg->type);\n+    }\n+\n+    return pkg;\n+}\n+\n+\n+char* getJvmLauncherLibPath(void) {\n+    char* modulePath = 0;\n+    char* appImageDir = 0;\n+    char* launcherLibPath = 0;\n+    const char* pkgQueryCmd = 0;\n+    int popenStatus = -1;\n+    PackageDesc* pkg = 0;\n+\n+    modulePath = getModulePath();\n+    if (!modulePath) {\n+        goto cleanup;\n+    }\n+\n+    pkg = findOwnerOfFile(modulePath);\n+    if (!pkg) {\n+        \/* Not a package install *\/\n+        \/* Launcher should be in \"bin\" subdirectory of app image. *\/\n+        \/* Launcher lib should be in \"lib\" subdirectory of app image. *\/\n+        appImageDir = dirname(dirname(modulePath));\n+        launcherLibPath = concat(appImageDir, \"\/lib\" LAUNCHER_LIB_NAME);\n+    } else {\n+        if (PACKAGE_TYPE_RPM == pkg->type) {\n+            pkgQueryCmd = \"rpm -ql '%s' 2>\/dev\/null\";\n+        } else if (PACKAGE_TYPE_RPM == pkg->type) {\n+            pkgQueryCmd = \"dpkg -L '%s' 2>\/dev\/null\";\n+        } else {\n+            \/* Should never happen *\/\n+            JP_LOG_ERRMSG(\"Internal error\");\n+            goto cleanup;\n+        }\n+\n+        popenStatus = popenCommand(pkgQueryCmd, pkg->name, findLauncherLib,\n+                                                        &launcherLibPath);\n+        if (popenStatus) {\n+            free(launcherLibPath);\n+            goto cleanup;\n+        }\n+    }\n+\n+cleanup:\n+    free(modulePath);\n+    freePackageDesc(pkg);\n+\n+    return launcherLibPath;\n+}\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxPackage.c","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef LinuxPackage_h\n+#define LinuxPackage_h\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+char* getJvmLauncherLibPath(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* #ifndef LinuxPackage_h *\/\n","filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/LinuxPackage.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/Executor.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/Executor.cpp","status":"renamed"},{"patch":"","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/Executor.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/Executor.h","status":"renamed"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"kludge_c++11.h\"\n+\n+#include <memory>\n+#include \"JvmLauncher.h\"\n+#include \"AppLauncher.h\"\n+#include \"FileUtils.h\"\n+#include \"UnixSysInfo.h\"\n+#include \"Package.h\"\n+#include \"Log.h\"\n+#include \"app.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+namespace {\n+\n+size_t hash(const std::string& str) {\n+    size_t h = 0;\n+    for(std::string::const_iterator it = str.begin(); it != str.end(); ++it) {\n+        h = 31 * h + (*it & 0xff);\n+    }\n+    return h;\n+}\n+\n+Jvm* jvmLauncher;\n+\n+void launchApp() {\n+    const tstring launcherPath = SysInfo::getProcessModulePath();\n+\n+    const Package ownerPackage = Package::findOwnerOfFile(launcherPath);\n+\n+    AppLauncher appLauncher;\n+    appLauncher.addJvmLibName(_T(\"lib\/libjli.so\"));\n+\n+    if (ownerPackage.name().empty()) {\n+        \/\/ Launcher should be in \"bin\" subdirectory of app image.\n+        const tstring appImageRoot = FileUtils::dirname(\n+                FileUtils::dirname(launcherPath));\n+\n+        appLauncher\n+            .setImageRoot(appImageRoot)\n+            .setAppDir(FileUtils::mkpath() << appImageRoot << _T(\"lib\/app\"))\n+            .setDefaultRuntimePath(FileUtils::mkpath() << appImageRoot\n+                    << _T(\"lib\/runtime\"));\n+    } else {\n+        ownerPackage.initAppLauncher(appLauncher);\n+    }\n+\n+    const std::string _JPACKAGE_LAUNCHER = \"_JPACKAGE_LAUNCHER\";\n+\n+    std::string launchInfo = SysInfo::getEnvVariable(std::nothrow,\n+            _JPACKAGE_LAUNCHER, \"\");\n+\n+    const std::string thisLdLibraryPath = SysInfo::getEnvVariable(std::nothrow,\n+            \"LD_LIBRARY_PATH\", \"\");\n+\n+    const size_t thisHash = hash(thisLdLibraryPath);\n+\n+    if (!launchInfo.empty()) {\n+        LOG_TRACE(tstrings::any() << \"Found \"\n+                << _JPACKAGE_LAUNCHER << \"=[\" << launchInfo << \"]\");\n+\n+        tistringstream iss(launchInfo);\n+        iss.exceptions(std::ios::failbit | std::ios::badbit);\n+\n+        size_t hash = 0;\n+        iss >> hash;\n+\n+        launchInfo = \"\";\n+\n+        if (thisHash != hash) {\n+            \/\/ This launcher execution is the result of execve() call from\n+            \/\/ withing JVM.\n+            \/\/ This means all JVM arguments are already configured in launcher\n+            \/\/ process command line.\n+            \/\/ No need to construct command line for JVM.\n+            LOG_TRACE(\"Not building JVM arguments from cfg file\");\n+            appLauncher.setInitJvmFromCmdlineOnly(true);\n+        }\n+    } else {\n+        \/\/ Changed LD_LIBRARY_PATH environment variable might result in\n+        \/\/ execve() call from within JVM.\n+        \/\/ Set _JPACKAGE_LAUNCHER environment variable accordingly so that\n+        \/\/ restarted launcher process can detect a restart.\n+\n+        launchInfo = (tstrings::any() << thisHash).str();\n+    }\n+\n+    JP_TRY;\n+    if (0 != setenv(_JPACKAGE_LAUNCHER.c_str(), launchInfo.c_str(), 1)) {\n+        JP_THROW(tstrings::any() << \"setenv(\" << _JPACKAGE_LAUNCHER\n+                << \", \" << launchInfo << \") failed. Error: \" << lastCRTError());\n+    } else {\n+        LOG_TRACE(tstrings::any() << \"Set \"\n+                << _JPACKAGE_LAUNCHER << \"=[\" << launchInfo << \"]\");\n+    }\n+    JP_CATCH_ALL;\n+\n+    jvmLauncher = appLauncher.createJvmLauncher();\n+}\n+\n+} \/\/ namespace\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT JvmlLauncherHandle jvmLauncherCreate(int argc, char *argv[]) {\n+    SysInfo::argc = argc;\n+    SysInfo::argv = argv;\n+    jvmLauncher = 0;\n+    app::launch(std::nothrow, launchApp);\n+\n+    JvmlLauncherHandle jlh = 0;\n+    if (jvmLauncher) {\n+        jlh = jvmLauncher->exportLauncher();\n+        const std::unique_ptr<Jvm> deleter(jvmLauncher);\n+    }\n+\n+    return jlh;\n+}\n+\n+} \/\/ extern \"C\"\n+\n+\n+namespace {\n+\n+void dcon() __attribute__((destructor));\n+\n+void dcon() {\n+   LOG_TRACE(\"unload\");\n+}\n+\n+} \/\/ namespace\n","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/LinuxLauncherLib.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/Package.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/Package.cpp","status":"renamed"},{"patch":"","filename":"src\/jdk.jpackage\/linux\/native\/libapplauncher\/Package.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/linux\/native\/applauncher\/Package.h","status":"renamed"},{"patch":"@@ -65,0 +65,5 @@\n+\n+        \/**\n+         * Linux app launcher shared library.\n+         *\/\n+        LINUX_APPLAUNCHER_LIB\n@@ -134,1 +139,2 @@\n-                PathRole.MODULES, Path.of(\"lib\/app\/mods\")\n+                PathRole.MODULES, Path.of(\"lib\/app\/mods\"),\n+                PathRole.LINUX_APPLAUNCHER_LIB, Path.of(\"lib\/libapplauncher.so\")\n@@ -189,1 +195,3 @@\n-                PathRole.MODULES, lib.resolve(\"app\/mods\")\n+                PathRole.MODULES, lib.resolve(\"app\/mods\"),\n+                PathRole.LINUX_APPLAUNCHER_LIB, lib.resolve(\n+                        \"lib\/libapplauncher.so\")\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayout.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include <jni.h>\n+#include \"tstrings.h\"\n@@ -42,0 +42,10 @@\n+Jvm::Jvm() {\n+    LOG_TRACE(tstrings::any() << \"Jvm(\" << this << \")::Jvm()\");\n+}\n+\n+\n+Jvm::~Jvm() {\n+    LOG_TRACE(tstrings::any() << \"Jvm(\" << this << \")::~Jvm()\");\n+}\n+\n+\n@@ -163,3 +173,0 @@\n-void convertArgs(const std::vector<std::string>& args, std::vector<char*>& argv) {\n-    argv.reserve(args.size() + 1);\n-    argv.resize(0);\n@@ -167,2 +174,2 @@\n-    std::vector<std::string>::const_iterator it = args.begin();\n-    const std::vector<std::string>::const_iterator end = args.end();\n+struct JvmlLauncherHandleCloser {\n+    typedef JvmlLauncherHandle pointer;\n@@ -170,3 +177,12 @@\n-    for (; it != end; ++it) {\n-        argv.push_back(const_cast<char*>(it->c_str()));\n-    };\n+    void operator()(JvmlLauncherHandle h) {\n+        jvmLauncherCloseHandle(jvmLauncherGetAPI(), h);\n+    }\n+};\n+\n+struct JvmlLauncherDataDeleter {\n+    typedef JvmlLauncherData* pointer;\n+\n+    void operator()(JvmlLauncherData* ptr) {\n+        free(ptr);\n+    }\n+};\n@@ -174,3 +190,0 @@\n-    \/\/ Add treminal '0'.\n-    argv.push_back(0);\n-}\n@@ -180,13 +193,93 @@\n-    typedef int (JNICALL *LaunchFuncType)(int argc, char ** argv,\n-        int jargc, const char** jargv,\n-        int appclassc, const char** appclassv,\n-        const char* fullversion,\n-        const char* dotversion,\n-        const char* pname,\n-        const char* lname,\n-        jboolean javaargs,\n-        jboolean cpwildcard,\n-        jboolean javaw,\n-        jint ergo);\n-\n-    std::vector<char*> argv;\n+    typedef std::unique_ptr<\n+        JvmlLauncherHandle, JvmlLauncherHandleCloser> AutoJvmlLauncherHandle;\n+\n+    typedef std::unique_ptr<\n+        JvmlLauncherData, JvmlLauncherDataDeleter> AutoJvmlLauncherData;\n+\n+    AutoJvmlLauncherHandle jlh(exportLauncher());\n+\n+    JvmlLauncherAPI* api = jvmLauncherGetAPI();\n+\n+    AutoJvmlLauncherData jld(jvmLauncherCreateJvmlLauncherData(api,\n+                                                            jlh.release()));\n+\n+    LOG_TRACE(tstrings::any() << \"JVM library: \\\"\" << jvmPath << \"\\\"\");\n+\n+    DllFunction<void*> func(Dll(jvmPath), LAUNCH_FUNC);\n+\n+    int exitStatus = jvmLauncherStartJvm(jld.get(), func.operator void*());\n+\n+    if (exitStatus != 0) {\n+        JP_THROW(\"Failed to launch JVM\");\n+    }\n+}\n+\n+\n+namespace {\n+\n+struct JliLaunchData {\n+    std::string jliLibPath;\n+    std::vector<std::string> args;\n+\n+    int initJvmlLauncherData(JvmlLauncherData* ptr, int bufferSize) const {\n+        int minimalBufferSize = initJvmlLauncherData(0);\n+        if (minimalBufferSize <= bufferSize) {\n+            initJvmlLauncherData(ptr);\n+        }\n+        return minimalBufferSize;\n+    }\n+\n+private:\n+    int initJvmlLauncherData(JvmlLauncherData* ptr) const {\n+        \/\/ Store path to JLI library just behind JvmlLauncherData header.\n+        char* curPtr = reinterpret_cast<char*>(ptr + 1);\n+        do {\n+            const size_t count = sizeof(char)\n+                    * (jliLibPath.size() + 1 \/* trailing zero *\/);\n+            if (ptr) {\n+                std::memcpy(curPtr, jliLibPath.c_str(), count);\n+                ptr->jliLibPath = curPtr;\n+            }\n+            curPtr += count;\n+        } while (false);\n+\n+        \/\/ Next write array of char* pointing to JLI lib arg strings.\n+        if (ptr) {\n+            ptr->jliLaunchArgv = reinterpret_cast<char**>(curPtr);\n+            ptr->jliLaunchArgc = (int)args.size();\n+            \/\/ Add terminal '0' arg.\n+            ptr->jliLaunchArgv[ptr->jliLaunchArgc] = 0;\n+        }\n+\n+        \/\/ Skip memory occupied by char* array.\n+        curPtr += sizeof(char*) * (args.size() + 1 \/* terminal '0' arg *\/);\n+\n+        \/\/ Store array of strings.\n+        for (size_t i = 0; i != args.size(); i++) {\n+            const size_t count = (args[i].size() + 1 \/* trailing zero *\/);\n+            if (ptr) {\n+                std::memcpy(curPtr, args[i].c_str(), count);\n+                ptr->jliLaunchArgv[i] = curPtr;\n+            }\n+            curPtr += count;\n+        };\n+\n+        const size_t bufferSize = curPtr - reinterpret_cast<char*>(ptr);\n+        if (ptr) {\n+            LOG_TRACE(tstrings::any() << \"Initialized \" << bufferSize\n+                                        << \" bytes at \" << ptr << \" address\");\n+        } else {\n+            LOG_TRACE(tstrings::any() << \"Need \" << bufferSize\n+                                    << \" bytes for JvmlLauncherData buffer\");\n+        }\n+        return static_cast<int>(bufferSize);\n+    }\n+};\n+\n+} \/\/ namespace\n+\n+JvmlLauncherHandle Jvm::exportLauncher() const {\n+    std::unique_ptr<JliLaunchData> result(new JliLaunchData());\n+\n+    result->jliLibPath = tstrings::toUtf8(jvmPath);\n+\n@@ -194,1 +287,0 @@\n-    std::vector<std::string> mbcs_args;\n@@ -199,1 +291,1 @@\n-            mbcs_args.push_back(tstrings::toACP(*it));\n+            result->args.push_back(tstrings::toACP(*it));\n@@ -202,1 +294,0 @@\n-    convertArgs(mbcs_args, argv);\n@@ -204,1 +295,1 @@\n-    convertArgs(args, argv);\n+    result->args = args;\n@@ -207,2 +298,2 @@\n-    \/\/ Don't count terminal '0'.\n-    const int argc = (int)argv.size() - 1;\n+    return result.release();\n+}\n@@ -210,1 +301,0 @@\n-    LOG_TRACE(tstrings::any() << \"JVM library: \\\"\" << jvmPath << \"\\\"\");\n@@ -212,12 +302,1 @@\n-    DllFunction<LaunchFuncType> func(Dll(jvmPath), LAUNCH_FUNC);\n-    int exitStatus = func(argc, argv.data(),\n-        0, 0,\n-        0, 0,\n-        \"\",\n-        \"\",\n-        \"java\",\n-        \"java\",\n-        JNI_FALSE,\n-        JNI_FALSE,\n-        JNI_FALSE,\n-        0);\n+namespace {\n@@ -225,2 +304,44 @@\n-    if (exitStatus != 0) {\n-        JP_THROW(\"Failed to launch JVM\");\n+void closeHandle(JvmlLauncherHandle h) {\n+    JP_TRY;\n+\n+    JliLaunchData* data = static_cast<JliLaunchData*>(h);\n+    const std::unique_ptr<JliLaunchData> deleter(data);\n+\n+    JP_CATCH_ALL;\n+}\n+\n+\n+int getJvmlLauncherDataSize(JvmlLauncherHandle h) {\n+    JP_TRY;\n+\n+    const JliLaunchData* data = static_cast<const JliLaunchData*>(h);\n+    return data->initJvmlLauncherData(0, 0);\n+\n+    JP_CATCH_ALL;\n+\n+    return -1;\n+}\n+\n+\n+JvmlLauncherData* initJvmlLauncherData(JvmlLauncherHandle h,\n+                                                void* ptr, int bufferSize) {\n+    JP_TRY;\n+\n+    const JliLaunchData* data = static_cast<const JliLaunchData*>(h);\n+    const int usedBufferSize = data->initJvmlLauncherData(\n+                            static_cast<JvmlLauncherData*>(ptr), bufferSize);\n+    if (bufferSize <= usedBufferSize) {\n+        return static_cast<JvmlLauncherData*>(ptr);\n+    }\n+\n+    JP_CATCH_ALL;\n+\n+    return 0;\n+}\n+\n+class Impl : public JvmlLauncherAPI {\n+public:\n+    Impl() {\n+        this->closeHandle = ::closeHandle;\n+        this->getJvmlLauncherDataSize = ::getJvmlLauncherDataSize;\n+        this->initJvmlLauncherData = ::initJvmlLauncherData;\n@@ -228,0 +349,9 @@\n+} api;\n+\n+} \/\/ namespace\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT JvmlLauncherAPI* jvmLauncherGetAPI(void) {\n+    return &api;\n@@ -229,0 +359,2 @@\n+\n+} \/\/ extern \"C\"\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncher.cpp","additions":178,"deletions":46,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -30,0 +30,61 @@\n+\n+#include \"jni.h\" \/* JNIEXPORT *\/\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct {\n+    const char* jliLibPath;\n+    int jliLaunchArgc;\n+    char** jliLaunchArgv;\n+} JvmlLauncherData;\n+\n+typedef void* JvmlLauncherHandle;\n+\n+typedef void (*JvmlLauncherAPI_CloseHandleFunc)(JvmlLauncherHandle);\n+typedef int (*JvmlLauncherAPI_GetJvmlLauncherDataSizeFunc)(JvmlLauncherHandle);\n+typedef JvmlLauncherData* (*JvmlLauncherAPI_InitJvmlLauncherDataFunc)(JvmlLauncherHandle, void*, int);\n+\n+typedef struct {\n+    JvmlLauncherAPI_CloseHandleFunc closeHandle;\n+    JvmlLauncherAPI_GetJvmlLauncherDataSizeFunc getJvmlLauncherDataSize;\n+    JvmlLauncherAPI_InitJvmlLauncherDataFunc initJvmlLauncherData;\n+} JvmlLauncherAPI;\n+\n+typedef JvmlLauncherAPI* (*JvmlLauncherAPI_GetAPIFunc)(void);\n+\n+JNIEXPORT JvmlLauncherAPI* jvmLauncherGetAPI(void);\n+\n+static inline void jvmLauncherCloseHandle(JvmlLauncherAPI* api, JvmlLauncherHandle h) {\n+    (*api->closeHandle)(h);\n+}\n+\n+static inline int jvmLauncherGetJvmlLauncherDataSize(JvmlLauncherAPI* api,\n+                                                        JvmlLauncherHandle h) {\n+    return (*api->getJvmlLauncherDataSize)(h);\n+}\n+\n+static inline JvmlLauncherData* jvmLauncherInitJvmlLauncherData(JvmlLauncherAPI* api,\n+                            JvmlLauncherHandle h, void* ptr, int bufferSize) {\n+    return (*api->initJvmlLauncherData)(h, ptr, bufferSize);\n+}\n+\n+JvmlLauncherData* jvmLauncherCreateJvmlLauncherData(JvmlLauncherAPI* api, JvmlLauncherHandle h);\n+int jvmLauncherStartJvm(JvmlLauncherData* jvmArgs, void* JLI_Launch);\n+\n+void jvmLauncherLog(const char* format, ...);\n+\n+#define JP_LOG_ERRMSG(msg) do { jvmLauncherLog((msg)); } while (0)\n+#define JP_LOG_ERRNO JP_LOG_ERRMSG(strerror(errno))\n+#define JP_LOG_TRACE jvmLauncherLog\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+\n+#ifdef __cplusplus\n+\n@@ -37,0 +98,3 @@\n+    Jvm();\n+    ~Jvm();\n+\n@@ -57,0 +121,2 @@\n+    JvmlLauncherHandle exportLauncher() const;\n+\n@@ -62,0 +128,2 @@\n+#endif \/\/ #ifdef __cplusplus\n+\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncher.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+\n+#include \"JvmLauncher.h\"\n+\n+\n+typedef int (JNICALL *JLI_LaunchFuncType)(int argc, char ** argv,\n+        int jargc, const char** jargv,\n+        int appclassc, const char** appclassv,\n+        const char* fullversion,\n+        const char* dotversion,\n+        const char* pname,\n+        const char* lname,\n+        jboolean javaargs,\n+        jboolean cpwildcard,\n+        jboolean javaw,\n+        jint ergo);\n+\n+\n+JvmlLauncherData* jvmLauncherCreateJvmlLauncherData(\n+                                JvmlLauncherAPI* api, JvmlLauncherHandle h) {\n+    JvmlLauncherData* result = 0;\n+    void* buf = 0;\n+    int jvmLauncherDataBufferSize;\n+\n+    if (!h) {\n+        return 0;\n+    }\n+\n+    jvmLauncherDataBufferSize = jvmLauncherGetJvmlLauncherDataSize(api, h);\n+    if (jvmLauncherDataBufferSize <= 0) {\n+        goto cleanup;\n+    }\n+\n+    buf = malloc(jvmLauncherDataBufferSize);\n+    if (!buf) {\n+        JP_LOG_ERRNO;\n+        goto cleanup;\n+    }\n+\n+    result = jvmLauncherInitJvmlLauncherData(api, h, buf,\n+                                                jvmLauncherDataBufferSize);\n+    if (result) {\n+        \/* Don't free the buffer in clean up. *\/\n+        buf = 0;\n+    }\n+\n+cleanup:\n+    jvmLauncherCloseHandle(api, h);\n+    free(buf);\n+\n+    return result;\n+}\n+\n+\n+static void dumpJvmlLauncherData(const JvmlLauncherData* jvmArgs) {\n+    int i = 0;\n+    JP_LOG_TRACE(\"jli lib: [%s]\", jvmArgs->jliLibPath);\n+    for (i = 0; i < jvmArgs->jliLaunchArgc; ++i) {\n+        JP_LOG_TRACE(\"jli arg[%d]: [%s]\", i, jvmArgs->jliLaunchArgv[i]);\n+    }\n+}\n+\n+\n+int jvmLauncherStartJvm(JvmlLauncherData* jvmArgs, void* JLI_Launch) {\n+    int exitCode;\n+\n+    dumpJvmlLauncherData(jvmArgs);\n+    exitCode = (*((JLI_LaunchFuncType)JLI_Launch))(\n+        jvmArgs->jliLaunchArgc, jvmArgs->jliLaunchArgv,\n+        0, 0,\n+        0, 0,\n+        \"\",\n+        \"\",\n+        \"java\",\n+        \"java\",\n+        JNI_FALSE,\n+        JNI_FALSE,\n+        JNI_FALSE,\n+        0);\n+\n+    return exitCode;\n+}\n+\n+\n+void jvmLauncherLog(const char* format, ...) {\n+    const char *withLog = getenv(\"JPACKAGE_DEBUG\");\n+    if (!withLog || strcmp(withLog, \"true\")) {\n+        return;\n+    }\n+\n+    va_list args;\n+    va_start(args, format);\n+\n+#if defined(__GNUC__) && __GNUC__ >= 5\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    vfprintf(stderr, format, args);\n+    fprintf(stderr, \"\\n\");\n+#if defined(__GNUC__) && __GNUC__ >= 5\n+#pragma GCC diagnostic pop\n+#endif\n+\n+    va_end (args);\n+}\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/JvmLauncherLib.c","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"kludge_c++11.h\"\n+\n@@ -59,0 +61,2 @@\n+    ResetLastErrorMsgAtEndOfScope() {\n+    }\n","filename":"src\/jdk.jpackage\/share\/native\/common\/app.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#ifdef __GNUC__\n+#if defined(__GNUC__) && __GNUC__ >= 5\n@@ -61,1 +61,1 @@\n-#ifdef __GNUC__\n+#if defined(__GNUC__) && __GNUC__ >= 5\n","filename":"src\/jdk.jpackage\/share\/native\/common\/tstrings.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}