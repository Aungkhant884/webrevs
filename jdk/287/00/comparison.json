{"files":[{"patch":"@@ -85,1 +85,6 @@\n-                if (e.lastError() != ERROR_DIR_NOT_ROOT)\n+                \/\/ GetVolumePathName might return the following error codes\n+                \/\/ when the drives were created using `subst`.\n+                \/\/ Try expanding the path again in such cases.\n+                if (e.lastError() != ERROR_DIR_NOT_ROOT &&\n+                    e.lastError() != ERROR_INVALID_PARAMETER &&\n+                    e.lastError() != ERROR_DIRECTORY)\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileStore.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.ProcessBuilder;\n+\n+import java.util.Map;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.io.PrintStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import java.nio.file.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/* @test\n+ * @summary Test Files' public APIs with drives created using the subst command on Windows.\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib ..\n+ * @build SubstDrive\n+ * @run testng SubstDrive\n+ *\/\n+public class SubstDrive {\n+\n+    private static final Path SUBST_DRIVE = Path.of(\"X:\");\n+    private static Path TEST_TEMP_FOLDER;\n+\n+    \/**\n+     * Create a temporary directory where all subsequently created temp\n+     * directories will be in. This folder and all of its contents will be\n+     * deleted when the test finishes.\n+     *\/\n+    @BeforeTest\n+    public void createRootTempDirectory() throws IOException {\n+        TEST_TEMP_FOLDER = TestUtil.createTemporaryDirectory();\n+        System.out.printf(\"Test folder is at %s\\n\", TEST_TEMP_FOLDER);\n+    }\n+\n+    \/**\n+     * Delete the root temporary directory together with all of its contents\n+     * when all tests finish.\n+     *\/\n+    @AfterTest\n+    public void removeRootTempDirectory() throws IOException {\n+        TestUtil.removeAll(TEST_TEMP_FOLDER);\n+    }\n+\n+    \/**\n+     * Each test method maps drive `SUBST_DRIVE` to a temporary folder,\n+     * unmap the drive after every test so that subsequent ones can reuse\n+     * the drive.\n+     *\/\n+    @AfterMethod\n+    public void deleteSubstDrive() throws IOException {\n+        Stream<String> substitutedDrives = substList();\n+        \/\/ Only delete `SUBST_DRIVE` if it is currently being substituted\n+        if (substitutedDrives.anyMatch(e -> e.contains(SUBST_DRIVE.toString()))) {\n+            substDelete(SUBST_DRIVE);\n+        }\n+    }\n+\n+    \/**\n+     * Test whether files can be created in the substituted drive.\n+     *\/\n+    @Test\n+    public void testCreateAndDeleteFile() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        String fileContents = \"Hello world!\";\n+        Path p = Path.of(SUBST_DRIVE.toString(), \"testFile.txt\");\n+        Files.createFile(p);\n+\n+        Assert.assertTrue(Files.exists(p));\n+\n+        Files.writeString(p, fileContents);\n+        Assert.assertEquals(Files.readString(p), fileContents);\n+    }\n+\n+    \/**\n+     * Test if we can delete the substituted drive (essentially just a folder).\n+     *\/\n+    @Test\n+    public void testDeleteSubstitutedDrive() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Assert.assertTrue(Files.exists(tempDirectory));\n+        Files.delete(SUBST_DRIVE);\n+        Assert.assertTrue(Files.notExists(tempDirectory));\n+    }\n+\n+    \/**\n+     * Test if the attributes returned by the Files' APIs are consistent when\n+     * using the actual path and the substituted path.\n+     *\/\n+    @Test\n+    public void testAttributes() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Assert.assertTrue(Files.isSameFile(tempDirectory, SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isExecutable(tempDirectory),\n+            Files.isExecutable(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isReadable(tempDirectory),\n+            Files.isReadable(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isDirectory(tempDirectory),\n+            Files.isDirectory(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isHidden(tempDirectory),\n+            Files.isHidden(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isRegularFile(tempDirectory),\n+            Files.isRegularFile(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isSymbolicLink(tempDirectory),\n+            Files.isSymbolicLink(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.getOwner(tempDirectory),\n+            Files.getOwner(SUBST_DRIVE));\n+\n+        Assert.assertEquals(\n+            Files.isWritable(tempDirectory),\n+            Files.isWritable(SUBST_DRIVE));\n+    }\n+\n+    \/**\n+     * Test if setting attributes for a substituted path works the same way\n+     * as it would for a real path.\n+     *\/\n+    @Test\n+    public void testGetSetAttributes() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Files.setAttribute(SUBST_DRIVE, \"dos:hidden\", true);\n+        Assert.assertTrue(Files.isHidden(SUBST_DRIVE));\n+        Assert.assertTrue(Files.isHidden(tempDirectory));\n+\n+        Files.setAttribute(tempDirectory, \"dos:hidden\", false);\n+        Assert.assertFalse(Files.isHidden(SUBST_DRIVE));\n+        Assert.assertFalse(Files.isHidden(tempDirectory));\n+\n+        Map<String, Object> attr1 = Files.readAttributes(SUBST_DRIVE, \"*\");\n+        Map<String, Object> attr2 = Files.readAttributes(tempDirectory, \"*\");\n+        Assert.assertEquals(attr1, attr2);\n+    }\n+\n+    \/**\n+     * Test if the FileStores returned from using substituted path and real path\n+     * are the same.\n+     *\/\n+    @Test\n+    public void testFileStore() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        FileStore fileStore1 = Files.getFileStore(tempDirectory);\n+        FileStore fileStore2 = Files.getFileStore(SUBST_DRIVE);\n+\n+        Assert.assertEquals(\n+            fileStore1.getTotalSpace(),\n+            fileStore2.getTotalSpace());\n+\n+        Assert.assertEquals(\n+            fileStore1.getBlockSize(),\n+            fileStore2.getBlockSize());\n+\n+        Assert.assertEquals(\n+            fileStore1.getUnallocatedSpace(),\n+            fileStore2.getUnallocatedSpace());\n+\n+        Assert.assertEquals(\n+            fileStore1.getUsableSpace(),\n+            fileStore2.getUsableSpace());\n+\n+        Assert.assertEquals(\n+            fileStore1.name(),\n+            fileStore2.name());\n+\n+        Assert.assertEquals(\n+            fileStore1.type(),\n+            fileStore2.type());\n+\n+        Assert.assertEquals(\n+            SUBST_DRIVE.getFileSystem().getRootDirectories(),\n+            tempDirectory.getFileSystem().getRootDirectories());\n+    }\n+\n+    \/**\n+     * Test if Files.copy works correctly on a substituted drive, and that\n+     * all of the attributes are the same.\n+     *\/\n+    @Test\n+    public void testMoveAndCopySubstDrive() throws IOException {\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        Path tempDirectoryCopy = Path.of(tempDirectory.toString() + \"_copy\");\n+\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Files.copy(SUBST_DRIVE, tempDirectoryCopy);\n+\n+        Assert.assertEquals(\n+            Files.isExecutable(SUBST_DRIVE),\n+            Files.isExecutable(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.isReadable(SUBST_DRIVE),\n+            Files.isReadable(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.isDirectory(SUBST_DRIVE),\n+            Files.isDirectory(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.isHidden(SUBST_DRIVE),\n+            Files.isHidden(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.isRegularFile(SUBST_DRIVE),\n+            Files.isRegularFile(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.isWritable(SUBST_DRIVE),\n+            Files.isWritable(tempDirectoryCopy));\n+\n+        Assert.assertEquals(\n+            Files.getOwner(SUBST_DRIVE),\n+            Files.getOwner(tempDirectoryCopy));\n+    }\n+\n+    \/**\n+     * Test if .toRealPath() works consistently when both the resolved symlink\n+     * and its target are in the same substituted drive.\n+     * https:\/\/bugs.openjdk.java.net\/browse\/JDK-8213216\n+     * Note: requires administrator privileges.\n+     *\/\n+    @Test\n+    public void testRealPath() throws IOException {\n+        if (!TestUtil.supportsLinks(TEST_TEMP_FOLDER)) {\n+            return;\n+        }\n+\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Path substDir = Files.createDirectory(SUBST_DRIVE.resolve(\"folder\"));\n+        Path dir = tempDirectory.resolve(\"folder\");\n+\n+        Path substFile = Files.createFile(substDir.resolve(\"foo\"));\n+        Path substLink = substDir.resolve(\"link\");\n+\n+        Path file = dir.resolve(\"foo\");\n+        Path link = dir.resolve(\"link\");\n+\n+        Files.createSymbolicLink(substLink, substFile.toAbsolutePath());\n+\n+        Assert.assertEquals(file.toRealPath(), link.toRealPath());\n+        Assert.assertEquals(substFile.toRealPath(), substLink.toRealPath());\n+    }\n+\n+    \/**\n+     * Test if the attributes of a resolved symlink are the same as its target's\n+     * Note: requires administrator privileges.\n+     *\/\n+    @Test\n+    public void testGetResolvedSymlinkAttribute() throws IOException {\n+        if (!TestUtil.supportsLinks(TEST_TEMP_FOLDER)) {\n+            return;\n+        }\n+\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        substCreate(SUBST_DRIVE, tempDirectory);\n+\n+        Path tempFile = Path.of(SUBST_DRIVE.toString(), \"test.txt\");\n+        String contents = \"Hello world!\";\n+        Files.writeString(tempFile, contents);\n+        Assert.assertEquals(Files.readString(tempFile), contents);\n+\n+        Path link = Path.of(SUBST_DRIVE.toString(), \"link\");\n+        Files.createSymbolicLink(link, tempFile);\n+\n+        Assert.assertEquals(Files.readString(link), contents);\n+        Assert.assertEquals(Files.isExecutable(link), Files.isExecutable(tempFile));\n+        Assert.assertEquals(Files.isReadable(link), Files.isReadable(tempFile));\n+        Assert.assertEquals(Files.isDirectory(link), Files.isDirectory(tempFile));\n+        Assert.assertEquals(Files.isHidden(link), Files.isHidden(tempFile));\n+        Assert.assertEquals(Files.isRegularFile(link), Files.isRegularFile(tempFile));\n+        Assert.assertEquals(Files.isWritable(link), Files.isWritable(tempFile));\n+        Assert.assertEquals(Files.getOwner(link), Files.getOwner(tempFile));\n+    }\n+\n+    \/**\n+     * Test if files and folders can be created, moved, and cut when the\n+     * substituted drive is a symlink.\n+     * Note: requires administrator privileges.\n+     *\/\n+    @Test\n+    public void testSubstWithSymlinkedFolder() throws IOException {\n+        if (!TestUtil.supportsLinks(TEST_TEMP_FOLDER)) {\n+            return;\n+        }\n+\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        Path tempLink = Path.of(tempDirectory.toString() + \"_link\");\n+        Files.createSymbolicLink(tempLink, tempDirectory);\n+\n+        substCreate(SUBST_DRIVE, tempLink);\n+\n+        Assert.assertEquals(\n+            Files.readAttributes(SUBST_DRIVE, \"*\"),\n+            Files.readAttributes(tempDirectory, \"*\"));\n+\n+        Assert.assertTrue(Files.isWritable(SUBST_DRIVE));\n+\n+        Path tempFile = Files.createTempFile(SUBST_DRIVE, \"prefix\", \"suffix\");\n+        String contents = \"Hello world!\";\n+        Files.writeString(tempFile, contents);\n+        Assert.assertEquals(Files.readString(tempFile), contents);\n+\n+        Path tempDirectory2 = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        Path copy = Path.of(tempDirectory2.toString(), \"copied\");\n+        Files.copy(tempFile, copy);\n+\n+        Assert.assertTrue(Files.exists(copy));\n+        Assert.assertEquals(Files.readString(copy), contents);\n+\n+        Path cut = Path.of(tempDirectory2.toString(), \"cut\");\n+        Files.move(tempFile, cut);\n+        Assert.assertTrue(Files.notExists(tempFile));\n+        Assert.assertTrue(Files.exists(cut));\n+        Assert.assertEquals(Files.readString(cut), contents);\n+    }\n+\n+    \/**\n+     * When the substituted drive is a symlink, test if it has the same\n+     * attributes as its target.\n+     * Note: requires administrator privileges.\n+     *\/\n+    @Test\n+    public void testMoveAndCopyFilesToSymlinkedDrive() throws IOException {\n+        if (!TestUtil.supportsLinks(TEST_TEMP_FOLDER)) {\n+            return;\n+        }\n+\n+        Path tempDirectory = TestUtil.createTemporaryDirectory(TEST_TEMP_FOLDER);\n+        Path tempLink = Path.of(tempDirectory.toString() + \"_link\");\n+        Files.createSymbolicLink(tempLink, tempDirectory);\n+\n+        substCreate(SUBST_DRIVE, tempLink);\n+\n+        Assert.assertEquals(\n+            Files.readAttributes(SUBST_DRIVE, \"*\"),\n+            Files.readAttributes(tempDirectory, \"*\"));\n+\n+        Assert.assertTrue(Files.isWritable(SUBST_DRIVE));\n+    }\n+\n+    \/**\n+     * Run a command and optionally prints stdout contents to\n+     * `customOutputStream`.\n+     *\/\n+    private void runCmd(ProcessBuilder pb, PrintStream customOutputStream) {\n+        try {\n+            PrintStream ps = customOutputStream != null ?\n+                                    customOutputStream :\n+                                    System.out;\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(pb)\n+                                            .outputTo(ps)\n+                                            .errorTo(System.err);\n+\n+            int exitCode = outputAnalyzer.getExitValue();\n+            Assert.assertEquals(\n+                exitCode \/* actual value *\/,\n+                0        \/* expected value *\/,\n+                String.format(\n+                    \"Command `%s` failed with exit code %d\",\n+                    pb.command(),\n+                    exitCode\n+                )\n+            );\n+\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    \/**\n+     * Helper to map a path to a drive letter using subst.\n+     * For reference, see:\n+     * https:\/\/docs.microsoft.com\/en-us\/windows-server\/administration\/windows-commands\/subst\n+     *\/\n+    private void substCreate(Path drive, Path path) {\n+        runCmd(\n+            new ProcessBuilder(\n+                \"cmd\", \"\/c\", \"subst\", drive.toString(), path.toString()),\n+            null \/* customOutputStream *\/);\n+    }\n+\n+    \/**\n+     * Delete a drive mapping using subst.\n+     * For reference, see:\n+     * https:\/\/docs.microsoft.com\/en-us\/windows-server\/administration\/windows-commands\/subst\n+     *\/\n+    private void substDelete(Path drive) throws IOException {\n+        runCmd(\n+            new ProcessBuilder(\n+                \"cmd\", \"\/c\", \"subst\", drive.toString(), \"\/D\"),\n+            null \/* customOutputStream *\/);\n+    }\n+\n+    \/**\n+     * Return a list of strings that represents all the currently mapped drives.\n+     * For instance, with the following output of subst:\n+     *      A:\\: => path1\n+     *      B:\\: => path2\n+     *      T:\\: => path3\n+     *      X:\\: => path4\n+     * The function returns: [\"A:\\\", \"B:\\\", \"T:\\\", \"X:\\\"]\n+     * For reference, see:\n+     * https:\/\/docs.microsoft.com\/en-us\/windows-server\/administration\/windows-commands\/subst\n+     *\/\n+    private Stream<String> substList() throws UnsupportedEncodingException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        String utf8 = StandardCharsets.UTF_8.name();\n+        try (PrintStream ps = new PrintStream(baos, true, utf8)) {\n+            \/\/ subst without any arguments returns a list of drives that\n+            \/\/ are being substituted\n+            runCmd(new ProcessBuilder(\"cmd\", \"\/c\", \"subst\"), ps);\n+            String stdout = baos.toString(utf8);\n+            return stdout\n+                    \/\/ split lines\n+                    .lines()\n+                    \/\/ only examine lines with \"=>\"\n+                    .filter(line -> line.contains(\"=>\"))\n+                    \/\/ split each line into 2 components and take the first one\n+                    .map(line -> line.split(\"=>\")[0].trim());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/SubstDrive.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -33,0 +33,4 @@\n+    static Path createTemporaryDirectory(Path where) throws IOException {\n+        return Files.createTempDirectory(where, \"name\");\n+    }\n+\n@@ -35,1 +39,1 @@\n-        return Files.createTempDirectory(dir, \"name\");\n+        return createTemporaryDirectory(dir);\n","filename":"test\/jdk\/java\/nio\/file\/TestUtil.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}