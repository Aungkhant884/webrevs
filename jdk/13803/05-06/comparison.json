{"files":[{"patch":"@@ -65,1 +65,0 @@\n-                || !TokenStorage.initSuccessful()\n@@ -108,1 +107,1 @@\n-        List<Rectangle> affectedScreenBounds =  getSystemScreensBounds()\n+        List<Rectangle> affectedScreenBounds = getSystemScreensBounds()\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -5,1 +30,0 @@\n-import java.io.Serializable;\n@@ -7,0 +31,1 @@\n+import java.util.Arrays;\n@@ -11,2 +36,1 @@\n-final class TokenItem implements Serializable {\n-    static final long serialVersionUID = -289029960632065531L;\n+import static sun.awt.screencast.ScreencastHelper.SCREENCAST_DEBUG;\n@@ -14,0 +38,1 @@\n+final class TokenItem {\n@@ -15,1 +40,1 @@\n-    ArrayList<Rectangle> allowedScreensBounds;\n+    List<Rectangle> allowedScreensBounds;\n@@ -18,0 +43,3 @@\n+        if (token == null || token.isBlank()) {\n+            throw new RuntimeException(\"empty or null tokens are not allowed\");\n+        }\n@@ -24,2 +52,1 @@\n-        this.allowedScreensBounds =\n-                (ArrayList<Rectangle>) IntStream\n+        this.allowedScreensBounds = IntStream\n@@ -57,0 +84,51 @@\n+    private static final int MAX_SIZE = 50000;\n+    private static final int MIN_SIZE = 1;\n+\n+    public boolean hasValidBounds() {\n+        \/\/This check is very formal, in order to filter out abnormal values\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            if (bounds.x < -MAX_SIZE || bounds.x > MAX_SIZE\n+                    || bounds.y < -MAX_SIZE || bounds.y > MAX_SIZE\n+                    || bounds.width < MIN_SIZE || bounds.width > MAX_SIZE\n+                    || bounds.height < MIN_SIZE || bounds.height > MAX_SIZE\n+            ) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String dump() {\n+        StringBuilder sb = new StringBuilder();\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            sb.append(\"_%d_%d_%d_%d\"\n+                    .formatted(bounds.x, bounds.y, bounds.width, bounds.height));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static TokenItem parse(String token, Object input) {\n+        if (token == null || input == null) return null;\n+\n+        try {\n+            int[] integers = Arrays.stream(String.valueOf(input)\n+                    .split(\"_\"))\n+                    .filter(s -> !s.isBlank())\n+                    .mapToInt(Integer::parseInt)\n+                    .toArray();\n+\n+            if (integers.length % 4 == 0) {\n+                TokenItem tokenItem = new TokenItem(token, integers);\n+                if (tokenItem.hasValidBounds()) {\n+                    return tokenItem;\n+                }\n+            }\n+        } catch (NumberFormatException ignored) {}\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.err.printf(\"Malformed record for token %s: %s\\n\",\n+                    token, input);\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenItem.java","additions":84,"deletions":6,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n@@ -5,2 +30,0 @@\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n@@ -8,2 +31,9 @@\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.PosixFilePermission;\n@@ -14,0 +44,3 @@\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n@@ -15,2 +48,0 @@\n-import java.util.prefs.BackingStoreException;\n-import java.util.prefs.Preferences;\n@@ -19,0 +50,4 @@\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+import static java.nio.file.StandardWatchEventKinds.OVERFLOW;\n@@ -22,2 +57,0 @@\n-    private TokenStorage() {\n-    }\n@@ -25,1 +58,9 @@\n-    private static final Preferences TOKEN_STORE;\n+    private TokenStorage() {}\n+\n+    private static final String REL_NAME =\n+            \".java\/.robot\/screencast-tokens.properties\";\n+\n+    private static final Properties PROPS = new Properties();\n+    private static final Path PROPS_PATH;\n+    private static final Path PROP_FILENAME;\n+    private static final Object PROPS_LOCK = new Object();\n@@ -28,1 +69,39 @@\n-        Preferences tokenStore;\n+        PROPS_PATH = setupPath();\n+        if (PROPS_PATH != null) {\n+            PROP_FILENAME = PROPS_PATH.getFileName();\n+            setupWatch();\n+        } else {\n+            \/\/ We can still work with tokens,\n+            \/\/ but they are not saved between sessions.\n+            PROP_FILENAME = null;\n+        }\n+    }\n+\n+    private static Path setupPath() {\n+        String userHome = System.getProperty(\"user.home\", null);\n+        if (userHome == null) {\n+            return null;\n+        }\n+\n+        Path path = Path.of(userHome, REL_NAME);\n+        Path workdir = path.getParent();\n+\n+        if (!Files.exists(workdir)) {\n+            try {\n+                Files.createDirectories(workdir);\n+            } catch (Exception e) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: cannot create\" +\n+                                    \" directory %s %s\\n\", workdir, e);\n+                }\n+                return null;\n+            }\n+        }\n+\n+        if (!Files.isWritable(workdir)) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+            }\n+            return null;\n+        }\n+\n@@ -30,6 +109,11 @@\n-            tokenStore = Preferences\n-                    .userNodeForPackage(ScreencastHelper.class)\n-                    .node(\"tokenStorage\");\n-        } catch (Exception e) {\n-            System.err.println(\"Failed to initialize token storage\");\n-            tokenStore = null;\n+            Files.setPosixFilePermissions(workdir,\n+                    Set.of(\n+                            PosixFilePermission.OWNER_READ,\n+                            PosixFilePermission.OWNER_WRITE,\n+                            PosixFilePermission.OWNER_EXECUTE\n+                    ));\n+        } catch (IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: cannot set permissions \" +\n+                        \"for directory %s %s\\n\", workdir, e);\n+            }\n@@ -38,1 +122,79 @@\n-        TOKEN_STORE = tokenStore;\n+        if (Files.exists(path)) {\n+            if (!setFilePermission(path)) {\n+                return null;\n+            }\n+\n+            readTokens(path);\n+        }\n+\n+        return path;\n+    }\n+\n+    private static boolean setFilePermission(Path path) {\n+        try {\n+            Files.setPosixFilePermissions(\n+                    path,\n+                    Set.of(PosixFilePermission.OWNER_READ,\n+                            PosixFilePermission.OWNER_WRITE)\n+            );\n+            return true;\n+        } catch (IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: failed to set \" +\n+                        \"property file permission %s %s\\n\", path, e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static class WatcherThread extends Thread {\n+        private final WatchService watcher;\n+\n+        public WatcherThread(WatchService watchService) {\n+            this.watcher = watchService;\n+            setName(\"ScreencastWatcher\");\n+            setDaemon(true);\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"ScreencastWatcher: started\");\n+            }\n+            for (;;) {\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException e) {\n+                    if (SCREENCAST_DEBUG) {\n+                        System.err.println(\"ScreencastWatcher: interrupted\");\n+                    }\n+                    return;\n+                }\n+\n+                for (WatchEvent<?> event: key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+                    if (kind == OVERFLOW\n+                            || !event.context().equals(PROP_FILENAME)) {\n+                        continue;\n+                    }\n+\n+                    if (SCREENCAST_DEBUG) {\n+                        System.out.printf(\"ScreencastWatcher: %s %s\\n\",\n+                                kind, event.context());\n+                    }\n+\n+                    if (kind == ENTRY_CREATE) {\n+                        setFilePermission(PROPS_PATH);\n+                    } else if (kind == ENTRY_MODIFY) {\n+                        readTokens(PROPS_PATH);\n+                    } else if (kind == ENTRY_DELETE) {\n+                        synchronized (PROPS_LOCK) {\n+                            PROPS.clear();\n+                        }\n+                    }\n+                }\n+\n+                key.reset();\n+            }\n+        }\n@@ -41,0 +203,11 @@\n+    private static void setupWatch() {\n+        try {\n+            WatchService watchService =\n+                    FileSystems.getDefault().newWatchService();\n+\n+            PROPS_PATH\n+                    .getParent()\n+                    .register(watchService,\n+                            ENTRY_CREATE,\n+                            ENTRY_DELETE,\n+                            ENTRY_MODIFY);\n@@ -42,2 +215,7 @@\n-    static boolean initSuccessful() {\n-        return TOKEN_STORE != null;\n+            new WatcherThread(watchService).start();\n+        } catch (Exception e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.printf(\"Token storage: failed to setup \" +\n+                        \"file watch %s\\n\", e);\n+            }\n+        }\n@@ -59,12 +237,1 @@\n-        storeToken(new TokenItem(newToken, allowedScreenBounds));\n-\n-        if (oldToken != null && !oldToken.equals(newToken)) {\n-            \/\/ old token is no longer valid\n-            if (SCREENCAST_DEBUG) {\n-                System.out.printf(\n-                        \"\/\/ storeTokenFromNative old token |%s| is \"\n-                        + \"no longer valid, removing\\n\", oldToken);\n-            }\n-            TOKEN_STORE.remove(oldToken);\n-        }\n-    }\n+        TokenItem tokenItem = new TokenItem(newToken, allowedScreenBounds);\n@@ -72,1 +239,0 @@\n-    private static void storeToken(TokenItem tokenItem) {\n@@ -74,1 +240,1 @@\n-            System.out.printf(\"Storing TokenItem:\\n%s\\n\", tokenItem);\n+            System.out.printf(\"\/\/ Storing TokenItem:\\n%s\\n\", tokenItem);\n@@ -77,9 +243,14 @@\n-        try {\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            ObjectOutputStream out = new ObjectOutputStream(bos);\n-            out.writeObject(tokenItem);\n-            TOKEN_STORE.putByteArray(tokenItem.token, bos.toByteArray());\n-            TOKEN_STORE.flush();\n-        } catch (IOException | BackingStoreException e) {\n-            if (SCREENCAST_DEBUG) {\n-                System.err.println(e);\n+        synchronized (PROPS_LOCK) {\n+            String oldBoundsRecord = PROPS.getProperty(tokenItem.token, null);\n+            String newBoundsRecord = tokenItem.dump();\n+\n+            boolean changed = false;\n+\n+            if (oldBoundsRecord == null\n+                    || !oldBoundsRecord.equals(newBoundsRecord)) {\n+                PROPS.setProperty(tokenItem.token, newBoundsRecord);\n+                if (SCREENCAST_DEBUG) {\n+                    System.out.printf(\n+                            \"\/\/ Writing new TokenItem:\\n%s\\n\", tokenItem);\n+                }\n+                changed = true;\n@@ -87,2 +258,0 @@\n-        }\n-    }\n@@ -90,10 +259,2 @@\n-    private static TokenItem readToken(String token) {\n-        byte[] bytes = TOKEN_STORE.getByteArray(token, null);\n-        if (bytes == null) {\n-            return null;\n-        }\n-        try {\n-            ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-            ObjectInputStream in = new ObjectInputStream(bis);\n-            Object o = in.readObject();\n-            if (o instanceof TokenItem t) {\n+            if (oldToken != null && !oldToken.equals(newToken)) {\n+                \/\/ old token is no longer valid\n@@ -101,1 +262,3 @@\n-                    System.out.printf(\"TokenItem read:\\n%s\\n\", t);\n+                    System.out.printf(\n+                            \"\/\/ storeTokenFromNative old token |%s| is \"\n+                                    + \"no longer valid, removing\\n\", oldToken);\n@@ -103,1 +266,7 @@\n-                return t;\n+\n+                PROPS.remove(oldToken);\n+                changed = true;\n+            }\n+\n+            if (changed) {\n+                store(\"save tokens\");\n@@ -105,1 +274,12 @@\n-        } catch (ClassNotFoundException | IOException e) {\n+        }\n+    }\n+\n+    private static boolean readTokens(Path path) {\n+        if (path == null) return false;\n+\n+        try (InputStream input = Files.newInputStream(path)) {\n+            synchronized (PROPS_LOCK) {\n+                PROPS.clear();\n+                PROPS.load(input);\n+            }\n+        } catch (IOException e) {\n@@ -107,1 +287,4 @@\n-                System.err.println(e);\n+                System.err.printf(\"\"\"\n+                        Token storage: failed to load property file %s\n+                        %s\n+                        \"\"\", path, e);\n@@ -109,0 +292,1 @@\n+            return false;\n@@ -110,1 +294,2 @@\n-        return null;\n+\n+        return true;\n@@ -114,1 +299,2 @@\n-        \/\/ We need an ordered set to store tokens with exact matches at the beginning.\n+        \/\/ We need an ordered set to store tokens\n+        \/\/ with exact matches at the beginning.\n@@ -116,2 +302,0 @@\n-        try {\n-            TOKEN_STORE.sync();\n@@ -119,4 +303,6 @@\n-            List<TokenItem> allTokenItems =\n-                    Arrays.stream(TOKEN_STORE.keys())\n-                            .map(TokenStorage::readToken)\n-                            .toList();\n+        Set<Map.Entry<Object, Object>> entries;\n+        synchronized (PROPS_LOCK) {\n+            entries = PROPS.entrySet();\n+        }\n+\n+        Set<String> malformed = new LinkedHashSet<>();\n@@ -124,0 +310,13 @@\n+        List<TokenItem> allTokenItems = entries\n+                .stream()\n+                .map(o -> {\n+                    String token = String.valueOf(o.getKey());\n+                    TokenItem tokenItem =\n+                            TokenItem.parse(token, o.getValue());\n+                    if (tokenItem == null) {\n+                        malformed.add(token);\n+                    }\n+                    return tokenItem;\n+                })\n+                .filter(obj -> !Objects.isNull(obj))\n+                .toList();\n@@ -125,7 +324,8 @@\n-            \/\/ 1. Try to find exact matches\n-            for (TokenItem tokenItem : allTokenItems) {\n-                if (tokenItem != null\n-                        && tokenItem\n-                        .hasAllScreensWithExactMatch(affectedScreenBounds)) {\n-                    result.add(tokenItem);\n-                }\n+        removeMalformedRecords(malformed);\n+\n+        \/\/ 1. Try to find exact matches\n+        for (TokenItem tokenItem : allTokenItems) {\n+            if (tokenItem != null\n+                    && tokenItem\n+                    .hasAllScreensWithExactMatch(affectedScreenBounds)) {\n+                result.add(tokenItem);\n@@ -133,0 +333,1 @@\n+        }\n@@ -134,2 +335,18 @@\n-            if (SCREENCAST_DEBUG) {\n-                System.out.println(\"\/\/ getTokens exact matches 1. \" + result);\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getTokens exact matches 1. \" + result);\n+        }\n+\n+        \/\/ 2. Try screens of the same size but in different locations,\n+        \/\/ screens may have been moved while the token is still valid\n+        List<Dimension> dimensions = affectedScreenBounds\n+                .stream()\n+                .map(rectangle -> new Dimension(\n+                        rectangle.width,\n+                        rectangle.height\n+                ))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+\n+        for (TokenItem tokenItem : allTokenItems) {\n+            if (tokenItem != null\n+                    && tokenItem.hasAllScreensOfSameSize(dimensions)) {\n+                result.add(tokenItem);\n@@ -137,0 +354,5 @@\n+        }\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getTokens same sizes 2. \" + result);\n+        }\n@@ -138,0 +360,2 @@\n+        return result;\n+    }\n@@ -139,9 +363,6 @@\n-            \/\/ 2. Try screens of the same size but in different locations,\n-            \/\/ screens may have been moved while the token is still valid\n-            List<Dimension> dimensions = affectedScreenBounds\n-                    .stream()\n-                    .map(rectangle -> new Dimension(\n-                            rectangle.width,\n-                            rectangle.height\n-                    ))\n-                    .collect(Collectors.toCollection(ArrayList::new));\n+    private static void removeMalformedRecords(Set<String> malformedRecords) {\n+        if (!isWritable()\n+                || malformedRecords == null\n+                || malformedRecords.isEmpty()) {\n+            return;\n+        }\n@@ -149,4 +370,5 @@\n-            for (TokenItem tokenItem : allTokenItems) {\n-                if (tokenItem != null\n-                        && tokenItem.hasAllScreensOfSameSize(dimensions)) {\n-                    result.add(tokenItem);\n+        synchronized (PROPS_LOCK) {\n+            for (String token : malformedRecords) {\n+                Object remove = PROPS.remove(token);\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.println(\"removing malformed record\\n\" + remove);\n@@ -156,0 +378,14 @@\n+            store(\"remove malformed records\");\n+        }\n+    }\n+\n+    private static void store(String failMsg) {\n+        if (!isWritable()) {\n+            return;\n+        }\n+\n+        try (OutputStream output = Files.newOutputStream(PROPS_PATH)) {\n+            synchronized (PROPS_LOCK) {\n+                PROPS.store(output, null);\n+            }\n+        } catch (IOException e) {\n@@ -157,1 +393,2 @@\n-                System.out.println(\"\/\/ getTokens same sizes 2. \" + result);\n+                System.err.printf(\n+                        \"Token storage: unable to %s\\n%s\\n\", failMsg, e);\n@@ -159,0 +396,2 @@\n+        }\n+    }\n@@ -160,2 +399,3 @@\n-            return result;\n-        } catch (BackingStoreException e) {\n+    private static boolean isWritable() {\n+        if (PROPS_PATH == null\n+                || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n@@ -163,1 +403,2 @@\n-                System.err.println(e);\n+                System.err.printf(\n+                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n@@ -165,0 +406,3 @@\n+            return false;\n+        } else {\n+            return true;\n@@ -166,1 +410,0 @@\n-        return Set.of();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":336,"deletions":93,"binary":false,"changes":429,"status":"modified"}]}