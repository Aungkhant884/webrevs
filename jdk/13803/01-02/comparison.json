{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -588,7 +588,0 @@\n-    \/**\n-     * placeholder\n-     *\/\n-    public void resetScreenCapturePermission() {\n-        peer.resetScreenCapturePermission();\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Robot.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,4 +131,0 @@\n-    \/**\n-     * placeholder\n-     *\/\n-    default void resetScreenCapturePermission() {}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/peer\/RobotPeer.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,7 +143,0 @@\n-    @Override\n-    public void resetScreenCapturePermission() {\n-        if (useScreencast && ScreencastHelper.isAvailable()) {\n-            ScreencastHelper.resetToken();\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XRobotPeer.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n@@ -6,1 +8,4 @@\n-import java.util.prefs.Preferences;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n@@ -11,2 +16,2 @@\n-    private static final boolean screencastDebug;\n-    private static final boolean isNativeLoaded;\n+    static final boolean SCREENCAST_DEBUG;\n+    private static final boolean IS_NATIVE_LOADED;\n@@ -14,3 +19,0 @@\n-    private static final Preferences TOKEN_STORE =\n-            Preferences.userNodeForPackage(ScreencastHelper.class);\n-    private static final String TOKEN_KEY = \"restoreToken\";\n@@ -18,1 +20,4 @@\n-    private ScreencastHelper() {}\n+    private static final int DENIED = -11;\n+\n+    private ScreencastHelper() {\n+    }\n@@ -21,1 +26,1 @@\n-        screencastDebug = Boolean.parseBoolean(\n+        SCREENCAST_DEBUG = Boolean.parseBoolean(\n@@ -29,2 +34,5 @@\n-        isNativeLoaded = loadPipewire(screencastDebug);\n-        if (!isNativeLoaded) {\n+        boolean loadFailed = false;\n+\n+        if (!TokenStorage.initSuccessful()\n+                || !loadPipewire(SCREENCAST_DEBUG)) {\n+\n@@ -34,0 +42,2 @@\n+\n+            loadFailed = true;\n@@ -35,0 +45,2 @@\n+\n+        IS_NATIVE_LOADED = !loadFailed;\n@@ -38,1 +50,1 @@\n-        return isNativeLoaded;\n+        return IS_NATIVE_LOADED;\n@@ -43,3 +55,6 @@\n-    public static void resetToken() {\n-        TOKEN_STORE.remove(TOKEN_KEY);\n-    }\n+    private static native int getRGBPixelsImpl(\n+            int x, int y, int width, int height,\n+            int[] pixelArray,\n+            int[] affectedScreensBoundsArray,\n+            String token\n+    );\n@@ -47,3 +62,8 @@\n-    \/\/ called from native\n-    private static void storeToken(String token) {\n-        TOKEN_STORE.put(TOKEN_KEY, token);\n+    private static List<Rectangle> getSystemScreensBounds() {\n+        return Arrays\n+                .stream(GraphicsEnvironment\n+                        .getLocalGraphicsEnvironment()\n+                        .getScreenDevices())\n+                .map(graphicsDevice ->\n+                        graphicsDevice.getDefaultConfiguration().getBounds()\n+                ).toList();\n@@ -52,3 +72,4 @@\n-    private static String getToken() {\n-        return TOKEN_STORE.get(TOKEN_KEY, null);\n-    }\n+    public static synchronized void getRGBPixels(\n+            int x, int y, int width, int height, int[] pixelArray\n+    ) {\n+        if (!IS_NATIVE_LOADED) return;\n@@ -56,1 +77,1 @@\n-    private static final int DENIED = -11;\n+        Rectangle captureArea = new Rectangle(x, y, width, height);\n@@ -58,3 +79,4 @@\n-    private static synchronized native int getRGBPixelsImpl(\n-            int x, int y, int width, int height, int[] pixelArray, String token\n-    );\n+        List<Rectangle> affectedScreenBounds =  getSystemScreensBounds()\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .toList();\n@@ -62,7 +84,49 @@\n-    public static void getRGBPixels(\n-            int x, int y, int width, int height, int[] pixelArray\n-    ) {\n-        if (isNativeLoaded\n-                && (DENIED\n-                == getRGBPixelsImpl(x, y, width, height, pixelArray, getToken()))\n-        ) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getRGBPixels affectedScreenBounds \"\n+                    + affectedScreenBounds);\n+        }\n+\n+        if (affectedScreenBounds.isEmpty()) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getRGBPixels - requested area \"\n+                        + \"outside of any screen\");\n+            }\n+            return;\n+        }\n+\n+        int retVal;\n+        Set<TokenItem> tokensForRectangle =\n+                TokenStorage.getTokens(affectedScreenBounds);\n+\n+        int[] affectedScreenBoundsArray = affectedScreenBounds\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .flatMapToInt(bounds -> IntStream.of(\n+                        bounds.x, bounds.y,\n+                        bounds.width, bounds.height\n+                ))\n+                .toArray();\n+\n+        for (TokenItem tokenItem : tokensForRectangle) {\n+            retVal = getRGBPixelsImpl(\n+                    x, y, width, height,\n+                    pixelArray,\n+                    affectedScreenBoundsArray,\n+                    tokenItem.token\n+            );\n+\n+            if (retVal >= 0) { \/\/ we have received a screen data\n+                return;\n+            }\n+        }\n+\n+        \/\/ we do not have a saved token or it did not work,\n+        \/\/ try without the token to show the system's permission request window\n+        retVal = getRGBPixelsImpl(\n+                x, y, width, height,\n+                pixelArray,\n+                affectedScreenBoundsArray,\n+                null\n+        );\n+\n+        if (retVal == DENIED) {\n@@ -70,1 +134,1 @@\n-                    \"User denied the screen data capture\"\n+                    \"Screen Capture in the selected area was not allowed\"\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":96,"deletions":32,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+final class TokenItem implements Serializable {\n+    static final long serialVersionUID = -289029960632065531L;\n+\n+    String token;\n+    ArrayList<Rectangle> allowedScreensBounds;\n+\n+    public TokenItem(String token, int[] allowedScreenBounds) {\n+        if (allowedScreenBounds.length % 4 != 0) {\n+            throw new RuntimeException(\"array with incorrect length provided\");\n+        }\n+\n+        this.token = token;\n+\n+        this.allowedScreensBounds =\n+                (ArrayList<Rectangle>) IntStream\n+                        .iterate(0,\n+                                i -> i < allowedScreenBounds.length,\n+                                i -> i + 4)\n+                        .mapToObj(i -> new Rectangle(\n+                                allowedScreenBounds[i], allowedScreenBounds[i+1],\n+                                allowedScreenBounds[i+2], allowedScreenBounds[i+3]\n+                        ))\n+                        .collect(Collectors.toList());\n+    }\n+\n+    public boolean hasAllScreensWithExactMatch(List<Rectangle> bounds) {\n+        return allowedScreensBounds.containsAll(bounds);\n+    }\n+\n+    public boolean hasAllScreensOfSameSize(List<Dimension> screenSizes) {\n+        \/\/ We also need to consider duplicates, since there may be\n+        \/\/ multiple screens of the same size.\n+        \/\/ The token item must also have at least the same number\n+        \/\/ of screens with that size.\n+\n+        List<Dimension> tokenSizes = allowedScreensBounds\n+                .stream()\n+                .map(bounds -> new Dimension(bounds.width, bounds.height))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+\n+        return screenSizes.size() == screenSizes\n+                .stream()\n+                .filter(tokenSizes::remove)\n+                .count();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"Token: \" + token + \"\\n\");\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            sb.append(\"\\t\").append(bounds).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenItem.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.prefs.BackingStoreException;\n+import java.util.prefs.Preferences;\n+import java.util.stream.Collectors;\n+\n+import static sun.awt.screencast.ScreencastHelper.SCREENCAST_DEBUG;\n+\n+final class TokenStorage {\n+    private TokenStorage() {\n+    }\n+\n+    private static final Preferences TOKEN_STORE;\n+\n+    static {\n+        Preferences tokenStore;\n+        try {\n+            tokenStore = Preferences\n+                    .userNodeForPackage(ScreencastHelper.class)\n+                    .node(\"tokenStorage\");\n+        } catch (Exception e) {\n+            System.err.println(\"Failed to initialize token storage\");\n+            tokenStore = null;\n+        }\n+\n+        TOKEN_STORE = tokenStore;\n+    }\n+\n+\n+    static boolean initSuccessful() {\n+        return TOKEN_STORE != null;\n+    }\n+\n+    \/\/ called from native\n+    private static void storeTokenFromNative(String oldToken,\n+                                             String newToken,\n+                                             int[] allowedScreenBounds) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"\/\/ storeToken old: |%s| new |%s| \" +\n+                            \"allowed bounds %s\\n\",\n+                    oldToken, newToken,\n+                    Arrays.toString(allowedScreenBounds));\n+        }\n+\n+        if (allowedScreenBounds == null) return;\n+\n+        storeToken(new TokenItem(newToken, allowedScreenBounds));\n+\n+        if (oldToken != null && !oldToken.equals(newToken)) {\n+            \/\/ old token is no longer valid\n+            if (SCREENCAST_DEBUG) {\n+                System.out.printf(\n+                        \"\/\/ storeTokenFromNative old token |%s| is \"\n+                        + \"no longer valid, removing\\n\", oldToken);\n+            }\n+            TOKEN_STORE.remove(oldToken);\n+        }\n+    }\n+\n+    private static void storeToken(TokenItem tokenItem) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"Storing TokenItem:\\n%s\\n\", tokenItem);\n+        }\n+\n+        try {\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(bos);\n+            out.writeObject(tokenItem);\n+            TOKEN_STORE.putByteArray(tokenItem.token, bos.toByteArray());\n+            TOKEN_STORE.flush();\n+        } catch (IOException | BackingStoreException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+    }\n+\n+    private static TokenItem readToken(String token) {\n+        byte[] bytes = TOKEN_STORE.getByteArray(token, null);\n+        if (bytes == null) {\n+            return null;\n+        }\n+        try {\n+            ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n+            ObjectInputStream in = new ObjectInputStream(bis);\n+            Object o = in.readObject();\n+            if (o instanceof TokenItem t) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.out.printf(\"TokenItem read:\\n%s\\n\", t);\n+                }\n+                return t;\n+            }\n+        } catch (ClassNotFoundException | IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+        \/\/ We need an ordered set to store tokens with exact matches at the beginning.\n+        LinkedHashSet<TokenItem> result = new LinkedHashSet<>();\n+        try {\n+            TOKEN_STORE.sync();\n+\n+            List<TokenItem> allTokenItems =\n+                    Arrays.stream(TOKEN_STORE.keys())\n+                            .map(TokenStorage::readToken)\n+                            .toList();\n+\n+\n+            \/\/ 1. Try to find exact matches\n+            for (TokenItem tokenItem : allTokenItems) {\n+                if (tokenItem != null\n+                        && tokenItem\n+                        .hasAllScreensWithExactMatch(affectedScreenBounds)) {\n+                    result.add(tokenItem);\n+                }\n+            }\n+\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getTokens exact matches 1. \" + result);\n+            }\n+\n+\n+            \/\/ 2. Try screens of the same size but in different locations,\n+            \/\/ screens may have been moved while the token is still valid\n+            List<Dimension> dimensions = affectedScreenBounds\n+                    .stream()\n+                    .map(rectangle -> new Dimension(\n+                            rectangle.width,\n+                            rectangle.height\n+                    ))\n+                    .collect(Collectors.toCollection(ArrayList::new));\n+\n+            for (TokenItem tokenItem : allTokenItems) {\n+                if (tokenItem != null\n+                        && tokenItem.hasAllScreensOfSameSize(dimensions)) {\n+                    result.add(tokenItem);\n+                }\n+            }\n+\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getTokens same sizes 2. \" + result);\n+            }\n+\n+            return result;\n+        } catch (BackingStoreException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+        return Set.of();\n+    }\n+}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"awt_p.h\"\n@@ -43,0 +42,5 @@\n+#define EXCEPTION_CHECK_DESCRIBE_CLEAR() if ((*env)->ExceptionCheck(env)) { \\\n+                                            (*env)->ExceptionDescribe(env); \\\n+                                            (*env)->ExceptionClear(env);    \\\n+                                         }\n+\n@@ -46,2 +50,1 @@\n-extern JavaVM *jvm;\n-jclass screencastHelperClass = NULL;\n+jclass tokenStorageClass = NULL;\n@@ -123,1 +126,3 @@\n-static gboolean initScreencast(const gchar *token) {\n+static gboolean initScreencast(const gchar *token,\n+                               GdkRectangle *affectedBounds,\n+                               gint affectedBoundsLength) {\n@@ -130,1 +135,3 @@\n-        || (pw.pwFd = getPipewireFd(token)) < 0) {\n+        || (pw.pwFd = getPipewireFd(token,\n+                                    affectedBounds,\n+                                    affectedBoundsLength)) < 0) {\n@@ -643,1 +650,2 @@\n-void storeRestoreToken(const gchar* token) {\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken) {\n+\n@@ -645,1 +653,1 @@\n-    DEBUG_SCREENCAST(\"saving token %s\\n\", token);\n+    DEBUG_SCREENCAST(\"saving token, old: |%s| > new: |%s|\\n\", oldToken, newToken);\n@@ -647,3 +655,7 @@\n-        jstring jtoken = (*env)->NewStringUTF(env, token);\n-        if ((*env)->ExceptionCheck(env)) {\n-            (*env)->ExceptionClear(env);\n+        jstring jOldToken = NULL;\n+        if (oldToken) {\n+            jOldToken = (*env)->NewStringUTF(env, oldToken);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!jOldToken) {\n+                return;\n+            }\n@@ -651,1 +663,4 @@\n-        if (!jtoken) {\n+        jstring jNewToken = (*env)->NewStringUTF(env, newToken);\n+        EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+        if (!jNewToken) {\n+            (*env)->DeleteLocalRef(env, jOldToken);\n@@ -654,5 +669,0 @@\n-        (*env)->CallStaticVoidMethod(env, screencastHelperClass,\n-                                     storeTokenMethodID, jtoken);\n-        if ((*env)->ExceptionCheck(env)) {\n-            (*env)->ExceptionClear(env);\n-        }\n@@ -660,1 +670,44 @@\n-        (*env)->DeleteLocalRef(env, jtoken);\n+        jintArray allowedBounds = NULL;\n+        if (screenSpace.screenCount > 0) {\n+            allowedBounds = (*env)->NewIntArray(env, screenSpace.screenCount*4);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!allowedBounds) {\n+                (*env)->ExceptionClear(env);\n+                return;\n+            }\n+            jint* elements = (*env)->GetIntArrayElements(env, allowedBounds, NULL);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!elements) {\n+                return;\n+            }\n+\n+            gboolean failed = false;\n+\n+            for (int i = 0; i < screenSpace.screenCount; ++i) {\n+                GdkRectangle bounds = screenSpace.screens[i].bounds;\n+                elements[4 * i] = bounds.x;\n+                elements[4 * i + 1] = bounds.y;\n+                elements[4 * i + 2] = bounds.width;\n+                elements[4 * i + 3] = bounds.height;\n+\n+                if ((*env)->ExceptionCheck(env)) {\n+                    (*env)->ExceptionDescribe(env);\n+                    (*env)->ExceptionClear(env);\n+                    failed = true;\n+                    break;\n+                }\n+            }\n+\n+            (*env)->ReleaseIntArrayElements(env, allowedBounds, elements, 0);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+\n+            if (!failed) {\n+                (*env)->CallStaticVoidMethod(env, tokenStorageClass,\n+                                             storeTokenMethodID,\n+                                             jOldToken, jNewToken,\n+                                             allowedBounds);\n+                EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            }\n+        }\n+        (*env)->DeleteLocalRef(env, jOldToken);\n+        (*env)->DeleteLocalRef(env, jNewToken);\n@@ -677,1 +730,1 @@\n-        return FALSE;\n+        return JNI_FALSE;\n@@ -679,2 +732,9 @@\n-    screencastHelperClass = (*env)->NewGlobalRef(env, cls);\n-    if (screencastHelperClass) {\n+\n+    tokenStorageClass = (*env)->FindClass(env, \"sun\/awt\/screencast\/TokenStorage\");\n+    if (!tokenStorageClass) {\n+        return JNI_FALSE;\n+    }\n+\n+    tokenStorageClass = (*env)->NewGlobalRef(env, tokenStorageClass);\n+\n+    if (tokenStorageClass) {\n@@ -683,3 +743,3 @@\n-                screencastHelperClass,\n-                \"storeToken\",\n-                \"(Ljava\/lang\/String;)V\"\n+                tokenStorageClass,\n+                \"storeTokenFromNative\",\n+                \"(Ljava\/lang\/String;Ljava\/lang\/String;[I)V\"\n@@ -687,0 +747,3 @@\n+        if (!storeTokenMethodID) {\n+            return JNI_FALSE;\n+        }\n@@ -688,2 +751,3 @@\n-        DEBUG_SCREENCAST(\"⚠ @@@ screencastHelperClass %p\\n\",\n-                         screencastHelperClass);\n+        DEBUG_SCREENCAST(\"⚠ @@@ tokenStorageClass %p\\n\",\n+                         tokenStorageClass);\n+        return JNI_FALSE;\n@@ -703,0 +767,26 @@\n+static void arrayToRectangles(JNIEnv *env,\n+                             jintArray boundsArray,\n+                             jint boundsLen,\n+                             GdkRectangle *out\n+) {\n+    if (!boundsArray) {\n+        return;\n+    }\n+\n+    jint * body = (*env)->GetIntArrayElements(env, boundsArray, 0);\n+    EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+    if (!body) {\n+        return;\n+    }\n+\n+    for (int i = 0; i < boundsLen; i += 4) {\n+        GdkRectangle screenBounds = {\n+                body[i], body[i + 1],\n+                body[i + 2], body[i + 3]\n+        };\n+        out[i \/ 4] = screenBounds;\n+    }\n+\n+    (*env)->ReleaseIntArrayElements(env, boundsArray, body, 0);\n+}\n+\n@@ -706,1 +796,1 @@\n- * Signature: (IIII[ILjava\/lang\/String;)I\n+ * Signature: (IIII[I[ILjava\/lang\/String;)I\n@@ -716,0 +806,1 @@\n+        jintArray affectedScreensBoundsArray,\n@@ -718,0 +809,17 @@\n+    jsize boundsLen = 0;\n+    gint affectedBoundsLength = 0;\n+    if (affectedScreensBoundsArray) {\n+        boundsLen = (*env)->GetArrayLength(env, affectedScreensBoundsArray);\n+        EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+        if (boundsLen % 4 != 0) {\n+            DEBUG_SCREENCAST(\"%s:%i incorrect array length\\n\", __FUNCTION__, __LINE__);\n+            return -1;\n+        }\n+        affectedBoundsLength = boundsLen \/ 4;\n+    }\n+\n+    GdkRectangle affectedScreenBounds[affectedBoundsLength];\n+    arrayToRectangles(env,\n+                     affectedScreensBoundsArray,\n+                     boundsLen,\n+                     (GdkRectangle *) &affectedScreenBounds);\n@@ -726,1 +834,1 @@\n-            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i token |%s|\\n\",\n+            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i with token |%s|\\n\",\n@@ -730,1 +838,1 @@\n-    if (!initScreencast(token)) {\n+    if (!initScreencast(token, affectedScreenBounds, affectedBoundsLength)) {\n@@ -738,0 +846,1 @@\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":137,"deletions":28,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-void storeRestoreToken(const gchar* token);\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+        memset(screen, 0, sizeof(struct ScreenProps));\n+\n@@ -579,0 +581,1 @@\n+    struct StartHelper *startHelper = helper->data;\n@@ -582,1 +585,1 @@\n-    const gchar *oldToken = (const gchar *) helper->data;\n+    const gchar *oldToken = startHelper->token;\n@@ -587,0 +590,1 @@\n+        \/\/ Cancel pressed on the system dialog\n@@ -588,1 +592,1 @@\n-        helper->data = (void *) START_DENIED;\n+        startHelper->result = START_DENIED;\n@@ -593,20 +597,0 @@\n-    GVariant *restoreTokenVar = gtk->g_variant_lookup_value(\n-            result,\n-            \"restore_token\",\n-            G_VARIANT_TYPE_STRING\n-    );\n-\n-    if (restoreTokenVar) {\n-        gsize len;\n-        const gchar * newToken = gtk->g_variant_get_string(restoreTokenVar, &len);\n-        DEBUG_SCREENCAST(\"restore_token |%s|\\n\", newToken);\n-\n-        if (!oldToken || (strcmp(newToken, oldToken) != 0)) {\n-            DEBUG_SCREENCAST(\"restore_token changed |%s| > |%s|\\n\",\n-                             oldToken, newToken);\n-            storeRestoreToken(newToken);\n-        }\n-\n-        gtk->g_variant_unref(restoreTokenVar);\n-    }\n-\n@@ -629,3 +613,3 @@\n-    helper->data = (rebuildScreenData(&iter, count == 1))\n-                   ? (void *) START_OK\n-                   : (void *) -1;\n+    startHelper->result = (rebuildScreenData(&iter, count == 1))\n+                   ? START_OK\n+                   : -1;\n@@ -633,2 +617,20 @@\n-    DEBUG_SCREENCAST(\"rebuildScreenData result |%i|\\n\",\n-                     helper->data);\n+    DEBUG_SCREENCAST(\"rebuildScreenData result |%i|\\n\", startHelper->result);\n+\n+    if (startHelper->result == START_OK) {\n+        GVariant *restoreTokenVar = gtk->g_variant_lookup_value(\n+                result,\n+                \"restore_token\",\n+                G_VARIANT_TYPE_STRING\n+        );\n+\n+        if (restoreTokenVar) {\n+            gsize len;\n+            const gchar *newToken = gtk->\n+                    g_variant_get_string(restoreTokenVar, &len);\n+            DEBUG_SCREENCAST(\"restore_token |%s|\\n\", newToken);\n+\n+            storeRestoreToken(oldToken, newToken);\n+\n+            gtk->g_variant_unref(restoreTokenVar);\n+        }\n+    }\n@@ -649,0 +651,3 @@\n+    struct StartHelper startHelper = { 0 };\n+    startHelper.token = token;\n+\n@@ -650,1 +655,1 @@\n-    helper.data = (void *) token;\n+    helper.data = &startHelper;\n@@ -704,3 +709,3 @@\n-    DEBUG_SCREENCAST(\"ScreenCastStartResult |%i|\\n\",\n-                     (ScreenCastStartResult) helper.data);\n-    return (ScreenCastStartResult) helper.data;\n+    DEBUG_SCREENCAST(\"ScreenCastStartResult |%i|\\n\", startHelper.result);\n+\n+    return startHelper.result;\n@@ -816,0 +821,46 @@\n+gboolean rectanglesEqual(GdkRectangle rect1, GdkRectangle rect2) {\n+    return rect1.x == rect2.x\n+           && rect1.y == rect2.y\n+           && rect1.width == rect2.width\n+           && rect1.height == rect2.height;\n+}\n+\n+gboolean checkCanCaptureAllRequiredScreens(GdkRectangle *affectedBounds,\n+                        gint affectedBoundsLength) {\n+\n+\n+    if (affectedBoundsLength > screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"Requested screen count is greater \"\n+                         \"than allowed with token (%i > %i)\\n\",\n+                         affectedBoundsLength, screenSpace.screenCount);\n+        return false;\n+    }\n+\n+\n+    for (int i = 0; i < affectedBoundsLength; ++i) {\n+        gboolean found = false;\n+        GdkRectangle affBounds = affectedBounds[i];\n+        for (int j = 0; j < screenSpace.screenCount; ++j) {\n+            GdkRectangle allowedBounds = screenSpace.screens[j].bounds;\n+\n+            if (rectanglesEqual(allowedBounds, affBounds)) {\n+                DEBUG_SCREENCAST(\"Found allowed screen bounds in affected \"\n+                                 \"screen bounds %i %i %i %i\\n\",\n+                                 affBounds.x, affBounds.y,\n+                                 affBounds.width, affBounds.height);\n+                found = true;\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            DEBUG_SCREENCAST(\"Could not find required screen %i %i %i %i \"\n+                             \"in allowed bounds\\n\",\n+                             affBounds.x, affBounds.y,\n+                             affBounds.width, affBounds.height);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n@@ -821,1 +872,3 @@\n-int getPipewireFd(const gchar *token) {\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength) {\n@@ -835,1 +888,1 @@\n-        DEBUG_SCREENCAST(\"Failed to get pipewire node\\n\", NULL);\n+        DEBUG_SCREENCAST(\"Failed to start\\n\", NULL);\n@@ -837,0 +890,8 @@\n+    } else {\n+        if (!checkCanCaptureAllRequiredScreens(affectedBounds,\n+                                               affectedBoundsLength)) {\n+            DEBUG_SCREENCAST(\"The location of the screens has changed, \"\n+                             \"the capture area is outside the allowed \"\n+                             \"area.\\n\", NULL)\n+            return START_DENIED;\n+        }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.c","additions":94,"deletions":33,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -41,1 +41,3 @@\n-int getPipewireFd();\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength);\n@@ -67,0 +69,5 @@\n+struct StartHelper {\n+    const gchar *token;\n+    ScreenCastStartResult result;\n+};\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}