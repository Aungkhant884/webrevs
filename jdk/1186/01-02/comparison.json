{"files":[{"patch":"@@ -50,1 +50,1 @@\n-  void **_keyvals;              \/\/ Array of keys and values\n+  void** _keyvals;              \/\/ Array of keys and values\n@@ -67,1 +67,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n+  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n@@ -71,1 +71,1 @@\n-Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena, int size)\n+Dict::Dict(CmpKey initcmp, Hash inithash, Arena* arena, int size)\n@@ -77,1 +77,1 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n+  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n@@ -82,1 +82,1 @@\n-Dict::Dict(const Dict &d, Arena *arena)\n+Dict::Dict(const Dict &d, Arena* arena)\n@@ -90,2 +90,2 @@\n-    _bin[i]._keyvals = (void**)_arena->Amalloc_4(sizeof(void *) * _bin[i]._max * 2);\n-    memcpy(_bin[i]._keyvals, d._bin[i]._keyvals, _bin[i]._cnt*2*sizeof(void*));\n+    _bin[i]._keyvals = (void**)_arena->Amalloc_4(sizeof(void*) * _bin[i]._max * 2);\n+    memcpy(_bin[i]._keyvals, d._bin[i]._keyvals, _bin[i]._cnt * 2 * sizeof(void*));\n@@ -97,20 +97,1 @@\n-Dict::~Dict() {\n-  \/*\n-  tty->print(\"~Dict %d\/%d: \",_cnt,_size);\n-  for( uint i=0; i < _size; i++) \/\/ For complete new table do\n-    tty->print(\"%d \",_bin[i]._cnt);\n-  tty->print(\"\\n\");*\/\n-  \/*for( uint i=0; i<_size; i++ ) {\n-    FREE_FAST( _bin[i]._keyvals );\n-    } *\/\n-}\n-\n-\/\/------------------------------Clear----------------------------------------\n-\/\/ Zap to empty; ready for re-use\n-void Dict::Clear() {\n-  _cnt = 0;                     \/\/ Empty contents\n-  for( uint i=0; i<_size; i++ )\n-    _bin[i]._cnt = 0;           \/\/ Empty buckets, but leave allocated\n-  \/\/ Leave _size & _bin alone, under the assumption that dictionary will\n-  \/\/ grow to this size again.\n-}\n+Dict::~Dict() { }\n@@ -124,1 +105,1 @@\n-void Dict::doubhash(void) {\n+void Dict::doubhash() {\n@@ -131,1 +112,1 @@\n-    bucket *b = &_bin[i];              \/\/ Handy shortcut for _bin[i]\n+    bucket* b = &_bin[i];              \/\/ Handy shortcut for _bin[i]\n@@ -134,1 +115,1 @@\n-    bucket *nb = &_bin[i+oldsize];     \/\/ New bucket shortcut\n+    bucket* nb = &_bin[i+oldsize];     \/\/ New bucket shortcut\n@@ -140,1 +121,1 @@\n-    nb->_keyvals = (void**)_arena->Amalloc_4(sizeof(void *) * nb->_max * 2);\n+    nb->_keyvals = (void**)_arena->Amalloc_4(sizeof(void* ) * nb->_max * 2);\n@@ -143,2 +124,2 @@\n-    for (j = 0; j < b->_cnt; ) {           \/\/ Rehash all keys in this bucket\n-      void *key = b->_keyvals[j + j];\n+    for (j = 0; j < b->_cnt;) {        \/\/ Rehash all keys in this bucket\n+      void* key = b->_keyvals[j + j];\n@@ -149,1 +130,1 @@\n-        b->_cnt--;                         \/\/ Remove key\/value from lo bucket\n+        b->_cnt--;                     \/\/ Remove key\/value from lo bucket\n@@ -166,6 +147,6 @@\n-void *Dict::Insert(void *key, void *val, bool replace) {\n-  uint hash = _hash( key );     \/\/ Get hash key\n-  uint i = hash & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ ) {\n-    if( !_cmp(key,b->_keyvals[j+j]) ) {\n+void*Dict::Insert(void* key, void* val, bool replace) {\n+  uint hash = _hash(key);       \/\/ Get hash key\n+  uint i = hash & (_size - 1);  \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n@@ -173,1 +154,1 @@\n-        return b->_keyvals[j+j+1];\n+        return b->_keyvals[j + j + 1];\n@@ -175,4 +156,4 @@\n-        void *prior = b->_keyvals[j+j+1];\n-        b->_keyvals[j+j  ] = key;       \/\/ Insert current key-value\n-        b->_keyvals[j+j+1] = val;\n-        return prior;           \/\/ Return prior\n+        void* prior = b->_keyvals[j + j + 1];\n+        b->_keyvals[j + j    ] = key;\n+        b->_keyvals[j + j + 1] = val;\n+        return prior;\n@@ -182,1 +163,1 @@\n-  if( ++_cnt > _size ) {        \/\/ Hash table is full\n+  if (++_cnt > _size) {         \/\/ Hash table is full\n@@ -184,2 +165,2 @@\n-    i = hash & (_size-1);       \/\/ Rehash\n-    b = &_bin[i];               \/\/ Handy shortcut\n+    i = hash & (_size - 1);     \/\/ Rehash\n+    b = &_bin[i];\n@@ -187,2 +168,2 @@\n-  if( b->_cnt == b->_max ) {    \/\/ Must grow bucket?\n-    if( !b->_keyvals ) {\n+  if (b->_cnt == b->_max) {     \/\/ Must grow bucket?\n+    if (!b->_keyvals) {\n@@ -196,2 +177,2 @@\n-  b->_keyvals[b->_cnt+b->_cnt  ] = key;\n-  b->_keyvals[b->_cnt+b->_cnt+1] = val;\n+  b->_keyvals[b->_cnt + b->_cnt    ] = key;\n+  b->_keyvals[b->_cnt + b->_cnt + 1] = val;\n@@ -204,6 +185,6 @@\n-void *Dict::Delete(void *key) {\n-  uint i = _hash( key ) & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ )\n-    if( !_cmp(key,b->_keyvals[j+j]) ) {\n-      void *prior = b->_keyvals[j+j+1];\n+void* Dict::Delete(void* key) {\n+  uint i = _hash(key) & (_size - 1); \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];         \/\/ Handy shortcut\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n+      void* prior = b->_keyvals[j + j + 1];\n@@ -211,2 +192,2 @@\n-      b->_keyvals[j+j  ] = b->_keyvals[b->_cnt+b->_cnt  ];\n-      b->_keyvals[j+j+1] = b->_keyvals[b->_cnt+b->_cnt+1];\n+      b->_keyvals[j+j  ] = b->_keyvals[b->_cnt + b->_cnt    ];\n+      b->_keyvals[j+j+1] = b->_keyvals[b->_cnt + b->_cnt + 1];\n@@ -216,0 +197,1 @@\n+  }\n@@ -222,22 +204,7 @@\n-void *Dict::operator [](const void *key) const {\n-  uint i = _hash( key ) & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ )\n-    if( !_cmp(key,b->_keyvals[j+j]) )\n-      return b->_keyvals[j+j+1];\n-  return NULL;\n-}\n-\n-\/\/------------------------------CmpDict--------------------------------------\n-\/\/ CmpDict compares two dictionaries; they must have the same keys (their\n-\/\/ keys must match using CmpKey) and they must have the same values (pointer\n-\/\/ comparison).  If so 1 is returned, if not 0 is returned.\n-int32_t Dict::operator ==(const Dict &d2) const {\n-  if( _cnt != d2._cnt ) return 0;\n-  if( _hash != d2._hash ) return 0;\n-  if( _cmp != d2._cmp ) return 0;\n-  for( uint i=0; i < _size; i++) {      \/\/ For complete hash table do\n-    bucket *b = &_bin[i];       \/\/ Handy shortcut\n-    if( b->_cnt != d2._bin[i]._cnt ) return 0;\n-    if( memcmp(b->_keyvals, d2._bin[i]._keyvals, b->_cnt*2*sizeof(void*) ) )\n-      return 0;                 \/\/ Key-value pairs must match\n+void* Dict::operator [](const void* key) const {\n+  uint i = _hash(key) & (_size - 1); \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];         \/\/ Handy shortcut\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n+      return b->_keyvals[j + j + 1];\n+    }\n@@ -245,1 +212,1 @@\n-  return 1;                     \/\/ All match, is OK\n+  return NULL;\n@@ -253,1 +220,1 @@\n-  for( ; i.test(); ++i ) {\n+  for (; i.test(); ++i) {\n@@ -270,1 +237,1 @@\n-int hashstr(const void *t) {\n+int hashstr(const void* t) {\n@@ -273,1 +240,1 @@\n-  const char *s = (const char *)t;\n+  const char* s = (const char*)t;\n@@ -275,1 +242,1 @@\n-  while( ((c = *s++) != '\\0') && (k < MAXID-1) ) { \/\/ Get characters till null or MAXID-1\n+  while (((c = *s++) != '\\0') && (k < MAXID-1)) { \/\/ Get characters till null or MAXID-1\n@@ -285,1 +252,1 @@\n-int hashptr(const void *key) {\n+int hashptr(const void* key) {\n@@ -290,1 +257,1 @@\n-int hashkey(const void *key) {\n+int hashkey(const void* key) {\n@@ -295,2 +262,2 @@\n-int32_t cmpstr(const void *k1, const void *k2) {\n-  return strcmp((const char *)k1,(const char *)k2);\n+int32_t cmpstr(const void* k1, const void* k2) {\n+  return strcmp((const char*)k1, (const char*)k2);\n@@ -300,2 +267,4 @@\n-int32_t cmpkey(const void *key1, const void *key2) {\n-  if (key1 == key2) return 0;\n+int32_t cmpkey(const void* key1, const void* key2) {\n+  if (key1 == key2) {\n+    return 0;\n+  }\n@@ -303,1 +272,3 @@\n-  if (delta > 0) return 1;\n+  if (delta > 0) {\n+    return 1;\n+  }\n@@ -310,2 +281,2 @@\n-void DictI::reset( const Dict *dict ) {\n-  _d = dict;                    \/\/ The dictionary\n+void DictI::reset(const Dict* dict) {\n+  _d = dict;\n@@ -321,3 +292,3 @@\n-  if( _j-- ) {                  \/\/ Still working in current bin?\n-    _key   = _d->_bin[_i]._keyvals[_j+_j];\n-    _value = _d->_bin[_i]._keyvals[_j+_j+1];\n+  if (_j--) {                   \/\/ Still working in current bin?\n+    _key   = _d->_bin[_i]._keyvals[_j + _j];\n+    _value = _d->_bin[_i]._keyvals[_j + _j + 1];\n@@ -327,1 +298,1 @@\n-  while( ++_i < _d->_size ) {   \/\/ Else scan for non-zero bucket\n+  while (++_i < _d->_size) {   \/\/ Else scan for non-zero bucket\n@@ -329,1 +300,3 @@\n-    if( !_j ) continue;\n+    if (!_j) {\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/libadt\/dict.cpp","additions":74,"deletions":101,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -42,3 +42,2 @@\n-typedef int32_t (*CmpKey)(const void *key1, const void *key2);\n-typedef int  (*Hash)(const void *key);\n-typedef void (*FuncDict)(const void *key, const void *val, Dict *d);\n+typedef int32_t (*CmpKey)(const void* key1, const void* key2);\n+typedef int     (*Hash)(const void* key);\n@@ -48,2 +47,2 @@\n-  class Arena *_arena;          \/\/ Where to draw storage from\n-  class bucket *_bin;           \/\/ Hash table is array of buckets\n+  class Arena* _arena;          \/\/ Where to draw storage from\n+  class bucket* _bin;           \/\/ Hash table is array of buckets\n@@ -54,1 +53,1 @@\n-  void doubhash( void );        \/\/ Double hash table size\n+  void doubhash();              \/\/ Double hash table size\n@@ -61,2 +60,2 @@\n-  Dict(CmpKey cmp, Hash hash, Arena *arena, int size = 16);\n-  Dict(const Dict &base, Arena *arena); \/\/ Deep-copy\n+  Dict(CmpKey cmp, Hash hash, Arena* arena, int size = 16);\n+  Dict(const Dict &base, Arena* arena); \/\/ Deep-copy\n@@ -65,4 +64,0 @@\n-\n-  \/\/ Zap to empty; ready for re-use\n-  void Clear();\n-\n@@ -74,2 +69,2 @@\n-  void *Insert(void *key, void *val, bool replace = true); \/\/ A new key-value\n-  void *Delete(void *key);        \/\/ Delete & return old\n+  void* Insert(void* key, void* val, bool replace = true); \/\/ A new key-value\n+  void* Delete(void* key);        \/\/ Delete & return old\n@@ -79,6 +74,1 @@\n-  void *operator [](const void *key) const;  \/\/ Do a lookup\n-\n-  \/\/ == compares two dictionaries; they must have the same keys (their keys\n-  \/\/ must match using CmpKey) and they must have the same values (pointer\n-  \/\/ comparison).  If so 1 is returned, if not 0 is returned.\n-  int32_t operator ==(const Dict &d) const;   \/\/ Compare dictionaries for equal\n+  void* operator [](const void* key) const;  \/\/ Do a lookup\n@@ -91,1 +81,1 @@\n-int hashstr(const void *s);        \/\/ Nice string hash\n+int hashstr(const void* s);        \/\/ Nice string hash\n@@ -94,1 +84,1 @@\n-int hashptr(const void *key);\n+int hashptr(const void* key);\n@@ -96,1 +86,1 @@\n-int hashkey(const void *key);\n+int hashkey(const void* key);\n@@ -99,1 +89,1 @@\n-int32_t cmpstr(const void *k1, const void *k2);\n+int32_t cmpstr(const void* k1, const void* k2);\n@@ -101,1 +91,1 @@\n-int32_t cmpkey(const void *key1, const void *key2);\n+int32_t cmpkey(const void* key1, const void* key2);\n@@ -109,1 +99,1 @@\n-  const Dict *_d;               \/\/ Dictionary being iterated over\n+  const Dict* _d;               \/\/ Dictionary being iterated over\n@@ -113,3 +103,4 @@\n-  const void *_key, *_value;    \/\/ Easy access to the key-value pair\n-  DictI( const Dict *d ) {reset(d);}; \/\/ Create a new iterator\n-  void reset( const Dict *dict );     \/\/ Reset existing iterator\n+  const void* _key;\n+  const void* _value;\n+  DictI(const Dict* d) { reset(d); }; \/\/ Create a new iterator\n+  void reset(const Dict* dict);       \/\/ Reset existing iterator\n@@ -117,1 +108,1 @@\n-  int test(void) { return _i<_d->_size;} \/\/ Test for end of iteration\n+  int test(void) { return _i < _d->_size; } \/\/ Test for end of iteration\n","filename":"src\/hotspot\/share\/libadt\/dict.hpp","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"}]}