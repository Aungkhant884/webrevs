{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  void **_keyvals;              \/\/ Array of keys and values\n+  void** _keyvals;              \/\/ Array of keys and values\n@@ -67,2 +67,2 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n-  memset((void*)_bin,0,sizeof(bucket)*_size);\n+  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  memset((void*)_bin, 0, sizeof(bucket) * _size);\n@@ -71,1 +71,1 @@\n-Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena, int size)\n+Dict::Dict(CmpKey initcmp, Hash inithash, Arena* arena, int size)\n@@ -77,2 +77,2 @@\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n-  memset((void*)_bin,0,sizeof(bucket)*_size);\n+  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  memset((void*)_bin, 0, sizeof(bucket) * _size);\n@@ -81,11 +81,12 @@\n-\/\/------------------------------~Dict------------------------------------------\n-\/\/ Delete an existing dictionary.\n-Dict::~Dict() {\n-  \/*\n-  tty->print(\"~Dict %d\/%d: \",_cnt,_size);\n-  for( uint i=0; i < _size; i++) \/\/ For complete new table do\n-    tty->print(\"%d \",_bin[i]._cnt);\n-  tty->print(\"\\n\");*\/\n-  \/*for( uint i=0; i<_size; i++ ) {\n-    FREE_FAST( _bin[i]._keyvals );\n-    } *\/\n+\/\/ Deep copy into arena of choice\n+Dict::Dict(const Dict &d, Arena* arena)\n+: _arena(arena), _size(d._size), _cnt(d._cnt), _hash(d._hash), _cmp(d._cmp) {\n+  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket) * _size);\n+  memcpy((void*)_bin, (void*)d._bin, sizeof(bucket) * _size);\n+  for (uint i = 0; i < _size; i++) {\n+    if (!_bin[i]._keyvals) {\n+      continue;\n+    }\n+    _bin[i]._keyvals = (void**)_arena->Amalloc_4(sizeof(void*) * _bin[i]._max * 2);\n+    memcpy(_bin[i]._keyvals, d._bin[i]._keyvals, _bin[i]._cnt * 2 * sizeof(void*));\n+  }\n@@ -94,9 +95,3 @@\n-\/\/------------------------------Clear----------------------------------------\n-\/\/ Zap to empty; ready for re-use\n-void Dict::Clear() {\n-  _cnt = 0;                     \/\/ Empty contents\n-  for( uint i=0; i<_size; i++ )\n-    _bin[i]._cnt = 0;           \/\/ Empty buckets, but leave allocated\n-  \/\/ Leave _size & _bin alone, under the assumption that dictionary will\n-  \/\/ grow to this size again.\n-}\n+\/\/------------------------------~Dict------------------------------------------\n+\/\/ Delete an existing dictionary.\n+Dict::~Dict() { }\n@@ -110,1 +105,1 @@\n-void Dict::doubhash(void) {\n+void Dict::doubhash() {\n@@ -117,1 +112,1 @@\n-    bucket *b = &_bin[i];              \/\/ Handy shortcut for _bin[i]\n+    bucket* b = &_bin[i];              \/\/ Handy shortcut for _bin[i]\n@@ -120,1 +115,1 @@\n-    bucket *nb = &_bin[i+oldsize];     \/\/ New bucket shortcut\n+    bucket* nb = &_bin[i+oldsize];     \/\/ New bucket shortcut\n@@ -126,1 +121,1 @@\n-    nb->_keyvals = (void**)_arena->Amalloc_4(sizeof(void *) * nb->_max * 2);\n+    nb->_keyvals = (void**)_arena->Amalloc_4(sizeof(void* ) * nb->_max * 2);\n@@ -129,2 +124,2 @@\n-    for (j = 0; j < b->_cnt; ) {           \/\/ Rehash all keys in this bucket\n-      void *key = b->_keyvals[j + j];\n+    for (j = 0; j < b->_cnt;) {        \/\/ Rehash all keys in this bucket\n+      void* key = b->_keyvals[j + j];\n@@ -135,1 +130,1 @@\n-        b->_cnt--;                         \/\/ Remove key\/value from lo bucket\n+        b->_cnt--;                     \/\/ Remove key\/value from lo bucket\n@@ -146,35 +141,0 @@\n-\/\/------------------------------Dict-----------------------------------------\n-\/\/ Deep copy a dictionary.\n-Dict::Dict( const Dict &d ) : ResourceObj(d), _arena(d._arena), _size(d._size), _cnt(d._cnt), _hash(d._hash), _cmp(d._cmp) {\n-  _bin = (bucket*)_arena->Amalloc_4(sizeof(bucket)*_size);\n-  memcpy( (void*)_bin, (void*)d._bin, sizeof(bucket)*_size );\n-  for( uint i=0; i<_size; i++ ) {\n-    if( !_bin[i]._keyvals ) continue;\n-    _bin[i]._keyvals=(void**)_arena->Amalloc_4( sizeof(void *)*_bin[i]._max*2);\n-    memcpy( _bin[i]._keyvals, d._bin[i]._keyvals,_bin[i]._cnt*2*sizeof(void*));\n-  }\n-}\n-\n-\/\/------------------------------Dict-----------------------------------------\n-\/\/ Deep copy a dictionary.\n-Dict &Dict::operator =( const Dict &d ) {\n-  if( _size < d._size ) {       \/\/ If must have more buckets\n-    _arena = d._arena;\n-    _bin = (bucket*)_arena->Arealloc( _bin, sizeof(bucket)*_size, sizeof(bucket)*d._size );\n-    memset( (void*)(&_bin[_size]), 0, (d._size-_size)*sizeof(bucket) );\n-    _size = d._size;\n-  }\n-  uint i;\n-  for( i=0; i<_size; i++ ) \/\/ All buckets are empty\n-    _bin[i]._cnt = 0;           \/\/ But leave bucket allocations alone\n-  _cnt = d._cnt;\n-  *(Hash*)(&_hash) = d._hash;\n-  *(CmpKey*)(&_cmp) = d._cmp;\n-  for( i=0; i<_size; i++ ) {\n-    bucket *b = &d._bin[i];     \/\/ Shortcut to source bucket\n-    for( uint j=0; j<b->_cnt; j++ )\n-      Insert( b->_keyvals[j+j], b->_keyvals[j+j+1] );\n-  }\n-  return *this;\n-}\n-\n@@ -187,6 +147,6 @@\n-void *Dict::Insert(void *key, void *val, bool replace) {\n-  uint hash = _hash( key );     \/\/ Get hash key\n-  uint i = hash & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ ) {\n-    if( !_cmp(key,b->_keyvals[j+j]) ) {\n+void*Dict::Insert(void* key, void* val, bool replace) {\n+  uint hash = _hash(key);       \/\/ Get hash key\n+  uint i = hash & (_size - 1);  \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n@@ -194,1 +154,1 @@\n-        return b->_keyvals[j+j+1];\n+        return b->_keyvals[j + j + 1];\n@@ -196,4 +156,4 @@\n-        void *prior = b->_keyvals[j+j+1];\n-        b->_keyvals[j+j  ] = key;       \/\/ Insert current key-value\n-        b->_keyvals[j+j+1] = val;\n-        return prior;           \/\/ Return prior\n+        void* prior = b->_keyvals[j + j + 1];\n+        b->_keyvals[j + j    ] = key;\n+        b->_keyvals[j + j + 1] = val;\n+        return prior;\n@@ -203,1 +163,1 @@\n-  if( ++_cnt > _size ) {        \/\/ Hash table is full\n+  if (++_cnt > _size) {         \/\/ Hash table is full\n@@ -205,2 +165,2 @@\n-    i = hash & (_size-1);       \/\/ Rehash\n-    b = &_bin[i];               \/\/ Handy shortcut\n+    i = hash & (_size - 1);     \/\/ Rehash\n+    b = &_bin[i];\n@@ -208,2 +168,2 @@\n-  if( b->_cnt == b->_max ) {    \/\/ Must grow bucket?\n-    if( !b->_keyvals ) {\n+  if (b->_cnt == b->_max) {     \/\/ Must grow bucket?\n+    if (!b->_keyvals) {\n@@ -217,2 +177,2 @@\n-  b->_keyvals[b->_cnt+b->_cnt  ] = key;\n-  b->_keyvals[b->_cnt+b->_cnt+1] = val;\n+  b->_keyvals[b->_cnt + b->_cnt    ] = key;\n+  b->_keyvals[b->_cnt + b->_cnt + 1] = val;\n@@ -225,6 +185,6 @@\n-void *Dict::Delete(void *key) {\n-  uint i = _hash( key ) & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ )\n-    if( !_cmp(key,b->_keyvals[j+j]) ) {\n-      void *prior = b->_keyvals[j+j+1];\n+void* Dict::Delete(void* key) {\n+  uint i = _hash(key) & (_size - 1); \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];         \/\/ Handy shortcut\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n+      void* prior = b->_keyvals[j + j + 1];\n@@ -232,2 +192,2 @@\n-      b->_keyvals[j+j  ] = b->_keyvals[b->_cnt+b->_cnt  ];\n-      b->_keyvals[j+j+1] = b->_keyvals[b->_cnt+b->_cnt+1];\n+      b->_keyvals[j+j  ] = b->_keyvals[b->_cnt + b->_cnt    ];\n+      b->_keyvals[j+j+1] = b->_keyvals[b->_cnt + b->_cnt + 1];\n@@ -237,0 +197,1 @@\n+  }\n@@ -243,22 +204,7 @@\n-void *Dict::operator [](const void *key) const {\n-  uint i = _hash( key ) & (_size-1);    \/\/ Get hash key, corrected for size\n-  bucket *b = &_bin[i];         \/\/ Handy shortcut\n-  for( uint j=0; j<b->_cnt; j++ )\n-    if( !_cmp(key,b->_keyvals[j+j]) )\n-      return b->_keyvals[j+j+1];\n-  return NULL;\n-}\n-\n-\/\/------------------------------CmpDict--------------------------------------\n-\/\/ CmpDict compares two dictionaries; they must have the same keys (their\n-\/\/ keys must match using CmpKey) and they must have the same values (pointer\n-\/\/ comparison).  If so 1 is returned, if not 0 is returned.\n-int32_t Dict::operator ==(const Dict &d2) const {\n-  if( _cnt != d2._cnt ) return 0;\n-  if( _hash != d2._hash ) return 0;\n-  if( _cmp != d2._cmp ) return 0;\n-  for( uint i=0; i < _size; i++) {      \/\/ For complete hash table do\n-    bucket *b = &_bin[i];       \/\/ Handy shortcut\n-    if( b->_cnt != d2._bin[i]._cnt ) return 0;\n-    if( memcmp(b->_keyvals, d2._bin[i]._keyvals, b->_cnt*2*sizeof(void*) ) )\n-      return 0;                 \/\/ Key-value pairs must match\n+void* Dict::operator [](const void* key) const {\n+  uint i = _hash(key) & (_size - 1); \/\/ Get hash key, corrected for size\n+  bucket* b = &_bin[i];         \/\/ Handy shortcut\n+  for (uint j = 0; j < b->_cnt; j++) {\n+    if (!_cmp(key, b->_keyvals[j + j])) {\n+      return b->_keyvals[j + j + 1];\n+    }\n@@ -266,1 +212,1 @@\n-  return 1;                     \/\/ All match, is OK\n+  return NULL;\n@@ -274,1 +220,1 @@\n-  for( ; i.test(); ++i ) {\n+  for (; i.test(); ++i) {\n@@ -291,1 +237,1 @@\n-int hashstr(const void *t) {\n+int hashstr(const void* t) {\n@@ -294,1 +240,1 @@\n-  const char *s = (const char *)t;\n+  const char* s = (const char*)t;\n@@ -296,1 +242,1 @@\n-  while( ((c = *s++) != '\\0') && (k < MAXID-1) ) { \/\/ Get characters till null or MAXID-1\n+  while (((c = *s++) != '\\0') && (k < MAXID-1)) { \/\/ Get characters till null or MAXID-1\n@@ -306,1 +252,1 @@\n-int hashptr(const void *key) {\n+int hashptr(const void* key) {\n@@ -311,1 +257,1 @@\n-int hashkey(const void *key) {\n+int hashkey(const void* key) {\n@@ -316,2 +262,2 @@\n-int32_t cmpstr(const void *k1, const void *k2) {\n-  return strcmp((const char *)k1,(const char *)k2);\n+int32_t cmpstr(const void* k1, const void* k2) {\n+  return strcmp((const char*)k1, (const char*)k2);\n@@ -321,2 +267,4 @@\n-int32_t cmpkey(const void *key1, const void *key2) {\n-  if (key1 == key2) return 0;\n+int32_t cmpkey(const void* key1, const void* key2) {\n+  if (key1 == key2) {\n+    return 0;\n+  }\n@@ -324,1 +272,3 @@\n-  if (delta > 0) return 1;\n+  if (delta > 0) {\n+    return 1;\n+  }\n@@ -331,2 +281,2 @@\n-void DictI::reset( const Dict *dict ) {\n-  _d = dict;                    \/\/ The dictionary\n+void DictI::reset(const Dict* dict) {\n+  _d = dict;\n@@ -342,3 +292,3 @@\n-  if( _j-- ) {                  \/\/ Still working in current bin?\n-    _key   = _d->_bin[_i]._keyvals[_j+_j];\n-    _value = _d->_bin[_i]._keyvals[_j+_j+1];\n+  if (_j--) {                   \/\/ Still working in current bin?\n+    _key   = _d->_bin[_i]._keyvals[_j + _j];\n+    _value = _d->_bin[_i]._keyvals[_j + _j + 1];\n@@ -348,1 +298,1 @@\n-  while( ++_i < _d->_size ) {   \/\/ Else scan for non-zero bucket\n+  while (++_i < _d->_size) {   \/\/ Else scan for non-zero bucket\n@@ -350,1 +300,3 @@\n-    if( !_j ) continue;\n+    if (!_j) {\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/libadt\/dict.cpp","additions":88,"deletions":136,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,2 @@\n-typedef int32_t (*CmpKey)(const void *key1, const void *key2);\n-typedef int  (*Hash)(const void *key);\n-typedef void (*FuncDict)(const void *key, const void *val, Dict *d);\n+typedef int32_t (*CmpKey)(const void* key1, const void* key2);\n+typedef int     (*Hash)(const void* key);\n@@ -48,2 +47,2 @@\n-  class Arena *_arena;          \/\/ Where to draw storage from\n-  class bucket *_bin;           \/\/ Hash table is array of buckets\n+  class Arena* _arena;          \/\/ Where to draw storage from\n+  class bucket* _bin;           \/\/ Hash table is array of buckets\n@@ -54,1 +53,1 @@\n-  void doubhash( void );        \/\/ Double hash table size\n+  void doubhash();              \/\/ Double hash table size\n@@ -60,2 +59,3 @@\n-  Dict( CmpKey cmp, Hash hash );\n-  Dict( CmpKey cmp, Hash hash, Arena *arena, int size=16 );\n+  Dict(CmpKey cmp, Hash hash);\n+  Dict(CmpKey cmp, Hash hash, Arena* arena, int size = 16);\n+  Dict(const Dict &base, Arena* arena); \/\/ Deep-copy\n@@ -64,6 +64,0 @@\n-  Dict( const Dict & );         \/\/ Deep-copy guts\n-  Dict &operator =( const Dict & );\n-\n-  \/\/ Zap to empty; ready for re-use\n-  void Clear();\n-\n@@ -75,2 +69,2 @@\n-  void *Insert(void *key, void *val, bool replace = true); \/\/ A new key-value\n-  void *Delete(void *key);        \/\/ Delete & return old\n+  void* Insert(void* key, void* val, bool replace = true); \/\/ A new key-value\n+  void* Delete(void* key);        \/\/ Delete & return old\n@@ -80,6 +74,1 @@\n-  void *operator [](const void *key) const;  \/\/ Do a lookup\n-\n-  \/\/ == compares two dictionaries; they must have the same keys (their keys\n-  \/\/ must match using CmpKey) and they must have the same values (pointer\n-  \/\/ comparison).  If so 1 is returned, if not 0 is returned.\n-  int32_t operator ==(const Dict &d) const;   \/\/ Compare dictionaries for equal\n+  void* operator [](const void* key) const;  \/\/ Do a lookup\n@@ -92,1 +81,1 @@\n-int hashstr(const void *s);        \/\/ Nice string hash\n+int hashstr(const void* s);        \/\/ Nice string hash\n@@ -95,1 +84,1 @@\n-int hashptr(const void *key);\n+int hashptr(const void* key);\n@@ -97,1 +86,1 @@\n-int hashkey(const void *key);\n+int hashkey(const void* key);\n@@ -100,1 +89,1 @@\n-int32_t cmpstr(const void *k1, const void *k2);\n+int32_t cmpstr(const void* k1, const void* k2);\n@@ -102,1 +91,1 @@\n-int32_t cmpkey(const void *key1, const void *key2);\n+int32_t cmpkey(const void* key1, const void* key2);\n@@ -110,1 +99,1 @@\n-  const Dict *_d;               \/\/ Dictionary being iterated over\n+  const Dict* _d;               \/\/ Dictionary being iterated over\n@@ -114,3 +103,4 @@\n-  const void *_key, *_value;    \/\/ Easy access to the key-value pair\n-  DictI( const Dict *d ) {reset(d);}; \/\/ Create a new iterator\n-  void reset( const Dict *dict );     \/\/ Reset existing iterator\n+  const void* _key;\n+  const void* _value;\n+  DictI(const Dict* d) { reset(d); }; \/\/ Create a new iterator\n+  void reset(const Dict* dict);       \/\/ Reset existing iterator\n@@ -118,1 +108,1 @@\n-  int test(void) { return _i<_d->_size;} \/\/ Test for end of iteration\n+  int test(void) { return _i < _d->_size; } \/\/ Test for end of iteration\n","filename":"src\/hotspot\/share\/libadt\/dict.hpp","additions":23,"deletions":33,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-  Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );\n+  Dict *tdic = new (type_arena) Dict(*_shared_type_dict, type_arena);\n@@ -706,7 +706,0 @@\n-\n-  \/\/ Transfer the shared types.\n-  DictI i(_shared_type_dict);\n-  for( ; i.test(); ++i ) {\n-    Type* t = (Type*)i._value;\n-    tdic->Insert(t,t);  \/\/ New Type, insert into Type table\n-  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}