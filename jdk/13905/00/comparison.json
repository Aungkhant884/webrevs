{"files":[{"patch":"@@ -236,1 +236,1 @@\n-        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" \\\"%s\\\"]:%*c\", level, p2i(thread), thread->name(), level, ' ');\n@@ -241,1 +241,1 @@\n-        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" <%s>]:%*c\", level, p2i(thread), thread->type_name(), level, ' ');\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  _ok_upcalls = 0;\n+  _err_upcalls = 0;\n+  _disabled = false;\n@@ -121,0 +124,3 @@\n+  if (_disabled) {\n+    return true;\n+  }\n@@ -214,0 +220,33 @@\n+void JVMCICompiler::on_upcall(const char* error, JVMCICompileState* compile_state) {\n+  if (error != nullptr) {\n+\n+    Atomic::inc(&_err_upcalls);\n+    int ok = _ok_upcalls;\n+    int err = _err_upcalls;\n+    \/\/ If there have been at least 10 upcalls with an error\n+    \/\/ and the number of error upcalls is 10% or more of the\n+    \/\/ number of non-error upcalls, disable JVMCI compilation.\n+    if (err > 10 && err * 10 > ok && !_disabled) {\n+      _disabled = true;\n+      int total = err + ok;\n+      const char* disable_msg = err_msg(\"JVMCI compiler disabled \"\n+      \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n+      \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      log_warning(jit,compilation)(\"%s\", disable_msg);\n+      if (compile_state != nullptr) {\n+        const char* disable_error = os::strdup(disable_msg);\n+        if (disable_error != nullptr) {\n+          compile_state->set_failure(true, disable_error, true);\n+          JVMCI_event_1(\"%s\", disable_error);\n+          return;\n+        } else {\n+          \/\/ Leave failure reason as set by caller when strdup fails\n+        }\n+      }\n+    }\n+    JVMCI_event_1(\"JVMCI upcall had an error: %s\", error);\n+  } else {\n+    Atomic::inc(&_ok_upcalls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class JVMCICompileState;\n+\n@@ -65,1 +67,1 @@\n-   * JVMCICompiler::compile_method().\n+   * JVMCIRuntime::compile_method().\n@@ -69,0 +71,10 @@\n+  \/\/ Tracks upcalls that should only fail under severe conditions (e.g.\n+  \/\/ memory pressure) and disables JVMCI compilation if too many fail\n+  \/\/ with an error. A good example is an OOME thrown\n+  \/\/ when libgraal calls into the HotSpot heap to get a copy\n+  \/\/ of the system properties or to translate an exception from\n+  \/\/ the HotSpot heap to the libgraal heap.\n+  volatile int _ok_upcalls;\n+  volatile int _err_upcalls;\n+  bool _disabled;\n+\n@@ -129,0 +141,5 @@\n+  \/\/ Called after a JVMCI upcall whose success is a measure of the\n+  \/\/ JVMCI compiler's health. The value of `error` describes\n+  \/\/ an error during the upcall, null if no error.\n+  void on_upcall(const char* error, JVMCICompileState* compile_state=nullptr);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,0 +70,15 @@\n+void JVMCICompileState::set_failure(bool retryable, const char* reason, bool reason_on_C_heap) {\n+  if (_failure_reason != nullptr && _failure_reason_on_C_heap) {\n+      os::free((void*) _failure_reason);\n+  }\n+  _failure_reason = reason;\n+  _failure_reason_on_C_heap = reason_on_C_heap;\n+  _retryable = retryable;\n+}\n+\n+void JVMCICompileState::notify_libjvmci_oome() {\n+  const char* msg = \"Out of memory initializing libjvmci or attaching it to the current thread\";\n+  set_failure(true, msg);\n+  _compiler->on_upcall(msg);\n+}\n+\n@@ -175,1 +190,1 @@\n-void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool attach_OOME_is_fatal) {\n+void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool OOME_is_fatal) {\n@@ -207,2 +222,2 @@\n-  _env = _runtime->init_shared_library_javavm();\n-\n+  int create_JavaVM_err = JNI_OK;\n+  _env = _runtime->init_shared_library_javavm(&create_JavaVM_err);\n@@ -212,0 +227,7 @@\n+  } else if (create_JavaVM_err != JNI_OK) {\n+    if (!OOME_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n+      _threw_OOME = true;\n+      return;\n+    } else {\n+      fatal(\"JNI_CreateJavaVM failed with return value %d\", create_JavaVM_err);\n+    }\n@@ -230,1 +252,1 @@\n-      } else if (!attach_OOME_is_fatal && attach_result == JNI_ENOMEM) {\n+      } else if (!OOME_is_fatal && attach_result == JNI_ENOMEM) {\n@@ -232,1 +254,1 @@\n-        _attach_threw_OOME = true;\n+        _threw_OOME = true;\n@@ -254,3 +276,3 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(compile_state) {\n-  \/\/ In case of OOME, there's a good chance a subsequent attempt to attach might succeed.\n-  \/\/ Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n+    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(compile_state) {\n+  \/\/ In case of OOME, there's a good chance a subsequent attempt to create libjvmci or attach to it\n+  \/\/ might succeed. Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n@@ -258,1 +280,1 @@\n-  if (_attach_threw_OOME) {\n+  if (_threw_OOME) {\n@@ -264,1 +286,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n@@ -269,1 +291,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n@@ -279,1 +301,1 @@\n-  _attach_threw_OOME = false;\n+  _threw_OOME = false;\n@@ -467,1 +489,1 @@\n-  if (_attach_threw_OOME) {\n+  if (_threw_OOME) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -140,5 +140,5 @@\n-  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {\n-    _failure_reason = reason;\n-    _failure_reason_on_C_heap = reason_on_C_heap;\n-    _retryable = retryable;\n-  }\n+  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false);\n+\n+  \/\/ Called when creating or attaching to a libjvmci isolate failed\n+  \/\/ due to an out of memory condition.\n+  void notify_libjvmci_oome();\n@@ -172,1 +172,1 @@\n-  bool    _attach_threw_OOME;    \/\/ Failed to attach thread due to OutOfMemoryError, the JVMCIEnv is invalid\n+  bool             _threw_OOME;  \/\/ OOME trying to create a libjvmci isolate or attach to it; the JVMCIEnv is invalid\n@@ -252,1 +252,3 @@\n-  \/\/ Prints an exception and stack trace of a pending exception.\n+  \/\/ Prints the toString() and stack trace of a pending exception.\n+  \/\/ If there is no pending exception, this is a nop.\n+  \/\/ If `clear` is false, the pending exception will remain pending upon return.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1228,1 +1228,1 @@\n-JNIEnv* JVMCIRuntime::init_shared_library_javavm() {\n+JNIEnv* JVMCIRuntime::init_shared_library_javavm(int* create_JavaVM_err) {\n@@ -1278,1 +1278,1 @@\n-      fatal(\"JNI_CreateJavaVM failed with return value %d\", result);\n+      *create_JavaVM_err = result;\n@@ -1464,0 +1464,1 @@\n+        JVMCI_event_1(\"error initializing system properties for JVMCI runtime %d\", _id);\n@@ -1980,0 +1981,28 @@\n+\/\/ Called after an upcall to `function` while compiling `method`.\n+\/\/ If an exception occurred, it is cleared, the compilation state\n+\/\/ is updated with the failure and this method returns true.\n+\/\/ Otherwise, it returns false.\n+static bool after_compiler_upcall(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle& method, const char* function) {\n+  if (JVMCIENV->has_pending_exception()) {\n+    bool reason_on_C_heap = true;\n+    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s\", function), mtJVMCI);\n+    if (failure_reason == nullptr) {\n+      failure_reason = \"uncaught exception\";\n+      reason_on_C_heap = false;\n+    }\n+    Log(jit, compilation) log;\n+    if (log.is_info()) {\n+      ResourceMark rm;\n+      log.info(\"%s while compiling %s\", failure_reason, method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    } else {\n+      JVMCIENV->clear_pending_exception();\n+    }\n+    JVMCICompileState* compile_state = JVMCIENV->compile_state();\n+    compile_state->set_failure(true, failure_reason, reason_on_C_heap);\n+    compiler->on_upcall(failure_reason, compile_state);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2005,7 +2034,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_HotSpotJVMCIRuntime\")) {\n@@ -2015,7 +2038,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception getting JVMCI wrapper method\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_jvmci_method\")) {\n@@ -2027,18 +2044,16 @@\n-  if (!JVMCIENV->has_pending_exception()) {\n-    if (result_object.is_non_null()) {\n-      JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n-      if (failure_message.is_non_null()) {\n-        \/\/ Copy failure reason into resource memory first ...\n-        const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n-        \/\/ ... and then into the C heap.\n-        failure_reason = os::strdup(failure_reason, mtJVMCI);\n-        bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n-        compile_state->set_failure(retryable, failure_reason, true);\n-      } else {\n-        if (!compile_state->task()->is_success()) {\n-          compile_state->set_failure(true, \"no nmethod produced\");\n-        } else {\n-          compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n-          compiler->inc_methods_compiled();\n-        }\n-      }\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"call_HotSpotJVMCIRuntime_compileMethod\")) {\n+    return;\n+  }\n+  compiler->on_upcall(nullptr);\n+  guarantee(result_object.is_non_null(), \"call_HotSpotJVMCIRuntime_compileMethod returned null\");\n+  JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n+  if (failure_message.is_non_null()) {\n+    \/\/ Copy failure reason into resource memory first ...\n+    const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n+    \/\/ ... and then into the C heap.\n+    failure_reason = os::strdup(failure_reason, mtJVMCI);\n+    bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n+    compile_state->set_failure(retryable, failure_reason, true);\n+  } else {\n+    if (!compile_state->task()->is_success()) {\n+      compile_state->set_failure(true, \"no nmethod produced\");\n@@ -2046,1 +2061,2 @@\n-      assert(false, \"JVMCICompiler.compileMethod should always return non-null\");\n+      compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n+      compiler->inc_methods_compiled();\n@@ -2048,4 +2064,0 @@\n-  } else {\n-    \/\/ An uncaught exception here implies failure during compiler initialization.\n-    \/\/ The only sensible thing to do here is to exit the VM.\n-    fatal_exception(JVMCIENV, \"Exception during JVMCI compiler initialization\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":51,"deletions":39,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -282,1 +282,3 @@\n-  JNIEnv* init_shared_library_javavm();\n+  \/\/ If this method tried to create the JavaVM but failed, the error code returned\n+  \/\/ by JNI_CreateJavaVM is returned in create_JavaVM_err.\n+  JNIEnv* init_shared_library_javavm(int* create_JavaVM_err);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}