{"files":[{"patch":"@@ -236,1 +236,1 @@\n-        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" \\\"%s\\\"]:%*c\", level, p2i(thread), thread->name(), level, ' ');\n@@ -241,1 +241,1 @@\n-        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" <%s>]:%*c\", level, p2i(thread), thread->type_name(), level, ' ');\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  _ok_upcalls = 0;\n+  _err_upcalls = 0;\n+  _disabled = false;\n@@ -121,0 +124,3 @@\n+  if (_disabled) {\n+    return true;\n+  }\n@@ -214,0 +220,33 @@\n+void JVMCICompiler::on_upcall(const char* error, JVMCICompileState* compile_state) {\n+  if (error != nullptr) {\n+\n+    Atomic::inc(&_err_upcalls);\n+    int ok = _ok_upcalls;\n+    int err = _err_upcalls;\n+    \/\/ If there have been at least 10 upcalls with an error\n+    \/\/ and the number of error upcalls is 10% or more of the\n+    \/\/ number of non-error upcalls, disable JVMCI compilation.\n+    if (err > 10 && err * 10 > ok && !_disabled) {\n+      _disabled = true;\n+      int total = err + ok;\n+      const char* disable_msg = err_msg(\"JVMCI compiler disabled \"\n+      \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n+      \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      log_warning(jit,compilation)(\"%s\", disable_msg);\n+      if (compile_state != nullptr) {\n+        const char* disable_error = os::strdup(disable_msg);\n+        if (disable_error != nullptr) {\n+          compile_state->set_failure(true, disable_error, true);\n+          JVMCI_event_1(\"%s\", disable_error);\n+          return;\n+        } else {\n+          \/\/ Leave failure reason as set by caller when strdup fails\n+        }\n+      }\n+    }\n+    JVMCI_event_1(\"JVMCI upcall had an error: %s\", error);\n+  } else {\n+    Atomic::inc(&_ok_upcalls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+class JVMCICompileState;\n+\n@@ -65,1 +67,1 @@\n-   * JVMCICompiler::compile_method().\n+   * JVMCIRuntime::compile_method().\n@@ -69,0 +71,10 @@\n+  \/\/ Tracks upcalls that should only fail under severe conditions (e.g.\n+  \/\/ memory pressure) and disables JVMCI compilation if too many fail\n+  \/\/ with an error. A good example is an OOME thrown\n+  \/\/ when libgraal calls into the HotSpot heap to get a copy\n+  \/\/ of the system properties or to translate an exception from\n+  \/\/ the HotSpot heap to the libgraal heap.\n+  volatile int _ok_upcalls;\n+  volatile int _err_upcalls;\n+  bool _disabled;\n+\n@@ -129,0 +141,5 @@\n+  \/\/ Called after a JVMCI upcall whose success is a measure of the\n+  \/\/ JVMCI compiler's health. The value of `error` describes\n+  \/\/ an error during the upcall, null if no error.\n+  void on_upcall(const char* error, JVMCICompileState* compile_state=nullptr);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2402,1 +2402,2 @@\n-    JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);\n+    bool jni_enomem_is_fatal = false;\n+    JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2404,0 +2405,3 @@\n+    if (peerEnv->has_jni_enomem()) {\n+      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+    }\n@@ -2566,1 +2570,2 @@\n-      JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);\n+      bool jni_enomem_is_fatal = false;\n+      JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2568,0 +2573,4 @@\n+      if (peerJVMCIEnv->has_jni_enomem()) {\n+        JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+      }\n+\n@@ -2661,1 +2670,2 @@\n-  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), __FILE__, __LINE__);\n+  bool jni_enomem_is_fatal = false;\n+  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2664,0 +2674,3 @@\n+  if (peerEnv->has_jni_enomem()) {\n+      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,0 +70,15 @@\n+void JVMCICompileState::set_failure(bool retryable, const char* reason, bool reason_on_C_heap) {\n+  if (_failure_reason != nullptr && _failure_reason_on_C_heap) {\n+      os::free((void*) _failure_reason);\n+  }\n+  _failure_reason = reason;\n+  _failure_reason_on_C_heap = reason_on_C_heap;\n+  _retryable = retryable;\n+}\n+\n+void JVMCICompileState::notify_libjvmci_oome() {\n+  const char* msg = \"Out of memory initializing libjvmci or attaching it to the current thread\";\n+  set_failure(true, msg);\n+  _compiler->on_upcall(msg);\n+}\n+\n@@ -175,1 +190,1 @@\n-void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool attach_OOME_is_fatal) {\n+void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal) {\n@@ -207,2 +222,2 @@\n-  _env = _runtime->init_shared_library_javavm();\n-\n+  int create_JavaVM_err = JNI_OK;\n+  _env = _runtime->init_shared_library_javavm(&create_JavaVM_err);\n@@ -212,0 +227,7 @@\n+  } else if (create_JavaVM_err != JNI_OK) {\n+    if (!jni_enomem_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n+      _jni_enomem = true;\n+      return;\n+    } else {\n+      fatal(\"JNI_CreateJavaVM failed with return value %d\", create_JavaVM_err);\n+    }\n@@ -230,1 +252,1 @@\n-      } else if (!attach_OOME_is_fatal && attach_result == JNI_ENOMEM) {\n+      } else if (!jni_enomem_is_fatal && attach_result == JNI_ENOMEM) {\n@@ -232,1 +254,1 @@\n-        _attach_threw_OOME = true;\n+        _jni_enomem = true;\n@@ -254,5 +276,6 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(compile_state) {\n-  \/\/ In case of OOME, there's a good chance a subsequent attempt to attach might succeed.\n-  \/\/ Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n-  init_env_mode_runtime(thread, nullptr, false);\n-  if (_attach_threw_OOME) {\n+    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(compile_state) {\n+  \/\/ In case of JNI_ENOMEM, there's a good chance a subsequent attempt to create libjvmci or attach to it\n+  \/\/ might succeed. Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n+  bool jni_enomem_is_fatal = false;\n+  init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n+  if (_jni_enomem) {\n@@ -264,1 +287,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n@@ -269,1 +292,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n@@ -274,1 +297,1 @@\n-void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n+void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n@@ -279,1 +302,1 @@\n-  _attach_threw_OOME = false;\n+  _jni_enomem = false;\n@@ -287,1 +310,1 @@\n-    init_env_mode_runtime(thread, nullptr);\n+    init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n@@ -467,1 +490,1 @@\n-  if (_attach_threw_OOME) {\n+  if (_jni_enomem) {\n@@ -778,0 +801,1 @@\n+DO_THROW(OutOfMemoryError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":40,"deletions":16,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -140,5 +140,5 @@\n-  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {\n-    _failure_reason = reason;\n-    _failure_reason_on_C_heap = reason_on_C_heap;\n-    _retryable = retryable;\n-  }\n+  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false);\n+\n+  \/\/ Called when creating or attaching to a libjvmci isolate failed\n+  \/\/ due to an out of memory condition.\n+  void notify_libjvmci_oome();\n@@ -160,1 +160,1 @@\n-  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool attach_OOME_is_fatal = true);\n+  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal = true);\n@@ -162,1 +162,1 @@\n-  void init(JavaThread* thread, bool is_hotspot, const char* file, int line);\n+  void init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line);\n@@ -172,1 +172,3 @@\n-  bool    _attach_threw_OOME;    \/\/ Failed to attach thread due to OutOfMemoryError, the JVMCIEnv is invalid\n+  bool             _jni_enomem;  \/\/ JNI_ENOMEM returned when creating or attaching to a libjvmci isolate.\n+                                 \/\/ If true, the JVMCIEnv is invalid and should not be used apart from\n+                                 \/\/ calling has_jni_enomem().\n@@ -215,1 +217,2 @@\n-    init(thread, for_object.is_hotspot(), file, line);\n+    bool jni_enomem_is_fatal = true;\n+    init(thread, for_object.is_hotspot(), jni_enomem_is_fatal, file, line);\n@@ -221,2 +224,2 @@\n-  JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n-    init(thread, is_hotspot, file, line);\n+  JVMCIEnv(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n+    init(thread, is_hotspot, jni_enomem_is_fatal, file, line);\n@@ -227,0 +230,6 @@\n+  \/\/ Determines if a JNI_ENOMEM occurred while trying to create a libjvmci\n+  \/\/ isolate or attach to it within the scope of a JVMCIEnv constructor.\n+  bool has_jni_enomem() {\n+    return _jni_enomem;\n+  }\n+\n@@ -252,1 +261,3 @@\n-  \/\/ Prints an exception and stack trace of a pending exception.\n+  \/\/ Prints the toString() and stack trace of a pending exception.\n+  \/\/ If there is no pending exception, this is a nop.\n+  \/\/ If `clear` is false, the pending exception will remain pending upon return.\n@@ -359,0 +370,1 @@\n+  DO_THROW(OutOfMemoryError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -247,0 +247,3 @@\n+  start_class(OutOfMemoryError, java_lang_OutOfMemoryError)                                                         \\\n+    jvmci_constructor(OutOfMemoryError, \"(Ljava\/lang\/String;)V\")                                                 \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -1228,1 +1229,1 @@\n-JNIEnv* JVMCIRuntime::init_shared_library_javavm() {\n+JNIEnv* JVMCIRuntime::init_shared_library_javavm(int* create_JavaVM_err) {\n@@ -1232,0 +1233,6 @@\n+    const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.forceEnomemOnLibjvmciInit\");\n+    if (val != nullptr && strcmp(val, \"true\") == 0) {\n+      *create_JavaVM_err = JNI_ENOMEM;\n+      return nullptr;\n+    }\n+\n@@ -1278,1 +1285,1 @@\n-      fatal(\"JNI_CreateJavaVM failed with return value %d\", result);\n+      *create_JavaVM_err = result;\n@@ -1464,0 +1471,1 @@\n+        JVMCI_event_1(\"error initializing system properties for JVMCI runtime %d\", _id);\n@@ -1551,0 +1559,1 @@\n+    bool jni_enomem_is_fatal = true;\n@@ -1552,1 +1561,1 @@\n-    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);\n+    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -1980,0 +1989,28 @@\n+\/\/ Called after an upcall to `function` while compiling `method`.\n+\/\/ If an exception occurred, it is cleared, the compilation state\n+\/\/ is updated with the failure and this method returns true.\n+\/\/ Otherwise, it returns false.\n+static bool after_compiler_upcall(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle& method, const char* function) {\n+  if (JVMCIENV->has_pending_exception()) {\n+    bool reason_on_C_heap = true;\n+    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s\", function), mtJVMCI);\n+    if (failure_reason == nullptr) {\n+      failure_reason = \"uncaught exception\";\n+      reason_on_C_heap = false;\n+    }\n+    Log(jit, compilation) log;\n+    if (log.is_info()) {\n+      ResourceMark rm;\n+      log.info(\"%s while compiling %s\", failure_reason, method->name_and_sig_as_C_string());\n+      JVMCIENV->describe_pending_exception(true);\n+    } else {\n+      JVMCIENV->clear_pending_exception();\n+    }\n+    JVMCICompileState* compile_state = JVMCIENV->compile_state();\n+    compile_state->set_failure(true, failure_reason, reason_on_C_heap);\n+    compiler->on_upcall(failure_reason, compile_state);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2005,7 +2042,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_HotSpotJVMCIRuntime\")) {\n@@ -2015,7 +2046,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception getting JVMCI wrapper method\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_jvmci_method\")) {\n@@ -2027,18 +2052,16 @@\n-  if (!JVMCIENV->has_pending_exception()) {\n-    if (result_object.is_non_null()) {\n-      JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n-      if (failure_message.is_non_null()) {\n-        \/\/ Copy failure reason into resource memory first ...\n-        const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n-        \/\/ ... and then into the C heap.\n-        failure_reason = os::strdup(failure_reason, mtJVMCI);\n-        bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n-        compile_state->set_failure(retryable, failure_reason, true);\n-      } else {\n-        if (!compile_state->task()->is_success()) {\n-          compile_state->set_failure(true, \"no nmethod produced\");\n-        } else {\n-          compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n-          compiler->inc_methods_compiled();\n-        }\n-      }\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"call_HotSpotJVMCIRuntime_compileMethod\")) {\n+    return;\n+  }\n+  compiler->on_upcall(nullptr);\n+  guarantee(result_object.is_non_null(), \"call_HotSpotJVMCIRuntime_compileMethod returned null\");\n+  JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n+  if (failure_message.is_non_null()) {\n+    \/\/ Copy failure reason into resource memory first ...\n+    const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n+    \/\/ ... and then into the C heap.\n+    failure_reason = os::strdup(failure_reason, mtJVMCI);\n+    bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n+    compile_state->set_failure(retryable, failure_reason, true);\n+  } else {\n+    if (!compile_state->task()->is_success()) {\n+      compile_state->set_failure(true, \"no nmethod produced\");\n@@ -2046,1 +2069,2 @@\n-      assert(false, \"JVMCICompiler.compileMethod should always return non-null\");\n+      compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n+      compiler->inc_methods_compiled();\n@@ -2048,4 +2072,0 @@\n-  } else {\n-    \/\/ An uncaught exception here implies failure during compiler initialization.\n-    \/\/ The only sensible thing to do here is to exit the VM.\n-    fatal_exception(JVMCIENV, \"Exception during JVMCI compiler initialization\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":60,"deletions":40,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -282,1 +282,3 @@\n-  JNIEnv* init_shared_library_javavm();\n+  \/\/ If this method tried to create the JavaVM but failed, the error code returned\n+  \/\/ by JNI_CreateJavaVM is returned in create_JavaVM_err.\n+  JNIEnv* init_shared_library_javavm(int* create_JavaVM_err);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib \/\n@@ -49,0 +50,2 @@\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -125,0 +128,50 @@\n+\n+    \/**\n+     * Test program that calls into the VM and expects an {@code OutOfMemoryError} to be\n+     * raised when {@code test.jvmci.forceEnomemOnLibjvmciInit == true}.\n+     *\n+     * For example:\n+     * <pre>\n+     * Exception in thread \"main\" java.lang.OutOfMemoryError: JNI_ENOMEM creating or attaching to libjvmci\n+     *    at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVM.attachCurrentThread(Native Method)\n+     *    at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.attachCurrentThread(HotSpotJVMCIRuntime.java:1385)\n+     *    at jdk.vm.ci.hotspot.test.TestHotSpotJVMCIRuntime$JNIEnomemVMCall.main(TestHotSpotJVMCIRuntime.java:133)\n+     * <\/pre>\n+     *\/\n+    public static class JNIEnomemVMCall {\n+        public static void main(String[] args) {\n+            String name = args[0];\n+            HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();\n+            MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();\n+            if (name.equals(\"translate\")) {\n+                runtime.translate(\"object\");\n+            } else if (name.equals(\"attachCurrentThread\")) {\n+                runtime.attachCurrentThread(false, null);\n+            } else if (name.equals(\"registerNativeMethods\")) {\n+                runtime.registerNativeMethods(JNIEnomemVMCall.class);\n+            } else {\n+                throw new InternalError(\"Unknown method: \" + name);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void jniEnomemTest() throws Exception {\n+        String[] names = {\"translate\", \"attachCurrentThread\", \"registerNativeMethods\"};\n+        for (String name : names) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+EnableJVMCI\",\n+                \"-XX:-UseJVMCICompiler\",\n+                \"-XX:+UseJVMCINativeLibrary\",\n+                \"-Dtest.jvmci.forceEnomemOnLibjvmciInit=true\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.services=ALL-UNNAMED\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.runtime=ALL-UNNAMED\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED\",\n+                \"-Xbootclasspath\/a:.\",\n+                JNIEnomemVMCall.class.getName(), name);\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.shouldContain(\"java.lang.OutOfMemoryError: JNI_ENOMEM creating or attaching to libjvmci\");\n+            output.shouldNotHaveExitValue(0);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"}]}