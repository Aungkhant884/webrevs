{"files":[{"patch":"@@ -236,1 +236,1 @@\n-        tty->print(\"JVMCITrace-%d[%s]:%*c\", level, thread->name(), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" \\\"%s\\\"]:%*c\", level, p2i(thread), thread->name(), level, ' ');\n@@ -241,1 +241,1 @@\n-        tty->print(\"JVMCITrace-%d[%s@\" PTR_FORMAT \"]:%*c\", level, thread->type_name(), p2i(thread), level, ' ');\n+        tty->print(\"JVMCITrace-%d[\" PTR_FORMAT \" <%s>]:%*c\", level, p2i(thread), thread->type_name(), level, ' ');\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+  _ok_upcalls = 0;\n+  _err_upcalls = 0;\n+  _disabled = false;\n@@ -121,0 +124,3 @@\n+  if (_disabled) {\n+    return true;\n+  }\n@@ -214,0 +220,33 @@\n+void JVMCICompiler::on_upcall(const char* error, JVMCICompileState* compile_state) {\n+  if (error != nullptr) {\n+\n+    Atomic::inc(&_err_upcalls);\n+    int ok = _ok_upcalls;\n+    int err = _err_upcalls;\n+    \/\/ If there have been at least 10 upcalls with an error\n+    \/\/ and the number of error upcalls is 10% or more of the\n+    \/\/ number of non-error upcalls, disable JVMCI compilation.\n+    if (err > 10 && err * 10 > ok && !_disabled) {\n+      _disabled = true;\n+      int total = err + ok;\n+      const char* disable_msg = err_msg(\"JVMCI compiler disabled \"\n+      \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n+      \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      log_warning(jit,compilation)(\"%s\", disable_msg);\n+      if (compile_state != nullptr) {\n+        const char* disable_error = os::strdup(disable_msg);\n+        if (disable_error != nullptr) {\n+          compile_state->set_failure(true, disable_error, true);\n+          JVMCI_event_1(\"%s\", disable_error);\n+          return;\n+        } else {\n+          \/\/ Leave failure reason as set by caller when strdup fails\n+        }\n+      }\n+    }\n+    JVMCI_event_1(\"JVMCI upcall had an error: %s\", error);\n+  } else {\n+    Atomic::inc(&_ok_upcalls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class JVMCICompileState;\n+\n@@ -65,1 +67,1 @@\n-   * JVMCICompiler::compile_method().\n+   * JVMCIRuntime::compile_method().\n@@ -69,0 +71,10 @@\n+  \/\/ Tracks upcalls that should only fail under severe conditions (e.g.\n+  \/\/ memory pressure) and disables JVMCI compilation if too many fail\n+  \/\/ with an error. A good example is an OOME thrown\n+  \/\/ when libgraal calls into the HotSpot heap to get a copy\n+  \/\/ of the system properties or to translate an exception from\n+  \/\/ the HotSpot heap to the libgraal heap.\n+  volatile int _ok_upcalls;\n+  volatile int _err_upcalls;\n+  bool _disabled;\n+\n@@ -129,0 +141,5 @@\n+  \/\/ Called after a JVMCI upcall whose success is a measure of the\n+  \/\/ JVMCI compiler's health. The value of `error` describes\n+  \/\/ an error during the upcall, null if no error.\n+  void on_upcall(const char* error, JVMCICompileState* compile_state=nullptr);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2407,1 +2407,1 @@\n-      peerEnv->describe_pending_exception(true);\n+      peerEnv->describe_pending_exception(tty);\n@@ -2571,1 +2571,1 @@\n-        peerJVMCIEnv->describe_pending_exception(true);\n+        peerJVMCIEnv->describe_pending_exception(tty);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,15 @@\n+void JVMCICompileState::set_failure(bool retryable, const char* reason, bool reason_on_C_heap) {\n+  if (_failure_reason != nullptr && _failure_reason_on_C_heap) {\n+      os::free((void*) _failure_reason);\n+  }\n+  _failure_reason = reason;\n+  _failure_reason_on_C_heap = reason_on_C_heap;\n+  _retryable = retryable;\n+}\n+\n+void JVMCICompileState::notify_libjvmci_oome() {\n+  const char* msg = \"Out of memory initializing libjvmci or attaching it to the current thread\";\n+  set_failure(true, msg);\n+  _compiler->on_upcall(msg);\n+}\n+\n@@ -175,1 +190,1 @@\n-void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool attach_OOME_is_fatal) {\n+void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool OOME_is_fatal) {\n@@ -207,2 +222,2 @@\n-  _env = _runtime->init_shared_library_javavm();\n-\n+  int create_JavaVM_err = JNI_OK;\n+  _env = _runtime->init_shared_library_javavm(&create_JavaVM_err);\n@@ -212,0 +227,7 @@\n+  } else if (create_JavaVM_err != JNI_OK) {\n+    if (!OOME_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n+      _threw_OOME = true;\n+      return;\n+    } else {\n+      fatal(\"JNI_CreateJavaVM failed with return value %d\", create_JavaVM_err);\n+    }\n@@ -230,1 +252,1 @@\n-      } else if (!attach_OOME_is_fatal && attach_result == JNI_ENOMEM) {\n+      } else if (!OOME_is_fatal && attach_result == JNI_ENOMEM) {\n@@ -232,1 +254,1 @@\n-        _attach_threw_OOME = true;\n+        _threw_OOME = true;\n@@ -254,3 +276,3 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(compile_state) {\n-  \/\/ In case of OOME, there's a good chance a subsequent attempt to attach might succeed.\n-  \/\/ Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n+    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(compile_state) {\n+  \/\/ In case of OOME, there's a good chance a subsequent attempt to create libjvmci or attach to it\n+  \/\/ might succeed. Other errors most likely indicate a non-recoverable error in the JVMCI runtime.\n@@ -258,1 +280,1 @@\n-  if (_attach_threw_OOME) {\n+  if (_threw_OOME) {\n@@ -264,1 +286,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n@@ -269,1 +291,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n@@ -279,1 +301,1 @@\n-  _attach_threw_OOME = false;\n+  _threw_OOME = false;\n@@ -291,2 +313,35 @@\n-\/\/ Prints a pending exception (if any) and its stack trace.\n-void JVMCIEnv::describe_pending_exception(bool clear) {\n+\/\/ Prints a pending exception (if any) and its stack trace to st.\n+\/\/ Also partially logs the stack trace to the JVMCI event log.\n+void JVMCIEnv::describe_pending_exception(outputStream* st) {\n+  char* stack_trace = nullptr;\n+  if (pending_exception_as_string(nullptr, (const char**) &stack_trace)) {\n+    st->print_raw_cr(stack_trace);\n+\n+    \/\/ Use up to half the lines of the JVMCI event log to\n+    \/\/ show the stack trace.\n+    char* cursor = stack_trace;\n+    int line = 0;\n+    const int max_lines = LogEventsBufferEntries \/ 2;\n+    while (*cursor != '\\0') {\n+      char* eol = strchr(cursor, '\\n');\n+      if (eol == nullptr) {\n+        if (line < max_lines) {\n+          JVMCI_event_1(\"%s\", cursor);\n+        }\n+        cursor = cursor + strlen(cursor);\n+      } else {\n+        *eol = '\\0';\n+        if (line < max_lines) {\n+          JVMCI_event_1(\"%s\", cursor);\n+        }\n+        cursor = eol + 1;\n+      }\n+      line++;\n+    }\n+    if (line >= max_lines) {\n+      JVMCI_event_1(\"[elided %d more stack trace lines]\", line - max_lines);\n+    }\n+  }\n+}\n+\n+bool JVMCIEnv::pending_exception_as_string(const char** to_string, const char** stack_trace) {\n@@ -294,0 +349,3 @@\n+  JVMCIObject to_string_obj;\n+  JVMCIObject stack_trace_obj;\n+  bool had_nested_exception = false;\n@@ -296,5 +354,21 @@\n-    if (jni()->ExceptionCheck()) {\n-      jthrowable ex = !clear ? jni()->ExceptionOccurred() : nullptr;\n-      jni()->ExceptionDescribe();\n-      if (ex != nullptr) {\n-        jni()->Throw(ex);\n+    jthrowable ex = jni()->ExceptionOccurred();\n+    if (ex != NULL) {\n+      jni()->ExceptionClear();\n+      jobjectArray pair = (jobjectArray) jni()->CallStaticObjectMethod(\n+        JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+        JNIJVMCI::HotSpotJVMCIRuntime::exceptionToString_method(),\n+        ex, to_string != nullptr, stack_trace != nullptr);\n+      if (jni()->ExceptionCheck()) {\n+        \/\/ As last resort, dump nested exception\n+        jni()->ExceptionDescribe();\n+        had_nested_exception = true;\n+      } else {\n+        guarantee(pair != nullptr, \"pair is null\");\n+        int len = jni()->GetArrayLength(pair);\n+        guarantee(len == 2, \"bad len is %d\", len);\n+        if (to_string != nullptr) {\n+          to_string_obj = JVMCIObject::create(jni()->GetObjectArrayElement(pair, 0), false);\n+        }\n+        if (stack_trace != nullptr) {\n+          stack_trace_obj = JVMCIObject::create(jni()->GetObjectArrayElement(pair, 1), false);\n+        }\n@@ -302,0 +376,2 @@\n+    } else {\n+      return false;\n@@ -305,1 +381,48 @@\n-      JVMCIRuntime::describe_pending_hotspot_exception(THREAD, clear);\n+      Handle exception(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      JavaCallArguments jargs;\n+      jargs.push_oop(exception);\n+      jargs.push_int(to_string != nullptr);\n+      jargs.push_int(stack_trace != nullptr);\n+      JavaValue result(T_OBJECT);\n+      JavaCalls::call_static(&result,\n+                              HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                              vmSymbols::exceptionToString_name(),\n+                              vmSymbols::exceptionToString_signature(), &jargs, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        Handle nested_exception(THREAD, PENDING_EXCEPTION);\n+        CLEAR_PENDING_EXCEPTION;\n+        java_lang_Throwable::print_stack_trace(nested_exception, tty);\n+        \/\/ Clear and ignore any exceptions raised during printing\n+        CLEAR_PENDING_EXCEPTION;\n+        had_nested_exception = true;\n+      } else {\n+        oop pair = result.get_oop();\n+        guarantee(pair->is_objArray(), \"must be\");\n+        objArrayOop pair_arr = objArrayOop(pair);\n+        int len = pair_arr->length();\n+        guarantee(len == 2, \"bad len is %d\", len);\n+        if (to_string != nullptr) {\n+          to_string_obj = HotSpotJVMCI::wrap(pair_arr->obj_at(0));\n+        }\n+        if (stack_trace != nullptr) {\n+          stack_trace_obj = HotSpotJVMCI::wrap(pair_arr->obj_at(1));\n+        }\n+      }\n+    } else {\n+      return false;\n+    }\n+  }\n+  if (had_nested_exception) {\n+    if (to_string != nullptr) {\n+      *to_string = \"nested exception occurred converting exception to string\";\n+    }\n+    if (stack_trace != nullptr) {\n+      *stack_trace = \"nested exception occurred converting exception stack to string\";\n+    }\n+  } else {\n+    if (to_string_obj.is_non_null()) {\n+      *to_string = as_utf8_string(to_string_obj);\n+    }\n+    if (stack_trace_obj.is_non_null()) {\n+      *stack_trace = as_utf8_string(stack_trace_obj);\n@@ -308,0 +431,1 @@\n+  return true;\n@@ -310,0 +434,1 @@\n+\n@@ -467,1 +592,1 @@\n-  if (_attach_threw_OOME) {\n+  if (_threw_OOME) {\n@@ -751,2 +876,3 @@\n-    int length = jni()->GetStringLength(str.as_jstring());\n-    int utf8_length = jni()->GetStringUTFLength(str.as_jstring());\n+    jstring jstr = str.as_jstring();\n+    int length = jni()->GetStringLength(jstr);\n+    int utf8_length = jni()->GetStringUTFLength(jstr);\n@@ -754,1 +880,1 @@\n-    jni()->GetStringUTFRegion(str.as_jstring(), 0, length, result);\n+    jni()->GetStringUTFRegion(jstr, 0, length, result);\n@@ -883,1 +1009,1 @@\n-    describe_pending_exception(true);\n+    describe_pending_exception(tty);\n@@ -939,24 +1065,0 @@\n-\n-JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {\n-  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n-  if (is_hotspot()) {\n-    JavaCallArguments jargs;\n-    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-                           HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n-                           vmSymbols::callToString_name(),\n-                           vmSymbols::callToString_signature(), &jargs, CHECK_(JVMCIObject()));\n-    return wrap(result.get_oop());\n-  } else {\n-    JNIAccessMark jni(this, THREAD);\n-    jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n-                                                     JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),\n-                                                     object.as_jobject());\n-    if (jni()->ExceptionCheck()) {\n-      return JVMCIObject();\n-    }\n-    return wrap(result);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":151,"deletions":49,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -140,5 +140,5 @@\n-  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {\n-    _failure_reason = reason;\n-    _failure_reason_on_C_heap = reason_on_C_heap;\n-    _retryable = retryable;\n-  }\n+  void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false);\n+\n+  \/\/ Called when creating or attaching to a libjvmci isolate failed\n+  \/\/ due to an out of memory condition.\n+  void notify_libjvmci_oome();\n@@ -172,1 +172,1 @@\n-  bool    _attach_threw_OOME;    \/\/ Failed to attach thread due to OutOfMemoryError, the JVMCIEnv is invalid\n+  bool             _threw_OOME;  \/\/ OOME trying to create a libjvmci isolate or attach to it; the JVMCIEnv is invalid\n@@ -252,2 +252,10 @@\n-  \/\/ Prints an exception and stack trace of a pending exception.\n-  void describe_pending_exception(bool clear);\n+  \/\/ Prints the stack trace of a pending exception to `st` and clears the exception.\n+  \/\/ If there is no pending exception, this is a nop.\n+  void describe_pending_exception(outputStream* st);\n+\n+  \/\/ Gets the output of calling toString and\/or printStactTrace on the pending exception.\n+  \/\/ If to_string is not null, the output of toString is returned in it.\n+  \/\/ If stack_trace is not null, the output of printStackTrace is returned in it.\n+  \/\/ Returns false if there is no pending exception otherwise clears the pending\n+  \/\/ exception and returns true.\n+  bool pending_exception_as_string(const char** to_string, const char** stack_trace);\n@@ -334,2 +342,0 @@\n-  JVMCIObject call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCI_TRAPS);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    JVMCIENV->describe_pending_exception(true);  \\\n+    JVMCIENV->describe_pending_exception(tty);   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciExceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, callToString, callToString_signature, (JVMCIObject object, JVMCI_TRAPS)) \\\n+    jvmci_method(CallStaticObjectMethod, GetStaticMethodID, call_static, JVMCIObject, HotSpotJVMCIRuntime, exceptionToString, exceptionToString_signature, (JVMCIObject object, bool toString, bool stackTrace, JVMCI_TRAPS)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -1228,1 +1229,1 @@\n-JNIEnv* JVMCIRuntime::init_shared_library_javavm() {\n+JNIEnv* JVMCIRuntime::init_shared_library_javavm(int* create_JavaVM_err) {\n@@ -1278,1 +1279,1 @@\n-      fatal(\"JNI_CreateJavaVM failed with return value %d\", result);\n+      *create_JavaVM_err = result;\n@@ -1464,0 +1465,1 @@\n+        JVMCI_event_1(\"error initializing system properties for JVMCI runtime %d\", _id);\n@@ -1604,1 +1606,1 @@\n-void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {\n+void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD) {\n@@ -1607,2 +1609,0 @@\n-    const char* exception_file = THREAD->exception_file();\n-    int exception_line = THREAD->exception_line();\n@@ -1614,3 +1614,0 @@\n-    if (!clear) {\n-      THREAD->set_pending_exception(exception(), exception_file, exception_line);\n-    }\n@@ -1629,1 +1626,1 @@\n-      JVMCIENV->describe_pending_exception(true);\n+      JVMCIENV->describe_pending_exception(tty);\n@@ -1631,1 +1628,1 @@\n-      describe_pending_hotspot_exception(THREAD, true);\n+      describe_pending_hotspot_exception(THREAD);\n@@ -1634,1 +1631,1 @@\n-    \/\/ Allow error reporting thread to print the stack trace.\n+    \/\/ Allow error reporting thread time to print the stack trace.\n@@ -1980,0 +1977,34 @@\n+\/\/ Called after an upcall to `function` while compiling `method`.\n+\/\/ If an exception occurred, it is cleared, the compilation state\n+\/\/ is updated with the failure and this method returns true.\n+\/\/ Otherwise, it returns false.\n+static bool after_compiler_upcall(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle& method, const char* function) {\n+  if (JVMCIENV->has_pending_exception()) {\n+    bool reason_on_C_heap = true;\n+    const char* pending_string = nullptr;\n+    const char* pending_stack_trace = nullptr;\n+    JVMCIENV->pending_exception_as_string(&pending_string, &pending_stack_trace);\n+    if (pending_string == nullptr) pending_string = \"null\";\n+    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s [%s]\", function, pending_string), mtJVMCI);\n+    if (failure_reason == nullptr) {\n+      failure_reason = \"uncaught exception\";\n+      reason_on_C_heap = false;\n+    }\n+    JVMCI_event_1(\"%s\", failure_reason);\n+    Log(jit, compilation) log;\n+    if (log.is_info()) {\n+      ResourceMark rm;\n+      log.info(\"%s while compiling %s\", failure_reason, method->name_and_sig_as_C_string());\n+      if (pending_stack_trace != nullptr) {\n+        LogStream ls(log.info());\n+        ls.print_raw_cr(pending_stack_trace);\n+      }\n+    }\n+    JVMCICompileState* compile_state = JVMCIENV->compile_state();\n+    compile_state->set_failure(true, failure_reason, reason_on_C_heap);\n+    compiler->on_upcall(failure_reason, compile_state);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2005,7 +2036,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"HotSpotJVMCIRuntime initialization failed when compiling %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception during HotSpotJVMCIRuntime initialization\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_HotSpotJVMCIRuntime\")) {\n@@ -2015,7 +2040,1 @@\n-  if (JVMCIENV->has_pending_exception()) {\n-    if (PrintWarnings) {\n-      ResourceMark rm(thread);\n-      warning(\"Error creating JVMCI wrapper for %s\", method->name_and_sig_as_C_string());\n-      JVMCIENV->describe_pending_exception(true);\n-    }\n-    compile_state->set_failure(false, \"exception getting JVMCI wrapper method\");\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"get_jvmci_method\")) {\n@@ -2027,18 +2046,21 @@\n-  if (!JVMCIENV->has_pending_exception()) {\n-    if (result_object.is_non_null()) {\n-      JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n-      if (failure_message.is_non_null()) {\n-        \/\/ Copy failure reason into resource memory first ...\n-        const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n-        \/\/ ... and then into the C heap.\n-        failure_reason = os::strdup(failure_reason, mtJVMCI);\n-        bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n-        compile_state->set_failure(retryable, failure_reason, true);\n-      } else {\n-        if (!compile_state->task()->is_success()) {\n-          compile_state->set_failure(true, \"no nmethod produced\");\n-        } else {\n-          compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n-          compiler->inc_methods_compiled();\n-        }\n-      }\n+#ifdef ASSERT\n+  if (JVMCIENV->has_pending_exception() && JVMCICompileMethodExceptionIsFatal) {\n+    fatal_exception(JVMCIENV, \"testing JVMCI fatal exception handling\");\n+  }\n+#endif\n+  if (after_compiler_upcall(JVMCIENV, compiler, method, \"call_HotSpotJVMCIRuntime_compileMethod\")) {\n+    return;\n+  }\n+  compiler->on_upcall(nullptr);\n+  guarantee(result_object.is_non_null(), \"call_HotSpotJVMCIRuntime_compileMethod returned null\");\n+  JVMCIObject failure_message = JVMCIENV->get_HotSpotCompilationRequestResult_failureMessage(result_object);\n+  if (failure_message.is_non_null()) {\n+    \/\/ Copy failure reason into resource memory first ...\n+    const char* failure_reason = JVMCIENV->as_utf8_string(failure_message);\n+    \/\/ ... and then into the C heap.\n+    failure_reason = os::strdup(failure_reason, mtJVMCI);\n+    bool retryable = JVMCIENV->get_HotSpotCompilationRequestResult_retry(result_object) != 0;\n+    compile_state->set_failure(retryable, failure_reason, true);\n+  } else {\n+    if (!compile_state->task()->is_success()) {\n+      compile_state->set_failure(true, \"no nmethod produced\");\n@@ -2046,1 +2068,2 @@\n-      assert(false, \"JVMCICompiler.compileMethod should always return non-null\");\n+      compile_state->task()->set_num_inlined_bytecodes(JVMCIENV->get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));\n+      compiler->inc_methods_compiled();\n@@ -2048,4 +2071,0 @@\n-  } else {\n-    \/\/ An uncaught exception here implies failure during compiler initialization.\n-    \/\/ The only sensible thing to do here is to exit the VM.\n-    fatal_exception(JVMCIENV, \"Exception during JVMCI compiler initialization\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":67,"deletions":48,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -282,1 +282,3 @@\n-  JNIEnv* init_shared_library_javavm();\n+  \/\/ If this method tried to create the JavaVM but failed, the error code returned\n+  \/\/ by JNI_CreateJavaVM is returned in create_JavaVM_err.\n+  JNIEnv* init_shared_library_javavm(int* create_JavaVM_err);\n@@ -470,1 +472,1 @@\n-  static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);\n+  static void describe_pending_hotspot_exception(JavaThread* THREAD);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  CHECK_NOT_SET(JVMCICompileMethodExceptionIsFatal,  EnableJVMCI)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+  notproduct(bool, JVMCICompileMethodExceptionIsFatal, false,               \\\n+          \"An exception thrown by HotSpotJVMCIRuntime::compileMethod \"      \\\n+          \"is fatal. Used to test error handling only.\")                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-  template(callToString_name,                                     \"callToString\")                                                         \\\n-  template(callToString_signature,                                \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\")                               \\\n+  template(exceptionToString_name,                                \"exceptionToString\")                                                    \\\n+  template(exceptionToString_signature,                           \"(Ljava\/lang\/Throwable;ZZ)[Ljava\/lang\/String;\")                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -42,0 +43,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -201,2 +203,13 @@\n-    static String callToString(Object o) {\n-        return o.toString();\n+    static String[] exceptionToString(Throwable o, boolean toString, boolean stackTrace) {\n+        String[] res = {null, null};\n+        if (toString) {\n+            res[0] = o.toString();\n+        }\n+        if (stackTrace) {\n+            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+            try (PrintStream ps = new PrintStream(buf)) {\n+                o.printStackTrace(ps);\n+            }\n+            res[1] = buf.toString(StandardCharsets.UTF_8);\n+        }\n+        return res;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+compiler.jvmci.TestUncaughtErrorInCompileMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.config","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests handling of an exception thrown by HotSpotJVMCIRuntime.compileMethod.\n+ * @requires vm.jvmci\n+ * @requires vm.debug\n+ * @library \/test\/lib \/\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.services\n+ * @run driver jdk.test.lib.FileInstaller .\/TestUncaughtErrorInCompileMethod.config\n+ *     .\/META-INF\/services\/jdk.vm.ci.services.JVMCIServiceLocator\n+ * @run driver compiler.jvmci.TestUncaughtErrorInCompileMethod\n+ *\/\n+\n+package compiler.jvmci;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.vm.ci.services.JVMCIServiceLocator;\n+import jdk.vm.ci.runtime.JVMCICompiler;\n+import jdk.vm.ci.runtime.JVMCICompilerFactory;\n+import jdk.vm.ci.runtime.JVMCIRuntime;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestUncaughtErrorInCompileMethod extends JVMCIServiceLocator {\n+\n+    \/**\n+     * Name of file whose existence implies that a JVMCICompiler has been created.\n+     *\/\n+    static String tmpFileName = \"ErrorCompilerCreated.\" + System.nanoTime();\n+\n+    \/**\n+     * @param args if args.length != 0, then executing in subprocess\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            testSubprocess(false);\n+            testSubprocess(true);\n+        } else {\n+            File watch = new File(tmpFileName);\n+            int total = 0;\n+            long start = System.currentTimeMillis();\n+\n+            \/\/ Use a 5 sec timeout just in case the compiler creation fails\n+            while (System.currentTimeMillis() - start < 5000) {\n+                total += getTime();\n+                if (watch.exists()) {\n+                    watch.delete();\n+                    break;\n+                }\n+            }\n+            System.out.println(total);\n+        }\n+    }\n+\n+    private static long getTime() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    static void testSubprocess(boolean fatalError) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+UseJVMCICompiler\", \"-Djvmci.Compiler=ErrorCompiler\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+PrintCompilation\",\n+            \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.services=ALL-UNNAMED\",\n+            \"-XX:\" + (fatalError ? \"+\" : \"-\") + \"JVMCICompileMethodExceptionIsFatal\",\n+            \"-XX:+PrintWarnings\",\n+            \"-Xbootclasspath\/a:.\",\n+            TestUncaughtErrorInCompileMethod.class.getName(), \"true\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        if (fatalError) {\n+            output.shouldContain(\"fatal error: Fatal exception in JVMCI: testing JVMCI fatal exception handling\");\n+            output.shouldNotHaveExitValue(0);\n+            File hs_err_file = openHsErrFileFromOutput(output);\n+            Path hsErrPath = hs_err_file.toPath();\n+            if (!Files.exists(hsErrPath)) {\n+                throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath);\n+            }\n+            String hsErr = Files.readString(hsErrPath);\n+\n+            \/*\n+             * JVMCI Events (11 events):\n+             * ...\n+             * Event: 0.274 Thread 0x0000000146819210 compiler.jvmci.TestUncaughtErrorInCompileMethod$CompilerCreationError\n+             * Event: 0.274 Thread 0x0000000146819210  at compiler.jvmci.TestUncaughtErrorInCompileMethod$1.createCompiler(TestUncaughtErrorInCompileMethod.java:147)\n+             * Event: 0.274 Thread 0x0000000146819210  at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.getCompiler(HotSpotJVMCIRuntime.java:829)\n+             * Event: 0.274 Thread 0x0000000146819210  at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.compileMethod(HotSpotJVMCIRuntime.java:943)\n+             *\/\n+\n+            \/\/ Check that hs-err contains the stack trace of the fatal exception (sample shown above)\n+            String[] stackTraceSubstrings = {\n+                \"at compiler.jvmci.TestUncaughtErrorInCompileMethod$1.createCompiler(TestUncaughtErrorInCompileMethod.java\",\n+                \"at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.compileMethod(HotSpotJVMCIRuntime.java\"\n+            };\n+            for (String expect : stackTraceSubstrings) {\n+                if (!hsErr.contains(expect)) {\n+                    throw new RuntimeException(\"Could not find \\\"\" + expect + \"\\\" in \" + hsErrPath);\n+                }\n+            }\n+        } else {\n+            output.shouldContain(\"COMPILE SKIPPED: uncaught exception in call_HotSpotJVMCIRuntime_compileMethod [compiler.jvmci.TestUncaughtErrorInCompileMethod$CompilerCreationError]\");\n+            output.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    public TestUncaughtErrorInCompileMethod() {\n+    }\n+\n+    static class CompilerCreationError extends InternalError {}\n+\n+    @Override\n+    public <S> S getProvider(Class<S> service) {\n+        if (service == JVMCICompilerFactory.class) {\n+            return service.cast(new JVMCICompilerFactory() {\n+                @Override\n+                public String getCompilerName() {\n+                    return \"ErrorCompiler\";\n+                }\n+\n+                @Override\n+                public JVMCICompiler createCompiler(JVMCIRuntime runtime) {\n+                    File watch = new File(tmpFileName);\n+                    try {\n+                        watch.createNewFile();\n+                    } catch (IOException e) {\n+                        e.printStackTrace();\n+                    }\n+                    throw new CompilerCreationError();\n+                }\n+            });\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Given the output of a java VM that crashed, extract the name of the hs-err file from the output\n+     *\/\n+    public static String extractHsErrFileNameFromOutput(OutputAnalyzer output) {\n+        output.shouldMatch(\"# A fatal error has been detected.*\");\n+\n+        \/\/ extract hs-err file\n+        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+        }\n+\n+        return hs_err_file;\n+    }\n+\n+    \/**\n+     * Given the output of a java VM that crashed, extract the name of the hs-err file from the output,\n+     * open that file and return its File.\n+     *\/\n+    public static File openHsErrFileFromOutput(OutputAnalyzer output) {\n+        String name = extractHsErrFileNameFromOutput(output);\n+        File f = new File(name);\n+        if (!f.exists()) {\n+            throw new RuntimeException(\"Cannot find hs-err file at \" + f.getAbsolutePath());\n+        }\n+        return f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}