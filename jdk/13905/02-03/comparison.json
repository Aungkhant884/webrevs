{"files":[{"patch":"@@ -2402,1 +2402,2 @@\n-    JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);\n+    bool jni_enomem_is_fatal = false;\n+    JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2404,0 +2405,3 @@\n+    if (peerEnv->has_jni_enomem()) {\n+      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+    }\n@@ -2566,1 +2570,2 @@\n-      JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);\n+      bool jni_enomem_is_fatal = false;\n+      JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2568,0 +2573,4 @@\n+      if (peerJVMCIEnv->has_jni_enomem()) {\n+        JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+      }\n+\n@@ -2661,1 +2670,2 @@\n-  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), __FILE__, __LINE__);\n+  bool jni_enomem_is_fatal = false;\n+  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n@@ -2664,0 +2674,3 @@\n+  if (peerEnv->has_jni_enomem()) {\n+      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool OOME_is_fatal) {\n+void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal) {\n@@ -228,2 +228,2 @@\n-    if (!OOME_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n-      _threw_OOME = true;\n+    if (!jni_enomem_is_fatal && create_JavaVM_err == JNI_ENOMEM) {\n+      _jni_enomem = true;\n@@ -252,1 +252,1 @@\n-      } else if (!OOME_is_fatal && attach_result == JNI_ENOMEM) {\n+      } else if (!jni_enomem_is_fatal && attach_result == JNI_ENOMEM) {\n@@ -254,1 +254,1 @@\n-        _threw_OOME = true;\n+        _jni_enomem = true;\n@@ -276,2 +276,2 @@\n-    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(compile_state) {\n-  \/\/ In case of OOME, there's a good chance a subsequent attempt to create libjvmci or attach to it\n+    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(compile_state) {\n+  \/\/ In case of JNI_ENOMEM, there's a good chance a subsequent attempt to create libjvmci or attach to it\n@@ -279,2 +279,3 @@\n-  init_env_mode_runtime(thread, nullptr, false);\n-  if (_threw_OOME) {\n+  bool jni_enomem_is_fatal = false;\n+  init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n+  if (_jni_enomem) {\n@@ -286,1 +287,1 @@\n-    _throw_to_caller(false), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(false), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n@@ -291,1 +292,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _threw_OOME(false), _compile_state(nullptr) {\n+    _throw_to_caller(true), _file(file), _line(line), _jni_enomem(false), _compile_state(nullptr) {\n@@ -296,1 +297,1 @@\n-void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n+void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n@@ -301,1 +302,1 @@\n-  _threw_OOME = false;\n+  _jni_enomem = false;\n@@ -309,1 +310,1 @@\n-    init_env_mode_runtime(thread, nullptr);\n+    init_env_mode_runtime(thread, nullptr, jni_enomem_is_fatal);\n@@ -489,1 +490,1 @@\n-  if (_threw_OOME) {\n+  if (_jni_enomem) {\n@@ -800,0 +801,1 @@\n+DO_THROW(OutOfMemoryError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool attach_OOME_is_fatal = true);\n+  void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env, bool jni_enomem_is_fatal = true);\n@@ -162,1 +162,1 @@\n-  void init(JavaThread* thread, bool is_hotspot, const char* file, int line);\n+  void init(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line);\n@@ -172,1 +172,3 @@\n-  bool             _threw_OOME;  \/\/ OOME trying to create a libjvmci isolate or attach to it; the JVMCIEnv is invalid\n+  bool             _jni_enomem;  \/\/ JNI_ENOMEM returned when creating or attaching to a libjvmci isolate.\n+                                 \/\/ If true, the JVMCIEnv is invalid and should not be used apart from\n+                                 \/\/ calling has_jni_enomem().\n@@ -215,1 +217,2 @@\n-    init(thread, for_object.is_hotspot(), file, line);\n+    bool jni_enomem_is_fatal = true;\n+    init(thread, for_object.is_hotspot(), jni_enomem_is_fatal, file, line);\n@@ -221,2 +224,2 @@\n-  JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {\n-    init(thread, is_hotspot, file, line);\n+  JVMCIEnv(JavaThread* thread, bool is_hotspot, bool jni_enomem_is_fatal, const char* file, int line) {\n+    init(thread, is_hotspot, jni_enomem_is_fatal, file, line);\n@@ -227,0 +230,6 @@\n+  \/\/ Determines if a JNI_ENOMEM occurred while trying to create a libjvmci\n+  \/\/ isolate or attach to it within the scope of a JVMCIEnv constructor.\n+  bool has_jni_enomem() {\n+    return _jni_enomem;\n+  }\n+\n@@ -361,0 +370,1 @@\n+  DO_THROW(OutOfMemoryError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -247,0 +247,3 @@\n+  start_class(OutOfMemoryError, java_lang_OutOfMemoryError)                                                         \\\n+    jvmci_constructor(OutOfMemoryError, \"(Ljava\/lang\/String;)V\")                                                 \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -1232,0 +1233,6 @@\n+    const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.forceEnomemOnLibjvmciInit\");\n+    if (val != nullptr && strcmp(val, \"true\") == 0) {\n+      *create_JavaVM_err = JNI_ENOMEM;\n+      return nullptr;\n+    }\n+\n@@ -1552,0 +1559,1 @@\n+    bool jni_enomem_is_fatal = true;\n@@ -1553,1 +1561,1 @@\n-    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);\n+    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib \/\n@@ -49,0 +50,2 @@\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -125,0 +128,50 @@\n+\n+    \/**\n+     * Test program that calls into the VM and expects an {@code OutOfMemoryError} to be\n+     * raised when {@code test.jvmci.forceEnomemOnLibjvmciInit == true}.\n+     *\n+     * For example:\n+     * <pre>\n+     * Exception in thread \"main\" java.lang.OutOfMemoryError: JNI_ENOMEM creating or attaching to libjvmci\n+     *    at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVM.attachCurrentThread(Native Method)\n+     *    at jdk.internal.vm.ci\/jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.attachCurrentThread(HotSpotJVMCIRuntime.java:1385)\n+     *    at jdk.vm.ci.hotspot.test.TestHotSpotJVMCIRuntime$JNIEnomemVMCall.main(TestHotSpotJVMCIRuntime.java:133)\n+     * <\/pre>\n+     *\/\n+    public static class JNIEnomemVMCall {\n+        public static void main(String[] args) {\n+            String name = args[0];\n+            HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();\n+            MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();\n+            if (name.equals(\"translate\")) {\n+                runtime.translate(\"object\");\n+            } else if (name.equals(\"attachCurrentThread\")) {\n+                runtime.attachCurrentThread(false, null);\n+            } else if (name.equals(\"registerNativeMethods\")) {\n+                runtime.registerNativeMethods(JNIEnomemVMCall.class);\n+            } else {\n+                throw new InternalError(\"Unknown method: \" + name);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void jniEnomemTest() throws Exception {\n+        String[] names = {\"translate\", \"attachCurrentThread\", \"registerNativeMethods\"};\n+        for (String name : names) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+EnableJVMCI\",\n+                \"-XX:-UseJVMCICompiler\",\n+                \"-XX:+UseJVMCINativeLibrary\",\n+                \"-Dtest.jvmci.forceEnomemOnLibjvmciInit=true\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.services=ALL-UNNAMED\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.runtime=ALL-UNNAMED\",\n+                \"--add-exports=jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED\",\n+                \"-Xbootclasspath\/a:.\",\n+                JNIEnomemVMCall.class.getName(), name);\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.shouldContain(\"java.lang.OutOfMemoryError: JNI_ENOMEM creating or attaching to libjvmci\");\n+            output.shouldNotHaveExitValue(0);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"}]}