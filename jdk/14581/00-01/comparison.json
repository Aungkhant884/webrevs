{"files":[{"patch":"@@ -633,1 +633,1 @@\n-    if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+    if (u->is_memory_phi()) {\n@@ -2278,4 +2278,0 @@\n-  if (!stride_is_con()) {\n-    \/\/ Stride could be non-constant if a loop is vector masked\n-    return 0;\n-  }\n@@ -2620,1 +2616,6 @@\n-  return cle != nullptr ? cle->stride_con() : 0;\n+  if (cle != nullptr && cle->stride_is_con()) {\n+    return cle->stride_con();\n+  }\n+  assert(is_post_loop() && is_vector_masked(),\n+         \"Stride could be non-constant only in vector masked post loops\");\n+  return 0;\n@@ -2685,1 +2686,1 @@\n-          if (uu->is_Phi() && uu->bottom_type() == Type::MEMORY) {\n+          if (uu->is_memory_phi()) {\n@@ -4682,1 +4683,1 @@\n-  \/\/ Perform loop vectorization with vector masks\n+  \/\/ Perform post loop vectorization with vector masks\n@@ -4689,1 +4690,4 @@\n-        vml.try_vectorize_loop(lpt);\n+        CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+        if (cl->is_post_loop() && !cl->is_vector_masked()) {\n+          vml.try_vectorize_loop(lpt);\n+        }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1218,0 +1218,3 @@\n+  \/\/ Whether this is a memory phi node\n+  bool is_memory_phi() const { return is_Phi() && bottom_type() == Type::MEMORY; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-    if (n->is_Phi() && (n->bottom_type() == Type::MEMORY)) {\n+    if (n->is_memory_phi()) {\n@@ -557,2 +557,1 @@\n-  if (cl->is_main_loop()) {\n-    compute_vector_element_type();\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n@@ -560,1 +559,1 @@\n-    \/\/ Attempt vectorization\n+  compute_vector_element_type();\n@@ -562,1 +561,1 @@\n-    find_adjacent_refs();\n+  \/\/ Attempt vectorization\n@@ -564,3 +563,1 @@\n-    if (align_to_ref() == nullptr) {\n-      return false; \/\/ Did not find memory reference to align vectors\n-    }\n+  find_adjacent_refs();\n@@ -568,1 +565,3 @@\n-    extend_packlist();\n+  if (align_to_ref() == nullptr) {\n+    return false; \/\/ Did not find memory reference to align vectors\n+  }\n@@ -570,1 +569,1 @@\n-    combine_packs();\n+  extend_packlist();\n@@ -572,1 +571,1 @@\n-    construct_my_pack_map();\n+  combine_packs();\n@@ -574,1 +573,1 @@\n-    filter_packs();\n+  construct_my_pack_map();\n@@ -576,1 +575,1 @@\n-    DEBUG_ONLY(verify_packs();)\n+  filter_packs();\n@@ -578,2 +577,3 @@\n-    schedule();\n-  }\n+  DEBUG_ONLY(verify_packs();)\n+\n+  schedule();\n@@ -1063,1 +1063,1 @@\n-    if (n->is_Mem() || (n->is_Phi() && n->bottom_type() == Type::MEMORY)) {\n+    if (n->is_Mem() || n->is_memory_phi()) {\n@@ -1173,1 +1173,1 @@\n-        } else if (out->is_Phi() && out->bottom_type() == Type::MEMORY && !in_bb(out)) {\n+        } else if (out->is_memory_phi() && !in_bb(out)) {\n@@ -3178,1 +3178,1 @@\n-    if (in_bb(n) && (n->is_Phi() && n->bottom_type() == Type::MEMORY)) {\n+    if (in_bb(n) && n->is_memory_phi()) {\n@@ -4700,1 +4700,1 @@\n-  } else if (_n->is_Mem() || (_n->is_Phi() && _n->bottom_type() == Type::MEMORY)) {\n+  } else if (_n->is_Mem() || _n->is_memory_phi()) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+    assert(1 <= size && size <= 8 && is_power_of_2(size), \"Illegal size\");\n@@ -666,1 +667,1 @@\n-    return _slp ? _slp->iv() : _lpt->_head->as_CountedLoop()->phi()->as_Phi();\n+    return _lpt->_head->as_CountedLoop()->phi()->as_Phi();\n@@ -669,2 +670,0 @@\n-  void init();\n-\n@@ -697,0 +696,1 @@\n+  void init();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1822,2 +1822,5 @@\n-\/\/------------------------------LoopVectorMaskNode------------------------------\n-\/\/ Node for generating a loop vector mask from an integer range\n+\/\/ This is used in vectorized loops to generate a vector mask which indicates\n+\/\/ active lanes of a vector. The number of active lanes should be equal to the\n+\/\/ size of the interval represented by 2 inputs \"from\" and \"to\" of this node.\n+\/\/ For large intervals whose size is greater than the vector size, this should\n+\/\/ output all-true masks.\n@@ -1846,1 +1849,3 @@\n-\/\/--------------------------Extract[High|Low]MaskNode--------------------------\n+\/\/ Below two nodes are used in pair to extract the upper (lower) half of a\n+\/\/ vector mask to get two vector masks which indicate the lane activity of\n+\/\/ the upper (lower) half of the original vector, respectively.\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,13 +59,20 @@\n-  CountedLoopNode *cl = lpt->_head->as_CountedLoop();\n-  \/\/ Skip if loop is already vector masked\n-  if (cl->is_vector_masked()) return;\n-  \/\/ Skip non-post loop\n-  if (!cl->is_post_loop()) return;\n-  \/\/ Skip malformed counted loop\n-  if (!cl->is_valid_counted_loop(T_INT)) return;\n-  \/\/ Skip loop if stride is unsupported\n-  if (abs(cl->stride_con()) != 1) return;\n-  \/\/ Skip loop with control flow\n-  if (cl->loopexit()->in(0) != cl) return;\n-  \/\/ Skip if some loop operations are pinned to the backedge\n-  if (cl->back_control()->outcnt() != 1) return;\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  assert(cl->is_post_loop() && !cl->is_vector_masked(),\n+         \"Current loop should be a post loop and not vector masked\");\n+\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n+    trace_msg(nullptr, \"Loop is not a valid counted loop\");\n+    return;\n+  }\n+  if (abs(cl->stride_con()) != 1) {\n+    trace_msg(nullptr, \"Loop has unsupported stride value\");\n+    return;\n+  }\n+  if (cl->loopexit()->in(0) != cl) {\n+    trace_msg(nullptr, \"Loop has unsupported control flow\");\n+    return;\n+  }\n+  if (cl->back_control()->outcnt() != 1) {\n+    trace_msg(nullptr, \"Loop has node pinned to the backedge\");\n+    return;\n+  }\n@@ -116,0 +123,2 @@\n+  ResourceMark rm;\n+\n@@ -133,3 +142,3 @@\n-  VectorSet visited(_arena);\n-  VectorSet post_visited(_arena);\n-  GrowableArray<Node*> stack(_arena, node_cnt, 0, nullptr);\n+  VectorSet visited;\n+  VectorSet post_visited;\n+  GrowableArray<Node*> stack(node_cnt, 0, nullptr);\n@@ -145,1 +154,1 @@\n-      if (!is_memory_phi(n)) {\n+      if (!n->is_memory_phi()) {\n@@ -195,1 +204,1 @@\n-          Node* node, uint idx, Node_List* stmt, Node_List* worklist) {\n+          const Node* node, const uint idx, Node_List* stmt, Node_List* worklist) {\n@@ -214,1 +223,2 @@\n-    \/\/ 2) We don't support phi nodes except the iv phi of the loop\n+    \/\/ 2) We don't support phi nodes except the iv phi of the loop and memory\n+    \/\/    phi's cannot be reached\n@@ -264,3 +274,1 @@\n-    Node* store = stmt->at(0);\n-    \/\/ Add value input of the store node into a worklist to include more nodes\n-    \/\/ into current statement\n+    \/\/ Create a new worklist and add the initial node of a statement\n@@ -268,3 +276,1 @@\n-    if (!collect_statements_helper(store, MemNode::ValueIn, stmt, worklist)) {\n-      return false;\n-    }\n+    worklist->push(stmt->at(0));\n@@ -323,1 +329,1 @@\n-    \/\/ Record vector lane size\n+    \/\/ Record vector element size\n@@ -367,1 +373,1 @@\n-              trace_msg(node, \"Vector element size does not match\");\n+              trace_msg(node, \"Inconsistent vector element size in one statement\");\n@@ -424,0 +430,1 @@\n+          assert(node->is_Load() || node->is_Store(), \"Must be load or store\");\n@@ -425,0 +432,4 @@\n+          if (!Matcher::match_rule_supported_vector_masked(vopc, vlen, bt)) {\n+            trace_msg(node, \"Vector masked memory access is not implemented\");\n+            return false;\n+          }\n@@ -427,5 +438,5 @@\n-        }\n-        if (vopc == 0 ||\n-            !Matcher::match_rule_supported_vector_masked(vopc, vlen, bt)) {\n-          trace_msg(node, \"Vector replacement node is not implemented\");\n-          return false;\n+          if (vopc == 0 ||\n+            !Matcher::match_rule_supported_vector(vopc, vlen, bt)) {\n+            trace_msg(node, \"Vector replacement node is not implemented\");\n+            return false;\n+          }\n@@ -442,1 +453,2 @@\n-  VectorSet tracked(_arena);\n+  ResourceMark rm;\n+  VectorSet tracked;\n@@ -465,1 +477,1 @@\n-    if ((node->is_Mem() && node->as_Mem()->is_Store())) {\n+    if (node->is_Store()) {\n@@ -482,1 +494,1 @@\n-    if (!tracked.test(idx) && !in_core(node) && !is_memory_phi(node)) {\n+    if (!tracked.test(idx) && !in_core(node) && !node->is_memory_phi()) {\n@@ -524,0 +536,1 @@\n+    trace_msg(mem, \"Only memory accesses of primitive types are supported\");\n@@ -530,0 +543,1 @@\n+    trace_msg(mem, \"Memory access has inconsistent type\");\n@@ -541,0 +555,1 @@\n+      trace_msg(mem, \"Memory access has inconsistent type or base\");\n@@ -553,0 +568,1 @@\n+    trace_msg(mem, \"Memory access has unsupported address pattern\");\n@@ -559,0 +575,1 @@\n+    trace_msg(mem, \"Memory access has unsupported direction or scale\");\n@@ -563,0 +580,1 @@\n+      trace_msg(mem, \"Memory access unexpectedly uses loop increment node\");\n@@ -708,1 +726,2 @@\n-\/\/ return the node map of scalar to vector replacement\n+\/\/ return the node map of scalar to vector replacement. The node map is used\n+\/\/ for vector duplication for larger types.\n@@ -790,1 +809,1 @@\n-  int level = exact_log2(dup_cnt);\n+  int vmask_tree_level = exact_log2(dup_cnt);\n@@ -814,1 +833,1 @@\n-          if (is_loop_iv(init_idx) || is_loop_iv_plus_stride(init_idx)) {\n+          if (is_loop_iv(init_idx) || is_loop_incr_pattern(init_idx)) {\n@@ -838,2 +857,2 @@\n-  for (int mask_off = 0; mask_off < dup_cnt; mask_off++) {\n-    Node_List* vnodes = vector_copies.at(mask_off);\n+  for (int level_offset = 0; level_offset < dup_cnt; level_offset++) {\n+    Node_List* vnodes = vector_copies.at(level_offset);\n@@ -843,1 +862,1 @@\n-      adjust_vector_node(vn, vmask_tree, level, mask_off);\n+      adjust_vector_node(vn, vmask_tree, vmask_tree_level, level_offset);\n@@ -859,3 +878,3 @@\n-    for (int mask_off = 0; mask_off < dup_cnt; mask_off++) {\n-      Node_List* vp = vector_copies.at(mask_off);\n-      tty->print_cr(\"Offset = %d\", mask_off);\n+    for (int level_offset = 0; level_offset < dup_cnt; level_offset++) {\n+      Node_List* vp = vector_copies.at(level_offset);\n+      tty->print_cr(\"Offset = %d\", level_offset);\n@@ -873,3 +892,4 @@\n-                                          int level, int mask_off) {\n-  Node* vmask = vmask_tree->at((1 << level) + mask_off);\n-  int lane_size = type2aelembytes(Matcher::vector_element_basic_type(vmask));\n+                                          int vmask_tree_level, int level_offset) {\n+  Node* vmask = vmask_tree->at((1 << vmask_tree_level) + level_offset);\n+  BasicType elem_bt = Matcher::vector_element_basic_type(vmask);\n+  int lane_size = type2aelembytes(elem_bt);\n@@ -877,0 +897,2 @@\n+  assert(Matcher::vector_width_in_bytes(elem_bt) == (int) vector_size_in_bytes,\n+         \"should get the same vector width\");\n@@ -881,1 +903,1 @@\n-    if (mask_off != 0) {\n+    if (level_offset != 0) {\n@@ -884,2 +906,1 @@\n-      int mem_scale = Matcher::max_vector_size(T_BYTE);\n-      Node* off = _igvn->MakeConX(mem_scale * mask_off);\n+      Node* off = _igvn->MakeConX(vector_size_in_bytes * level_offset);\n@@ -892,1 +913,1 @@\n-    if (mask_off != 0) {\n+    if (level_offset != 0) {\n@@ -894,1 +915,1 @@\n-      Node* idx_off = _igvn->intcon(v_stride * mask_off);\n+      Node* idx_off = _igvn->intcon(v_stride * level_offset);\n@@ -903,1 +924,1 @@\n-Node_List* VectorMaskedLoop::clone_node_list(Node_List* list) {\n+Node_List* VectorMaskedLoop::clone_node_list(const Node_List* list) {\n@@ -935,1 +956,1 @@\n-  \/\/ Create a tree of vector masks for different vector lane sizes\n+  \/\/ Create a tree of vector masks for different vector element sizes\n@@ -939,1 +960,5 @@\n-  \/\/ Replace vectorization candidate nodes to vector nodes\n+  \/\/ Replace vectorization candidate nodes to vector nodes. For now we only\n+  \/\/ generate a single vector node per scalar node. And that the duplication\n+  \/\/ afterwards makes sure that all scalar nodes are \"widened\" to the same\n+  \/\/ number of elements. The smalles type using a single vector, larger types\n+  \/\/ using multiple (duplicated) vectors per scalar node.\n@@ -942,1 +967,2 @@\n-  \/\/ Duplicate and adjust vector nodes with larger vector lane sizes\n+  \/\/ Duplicate and adjust vector operations with larger vector element sizes\n+  \/\/ which need multiple vectors to process\n@@ -965,1 +991,1 @@\n-void VectorMaskedLoop::trace_msg(Node* n, const char* format, ...) {\n+void VectorMaskedLoop::trace_msg(Node* n, const char* msg) {\n@@ -968,5 +994,4 @@\n-    va_list ap;\n-    va_start(ap, format);\n-    tty->vprint_cr(format, ap);\n-    va_end(ap);\n-    if (n != nullptr) n->dump();\n+    tty->print_cr(\"%s\", msg);\n+    if (n != nullptr) {\n+      n->dump();\n+    }\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.cpp","additions":87,"deletions":62,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  BasicType statement_bottom_type(Node_List* stmt) {\n+  BasicType statement_bottom_type(const Node_List* stmt) const {\n@@ -67,1 +67,1 @@\n-  BasicType size_to_basic_type(int size) {\n+  BasicType size_to_basic_type(const int size) const {\n@@ -85,3 +85,2 @@\n-  bool is_loop_iv(Node* n) { return n == _iv; }\n-  bool is_loop_incr(Node* n) { return n == _cl->incr(); }\n-  bool is_loop_iv_or_incr(Node* n) { return n == _iv || n == _cl->incr(); }\n+  bool is_loop_iv(const Node* n) const { return n == _iv; }\n+  bool is_loop_incr(const Node* n) const { return n == _cl->incr(); }\n@@ -89,1 +88,5 @@\n-  bool is_loop_iv_plus_stride(Node* n) {\n+  bool is_loop_iv_or_incr(const Node* n) const {\n+    return n == _iv || n == _cl->incr();\n+  }\n+\n+  bool is_loop_incr_pattern (const Node* n) const {\n@@ -97,4 +100,0 @@\n-  bool is_memory_phi(Node* n) {\n-    return n != nullptr && n->is_Phi() && n->bottom_type() == Type::MEMORY;\n-  }\n-\n@@ -105,1 +104,2 @@\n-  bool collect_statements_helper(Node* node, uint idx, Node_List* stmt, Node_List* worklist);\n+  bool collect_statements_helper(const Node* node, const uint idx,\n+                                 Node_List* stmt, Node_List* worklist);\n@@ -125,1 +125,1 @@\n-  Node_List* clone_node_list(Node_List* list);\n+  Node_List* clone_node_list(const Node_List* list);\n@@ -129,1 +129,1 @@\n-  void trace_msg(Node* n, const char* format, ...);\n+  void trace_msg(Node* n, const char* msg);\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}