{"files":[{"patch":"@@ -168,0 +168,1 @@\n+      case Op_LoopVectorMask:\n@@ -5906,0 +5907,30 @@\n+instruct loop_vmask_gen(pRegGov pg, iRegIorL2I from, iRegIorL2I to, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (LoopVectorMask from to));\n+  effect(KILL cr);\n+  format %{ \"loop_vmask_gen $pg, $from, $to\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whileltw($pg$$PRegister, __ elemType_to_regVariant(bt), $from$$Register, $to$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ -------------------------- Vector mask extraction --------------------------\n+\n+instruct extract_high_mask(pRegGov pd, pRegGov pn) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (ExtractHighMask pn));\n+  format %{ \"extract_high_mask $pd, $pn\" %}\n+  ins_encode %{ __ sve_punpkhi($pd$$PRegister, $pn$$PRegister); %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extract_low_mask(pRegGov pd, pRegGov pn) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (ExtractLowMask pn));\n+  format %{ \"extract_low_mask $pd, $pn\" %}\n+  ins_encode %{ __ sve_punpklo($pd$$PRegister, $pn$$PRegister); %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+      case Op_LoopVectorMask:\n@@ -4162,0 +4163,30 @@\n+instruct loop_vmask_gen(pRegGov pg, iRegIorL2I from, iRegIorL2I to, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (LoopVectorMask from to));\n+  effect(KILL cr);\n+  format %{ \"loop_vmask_gen $pg, $from, $to\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whileltw($pg$$PRegister, __ elemType_to_regVariant(bt), $from$$Register, $to$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ -------------------------- Vector mask extraction --------------------------\n+\n+instruct extract_high_mask(pRegGov pd, pRegGov pn) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (ExtractHighMask pn));\n+  format %{ \"extract_high_mask $pd, $pn\" %}\n+  ins_encode %{ __ sve_punpkhi($pd$$PRegister, $pn$$PRegister); %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extract_low_mask(pRegGov pd, pRegGov pn) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (ExtractLowMask pn));\n+  format %{ \"extract_low_mask $pd, $pn\" %}\n+  ins_encode %{ __ sve_punpklo($pd$$PRegister, $pn$$PRegister); %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1761,0 +1761,1 @@\n+    case Op_LoopVectorMask:\n@@ -9021,0 +9022,57 @@\n+instruct loop_vmask_gen_small_trip(kReg dst, rRegI from, rRegI to, rRegI tmp1, rRegL tmp2) %{\n+  predicate(n->as_LoopVectorMask()->max_trips() > 0 &&\n+            n->as_LoopVectorMask()->max_trips() < 256);\n+  match(Set dst (LoopVectorMask from to));\n+  format %{ \"loop_vmask_gen_small_trip $dst, $from, $to\\t! loop vector mask generator\" %}\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    jlong all_true_mask = (vlen < 64) ? ((1L << vlen) - 1) : -1L;\n+    __ movl($tmp1$$Register, $to$$Register);\n+    __ subl($tmp1$$Register, $from$$Register);\n+    __ mov64($tmp2$$Register, all_true_mask);\n+    __ bzhiq($tmp2$$Register, $tmp2$$Register, $tmp1$$Register);\n+    __ kmovql($dst$$KRegister, $tmp2$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct loop_vmask_gen(kReg dst, rRegI from, rRegI to, rRegI tmp1, rRegL tmp2) %{\n+  predicate(n->as_LoopVectorMask()->max_trips() <= 0 ||\n+            n->as_LoopVectorMask()->max_trips() >= 256);\n+  match(Set dst (LoopVectorMask from to));\n+  format %{ \"loop_vmask_gen $dst, $from, $to\\t! loop vector mask generator\" %}\n+  effect(TEMP tmp1, TEMP tmp2);\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    jlong all_true_mask = (vlen < 64) ? ((1L << vlen) - 1) : -1L;\n+    Label SATURATED;\n+    __ movl($tmp1$$Register, $to$$Register);\n+    __ subl($tmp1$$Register, $from$$Register);\n+    __ mov64($tmp2$$Register, all_true_mask);\n+    __ cmpl($tmp1$$Register, 255);\n+    __ jccb(Assembler::greaterEqual, SATURATED);\n+    __ bzhiq($tmp2$$Register, $tmp2$$Register, $tmp1$$Register);\n+    __ bind(SATURATED);\n+    __ kmovql($dst$$KRegister, $tmp2$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct extract_high_mask(kReg dst, kReg src) %{\n+  match(Set dst (ExtractHighMask src));\n+  format %{ \"extract_high_mask $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    __ kshiftrql($dst$$KRegister, $src$$KRegister, vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct extract_low_mask(kReg dst_src) %{\n+  match(Set dst_src (ExtractLowMask dst_src));\n+  format %{ \"extract_low_mask $dst_src, $dst_src\\t# do nothing\" %}\n+  ins_encode %{ \/* empty encoding *\/ %}\n+  ins_pipe( empty );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -4267,0 +4267,1 @@\n+    \"LoopVectorMask\", \"ExtractLowMask\", \"ExtractHighMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -576,0 +576,6 @@\n+  product(bool, UseMaskedLoop, false, EXPERIMENTAL,                         \\\n+          \"Use fully predicated loop auto-vectorization\")                   \\\n+                                                                            \\\n+  notproduct(bool, TraceMaskedLoop, false,                                  \\\n+          \"Trace masked loop transformations\")                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+macro(LoopVectorMask)\n@@ -486,0 +487,2 @@\n+macro(ExtractHighMask)\n+macro(ExtractLowMask)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/vmaskloop.hpp\"\n@@ -2577,1 +2578,6 @@\n-  return cle != nullptr ? cle->stride_con() : 0;\n+  if (cle != nullptr && cle->stride_is_con()) {\n+    return cle->stride_con();\n+  }\n+  assert(is_post_loop() && is_vector_masked(),\n+         \"Stride could be non-constant only in vector masked post loops\");\n+  return 0;\n@@ -3977,0 +3983,1 @@\n+    if (cl->is_vector_masked()) tty->print(\" masked\");\n@@ -4673,0 +4680,15 @@\n+\n+  \/\/ Perform post loop vectorization with vector masks\n+  if (UseMaskedLoop && Matcher::has_predicated_vectors() &&\n+      C->has_loops() && !C->major_progress()) {\n+    VectorMaskedLoop vml(this);\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree* lpt = iter.current();\n+      if (lpt->is_counted() && lpt->is_innermost()) {\n+        CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+        if (cl->is_post_loop() && !cl->is_vector_masked()) {\n+          vml.try_vectorize_loop(lpt);\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -80,1 +80,2 @@\n-         LoopNestLongOuterLoop = 1<<16 };\n+         LoopNestLongOuterLoop = 1<<16,\n+         VectorMasked          = 1<<17 };\n@@ -95,0 +96,1 @@\n+  bool is_vector_masked() const { return _loop_flags & VectorMasked; }\n@@ -110,0 +112,1 @@\n+  void mark_vector_masked() { _loop_flags |= VectorMasked; }\n@@ -139,0 +142,3 @@\n+    if (is_vector_masked()) {\n+      return false;\n+    }\n@@ -768,0 +774,2 @@\n+  void collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const;\n+\n@@ -801,2 +809,0 @@\n-  void collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const;\n-\n@@ -822,0 +828,1 @@\n+  friend class VectorMaskedLoop;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+class LoopVectorMaskNode;\n@@ -123,0 +124,2 @@\n+class ExtractHighMaskNode;\n+class ExtractLowMaskNode;\n@@ -734,0 +737,1 @@\n+      DEFINE_CLASS_ID(LoopVectorMask, Type, 10)\n@@ -918,0 +922,1 @@\n+  DEFINE_CLASS_QUERY(LoopVectorMask)\n@@ -1753,1 +1758,1 @@\n-class Node_Stack {\n+class Node_Stack : public ResourceObj {\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -398,0 +398,45 @@\n+\/\/ Check potential data dependence among load & store operations.\n+\/\/ Dependence only exists between load-store or store-store with\n+\/\/ same data type or subword data size (i.e., a LoadS and a StoreC\n+\/\/ may have data dependence because C2 store nodes have imprecise\n+\/\/ type info about signedness).\n+bool VPointer::has_potential_dependence(GrowableArray<VPointer*> vptrs) {\n+  \/\/ Initialize an array of VPointer* for store operations of each\n+  \/\/ basic type. The maximum possible type is T_LONG.\n+  VPointer* stores[T_LONG + 1];\n+  memset(stores, 0, sizeof(stores));\n+\n+  \/\/ First iterate stores to fill this array and search unaligned\n+  \/\/ overlap between store operations.\n+  for (int i = 0; i < vptrs.length(); i++) {\n+    VPointer* ptr = vptrs.at(i);\n+    MemNode* mem = ptr->mem();\n+    if (mem->is_Store()) {\n+      \/\/ Map unsigned subword types to signed\n+      BasicType bt = get_signed_subword_bt(mem->memory_type());\n+      if (stores[bt] == NULL) {\n+        stores[bt] = ptr;\n+      } else if (!stores[bt]->equal(*ptr)) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  \/\/ Then iterate load nodes to search between load and store. No\n+  \/\/ dependence may exist if there's no store node.\n+  for (int i = 0; i < vptrs.length(); i++) {\n+    VPointer* ptr = vptrs.at(i);\n+    MemNode* mem = ptr->mem();\n+    if (mem->is_Load()) {\n+      \/\/ Map unsigned subword types to signed\n+      BasicType bt = get_signed_subword_bt(mem->memory_type());\n+      if (stores[bt] != NULL && !stores[bt]->equal(*ptr)) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  \/\/ No potential dependence is found so far\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -200,0 +200,2 @@\n+\n+  static bool has_potential_dependence(GrowableArray<VPointer*> vptrs);\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1837,0 +1837,50 @@\n+\/\/ This is used in vectorized loops to generate a vector mask which indicates\n+\/\/ active lanes of a vector. The number of active lanes should be equal to the\n+\/\/ size of the interval represented by 2 inputs \"from\" and \"to\" of this node.\n+\/\/ For large intervals whose size is greater than the vector size, this should\n+\/\/ output all-true masks.\n+class LoopVectorMaskNode : public TypeNode {\n+ private:\n+  int _max_trips;\n+ public:\n+  LoopVectorMaskNode(Node* from, Node* to, const Type* ty, int max_trips) :\n+      TypeNode(ty, 3), _max_trips(max_trips) {\n+    init_class_id(Class_LoopVectorMask);\n+    init_req(1, from);\n+    init_req(2, to);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual uint hash() const { return TypeNode::hash() + _max_trips; }\n+  virtual bool cmp(const Node& n) const {\n+    return TypeNode::cmp(n) &&\n+           _max_trips == ((LoopVectorMaskNode&)n)._max_trips;\n+  }\n+  virtual uint size_of() const { return sizeof(LoopVectorMaskNode); }\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+  int max_trips() const { return _max_trips; }\n+};\n+\n+\/\/ Below two nodes are used in pair to extract the upper (lower) half of a\n+\/\/ vector mask to get two vector masks which indicate the lane activity of\n+\/\/ the upper (lower) half of the original vector, respectively.\n+class ExtractHighMaskNode : public TypeNode {\n+ public:\n+  ExtractHighMaskNode(Node* in, const Type* ty) : TypeNode(ty, 2) {\n+    init_req(1, in);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+};\n+\n+class ExtractLowMaskNode : public TypeNode {\n+ public:\n+  ExtractLowMaskNode(Node* in, const Type* ty) : TypeNode(ty, 2) {\n+    init_req(1, in);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,1003 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/addnode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n+#include \"opto\/vmaskloop.hpp\"\n+\n+VectorMaskedLoop::VectorMaskedLoop(PhaseIdealLoop* phase) :\n+  _phase(phase),\n+  _igvn(&(phase->_igvn)),\n+  _arena(phase->C->comp_arena()),\n+\n+  _lpt(nullptr),\n+  _cl(nullptr),\n+  _cle(nullptr),\n+  _iv(nullptr),\n+\n+  _core_set(_arena),\n+  _body_set(_arena),\n+  _body_nodes(_arena, 32, 0, nullptr),\n+  _rpo_idx(_arena, 32, 0, 0),\n+  _elem_bt(_arena, 32, 0, T_ILLEGAL),\n+  _stmts(_arena, 2, 0, nullptr),\n+  _vptrs(_arena, 8, 0, nullptr),\n+  _size_stats(_arena)\n+{}\n+\n+\/\/ Try vectorizing loop with vector masks - entry function of the vectorizer\n+void VectorMaskedLoop::try_vectorize_loop(IdealLoopTree* lpt) {\n+  assert(UseMaskedLoop, \"Option should be enabled\");\n+  assert(lpt->is_counted(), \"Loop must be counted\");\n+  assert(lpt->is_innermost(), \"Loop must be innermost\");\n+\n+  \/\/ Reset basic loop info\n+  _lpt = lpt;\n+  _cl = lpt->_head->as_CountedLoop();\n+  _cle = _cl->loopexit();\n+  _iv = _cle->phi();\n+  assert(_cl->is_post_loop() && !_cl->is_vector_masked(),\n+         \"Current loop should be a post loop and not vector masked\");\n+\n+  if (!_cl->is_valid_counted_loop(T_INT)) {\n+    trace_msg(\"Loop is not a valid counted loop\");\n+    return;\n+  }\n+  if (abs(_cl->stride_con()) != 1) {\n+    trace_msg(\"Loop has unsupported stride value\", _cl->stride());\n+    return;\n+  }\n+  if (_cl->loopexit()->in(0) != _cl) {\n+    trace_msg(\"Loop has unsupported control flow\");\n+    return;\n+  }\n+  if (_cl->back_control()->outcnt() != 1) {\n+    trace_msg(\"Loop has node pinned to the backedge\");\n+    return;\n+  }\n+\n+  \/\/ Collect loop info data structures and analyze vectorizability\n+  reset();\n+  if (!collect_loop_nodes()) return;\n+  if (!collect_statements()) return;\n+  if (!analyze_vectorizability()) return;\n+\n+  \/\/ Try creating a vector mask with the smallest vector element size\n+  const TypeVectMask* t_vmask = create_vector_mask_type();\n+  if (t_vmask == nullptr || !t_vmask->isa_vectmask()) return;\n+\n+  \/\/ Transform the loop and set flags\n+  transform_loop(t_vmask);\n+  _cl->mark_loop_vectorized();\n+  _cl->mark_vector_masked();\n+  _phase->C->set_max_vector_size(MaxVectorSize);\n+  trace_msg(\"Loop is vector masked\");\n+}\n+\n+\n+\/\/ Below are loop vectorizable analysis functions. At the analysis stage, we\n+\/\/ collect enough loop information and check the vectorizability of the whole\n+\/\/ loop. The ideal graph is \"read-only\" at this time.\n+\n+\/\/ reset: all loop info should be reset at this point\n+void VectorMaskedLoop::reset() {\n+  _core_set.clear();\n+  _body_set.clear();\n+  _body_nodes.clear();\n+  _rpo_idx.clear();\n+  _elem_bt.clear();\n+  _stmts.clear();\n+  _vptrs.clear();\n+  _size_stats.clear();\n+}\n+\n+\/\/ Collect loop nodes into an array with reverse postorder for convenience of\n+\/\/ future traversal. Do early bail out if unsupported node is found.\n+bool VectorMaskedLoop::collect_loop_nodes() {\n+  ResourceMark rm;\n+\n+  \/\/ Collect 7 (see EMPTY_LOOP_SIZE) core nodes of the loop\n+  _lpt->collect_loop_core_nodes(_phase, _core_set);\n+\n+  \/\/ Push loop nodes into a node set for fast membership check, also create a\n+  \/\/ temporary index map for RPO visit\n+  int node_cnt = _lpt->_body.size();\n+  for (int i = 0; i < node_cnt; i++) {\n+    Node* n = _lpt->_body.at(i);\n+    if (n->is_LoadStore() || n->is_RangeCheck() || n->is_Call()) {\n+      trace_msg(\"Found unsupported node in the loop\", n);\n+      return false;\n+    }\n+    _body_set.push(n);\n+    set_rpo_idx(n, i);\n+  }\n+\n+  \/\/ Visit all loop nodes from the head to create reverse postorder\n+  VectorSet visited;\n+  VectorSet post_visited;\n+  GrowableArray<Node*> stack(node_cnt, 0, nullptr);\n+  stack.push(_cl);\n+  int idx = node_cnt - 1;\n+  while (stack.length() > 0) {\n+    Node* n = stack.top();\n+    if (!visited.test(rpo_idx(n))) {\n+      \/\/ Forward arc in graph\n+      visited.set(rpo_idx(n));\n+    } else if (!post_visited.test(rpo_idx(n))) {\n+      \/\/ Cross or backward arc in graph\n+      if (!n->is_memory_phi()) {\n+        \/\/ Push all users in loop for non-mem-phi nodes\n+        for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+          Node* use = n->fast_out(i);\n+          if (in_body(use) && !visited.test(rpo_idx(use))) {\n+            stack.push(use);\n+          }\n+        }\n+      }\n+      if (n == stack.top()) {\n+        \/\/ Node is still at the top - no additional use is pushed, visit it.\n+        \/\/ Also initialize node info at this time.\n+        stack.pop();\n+        assert(idx >= 0, \"Is some node visited more than once?\");\n+        _body_nodes.at_put_grow(idx, n);\n+        _elem_bt.at_put_grow(idx, T_ILLEGAL);\n+        idx--;\n+        post_visited.set(rpo_idx(n));\n+      }\n+    } else {\n+      stack.pop();\n+    }\n+  }\n+\n+  \/\/ Bail out if loop has unreachable node while traversing from head\n+  if (idx != -1) {\n+    trace_msg(\"Loop has unreachable node while traversing from head\");\n+    return false;\n+  }\n+  \/\/ Create a real index map for future use\n+  for (int i = 0; i < _body_nodes.length(); i++) {\n+    set_rpo_idx(_body_nodes.at(i), i);\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    tty->print_cr(\"Collected loop nodes in reverse postorder\");\n+    for (int i = 0; i < _body_nodes.length(); i++) {\n+      tty->print(\" rpo=%d\\t\", i);\n+      _body_nodes.at(i)->dump();\n+    }\n+    tty->cr();\n+  }\n+#endif\n+\n+  return true;\n+}\n+\n+\/\/ Try including a node's input at specified index into current statement\n+bool VectorMaskedLoop::collect_statements_helper(\n+          const Node* node, const uint idx, Node_List* stmt, Node_List* worklist) {\n+  Node* in = node->in(idx);\n+  if (stmt->contains(in) || !in_body(in)) {\n+    \/\/ Input is already included in current statement or out of loop\n+    return true;\n+  }\n+\n+  \/\/ Check support for special inputs first and then general ones\n+  if (is_loop_iv_or_incr(in)) {\n+    \/\/ 1) Check the support of loop iv or increment node input\n+    BasicType bt = statement_bottom_type(stmt);\n+    bt = is_subword_type(bt) ? bt : T_INT;\n+    if (VectorNode::is_populate_index_supported(bt)) {\n+      return true;\n+    } else {\n+      trace_msg(\"Populate index operation is not supported\", in);\n+      return false;\n+    }\n+  } else if (in->is_Phi()) {\n+    \/\/ 2) We don't support phi nodes except the iv phi of the loop and memory\n+    \/\/    phi's cannot be reached\n+    trace_msg(\"Found unsupported phi input\", in);\n+    return false;\n+  } else if (in->is_Load()) {\n+    \/\/ 3) Ok to include a load node if it's supported memory access\n+    if (supported_mem_access(in->as_Load())) {\n+      stmt->push(in);\n+      return true;\n+    } else {\n+      trace_msg(\"Found unsupported memory load input\", in);\n+      return false;\n+    }\n+  } else if (VectorNode::is_shift(in) && in_body(in->in(2))) {\n+    \/\/ 4) We don't support shift operations with variant shift count\n+    trace_msg(\"Variant shift count is not supported\", in);\n+    return false;\n+  } else {\n+    \/\/ 5) For other general inputs, include it and also push it into the\n+    \/\/    worklist to collect inputs recursively\n+    worklist->push(in);\n+    stmt->push(in);\n+    return true;\n+  }\n+}\n+\n+\/\/ Collect lists of nodes that make up loop statements\n+bool VectorMaskedLoop::collect_statements() {\n+  \/\/ First, initialize each statement from a store node.\n+  for (int idx = 0; idx < _body_nodes.length(); idx++) {\n+    Node* node = _body_nodes.at(idx);\n+    if (node->is_Store() && supported_mem_access(node->as_Store())) {\n+      \/\/ Create a new statement and add the store into its node list\n+      Node_List* stmt = new Node_List(_arena);\n+      stmt->push(node);\n+      _stmts.append(stmt);\n+    }\n+  }\n+\n+  \/\/ Do early bail out if no statement is created\n+  int num_stmts = _stmts.length();\n+  if (num_stmts == 0) {\n+    trace_msg(\"No vectorizable statement is found\");\n+    return false;\n+  }\n+\n+  \/\/ Then, extend each statement by recursively including input nodes. Bail out\n+  \/\/ if unsupported node is found.\n+  for (int idx = 0; idx < num_stmts; idx++) {\n+    Node_List* stmt = _stmts.at(idx);\n+    assert(stmt->size() == 1, \"Each statement should have exactly one node\");\n+    \/\/ Create a new worklist and add the initial node of a statement\n+    Node_List* worklist = new Node_List(_arena);\n+    worklist->push(stmt->at(0));\n+    \/\/ Continue adding nodes until the worklist is empty\n+    while (worklist->size() > 0) {\n+      Node* node = worklist->pop();\n+      uint start, end;\n+      VectorNode::vector_operands(node, &start, &end);\n+      for (uint idx = start; idx < end; idx++) {\n+        if (!collect_statements_helper(node, idx, stmt, worklist)) {\n+          return false;\n+        }\n+      }\n+    }\n+#ifndef PRODUCT\n+    if (TraceMaskedLoop) {\n+      tty->print_cr(\"Nodes in statement [%d] with element type '%s'\",\n+                    idx, type2name(statement_bottom_type(stmt)));\n+      for (uint i = 0; i < stmt->size(); i++) {\n+        stmt->at(i)->dump();\n+      }\n+      tty->cr();\n+    }\n+#endif\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ Analyze loop statements and bail out if any of them is not vectorizable\n+bool VectorMaskedLoop::analyze_vectorizability() {\n+  if (!find_vector_element_types()) {\n+    return false;\n+  }\n+  if (!vector_nodes_implemented()) {\n+    return false;\n+  }\n+  \/\/ Delegate data dependence check to VPointer utility\n+  if (VPointer::has_potential_dependence(_vptrs)) {\n+    trace_msg(\"Potential data dependence is found in the loop\");\n+    return false;\n+  }\n+  if (!analyze_loop_body_nodes()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Find element basic type for each vectorization candidate node\n+bool VectorMaskedLoop::find_vector_element_types() {\n+  for (int idx = 0; idx < _stmts.length(); idx++) {\n+    Node_List* stmt = _stmts.at(idx);\n+    BasicType stmt_bottom_type = statement_bottom_type(stmt);\n+    bool subword_stmt = is_subword_type(stmt_bottom_type);\n+\n+    \/\/ Record vector element size\n+    _size_stats.record_size(type2aelembytes(stmt_bottom_type));\n+\n+    \/\/ Set element type for each statement node from bottom to top. Bail out if\n+    \/\/ the pattern is unsupported\n+    for (int i = stmt->size() - 1; i >= 0; i--) {\n+      Node* node = stmt->at(i);\n+      if (node->is_Mem()) {\n+        \/\/ Use memory type as its element basic type for memory node\n+        BasicType mem_type = node->as_Mem()->memory_type();\n+        set_elem_bt(node, mem_type);\n+        if (node->is_Load()) {\n+          \/\/ For load node, check if it has the same vector element size with\n+          \/\/ the bottom type of the statement\n+          if (!same_element_size(mem_type, stmt_bottom_type)) {\n+            trace_msg(\"Vector element size does not match\", node);\n+            return false;\n+          }\n+        }\n+      } else {\n+        int opc = node->Opcode();\n+        if (subword_stmt &&\n+            (opc == Op_RShiftI || opc == Op_URShiftI ||\n+             opc == Op_AbsI || opc == Op_ReverseBytesI)) {\n+          \/\/ In any Java arithmetic operation, operands of small integer types\n+          \/\/ (boolean, byte, char & short) should be promoted to int first. For\n+          \/\/ some operations, the compiler has to know the operand's higher\n+          \/\/ order bits, which will be lost in narrowed type. These operations\n+          \/\/ shouldn't be vectorized if the higher order bits info is unknown.\n+          Node* in1 = node->in(1);\n+          if (in1->is_Load()) {\n+            BasicType mem_type = in1->as_Mem()->memory_type();\n+            set_elem_bt(node, mem_type);\n+          } else {\n+            trace_msg(\"Subword operand does not have precise type\", node);\n+            return false;\n+          }\n+        } else {\n+          \/\/ Otherwise, use signed subword type or the statement's bottom type\n+          if (subword_stmt) {\n+            set_elem_bt(node, get_signed_subword_bt(stmt_bottom_type));\n+          } else {\n+            BasicType self_type = node->bottom_type()->array_element_basic_type();\n+            if (!same_element_size(self_type, stmt_bottom_type)) {\n+              trace_msg(\"Inconsistent vector element size in one statement\", node);\n+              return false;\n+            }\n+            set_elem_bt(node, self_type);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    tty->print_cr(\"Element basic types of nodes in the loop\");\n+    for (int idx = 0; idx < _body_nodes.length(); idx++) {\n+      Node* node = _body_nodes.at(idx);\n+      if (has_valid_elem_bt(node)) {\n+        tty->print(\" %s\\t\", type2name(elem_bt(node)));\n+        node->dump();\n+      }\n+    }\n+    tty->cr();\n+  }\n+#endif\n+\n+  return true;\n+}\n+\n+\/\/ Check if all vector operations required are implemented in current backend.\n+\/\/ Bail out if any of the vector op is not implemented.\n+bool VectorMaskedLoop::vector_nodes_implemented() {\n+  for (int idx = 0; idx < _stmts.length(); idx++) {\n+    Node_List* stmt = _stmts.at(idx);\n+    for (int i = stmt->size() - 1; i >= 0; i--) {\n+      Node* node = stmt->at(i);\n+      int opc = node->Opcode();\n+      BasicType bt = elem_bt(node);\n+      int vlen = Matcher::max_vector_size(bt);\n+      if (vlen == 0) {\n+        \/\/ Bail out if vector cannot hold such elements\n+        return false;\n+      }\n+      \/\/ We check special convert and min\/max ops first and then general ops\n+      if (VectorNode::is_convert_opcode(opc)) {\n+        Node* in = node->in(1);\n+        BasicType in_bt = is_loop_iv_or_incr(in) ? T_INT : elem_bt(in);\n+        if (in_bt == T_ILLEGAL || !same_element_size(in_bt, bt) ||\n+            !VectorCastNode::implemented(opc, vlen, in_bt, bt)) {\n+          trace_msg(\"Found unimplemented vector cast node\", node);\n+          return false;\n+        }\n+      } else if (VectorNode::is_minmax_opcode(opc) && is_subword_type(bt)) {\n+        \/\/ Java API for Math.min\/max operations supports only int, long, float\n+        \/\/ and double types. Bail out for subword min\/max operations.\n+        return false;\n+      } else {\n+        int vopc = 0;\n+        if (node->is_Mem()) {\n+          assert(node->is_Load() || node->is_Store(), \"Must be load or store\");\n+          vopc = node->is_Store() ? Op_StoreVectorMasked : Op_LoadVectorMasked;\n+          if (!Matcher::match_rule_supported_vector_masked(vopc, vlen, bt)) {\n+            trace_msg(\"Vector masked memory access is not implemented\", node);\n+            return false;\n+          }\n+        } else {\n+          vopc = VectorNode::opcode(opc, bt);\n+          if (vopc == 0 ||\n+            !Matcher::match_rule_supported_vector(vopc, vlen, bt)) {\n+            trace_msg(\"Vector replacement node is not implemented\", node);\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Find unhandled out-of-loop use of loop body nodes and untracked loop body\n+\/\/ nodes to bail out for complex loops\n+bool VectorMaskedLoop::analyze_loop_body_nodes() {\n+  ResourceMark rm;\n+  VectorSet tracked;\n+  int n_nodes = _body_nodes.length();\n+  \/\/ 1) Track all vectorization candidates and loop iv phi nodes\n+  for (int idx = 0; idx < n_nodes; idx++) {\n+    Node* node = _body_nodes.at(idx);\n+    if (has_valid_elem_bt(node) || is_loop_iv(node)) {\n+      tracked.set(idx);\n+    }\n+  }\n+  \/\/ 2) Track memory address computing nodes in VPointer node stacks\n+  for (int ptridx = 0; ptridx < _vptrs.length(); ptridx++) {\n+    Node_Stack* nstack = _vptrs.at(ptridx)->node_stack();\n+    while (nstack->is_nonempty()) {\n+      Node* node = nstack->node();\n+      if (in_body(node)) {\n+        tracked.set(rpo_idx(node));\n+      }\n+      nstack->pop();\n+    }\n+  }\n+  \/\/ 3) Up to this point, all tracked nodes shouldn't have out-of-loop users\n+  for (int idx = 0; idx < n_nodes; idx++) {\n+    Node* node = _body_nodes.at(idx);\n+    if (node->is_Store()) {\n+      \/\/ Only store nodes are exceptions\n+      continue;\n+    }\n+    if (tracked.test(idx)) {\n+      for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+        Node* out = node->fast_out(i);\n+        if (!in_body(out)) {\n+          trace_msg(\"Node has out-of-loop user found\", node);\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  \/\/ 4) Bail out if the loop body has extra node\n+  for (int idx = 0; idx < n_nodes; idx++) {\n+    Node* node = _body_nodes.at(idx);\n+    if (!tracked.test(idx) && !in_core(node) && !node->is_memory_phi()) {\n+      trace_msg(\"Found extra loop node in loop body\", node);\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Try creating a vector mask with the smallest vector element size\n+const TypeVectMask* VectorMaskedLoop::create_vector_mask_type() {\n+  BasicType vmask_bt = size_to_basic_type(_size_stats.smallest_size());\n+  int vlen = Matcher::max_vector_size(vmask_bt);\n+  if (!Matcher::match_rule_supported_vector(Op_LoopVectorMask, vlen, vmask_bt)) {\n+    \/\/ Unable to create vector mask with the vlen & bt on this platform\n+    return nullptr;\n+  }\n+  return (TypeVectMask*) TypeVect::makemask(vmask_bt, vlen);\n+}\n+\n+\/\/ This checks if memory access node is our supported pattern\n+bool VectorMaskedLoop::supported_mem_access(MemNode* mem) {\n+  \/\/ First do a quick check by searching existing VPointer(s)\n+  for (int idx = 0; idx < _vptrs.length(); idx++) {\n+    if (_vptrs.at(idx)->mem() == mem) {\n+      return true;\n+    }\n+  }\n+  \/\/ If not found, try creating a new VPointer and insert it\n+  VPointer* ptr = mem_access_to_vpointer(mem);\n+  if (ptr != nullptr) {\n+    _vptrs.push(ptr);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ This tries creating an VPointer object associated to the memory access.\n+\/\/ Return nullptr if it fails or the VPointer is not valid.\n+VPointer* VectorMaskedLoop::mem_access_to_vpointer(MemNode* mem) {\n+  \/\/ Should access memory of a Java primitive value\n+  BasicType mem_type = mem->memory_type();\n+  if (!is_java_primitive(mem_type)) {\n+    trace_msg(\"Only memory accesses of primitive types are supported\", mem, false);\n+    return nullptr;\n+  }\n+  \/\/ addp: memory address for loading\/storing an array element. It should be an\n+  \/\/ AddP node operating on an array of specific type\n+  Node* addp = mem->in(MemNode::Address);\n+  if (!addp->is_AddP() || !operates_on_array_of_type(addp, mem_type)) {\n+    trace_msg(\"Memory access has inconsistent type\", mem, false);\n+    return nullptr;\n+  }\n+  \/\/ Create a Node_Stack for VPointer's initial stack\n+  Node_Stack* nstack = new Node_Stack(_arena, 5);\n+  nstack->push(addp, 0);\n+  \/\/ addp2: another possible AddP node for array element addressing. It should\n+  \/\/ operate on the same memory type and have the same base with previous AddP.\n+  Node* addp2 = addp->in(AddPNode::Address);\n+  if (addp2->is_AddP()) {\n+    if (!operates_on_array_of_type(addp2, mem_type) ||\n+        addp->in(AddPNode::Base) != addp2->in(AddPNode::Base)) {\n+      trace_msg(\"Memory access has inconsistent type or base\", mem, false);\n+      return nullptr;\n+    }\n+    nstack->push(addp2, 1);\n+  }\n+\n+  \/\/ Check supported memory access via VPointer. It's not supported if\n+  \/\/  1) The constructed VPointer is invalid\n+  \/\/  2) Address is growing down (index scale * loop stride < 0)\n+  \/\/  3) Memory access scale is different from data size\n+  \/\/  4) The loop increment node is on the VPointer's node stack\n+  VPointer* ptr = new (_arena) VPointer(mem, _phase, _lpt, nstack, true);\n+  if (!ptr->valid()) {\n+    trace_msg(\"Memory access has unsupported address pattern\", mem, false);\n+    return nullptr;\n+  }\n+  int scale_in_bytes = ptr->scale_in_bytes();\n+  int element_size = type2aelembytes(mem_type);\n+  if (scale_in_bytes * _cl->stride_con() < 0 ||\n+      abs(scale_in_bytes) != element_size) {\n+    trace_msg(\"Memory access has unsupported direction or scale\", mem, false);\n+    return nullptr;\n+  }\n+  for (uint i = 0; i < nstack->size(); i++) {\n+    if (nstack->node_at(i) == _cl->incr()) {\n+      trace_msg(\"Memory access unexpectedly uses loop increment node\", mem, false);\n+      return nullptr;\n+    }\n+  }\n+\n+  return ptr;\n+}\n+\n+\/\/ Check if node operates on an array of specific type\n+bool VectorMaskedLoop::operates_on_array_of_type(Node* node, BasicType bt) {\n+  const TypeAryPtr* aryptr = node->bottom_type()->isa_aryptr();\n+  if (aryptr == nullptr) {\n+    return false;\n+  }\n+  BasicType elem_bt = aryptr->elem()->array_element_basic_type();\n+  return same_type_or_subword_size(elem_bt, bt);\n+}\n+\n+\n+\/\/ Below are actual loop transformation functions. Ideal graph transformations\n+\/\/ will be performed in this stage. The functions should be called only after\n+\/\/ the loop is considered vectorizable after the whole analysis.\n+\n+\/\/ Create a tree of vector masks for use of vectorized operations in the loop\n+Node_List* VectorMaskedLoop::create_vmask_tree(const TypeVectMask* t_vmask) {\n+  \/\/ Create the root vector mask node from given vector type\n+  int max_trip_cnt = _cl->trip_count();\n+  Node* root_vmask = _cl->stride_con() > 0 ?\n+      new LoopVectorMaskNode(_iv, _cl->limit(), t_vmask, max_trip_cnt) :\n+      new LoopVectorMaskNode(_cl->limit(), _iv, t_vmask, max_trip_cnt);\n+  _igvn->register_new_node_with_optimizer(root_vmask);\n+\n+  \/\/ Compute the depth of vector mask tree\n+  uint small = _size_stats.smallest_size();\n+  uint large = _size_stats.largest_size();\n+  uint tree_depth = exact_log2(large) - exact_log2(small) + 1;\n+  \/\/ All vector masks construct a perfect binary tree of \"2 ^ depth - 1\" nodes\n+  \/\/ We create a list of \"2 ^ depth\" nodes for easier computation.\n+  Node_List* vmask_tree = new Node_List(_arena, 1 << tree_depth);\n+  \/\/ The root vector mask is always placed at index 1\n+  vmask_tree->insert(1, root_vmask);\n+\n+  \/\/ Place extracted vector masks from the root mask\n+  for (uint lev = 0; lev < tree_depth - 1; lev++) {\n+    uint idx_start = 1 << lev;\n+    uint idx_end = 1 << (lev + 1);\n+    for (uint idx = idx_start; idx < idx_end; idx++) {\n+      \/\/ Calculate children's vector mask type from the parent's type\n+      Node* parent = vmask_tree->at(idx);\n+      int parent_size = type2aelembytes(Matcher::vector_element_basic_type(parent));\n+      BasicType child_bt = size_to_basic_type(parent_size * 2);\n+      int child_vlen = Matcher::max_vector_size(child_bt);\n+      const TypeVectMask* t_vmask = (TypeVectMask*) TypeVect::makemask(child_bt, child_vlen);\n+      \/\/ Create left and right child of the parent\n+      Node* left = new ExtractLowMaskNode(parent, t_vmask);\n+      _igvn->register_new_node_with_optimizer(left);\n+      vmask_tree->insert(2 * idx, left);\n+      Node* right = new ExtractHighMaskNode(parent, t_vmask);\n+      _igvn->register_new_node_with_optimizer(right);\n+      vmask_tree->insert(2 * idx + 1, right);\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    tty->print_cr(\"Generated vector masks in vmask tree\");\n+    for (uint lev = 0; lev < tree_depth; lev++) {\n+      uint lane_size = 1 << (exact_log2(small) + lev);\n+      tty->print_cr(\"Lane_size = %d\", lane_size);\n+      uint idx_start = 1 << lev;\n+      uint idx_end = 1 << (lev + 1);\n+      for (uint idx = idx_start; idx < idx_end; idx++) {\n+        Node* node = vmask_tree->at(idx);\n+        node->dump();\n+      }\n+    }\n+    tty->cr();\n+  }\n+#endif\n+\n+  return vmask_tree;\n+}\n+\n+\/\/ Helper method for finding or creating a vector input at specified index\n+Node* VectorMaskedLoop::get_vector_input(Node* node, uint idx) {\n+  assert(node != nullptr, \"Given node shouldn't be nullptr\");\n+  BasicType bt = elem_bt(node);\n+  Node* in = node->in(idx);\n+  assert(in != nullptr, \"Input node shouldn't be nullptr\");\n+\n+  \/\/ If input is already a vector node, just use it\n+  if (in->is_Vector() || in->is_LoadVector()) {\n+    return in;\n+  }\n+\n+  \/\/ Create a vector input for different scalar input cases\n+  int vlen = Matcher::max_vector_size(bt);\n+  if (is_loop_iv_or_incr(in)) {\n+    \/\/ Input is the loop iv or increment node\n+    BasicType pop_index_bt = is_subword_type(bt) ?\n+                             get_signed_subword_bt(bt) : T_INT;\n+    const TypeVect* vt = TypeVect::make(pop_index_bt, vlen);\n+    Node* n_stride = _igvn->intcon(_cl->stride_con());\n+    Node* start_index = _iv;\n+    if (is_loop_incr(in)) {\n+      start_index = new AddINode(_iv, n_stride);\n+      _igvn->register_new_node_with_optimizer(start_index);\n+    }\n+    Node* popindex = new PopulateIndexNode(start_index, n_stride, vt);\n+    _igvn->register_new_node_with_optimizer(popindex);\n+    VectorNode::trace_new_vector(popindex, \"VectorMasked\");\n+    return popindex;\n+  } else {\n+    \/\/ Input is a scalar value not in this loop\n+    assert(!in_body(in), \"Node shouldn't be in this loop\");\n+    if (VectorNode::is_roundopD(node) && idx == 2) {\n+      \/\/ 1) Just return the scalar input\n+      return in;\n+    } else {\n+      \/\/ 2) Need replicate the scalar input\n+      Node* vrep = nullptr;\n+      if (VectorNode::is_shift(node) && idx == 2) {\n+        \/\/ 2.1) Input is the 2nd (shift count) of left\/right shift\n+        assert(is_integral_type(bt), \"Shift operation should work on integers\");\n+        Node* mask_con = _igvn->intcon((bt == T_LONG) ?\n+                                       (BitsPerLong - 1) : (BitsPerInt - 1));\n+        Node* mask_op = new AndINode(in, mask_con);\n+        _igvn->register_new_node_with_optimizer(mask_op);\n+        vrep = VectorNode::shift_count(node->Opcode(), mask_op, vlen, bt);\n+      } else if (VectorNode::is_scalar_rotate(node) && idx == 2) {\n+        \/\/ 2.2) Input is the 2nd (rotate shift count) of rotate shift\n+        Node* conv = in;\n+        if (bt == T_LONG) {\n+          conv = new ConvI2LNode(in);\n+          _igvn->register_new_node_with_optimizer(conv);\n+        }\n+        vrep = VectorNode::scalar2vector(conv, vlen, Type::get_const_basic_type(bt));\n+      } else {\n+        \/\/ 2.3) Other general scalar inputs\n+        const Type* type = Type::get_const_basic_type(get_signed_subword_bt(bt));\n+        vrep = VectorNode::scalar2vector(in, vlen, type);\n+      }\n+      _igvn->register_new_node_with_optimizer(vrep);\n+      VectorNode::trace_new_vector(vrep, \"VectorMasked\");\n+      return vrep;\n+    }\n+  }\n+}\n+\n+\/\/ Replace scalar nodes in the loop by vector nodes from top to bottom and\n+\/\/ return the node map of scalar to vector replacement. The node map is used\n+\/\/ for vector duplication for larger types.\n+Node_List* VectorMaskedLoop::replace_scalar_ops(Node* mask) {\n+  \/\/ Create a node map of scalar to vector replacement\n+  int n_nodes = _body_nodes.length();\n+  Node_List* s2v_map = new Node_List(_arena, n_nodes);\n+\n+  \/\/ Replace each node with valid element basic type set\n+  for (int idx = 0; idx < n_nodes; idx++) {\n+    Node* snode = _body_nodes.at(idx);\n+    if (has_valid_elem_bt(snode)) {\n+      Node* vnode;\n+      int opc = snode->Opcode();\n+      BasicType bt = elem_bt(snode);\n+      int vlen = Matcher::max_vector_size(bt);\n+      if (snode->is_Mem()) {\n+        Node* ctrl = snode->in(MemNode::Control);\n+        Node* mem = snode->in(MemNode::Memory);\n+        Node* addr = snode->in(MemNode::Address);\n+        const TypePtr* at = snode->as_Mem()->adr_type();\n+        const TypeVect* vt = TypeVect::make(Type::get_const_basic_type(bt), vlen);\n+        if (snode->is_Load()) {\n+          vnode = new LoadVectorMaskedNode(ctrl, mem, addr, at, vt, mask);\n+        } else {\n+          assert(snode->is_Store(), \"Unexpected memory op\");\n+          Node* val = get_vector_input(snode, MemNode::ValueIn);\n+          vnode = new StoreVectorMaskedNode(ctrl, mem, addr, val, at, mask);\n+        }\n+      } else if (VectorNode::is_convert_opcode(opc)) {\n+        Node* in = get_vector_input(snode, 1);\n+        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n+        vnode = VectorCastNode::make(vopc, in, bt, vlen);\n+      } else {\n+        uint start, end;\n+        VectorNode::vector_operands(snode, &start, &end);\n+        assert(start == 1, \"Start should be 1 for all currently supported ops\");\n+        \/\/ The 1st operand is always there\n+        Node* in1 = get_vector_input(snode, 1);\n+        \/\/ The 2nd operand is optional and may be vector shift count\n+        Node* in2 = nullptr;\n+        if (end > 2 || VectorNode::is_shift(snode) || VectorNode::is_roundopD(snode)) {\n+          in2 = get_vector_input(snode, 2);\n+        }\n+        \/\/ The 3rd operand is optional\n+        if (end > 3) {\n+          Node* in3 = get_vector_input(snode, 3);\n+          vnode = VectorNode::make(opc, in1, in2, in3, vlen, bt);\n+        } else {\n+          vnode = VectorNode::make(opc, in1, in2, vlen, bt);\n+        }\n+      }\n+      VectorNode::trace_new_vector(vnode, \"VectorMasked\");\n+      _phase->set_ctrl(vnode, _phase->get_ctrl(snode));\n+      _igvn->replace_node(snode, _igvn->register_new_node_with_optimizer(vnode, snode));\n+      s2v_map->map(rpo_idx(snode), vnode);\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    tty->print_cr(\"Node scalar to vector replacements\");\n+    for (int idx = 0; idx < _body_nodes.length(); idx++) {\n+      Node* snode = _body_nodes.at(idx);\n+      if (has_valid_elem_bt(snode)) {\n+        Node* vnode = s2v_map->at(rpo_idx(snode));\n+        tty->print(\" Scalar:\\t\");\n+        snode->dump();\n+        tty->print(\"  Vector:\\t\");\n+        vnode->dump();\n+      }\n+    }\n+    tty->cr();\n+  }\n+#endif\n+\n+  return s2v_map;\n+}\n+\n+\/\/ Duplicate vectorized operations with given vector element size\n+void VectorMaskedLoop::duplicate_vector_ops(\n+                Node_List* vmask_tree, Node_List* s2v_map, int lane_size) {\n+  \/\/ Compute vector duplication count and the vmask tree level\n+  int dup_cnt = lane_size \/ _size_stats.smallest_size();\n+  int vmask_tree_level = exact_log2(dup_cnt);\n+\n+  \/\/ Collect and clone all vector nodes with given vector element size\n+  Node_List* clone_list = new Node_List(_arena);\n+  for (int idx = 0; idx < _stmts.length(); idx++) {\n+    Node_List* stmt = _stmts.at(idx);\n+    if (type2aelembytes(statement_bottom_type(stmt)) != lane_size) {\n+      continue;\n+    }\n+\n+    \/\/ Collect all nodes to be cloned\n+    for (uint i = 0; i < stmt->size(); i++) {\n+      Node* vnode = s2v_map->at(rpo_idx(stmt->at(i)));\n+      if (!clone_list->contains(vnode)) {\n+        clone_list->push(vnode);\n+      }\n+      \/\/ Also include vector operands of populate index nodes, because those\n+      \/\/ nodes also need to be cloned and adjusted\n+      uint start, end;\n+      VectorNode::vector_operands(vnode, &start, &end);\n+      for (uint i = start; i < end; i++) {\n+        Node* vopd = vnode->in(i);\n+        if (vopd->Opcode() == Op_PopulateIndex) {\n+          Node* init_idx = vopd->in(1);\n+          if (is_loop_iv(init_idx) || is_loop_incr_pattern(init_idx)) {\n+            if (!clone_list->contains(vopd)) {\n+              clone_list->push(vopd);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Clone \"dup_cnt - 1\" copies of collected vector nodes and insert the lists\n+  \/\/ of cloned nodes into an array. Also insert the list of the original vector\n+  \/\/ nodes at the array end.\n+  GrowableArray<Node_List*> vector_copies(_arena, dup_cnt, 0, nullptr);\n+  for (int i = 0; i < dup_cnt - 1; i++) {\n+    Node_List* cloned = clone_node_list(clone_list);\n+    vector_copies.push(cloned);\n+  }\n+  vector_copies.push(clone_list);\n+\n+  \/\/ As vector store nodes have phi output, to make adjustment simpler, we use\n+  \/\/ the original list to handle operations at max mask offset \"dup_cnt - 1\".\n+  \/\/ The cloned lists are for small mask offset from \"0\" to \"dup_cnt - 2\".\n+  Node* prev_store = nullptr;\n+  for (int level_offset = 0; level_offset < dup_cnt; level_offset++) {\n+    Node_List* vnodes = vector_copies.at(level_offset);\n+    for (uint i = 0; i < vnodes->size(); i++) {\n+      Node* vn = vnodes->at(i);\n+      \/\/ Do general vector node adjustment for the vector nodes\n+      adjust_vector_node(vn, vmask_tree, vmask_tree_level, level_offset);\n+      \/\/ Do cross-node adjustment for vector store nodes.\n+      if (vn->is_StoreVector()) {\n+        \/\/ For vector store nodes, we re-connect memory edges to the previous\n+        \/\/ vector store we just iterated\n+        if (prev_store != nullptr) {\n+          vn->set_req(MemNode::Memory, prev_store);\n+        }\n+        prev_store = vn;\n+      }\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    tty->print_cr(\"Duplicated vector nodes with lane size = %d\", lane_size);\n+    for (int level_offset = 0; level_offset < dup_cnt; level_offset++) {\n+      Node_List* vp = vector_copies.at(level_offset);\n+      tty->print_cr(\"Offset = %d\", level_offset);\n+      for (uint i = 0; i < vp->size(); i++) {\n+        vp->at(i)->dump();\n+      }\n+    }\n+    tty->cr();\n+  }\n+#endif\n+}\n+\n+\/\/ Helper function for general vector node adjustment after duplication\n+void VectorMaskedLoop::adjust_vector_node(Node* vn, Node_List* vmask_tree,\n+                                          int vmask_tree_level, int level_offset) {\n+  Node* vmask = vmask_tree->at((1 << vmask_tree_level) + level_offset);\n+  BasicType elem_bt = Matcher::vector_element_basic_type(vmask);\n+  int lane_size = type2aelembytes(elem_bt);\n+  uint vector_size_in_bytes = Matcher::max_vector_size(T_BYTE);\n+  assert(Matcher::vector_width_in_bytes(elem_bt) == (int) vector_size_in_bytes,\n+         \"should get the same vector width\");\n+  if (vn->is_Mem()) {\n+    \/\/ 1) For mem accesses, update the mask input, and add additional address\n+    \/\/    offset if mask offset is non-zero\n+    vn->set_req(vn->req() - 1, vmask);\n+    if (level_offset != 0) {\n+      Node* ptr = vn->in(MemNode::Address);\n+      Node* base = ptr->in(AddPNode::Base);\n+      Node* off = _igvn->MakeConX(vector_size_in_bytes * level_offset);\n+      Node* new_ptr = new AddPNode(base, ptr, off);\n+      _igvn->register_new_node_with_optimizer(new_ptr, ptr);\n+      vn->set_req(MemNode::Address, new_ptr);\n+    }\n+  } else if (vn->Opcode() == Op_PopulateIndex) {\n+    \/\/ 2) For populate index, update start index for non-zero mask offset\n+    if (level_offset != 0) {\n+      int v_stride = vector_size_in_bytes \/ lane_size * _cl->stride_con();\n+      Node* idx_off = _igvn->intcon(v_stride * level_offset);\n+      Node* new_base = new AddINode(vn->in(1), idx_off);\n+      _igvn->register_new_node_with_optimizer(new_base, vn->in(1));\n+      vn->set_req(1, new_base);\n+    }\n+  }\n+}\n+\n+\/\/ Helper function for duplicating a subgraph of nodes\n+Node_List* VectorMaskedLoop::clone_node_list(const Node_List* list) {\n+  assert(list != nullptr && list->size() > 0, \"Should not be empty\");\n+  uint size = list->size();\n+  Node_List* new_list = new Node_List(_arena, size);\n+  Node_List* clone_map = new Node_List(_arena, size);\n+  \/\/ Clone each node in the list\n+  for (uint i = 0; i < size; i++) {\n+    Node* old = list->at(i);\n+    Node* new_node = old->clone();\n+    clone_map->map(old->_idx, new_node);\n+    _igvn->register_new_node_with_optimizer(new_node, old);\n+    VectorNode::trace_new_vector(new_node, \"VectorMasked\");\n+    new_list->push(new_node);\n+  }\n+  \/\/ Re-connect input edges to the cloned node\n+  for (uint i = 0; i < size; i++) {\n+    Node* new_node = new_list->at(i);\n+    for (uint j = 0; j < new_node->req(); j++) {\n+      Node* in = new_node->in(j);\n+      if (in != nullptr && in->_idx < clone_map->max()) {\n+        Node* new_in = clone_map->at(in->_idx);\n+        if (new_in != nullptr) {\n+          new_node->set_req(j, new_in);\n+        }\n+      }\n+    }\n+  }\n+  return new_list;\n+}\n+\n+\/\/ Entry function of actual vector mask transformation\n+void VectorMaskedLoop::transform_loop(const TypeVectMask* t_vmask) {\n+  \/\/ Create a tree of vector masks for different vector element sizes\n+  Node_List* vmask_tree = create_vmask_tree(t_vmask);\n+  Node* root_vmask = vmask_tree->at(1);\n+\n+  \/\/ Replace vectorization candidate nodes to vector nodes. For now we only\n+  \/\/ generate a single vector node per scalar node. And that the duplication\n+  \/\/ afterwards makes sure that all scalar nodes are \"widened\" to the same\n+  \/\/ number of elements. The smalles type using a single vector, larger types\n+  \/\/ using multiple (duplicated) vectors per scalar node.\n+  Node_List* s2v_map = replace_scalar_ops(root_vmask);\n+\n+  \/\/ Duplicate and adjust vector operations with larger vector element sizes\n+  \/\/ which need multiple vectors to process\n+  int small = _size_stats.smallest_size();\n+  int large = _size_stats.largest_size();\n+  for (int lane_size = small * 2; lane_size <= large; lane_size *= 2) {\n+    if (_size_stats.count_size(lane_size) > 0) {\n+      duplicate_vector_ops(vmask_tree, s2v_map, lane_size);\n+    }\n+  }\n+\n+  \/\/ Update loop increment\/decrement to the vector mask true count\n+  Node* true_cnt = new VectorMaskTrueCountNode(root_vmask, TypeInt::INT);\n+  _igvn->register_new_node_with_optimizer(true_cnt);\n+  Node* new_incr;\n+  if (_cl->stride_con() > 0) {\n+    new_incr = new AddINode(_iv, true_cnt);\n+  } else {\n+    new_incr = new SubINode(_iv, true_cnt);\n+  }\n+  _igvn->register_new_node_with_optimizer(new_incr);\n+  _igvn->replace_node(_cl->incr(), new_incr);\n+}\n+\n+\n+\/\/ Function for debug printing\n+void VectorMaskedLoop::trace_msg(const char* msg, Node* n, bool dump_head) {\n+#ifndef PRODUCT\n+  if (TraceMaskedLoop) {\n+    if (dump_head) {\n+      _lpt->dump_head();\n+    }\n+    tty->print_cr(\"%s\", msg);\n+    if (n != nullptr) {\n+      n->dump();\n+    }\n+  }\n+#endif\n+}\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.cpp","additions":1003,"deletions":0,"binary":false,"changes":1003,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_OPTO_VMASKLOOP_HPP\n+#define SHARE_OPTO_VMASKLOOP_HPP\n+\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/vectorization.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+\n+\/\/        L O O P   V E C T O R   M A S K   T R A N S F O R M A T I O N\n+\/\/\n+\/\/ This implements yet another loop vectorizer which is different from SLP (or\n+\/\/ SuperWord) in the C2 compiler. We name it \"VectorMaskedLoop\" as it can take\n+\/\/ advantage of vector mask (predicate) features of some hardware platforms,\n+\/\/ such as x86 AVX-512 and AArch64 SVE, to vectorize loops with more elegant\n+\/\/ native code generated. The main idea of this vectorizer is widening scalar\n+\/\/ operations in the loop and adding vector masks to them. This vectorization\n+\/\/ approach does not require many pre-requisite loop transformations, such as\n+\/\/ loop iteration-split or unrolling.\n+\n+class VectorMaskedLoop : public ResourceObj {\n+ private:\n+  \/\/ Useful handles\n+  PhaseIdealLoop*            _phase;\n+  PhaseIterGVN*              _igvn;\n+  Arena*                     _arena;\n+\n+  \/\/ Loop information\n+  IdealLoopTree*             _lpt;          \/\/ Idealloop tree\n+  CountedLoopNode*           _cl;           \/\/ CountedLoop node\n+  CountedLoopEndNode*        _cle;          \/\/ CountedLoopEnd node\n+  PhiNode*                   _iv;           \/\/ Loop induction variable PhiNode\n+\n+  \/\/ Data structures for loop analysis\n+  Unique_Node_List           _core_set;     \/\/ Loop core nodes set for fast membership check\n+  Unique_Node_List           _body_set;     \/\/ Loop body nodes set for fast membership check\n+  GrowableArray<Node*>       _body_nodes;   \/\/ Loop body nodes with reverse postorder\n+  GrowableArray<int>         _rpo_idx;      \/\/ Map from node index to RPO traversal index\n+  GrowableArray<BasicType>   _elem_bt;      \/\/ Per node vector element basic type\n+  GrowableArray<Node_List*>  _stmts;        \/\/ Lists of nodes that make up loop statements\n+  GrowableArray<VPointer*>   _vptrs;        \/\/ VPointer array for memory access nodes\n+  VectorElementSizeStats     _size_stats;   \/\/ Statistics of data sizes in vectors\n+\n+  \/\/ Basic utilities\n+  bool in_core(Node* n)            { return n != nullptr && _core_set.member(n); }\n+  bool in_body(Node* n)            { return n != nullptr && _body_set.member(n); }\n+  int  rpo_idx(Node* n)            { assert(in_body(n), \"What?\"); return _rpo_idx.at(n->_idx); }\n+  void set_rpo_idx(Node* n, int i) { assert(in_body(n), \"What?\"); _rpo_idx.at_put_grow(n->_idx, i); }\n+\n+  BasicType statement_bottom_type(const Node_List* stmt) const {\n+    assert(stmt != nullptr && stmt->size() > 0, \"should not be empty\");\n+    assert(stmt->at(0)->is_Store(), \"Must be a store node\");\n+    return stmt->at(0)->as_Store()->memory_type();\n+  }\n+\n+  BasicType size_to_basic_type(const int size) const {\n+    BasicType bt = T_ILLEGAL;\n+    switch (size) {\n+      case 1: bt = T_BYTE;  break;\n+      case 2: bt = T_SHORT; break;\n+      case 4: bt = T_INT;   break;\n+      case 8: bt = T_LONG;  break;\n+      default: ShouldNotReachHere();\n+    }\n+    return bt;\n+  }\n+\n+  \/\/ Node vector element type accessors\n+  BasicType elem_bt(Node* n) { return _elem_bt.at(rpo_idx(n)); }\n+  void set_elem_bt(Node* n, BasicType bt) { _elem_bt.at_put(rpo_idx(n), bt); }\n+  bool has_valid_elem_bt(Node* n) { return elem_bt(n) != T_ILLEGAL; }\n+\n+  \/\/ Some node check utilities\n+  bool is_loop_iv(const Node* n) const { return n == _iv; }\n+  bool is_loop_incr(const Node* n) const { return n == _cl->incr(); }\n+\n+  bool is_loop_iv_or_incr(const Node* n) const {\n+    return n == _iv || n == _cl->incr();\n+  }\n+\n+  bool is_loop_incr_pattern(const Node* n) const {\n+    if (n != nullptr && n->is_Add() && n->in(1) == _iv && n->in(2)->is_Con()) {\n+      const Type* t = n->in(2)->bottom_type();\n+      return t->is_int()->get_con() == _cl->stride_con();\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Methods for loop vectorizable analysis\n+  void reset();\n+  bool collect_loop_nodes();\n+\n+  bool collect_statements_helper(const Node* node, const uint idx,\n+                                 Node_List* stmt, Node_List* worklist);\n+  bool collect_statements();\n+\n+  bool analyze_vectorizability();\n+  bool find_vector_element_types();\n+  bool vector_nodes_implemented();\n+  bool analyze_loop_body_nodes();\n+\n+  const TypeVectMask* create_vector_mask_type();\n+\n+  bool supported_mem_access(MemNode* mem);\n+  VPointer* mem_access_to_vpointer(MemNode* mem);\n+  bool operates_on_array_of_type(Node* node, BasicType bt);\n+\n+  \/\/ Methods for vector masked loop transformation\n+  Node_List* create_vmask_tree(const TypeVectMask* t_vmask);\n+  Node* get_vector_input(Node* node, uint idx);\n+  Node_List* replace_scalar_ops(Node* mask);\n+  void duplicate_vector_ops(Node_List* vmask_tree, Node_List* s2v_map, int lane_size);\n+  void adjust_vector_node(Node* vn, Node_List* vmask_tree, int level, int mask_off);\n+  Node_List* clone_node_list(const Node_List* list);\n+  void transform_loop(const TypeVectMask* t_vmask);\n+\n+  \/\/ Debug printing\n+  void trace_msg(const char* msg, Node* n = nullptr, bool dump_head = true);\n+\n+ public:\n+  VectorMaskedLoop(PhaseIdealLoop* phase);\n+  void try_vectorize_loop(IdealLoopTree* lpt);\n+};\n+\n+#endif \/\/ SHARE_OPTO_VMASKLOOP_HPP\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.hpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -1546,0 +1546,1 @@\n+  declare_c2_type(LoopVectorMaskNode, TypeNode)                           \\\n@@ -1797,0 +1798,2 @@\n+  declare_c2_type(LoadVectorMaskedNode, LoadVectorNode)                   \\\n+  declare_c2_type(StoreVectorMaskedNode, StoreVectorNode)                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -858,0 +858,4 @@\n+inline bool same_element_size(BasicType t1, BasicType t2) {\n+  return type2aelembytes(t1) == type2aelembytes(t2);\n+}\n+\n@@ -859,1 +863,7 @@\n-  return (t1 == t2) || (is_subword_type(t1) && type2aelembytes(t1) == type2aelembytes(t2));\n+  return (t1 == t2) || (is_subword_type(t1) && same_element_size(t1, t2));\n+}\n+\n+inline BasicType get_signed_subword_bt(BasicType bt) {\n+  if (bt == T_BOOLEAN) return T_BYTE;\n+  if (bt == T_CHAR) return T_SHORT;\n+  return bt;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -765,0 +765,5 @@\n+    public static final String LOOP_VECTOR_MASK = PREFIX + \"LOOP_VECTOR_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOOP_VECTOR_MASK, \"LoopVectorMask\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,0 +80,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +108,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -113,0 +122,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +136,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +150,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -146,0 +164,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -158,0 +179,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -170,0 +194,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -183,0 +210,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -197,0 +227,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -208,0 +241,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -73,0 +76,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -84,0 +90,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -95,0 +104,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -115,0 +127,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -126,0 +141,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -139,0 +157,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -94,0 +97,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -109,0 +115,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +133,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +147,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -150,0 +165,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -161,0 +179,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -173,0 +194,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -184,0 +208,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -195,0 +222,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -210,0 +240,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIfAnd = {\"UseMaskedLoop\", \"true\", \"OptimizeFill\", \"false\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +108,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -113,0 +122,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +136,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +150,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -146,0 +164,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -157,0 +178,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,0 +136,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -172,0 +175,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -226,0 +232,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -262,0 +271,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -72,0 +75,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,0 +80,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +108,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -82,0 +85,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -93,0 +99,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -104,0 +113,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -115,0 +127,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -126,0 +141,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -137,0 +155,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -149,0 +170,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -160,0 +184,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -171,0 +198,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -182,0 +212,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -194,0 +227,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -205,0 +241,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -83,0 +86,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -94,0 +100,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -105,0 +114,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -116,0 +128,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -128,0 +143,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -139,0 +157,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -151,0 +172,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -162,0 +186,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -173,0 +200,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -184,0 +214,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -196,0 +229,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -207,0 +243,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -218,0 +257,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -230,0 +272,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -80,0 +83,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +97,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +111,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -113,0 +125,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +139,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +153,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -146,0 +167,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -157,0 +181,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -168,0 +195,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -179,0 +209,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -190,0 +223,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -203,0 +239,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -216,0 +255,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -229,0 +271,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -244,0 +289,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -259,0 +307,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -272,0 +323,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -80,0 +83,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +97,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +111,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -113,0 +125,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +139,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +153,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -146,0 +167,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -157,0 +181,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -170,0 +197,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -183,0 +213,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -196,0 +229,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -211,0 +247,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -226,0 +265,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -239,0 +281,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -80,0 +83,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -91,0 +97,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -102,0 +111,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -113,0 +125,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -124,0 +139,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -135,0 +153,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -146,0 +167,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -158,0 +182,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -169,0 +196,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -180,0 +210,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -191,0 +224,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -203,0 +239,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -214,0 +253,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -225,0 +267,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -81,0 +84,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -92,0 +98,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -103,0 +112,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -114,0 +126,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -127,0 +142,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -138,0 +156,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -150,0 +171,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -161,0 +185,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -172,0 +199,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -183,0 +213,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -195,0 +228,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -206,0 +242,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -217,0 +256,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -82,0 +85,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -93,0 +99,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -104,0 +113,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -115,0 +127,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -126,0 +141,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -137,0 +155,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -149,0 +170,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -160,0 +184,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -171,0 +198,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -182,0 +212,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -194,0 +227,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -205,0 +241,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -253,0 +292,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -99,0 +102,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -112,0 +118,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -126,0 +135,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -140,0 +152,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -154,0 +169,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -372,0 +390,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -99,0 +102,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -110,0 +116,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -121,0 +130,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -132,0 +144,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -143,0 +158,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -158,0 +176,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -173,0 +194,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -186,0 +210,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -201,0 +228,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -214,0 +244,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -227,0 +260,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -240,0 +276,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -253,0 +292,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -265,0 +307,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -274,0 +319,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -292,0 +340,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -85,0 +88,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -97,0 +103,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -109,0 +118,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -121,0 +133,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -95,0 +98,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -106,0 +112,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -117,0 +126,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -128,0 +140,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -141,0 +156,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -214,0 +232,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -87,0 +90,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n@@ -103,0 +109,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+    @IR(applyIfCPUFeature = {\"sve\", \"true\"},\n+        applyIf = {\"UseMaskedLoop\", \"true\"},\n+        counts = {IRNode.LOOP_VECTOR_MASK, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}