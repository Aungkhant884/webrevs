{"files":[{"patch":"@@ -29,4 +29,0 @@\n-\/\/        L O O P   V E C T O R   M A S K   T R A N S F O R M A T I O N\n-\/\/ ============================================================================\n-\n-\/\/ -------------------------------- Constructor -------------------------------\n@@ -53,1 +49,1 @@\n-\/\/ ------------------- Entry function of vector masked loop -------------------\n+\/\/ Try vectorizing loop with vector masks - entry function of the vectorizer\n@@ -59,2 +55,6 @@\n-  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n-  assert(cl->is_post_loop() && !cl->is_vector_masked(),\n+  \/\/ Reset basic loop info\n+  _lpt = lpt;\n+  _cl = lpt->_head->as_CountedLoop();\n+  _cle = _cl->loopexit();\n+  _iv = _cle->phi();\n+  assert(_cl->is_post_loop() && !_cl->is_vector_masked(),\n@@ -63,2 +63,2 @@\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    trace_msg(nullptr, \"Loop is not a valid counted loop\");\n+  if (!_cl->is_valid_counted_loop(T_INT)) {\n+    trace_msg(\"Loop is not a valid counted loop\");\n@@ -67,2 +67,2 @@\n-  if (abs(cl->stride_con()) != 1) {\n-    trace_msg(nullptr, \"Loop has unsupported stride value\");\n+  if (abs(_cl->stride_con()) != 1) {\n+    trace_msg(\"Loop has unsupported stride value\", _cl->stride());\n@@ -71,2 +71,2 @@\n-  if (cl->loopexit()->in(0) != cl) {\n-    trace_msg(nullptr, \"Loop has unsupported control flow\");\n+  if (_cl->loopexit()->in(0) != _cl) {\n+    trace_msg(\"Loop has unsupported control flow\");\n@@ -75,2 +75,2 @@\n-  if (cl->back_control()->outcnt() != 1) {\n-    trace_msg(nullptr, \"Loop has node pinned to the backedge\");\n+  if (_cl->back_control()->outcnt() != 1) {\n+    trace_msg(\"Loop has node pinned to the backedge\");\n@@ -80,2 +80,2 @@\n-  \/\/ Init data structures and collect loop nodes\n-  init(lpt);\n+  \/\/ Collect loop info data structures and analyze vectorizability\n+  reset();\n@@ -83,2 +83,0 @@\n-\n-  \/\/ Collect loop statements and analyze vectorizability\n@@ -94,2 +92,2 @@\n-  cl->mark_loop_vectorized();\n-  cl->mark_vector_masked();\n+  _cl->mark_loop_vectorized();\n+  _cl->mark_vector_masked();\n@@ -97,1 +95,1 @@\n-  trace_msg(nullptr, \"Loop is vector masked\");\n+  trace_msg(\"Loop is vector masked\");\n@@ -100,7 +98,0 @@\n-\/\/ ----------------------------------- Init -----------------------------------\n-void VectorMaskedLoop::init(IdealLoopTree* lpt) {\n-  \/\/ Set current loop info\n-  _lpt = lpt;\n-  _cl = lpt->_head->as_CountedLoop();\n-  _cle = _cl->loopexit();\n-  _iv = _cle->phi();\n@@ -108,1 +99,6 @@\n-  \/\/ Reset data structures\n+\/\/ Below are loop vectorizable analysis functions. At the analysis stage, we\n+\/\/ collect enough loop information and check the vectorizability of the whole\n+\/\/ loop. The ideal graph is \"read-only\" at this time.\n+\n+\/\/ reset: all loop info should be reset at this point\n+void VectorMaskedLoop::reset() {\n@@ -119,1 +115,0 @@\n-\/\/ ------------------- Loop vectorizable analysis functions -------------------\n@@ -134,1 +129,1 @@\n-      trace_msg(n, \"Found unsupported node in the loop\");\n+      trace_msg(\"Found unsupported node in the loop\", n);\n@@ -180,1 +175,1 @@\n-    trace_msg(nullptr, \"Loop has unreachable node while traversing from head\");\n+    trace_msg(\"Loop has unreachable node while traversing from head\");\n@@ -219,1 +214,1 @@\n-      trace_msg(in, \"Populate index operation is not supported\");\n+      trace_msg(\"Populate index operation is not supported\", in);\n@@ -225,1 +220,1 @@\n-    trace_msg(in, \"Found unsupported phi input\");\n+    trace_msg(\"Found unsupported phi input\", in);\n@@ -233,1 +228,1 @@\n-      trace_msg(in, \"Found unsupported memory load input\");\n+      trace_msg(\"Found unsupported memory load input\", in);\n@@ -238,1 +233,1 @@\n-    trace_msg(in, \"Variant shift count is not supported\");\n+    trace_msg(\"Variant shift count is not supported\", in);\n@@ -265,1 +260,1 @@\n-    trace_msg(nullptr, \"No vectorizable statement is found\");\n+    trace_msg(\"No vectorizable statement is found\");\n@@ -313,1 +308,1 @@\n-    trace_msg(nullptr, \"Potential data dependence is found in the loop\");\n+    trace_msg(\"Potential data dependence is found in the loop\");\n@@ -344,1 +339,1 @@\n-            trace_msg(node, \"Vector element size does not match\");\n+            trace_msg(\"Vector element size does not match\", node);\n@@ -363,1 +358,1 @@\n-            trace_msg(node, \"Subword operand does not have precise type\");\n+            trace_msg(\"Subword operand does not have precise type\", node);\n@@ -373,1 +368,1 @@\n-              trace_msg(node, \"Inconsistent vector element size in one statement\");\n+              trace_msg(\"Inconsistent vector element size in one statement\", node);\n@@ -420,1 +415,1 @@\n-          trace_msg(node, \"Found unimplemented vector cast node\");\n+          trace_msg(\"Found unimplemented vector cast node\", node);\n@@ -433,1 +428,1 @@\n-            trace_msg(node, \"Vector masked memory access is not implemented\");\n+            trace_msg(\"Vector masked memory access is not implemented\", node);\n@@ -440,1 +435,1 @@\n-            trace_msg(node, \"Vector replacement node is not implemented\");\n+            trace_msg(\"Vector replacement node is not implemented\", node);\n@@ -485,1 +480,1 @@\n-          trace_msg(node, \"Node has out-of-loop user found\");\n+          trace_msg(\"Node has out-of-loop user found\", node);\n@@ -495,1 +490,1 @@\n-      trace_msg(node, \"Found extra loop node in loop body\");\n+      trace_msg(\"Found extra loop node in loop body\", node);\n@@ -522,1 +517,1 @@\n-  VPointer* ptr = mem_access_to_VPointer(mem);\n+  VPointer* ptr = mem_access_to_vpointer(mem);\n@@ -532,1 +527,1 @@\n-VPointer* VectorMaskedLoop::mem_access_to_VPointer(MemNode* mem) {\n+VPointer* VectorMaskedLoop::mem_access_to_vpointer(MemNode* mem) {\n@@ -536,1 +531,1 @@\n-    trace_msg(mem, \"Only memory accesses of primitive types are supported\");\n+    trace_msg(\"Only memory accesses of primitive types are supported\", mem, false);\n@@ -543,1 +538,1 @@\n-    trace_msg(mem, \"Memory access has inconsistent type\");\n+    trace_msg(\"Memory access has inconsistent type\", mem, false);\n@@ -555,1 +550,1 @@\n-      trace_msg(mem, \"Memory access has inconsistent type or base\");\n+      trace_msg(\"Memory access has inconsistent type or base\", mem, false);\n@@ -568,1 +563,1 @@\n-    trace_msg(mem, \"Memory access has unsupported address pattern\");\n+    trace_msg(\"Memory access has unsupported address pattern\", mem, false);\n@@ -575,1 +570,1 @@\n-    trace_msg(mem, \"Memory access has unsupported direction or scale\");\n+    trace_msg(\"Memory access has unsupported direction or scale\", mem, false);\n@@ -580,1 +575,1 @@\n-      trace_msg(mem, \"Memory access unexpectedly uses loop increment node\");\n+      trace_msg(\"Memory access unexpectedly uses loop increment node\", mem, false);\n@@ -598,1 +593,5 @@\n-\/\/ ------------------- Actual loop transformation functions -------------------\n+\n+\/\/ Below are actual loop transformation functions. Ideal graph transformations\n+\/\/ will be performed in this stage. The functions should be called only after\n+\/\/ the loop is considered vectorizable after the whole analysis.\n+\n@@ -990,2 +989,3 @@\n-\/\/ ------------------------------ Debug printing ------------------------------\n-void VectorMaskedLoop::trace_msg(Node* n, const char* msg) {\n+\n+\/\/ Function for debug printing\n+void VectorMaskedLoop::trace_msg(const char* msg, Node* n, bool dump_head) {\n@@ -994,0 +994,3 @@\n+    if (dump_head) {\n+      _lpt->dump_head();\n+    }\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.cpp","additions":61,"deletions":58,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -31,1 +31,11 @@\n-\/\/ ----------------------------- VectorMaskedLoop -----------------------------\n+\/\/        L O O P   V E C T O R   M A S K   T R A N S F O R M A T I O N\n+\/\/\n+\/\/ This implements yet another loop vectorizer which is different from SLP (or\n+\/\/ SuperWord) in the C2 compiler. We name it \"VectorMaskedLoop\" as it can take\n+\/\/ advantage of vector mask (predicate) features of some hardware platforms,\n+\/\/ such as x86 AVX-512 and AArch64 SVE, to vectorize loops with more elegant\n+\/\/ native code generated. The main idea of this vectorizer is widening scalar\n+\/\/ operations in the loop and adding vector masks to them. This vectorization\n+\/\/ approach does not require many pre-requisite loop transformations, such as\n+\/\/ loop iteration-split or unrolling.\n+\n@@ -92,1 +102,1 @@\n-  bool is_loop_incr_pattern (const Node* n) const {\n+  bool is_loop_incr_pattern(const Node* n) const {\n@@ -101,1 +111,1 @@\n-  void init(IdealLoopTree* lpt);\n+  void reset();\n@@ -116,1 +126,1 @@\n-  VPointer* mem_access_to_VPointer(MemNode* mem);\n+  VPointer* mem_access_to_vpointer(MemNode* mem);\n@@ -129,1 +139,1 @@\n-  void trace_msg(Node* n, const char* msg);\n+  void trace_msg(const char* msg, Node* n = nullptr, bool dump_head = true);\n","filename":"src\/hotspot\/share\/opto\/vmaskloop.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}