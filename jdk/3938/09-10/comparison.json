{"files":[{"patch":"@@ -62,1 +62,1 @@\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 124;\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 113;\n@@ -67,1 +67,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+    private static final int MAX_INSERTION_SORT_SIZE = 26;\n@@ -165,2 +165,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -171,1 +170,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -183,1 +182,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -191,1 +190,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -205,2 +204,1 @@\n-             * Switch to heap sort, if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -239,7 +237,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -247,5 +245,5 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -271,1 +269,2 @@\n-             * Try Radix sort on large fully random data.\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n@@ -316,7 +315,11 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -324,1 +327,1 @@\n-                 * Invariants\n+                 * Invariants:\n@@ -329,2 +332,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -336,9 +337,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -348,0 +342,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -372,1 +373,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -392,1 +393,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -400,1 +401,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -405,2 +410,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -450,2 +453,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -465,1 +468,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            int ai = a[i = low];\n@@ -468,1 +476,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -470,2 +478,1 @@\n-            for (int i; ++low < high; ) {\n-                int ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -473,4 +480,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -478,0 +491,2 @@\n+            a[i + 1] = ai;\n+        }\n@@ -479,1 +494,5 @@\n-        } else {\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            int ai = a[i = low];\n@@ -482,1 +501,1 @@\n-             * Start with pin insertion sort on small part.\n+             * Insert element into sorted part.\n@@ -484,4 +503,5 @@\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -489,7 +509,5 @@\n-                \/*\n-                 * Put elements larger than an element called pin\n-                 * to the end of array (the proper area for them).\n-                 * It avoids expensive movements of these elements\n-                 * through the whole array.\n-                 *\/\n-                if (p > i && ai > pin) { \/\/ Element, larger than pin\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -497,4 +515,6 @@\n-                    \/*\n-                     * Find element, smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -502,7 +522,2 @@\n-                    \/*\n-                     * Swap it with larger element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -510,0 +525,1 @@\n+                a[++i + 1] = a1;\n@@ -511,4 +527,1 @@\n-                \/*\n-                 * Insert element into sorted part.\n-                 *\/\n-                while (ai < a[--i]) {\n+                while (a2 < a[--i]) {\n@@ -517,8 +530,1 @@\n-                a[i + 1] = ai;\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n+                a[i + 1] = a2;\n@@ -526,18 +532,1 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -545,4 +534,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -550,4 +539,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -555,0 +542,1 @@\n+                a[i + 1] = a1;\n@@ -565,0 +553,1 @@\n+     * @param leftmost indicates that the range is the leftmost part\n@@ -566,3 +555,4 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            int ai = a[i = k];\n+    private static void insertionSort(int[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                int ai = a[i = k];\n@@ -570,2 +560,12 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n+                        a[i + 1] = a[i];\n+                    }\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                int ai = a[i = low];\n+\n+                while (ai < a[--i]) {\n@@ -1054,2 +1054,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1060,1 +1059,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1072,1 +1071,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -1080,1 +1079,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -1094,2 +1093,1 @@\n-             * Switch to heap sort, if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -1128,7 +1126,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -1136,5 +1134,5 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1160,1 +1158,2 @@\n-             * Try Radix sort on large fully random data.\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n@@ -1205,7 +1204,11 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1213,1 +1216,1 @@\n-                 * Invariants\n+                 * Invariants:\n@@ -1218,2 +1221,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -1225,9 +1226,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -1237,0 +1231,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -1261,1 +1262,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -1281,1 +1282,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -1289,1 +1290,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -1294,2 +1299,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -1339,2 +1342,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -1354,1 +1357,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            long ai = a[i = low];\n@@ -1357,1 +1365,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -1359,2 +1367,1 @@\n-            for (int i; ++low < high; ) {\n-                long ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -1362,4 +1369,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -1367,0 +1380,2 @@\n+            a[i + 1] = ai;\n+        }\n@@ -1368,1 +1383,5 @@\n-        } else {\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            long ai = a[i = low];\n@@ -1371,1 +1390,1 @@\n-             * Start with pin insertion sort on small part.\n+             * Insert element into sorted part.\n@@ -1373,4 +1392,5 @@\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -1378,7 +1398,5 @@\n-                \/*\n-                 * Put elements larger than an element called pin\n-                 * to the end of array (the proper area for them).\n-                 * It avoids expensive movements of these elements\n-                 * through the whole array.\n-                 *\/\n-                if (p > i && ai > pin) { \/\/ Element, larger than pin\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1386,4 +1404,6 @@\n-                    \/*\n-                     * Find element, smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -1391,7 +1411,2 @@\n-                    \/*\n-                     * Swap it with larger element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -1399,0 +1414,1 @@\n+                a[++i + 1] = a1;\n@@ -1400,4 +1416,1 @@\n-                \/*\n-                 * Insert element into sorted part.\n-                 *\/\n-                while (ai < a[--i]) {\n+                while (a2 < a[--i]) {\n@@ -1406,20 +1419,1 @@\n-                a[i + 1] = ai;\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                a[i + 1] = a2;\n@@ -1427,4 +1421,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -1432,6 +1423,4 @@\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -1439,4 +1428,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1444,0 +1431,1 @@\n+                a[i + 1] = a1;\n@@ -1454,0 +1442,1 @@\n+     * @param leftmost indicates that the range is the leftmost part\n@@ -1455,3 +1444,4 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            long ai = a[i = k];\n+    private static void insertionSort(long[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                long ai = a[i = k];\n@@ -1459,2 +1449,12 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n+                        a[i + 1] = a[i];\n+                    }\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                long ai = a[i = low];\n+\n+                while (ai < a[--i]) {\n@@ -2044,2 +2044,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2049,1 +2048,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2066,2 +2065,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -2097,7 +2095,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2105,5 +2103,5 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2164,7 +2162,11 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n+                 *\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2172,1 +2174,1 @@\n-                 * Invariants\n+                 * Invariants:\n@@ -2177,2 +2179,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -2184,9 +2184,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2196,0 +2189,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2215,1 +2215,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -2235,1 +2235,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2243,1 +2243,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -2248,2 +2252,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -2366,2 +2368,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2371,1 +2372,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2388,2 +2389,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -2419,7 +2419,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2427,5 +2427,5 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2486,7 +2486,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2494,1 +2494,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -2499,2 +2503,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -2506,9 +2508,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2518,0 +2513,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2537,1 +2539,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -2557,1 +2559,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2565,1 +2567,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -2570,2 +2576,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -2756,2 +2760,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2762,1 +2765,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2774,1 +2777,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -2782,1 +2785,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -2796,2 +2799,1 @@\n-             * Switch to heap sort, if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -2830,7 +2832,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2838,5 +2840,5 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2862,1 +2864,2 @@\n-             * Try Radix sort on large fully random data.\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n@@ -2907,7 +2910,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2915,1 +2918,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -2920,2 +2927,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -2927,9 +2932,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2939,0 +2937,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2963,1 +2968,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -2983,1 +2988,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2991,1 +2996,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -2996,2 +3005,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -3041,2 +3048,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -3056,1 +3063,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            float ai = a[i = low];\n@@ -3059,1 +3071,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -3061,2 +3073,1 @@\n-            for (int i; ++low < high; ) {\n-                float ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -3064,4 +3075,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -3069,0 +3086,2 @@\n+            a[i + 1] = ai;\n+        }\n@@ -3070,1 +3089,5 @@\n-        } else {\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            float ai = a[i = low];\n@@ -3073,1 +3096,1 @@\n-             * Start with pin insertion sort on small part.\n+             * Insert element into sorted part.\n@@ -3075,4 +3098,5 @@\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -3080,7 +3104,5 @@\n-                \/*\n-                 * Put elements larger than an element called pin\n-                 * to the end of array (the proper area for them).\n-                 * It avoids expensive movements of these elements\n-                 * through the whole array.\n-                 *\/\n-                if (p > i && ai > pin) { \/\/ Element, larger than pin\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -3088,4 +3110,6 @@\n-                    \/*\n-                     * Find element, smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3093,7 +3117,2 @@\n-                    \/*\n-                     * Swap it with larger element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3101,0 +3120,1 @@\n+                a[++i + 1] = a1;\n@@ -3102,4 +3122,1 @@\n-                \/*\n-                 * Insert element into sorted part.\n-                 *\/\n-                while (ai < a[--i]) {\n+                while (a2 < a[--i]) {\n@@ -3108,25 +3125,1 @@\n-                a[i + 1] = ai;\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                a[i + 1] = a2;\n@@ -3134,1 +3127,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -3136,4 +3129,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -3141,4 +3134,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3146,0 +3137,1 @@\n+                a[i + 1] = a1;\n@@ -3156,0 +3148,1 @@\n+     * @param leftmost indicates that the range is the leftmost part\n@@ -3157,3 +3150,4 @@\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n+    private static void insertionSort(float[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                float ai = a[i = k];\n@@ -3161,2 +3155,12 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n+                        a[i + 1] = a[i];\n+                    }\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                float ai = a[i = low];\n+\n+                while (ai < a[--i]) {\n@@ -3674,2 +3678,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3680,1 +3683,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3692,1 +3695,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -3700,1 +3703,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -3714,2 +3717,1 @@\n-             * Switch to heap sort, if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -3748,7 +3750,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -3756,5 +3758,5 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -3780,1 +3782,2 @@\n-             * Try Radix sort on large fully random data.\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n@@ -3825,7 +3828,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -3833,1 +3836,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -3838,2 +3845,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -3845,9 +3850,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -3857,0 +3855,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -3881,1 +3886,1 @@\n-            } else { \/\/ Partitioning with one pivot for repeated data\n+            } else { \/\/ Partitioning with one pivot\n@@ -3901,1 +3906,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -3909,1 +3914,5 @@\n-                 * Invariants\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n+                 * Invariants:\n@@ -3914,2 +3923,0 @@\n-                 *\n-                 * Pointer k is the last index of ?-part\n@@ -3959,2 +3966,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -3974,1 +3981,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            double ai = a[i = low];\n@@ -3977,1 +3989,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -3979,2 +3991,1 @@\n-            for (int i; ++low < high; ) {\n-                double ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -3982,4 +3993,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -3987,0 +4004,2 @@\n+            a[i + 1] = ai;\n+        }\n@@ -3988,1 +4007,5 @@\n-        } else {\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            double ai = a[i = low];\n@@ -3991,1 +4014,1 @@\n-             * Start with pin insertion sort on small part.\n+             * Insert element into sorted part.\n@@ -3993,4 +4016,5 @@\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -3998,7 +4022,5 @@\n-                \/*\n-                 * Put elements larger than an element called pin\n-                 * to the end of array (the proper area for them).\n-                 * It avoids expensive movements of these elements\n-                 * through the whole array.\n-                 *\/\n-                if (p > i && ai > pin) { \/\/ Element, larger than pin\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -4006,4 +4028,6 @@\n-                    \/*\n-                     * Find element, smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -4011,7 +4035,2 @@\n-                    \/*\n-                     * Swap it with larger element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -4019,0 +4038,1 @@\n+                a[++i + 1] = a1;\n@@ -4020,4 +4040,1 @@\n-                \/*\n-                 * Insert element into sorted part.\n-                 *\/\n-                while (ai < a[--i]) {\n+                while (a2 < a[--i]) {\n@@ -4026,20 +4043,1 @@\n-                a[i + 1] = ai;\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                a[i + 1] = a2;\n@@ -4047,6 +4045,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -4054,4 +4047,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -4059,4 +4052,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -4064,0 +4055,1 @@\n+                a[i + 1] = a1;\n@@ -4074,0 +4066,1 @@\n+     * @param leftmost indicates that the range is the leftmost part\n@@ -4075,3 +4068,4 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            double ai = a[i = k];\n+    private static void insertionSort(double[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                double ai = a[i = k];\n@@ -4079,2 +4073,12 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n+                        a[i + 1] = a[i];\n+                    }\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                double ai = a[i = low];\n+\n+                while (ai < a[--i]) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":572,"deletions":568,"binary":false,"changes":1140,"status":"modified"}]}