{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -39,2 +38,3 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, Radix sort, heap\n+ * sort, mixed (simple, pin, pair) insertion sort, counting sort and\n+ * parallel merge sort.\n@@ -47,1 +47,1 @@\n- * @version 2018.08.18\n+ * @version 2022.06.14\n@@ -49,1 +49,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 20\n@@ -58,0 +58,2 @@\n+    \/* ---------------- Insertion sort section ---------------- *\/\n+\n@@ -61,1 +63,1 @@\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 124;\n@@ -66,6 +68,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n-\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n@@ -73,4 +70,1 @@\n-    \/**\n-     * Min array size to try merging of runs.\n-     *\/\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    \/* ----------------- Merging sort section ----------------- *\/\n@@ -79,1 +73,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min array size to use merging sort.\n@@ -81,1 +75,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -84,1 +78,1 @@\n-     * Min factor for the first runs to continue scanning.\n+     * Min size of run to continue scanning.\n@@ -86,1 +80,1 @@\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    private static final int MIN_RUN_SIZE = 128;\n@@ -88,4 +82,1 @@\n-    \/**\n-     * Max capacity of the index array for tracking runs.\n-     *\/\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    \/* ------------------ Radix sort section ------------------ *\/\n@@ -94,1 +85,1 @@\n-     * Min number of runs, required by parallel merging.\n+     * Min array size to use Radix sort.\n@@ -96,1 +87,1 @@\n-    private static final int MIN_RUN_COUNT = 4;\n+    private static final int MIN_RADIX_SORT_SIZE = 768;\n@@ -98,4 +89,1 @@\n-    \/**\n-     * Min array size to use parallel merging of parts.\n-     *\/\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    \/* ------------------ Counting sort section --------------- *\/\n@@ -113,0 +101,2 @@\n+    \/* -------------------- Common section -------------------- *\/\n+\n@@ -114,1 +104,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Min array size to perform sorting in parallel.\n@@ -116,1 +106,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 1024;\n@@ -119,1 +109,1 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Max recursive depth before switching to heap sort.\n@@ -121,1 +111,1 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -124,6 +114,2 @@\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n+     * Max size of additional buffer,\n+     *      limited by max_heap \/ 128 or 2 GB max.\n@@ -131,2 +117,2 @@\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n+    private static final int MAX_4_BYTE_BUFFER_SIZE =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 7, Integer.MAX_VALUE);\n@@ -134,5 +120,6 @@\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n+    \/**\n+     * Max size of additional buffer,\n+     *      limited by max_heap \/ 256 or 2 GB max.\n+     *\/\n+    private static final int MAX_8_BYTE_BUFFER_SIZE =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 8, Integer.MAX_VALUE);\n@@ -159,3 +146,1 @@\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+            new Sorter(a, tryIntAllocate(size), parallelism, low, size, 0).invoke();\n@@ -168,2 +153,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -174,1 +158,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -180,1 +164,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -183,1 +167,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -186,1 +170,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high);\n@@ -199,11 +183,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -211,2 +185,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -220,1 +194,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -228,0 +202,1 @@\n+            int end = high - 1;\n@@ -235,0 +210,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n+\n@@ -239,7 +217,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -247,5 +225,5 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -253,0 +231,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -267,0 +248,19 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -272,1 +272,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -303,7 +303,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -311,1 +311,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -313,3 +315,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -317,1 +317,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -323,9 +325,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -335,0 +330,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -352,2 +354,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -359,1 +361,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -377,1 +379,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -379,1 +381,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -387,1 +389,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -389,3 +393,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -393,1 +395,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -425,1 +429,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -437,2 +441,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -448,1 +452,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -451,2 +454,2 @@\n-    private static void mixedInsertionSort(int[] a, int low, int end, int high) {\n-        if (end == high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n+        int size = high - low;\n@@ -454,4 +457,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n@@ -465,29 +469,2 @@\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            return;\n+        }\n@@ -495,4 +472,5 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+        \/*\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n@@ -500,7 +478,5 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n@@ -508,8 +484,6 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -519,1 +493,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -521,2 +495,5 @@\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -524,6 +501,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -531,4 +507,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -536,4 +514,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -541,1 +519,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -543,4 +524,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -548,4 +526,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -553,0 +529,6 @@\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n@@ -564,1 +546,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n@@ -568,8 +550,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n+            if (ai < a[low]) {\n@@ -577,17 +552,3 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -595,12 +556,1 @@\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                a[low] = ai;\n@@ -608,8 +558,7 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -618,1 +567,0 @@\n-        a[p] = value;\n@@ -622,1 +570,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -626,3 +574,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -630,1 +578,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, int[] a, int low, int high) {\n@@ -633,3 +581,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -637,0 +584,1 @@\n+        int count = 1;\n@@ -638,2 +586,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -644,1 +590,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -647,1 +593,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -672,1 +618,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -675,1 +629,0 @@\n-                if (k == high) {\n@@ -677,0 +630,1 @@\n+                if (k == high) {\n@@ -678,1 +632,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -684,10 +638,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -696,12 +641,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -709,0 +643,1 @@\n+                if (++count == run.length) {\n@@ -714,0 +649,1 @@\n+            }\n@@ -715,1 +651,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -717,5 +656,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -723,1 +662,0 @@\n-            run[count] = (last = k);\n@@ -727,1 +665,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -732,3 +670,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = (int[]) sorter.b) != null) {\n@@ -736,0 +672,2 @@\n+            } else if ((b = tryIntAllocate(high - low)) == null) {\n+                return false;\n@@ -762,3 +700,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -775,1 +711,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -777,11 +713,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        int[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        int[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -796,1 +723,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -835,1 +765,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -847,1 +777,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -859,0 +789,3 @@\n+                \/*\n+                 * Reserve space for the left part.\n+                 *\/\n@@ -862,1 +795,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -864,1 +797,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -867,1 +800,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -892,2 +825,0 @@\n-\/\/ [long]\n-\n@@ -895,8 +826,2 @@\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -905,1 +830,0 @@\n-     * @param parallelism the parallelism level\n@@ -908,0 +832,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -909,2 +834,2 @@\n-    static void sort(long[] a, int parallelism, int low, int high) {\n-        int size = high - low;\n+    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n@@ -912,6 +837,7 @@\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n-        } else {\n-            sort(null, a, 0, low, high);\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (int[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryIntAllocate(size)) == null) {\n+            return false;\n@@ -919,1 +845,0 @@\n-    }\n@@ -921,14 +846,2 @@\n-    \/**\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param bits the combination of recursion depth and bit flag, where\n-     *        the right bit \"0\" indicates that array is the leftmost part\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n-        while (true) {\n-            int end = high - 1, size = high - low;\n+        int start = low - offset;\n+        int last = high - offset;\n@@ -936,7 +849,12 @@\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n-                return;\n-            }\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ a[i]         & 0x3FF]--;\n+            count2[(a[i] >>> 10) & 0x7FF]--;\n+            count3[(a[i] >>> 21) ^ 0x400]--; \/\/ Reverse the sign bit\n+        }\n@@ -944,7 +862,6 @@\n-            \/*\n-             * Invoke insertion sort on small leftmost part.\n-             *\/\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                insertionSort(a, low, high);\n-                return;\n-            }\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n@@ -952,7 +869,6 @@\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[a[i] & 0x3FF]++ - offset] = a[i];\n@@ -960,0 +876,1 @@\n+        }\n@@ -961,7 +878,12 @@\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n@@ -969,0 +891,1 @@\n+        }\n@@ -970,1 +893,182 @@\n-            \/*\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Checks the count array and then creates histogram.\n+     *\n+     * @param count the count array\n+     * @param last the last index of count array\n+     * @param total the total number of elements\n+     * @param high the index of the last element, exclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int last, int total, int high) {\n+\n+        \/*\n+         * Check if we can skip given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c < 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[last] += high;\n+\n+        for (int i = last; i > 0; --i) {\n+            count[i - 1] += count[i];\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static int[] tryIntAllocate(int size) {\n+        try {\n+            return size < MAX_4_BYTE_BUFFER_SIZE ? new int[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+\/\/ #[long]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(long[] a, int parallelism, int low, int high) {\n+        int size = high - low;\n+\n+        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, tryLongAllocate(size), parallelism, low, size, 0).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param sorter parallel context\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                mixedInsertionSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Try merging sort on large part.\n+             *\/\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n@@ -974,1 +1078,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -982,0 +1086,1 @@\n+            int end = high - 1;\n@@ -989,0 +1094,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n+\n@@ -993,7 +1101,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -1001,5 +1109,5 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1007,0 +1115,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -1021,0 +1132,19 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -1026,1 +1156,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -1057,7 +1187,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -1065,1 +1195,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1067,3 +1199,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -1071,1 +1201,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -1077,9 +1209,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -1089,0 +1214,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -1106,2 +1238,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -1113,1 +1245,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -1131,1 +1263,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -1133,1 +1265,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -1141,1 +1273,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1143,3 +1277,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -1147,1 +1279,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -1179,1 +1313,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -1191,2 +1325,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -1202,1 +1336,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -1205,2 +1338,2 @@\n-    private static void mixedInsertionSort(long[] a, int low, int end, int high) {\n-        if (end == high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n+        int size = high - low;\n@@ -1208,4 +1341,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n@@ -1219,29 +1353,2 @@\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            return;\n+        }\n@@ -1249,4 +1356,5 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+        \/*\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n@@ -1254,7 +1362,5 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n@@ -1262,8 +1368,6 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -1273,1 +1377,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -1275,2 +1379,5 @@\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -1278,6 +1385,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1285,4 +1391,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -1290,4 +1398,9 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1295,1 +1408,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -1297,4 +1410,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -1302,4 +1415,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1307,0 +1418,1 @@\n+                a[i + 1] = a1;\n@@ -1318,1 +1430,1 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n+    static void insertionSort(long[] a, int low, int high) {\n@@ -1322,8 +1434,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n+            if (ai < a[low]) {\n@@ -1331,17 +1436,3 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -1349,12 +1440,1 @@\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                a[low] = ai;\n@@ -1362,8 +1442,7 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -1372,1 +1451,0 @@\n-        a[p] = value;\n@@ -1376,1 +1454,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1380,3 +1458,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1384,1 +1462,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, long[] a, int low, int high) {\n@@ -1387,3 +1465,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1391,0 +1468,1 @@\n+        int count = 1;\n@@ -1392,2 +1470,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1398,1 +1474,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1401,1 +1477,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -1426,1 +1502,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -1429,1 +1513,0 @@\n-                if (k == high) {\n@@ -1431,0 +1514,1 @@\n+                if (k == high) {\n@@ -1432,1 +1516,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -1438,10 +1522,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -1450,12 +1525,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1463,0 +1527,1 @@\n+                if (++count == run.length) {\n@@ -1468,0 +1533,1 @@\n+            }\n@@ -1469,1 +1535,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -1471,5 +1540,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -1477,1 +1546,0 @@\n-            run[count] = (last = k);\n@@ -1481,1 +1549,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1486,3 +1554,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = (long[]) sorter.b) != null) {\n@@ -1490,0 +1556,2 @@\n+            } else if ((b = tryLongAllocate(high - low)) == null) {\n+                return false;\n@@ -1516,3 +1584,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1529,1 +1595,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -1531,11 +1597,2 @@\n-        long[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        long[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        long[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -1550,1 +1607,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -1589,1 +1649,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -1601,1 +1661,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -1613,0 +1673,3 @@\n+                \/*\n+                 * Reserve space for the left part.\n+                 *\/\n@@ -1616,1 +1679,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -1618,1 +1681,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -1621,1 +1684,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -1646,2 +1709,0 @@\n-\/\/ [byte]\n-\n@@ -1649,2 +1710,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -1655,0 +1716,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1656,5 +1718,10 @@\n-    static void sort(byte[] a, int low, int high) {\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            insertionSort(a, low, high);\n+    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (long[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryLongAllocate(size)) == null) {\n+            return false;\n@@ -1662,0 +1729,124 @@\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (a[i]         & 0x3FF)]--;\n+            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;\n+            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;\n+            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;\n+            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;\n+            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n@@ -1665,1 +1856,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Sorts the specified range of the array using heap sort.\n@@ -1671,3 +1862,10 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            byte ai = a[i = k];\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n@@ -1675,5 +1873,21 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1682,0 +1896,33 @@\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static long[] tryLongAllocate(int size) {\n+        try {\n+            return size < MAX_8_BYTE_BUFFER_SIZE ? new long[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+\/\/ #[byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using\n+     * counting sort or insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            insertionSort(a, low, high);\n+        }\n@@ -1705,1 +1952,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram for all values.\n@@ -1710,1 +1957,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -1734,1 +1981,31 @@\n-\/\/ [char]\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(byte[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            byte ai = a[i = k];\n+\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n+            }\n+        }\n+    }\n+\n+\/\/ #[char]\n@@ -1753,2 +2030,42 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * The number of distinct char values.\n+     *\/\n+    private static final int NUM_CHAR_VALUES = 1 << 16;\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void countingSort(char[] a, int low, int high) {\n+        int[] count = new int[NUM_CHAR_VALUES];\n+\n+        \/*\n+         * Compute the histogram for all values.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i]]);\n+\n+        \/*\n+         * Put values on their final positions.\n+         *\/\n+        if (high - low > NUM_CHAR_VALUES) {\n+            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n+                for (low = high - count[--i]; high > low;\n+                    a[--high] = (char) i\n+                );\n+            }\n+        } else {\n+            for (int i = NUM_CHAR_VALUES; high > low; ) {\n+                while (count[--i] == 0);\n+                int c = count[i];\n+\n+                do {\n+                    a[--high] = (char) i;\n+                } while (--c > 0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1758,1 +2075,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1764,1 +2081,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1767,1 +2084,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -1775,2 +2092,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -1778,1 +2094,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -1787,1 +2103,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -1795,0 +2111,1 @@\n+            int end = high - 1;\n@@ -1806,7 +2123,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -1814,5 +2131,5 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1820,0 +2137,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -1839,1 +2159,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -1870,7 +2190,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -1878,1 +2198,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1880,3 +2202,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -1884,1 +2204,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -1890,9 +2212,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -1902,0 +2217,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -1921,1 +2243,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -1939,1 +2261,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -1941,1 +2263,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -1949,0 +2271,4 @@\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n+                 *\n@@ -1951,5 +2277,3 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -1999,1 +2323,1 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n+    static void insertionSort(char[] a, int low, int high) {\n@@ -2003,4 +2327,14 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n@@ -2012,0 +2346,2 @@\n+\/\/ #[short]\n+\n@@ -2013,1 +2349,6 @@\n-     * The number of distinct char values.\n+     * Sorts the specified range of the array using\n+     * counting sort or Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -2015,1 +2356,17 @@\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n+    static void sort(short[] a, int low, int high) {\n+        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+\n+    \/**\n+     * The number of distinct short values.\n+     *\/\n+    private static final int NUM_SHORT_VALUES = 1 << 16;\n+\n+    \/**\n+     * Max index of short counter.\n+     *\/\n+    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n@@ -2024,2 +2381,2 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    private static void countingSort(short[] a, int low, int high) {\n+        int[] count = new int[NUM_SHORT_VALUES];\n@@ -2028,1 +2385,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram for all values.\n@@ -2030,1 +2387,1 @@\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n@@ -2033,1 +2390,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2035,4 +2392,6 @@\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n+        if (high - low > NUM_SHORT_VALUES) {\n+            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n+                int value = i & 0xFFFF;\n+\n+                for (low = high - count[value]; high > low;\n+                    a[--high] = (short) value\n@@ -2042,3 +2401,5 @@\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n+            for (int i = MAX_SHORT_INDEX; high > low; ) {\n+                while (count[--i & 0xFFFF] == 0);\n+\n+                int value = i & 0xFFFF;\n+                int c = count[value];\n@@ -2047,1 +2408,1 @@\n-                    a[--high] = (char) i;\n+                    a[--high] = (short) value;\n@@ -2053,18 +2414,0 @@\n-\/\/ [short]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(short[] a, int low, int high) {\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            sort(a, 0, low, high);\n-        }\n-    }\n-\n@@ -2072,2 +2415,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2077,1 +2419,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2083,1 +2425,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2086,1 +2428,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2094,2 +2436,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -2097,1 +2438,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -2106,1 +2447,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -2114,0 +2455,1 @@\n+            int end = high - 1;\n@@ -2125,7 +2467,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2133,5 +2475,5 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2139,0 +2481,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2158,1 +2503,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2189,7 +2534,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2197,1 +2542,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2199,3 +2546,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -2203,1 +2548,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -2209,9 +2556,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2221,0 +2561,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2240,1 +2587,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2258,1 +2605,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2260,1 +2607,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2268,1 +2615,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2270,3 +2619,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -2274,1 +2621,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -2318,1 +2667,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2322,33 +2671,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n-\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+            if (ai < a[low]) {\n@@ -2356,6 +2673,3 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -2363,7 +2677,1 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n+                a[low] = ai;\n@@ -2371,2 +2679,1 @@\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n+             } else if (ai < a[i - 1]) {\n@@ -2375,2 +2682,4 @@\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -2381,1 +2690,1 @@\n-\/\/ [float]\n+\/\/ #[float]\n@@ -2425,3 +2734,1 @@\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+            new Sorter(a, tryFloatAllocate(size), parallelism, low, size, 0).invoke();\n@@ -2463,2 +2770,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2469,1 +2775,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2475,1 +2781,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2478,1 +2784,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2481,1 +2787,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high);\n@@ -2494,11 +2800,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -2506,2 +2802,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2515,1 +2811,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -2523,0 +2819,1 @@\n+            int end = high - 1;\n@@ -2530,0 +2827,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n+\n@@ -2534,7 +2834,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2542,5 +2842,5 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2548,0 +2848,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2562,0 +2865,19 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -2567,1 +2889,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2598,7 +2920,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2606,1 +2928,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2608,3 +2932,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -2612,1 +2934,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -2618,9 +2942,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2630,0 +2947,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2647,2 +2971,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -2654,1 +2978,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2672,1 +2996,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2674,1 +2998,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2682,1 +3006,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2684,3 +3010,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -2688,1 +3012,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -2720,1 +3046,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -2732,2 +3058,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -2743,1 +3069,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -2746,2 +3071,2 @@\n-    private static void mixedInsertionSort(float[] a, int low, int end, int high) {\n-        if (end == high) {\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n+        int size = high - low;\n@@ -2749,4 +3074,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n@@ -2760,29 +3086,2 @@\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            return;\n+        }\n@@ -2790,4 +3089,5 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+        \/*\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n@@ -2795,7 +3095,5 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n@@ -2803,8 +3101,6 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -2814,1 +3110,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -2816,32 +3112,2 @@\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -2849,0 +3115,1 @@\n+            a[i + 1] = ai;\n@@ -2850,1 +3117,0 @@\n-    }\n@@ -2852,10 +3118,5 @@\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -2863,3 +3124,9 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -2867,4 +3134,1 @@\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n+                a[++i + 1] = a1;\n@@ -2872,15 +3136,17 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n+\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n@@ -2891,1 +3157,1 @@\n-     * Pushes specified element down during heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -2893,3 +3159,1 @@\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n+     * @param a the array to be sorted\n@@ -2899,3 +3163,3 @@\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+    static void insertionSort(float[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            float ai = a[i = k];\n@@ -2903,8 +3167,15 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -2913,1 +3184,0 @@\n-        a[p] = value;\n@@ -2917,1 +3187,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -2921,3 +3191,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -2925,1 +3195,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, float[] a, int low, int high) {\n@@ -2928,3 +3198,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -2932,0 +3201,1 @@\n+        int count = 1;\n@@ -2933,2 +3203,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -2939,1 +3207,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -2942,1 +3210,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -2967,1 +3235,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -2970,1 +3246,0 @@\n-                if (k == high) {\n@@ -2972,0 +3247,1 @@\n+                if (k == high) {\n@@ -2973,1 +3249,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -2979,10 +3255,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -2991,12 +3258,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3004,0 +3260,1 @@\n+                if (++count == run.length) {\n@@ -3009,0 +3266,1 @@\n+            }\n@@ -3010,1 +3268,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3012,5 +3273,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3018,1 +3279,0 @@\n-            run[count] = (last = k);\n@@ -3022,1 +3282,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3027,3 +3287,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = (float[]) sorter.b) != null) {\n@@ -3031,0 +3289,2 @@\n+            } else if ((b = tryFloatAllocate(high - low)) == null) {\n+                return false;\n@@ -3057,3 +3317,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3070,1 +3328,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -3072,11 +3330,2 @@\n-        float[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        float[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        float[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -3091,1 +3340,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -3130,1 +3382,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -3142,1 +3394,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -3154,0 +3406,3 @@\n+                \/*\n+                 * Reserve space for the left part.\n+                 *\/\n@@ -3157,1 +3412,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -3159,1 +3414,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -3162,1 +3417,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -3187,1 +3442,162 @@\n-\/\/ [double]\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (float[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryFloatAllocate(size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ fti(a[i])         & 0x3FF]--;\n+            count2[(fti(a[i]) >>> 10) & 0x7FF]--;\n+            count3[(fti(a[i]) >>> 21) & 0x7FF]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the float value.\n+     *\n+     * @param f the given value\n+     * @return masked bits\n+     *\/\n+    private static int fti(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x ^ ((x >> 31) | 0x80000000);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static float[] tryFloatAllocate(int size) {\n+        try {\n+            return size < MAX_4_BYTE_BUFFER_SIZE ? new float[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+\/\/ #[double]\n@@ -3231,3 +3647,1 @@\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+            new Sorter(a, tryDoubleAllocate(size), parallelism, low, size, 0).invoke();\n@@ -3269,2 +3683,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3275,1 +3688,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3281,1 +3694,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -3284,1 +3697,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3287,1 +3700,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high);\n@@ -3300,11 +3713,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n-                return;\n-            }\n-\n-            \/*\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -3312,2 +3715,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3321,1 +3724,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -3329,0 +3732,1 @@\n+            int end = high - 1;\n@@ -3336,0 +3740,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n+\n@@ -3340,7 +3747,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -3348,5 +3755,5 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -3354,0 +3761,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -3368,0 +3778,19 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -3373,1 +3802,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -3404,7 +3833,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -3412,1 +3841,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -3414,3 +3845,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -3418,1 +3847,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -3424,9 +3855,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -3436,0 +3860,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -3453,2 +3884,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -3460,1 +3891,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3478,1 +3909,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -3480,1 +3911,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -3488,1 +3919,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -3490,3 +3923,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -3494,1 +3925,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -3526,1 +3959,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -3538,2 +3971,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -3549,1 +3982,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -3552,2 +3984,2 @@\n-    private static void mixedInsertionSort(double[] a, int low, int end, int high) {\n-        if (end == high) {\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n+        int size = high - low;\n@@ -3555,4 +3987,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n@@ -3566,29 +3999,2 @@\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            return;\n+        }\n@@ -3596,4 +4002,5 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+        \/*\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n@@ -3601,7 +4008,5 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n@@ -3609,8 +4014,6 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3620,1 +4023,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3622,2 +4025,5 @@\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -3625,6 +4031,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3632,4 +4037,11 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3637,4 +4049,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3642,1 +4054,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -3644,4 +4056,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -3649,4 +4061,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3654,0 +4064,1 @@\n+                a[i + 1] = a1;\n@@ -3665,1 +4076,1 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n+    static void insertionSort(double[] a, int low, int high) {\n@@ -3669,8 +4080,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n+            if (ai < a[low]) {\n@@ -3678,17 +4082,3 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -3696,12 +4086,1 @@\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                a[low] = ai;\n@@ -3709,8 +4088,7 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -3719,1 +4097,0 @@\n-        a[p] = value;\n@@ -3723,1 +4100,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3727,3 +4104,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3731,1 +4108,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, double[] a, int low, int high) {\n@@ -3734,3 +4111,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3738,0 +4114,1 @@\n+        int count = 1;\n@@ -3739,2 +4116,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3745,1 +4120,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3748,1 +4123,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -3773,1 +4148,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -3776,1 +4159,0 @@\n-                if (k == high) {\n@@ -3778,0 +4160,1 @@\n+                if (k == high) {\n@@ -3779,1 +4162,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3785,10 +4168,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -3797,12 +4171,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3810,0 +4173,1 @@\n+                if (++count == run.length) {\n@@ -3815,0 +4179,1 @@\n+            }\n@@ -3816,1 +4181,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3818,5 +4186,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3824,1 +4192,0 @@\n-            run[count] = (last = k);\n@@ -3828,1 +4195,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3833,3 +4200,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = (double[]) sorter.b) != null) {\n@@ -3837,0 +4202,2 @@\n+            } else if ((b = tryDoubleAllocate(high - low)) == null) {\n+                return false;\n@@ -3863,3 +4230,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3876,1 +4241,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -3878,11 +4243,2 @@\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        double[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        double[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -3897,1 +4253,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -3936,1 +4295,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -3948,1 +4307,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -3960,0 +4319,3 @@\n+                \/*\n+                 * Reserve space for the left part.\n+                 *\/\n@@ -3963,1 +4325,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -3965,1 +4327,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -3968,1 +4330,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -3993,1 +4355,216 @@\n-\/\/ [class]\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (double[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryDoubleAllocate(size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (dtl(a[i])         & 0x3FF)]--;\n+            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;\n+            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;\n+            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;\n+            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;\n+            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the double value.\n+     *\n+     * @param d the given value\n+     * @return masked bits\n+     *\/\n+    private static long dtl(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static double[] tryDoubleAllocate(int size) {\n+        try {\n+            return size < MAX_8_BYTE_BUFFER_SIZE ? new double[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+\/\/ #[class]\n@@ -3999,1 +4576,2 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4004,0 +4582,13 @@\n+        private Sorter(Object a, Object b, int parallelism, int low, int size, int depth) {\n+            this.a = a;\n+            this.b = b;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+\n+            while (b != null && (parallelism >>= 1) > 0 && (size >>= 8) > 0) {\n+                depth -= 2;\n+            }\n+            this.depth = depth;\n+        }\n+\n@@ -4016,1 +4607,1 @@\n-        public final void compute() {\n+        public void compute() {\n@@ -4032,2 +4623,1 @@\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                    throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4040,1 +4630,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> parent) {\n@@ -4058,1 +4648,1 @@\n-        private void forkSorter(int depth, int low, int high) {\n+        private void fork(int depth, int low, int high) {\n@@ -4060,1 +4650,0 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n@@ -4069,1 +4658,2 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4088,1 +4678,1 @@\n-        public final void compute() {\n+        public void compute() {\n@@ -4102,2 +4692,1 @@\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+                throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4108,2 +4697,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(Object dst, int k, Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n@@ -4114,50 +4702,0 @@\n-\n-    \/**\n-     * This class implements parallel merging of runs.\n-     *\/\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":1982,"deletions":1444,"binary":false,"changes":3426,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -38,1 +38,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -47,3 +47,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_RUN_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 10_000 };\n@@ -51,3 +51,3 @@\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_RUN_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 10_000, 50_000 };\n@@ -55,3 +55,3 @@\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+    \/\/ Initial random values for short run\n+    private static final TestRandom[] SHORT_RUN_RANDOMS =\n+        { TestRandom.C0FFEE };\n@@ -59,3 +59,3 @@\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RUN_RANDOMS =\n+        { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n@@ -63,1 +63,1 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Constant to fill the left part of array\n@@ -65,0 +65,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -70,0 +72,1 @@\n+    private final boolean fix;\n@@ -80,0 +83,4 @@\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms).testBase();\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured(512);\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -82,1 +89,0 @@\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n@@ -87,1 +93,5 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms) {\n+        this(sortingHelper, randoms, SHORT_RUN_LENGTHS, true);\n@@ -91,0 +101,4 @@\n+        this(sortingHelper, randoms, lengths, false);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean fix) {\n@@ -94,0 +108,1 @@\n+        this.fix = fix;\n@@ -96,1 +111,2 @@\n-    private void testBasic() {\n+    private void testBase() {\n+        testStructured(0);\n@@ -101,3 +117,1 @@\n-            testBasic(length);\n-        }\n-    }\n+            testSubArray(length);\n@@ -105,5 +119,5 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+            for (TestRandom random : randoms) {\n+                testWithCheckSum(length, random);\n+                testWithScrambling(length, random);\n+                testWithInsertionSort(length, random);\n+            }\n@@ -114,0 +128,2 @@\n+        testBase();\n+\n@@ -116,6 +132,0 @@\n-            testCore(length);\n-        }\n-    }\n-\n-    private void testCore(int length) {\n-        testBasic(length);\n@@ -123,5 +133,4 @@\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n+            for (TestRandom random : randoms) {\n+                testNegativeZero(length, random);\n+                testFloatingPointSorting(length, random);\n+            }\n@@ -132,0 +141,2 @@\n+        testCore();\n+\n@@ -134,1 +145,1 @@\n-            testAll(length);\n+            testRange(length);\n@@ -138,6 +149,4 @@\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n+    private void testStructured(int min) {\n+        for (int length : lengths) {\n+            createData(length);\n+            testStructured(length, min);\n@@ -148,26 +157,0 @@\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n@@ -177,15 +160,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullLongArray() {\n@@ -195,15 +163,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullByteArray() {\n@@ -213,15 +166,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullCharArray() {\n@@ -231,15 +169,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullShortArray() {\n@@ -249,15 +172,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullFloatArray() {\n@@ -267,15 +175,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullDoubleArray() {\n@@ -284,13 +177,0 @@\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n@@ -299,2 +179,2 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n+    private void testSubArray(int length) {\n+        if (fix || length < 4) {\n@@ -304,1 +184,0 @@\n-            int fromIndex = m;\n@@ -307,1 +186,1 @@\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n+            prepareSubArray((int[]) gold[0], m, toIndex);\n@@ -310,2 +189,2 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test subarray\", length,\n@@ -313,2 +192,2 @@\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n+                sortingHelper.sort(test[i], m, toIndex);\n+                checkSubArray(test[i], m, toIndex);\n@@ -320,4 +199,1 @@\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n+    private void testRange(int length) {\n@@ -325,2 +201,2 @@\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n+            for (int i = 1; i <= length; ++i) {\n+                ((int[]) gold[0])[i - 1] = i % m + m % i;\n@@ -330,2 +206,2 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test range check\", length,\n@@ -339,45 +215,0 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n@@ -385,1 +216,1 @@\n-        if (length > 1000) {\n+        if (length > 1_000) {\n@@ -393,1 +224,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -398,0 +229,1 @@\n+                    checkSorted(gold[i]);\n@@ -405,2 +237,2 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n+    private void testStructured(int length, int min) {\n+        if (length < min) {\n@@ -409,4 +241,2 @@\n-        final int PERIOD = 50;\n-\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n+        for (int m = 1; m < 8; ++m) {\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\n@@ -416,2 +246,2 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n+                for (int i = 0; i < test.length; ++i) {\n+                    printTestName(\"Test structured\", length,\n@@ -428,0 +258,3 @@\n+        if (length > 1_000) {\n+            return;\n+        }\n@@ -433,1 +266,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -445,0 +278,3 @@\n+        if (fix) {\n+            return;\n+        }\n@@ -450,1 +286,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -463,1 +299,1 @@\n-        for (int i = 5; i < test.length; i++) {\n+        for (int i = 5; i < test.length; ++i) {\n@@ -466,1 +302,1 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n@@ -476,1 +312,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -479,1 +315,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -481,6 +318,6 @@\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n+        for (int a = 0; a < MAX; ++a) {\n+            for (int g = 0; g < MAX; ++g) {\n+                for (int z = 0; z < MAX; ++z) {\n+                    for (int n = 0; n < MAX; ++n) {\n+                        for (int p = 0; p < MAX; ++p) {\n+                            if (a + g + z + n + p + s != length) {\n@@ -489,1 +326,1 @@\n-                            for (int i = 5; i < test.length; i++) {\n+                            for (int i = 5; i < test.length; ++i) {\n@@ -498,1 +335,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], a, n + 2, g);\n@@ -505,0 +342,3 @@\n+        for (int m = MAX; m > 4; --m) {\n+            int g = length \/ m;\n+            int a = length - g - g - g - g - s;\n@@ -506,6 +346,1 @@\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n-\n-            for (int i = 5; i < test.length; i++) {\n+            for (int i = 5; i < test.length; ++i) {\n@@ -513,4 +348,4 @@\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n+                    \", a = \" + a + \", g = \" + g + \", z = \" + g +\n+                    \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n+                builder.build(gold[i], a, g, g, g, g, random);\n@@ -520,1 +355,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], a, g + 2, g);\n@@ -527,1 +362,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -533,1 +368,1 @@\n-        for (int i = fromIndex; i < middle; i++) {\n+        for (int i = fromIndex; i < middle; ++i) {\n@@ -537,1 +372,1 @@\n-        for (int i = middle; i < toIndex; i++) {\n+        for (int i = middle; i < toIndex; ++i) {\n@@ -541,1 +376,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -562,1 +397,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -567,1 +402,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -573,1 +408,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -579,1 +414,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -585,1 +420,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -591,1 +426,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -597,1 +432,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -603,1 +438,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -641,0 +476,4 @@\n+    private void fail(Object object) {\n+        fail(\"Unknown type of array: \" + object.getClass().getName());\n+    }\n+\n@@ -652,1 +491,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -657,1 +496,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -665,1 +504,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -678,1 +517,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -683,1 +522,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -690,1 +529,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -696,1 +535,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -704,1 +543,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -711,1 +550,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -717,1 +556,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -740,1 +579,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -745,1 +584,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -753,1 +592,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -761,1 +600,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -769,1 +608,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -777,1 +616,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -785,1 +624,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -793,1 +632,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -824,1 +663,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -844,1 +683,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -849,1 +688,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -857,1 +696,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -865,1 +704,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -873,1 +712,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -881,1 +720,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -889,1 +728,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -897,1 +736,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -935,1 +774,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -963,1 +802,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -972,1 +811,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -981,1 +820,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1024,1 +863,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -1052,1 +891,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1061,1 +900,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1070,1 +909,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1092,94 +931,1 @@\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n+        SortingHelper.INSERTION_SORT.sort(a);\n@@ -1204,1 +950,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1209,1 +955,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1215,1 +961,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1221,1 +967,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1229,1 +975,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1235,1 +981,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1241,1 +987,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1249,1 +995,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1255,1 +1001,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1261,1 +1007,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1269,1 +1015,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1275,1 +1021,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1281,1 +1027,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1289,1 +1035,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1295,1 +1041,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1301,1 +1047,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1309,1 +1055,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1315,1 +1061,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1321,1 +1067,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1329,1 +1075,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1335,1 +1081,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1341,1 +1087,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1364,1 +1110,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1372,1 +1118,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1392,1 +1138,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1412,1 +1158,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1432,1 +1178,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1452,1 +1198,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1472,1 +1218,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1492,1 +1238,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1514,1 +1260,1 @@\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+            fail(src);\n@@ -1526,4 +1272,0 @@\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n-    }\n-\n@@ -1545,3 +1287,3 @@\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n+        for (int i = 0; i < gold.length; ++i) {\n+            TypeConverter converter = TypeConverter.values()[i];\n+            converter.convert((int[]) gold[0], gold[i], fix);\n@@ -1550,1 +1292,1 @@\n-        for (int i = 0; i < gold.length; i++) {\n+        for (int i = 0; i < gold.length; ++i) {\n@@ -1559,0 +1301,4 @@\n+    private void printTestName(String test, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n+    }\n+\n@@ -1560,1 +1306,1 @@\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\n@@ -1564,1 +1310,11 @@\n-    private static enum TypeConverter {\n+    private enum TypeConverter {\n+\n+        INT {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n+                if (fix) {\n+                    src[0] = Integer.MIN_VALUE;\n+                }\n+            }\n+        },\n+\n@@ -1566,1 +1322,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1569,2 +1326,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Long.MIN_VALUE;\n@@ -1576,1 +1336,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1579,1 +1340,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1582,0 +1343,3 @@\n+                if (fix) {\n+                    b[0] = Byte.MIN_VALUE;\n+                }\n@@ -1586,1 +1350,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1589,1 +1354,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1592,0 +1357,3 @@\n+                if (fix) {\n+                    b[0] = Character.MIN_VALUE;\n+                }\n@@ -1596,1 +1364,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1599,1 +1368,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1602,0 +1371,3 @@\n+                if (fix) {\n+                    b[0] = Short.MIN_VALUE;\n+                }\n@@ -1606,1 +1378,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1609,1 +1382,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1612,0 +1385,3 @@\n+                if (fix) {\n+                    b[0] = Float.NEGATIVE_INFINITY;\n+                }\n@@ -1616,1 +1392,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1619,2 +1396,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Double.NEGATIVE_INFINITY;\n@@ -1625,1 +1405,1 @@\n-        abstract void convert(int[] src, Object dst);\n+        abstract void convert(int[] src, Object dst, boolean fix);\n@@ -1628,1 +1408,2 @@\n-    private static enum SortedBuilder {\n+    private enum SortedBuilder {\n+\n@@ -1630,0 +1411,1 @@\n+            @Override\n@@ -1631,1 +1413,1 @@\n-                for (int i = 0; i < m; i++) {\n+                for (int i = 0; i < m; ++i) {\n@@ -1635,1 +1417,1 @@\n-                for (int i = m; i < a.length; i++) {\n+                for (int i = m; i < a.length; ++i) {\n@@ -1644,1 +1426,2 @@\n-    private static enum UnsortedBuilder {\n+    private enum UnsortedBuilder {\n+\n@@ -1646,0 +1429,1 @@\n+            @Override\n@@ -1647,1 +1431,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1653,1 +1437,2 @@\n-        ASCENDING {\n+        PERMUTATION {\n+            @Override\n@@ -1655,2 +1440,8 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; --i) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1]; a[i - 1] = a[k]; a[k] = t;\n@@ -1661,1 +1452,2 @@\n-        DESCENDING {\n+        UNIFORM {\n+            @Override\n@@ -1663,2 +1455,4 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n@@ -1669,1 +1463,2 @@\n-        EQUAL {\n+        REPEATED {\n+            @Override\n@@ -1671,2 +1466,11 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % m;\n+                }\n+            }\n+        },\n+\n+        DUPLICATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m);\n@@ -1677,1 +1481,2 @@\n-        SAW {\n+        SAWTOOTH {\n+            @Override\n@@ -1685,1 +1490,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1693,1 +1498,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1704,1 +1509,2 @@\n-        REPEATED {\n+        SHUFFLE {\n+            @Override\n@@ -1706,2 +1512,16 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] a, int m, Random random);\n+    }\n+\n+    private enum StructuredBuilder {\n+\n+        ASCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = m + i;\n@@ -1712,4 +1532,23 @@\n-        DUPLICATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n+        DESCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = a.length - m - i;\n+                }\n+            }\n+        },\n+\n+        EQUAL {\n+            @Override\n+            void build(int[] a, int m) {\n+                Arrays.fill(a, m);\n+            }\n+        },\n+\n+        MASKED {\n+            @Override\n+            void build(int[] a, int m) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i ^ 0xFF) & mask;\n@@ -1721,1 +1560,2 @@\n-            void build(int[] a, int m, Random random) {\n+            @Override\n+            void build(int[] a, int m) {\n@@ -1724,1 +1564,1 @@\n-                for (int i = 0; i < middle; i++) {\n+                for (int i = 0; i < middle; ++i) {\n@@ -1728,1 +1568,1 @@\n-                for (int i = middle; i < a.length; i++) {\n+                for (int i = middle; i < a.length; ++i) {\n@@ -1735,2 +1575,3 @@\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1743,2 +1584,3 @@\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1750,10 +1592,0 @@\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n-                }\n-            }\n-        },\n-\n@@ -1761,1 +1593,2 @@\n-            void build(int[] a, int m, Random random) {\n+            @Override\n+            void build(int[] a, int m) {\n@@ -1763,1 +1596,1 @@\n-                max = max < 2 ? 2 : max;\n+                max = Math.max(max, 2);\n@@ -1765,1 +1598,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1769,46 +1602,0 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n-\n-    private static enum MergingBuilder {\n-        ASCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n@@ -1818,0 +1605,1 @@\n+            @Override\n@@ -1819,3 +1607,1 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n-                }\n+                Arrays.fill(a, 0);\n@@ -1827,0 +1613,1 @@\n+            @Override\n@@ -1828,1 +1615,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1831,1 +1618,1 @@\n-                reverse(a, 0, a.length - 1);\n+                reverse(a, m, a.length - 1);\n@@ -1836,0 +1623,1 @@\n+            @Override\n@@ -1837,1 +1625,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1840,1 +1628,1 @@\n-                reverse(a, 0, 2);\n+                reverse(a, 0, Math.min(m, a.length));\n@@ -1845,0 +1633,1 @@\n+            @Override\n@@ -1850,1 +1639,1 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n+                for (int i = 0, k = level; i < k1; ++i) {\n@@ -1854,1 +1643,1 @@\n-                for (int i = k1; i < k2; i++) {\n+                for (int i = k1; i < k2; ++i) {\n@@ -1858,1 +1647,1 @@\n-                for (int i = k2, k = level; i < a.length; i++) {\n+                for (int i = k2, k = level; i < a.length; ++i) {\n@@ -1875,1 +1664,2 @@\n-    private static enum NegativeZeroBuilder {\n+    private enum NegativeZeroBuilder {\n+\n@@ -1877,0 +1667,1 @@\n+            @Override\n@@ -1880,1 +1671,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1887,0 +1678,1 @@\n+            @Override\n@@ -1890,1 +1682,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1899,1 +1691,2 @@\n-    private static enum FloatingPointBuilder {\n+    private enum FloatingPointBuilder {\n+\n@@ -1901,0 +1694,1 @@\n+            @Override\n@@ -1904,1 +1698,1 @@\n-                float[] x = (float[]) o;\n+                float[] data = (float[]) o;\n@@ -1907,1 +1701,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1910,1 +1710,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                fillWithValue(data, -0.0f, fromIndex, g);\n@@ -1913,1 +1713,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                fillWithValue(data, 0.0f, fromIndex, z);\n@@ -1916,1 +1716,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1919,1 +1719,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                fillWithValue(data, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.NaN, fromIndex, a);\n@@ -1924,0 +1730,1 @@\n+            @Override\n@@ -1927,1 +1734,1 @@\n-                double[] x = (double[]) o;\n+                double[] data = (double[]) o;\n@@ -1930,1 +1737,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1933,1 +1746,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                fillWithValue(data, -0.0d, fromIndex, g);\n@@ -1936,1 +1749,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                fillWithValue(data, 0.0d, fromIndex, z);\n@@ -1939,1 +1752,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1942,1 +1755,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                fillWithValue(data, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.NaN, fromIndex, a);\n@@ -1948,2 +1767,2 @@\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1954,2 +1773,2 @@\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1961,37 +1780,0 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n@@ -2000,1 +1782,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2002,0 +1783,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2014,1 +1796,1 @@\n-        private String seed;\n+        private final String seed;\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":408,"deletions":626,"binary":false,"changes":1034,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @version 2019.09.19\n+ * @version 2022.06.14\n@@ -36,1 +36,1 @@\n- * @since 14\n+ * @since 14 ^ 20\n@@ -41,0 +41,5 @@\n+        @Override\n+        public void sort(Object a, int low, int high) {\n+            sort(a, SEQUENTIAL, low, high);\n+        }\n+    },\n@@ -42,0 +47,1 @@\n+    PARALLEL_SORT(\"Parallel sort\") {\n@@ -43,18 +49,2 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n+        public void sort(Object a, int low, int high) {\n+            sort(a, PARALLEL, low, high);\n@@ -62,0 +52,1 @@\n+    },\n@@ -63,0 +54,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -66,1 +58,1 @@\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((int[]) a, low, high);\n@@ -68,1 +60,1 @@\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((long[]) a, low, high);\n@@ -72,1 +64,1 @@\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -74,1 +66,1 @@\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -76,1 +68,1 @@\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((float[]) a, low, high);\n@@ -78,1 +70,1 @@\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((double[]) a, low, high);\n@@ -83,10 +75,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -95,2 +77,1 @@\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -98,1 +79,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -100,1 +81,1 @@\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n+                DualPivotQuicksort.insertionSort((int[]) a, low, high);\n@@ -102,1 +83,1 @@\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n+                DualPivotQuicksort.insertionSort((long[]) a, low, high);\n@@ -104,1 +85,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.insertionSort((byte[]) a, low, high);\n@@ -106,1 +87,1 @@\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n+                DualPivotQuicksort.insertionSort((char[]) a, low, high);\n@@ -108,1 +89,1 @@\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n+                DualPivotQuicksort.insertionSort((short[]) a, low, high);\n@@ -110,1 +91,1 @@\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n+                DualPivotQuicksort.insertionSort((float[]) a, low, high);\n@@ -112,1 +93,1 @@\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n+                DualPivotQuicksort.insertionSort((double[]) a, low, high);\n@@ -117,0 +98,1 @@\n+    },\n@@ -118,0 +100,1 @@\n+    MERGING_SORT(\"Merging sort\") {\n@@ -121,1 +104,1 @@\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (int[]) a, low, high - low));\n@@ -123,1 +106,1 @@\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (long[]) a, low, high - low));\n@@ -127,1 +110,1 @@\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -129,1 +112,1 @@\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -131,1 +114,1 @@\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (float[]) a, low, high - low));\n@@ -133,1 +116,1 @@\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (double[]) a, low, high - low));\n@@ -138,10 +121,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -150,2 +123,1 @@\n-    HEAP_SORT(\"Heap sort\") {\n-\n+    RADIX_SORT(\"Radix sort\") {\n@@ -153,1 +125,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -155,1 +127,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high));\n@@ -157,1 +129,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high));\n@@ -159,1 +131,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\n@@ -161,1 +133,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -163,1 +135,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -165,1 +137,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high));\n@@ -167,1 +139,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high));\n@@ -172,0 +144,1 @@\n+    },\n@@ -173,0 +146,1 @@\n+    HEAP_SORT(\"Heap sort\") {\n@@ -176,1 +150,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((int[]) a, low, high);\n@@ -178,1 +152,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((long[]) a, low, high);\n@@ -182,1 +156,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -184,1 +158,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -186,1 +160,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((float[]) a, low, high);\n@@ -188,1 +162,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((double[]) a, low, high);\n@@ -193,10 +167,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -206,1 +170,0 @@\n-\n@@ -248,11 +211,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -262,1 +214,0 @@\n-\n@@ -304,12 +255,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -318,2 +257,0 @@\n-    abstract public void sort(Object a);\n-\n@@ -322,3 +259,19 @@\n-    abstract public void sort(Object[] a);\n-\n-    abstract public void sort(Object[] a, Comparator comparator);\n+    public void sort(Object a) {\n+        if (a instanceof int[]) {\n+            sort(a, 0, ((int[]) a).length);\n+        } else if (a instanceof long[]) {\n+            sort(a, 0, ((long[]) a).length);\n+        } else if (a instanceof byte[]) {\n+            sort(a, 0, ((byte[]) a).length);\n+        } else if (a instanceof char[]) {\n+            sort(a, 0, ((char[]) a).length);\n+        } else if (a instanceof short[]) {\n+            sort(a, 0, ((short[]) a).length);\n+        } else if (a instanceof float[]) {\n+            sort(a, 0, ((float[]) a).length);\n+        } else if (a instanceof double[]) {\n+            sort(a, 0, ((double[]) a).length);\n+        } else {\n+            fail(a);\n+        }\n+    }\n@@ -326,1 +279,1 @@\n-    private SortingHelper(String name) {\n+    SortingHelper(String name) {\n@@ -335,0 +288,26 @@\n+    static void sort(Object a, int parallelism, int low, int high) {\n+        if (a instanceof int[]) {\n+            DualPivotQuicksort.sort((int[]) a, parallelism, low, high);\n+        } else if (a instanceof long[]) {\n+            DualPivotQuicksort.sort((long[]) a, parallelism, low, high);\n+        } else if (a instanceof byte[]) {\n+            DualPivotQuicksort.sort((byte[]) a, low, high);\n+        } else if (a instanceof char[]) {\n+            DualPivotQuicksort.sort((char[]) a, low, high);\n+        } else if (a instanceof short[]) {\n+            DualPivotQuicksort.sort((short[]) a, low, high);\n+        } else if (a instanceof float[]) {\n+            DualPivotQuicksort.sort((float[]) a, parallelism, low, high);\n+        } else if (a instanceof double[]) {\n+            DualPivotQuicksort.sort((double[]) a, parallelism, low, high);\n+        } else {\n+            fail(a);\n+        }\n+    }\n+\n+    private static void check(String name, boolean result) {\n+        if (!result) {\n+            fail(name + \" sort must return true\");\n+        }\n+    }\n+\n@@ -336,1 +315,5 @@\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+        fail(\"Unknown array: \" + a.getClass().getName());\n+    }\n+\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n@@ -339,1 +322,1 @@\n-    private String name;\n+    private final String name;\n@@ -342,1 +325,1 @@\n-     * Parallelism level for sequential and parallel sorting.\n+     * Parallelism level for sequential sorting.\n@@ -345,1 +328,0 @@\n-    private static final int PARALLEL = 87;\n@@ -348,2 +330,1 @@\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n+     * Parallelism level for parallel sorting.\n@@ -351,1 +332,1 @@\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n+    private static final int PARALLEL = 88;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":108,"deletions":127,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -0,0 +1,552 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Microbenchmark for Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2022.06.14\n+ *\n+ * @since 20\n+ *\/\n+@Fork(1)\n+@State(Scope.Benchmark)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 1, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 3, timeUnit = TimeUnit.SECONDS)\n+public class ArraysSort {\n+\n+    @Param({ \"100\", \"1000\", \"10000\", \"100000\", \"1000000\" })\n+    int size;\n+\n+    Random random;\n+\n+    @Setup(Level.Iteration)\n+    public void start() {\n+        random = new Random(0x777);\n+    }\n+\n+    public static class Int extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        int[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(int[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(int[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = i % 7;\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(int[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (i * 5) % a.length;\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(int[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = random.nextInt(6) > 0 ? (j += 2) : (k += 2);\n+                    }\n+                }\n+            };\n+\n+            abstract void build(int[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new int[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Long extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        long[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(long[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = random.nextLong();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(long[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = i % 7;\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(long[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (i * 5L) % a.length;\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(long[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = random.nextInt(6) > 0 ? (j += 2) : (k += 2);\n+                    }\n+                }\n+            };\n+\n+            abstract void build(long[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Byte extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        byte[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(byte[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(byte[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i % 7);\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(byte[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) ((i * 5) % a.length);\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(byte[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (byte) (random.nextInt(6) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            };\n+\n+            abstract void build(byte[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Char extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        char[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(char[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(char[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i % 7);\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(char[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) ((i * 5) % a.length);\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(char[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (char) (random.nextInt(6) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            };\n+\n+            abstract void build(char[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Short extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        short[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(short[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(short[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i % 7);\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(short[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) ((i * 5) % a.length);\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(short[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (short) (random.nextInt(6) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            };\n+\n+            abstract void build(short[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Float extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        float[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(float[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = random.nextFloat();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(float[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = i % 7;\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(float[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (i * 5) % a.length;\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(float[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = random.nextInt(6) > 0 ? (j += 2) : (k += 2);\n+                    }\n+                }\n+            };\n+\n+            abstract void build(float[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+\n+    public static class Double extends ArraysSort {\n+\n+        @Param\n+        private Type type;\n+\n+        double[] gold;\n+\n+        public enum Type {\n+\n+            RANDOM {\n+                @Override\n+                void build(double[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = random.nextDouble();\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                void build(double[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = i % 7;\n+                    }\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                void build(double[] a, Random random) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (i * 5) % a.length;\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                void build(double[] a, Random random) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = random.nextInt(6) > 0 ? (j += 2) : (k += 2);\n+                    }\n+                }\n+            };\n+\n+            abstract void build(double[] a, Random random);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            gold = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void init() {\n+            type.build(gold, random);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(gold);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(gold);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":552,"deletions":0,"binary":false,"changes":552,"status":"added"}]}