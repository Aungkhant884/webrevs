{"files":[{"patch":"@@ -39,2 +39,3 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, Radix sort, heap\n+ * sort, mixed (simple, pin, pair) insertion sort, counting sort and\n+ * parallel merge sort.\n@@ -47,1 +48,1 @@\n- * @version 2018.08.18\n+ * @version 2020.06.14\n@@ -49,1 +50,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 18\n@@ -61,1 +62,1 @@\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 113;\n@@ -66,1 +67,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+    private static final int MAX_INSERTION_SORT_SIZE = 26;\n@@ -74,1 +75,1 @@\n-     * Min array size to try merging of runs.\n+     * Min array size to use merging sort.\n@@ -76,1 +77,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 4 << 10;\n@@ -114,1 +115,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Min array size to use Radix sort.\n@@ -116,1 +117,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MIN_RADIX_SORT_SIZE = 6 << 10;\n@@ -119,1 +120,1 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Threshold of mixed insertion sort is increased by this value.\n@@ -121,1 +122,1 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int DEPTH = 3 << 1;\n@@ -124,6 +125,1 @@\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n+     * Min depth to invoke Radix sort.\n@@ -131,2 +127,1 @@\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n+    private static final int MIN_RADIX_SORT_DEPTH = DEPTH << 2;\n@@ -134,5 +129,11 @@\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n+    \/**\n+     * Max recursive partitioning depth before using heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 * DEPTH;\n+\n+    \/**\n+     * Max length of additional buffer,\n+     * limited by max_heap \/ 64 or 256m elements (2gb max).\n+     *\/\n+    private static final int MAX_BUFFER_LENGTH =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 6, 256L << 20);\n@@ -156,6 +157,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, parallelism, low, high - low, 0).invoke();\n@@ -168,2 +165,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -174,1 +170,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -186,1 +182,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -194,1 +190,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -202,2 +198,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -208,2 +204,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -211,1 +206,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -220,1 +215,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -235,0 +230,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -239,7 +237,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -247,5 +245,5 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -253,0 +251,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -267,0 +268,11 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -272,1 +284,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -303,7 +315,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -311,1 +323,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -313,3 +327,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -317,1 +329,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -323,9 +337,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -335,0 +342,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -359,1 +373,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -377,1 +391,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -379,1 +393,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -387,1 +401,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -389,3 +405,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -393,1 +407,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -437,2 +453,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -452,1 +468,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            int ai = a[i = low];\n@@ -455,1 +476,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -457,2 +478,1 @@\n-            for (int i; ++low < end; ) {\n-                int ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -460,4 +480,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -465,1 +491,8 @@\n-        } else {\n+            a[i + 1] = ai;\n+        }\n+\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            int ai = a[i = low];\n@@ -468,7 +501,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -476,1 +503,5 @@\n-            int pin = a[end];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -478,2 +509,5 @@\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -481,1 +515,6 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -483,4 +522,4 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -488,4 +527,4 @@\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -493,1 +532,1 @@\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            } else if (a1 < a[i - 1]) {\n@@ -495,4 +534,4 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -500,7 +539,7 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n@@ -508,4 +547,15 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param leftmost indicates that the range is the leftmost part\n+     *\/\n+    private static void insertionSort(int[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                int ai = a[i = k];\n+\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n@@ -517,0 +567,3 @@\n+        } else {\n+            for (int i; ++low < high; ) {\n+                int ai = a[i = low];\n@@ -518,5 +571,7 @@\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n+            }\n+        }\n+    }\n@@ -524,6 +579,11 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n@@ -531,4 +591,10 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (int[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else {\n+            if ((b = (int[]) tryAllocate(a, size)) == null) {\n+                return false;\n+            }\n+        }\n@@ -536,4 +602,2 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+        int start = low - offset;\n+        int last = high - offset;\n@@ -541,1 +605,12 @@\n-                } else if (a1 < a[i - 1]) {\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ a[i]         & 0x3FF]--;\n+            count2[(a[i] >>> 10) & 0x7FF]--;\n+            count3[(a[i] >>> 21) ^ 0x400]--; \/\/ Reverse the sign bit\n+        }\n@@ -543,4 +618,6 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n@@ -548,4 +625,35 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[a[i] & 0x3FF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];\n@@ -555,0 +663,8 @@\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n@@ -558,1 +674,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Checks the count array and then creates histogram.\n@@ -560,3 +676,5 @@\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param count the count array\n+     * @param last the last index of count array\n+     * @param total the total number of elements\n+     * @param high the index of the last element, exclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n@@ -564,3 +682,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            int ai = a[i = k];\n+    private static boolean processDigit(int[] count, int last, int total, int high) {\n@@ -568,5 +684,9 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+        \/*\n+         * Check if we can skip given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c < 0) {\n+                break;\n@@ -575,0 +695,10 @@\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[last] += high;\n+\n+        for (int i = last; i > 0; --i) {\n+            count[i - 1] += count[i];\n+        }\n+        return true;\n@@ -622,1 +752,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -628,1 +758,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -630,1 +760,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {\n@@ -676,1 +806,0 @@\n-\n@@ -685,1 +814,0 @@\n-\n@@ -693,0 +821,1 @@\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -696,1 +825,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -699,1 +828,0 @@\n-\n@@ -708,1 +836,0 @@\n-\n@@ -716,1 +843,0 @@\n-\n@@ -724,0 +850,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * This is single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -732,3 +865,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = (int[]) sorter.b) != null) {\n@@ -736,0 +867,4 @@\n+            } else {\n+                if ((b = (int[]) tryAllocate(a, size)) == null) {\n+                    return false;\n+                }\n@@ -762,3 +897,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -859,0 +992,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -892,1 +1028,1 @@\n-\/\/ [long]\n+\/\/ #[long]\n@@ -910,6 +1046,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, parallelism, low, high - low, 0).invoke();\n@@ -922,2 +1054,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -928,1 +1059,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -940,1 +1071,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -948,1 +1079,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -956,2 +1087,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -962,2 +1093,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -965,1 +1095,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -974,1 +1104,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -989,0 +1119,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -993,7 +1126,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -1001,5 +1134,5 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1007,0 +1140,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -1021,0 +1157,11 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -1026,1 +1173,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -1057,7 +1204,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -1065,1 +1212,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1067,3 +1216,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -1071,1 +1218,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -1077,9 +1226,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -1089,0 +1231,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -1113,1 +1262,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -1131,1 +1280,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -1133,1 +1282,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -1141,1 +1290,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1143,3 +1294,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -1147,1 +1296,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -1191,2 +1342,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -1206,1 +1357,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            long ai = a[i = low];\n@@ -1209,1 +1365,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -1211,2 +1367,1 @@\n-            for (int i; ++low < end; ) {\n-                long ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -1214,6 +1369,4 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n@@ -1222,7 +1375,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -1230,1 +1377,5 @@\n-            long pin = a[end];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -1232,2 +1383,5 @@\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            long ai = a[i = low];\n@@ -1235,1 +1389,8 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -1237,4 +1398,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1242,4 +1404,6 @@\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -1247,1 +1411,4 @@\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -1249,4 +1416,4 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1254,7 +1421,1 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+            } else if (a1 < a[i - 1]) {\n@@ -1262,7 +1423,2 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -1270,7 +1426,1 @@\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n+                a[++i + 1] = a2;\n@@ -1278,6 +1428,7 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n@@ -1285,4 +1436,12 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param leftmost indicates that the range is the leftmost part\n+     *\/\n+    private static void insertionSort(long[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                long ai = a[i = k];\n@@ -1290,1 +1449,2 @@\n-                    while (a2 < a[--i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n@@ -1293,8 +1453,6 @@\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                long ai = a[i = low];\n@@ -1302,4 +1460,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1307,0 +1463,1 @@\n+                a[i + 1] = ai;\n@@ -1312,1 +1469,2 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -1317,0 +1475,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1318,3 +1477,2 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            long ai = a[i = k];\n+    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n@@ -1322,3 +1480,93 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (long[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else {\n+            if ((b = (long[]) tryAllocate(a, size)) == null) {\n+                return false;\n+            }\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (a[i]         & 0x3FF)]--;\n+            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;\n+            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;\n+            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;\n+            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;\n+            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];\n@@ -1326,1 +1574,0 @@\n-                a[i + 1] = ai;\n@@ -1329,0 +1576,38 @@\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n@@ -1376,1 +1661,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1382,1 +1667,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1384,1 +1669,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {\n@@ -1430,1 +1715,0 @@\n-\n@@ -1439,1 +1723,0 @@\n-\n@@ -1447,0 +1730,1 @@\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -1450,1 +1734,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -1453,1 +1737,0 @@\n-\n@@ -1462,1 +1745,0 @@\n-\n@@ -1470,1 +1752,0 @@\n-\n@@ -1478,0 +1759,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * This is single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -1486,3 +1774,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = (long[]) sorter.b) != null) {\n@@ -1490,0 +1776,4 @@\n+            } else {\n+                if ((b = (long[]) tryAllocate(a, size)) == null) {\n+                    return false;\n+                }\n@@ -1516,3 +1806,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1613,0 +1901,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -1646,1 +1937,1 @@\n-\/\/ [byte]\n+\/\/ #[byte]\n@@ -1705,1 +1996,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram for all values.\n@@ -1710,1 +2001,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -1734,1 +2025,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -1753,2 +2044,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1758,1 +2048,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1775,2 +2065,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -1778,1 +2067,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -1787,1 +2076,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -1806,7 +2095,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -1814,5 +2103,5 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1820,0 +2109,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -1839,1 +2131,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -1870,7 +2162,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -1878,1 +2170,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1880,3 +2174,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -1884,1 +2176,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -1890,9 +2184,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -1902,0 +2189,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -1921,1 +2215,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -1939,1 +2233,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -1941,1 +2235,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -1949,1 +2243,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -1951,3 +2247,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -1955,1 +2249,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -2028,1 +2324,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram for all values.\n@@ -2033,1 +2329,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2053,1 +2349,1 @@\n-\/\/ [short]\n+\/\/ #[short]\n@@ -2072,2 +2368,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2077,1 +2372,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2094,2 +2389,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -2097,1 +2391,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -2106,1 +2400,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -2125,7 +2419,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2133,5 +2427,5 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2139,0 +2433,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2158,1 +2455,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2189,7 +2486,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2197,1 +2494,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2199,3 +2498,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -2203,1 +2500,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -2209,9 +2508,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2221,0 +2513,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2240,1 +2539,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2258,1 +2557,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2260,1 +2559,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2268,1 +2567,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2270,3 +2571,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -2274,1 +2573,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -2352,1 +2653,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram for all values.\n@@ -2357,1 +2658,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2381,1 +2682,1 @@\n-\/\/ [float]\n+\/\/ #[float]\n@@ -2422,6 +2723,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, parallelism, low, high - low, 0).invoke();\n@@ -2463,2 +2760,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2469,1 +2765,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2481,1 +2777,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -2489,1 +2785,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -2497,2 +2793,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -2503,2 +2799,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -2506,1 +2801,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -2515,1 +2810,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -2530,0 +2825,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -2534,7 +2832,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -2542,5 +2840,5 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2548,0 +2846,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2562,0 +2863,11 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -2567,1 +2879,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2598,7 +2910,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -2606,1 +2918,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2608,3 +2922,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -2612,1 +2924,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -2618,9 +2932,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2630,0 +2937,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -2654,1 +2968,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2672,1 +2986,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2674,1 +2988,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -2682,1 +2996,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2684,3 +3000,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -2688,1 +3002,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -2732,2 +3048,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -2747,1 +3063,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            float ai = a[i = low];\n@@ -2750,1 +3071,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -2752,2 +3073,1 @@\n-            for (int i; ++low < end; ) {\n-                float ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -2755,4 +3075,10 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n@@ -2760,1 +3086,8 @@\n-        } else {\n+            a[i + 1] = ai;\n+        }\n+\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            float ai = a[i = low];\n@@ -2763,7 +3096,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -2771,1 +3098,5 @@\n-            float pin = a[end];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -2773,2 +3104,5 @@\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -2776,1 +3110,6 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -2778,4 +3117,4 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -2783,4 +3122,4 @@\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -2788,1 +3127,1 @@\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+            } else if (a1 < a[i - 1]) {\n@@ -2790,4 +3129,4 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -2795,7 +3134,7 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n@@ -2803,4 +3142,15 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param leftmost indicates that the range is the leftmost part\n+     *\/\n+    private static void insertionSort(float[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                float ai = a[i = k];\n+\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n@@ -2812,0 +3162,3 @@\n+        } else {\n+            for (int i; ++low < high; ) {\n+                float ai = a[i = low];\n@@ -2813,5 +3166,7 @@\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n+            }\n+        }\n+    }\n@@ -2819,6 +3174,11 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n@@ -2826,4 +3186,10 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (float[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else {\n+            if ((b = (float[]) tryAllocate(a, size)) == null) {\n+                return false;\n+            }\n+        }\n@@ -2831,4 +3197,2 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+        int start = low - offset;\n+        int last = high - offset;\n@@ -2836,1 +3200,28 @@\n-                } else if (a1 < a[i - 1]) {\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ fti(a[i])         & 0x3FF]--;\n+            count2[(fti(a[i]) >>> 10) & 0x7FF]--;\n+            count3[(fti(a[i]) >>> 21) & 0x7FF]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];\n+            }\n+        }\n@@ -2838,4 +3229,14 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n@@ -2843,4 +3244,11 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];\n@@ -2850,0 +3258,8 @@\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n@@ -2853,1 +3269,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Returns masked bits that represent the float number.\n@@ -2855,3 +3271,2 @@\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param f the given number\n+     * @return masked bits\n@@ -2859,11 +3274,3 @@\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n-\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n+    private static int fti(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x ^ ((x >> 31) | 0x80000000);\n@@ -2917,1 +3324,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -2923,1 +3330,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -2925,1 +3332,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {\n@@ -2971,1 +3378,0 @@\n-\n@@ -2980,1 +3386,0 @@\n-\n@@ -2988,0 +3393,1 @@\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -2991,1 +3397,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -2994,1 +3400,0 @@\n-\n@@ -3003,1 +3408,0 @@\n-\n@@ -3011,1 +3415,0 @@\n-\n@@ -3019,0 +3422,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * This is single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -3027,3 +3437,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = (float[]) sorter.b) != null) {\n@@ -3031,0 +3439,4 @@\n+            } else {\n+                if ((b = (float[]) tryAllocate(a, size)) == null) {\n+                    return false;\n+                }\n@@ -3057,3 +3469,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3154,0 +3564,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -3187,1 +3600,1 @@\n-\/\/ [double]\n+\/\/ #[double]\n@@ -3228,6 +3641,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, parallelism, low, high - low, 0).invoke();\n@@ -3269,2 +3678,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3275,1 +3683,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3287,1 +3695,1 @@\n-                mixedInsertionSort(a, low, high - 3 * ((size >> 5) << 3), high);\n+                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n@@ -3295,1 +3703,1 @@\n-                insertionSort(a, low, high);\n+                insertionSort(a, low, high, (bits & 1) == 0);\n@@ -3303,2 +3711,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -3309,2 +3717,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -3312,1 +3719,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -3321,1 +3728,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n@@ -3336,0 +3743,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -3340,7 +3750,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *    1  ------------o-----o------------\n+             *                   |     |\n+             *    2  ------o-----|-----o-----o------\n+             *             |     |           |\n+             *    4  ------|-----o-----o-----o------\n+             *             |           |\n+             *    5  ------o-----------o------------\n@@ -3348,5 +3758,5 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -3354,0 +3764,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -3368,0 +3781,11 @@\n+            \/*\n+             * Try Radix sort on large fully random data,\n+             * taking into account parallel context.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -3373,1 +3797,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -3404,7 +3828,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n+                 *     left part                    central part          right part\n+                 * +------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |\n+                 * +------------------------------------------------------------------+\n+                 *               ^         ^                            ^\n+                 *               |         |                            |\n+                 *             lower       k                          upper\n@@ -3412,1 +3836,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -3414,3 +3840,1 @@\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 * Invariants:\n@@ -3418,1 +3842,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot1\n+                 *     all in (k, upper)   in [pivot1, pivot2]\n+                 *     all in [upper, end)  >  pivot2\n@@ -3424,9 +3850,2 @@\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -3436,0 +3855,7 @@\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n@@ -3460,1 +3886,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3478,1 +3904,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -3480,1 +3906,1 @@\n-                 *   left part                 central part    right part\n+                 *    left part                central part    right part\n@@ -3488,1 +3914,3 @@\n-                 * Invariants:\n+                 * Pointer k is the last index of ?-part\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -3490,3 +3918,1 @@\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 * Invariants:\n@@ -3494,1 +3920,3 @@\n-                 * Pointer k is the last index of ?-part\n+                 *     all in (low, lower]  <  pivot\n+                 *     all in (k, upper)   ==  pivot\n+                 *     all in [upper, end]  >  pivot\n@@ -3538,2 +3966,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -3553,1 +3981,6 @@\n-        if (end == high) {\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end && low < p; ) {\n+            double ai = a[i = low];\n@@ -3556,1 +3989,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Find pin element, smaller than the given element.\n@@ -3558,2 +3991,1 @@\n-            for (int i; ++low < end; ) {\n-                double ai = a[i = low];\n+            while (ai < a[--p]);\n@@ -3561,6 +3993,4 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n+            \/*\n+             * Swap these elements.\n+             *\/\n+            ai = a[p]; a[p] = a[i];\n@@ -3569,7 +3999,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -3577,1 +4001,5 @@\n-            double pin = a[end];\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -3579,2 +4007,5 @@\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n+        \/*\n+         * Continue with simple insertion sort.\n+         *\/\n+        for (int i; low < end; ++low) {\n+            double ai = a[i = low];\n@@ -3582,1 +4013,8 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[--i]) {\n+                a[i + 1] = a[i];\n+            }\n+            a[i + 1] = ai;\n+        }\n@@ -3584,4 +4022,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3589,4 +4028,6 @@\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3594,1 +4035,4 @@\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3596,4 +4040,4 @@\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3601,7 +4045,1 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+            } else if (a1 < a[i - 1]) {\n@@ -3609,7 +4047,2 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3617,7 +4050,1 @@\n-            }\n-\n-            \/*\n-             * Continue with pair insertion sort on remain part.\n-             *\/\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n+                a[++i + 1] = a2;\n@@ -3625,6 +4052,7 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n@@ -3632,4 +4060,12 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param leftmost indicates that the range is the leftmost part\n+     *\/\n+    private static void insertionSort(double[] a, int low, int high, boolean leftmost) {\n+        if (leftmost) {\n+            for (int i, k = low; ++k < high; ) {\n+                double ai = a[i = k];\n@@ -3637,1 +4073,2 @@\n-                    while (a2 < a[--i]) {\n+                if (ai < a[i - 1]) {\n+                    while (--i >= low && ai < a[i]) {\n@@ -3640,8 +4077,6 @@\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                    a[i + 1] = ai;\n+                }\n+            }\n+        } else {\n+            for (int i; ++low < high; ) {\n+                double ai = a[i = low];\n@@ -3649,4 +4084,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3654,0 +4087,1 @@\n+                a[i + 1] = ai;\n@@ -3659,1 +4093,2 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -3664,0 +4099,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3665,3 +4101,2 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            double ai = a[i = k];\n+    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n@@ -3669,3 +4104,123 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (double[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else {\n+            if ((b = (double[]) tryAllocate(a, size)) == null) {\n+                return false;\n+            }\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (dtl(a[i])         & 0x3FF)]--;\n+            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;\n+            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;\n+            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;\n+            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;\n+            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];\n@@ -3673,1 +4228,0 @@\n-                a[i + 1] = ai;\n@@ -3676,0 +4230,19 @@\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the double number.\n+     *\n+     * @param f the given number\n+     * @return masked bits\n+     *\/\n+    private static long dtl(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\n@@ -3723,1 +4296,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3729,1 +4302,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3731,1 +4304,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {\n@@ -3777,1 +4350,0 @@\n-\n@@ -3786,1 +4358,0 @@\n-\n@@ -3794,0 +4365,1 @@\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -3797,1 +4369,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -3800,1 +4372,0 @@\n-\n@@ -3809,1 +4380,0 @@\n-\n@@ -3817,1 +4387,0 @@\n-\n@@ -3825,0 +4394,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * This is single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -3833,3 +4409,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = (double[]) sorter.b) != null) {\n@@ -3837,0 +4411,4 @@\n+            } else {\n+                if ((b = (double[]) tryAllocate(a, size)) == null) {\n+                    return false;\n+                }\n@@ -3863,3 +4441,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3960,0 +4536,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -3993,1 +4572,1 @@\n-\/\/ [class]\n+\/\/ #[class]\n@@ -3999,1 +4578,2 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4004,0 +4584,13 @@\n+        private Sorter(Object a, int parallelism, int low, int size, int depth) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+\n+            while ((parallelism >>= 1) > 0 && (size >>= 8) > 0) {\n+                depth -= 2;\n+            }\n+            this.b = depth == 0 ? null : tryAllocate(a, this.size);\n+            this.depth = b == null ? 0 : depth;\n+        }\n+\n@@ -4032,2 +4625,1 @@\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                    throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4060,1 +4652,0 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n@@ -4069,1 +4660,2 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4102,2 +4694,1 @@\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+                throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4119,1 +4710,2 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4150,2 +4742,1 @@\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n+            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4164,0 +4755,30 @@\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param a the array of given type\n+     * @param length the additional buffer length\n+     * @return {@code null} if requested length is too large, otherwise created buffer\n+     *\/\n+    private static Object tryAllocate(Object a, int length) {\n+        if (length > MAX_BUFFER_LENGTH) {\n+            return null;\n+        }\n+        try {\n+            if (a instanceof int[]) {\n+                return new int[length];\n+            }\n+            if (a instanceof long[]) {\n+                return new long[length];\n+            }\n+            if (a instanceof float[]) {\n+                return new float[length];\n+            }\n+            if (a instanceof double[]) {\n+                return new double[length];\n+            }\n+            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":1414,"deletions":793,"binary":false,"changes":2207,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -47,3 +47,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_RUN_LENGTHS =\n+        { 1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n@@ -51,3 +51,3 @@\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_RUN_LENGTHS =\n+        { 1, 8, 55, 100, 10_000 };\n@@ -55,3 +55,3 @@\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RUN_RANDOMS =\n+        { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n@@ -59,3 +59,3 @@\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Initial random values for short run\n+    private static final TestRandom[] SHORT_RUN_RANDOMS =\n+        { TestRandom.C0FFEE };\n@@ -63,1 +63,1 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Constant to fill the left part of array\n@@ -65,0 +65,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -83,0 +85,1 @@\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -124,1 +127,0 @@\n-            testMergingSort(length, random);\n@@ -126,0 +128,1 @@\n+            testMergingSort(length, random);\n@@ -142,1 +145,0 @@\n-            testRange(length, random);\n@@ -144,0 +146,1 @@\n+            testOutOfBounds(length, random);\n@@ -310,1 +313,1 @@\n-            for (int i = 0; i < test.length; i++) {\n+            for (int i = 0; i < test.length; ++i) {\n@@ -320,1 +323,1 @@\n-    private void testRange(int length, TestRandom random) {\n+    private void testOutOfBounds(int length, TestRandom random) {\n@@ -325,1 +328,1 @@\n-            for (int i = 1; i <= length; i++) {\n+            for (int i = 1; i <= length; ++i) {\n@@ -330,1 +333,1 @@\n-            for (int i = 0; i < test.length; i++) {\n+            for (int i = 0; i < test.length; ++i) {\n@@ -333,1 +336,1 @@\n-                checkRange(test[i], m);\n+                checkOutOfBounds(test[i], m);\n@@ -340,1 +343,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -393,1 +396,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -411,1 +414,1 @@\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n+        for (int m = PERIOD - 2; m <= PERIOD + 2; ++m) {\n@@ -416,1 +419,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -433,1 +436,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -450,1 +453,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -463,1 +466,1 @@\n-        for (int i = 5; i < test.length; i++) {\n+        for (int i = 5; i < test.length; ++i) {\n@@ -476,1 +479,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -479,1 +482,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -481,6 +485,6 @@\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n+        for (int a = 0; a < MAX; ++a) {\n+            for (int g = 0; g < MAX; ++g) {\n+                for (int z = 0; z < MAX; ++z) {\n+                    for (int n = 0; n < MAX; ++n) {\n+                        for (int p = 0; p < MAX; ++p) {\n+                            if (a + g + z + n + p + s != length) {\n@@ -489,1 +493,1 @@\n-                            for (int i = 5; i < test.length; i++) {\n+                            for (int i = 5; i < test.length; ++i) {\n@@ -498,1 +502,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], a, n + 2, g);\n@@ -505,2 +509,1 @@\n-\n-        for (int m = 13; m > 4; m--) {\n+        for (int m = MAX; m > 4; --m) {\n@@ -509,1 +512,1 @@\n-            int a = length - g - z - n - p;\n+            int a = length - g - z - n - p - s;\n@@ -511,1 +514,1 @@\n-            for (int i = 5; i < test.length; i++) {\n+            for (int i = 5; i < test.length; ++i) {\n@@ -520,1 +523,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], a, n + 2, g);\n@@ -527,1 +530,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -533,1 +536,1 @@\n-        for (int i = fromIndex; i < middle; i++) {\n+        for (int i = fromIndex; i < middle; ++i) {\n@@ -537,1 +540,1 @@\n-        for (int i = middle; i < toIndex; i++) {\n+        for (int i = middle; i < toIndex; ++i) {\n@@ -541,1 +544,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -567,1 +570,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -573,1 +576,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -579,1 +582,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -585,1 +588,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -591,1 +594,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -597,1 +600,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -603,1 +606,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -657,1 +660,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -665,1 +668,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -683,1 +686,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -690,1 +693,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -696,1 +699,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -704,1 +707,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -711,1 +714,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -717,1 +720,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -745,1 +748,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -753,1 +756,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -761,1 +764,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -769,1 +772,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -777,1 +780,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -785,1 +788,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -793,1 +796,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -849,1 +852,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -857,1 +860,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -865,1 +868,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -873,1 +876,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -881,1 +884,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -889,1 +892,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -897,1 +900,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -1112,1 +1115,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1115,1 +1118,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1123,1 +1126,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1126,1 +1129,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1134,1 +1137,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1137,1 +1140,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1145,1 +1148,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1148,1 +1151,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1156,1 +1159,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1159,1 +1162,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1167,1 +1170,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1170,1 +1173,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1178,1 +1181,1 @@\n-        for (int j, i = 1; i < a.length; i++) {\n+        for (int j, i = 1; i < a.length; ++i) {\n@@ -1181,1 +1184,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n+            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n@@ -1209,1 +1212,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1215,1 +1218,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1221,1 +1224,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1229,1 +1232,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1235,1 +1238,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1241,1 +1244,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1249,1 +1252,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1255,1 +1258,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1261,1 +1264,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1269,1 +1272,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1275,1 +1278,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1281,1 +1284,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1289,1 +1292,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1295,1 +1298,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1301,1 +1304,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1309,1 +1312,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1315,1 +1318,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1321,1 +1324,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1329,1 +1332,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1335,1 +1338,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1341,1 +1344,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1348,1 +1351,1 @@\n-    private void checkRange(Object a, int m) {\n+    private void checkOutOfBounds(Object a, int m) {\n@@ -1350,1 +1353,1 @@\n-            checkRange((int[]) a, m);\n+            checkOutOfBounds((int[]) a, m);\n@@ -1352,1 +1355,1 @@\n-            checkRange((long[]) a, m);\n+            checkOutOfBounds((long[]) a, m);\n@@ -1354,1 +1357,1 @@\n-            checkRange((byte[]) a, m);\n+            checkOutOfBounds((byte[]) a, m);\n@@ -1356,1 +1359,1 @@\n-            checkRange((char[]) a, m);\n+            checkOutOfBounds((char[]) a, m);\n@@ -1358,1 +1361,1 @@\n-            checkRange((short[]) a, m);\n+            checkOutOfBounds((short[]) a, m);\n@@ -1360,1 +1363,1 @@\n-            checkRange((float[]) a, m);\n+            checkOutOfBounds((float[]) a, m);\n@@ -1362,1 +1365,1 @@\n-            checkRange((double[]) a, m);\n+            checkOutOfBounds((double[]) a, m);\n@@ -1368,1 +1371,1 @@\n-    private void checkRange(int[] a, int m) {\n+    private void checkOutOfBounds(int[] a, int m) {\n@@ -1388,1 +1391,1 @@\n-    private void checkRange(long[] a, int m) {\n+    private void checkOutOfBounds(long[] a, int m) {\n@@ -1408,1 +1411,1 @@\n-    private void checkRange(byte[] a, int m) {\n+    private void checkOutOfBounds(byte[] a, int m) {\n@@ -1428,1 +1431,1 @@\n-    private void checkRange(char[] a, int m) {\n+    private void checkOutOfBounds(char[] a, int m) {\n@@ -1448,1 +1451,1 @@\n-    private void checkRange(short[] a, int m) {\n+    private void checkOutOfBounds(short[] a, int m) {\n@@ -1468,1 +1471,1 @@\n-    private void checkRange(float[] a, int m) {\n+    private void checkOutOfBounds(float[] a, int m) {\n@@ -1488,1 +1491,1 @@\n-    private void checkRange(double[] a, int m) {\n+    private void checkOutOfBounds(double[] a, int m) {\n@@ -1545,1 +1548,1 @@\n-        for (int i = 1; i < gold.length; i++) {\n+        for (int i = 1; i < gold.length; ++i) {\n@@ -1550,1 +1553,1 @@\n-        for (int i = 0; i < gold.length; i++) {\n+        for (int i = 0; i < gold.length; ++i) {\n@@ -1565,0 +1568,1 @@\n+\n@@ -1569,1 +1573,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1579,1 +1583,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1589,1 +1593,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1599,1 +1603,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1609,1 +1613,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1619,1 +1623,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1631,1 +1635,1 @@\n-                for (int i = 0; i < m; i++) {\n+                for (int i = 0; i < m; ++i) {\n@@ -1635,1 +1639,1 @@\n-                for (int i = m; i < a.length; i++) {\n+                for (int i = m; i < a.length; ++i) {\n@@ -1645,0 +1649,1 @@\n+\n@@ -1647,1 +1652,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1653,0 +1658,14 @@\n+        PERMUTATION {\n+            void build(int[] a, int m, Random random) {\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; --i) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1]; a[i - 1] = a[k]; a[k] = t;\n+                }\n+            }\n+        },\n+\n@@ -1655,1 +1674,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1663,1 +1682,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1671,1 +1690,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1677,1 +1696,21 @@\n-        SAW {\n+        UNIFORM {\n+            void build(int[] a, int m, Random random) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n+                }\n+            }\n+        },\n+\n+        MASKED {\n+            void build(int[] a, int m, Random random) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i ^ 0xFF) & mask;\n+                }\n+            }\n+        },\n+\n+        SAWTOOTH {\n@@ -1685,1 +1724,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1693,1 +1732,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1706,1 +1745,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1714,1 +1753,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1724,1 +1763,1 @@\n-                for (int i = 0; i < middle; i++) {\n+                for (int i = 0; i < middle; ++i) {\n@@ -1728,1 +1767,1 @@\n-                for (int i = middle; i < a.length; i++) {\n+                for (int i = middle; i < a.length; ++i) {\n@@ -1736,1 +1775,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1744,1 +1783,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1752,1 +1791,1 @@\n-                int x = 0, y = 0;\n+                int k = 0, j = 0;\n@@ -1754,2 +1793,2 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextBoolean() ? (k += 2) : (j += 2);\n@@ -1765,1 +1804,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1775,0 +1814,1 @@\n+\n@@ -1780,1 +1820,1 @@\n-                for (int k = 0; k < m; k++) {\n+                for (int k = 0; k < m; ++k) {\n@@ -1783,1 +1823,1 @@\n-                    for (int p = 0; p < period; p++) {\n+                    for (int p = 0; p < period; ++p) {\n@@ -1788,1 +1828,1 @@\n-                for (int j = i; j < a.length - 1; j++) {\n+                for (int j = i; j < a.length - 1; ++j) {\n@@ -1801,1 +1841,1 @@\n-                for (int k = 0; k < m; k++) {\n+                for (int k = 0; k < m; ++k) {\n@@ -1804,1 +1844,1 @@\n-                    for (int p = 0; p < period; p++) {\n+                    for (int p = 0; p < period; ++p) {\n@@ -1809,1 +1849,1 @@\n-                for (int j = i; j < a.length - 1; j++) {\n+                for (int j = i; j < a.length - 1; ++j) {\n@@ -1819,1 +1859,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1828,1 +1868,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1837,1 +1877,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1850,1 +1890,1 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n+                for (int i = 0, k = level; i < k1; ++i) {\n@@ -1854,1 +1894,1 @@\n-                for (int i = k1; i < k2; i++) {\n+                for (int i = k1; i < k2; ++i) {\n@@ -1858,1 +1898,1 @@\n-                for (int i = k2, k = level; i < a.length; i++) {\n+                for (int i = k2, k = level; i < a.length; ++i) {\n@@ -1876,0 +1916,1 @@\n+\n@@ -1880,1 +1921,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1890,1 +1931,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1900,0 +1941,1 @@\n+\n@@ -1904,1 +1946,1 @@\n-                float[] x = (float[]) o;\n+                float[] data = (float[]) o;\n@@ -1907,1 +1949,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1910,1 +1958,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                fillWithValue(data, -0.0f, fromIndex, g);\n@@ -1913,1 +1961,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                fillWithValue(data, 0.0f, fromIndex, z);\n@@ -1916,1 +1964,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1919,1 +1967,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                fillWithValue(data, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.NaN, fromIndex, a);\n@@ -1927,1 +1981,1 @@\n-                double[] x = (double[]) o;\n+                double[] data = (double[]) o;\n@@ -1930,1 +1984,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1933,1 +1993,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                fillWithValue(data, -0.0d, fromIndex, g);\n@@ -1936,1 +1996,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                fillWithValue(data, 0.0d, fromIndex, z);\n@@ -1939,1 +1999,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1942,1 +2002,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                fillWithValue(data, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.NaN, fromIndex, a);\n@@ -1948,2 +2014,2 @@\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1954,2 +2020,2 @@\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -2000,1 +2066,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2002,0 +2067,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":251,"deletions":185,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @version 2019.09.19\n+ * @version 2020.06.14\n@@ -36,1 +36,1 @@\n- * @since 14\n+ * @since 14 & 18\n@@ -83,10 +83,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -138,10 +128,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -193,0 +173,3 @@\n+    },\n+\n+    RADIX_SORT(\"Radix sort\") {\n@@ -195,2 +178,18 @@\n-        public void sort(Object[] a) {\n-            fail(a);\n+        public void sort(Object a) {\n+            if (a instanceof int[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (int[]) a, 0, ((int[]) a).length);\n+            } else if (a instanceof long[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (long[]) a, 0, ((long[]) a).length);\n+            } else if (a instanceof byte[]) {\n+                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+            } else if (a instanceof char[]) {\n+                DualPivotQuicksort.sort((char[]) a, 0, ((char[]) a).length);\n+            } else if (a instanceof short[]) {\n+                DualPivotQuicksort.sort((short[]) a, 0, ((short[]) a).length);\n+            } else if (a instanceof float[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (float[]) a, 0, ((float[]) a).length);\n+            } else if (a instanceof double[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (double[]) a, 0, ((double[]) a).length);\n+            } else {\n+                fail(a);\n+            }\n@@ -200,2 +199,18 @@\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n+        public void sort(Object a, int low, int high) {\n+            if (a instanceof int[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high);\n+            } else if (a instanceof long[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high);\n+            } else if (a instanceof byte[]) {\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\n+            } else if (a instanceof char[]) {\n+                DualPivotQuicksort.sort((char[]) a, 0, low, high);\n+            } else if (a instanceof short[]) {\n+                DualPivotQuicksort.sort((short[]) a, 0, low, high);\n+            } else if (a instanceof float[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high);\n+            } else if (a instanceof double[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high);\n+            } else {\n+                fail(a);\n+            }\n@@ -322,1 +337,3 @@\n-    abstract public void sort(Object[] a);\n+    public void sort(Object[] a) {\n+        fail(a);\n+    }\n@@ -324,1 +341,3 @@\n-    abstract public void sort(Object[] a, Comparator comparator);\n+    public void sort(Object[] a, Comparator comparator) {\n+        fail(a);\n+    }\n@@ -342,1 +361,1 @@\n-     * Parallelism level for sequential and parallel sorting.\n+     * Parallelism level for sequential sorting.\n@@ -345,1 +364,5 @@\n-    private static final int PARALLEL = 87;\n+\n+    \/**\n+     * Parallelism level for parallel sorting.\n+     *\/\n+    private static final int PARALLEL = 88;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":54,"deletions":31,"binary":false,"changes":85,"status":"modified"}]}