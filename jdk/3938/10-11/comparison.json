{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,2 @@\n+    \/* ---------------- Insertion sort section ---------------- *\/\n+\n@@ -62,1 +64,1 @@\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 113;\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 124;\n@@ -67,1 +69,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 26;\n+    private static final int MAX_INSERTION_SORT_SIZE = 20;\n@@ -69,4 +71,1 @@\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    \/* ----------------- Merging sort section ----------------- *\/\n@@ -77,1 +76,1 @@\n-    private static final int MIN_MERGING_SORT_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -80,1 +79,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min size of run to continue scanning.\n@@ -82,1 +81,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_RUN_SIZE = 128;\n@@ -85,1 +84,1 @@\n-     * Min factor for the first runs to continue scanning.\n+     * Min number of runs for parallel merging.\n@@ -87,1 +86,1 @@\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    private static final int MIN_PARALLEL_RUN_MERGING_COUNT = 4;\n@@ -90,1 +89,1 @@\n-     * Max capacity of the index array for tracking runs.\n+     * Min array size to invoke parallel merging of parts.\n@@ -92,1 +91,1 @@\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    private static final int MIN_PARALLEL_PART_MERGING_SIZE = 4 << 10;\n@@ -94,4 +93,1 @@\n-    \/**\n-     * Min number of runs, required by parallel merging.\n-     *\/\n-    private static final int MIN_RUN_COUNT = 4;\n+    \/* ------------------ Radix sort section ------------------ *\/\n@@ -100,1 +96,1 @@\n-     * Min array size to use parallel merging of parts.\n+     * Min array size to use Radix sort.\n@@ -102,1 +98,3 @@\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    private static final int MIN_RADIX_SORT_SIZE = 768;\n+\n+    \/* ------------------ Counting sort section --------------- *\/\n@@ -114,9 +112,1 @@\n-    \/**\n-     * Min array size to use Radix sort.\n-     *\/\n-    private static final int MIN_RADIX_SORT_SIZE = 6 << 10;\n-\n-    \/**\n-     * Threshold of mixed insertion sort is increased by this value.\n-     *\/\n-    private static final int DEPTH = 3 << 1;\n+    \/* -------------------- Common section -------------------- *\/\n@@ -125,1 +115,1 @@\n-     * Min depth to invoke Radix sort.\n+     * Max recursive depth before switching to heap sort.\n@@ -127,1 +117,1 @@\n-    private static final int MIN_RADIX_SORT_DEPTH = DEPTH << 2;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -130,1 +120,1 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Min array size to perform sorting in parallel.\n@@ -132,1 +122,1 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DEPTH;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n@@ -135,2 +125,2 @@\n-     * Max length of additional buffer,\n-     * limited by max_heap \/ 64 or 256m elements (2gb max).\n+     * Max length of additional buffer, limited by\n+     *      max_heap \/ 64 or 256mb elements (2gb max).\n@@ -179,1 +169,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -182,1 +172,1 @@\n-                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n+                mixedInsertionSort(a, low, high);\n@@ -190,1 +180,1 @@\n-                insertionSort(a, low, high, (bits & 1) == 0);\n+                insertionSort(a, low, high);\n@@ -195,2 +185,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -198,1 +187,1 @@\n-            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n@@ -203,8 +192,0 @@\n-            \/*\n-             * Switch to heap sort, if execution time is quadratic.\n-             *\/\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n@@ -231,1 +212,1 @@\n-                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n@@ -272,3 +253,3 @@\n-            if (size > MIN_RADIX_SORT_SIZE\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n@@ -279,0 +260,8 @@\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -464,1 +453,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -467,1 +455,2 @@\n-    private static void mixedInsertionSort(int[] a, int low, int end, int high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n+        int end = high - (((high - low) >> 4) << 3);\n@@ -553,128 +542,0 @@\n-     * @param leftmost indicates that the range is the leftmost part\n-     *\/\n-    private static void insertionSort(int[] a, int low, int high, boolean leftmost) {\n-        if (leftmost) {\n-            for (int i, k = low; ++k < high; ) {\n-                int ai = a[i = k];\n-\n-                if (ai < a[i - 1]) {\n-                    while (--i >= low && ai < a[i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-        } else {\n-            for (int i; ++low < high; ) {\n-                int ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (Least Significant Digit) Radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {\n-        int[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = (int[]) sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else {\n-            if ((b = (int[]) tryAllocate(a, size)) == null) {\n-                return false;\n-            }\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1024];\n-        int[] count2 = new int[2048];\n-        int[] count3 = new int[2048];\n-\n-        for (int i = low; i < high; ++i) {\n-            count1[ a[i]         & 0x3FF]--;\n-            count2[(a[i] >>> 10) & 0x7FF]--;\n-            count3[(a[i] >>> 21) ^ 0x400]--; \/\/ Reverse the sign bit\n-        }\n-\n-        \/*\n-         * Detect digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n-        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n-        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = low; i < high; ++i) {\n-                b[count1[a[i] & 0x3FF]++ - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Checks the count array and then creates histogram.\n-     *\n-     * @param count the count array\n-     * @param last the last index of count array\n-     * @param total the total number of elements\n-     * @param high the index of the last element, exclusive\n-     * @return {@code true} if the digit must be processed, otherwise {@code false}\n@@ -682,1 +543,3 @@\n-    private static boolean processDigit(int[] count, int last, int total, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            int ai = a[i = k];\n@@ -684,11 +547,1 @@\n-        \/*\n-         * Check if we can skip given digit.\n-         *\/\n-        for (int c : count) {\n-            if (c == total) {\n-                return false;\n-            }\n-            if (c < 0) {\n-                break;\n-            }\n-        }\n+            if (ai < a[low]) {\n@@ -696,4 +549,3 @@\n-        \/*\n-         * Compute the histogram.\n-         *\/\n-        count[last] += high;\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -701,5 +553,1 @@\n-        for (int i = last; i > 0; --i) {\n-            count[i - 1] += count[i];\n-        }\n-        return true;\n-    }\n+                a[low] = ai;\n@@ -707,17 +555,1 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n+             } else if (ai < a[i - 1]) {\n@@ -725,12 +557,3 @@\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n@@ -738,8 +561,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i + 1] = ai;\n@@ -748,1 +564,0 @@\n-        a[p] = value;\n@@ -760,1 +575,1 @@\n-    private static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {\n@@ -763,3 +578,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * Element run[i] holds the start index of\n+         * i-th sub-sequence in non-descending order.\n@@ -777,1 +591,1 @@\n-             * Find the end index of the current run.\n+             * Find the end of the current run.\n@@ -802,1 +616,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -805,0 +627,1 @@\n+\n@@ -807,1 +630,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -813,10 +636,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                \/\/ Initial min 127, max 1023, extended to 5120\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[(size >> 9) & 0x1FF | 0x3F];\n@@ -825,9 +639,1 @@\n-            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -835,1 +641,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n+                if (++count == run.length) {\n@@ -841,7 +647,0 @@\n-\n-                if (count == run.length) {\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n@@ -849,0 +648,1 @@\n+\n@@ -851,0 +651,3 @@\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n@@ -852,3 +655,0 @@\n-                \/*\n-                 * This is single-element run at the end.\n-                 *\/\n@@ -860,1 +660,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -867,4 +667,2 @@\n-            } else {\n-                if ((b = (int[]) tryAllocate(a, size)) == null) {\n-                    return false;\n-                }\n+            } else if ((b = (int[]) tryAllocate(a, size)) == null) {\n+                return false;\n@@ -912,1 +710,1 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n+        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n@@ -968,1 +766,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n@@ -1028,2 +826,0 @@\n-\/\/ #[long]\n-\n@@ -1031,8 +827,2 @@\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n-     *\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n-     * the four-way parallel merge is started, still ensuring enough\n-     * parallelism to process the partitions.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -1041,1 +831,0 @@\n-     * @param parallelism the parallelism level\n@@ -1044,0 +833,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1045,4 +835,182 @@\n-    static void sort(long[] a, int parallelism, int low, int high) {\n-        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n-            new Sorter(a, parallelism, low, high - low, 0).invoke();\n-        } else {\n+    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (int[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = (int[]) tryAllocate(a, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ a[i]         & 0x3FF]--;\n+            count2[(a[i] >>> 10) & 0x7FF]--;\n+            count3[(a[i] >>> 21) ^ 0x400]--; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[a[i] & 0x3FF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Checks the count array and then creates histogram.\n+     *\n+     * @param count the count array\n+     * @param last the last index of count array\n+     * @param total the total number of elements\n+     * @param high the index of the last element, exclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int last, int total, int high) {\n+\n+        \/*\n+         * Check if we can skip given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c < 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[last] += high;\n+\n+        for (int i = last; i > 0; --i) {\n+            count[i - 1] += count[i];\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[long]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(long[] a, int parallelism, int low, int high) {\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, parallelism, low, high - low, 0).invoke();\n+        } else {\n@@ -1068,1 +1036,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -1071,1 +1039,1 @@\n-                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n+                mixedInsertionSort(a, low, high);\n@@ -1079,1 +1047,1 @@\n-                insertionSort(a, low, high, (bits & 1) == 0);\n+                insertionSort(a, low, high);\n@@ -1084,2 +1052,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -1087,1 +1054,1 @@\n-            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n@@ -1092,8 +1059,0 @@\n-            \/*\n-             * Switch to heap sort, if execution time is quadratic.\n-             *\/\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n@@ -1120,1 +1079,1 @@\n-                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n@@ -1161,3 +1120,3 @@\n-            if (size > MIN_RADIX_SORT_SIZE\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n@@ -1168,0 +1127,8 @@\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -1353,1 +1320,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -1356,1 +1322,2 @@\n-    private static void mixedInsertionSort(long[] a, int low, int end, int high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n+        int end = high - (((high - low) >> 4) << 3);\n@@ -1442,1 +1409,0 @@\n-     * @param leftmost indicates that the range is the leftmost part\n@@ -1444,15 +1410,17 @@\n-    private static void insertionSort(long[] a, int low, int high, boolean leftmost) {\n-        if (leftmost) {\n-            for (int i, k = low; ++k < high; ) {\n-                long ai = a[i = k];\n-\n-                if (ai < a[i - 1]) {\n-                    while (--i >= low && ai < a[i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-        } else {\n-            for (int i; ++low < high; ) {\n-                long ai = a[i = low];\n+    static void insertionSort(long[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            long ai = a[i = k];\n+\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n@@ -1460,3 +1428,0 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n@@ -1469,2 +1434,1 @@\n-     * Tries to sort the specified range of the array\n-     * using LSD (Least Significant Digit) Radix sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1472,0 +1436,1 @@\n+     * @param sorter parallel context\n@@ -1473,2 +1438,2 @@\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n+     * @param low the index of the first element to be sorted\n+     * @param size the array size\n@@ -1477,2 +1442,1 @@\n-    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {\n-        long[] b; int offset = low, size = high - low;\n+    static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {\n@@ -1481,1 +1445,2 @@\n-         * Allocate additional buffer.\n+         * Element run[i] holds the start index of\n+         * i-th sub-sequence in non-descending order.\n@@ -1483,10 +1448,3 @@\n-        if (sorter != null && (b = (long[]) sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else {\n-            if ((b = (long[]) tryAllocate(a, size)) == null) {\n-                return false;\n-            }\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n+        int[] run = null;\n+        int high = low + size;\n+        int count = 1, last = low;\n@@ -1495,1 +1453,1 @@\n-         * Count the number of all digits.\n+         * Identify all possible runs.\n@@ -1497,6 +1455,1 @@\n-        int[] count1 = new int[1024];\n-        int[] count2 = new int[2048];\n-        int[] count3 = new int[2048];\n-        int[] count4 = new int[2048];\n-        int[] count5 = new int[2048];\n-        int[] count6 = new int[1024];\n+        for (int k = low + 1; k < high; ) {\n@@ -1504,185 +1457,4 @@\n-        for (int i = low; i < high; ++i) {\n-            count1[(int)  (a[i]         & 0x3FF)]--;\n-            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;\n-            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;\n-            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;\n-            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;\n-            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; \/\/ Reverse the sign bit\n-        }\n-\n-        \/*\n-         * Detect digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n-        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n-        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n-        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n-        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n-        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = low; i < high; ++i) {\n-                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 5-th digit.\n-         *\/\n-        if (processDigit5) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 6-th digit.\n-         *\/\n-        if (processDigit6) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array using merging sort.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    private static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {\n-\n-        \/*\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n-         *\/\n-        int[] run = null;\n-        int high = low + size;\n-        int count = 1, last = low;\n-\n-        \/*\n-         * Identify all possible runs.\n-         *\/\n-        for (int k = low + 1; k < high; ) {\n-\n-            \/*\n-             * Find the end index of the current run.\n-             *\/\n-            if (a[k - 1] < a[k]) {\n+            \/*\n+             * Find the end of the current run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n@@ -1711,1 +1483,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -1714,0 +1494,1 @@\n+\n@@ -1716,1 +1497,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -1722,10 +1503,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                \/\/ Initial min 127, max 1023, extended to 5120\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[(size >> 9) & 0x1FF | 0x3F];\n@@ -1734,1 +1506,1 @@\n-            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1736,9 +1508,1 @@\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+                if (++count == run.length) {\n@@ -1750,7 +1514,0 @@\n-\n-                if (count == run.length) {\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n@@ -1758,0 +1515,1 @@\n+\n@@ -1760,0 +1518,3 @@\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n@@ -1761,3 +1522,0 @@\n-                \/*\n-                 * This is single-element run at the end.\n-                 *\/\n@@ -1769,1 +1527,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1776,4 +1534,2 @@\n-            } else {\n-                if ((b = (long[]) tryAllocate(a, size)) == null) {\n-                    return false;\n-                }\n+            } else if ((b = (long[]) tryAllocate(a, size)) == null) {\n+                return false;\n@@ -1821,1 +1577,1 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n+        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n@@ -1877,1 +1633,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n@@ -1937,2 +1693,0 @@\n-\/\/ #[byte]\n-\n@@ -1940,2 +1694,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -1946,0 +1700,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1947,5 +1702,81 @@\n-    static void sort(byte[] a, int low, int high) {\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            insertionSort(a, low, high);\n+    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (long[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = (long[]) tryAllocate(a, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (a[i]         & 0x3FF)]--;\n+            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;\n+            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;\n+            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;\n+            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;\n+            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n@@ -1953,0 +1784,53 @@\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n@@ -1956,1 +1840,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Sorts the specified range of the array using heap sort.\n@@ -1962,3 +1846,10 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            byte ai = a[i = k];\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n@@ -1966,5 +1857,15 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n@@ -1972,0 +1873,25 @@\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using\n+     * counting sort or insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            insertionSort(a, low, high);\n@@ -2025,0 +1951,30 @@\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(byte[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            byte ai = a[i = k];\n+\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n+            }\n+        }\n+    }\n+\n@@ -2043,0 +1999,41 @@\n+    \/**\n+     * The number of distinct char values.\n+     *\/\n+    private static final int NUM_CHAR_VALUES = 1 << 16;\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void countingSort(char[] a, int low, int high) {\n+        int[] count = new int[NUM_CHAR_VALUES];\n+\n+        \/*\n+         * Compute the histogram for all values.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i]]);\n+\n+        \/*\n+         * Put values on their final positions.\n+         *\/\n+        if (high - low > NUM_CHAR_VALUES) {\n+            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n+                for (low = high - count[--i]; high > low;\n+                    a[--high] = (char) i\n+                );\n+            }\n+        } else {\n+            for (int i = NUM_CHAR_VALUES; high > low; ) {\n+                while (count[--i] == 0);\n+                int c = count[i];\n+\n+                do {\n+                    a[--high] = (char) i;\n+                } while (--c > 0);\n+            }\n+        }\n+    }\n+\n@@ -2057,1 +2054,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2067,1 +2064,1 @@\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -2295,1 +2292,1 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n+    static void insertionSort(char[] a, int low, int high) {\n@@ -2299,4 +2296,14 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n@@ -2308,0 +2315,2 @@\n+\/\/ #[short]\n+\n@@ -2309,1 +2318,6 @@\n-     * The number of distinct char values.\n+     * Sorts the specified range of the array using\n+     * counting sort or Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -2311,1 +2325,17 @@\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n+    static void sort(short[] a, int low, int high) {\n+        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+\n+    \/**\n+     * The number of distinct short values.\n+     *\/\n+    private static final int NUM_SHORT_VALUES = 1 << 16;\n+\n+    \/**\n+     * Max index of short counter.\n+     *\/\n+    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n@@ -2320,2 +2350,2 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    private static void countingSort(short[] a, int low, int high) {\n+        int[] count = new int[NUM_SHORT_VALUES];\n@@ -2326,1 +2356,1 @@\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n@@ -2331,4 +2361,6 @@\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n+        if (high - low > NUM_SHORT_VALUES) {\n+            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n+                int value = i & 0xFFFF;\n+\n+                for (low = high - count[value]; high > low;\n+                    a[--high] = (short) value\n@@ -2338,3 +2370,5 @@\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n+            for (int i = MAX_SHORT_INDEX; high > low; ) {\n+                while (count[--i & 0xFFFF] == 0);\n+\n+                int value = i & 0xFFFF;\n+                int c = count[value];\n@@ -2343,1 +2377,1 @@\n-                    a[--high] = (char) i;\n+                    a[--high] = (short) value;\n@@ -2349,18 +2383,0 @@\n-\/\/ #[short]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(short[] a, int low, int high) {\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            sort(a, 0, low, high);\n-        }\n-    }\n-\n@@ -2381,1 +2397,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2391,1 +2407,1 @@\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -2619,1 +2635,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2623,33 +2639,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n-\n-        \/*\n-         * Compute the histogram for all values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+            if (ai < a[low]) {\n@@ -2657,6 +2641,3 @@\n-        \/*\n-         * Put values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n@@ -2664,7 +2645,1 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n+                a[low] = ai;\n@@ -2672,2 +2647,1 @@\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n+             } else if (ai < a[i - 1]) {\n@@ -2676,2 +2650,4 @@\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -2774,1 +2750,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2777,1 +2753,1 @@\n-                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n+                mixedInsertionSort(a, low, high);\n@@ -2785,1 +2761,1 @@\n-                insertionSort(a, low, high, (bits & 1) == 0);\n+                insertionSort(a, low, high);\n@@ -2790,2 +2766,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -2793,1 +2768,1 @@\n-            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n@@ -2798,8 +2773,0 @@\n-            \/*\n-             * Switch to heap sort, if execution time is quadratic.\n-             *\/\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n@@ -2826,1 +2793,1 @@\n-                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n@@ -2867,3 +2834,3 @@\n-            if (size > MIN_RADIX_SORT_SIZE\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n@@ -2874,0 +2841,8 @@\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -3059,1 +3034,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -3062,1 +3036,2 @@\n-    private static void mixedInsertionSort(float[] a, int low, int end, int high) {\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n+        int end = high - (((high - low) >> 4) << 3);\n@@ -3122,118 +3097,2 @@\n-                while (a2 < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = a2;\n-\n-            } else if (a1 < a[i - 1]) {\n-\n-                while (a2 < a[--i]) {\n-                    a[i + 2] = a[i];\n-                }\n-                a[++i + 1] = a2;\n-\n-                while (a1 < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = a1;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @param leftmost indicates that the range is the leftmost part\n-     *\/\n-    private static void insertionSort(float[] a, int low, int high, boolean leftmost) {\n-        if (leftmost) {\n-            for (int i, k = low; ++k < high; ) {\n-                float ai = a[i = k];\n-\n-                if (ai < a[i - 1]) {\n-                    while (--i >= low && ai < a[i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-        } else {\n-            for (int i; ++low < high; ) {\n-                float ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (Least Significant Digit) Radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {\n-        float[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = (float[]) sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else {\n-            if ((b = (float[]) tryAllocate(a, size)) == null) {\n-                return false;\n-            }\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1024];\n-        int[] count2 = new int[2048];\n-        int[] count3 = new int[2048];\n-\n-        for (int i = low; i < high; ++i) {\n-            count1[ fti(a[i])         & 0x3FF]--;\n-            count2[(fti(a[i]) >>> 10) & 0x7FF]--;\n-            count3[(fti(a[i]) >>> 21) & 0x7FF]--;\n-        }\n-\n-        \/*\n-         * Detect digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n-        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n-        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = low; i < high; ++i) {\n-                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3241,2 +3100,1 @@\n-            }\n-        }\n+                a[i + 1] = a2;\n@@ -3244,7 +3102,4 @@\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3252,3 +3107,4 @@\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3256,0 +3112,1 @@\n+                a[i + 1] = a1;\n@@ -3258,8 +3115,0 @@\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n@@ -3269,12 +3118,1 @@\n-     * Returns masked bits that represent the float number.\n-     *\n-     * @param f the given number\n-     * @return masked bits\n-     *\/\n-    private static int fti(float f) {\n-        int x = Float.floatToRawIntBits(f);\n-        return x ^ ((x >> 31) | 0x80000000);\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -3286,10 +3124,3 @@\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n+    static void insertionSort(float[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            float ai = a[i = k];\n@@ -3297,12 +3128,1 @@\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+            if (ai < a[low]) {\n@@ -3310,8 +3130,13 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -3320,1 +3145,0 @@\n-        a[p] = value;\n@@ -3332,1 +3156,1 @@\n-    private static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {\n@@ -3335,3 +3159,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * Element run[i] holds the start index of\n+         * i-th sub-sequence in non-descending order.\n@@ -3349,1 +3172,1 @@\n-             * Find the end index of the current run.\n+             * Find the end of the current run.\n@@ -3374,1 +3197,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -3377,0 +3208,1 @@\n+\n@@ -3379,1 +3211,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3385,10 +3217,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                \/\/ Initial min 127, max 1023, extended to 5120\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[(size >> 9) & 0x1FF | 0x3F];\n@@ -3397,9 +3220,1 @@\n-            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3407,1 +3222,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n+                if (++count == run.length) {\n@@ -3413,7 +3228,0 @@\n-\n-                if (count == run.length) {\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n@@ -3421,0 +3229,1 @@\n+\n@@ -3423,0 +3232,3 @@\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n@@ -3424,3 +3236,0 @@\n-                \/*\n-                 * This is single-element run at the end.\n-                 *\/\n@@ -3432,1 +3241,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3439,4 +3248,2 @@\n-            } else {\n-                if ((b = (float[]) tryAllocate(a, size)) == null) {\n-                    return false;\n-                }\n+            } else if ((b = (float[]) tryAllocate(a, size)) == null) {\n+                return false;\n@@ -3484,1 +3291,1 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n+        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n@@ -3540,1 +3347,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n@@ -3569,4 +3376,164 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                \/*\n+                 * Merge the right sub-parts in parallel.\n+                 *\/\n+                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+\n+                \/*\n+                 * Process the sub-left parts.\n+                 *\/\n+                hi1 = mi1;\n+                hi2 = mi2;\n+            }\n+        }\n+\n+        \/*\n+         * Merge small parts sequentially.\n+         *\/\n+        while (lo1 < hi1 && lo2 < hi2) {\n+            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        }\n+        if (dst != a1 || k < lo1) {\n+            while (lo1 < hi1) {\n+                dst[k++] = a1[lo1++];\n+            }\n+        }\n+        if (dst != a2 || k < lo2) {\n+            while (lo2 < hi2) {\n+                dst[k++] = a2[lo2++];\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (float[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = (float[]) tryAllocate(a, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ fti(a[i])         & 0x3FF]--;\n+            count2[(fti(a[i]) >>> 10) & 0x7FF]--;\n+            count3[(fti(a[i]) >>> 21) & 0x7FF]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the float value.\n+     *\n+     * @param f the given value\n+     * @return masked bits\n+     *\/\n+    private static int fti(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x ^ ((x >> 31) | 0x80000000);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n@@ -3574,5 +3541,2 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+            if (k > high) {\n+                break;\n@@ -3580,11 +3544,2 @@\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n@@ -3592,4 +3547,2 @@\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+            if (a[k] <= value) {\n+                break;\n@@ -3598,0 +3551,1 @@\n+        a[p] = value;\n@@ -3692,1 +3646,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3695,1 +3649,1 @@\n-                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);\n+                mixedInsertionSort(a, low, high);\n@@ -3703,1 +3657,1 @@\n-                insertionSort(a, low, high, (bits & 1) == 0);\n+                insertionSort(a, low, high);\n@@ -3708,2 +3662,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -3711,1 +3664,1 @@\n-            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n@@ -3716,8 +3669,0 @@\n-            \/*\n-             * Switch to heap sort, if execution time is quadratic.\n-             *\/\n-            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n@@ -3744,1 +3689,1 @@\n-                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+                a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];\n@@ -3785,3 +3730,3 @@\n-            if (size > MIN_RADIX_SORT_SIZE\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+            isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];\n+\n+            if (size > MIN_RADIX_SORT_SIZE && isRandom && (sorter == null || bits > 0)\n@@ -3792,0 +3737,8 @@\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n@@ -3977,1 +3930,0 @@\n-     * @param end the index of the last element for simple insertion sort\n@@ -3980,1 +3932,2 @@\n-    private static void mixedInsertionSort(double[] a, int low, int end, int high) {\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n+        int end = high - (((high - low) >> 4) << 3);\n@@ -4053,213 +4006,4 @@\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = a1;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @param leftmost indicates that the range is the leftmost part\n-     *\/\n-    private static void insertionSort(double[] a, int low, int high, boolean leftmost) {\n-        if (leftmost) {\n-            for (int i, k = low; ++k < high; ) {\n-                double ai = a[i = k];\n-\n-                if (ai < a[i - 1]) {\n-                    while (--i >= low && ai < a[i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n-            }\n-        } else {\n-            for (int i; ++low < high; ) {\n-                double ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (Least Significant Digit) Radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {\n-        double[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = (double[]) sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else {\n-            if ((b = (double[]) tryAllocate(a, size)) == null) {\n-                return false;\n-            }\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1024];\n-        int[] count2 = new int[2048];\n-        int[] count3 = new int[2048];\n-        int[] count4 = new int[2048];\n-        int[] count5 = new int[2048];\n-        int[] count6 = new int[1024];\n-\n-        for (int i = low; i < high; ++i) {\n-            count1[(int)  (dtl(a[i])         & 0x3FF)]--;\n-            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;\n-            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;\n-            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;\n-            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;\n-            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;\n-        }\n-\n-        \/*\n-         * Detect digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n-        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n-        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n-        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n-        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n-        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = low; i < high; ++i) {\n-                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 5-th digit.\n-         *\/\n-        if (processDigit5) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 6-th digit.\n-         *\/\n-        if (processDigit6) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns masked bits that represent the double number.\n-     *\n-     * @param f the given number\n-     * @return masked bits\n-     *\/\n-    private static long dtl(double d) {\n-        long x = Double.doubleToRawLongBits(d);\n-        return x ^ ((x >> 63) | 0x8000000000000000L);\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n@@ -4270,1 +4014,1 @@\n-     * Pushes specified element down during heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -4272,3 +4016,1 @@\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n+     * @param a the array to be sorted\n@@ -4278,3 +4020,3 @@\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+    static void insertionSort(double[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            double ai = a[i = k];\n@@ -4282,8 +4024,15 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+            if (ai < a[low]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (--i > low);\n+\n+                a[low] = ai;\n+\n+             } else if (ai < a[i - 1]) {\n+\n+                do {\n+                    a[i] = a[i - 1];\n+                } while (ai < a[--i]);\n+\n+                a[i + 1] = ai;\n@@ -4292,1 +4041,0 @@\n-        a[p] = value;\n@@ -4304,1 +4052,1 @@\n-    private static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {\n@@ -4307,3 +4055,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * Element run[i] holds the start index of\n+         * i-th sub-sequence in non-descending order.\n@@ -4321,1 +4068,1 @@\n-             * Find the end index of the current run.\n+             * Find the end of the current run.\n@@ -4346,1 +4093,9 @@\n-             * Check special cases.\n+             * Check if the runs are too\n+             * long to continue scanning.\n+             *\/\n+            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -4349,0 +4104,1 @@\n+\n@@ -4351,1 +4107,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -4357,10 +4113,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                \/\/ Initial min 127, max 1023, extended to 5120\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[(size >> 9) & 0x1FF | 0x3F];\n@@ -4369,9 +4116,1 @@\n-            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -4379,1 +4118,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n+                if (++count == run.length) {\n@@ -4385,7 +4124,0 @@\n-\n-                if (count == run.length) {\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n@@ -4393,0 +4125,1 @@\n+\n@@ -4395,0 +4128,3 @@\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n@@ -4396,3 +4132,0 @@\n-                \/*\n-                 * This is single-element run at the end.\n-                 *\/\n@@ -4404,1 +4137,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -4411,4 +4144,2 @@\n-            } else {\n-                if ((b = (double[]) tryAllocate(a, size)) == null) {\n-                    return false;\n-                }\n+            } else if ((b = (double[]) tryAllocate(a, size)) == null) {\n+                return false;\n@@ -4456,1 +4187,1 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n+        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n@@ -4512,1 +4243,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n@@ -4572,0 +4303,201 @@\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = (double[]) sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = (double[]) tryAllocate(a, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (dtl(a[i])         & 0x3FF)]--;\n+            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;\n+            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;\n+            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;\n+            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;\n+            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the double value.\n+     *\n+     * @param d the given value\n+     * @return masked bits\n+     *\/\n+    private static long dtl(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n@@ -4593,1 +4525,1 @@\n-            this.b = depth == 0 ? null : tryAllocate(a, this.size);\n+            this.b = tryAllocate(a, this.size);\n@@ -4609,1 +4541,1 @@\n-        public final void compute() {\n+        public void compute() {\n@@ -4632,1 +4564,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> caller) {\n@@ -4680,1 +4612,1 @@\n-        public final void compute() {\n+        public void compute() {\n@@ -4729,1 +4661,1 @@\n-        protected final Object compute() {\n+        protected Object compute() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":1196,"deletions":1264,"binary":false,"changes":2460,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -47,4 +47,0 @@\n-    \/\/ Lengths of arrays for long run (default)\n-    private static final int[] LONG_RUN_LENGTHS =\n-        { 1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n-\n@@ -53,1 +49,1 @@\n-        { 1, 8, 55, 100, 10_000 };\n+        { 1, 2, 14, 100, 500, 1_000, 10_000 };\n@@ -55,3 +51,3 @@\n-    \/\/ Initial random values for long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS =\n-        { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_RUN_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 10_000, 50_000 };\n@@ -63,0 +59,4 @@\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RUN_RANDOMS =\n+        { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n+\n@@ -72,0 +72,1 @@\n+    private final boolean fix;\n@@ -82,0 +83,4 @@\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms).testBase();\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured(512);\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -84,2 +89,0 @@\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n-        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -90,1 +93,5 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms) {\n+        this(sortingHelper, randoms, SHORT_RUN_LENGTHS, true);\n@@ -94,0 +101,4 @@\n+        this(sortingHelper, randoms, lengths, false);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean fix) {\n@@ -97,0 +108,1 @@\n+        this.fix = fix;\n@@ -99,1 +111,2 @@\n-    private void testBasic() {\n+    private void testBase() {\n+        testStructured(0);\n@@ -104,3 +117,1 @@\n-            testBasic(length);\n-        }\n-    }\n+            testSubArray(length);\n@@ -108,5 +119,5 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+            for (TestRandom random : randoms) {\n+                testWithCheckSum(length, random);\n+                testWithScrambling(length, random);\n+                testWithInsertionSort(length, random);\n+            }\n@@ -117,0 +128,2 @@\n+        testBase();\n+\n@@ -119,3 +132,0 @@\n-            testCore(length);\n-        }\n-    }\n@@ -123,8 +133,4 @@\n-    private void testCore(int length) {\n-        testBasic(length);\n-\n-        for (TestRandom random : randoms) {\n-            testSubArray(length, random);\n-            testMergingSort(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n+            for (TestRandom random : randoms) {\n+                testNegativeZero(length, random);\n+                testFloatingPointSorting(length, random);\n+            }\n@@ -135,0 +141,3 @@\n+        testCore();\n+        testNullArray();\n+\n@@ -137,1 +146,1 @@\n-            testAll(length);\n+            testRange(length);\n@@ -141,6 +150,4 @@\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testStability(length, random);\n-            testOutOfBounds(length, random);\n+    private void testStructured(int min) {\n+        for (int length : lengths) {\n+            createData(length);\n+            testStructured(length, min);\n@@ -151,8 +158,2 @@\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n+        sortingHelper.sort(new int[] {});\n+        sortingHelper.sort(new int[] {}, 0, 0);\n@@ -160,2 +161,2 @@\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n+        sortingHelper.sort(new long[] {});\n+        sortingHelper.sort(new long[] {}, 0, 0);\n@@ -163,4 +164,2 @@\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n+        sortingHelper.sort(new byte[] {});\n+        sortingHelper.sort(new byte[] {}, 0, 0);\n@@ -168,4 +167,2 @@\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n+        sortingHelper.sort(new char[] {});\n+        sortingHelper.sort(new char[] {}, 0, 0);\n@@ -173,1 +170,8 @@\n-        out.println();\n+        sortingHelper.sort(new short[] {});\n+        sortingHelper.sort(new short[] {}, 0, 0);\n+\n+        sortingHelper.sort(new float[] {});\n+        sortingHelper.sort(new float[] {}, 0, 0);\n+\n+        sortingHelper.sort(new double[] {});\n+        sortingHelper.sort(new double[] {}, 0, 0);\n@@ -176,3 +180,9 @@\n-    private void testEmptyAndNullIntArray() {\n-        sortingHelper.sort(new int[] {});\n-        sortingHelper.sort(new int[] {}, 0, 0);\n+    private void testNullArray() {\n+        testNullIntArray();\n+        testNullLongArray();\n+        testNullByteArray();\n+        testNullCharArray();\n+        testNullShortArray();\n+        testNullFloatArray();\n+        testNullDoubleArray();\n+    }\n@@ -180,0 +190,1 @@\n+    private void testNullIntArray() {\n@@ -194,4 +205,1 @@\n-    private void testEmptyAndNullLongArray() {\n-        sortingHelper.sort(new long[] {});\n-        sortingHelper.sort(new long[] {}, 0, 0);\n-\n+    private void testNullLongArray() {\n@@ -212,4 +220,1 @@\n-    private void testEmptyAndNullByteArray() {\n-        sortingHelper.sort(new byte[] {});\n-        sortingHelper.sort(new byte[] {}, 0, 0);\n-\n+    private void testNullByteArray() {\n@@ -230,4 +235,1 @@\n-    private void testEmptyAndNullCharArray() {\n-        sortingHelper.sort(new char[] {});\n-        sortingHelper.sort(new char[] {}, 0, 0);\n-\n+    private void testNullCharArray() {\n@@ -248,4 +250,1 @@\n-    private void testEmptyAndNullShortArray() {\n-        sortingHelper.sort(new short[] {});\n-        sortingHelper.sort(new short[] {}, 0, 0);\n-\n+    private void testNullShortArray() {\n@@ -266,4 +265,1 @@\n-    private void testEmptyAndNullFloatArray() {\n-        sortingHelper.sort(new float[] {});\n-        sortingHelper.sort(new float[] {}, 0, 0);\n-\n+    private void testNullFloatArray() {\n@@ -284,4 +280,1 @@\n-    private void testEmptyAndNullDoubleArray() {\n-        sortingHelper.sort(new double[] {});\n-        sortingHelper.sort(new double[] {}, 0, 0);\n-\n+    private void testNullDoubleArray() {\n@@ -302,2 +295,2 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n+    private void testSubArray(int length) {\n+        if (fix || length < 4) {\n@@ -307,1 +300,0 @@\n-            int fromIndex = m;\n@@ -310,1 +302,1 @@\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n+            prepareSubArray((int[]) gold[0], m, toIndex);\n@@ -314,1 +306,1 @@\n-                printTestName(\"Test subarray\", random, length,\n+                printTestName(\"Test subarray\", length,\n@@ -316,2 +308,2 @@\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n+                sortingHelper.sort(test[i], m, toIndex);\n+                checkSubArray(test[i], m, toIndex);\n@@ -323,4 +315,1 @@\n-    private void testOutOfBounds(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n+    private void testRange(int length) {\n@@ -334,1 +323,1 @@\n-                printTestName(\"Test range check\", random, length,\n+                printTestName(\"Test range check\", length,\n@@ -336,1 +325,1 @@\n-                checkOutOfBounds(test[i], m);\n+                checkRange(test[i], m);\n@@ -342,45 +331,0 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; ++i) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n@@ -388,1 +332,1 @@\n-        if (length > 1000) {\n+        if (length > 1_000) {\n@@ -401,0 +345,1 @@\n+                    checkSorted(gold[i]);\n@@ -408,2 +353,2 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n+    private void testStructured(int length, int min) {\n+        if (length < min) {\n@@ -412,4 +357,2 @@\n-        final int PERIOD = 50;\n-\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; ++m) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n+        for (int m = 1; m < 8; ++m) {\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\n@@ -420,1 +363,1 @@\n-                    printTestName(\"Test merging sort\", random, length,\n+                    printTestName(\"Test structured\", length,\n@@ -431,0 +374,3 @@\n+        if (length > 1_000) {\n+            return;\n+        }\n@@ -448,0 +394,3 @@\n+        if (fix) {\n+            return;\n+        }\n@@ -510,3 +459,2 @@\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p - s;\n+            int g = length \/ m;\n+            int a = length - g - g - g - g - s;\n@@ -516,2 +464,2 @@\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n+                    \", a = \" + a + \", g = \" + g + \", z = \" + g +\n+                    \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n@@ -519,1 +467,1 @@\n-                builder.build(gold[i], a, g, z, n, p, random);\n+                builder.build(gold[i], a, g, g, g, g, random);\n@@ -523,1 +471,1 @@\n-                compare(test[i], gold[i], a, n + 2, g);\n+                compare(test[i], gold[i], a, g + 2, g);\n@@ -565,1 +513,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -644,0 +592,4 @@\n+    private void fail(Object object) {\n+        fail(\"Unknown type of array: \" + object.getClass().getName());\n+    }\n+\n@@ -655,1 +607,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -681,1 +633,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -743,1 +695,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -827,1 +779,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -847,1 +799,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -938,1 +890,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -966,1 +918,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -975,1 +927,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -984,1 +936,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1027,1 +979,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -1055,1 +1007,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1064,1 +1016,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1073,1 +1025,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1095,94 +1047,1 @@\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; ++i) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; --j) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n+        SortingHelper.INSERTION_SORT.sort(a);\n@@ -1207,1 +1066,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1351,1 +1210,1 @@\n-    private void checkOutOfBounds(Object a, int m) {\n+    private void checkRange(Object a, int m) {\n@@ -1353,1 +1212,1 @@\n-            checkOutOfBounds((int[]) a, m);\n+            checkRange((int[]) a, m);\n@@ -1355,1 +1214,1 @@\n-            checkOutOfBounds((long[]) a, m);\n+            checkRange((long[]) a, m);\n@@ -1357,1 +1216,1 @@\n-            checkOutOfBounds((byte[]) a, m);\n+            checkRange((byte[]) a, m);\n@@ -1359,1 +1218,1 @@\n-            checkOutOfBounds((char[]) a, m);\n+            checkRange((char[]) a, m);\n@@ -1361,1 +1220,1 @@\n-            checkOutOfBounds((short[]) a, m);\n+            checkRange((short[]) a, m);\n@@ -1363,1 +1222,1 @@\n-            checkOutOfBounds((float[]) a, m);\n+            checkRange((float[]) a, m);\n@@ -1365,1 +1224,1 @@\n-            checkOutOfBounds((double[]) a, m);\n+            checkRange((double[]) a, m);\n@@ -1367,1 +1226,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1371,1 +1230,1 @@\n-    private void checkOutOfBounds(int[] a, int m) {\n+    private void checkRange(int[] a, int m) {\n@@ -1391,1 +1250,1 @@\n-    private void checkOutOfBounds(long[] a, int m) {\n+    private void checkRange(long[] a, int m) {\n@@ -1411,1 +1270,1 @@\n-    private void checkOutOfBounds(byte[] a, int m) {\n+    private void checkRange(byte[] a, int m) {\n@@ -1431,1 +1290,1 @@\n-    private void checkOutOfBounds(char[] a, int m) {\n+    private void checkRange(char[] a, int m) {\n@@ -1451,1 +1310,1 @@\n-    private void checkOutOfBounds(short[] a, int m) {\n+    private void checkRange(short[] a, int m) {\n@@ -1471,1 +1330,1 @@\n-    private void checkOutOfBounds(float[] a, int m) {\n+    private void checkRange(float[] a, int m) {\n@@ -1491,1 +1350,1 @@\n-    private void checkOutOfBounds(double[] a, int m) {\n+    private void checkRange(double[] a, int m) {\n@@ -1517,1 +1376,1 @@\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+            fail(src);\n@@ -1529,4 +1388,0 @@\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n-    }\n-\n@@ -1548,3 +1403,3 @@\n-        for (int i = 1; i < gold.length; ++i) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n+        for (int i = 0; i < gold.length; ++i) {\n+            TypeConverter converter = TypeConverter.values()[i];\n+            converter.convert((int[]) gold[0], gold[i], fix);\n@@ -1562,0 +1417,4 @@\n+    private void printTestName(String test, int length, String message) {\n+        out.println( \"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n+    }\n+\n@@ -1567,1 +1426,9 @@\n-    private static enum TypeConverter {\n+    private enum TypeConverter {\n+\n+        INT {\n+            void convert(int[] src, Object dst, boolean fix) {\n+                if (fix) {\n+                    src[0] = Integer.MIN_VALUE;\n+                }\n+            }\n+        },\n@@ -1570,1 +1437,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1574,1 +1441,4 @@\n-                    b[i] = (long) src[i];\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Long.MIN_VALUE;\n@@ -1580,1 +1450,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1586,0 +1456,3 @@\n+                if (fix) {\n+                    b[0] = Byte.MIN_VALUE;\n+                }\n@@ -1590,1 +1463,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1596,0 +1469,3 @@\n+                if (fix) {\n+                    b[0] = Character.MIN_VALUE;\n+                }\n@@ -1600,1 +1476,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1606,0 +1482,3 @@\n+                if (fix) {\n+                    b[0] = Short.MIN_VALUE;\n+                }\n@@ -1610,1 +1489,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1616,0 +1495,3 @@\n+                if (fix) {\n+                    b[0] = Float.NEGATIVE_INFINITY;\n+                }\n@@ -1620,1 +1502,1 @@\n-            void convert(int[] src, Object dst) {\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1624,1 +1506,4 @@\n-                    b[i] = (double) src[i];\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Double.NEGATIVE_INFINITY;\n@@ -1629,1 +1514,1 @@\n-        abstract void convert(int[] src, Object dst);\n+        abstract void convert(int[] src, Object dst, boolean fix);\n@@ -1632,1 +1517,2 @@\n-    private static enum SortedBuilder {\n+    private enum SortedBuilder {\n+\n@@ -1648,1 +1534,1 @@\n-    private static enum UnsortedBuilder {\n+    private enum UnsortedBuilder {\n@@ -1672,1 +1558,1 @@\n-        ASCENDING {\n+        UNIFORM {\n@@ -1674,5 +1560,1 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = m + i;\n-                }\n-            }\n-        },\n+                int mask = (m << 15) - 1;\n@@ -1680,2 +1562,0 @@\n-        DESCENDING {\n-            void build(int[] a, int m, Random random) {\n@@ -1683,1 +1563,1 @@\n-                    a[i] = a.length - m - i;\n+                    a[i] = random.nextInt() & mask;\n@@ -1688,1 +1568,1 @@\n-        EQUAL {\n+        REPEATED {\n@@ -1691,11 +1571,1 @@\n-                    a[i] = m;\n-                }\n-            }\n-        },\n-\n-        UNIFORM {\n-            void build(int[] a, int m, Random random) {\n-                int mask = (m << 15) - 1;\n-\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextInt() & mask;\n+                    a[i] = i % m;\n@@ -1706,1 +1576,1 @@\n-        MASKED {\n+        DUPLICATED {\n@@ -1708,2 +1578,0 @@\n-                int mask = (m << 15) - 1;\n-\n@@ -1711,1 +1579,1 @@\n-                    a[i] = (i ^ 0xFF) & mask;\n+                    a[i] = random.nextInt(m);\n@@ -1743,1 +1611,1 @@\n-        REPEATED {\n+        SHUFFLE {\n@@ -1745,0 +1613,13 @@\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] a, int m, Random random);\n+    }\n+\n+    private enum StructuredBuilder {\n+\n+        ASCENDING {\n+            void build(int[] a, int m) {\n@@ -1746,1 +1627,1 @@\n-                    a[i] = i % m;\n+                    a[i] = m + i;\n@@ -1751,2 +1632,2 @@\n-        DUPLICATED {\n-            void build(int[] a, int m, Random random) {\n+        DESCENDING {\n+            void build(int[] a, int m) {\n@@ -1754,1 +1635,17 @@\n-                    a[i] = random.nextInt(m);\n+                    a[i] = a.length - m - i;\n+                }\n+            }\n+        },\n+\n+        EQUAL {\n+            void build(int[] a, int m) {\n+                Arrays.fill(a, m);\n+            }\n+        },\n+\n+        MASKED {\n+            void build(int[] a, int m) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i ^ 0xFF) & mask;\n@@ -1760,1 +1657,1 @@\n-            void build(int[] a, int m, Random random) {\n+            void build(int[] a, int m) {\n@@ -1774,1 +1671,1 @@\n-            void build(int[] a, int m, Random random) {\n+            void build(int[] a, int m) {\n@@ -1782,1 +1679,1 @@\n-            void build(int[] a, int m, Random random) {\n+            void build(int[] a, int m) {\n@@ -1789,10 +1686,0 @@\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int k = 0, j = 0;\n-\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextBoolean() ? (k += 2) : (j += 2);\n-                }\n-            }\n-        },\n-\n@@ -1800,1 +1687,1 @@\n-            void build(int[] a, int m, Random random) {\n+            void build(int[] a, int m) {\n@@ -1802,1 +1689,1 @@\n-                max = max < 2 ? 2 : max;\n+                max = Math.max(max, 2);\n@@ -1808,47 +1695,0 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n-\n-    private static enum MergingBuilder {\n-\n-        ASCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; ++k) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; ++p) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; ++j) {\n-                    a[j] = v++;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; ++k) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; ++p) {\n-                        a[i++] = v--;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; ++j) {\n-                    a[j] = v--;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n@@ -1859,3 +1699,1 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = 0;\n-                }\n+                Arrays.fill(a, 0);\n@@ -1871,1 +1709,1 @@\n-                reverse(a, 0, a.length - 1);\n+                reverse(a, m, a.length - 1);\n@@ -1880,1 +1718,1 @@\n-                reverse(a, 0, 2);\n+                reverse(a, 0, Math.min(m, a.length));\n@@ -1915,1 +1753,1 @@\n-    private static enum NegativeZeroBuilder {\n+    private enum NegativeZeroBuilder {\n@@ -1940,1 +1778,1 @@\n-    private static enum FloatingPointBuilder {\n+    private enum FloatingPointBuilder {\n@@ -2027,37 +1865,0 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n@@ -2080,1 +1881,1 @@\n-        private String seed;\n+        private final String seed;\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":242,"deletions":441,"binary":false,"changes":683,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,22 +41,0 @@\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n@@ -65,17 +43,1 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n-            } else {\n-                fail(a);\n-            }\n+            sort(a, SEQUENTIAL, low, high);\n@@ -86,1 +48,0 @@\n-\n@@ -88,18 +49,2 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n+        public void sort(Object a, int low, int high) {\n+            sort(a, PARALLEL, low, high);\n@@ -107,0 +52,1 @@\n+    },\n@@ -108,0 +54,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -111,1 +58,1 @@\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((int[]) a, low, high);\n@@ -113,1 +60,1 @@\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((long[]) a, low, high);\n@@ -117,1 +64,1 @@\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -119,1 +66,1 @@\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -121,1 +68,1 @@\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((float[]) a, low, high);\n@@ -123,1 +70,1 @@\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((double[]) a, low, high);\n@@ -130,2 +77,1 @@\n-    HEAP_SORT(\"Heap sort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -133,1 +79,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -135,1 +81,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n+                DualPivotQuicksort.insertionSort((int[]) a, low, high);\n@@ -137,1 +83,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n+                DualPivotQuicksort.insertionSort((long[]) a, low, high);\n@@ -139,1 +85,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.insertionSort((byte[]) a, low, high);\n@@ -141,1 +87,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n+                DualPivotQuicksort.insertionSort((char[]) a, low, high);\n@@ -143,1 +89,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n+                DualPivotQuicksort.insertionSort((short[]) a, low, high);\n@@ -145,1 +91,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n+                DualPivotQuicksort.insertionSort((float[]) a, low, high);\n@@ -147,1 +93,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n+                DualPivotQuicksort.insertionSort((double[]) a, low, high);\n@@ -152,0 +98,1 @@\n+    },\n@@ -153,0 +100,1 @@\n+    MERGING_SORT(\"Merging sort\") {\n@@ -156,1 +104,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (int[]) a, low, high - low));\n@@ -158,1 +106,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (long[]) a, low, high - low));\n@@ -162,1 +110,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -164,1 +112,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -166,1 +114,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (float[]) a, low, high - low));\n@@ -168,1 +116,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (double[]) a, low, high - low));\n@@ -176,1 +124,0 @@\n-\n@@ -178,1 +125,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -180,1 +127,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (int[]) a, 0, ((int[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high));\n@@ -182,1 +129,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (long[]) a, 0, ((long[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high));\n@@ -184,1 +131,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\n@@ -186,1 +133,1 @@\n-                DualPivotQuicksort.sort((char[]) a, 0, ((char[]) a).length);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -188,1 +135,1 @@\n-                DualPivotQuicksort.sort((short[]) a, 0, ((short[]) a).length);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -190,1 +137,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (float[]) a, 0, ((float[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high));\n@@ -192,1 +139,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (double[]) a, 0, ((double[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high));\n@@ -197,0 +144,1 @@\n+    },\n@@ -198,0 +146,1 @@\n+    HEAP_SORT(\"Heap sort\") {\n@@ -201,1 +150,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high);\n+                DualPivotQuicksort.heapSort((int[]) a, low, high);\n@@ -203,1 +152,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high);\n+                DualPivotQuicksort.heapSort((long[]) a, low, high);\n@@ -207,1 +156,1 @@\n-                DualPivotQuicksort.sort((char[]) a, 0, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -209,1 +158,1 @@\n-                DualPivotQuicksort.sort((short[]) a, 0, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -211,1 +160,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high);\n+                DualPivotQuicksort.heapSort((float[]) a, low, high);\n@@ -213,1 +162,1 @@\n-                DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high);\n+                DualPivotQuicksort.heapSort((double[]) a, low, high);\n@@ -221,1 +170,0 @@\n-\n@@ -263,11 +211,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -277,1 +214,0 @@\n-\n@@ -319,12 +255,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -333,2 +257,0 @@\n-    abstract public void sort(Object a);\n-\n@@ -337,6 +259,18 @@\n-    public void sort(Object[] a) {\n-        fail(a);\n-    }\n-\n-    public void sort(Object[] a, Comparator comparator) {\n-        fail(a);\n+    public void sort(Object a) {\n+        if (a instanceof int[]) {\n+            sort(a, 0, ((int[]) a).length);\n+        } else if (a instanceof long[]) {\n+            sort(a, 0, ((long[]) a).length);\n+        } else if (a instanceof byte[]) {\n+            sort(a, 0, ((byte[]) a).length);\n+        } else if (a instanceof char[]) {\n+            sort(a, 0, ((char[]) a).length);\n+        } else if (a instanceof short[]) {\n+            sort(a, 0, ((short[]) a).length);\n+        } else if (a instanceof float[]) {\n+            sort(a, 0, ((float[]) a).length);\n+        } else if (a instanceof double[]) {\n+            sort(a, 0, ((double[]) a).length);\n+        } else {\n+            fail(a);\n+        }\n@@ -345,1 +279,1 @@\n-    private SortingHelper(String name) {\n+    SortingHelper(String name) {\n@@ -354,0 +288,26 @@\n+    static void sort(Object a, int parallelism, int low, int high) {\n+        if (a instanceof int[]) {\n+            DualPivotQuicksort.sort((int[]) a, parallelism, low, high);\n+        } else if (a instanceof long[]) {\n+            DualPivotQuicksort.sort((long[]) a, parallelism, low, high);\n+        } else if (a instanceof byte[]) {\n+            DualPivotQuicksort.sort((byte[]) a, low, high);\n+        } else if (a instanceof char[]) {\n+            DualPivotQuicksort.sort((char[]) a, low, high);\n+        } else if (a instanceof short[]) {\n+            DualPivotQuicksort.sort((short[]) a, low, high);\n+        } else if (a instanceof float[]) {\n+            DualPivotQuicksort.sort((float[]) a, parallelism, low, high);\n+        } else if (a instanceof double[]) {\n+            DualPivotQuicksort.sort((double[]) a, parallelism, low, high);\n+        } else {\n+            fail(a);\n+        }\n+    }\n+\n+    private static void check(String name, boolean result) {\n+        if (!result) {\n+            fail(name + \" sort must return true\");\n+        }\n+    }\n+\n@@ -355,1 +315,1 @@\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+        fail(\"Unknown array: \" + a.getClass().getName());\n@@ -358,1 +318,5 @@\n-    private String name;\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n+    }\n+\n+    private final String name;\n@@ -369,6 +333,0 @@\n-\n-    \/**\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n-     *\/\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":96,"deletions":138,"binary":false,"changes":234,"status":"modified"}]}