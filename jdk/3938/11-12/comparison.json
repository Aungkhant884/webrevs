{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -48,1 +47,1 @@\n- * @version 2020.06.14\n+ * @version 2022.06.14\n@@ -50,1 +49,1 @@\n- * @since 1.7 * 14 ^ 18\n+ * @since 1.7 * 14 & 20\n@@ -69,1 +68,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 20;\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n@@ -83,10 +82,0 @@\n-    \/**\n-     * Min number of runs for parallel merging.\n-     *\/\n-    private static final int MIN_PARALLEL_RUN_MERGING_COUNT = 4;\n-\n-    \/**\n-     * Min array size to invoke parallel merging of parts.\n-     *\/\n-    private static final int MIN_PARALLEL_PART_MERGING_SIZE = 4 << 10;\n-\n@@ -114,0 +103,5 @@\n+    \/**\n+     * Min array size to perform sorting in parallel.\n+     *\/\n+    private static final int MIN_PARALLEL_SORT_SIZE = 640;\n+\n@@ -120,1 +114,2 @@\n-     * Min array size to perform sorting in parallel.\n+     * Max size of additional buffer,\n+     *      limited by max_heap \/ 128 or 2 GB max.\n@@ -122,1 +117,2 @@\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    private static final int MAX_4_BYTE_BUFFER_SIZE =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 7, Integer.MAX_VALUE);\n@@ -125,2 +121,2 @@\n-     * Max length of additional buffer, limited by\n-     *      max_heap \/ 64 or 256mb elements (2gb max).\n+     * Max size of additional buffer,\n+     *      limited by max_heap \/ 256 or 2 GB max.\n@@ -128,2 +124,2 @@\n-    private static final int MAX_BUFFER_LENGTH =\n-            (int) Math.min(Runtime.getRuntime().maxMemory() >> 6, 256L << 20);\n+    private static final int MAX_8_BYTE_BUFFER_SIZE =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 8, Integer.MAX_VALUE);\n@@ -147,2 +143,4 @@\n-        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n-            new Sorter(a, parallelism, low, high - low, 0).invoke();\n+        int size = high - low;\n+\n+        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, tryIntAllocate(size), parallelism, low, size, 0).invoke();\n@@ -166,1 +164,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -188,1 +186,1 @@\n-                    && tryMergingSort(sorter, a, low, size)) {\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -204,0 +202,1 @@\n+            int end = high - 1;\n@@ -355,2 +354,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -430,1 +429,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -456,1 +455,1 @@\n-        int end = high - (((high - low) >> 4) << 3);\n+        int size = high - low;\n@@ -459,1 +458,1 @@\n-         * Start with pin insertion sort.\n+         * Invoke simple insertion sort on small part.\n@@ -461,7 +460,3 @@\n-        for (int i, p = high; ++low < end && low < p; ) {\n-            int ai = a[i = low];\n-\n-            \/*\n-             * Find pin element, smaller than the given element.\n-             *\/\n-            while (ai < a[--p]);\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n+                int ai = a[i = low];\n@@ -469,10 +464,4 @@\n-            \/*\n-             * Swap these elements.\n-             *\/\n-            ai = a[p]; a[p] = a[i];\n-\n-            \/*\n-             * Insert element into sorted part.\n-             *\/\n-            while (ai < a[--i]) {\n-                a[i + 1] = a[i];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n@@ -480,1 +469,1 @@\n-            a[i + 1] = ai;\n+            return;\n@@ -484,1 +473,7 @@\n-         * Continue with simple insertion sort.\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n@@ -486,2 +481,10 @@\n-        for (int i; low < end; ++low) {\n-            int ai = a[i = low];\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n@@ -571,2 +574,2 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -575,1 +578,1 @@\n-    static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, int[] a, int low, int high) {\n@@ -578,2 +581,2 @@\n-         * Element run[i] holds the start index of\n-         * i-th sub-sequence in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -581,0 +584,1 @@\n+        int count = 1;\n@@ -582,2 +586,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -588,1 +590,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -591,1 +593,1 @@\n-             * Find the end of the current run.\n+             * Find the next run.\n@@ -619,1 +621,1 @@\n-            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n@@ -636,1 +638,1 @@\n-                run = new int[(size >> 9) & 0x1FF | 0x3F];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -649,0 +651,3 @@\n+            \/*\n+             * Save the current run.\n+             *\/\n@@ -667,1 +672,1 @@\n-            } else if ((b = (int[]) tryAllocate(a, size)) == null) {\n+            } else if ((b = tryIntAllocate(high - low)) == null) {\n@@ -706,1 +711,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -708,11 +713,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        int[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        int[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -727,1 +723,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -766,1 +765,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -778,1 +777,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -791,1 +790,1 @@\n-                 * Reserve space for the left sub-parts.\n+                 * Reserve space for the left part.\n@@ -796,1 +795,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -798,1 +797,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -801,1 +800,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -828,1 +827,1 @@\n-     * using LSD (Least Significant Digit) Radix sort.\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -843,1 +842,1 @@\n-        } else if ((b = (int[]) tryAllocate(a, size)) == null) {\n+        } else if ((b = tryIntAllocate(size)) == null) {\n@@ -996,0 +995,14 @@\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static int[] tryIntAllocate(int size) {\n+        try {\n+            return size < MAX_4_BYTE_BUFFER_SIZE ? new int[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n@@ -1014,2 +1027,4 @@\n-        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n-            new Sorter(a, parallelism, low, high - low, 0).invoke();\n+        int size = high - low;\n+\n+        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, tryLongAllocate(size), parallelism, low, size, 0).invoke();\n@@ -1033,1 +1048,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1055,1 +1070,1 @@\n-                    && tryMergingSort(sorter, a, low, size)) {\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -1071,0 +1086,1 @@\n+            int end = high - 1;\n@@ -1222,2 +1238,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -1297,1 +1313,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -1323,1 +1339,1 @@\n-        int end = high - (((high - low) >> 4) << 3);\n+        int size = high - low;\n@@ -1326,1 +1342,1 @@\n-         * Start with pin insertion sort.\n+         * Invoke simple insertion sort on small part.\n@@ -1328,2 +1344,3 @@\n-        for (int i, p = high; ++low < end && low < p; ) {\n-            long ai = a[i = low];\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n+                long ai = a[i = low];\n@@ -1331,15 +1348,4 @@\n-            \/*\n-             * Find pin element, smaller than the given element.\n-             *\/\n-            while (ai < a[--p]);\n-\n-            \/*\n-             * Swap these elements.\n-             *\/\n-            ai = a[p]; a[p] = a[i];\n-\n-            \/*\n-             * Insert element into sorted part.\n-             *\/\n-            while (ai < a[--i]) {\n-                a[i + 1] = a[i];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n@@ -1347,1 +1353,1 @@\n-            a[i + 1] = ai;\n+            return;\n@@ -1351,1 +1357,2 @@\n-         * Continue with simple insertion sort.\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n@@ -1353,2 +1360,15 @@\n-        for (int i; low < end; ++low) {\n-            long ai = a[i = low];\n+        int end = high - 3 * (size >> 3 << 1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n@@ -1438,2 +1458,2 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -1442,1 +1462,1 @@\n-    static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, long[] a, int low, int high) {\n@@ -1445,2 +1465,2 @@\n-         * Element run[i] holds the start index of\n-         * i-th sub-sequence in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1448,0 +1468,1 @@\n+        int count = 1;\n@@ -1449,2 +1470,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1455,1 +1474,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1458,1 +1477,1 @@\n-             * Find the end of the current run.\n+             * Find the next run.\n@@ -1486,1 +1505,1 @@\n-            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n@@ -1503,1 +1522,1 @@\n-                run = new int[(size >> 9) & 0x1FF | 0x3F];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -1516,0 +1535,3 @@\n+            \/*\n+             * Save the current run.\n+             *\/\n@@ -1534,1 +1556,1 @@\n-            } else if ((b = (long[]) tryAllocate(a, size)) == null) {\n+            } else if ((b = tryLongAllocate(high - low)) == null) {\n@@ -1573,1 +1595,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -1575,11 +1597,2 @@\n-        long[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        long[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        long[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -1594,1 +1607,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -1633,1 +1649,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -1645,1 +1661,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -1658,1 +1674,1 @@\n-                 * Reserve space for the left sub-parts.\n+                 * Reserve space for the left part.\n@@ -1663,1 +1679,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -1665,1 +1681,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -1668,1 +1684,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -1695,1 +1711,1 @@\n-     * using LSD (Least Significant Digit) Radix sort.\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -1710,1 +1726,1 @@\n-        } else if ((b = (long[]) tryAllocate(a, size)) == null) {\n+        } else if ((b = tryLongAllocate(size)) == null) {\n@@ -1883,0 +1899,14 @@\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static long[] tryLongAllocate(int size) {\n+        try {\n+            return size < MAX_8_BYTE_BUFFER_SIZE ? new long[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n@@ -2051,1 +2081,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2081,0 +2111,1 @@\n+            int end = high - 1;\n@@ -2394,1 +2425,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2424,0 +2455,1 @@\n+            int end = high - 1;\n@@ -2699,2 +2731,4 @@\n-        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n-            new Sorter(a, parallelism, low, high - low, 0).invoke();\n+        int size = high - low;\n+\n+        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, tryFloatAllocate(size), parallelism, low, size, 0).invoke();\n@@ -2747,1 +2781,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2769,1 +2803,1 @@\n-                    && tryMergingSort(sorter, a, low, size)) {\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2785,0 +2819,1 @@\n+            int end = high - 1;\n@@ -2936,2 +2971,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -3011,1 +3046,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -3037,1 +3072,1 @@\n-        int end = high - (((high - low) >> 4) << 3);\n+        int size = high - low;\n@@ -3040,1 +3075,1 @@\n-         * Start with pin insertion sort.\n+         * Invoke simple insertion sort on small part.\n@@ -3042,7 +3077,3 @@\n-        for (int i, p = high; ++low < end && low < p; ) {\n-            float ai = a[i = low];\n-\n-            \/*\n-             * Find pin element, smaller than the given element.\n-             *\/\n-            while (ai < a[--p]);\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n+                float ai = a[i = low];\n@@ -3050,10 +3081,4 @@\n-            \/*\n-             * Swap these elements.\n-             *\/\n-            ai = a[p]; a[p] = a[i];\n-\n-            \/*\n-             * Insert element into sorted part.\n-             *\/\n-            while (ai < a[--i]) {\n-                a[i + 1] = a[i];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n@@ -3061,1 +3086,1 @@\n-            a[i + 1] = ai;\n+            return;\n@@ -3065,1 +3090,7 @@\n-         * Continue with simple insertion sort.\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n@@ -3067,2 +3098,10 @@\n-        for (int i; low < end; ++low) {\n-            float ai = a[i = low];\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n@@ -3152,2 +3191,2 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -3156,1 +3195,1 @@\n-    static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, float[] a, int low, int high) {\n@@ -3159,2 +3198,2 @@\n-         * Element run[i] holds the start index of\n-         * i-th sub-sequence in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3162,0 +3201,1 @@\n+        int count = 1;\n@@ -3163,2 +3203,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3169,1 +3207,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3172,1 +3210,1 @@\n-             * Find the end of the current run.\n+             * Find the next run.\n@@ -3200,1 +3238,1 @@\n-            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n@@ -3217,1 +3255,1 @@\n-                run = new int[(size >> 9) & 0x1FF | 0x3F];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -3230,0 +3268,3 @@\n+            \/*\n+             * Save the current run.\n+             *\/\n@@ -3248,1 +3289,1 @@\n-            } else if ((b = (float[]) tryAllocate(a, size)) == null) {\n+            } else if ((b = tryFloatAllocate(high - low)) == null) {\n@@ -3287,1 +3328,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -3289,11 +3330,2 @@\n-        float[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        float[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        float[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -3308,1 +3340,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -3347,1 +3382,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -3359,1 +3394,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -3372,1 +3407,1 @@\n-                 * Reserve space for the left sub-parts.\n+                 * Reserve space for the left part.\n@@ -3377,1 +3412,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -3379,1 +3414,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -3382,1 +3417,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -3409,1 +3444,1 @@\n-     * using LSD (Least Significant Digit) Radix sort.\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -3424,1 +3459,1 @@\n-        } else if ((b = (float[]) tryAllocate(a, size)) == null) {\n+        } else if ((b = tryFloatAllocate(size)) == null) {\n@@ -3554,0 +3589,14 @@\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static float[] tryFloatAllocate(int size) {\n+        try {\n+            return size < MAX_4_BYTE_BUFFER_SIZE ? new float[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n@@ -3595,2 +3644,4 @@\n-        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n-            new Sorter(a, parallelism, low, high - low, 0).invoke();\n+        int size = high - low;\n+\n+        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter(a, tryDoubleAllocate(size), parallelism, low, size, 0).invoke();\n@@ -3643,1 +3694,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -3665,1 +3716,1 @@\n-                    && tryMergingSort(sorter, a, low, size)) {\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3681,0 +3732,1 @@\n+            int end = high - 1;\n@@ -3832,2 +3884,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, lower + 1, upper);\n+                    sorter.fork(bits | 1, upper + 1, high);\n@@ -3907,1 +3959,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, upper, high);\n@@ -3933,1 +3985,1 @@\n-        int end = high - (((high - low) >> 4) << 3);\n+        int size = high - low;\n@@ -3936,1 +3988,1 @@\n-         * Start with pin insertion sort.\n+         * Invoke simple insertion sort on small part.\n@@ -3938,12 +3990,3 @@\n-        for (int i, p = high; ++low < end && low < p; ) {\n-            double ai = a[i = low];\n-\n-            \/*\n-             * Find pin element, smaller than the given element.\n-             *\/\n-            while (ai < a[--p]);\n-\n-            \/*\n-             * Swap these elements.\n-             *\/\n-            ai = a[p]; a[p] = a[i];\n+        if (size < MAX_INSERTION_SORT_SIZE) {\n+            for (int i; ++low < high; ) {\n+                double ai = a[i = low];\n@@ -3951,5 +3994,4 @@\n-            \/*\n-             * Insert element into sorted part.\n-             *\/\n-            while (ai < a[--i]) {\n-                a[i + 1] = a[i];\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = ai;\n@@ -3957,1 +3999,1 @@\n-            a[i + 1] = ai;\n+            return;\n@@ -3961,1 +4003,7 @@\n-         * Continue with simple insertion sort.\n+         * The index of the last element\n+         * for pin insertion sort, exclusive.\n+         *\/\n+        int end = high - 3 * (size >> 3 << 1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n@@ -3963,2 +4011,10 @@\n-        for (int i; low < end; ++low) {\n-            double ai = a[i = low];\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n@@ -4048,2 +4104,2 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -4052,1 +4108,1 @@\n-    static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter sorter, double[] a, int low, int high) {\n@@ -4055,2 +4111,2 @@\n-         * Element run[i] holds the start index of\n-         * i-th sub-sequence in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -4058,0 +4114,1 @@\n+        int count = 1;\n@@ -4059,2 +4116,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -4065,1 +4120,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -4068,1 +4123,1 @@\n-             * Find the end of the current run.\n+             * Find the next run.\n@@ -4096,1 +4151,1 @@\n-            if (count > 1 && k - low < count * MIN_RUN_SIZE) {\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n@@ -4113,1 +4168,1 @@\n-                run = new int[(size >> 9) & 0x1FF | 0x3F];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -4126,0 +4181,3 @@\n+            \/*\n+             * Save the current run.\n+             *\/\n@@ -4144,1 +4202,1 @@\n-            } else if ((b = (double[]) tryAllocate(a, size)) == null) {\n+            } else if ((b = tryDoubleAllocate(high - low)) == null) {\n@@ -4183,1 +4241,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -4185,11 +4243,2 @@\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_PARALLEL_RUN_MERGING_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        double[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        double[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -4204,1 +4253,4 @@\n-        if (parallel) {\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n@@ -4243,1 +4295,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_PART_MERGING_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -4255,1 +4307,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -4268,1 +4320,1 @@\n-                 * Reserve space for the left sub-parts.\n+                 * Reserve space for the left part.\n@@ -4273,1 +4325,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge the right part in parallel.\n@@ -4275,1 +4327,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n@@ -4278,1 +4330,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left part.\n@@ -4305,1 +4357,1 @@\n-     * using LSD (Least Significant Digit) Radix sort.\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -4320,1 +4372,1 @@\n-        } else if ((b = (double[]) tryAllocate(a, size)) == null) {\n+        } else if ((b = tryDoubleAllocate(size)) == null) {\n@@ -4504,0 +4556,14 @@\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n+     *\n+     * @param size the size of additional buffer\n+     * @return {@code null} if requested size is too large, otherwise created buffer\n+     *\/\n+    private static double[] tryDoubleAllocate(int size) {\n+        try {\n+            return size < MAX_8_BYTE_BUFFER_SIZE ? new double[size] : null;\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n@@ -4516,1 +4582,1 @@\n-        private Sorter(Object a, int parallelism, int low, int size, int depth) {\n+        private Sorter(Object a, Object b, int parallelism, int low, int size, int depth) {\n@@ -4518,0 +4584,1 @@\n+            this.b = b;\n@@ -4522,1 +4589,1 @@\n-            while ((parallelism >>= 1) > 0 && (size >>= 8) > 0) {\n+            while (b != null && (parallelism >>= 1) > 0 && (size >>= 8) > 0) {\n@@ -4525,2 +4592,1 @@\n-            this.b = tryAllocate(a, this.size);\n-            this.depth = b == null ? 0 : depth;\n+            this.depth = depth;\n@@ -4564,1 +4630,1 @@\n-        public void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> parent) {\n@@ -4582,1 +4648,1 @@\n-        private void forkSorter(int depth, int low, int high) {\n+        private void fork(int depth, int low, int high) {\n@@ -4631,2 +4697,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(Object dst, int k, Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n@@ -4637,80 +4702,0 @@\n-\n-    \/**\n-     * This class implements parallel merging of runs.\n-     *\/\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 123456789L;\n-\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n-        }\n-    }\n-\n-    \/**\n-     * Tries to allocate memory for additional buffer.\n-     *\n-     * @param a the array of given type\n-     * @param length the additional buffer length\n-     * @return {@code null} if requested length is too large, otherwise created buffer\n-     *\/\n-    private static Object tryAllocate(Object a, int length) {\n-        if (length > MAX_BUFFER_LENGTH) {\n-            return null;\n-        }\n-        try {\n-            if (a instanceof int[]) {\n-                return new int[length];\n-            }\n-            if (a instanceof long[]) {\n-                return new long[length];\n-            }\n-            if (a instanceof float[]) {\n-                return new float[length];\n-            }\n-            if (a instanceof double[]) {\n-                return new double[length];\n-            }\n-            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n-        } catch (OutOfMemoryError e) {\n-            return null;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":347,"deletions":362,"binary":false,"changes":709,"status":"modified"},{"patch":"@@ -142,1 +142,0 @@\n-        testNullArray();\n@@ -180,115 +179,0 @@\n-    private void testNullArray() {\n-        testNullIntArray();\n-        testNullLongArray();\n-        testNullByteArray();\n-        testNullCharArray();\n-        testNullShortArray();\n-        testNullFloatArray();\n-        testNullDoubleArray();\n-    }\n-\n-    private void testNullIntArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullLongArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullByteArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullCharArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullShortArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullFloatArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n-\n-    private void testNullDoubleArray() {\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n-    }\n-\n@@ -318,1 +202,1 @@\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n+                ((int[]) gold[0])[i - 1] = i % m + m % i;\n@@ -418,1 +302,1 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n@@ -466,1 +350,1 @@\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n@@ -1234,1 +1118,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1254,1 +1138,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1274,1 +1158,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1294,1 +1178,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1314,1 +1198,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1334,1 +1218,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1354,1 +1238,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1418,1 +1302,1 @@\n-        out.println( \"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n@@ -1422,1 +1306,1 @@\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":12,"deletions":128,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @version 2020.06.14\n+ * @version 2022.06.14\n@@ -36,1 +36,1 @@\n- * @since 14 & 18\n+ * @since 14 & 20\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}