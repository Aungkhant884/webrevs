{"files":[{"patch":"@@ -49,1 +49,1 @@\n- * @since 1.7 * 14 & 18\n+ * @since 1.7 * 14 ^ 18\n@@ -134,6 +134,2 @@\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n+     * Max length of additional buffer,\n+     * limited by max_heap \/ 64 or 256m elements (2gb max).\n@@ -141,8 +137,2 @@\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n+    private static final int MAX_BUFFER_LENGTH =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >> 6, 256L << 20);\n@@ -245,0 +235,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -281,1 +274,1 @@\n-             * Try Radix sort on large random data.\n+             * Try Radix sort on large fully random data.\n@@ -284,1 +277,1 @@\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH || isRandom)\n@@ -596,1 +589,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -620,4 +613,3 @@\n-        int[] count1 = new int[256];\n-        int[] count2 = new int[256];\n-        int[] count3 = new int[256];\n-        int[] count4 = new int[256];\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n@@ -626,4 +618,3 @@\n-            count1[ a[i]         & 0xFF]--;\n-            count2[(a[i] >>>  8) & 0xFF]--;\n-            count3[(a[i] >>> 16) & 0xFF]--;\n-            count4[(a[i] >>> 24) ^ 0x80]--; \/\/ Reverse the sign bit\n+            count1[ a[i]         & 0x3FF]--;\n+            count2[(a[i] >>> 10) & 0x7FF]--;\n+            count3[(a[i] >>> 21) ^ 0x400]--; \/\/ Reverse the sign bit\n@@ -635,4 +626,3 @@\n-        boolean processDigit1 = processDigit(count1, 255, -size, high);\n-        boolean processDigit2 = processDigit(count2, 255, -size, high);\n-        boolean processDigit3 = processDigit(count3, 255, -size, high);\n-        boolean processDigit4 = processDigit(count4, 255, -size, high);\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n@@ -645,1 +635,1 @@\n-                b[count1[a[i] & 0xFF]++ - offset] = a[i];\n+                b[count1[a[i] & 0x3FF]++ - offset] = a[i];\n@@ -655,1 +645,1 @@\n-                    a[count2[(b[i] >>> 8) & 0xFF]++] = b[i];\n+                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];\n@@ -659,1 +649,1 @@\n-                    b[count2[(a[i] >>> 8) & 0xFF]++ - offset] = a[i];\n+                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];\n@@ -670,16 +660,1 @@\n-                    a[count3[(b[i] >>> 16) & 0xFF]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(a[i] >>> 16) & 0xFF]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count4[(b[i] >>> 24) ^ 0x80]++] = b[i];\n+                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];\n@@ -689,1 +664,1 @@\n-                    b[count4[(a[i] >>> 24) ^ 0x80]++ - offset] = a[i];\n+                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];\n@@ -697,1 +672,1 @@\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -710,1 +685,1 @@\n-     * @return false if the digit can be skipped, true otherwise\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n@@ -718,3 +693,0 @@\n-            if (c == 0) {\n-                continue;\n-            }\n@@ -724,1 +696,3 @@\n-            break;\n+            if (c < 0) {\n+                break;\n+            }\n@@ -789,1 +763,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -852,1 +826,1 @@\n-                \/\/ Min 127, max 1023, extend to 5120\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -930,3 +904,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1027,0 +999,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -1157,0 +1132,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -1193,1 +1171,1 @@\n-             * Try Radix sort on large random data.\n+             * Try Radix sort on large fully random data.\n@@ -1196,1 +1174,1 @@\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH || isRandom)\n@@ -1508,1 +1486,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1702,1 +1680,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1765,1 +1743,1 @@\n-                \/\/ Min 127, max 1023, extend to 5120\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -1843,3 +1821,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1940,0 +1916,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -2863,0 +2842,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -2899,1 +2881,1 @@\n-             * Try Radix sort on large random data.\n+             * Try Radix sort on large fully random data.\n@@ -2902,1 +2884,1 @@\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH || isRandom)\n@@ -3214,1 +3196,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3238,4 +3220,3 @@\n-        int[] count1 = new int[256];\n-        int[] count2 = new int[256];\n-        int[] count3 = new int[256];\n-        int[] count4 = new int[256];\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n@@ -3244,4 +3225,3 @@\n-            count1[ fti(a[i])         & 0xFF]--;\n-            count2[(fti(a[i]) >>>  8) & 0xFF]--;\n-            count3[(fti(a[i]) >>> 16) & 0xFF]--;\n-            count4[(fti(a[i]) >>> 24) & 0xFF]--;\n+            count1[ fti(a[i])         & 0x3FF]--;\n+            count2[(fti(a[i]) >>> 10) & 0x7FF]--;\n+            count3[(fti(a[i]) >>> 21) & 0x7FF]--;\n@@ -3253,4 +3233,3 @@\n-        boolean processDigit1 = processDigit(count1, 255, -size, high);\n-        boolean processDigit2 = processDigit(count2, 255, -size, high);\n-        boolean processDigit3 = processDigit(count3, 255, -size, high);\n-        boolean processDigit4 = processDigit(count4, 255, -size, high);\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n@@ -3263,1 +3242,1 @@\n-                b[count1[fti(a[i]) & 0xFF]++ - offset] = a[i];\n+                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];\n@@ -3273,1 +3252,1 @@\n-                    a[count2[(fti(b[i]) >>> 8) & 0xFF]++] = b[i];\n+                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];\n@@ -3277,1 +3256,1 @@\n-                    b[count2[(fti(a[i]) >>> 8) & 0xFF]++ - offset] = a[i];\n+                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];\n@@ -3288,16 +3267,1 @@\n-                    a[count3[(fti(b[i]) >>> 16) & 0xFF]++] = b[i];\n-                }\n-            } else {\n-                for (int i = low; i < high; ++i) {\n-                    b[count3[(fti(a[i]) >>> 16) & 0xFF]++ - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = start; i < last; ++i) {\n-                    a[count4[(fti(b[i]) >>> 24) & 0xFF]++] = b[i];\n+                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];\n@@ -3307,1 +3271,1 @@\n-                    b[count4[(fti(a[i]) >>> 24) & 0xFF]++ - offset] = a[i];\n+                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];\n@@ -3315,1 +3279,1 @@\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -3383,1 +3347,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3446,1 +3410,1 @@\n-                \/\/ Min 127, max 1023, extend to 5120\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -3524,3 +3488,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3621,0 +3583,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -3803,0 +3768,3 @@\n+            boolean isRandom =\n+                a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];\n+\n@@ -3839,1 +3807,1 @@\n-             * Try Radix sort on large random data.\n+             * Try Radix sort on large fully random data.\n@@ -3842,1 +3810,1 @@\n-                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH || isRandom)\n@@ -4154,1 +4122,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -4359,1 +4327,1 @@\n-     * @return true if the array is finally sorted, false otherwise\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -4422,1 +4390,1 @@\n-                \/\/ Min 127, max 1023, extend to 5120\n+                \/\/ Initial min 127, max 1023, extended to 5120\n@@ -4500,3 +4468,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -4597,0 +4563,3 @@\n+                \/*\n+                 * Reserve space for the left sub-parts.\n+                 *\/\n@@ -4636,1 +4605,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n@@ -4670,1 +4639,1 @@\n-                    throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n+                    throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4697,1 +4666,0 @@\n-            Object a = this.a; \/\/ Use local variable for better performance\n@@ -4706,1 +4674,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n@@ -4740,1 +4708,1 @@\n-                throw new IllegalArgumentException(\"Unknown type: \" + dst.getClass().getName());\n+                throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4756,1 +4724,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 123456789L;\n@@ -4788,1 +4756,1 @@\n-            throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n+            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4803,1 +4771,17 @@\n-     * Tries to allocate memory for new array.\n+     * Calculates the negative double depth of parallel merging.\n+     *\n+     * @param parallelism the parallelism level\n+     * @param size the target size\n+     * @return the depth of parallel merging\n+     *\/\n+    private static int getDepth(int parallelism, int size) {\n+        int depth = 0;\n+\n+        while ((parallelism >>= 1) > 0 && (size >>= 2) > 0) {\n+            depth -= 2;\n+        }\n+        return depth;\n+    }\n+\n+    \/**\n+     * Tries to allocate memory for additional buffer.\n@@ -4806,2 +4790,2 @@\n-     * @param size the new array size\n-     * @return null if there is not enough memory, created array otherwise\n+     * @param length the additional buffer length\n+     * @return {@code null} if requested length is too large, otherwise created buffer\n@@ -4809,1 +4793,4 @@\n-    private static Object tryAllocate(Object a, int size) {\n+    private static Object tryAllocate(Object a, int length) {\n+        if (length > MAX_BUFFER_LENGTH) {\n+            return null;\n+        }\n@@ -4812,1 +4799,1 @@\n-                return new int[size];\n+                return new int[length];\n@@ -4815,1 +4802,1 @@\n-                return new long[size];\n+                return new long[length];\n@@ -4818,1 +4805,1 @@\n-                return new float[size];\n+                return new float[length];\n@@ -4821,1 +4808,1 @@\n-                return new double[size];\n+                return new double[length];\n@@ -4823,1 +4810,1 @@\n-            throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n+            throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":121,"deletions":134,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+        TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n@@ -2066,1 +2066,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2068,0 +2067,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}