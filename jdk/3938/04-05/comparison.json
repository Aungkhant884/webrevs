{"files":[{"patch":"@@ -39,2 +39,2 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, radix sort, counting sort and parallel merge sort.\n+ * Quicksort such as mixed insertion sort, merging sort and counting\n+ * sort, heap sort and LSD Radix sort, parallel merge sort.\n@@ -74,1 +74,1 @@\n-     * Min array size to try merging of runs.\n+     * Min array size to use merging sort.\n@@ -76,1 +76,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 4 << 10;\n@@ -114,1 +114,1 @@\n-     * Min array size to use radix sort.\n+     * Min array size to use Radix sort.\n@@ -124,1 +124,1 @@\n-     * Min depth to invoke radix sort.\n+     * Min depth to invoke Radix sort.\n@@ -212,2 +212,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -264,1 +264,1 @@\n-             * Insert the last element.\n+             * Insert the third element.\n@@ -281,1 +281,1 @@\n-             * Try radix sort on large random data.\n+             * Try Radix sort on large random data.\n@@ -382,1 +382,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -505,1 +505,1 @@\n-                if (p > i && ai > pin) { \/\/ Element larger than pin\n+                if (p > i && ai > pin) { \/\/ Element, larger than pin\n@@ -508,1 +508,1 @@\n-                     * Find element smaller than pin.\n+                     * Find element, smaller than pin.\n@@ -590,45 +590,2 @@\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array using radix sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -639,1 +596,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -644,0 +601,3 @@\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n@@ -657,0 +617,3 @@\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n@@ -666,1 +629,1 @@\n-            count4[(a[i] >>> 24) ^ 0x80]--;\n+            count4[(a[i] >>> 24) ^ 0x80]--; \/\/ Reverse the sign bit\n@@ -669,4 +632,7 @@\n-        boolean passLevel1 = passLevel(count1, 255, -size, high);\n-        boolean passLevel2 = passLevel(count2, 255, -size, high);\n-        boolean passLevel3 = passLevel(count3, 255, -size, high);\n-        boolean passLevel4 = passLevel(count4, 255, -size, high);\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 255, -size, high);\n+        boolean processDigit2 = processDigit(count2, 255, -size, high);\n+        boolean processDigit3 = processDigit(count3, 255, -size, high);\n+        boolean processDigit4 = processDigit(count4, 255, -size, high);\n@@ -674,1 +640,4 @@\n-        if (passLevel1) {\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n@@ -680,2 +649,5 @@\n-        if (passLevel2) {\n-            if (passLevel1) {\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n@@ -692,2 +664,5 @@\n-        if (passLevel3) {\n-            if (passLevel1 ^ passLevel2) {\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n@@ -704,2 +679,5 @@\n-        if (passLevel4) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -716,1 +694,4 @@\n-        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n@@ -723,1 +704,1 @@\n-     * Scans count array and creates histogram.\n+     * Checks the count array and then creates histogram.\n@@ -726,1 +707,1 @@\n-     * @param last the last index of count\n+     * @param last the last index of count array\n@@ -729,1 +710,1 @@\n-     * @return false if the level can be skipped, true otherwise\n+     * @return false if the digit can be skipped, true otherwise\n@@ -731,1 +712,5 @@\n-    private static boolean passLevel(int[] count, int last, int total, int high) {\n+    private static boolean processDigit(int[] count, int last, int total, int high) {\n+\n+        \/*\n+         * Check if we can skip given digit.\n+         *\/\n@@ -736,1 +721,1 @@\n-            if (c == total) { \/\/ All elements are equal\n+            if (c == total) {\n@@ -754,1 +739,45 @@\n-     * Tries to sort the specified range of the array.\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -760,1 +789,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -762,1 +791,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {\n@@ -823,1 +852,1 @@\n-                \/\/ min 127, max 1023, ext 5120\n+                \/\/ Min 127, max 1023, extend to 5120\n@@ -855,1 +884,1 @@\n-                 * There is a single-element run at the end.\n+                 * This is single-element run at the end.\n@@ -1031,1 +1060,1 @@\n-\/\/ [long]\n+\/\/ #[long]\n@@ -1095,2 +1124,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -1147,1 +1176,1 @@\n-             * Insert the last element.\n+             * Insert the third element.\n@@ -1164,1 +1193,1 @@\n-             * Try radix sort on large random data.\n+             * Try Radix sort on large random data.\n@@ -1265,1 +1294,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -1388,1 +1417,1 @@\n-                if (p > i && ai > pin) { \/\/ Element larger than pin\n+                if (p > i && ai > pin) { \/\/ Element, larger than pin\n@@ -1391,1 +1420,1 @@\n-                     * Find element smaller than pin.\n+                     * Find element, smaller than pin.\n@@ -1473,45 +1502,2 @@\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array using radix sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -1522,1 +1508,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -1527,0 +1513,3 @@\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n@@ -1540,0 +1529,3 @@\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n@@ -1553,1 +1545,1 @@\n-            count6[(int) ((a[i] >>> 54) ^ 0x200)]--;\n+            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; \/\/ Reverse the sign bit\n@@ -1556,6 +1548,9 @@\n-        boolean passLevel1 = passLevel(count1, 1023, -size, high);\n-        boolean passLevel2 = passLevel(count2, 2047, -size, high);\n-        boolean passLevel3 = passLevel(count3, 2047, -size, high);\n-        boolean passLevel4 = passLevel(count4, 2047, -size, high);\n-        boolean passLevel5 = passLevel(count5, 2047, -size, high);\n-        boolean passLevel6 = passLevel(count6, 1023, -size, high);\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n@@ -1563,1 +1558,4 @@\n-        if (passLevel1) {\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n@@ -1569,2 +1567,5 @@\n-        if (passLevel2) {\n-            if (passLevel1) {\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n@@ -1581,2 +1582,5 @@\n-        if (passLevel3) {\n-            if (passLevel1 ^ passLevel2) {\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n@@ -1593,2 +1597,5 @@\n-        if (passLevel4) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -1605,2 +1612,5 @@\n-        if (passLevel5) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n@@ -1617,2 +1627,5 @@\n-        if (passLevel6) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5) {\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n@@ -1629,1 +1642,4 @@\n-        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5 ^ passLevel6) {\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n@@ -1636,1 +1652,45 @@\n-     * Tries to sort the specified range of the array.\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1642,1 +1702,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -1644,1 +1704,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {\n@@ -1705,1 +1765,1 @@\n-                \/\/ min 127, max 1023, ext 5120\n+                \/\/ Min 127, max 1023, extend to 5120\n@@ -1737,1 +1797,1 @@\n-                 * There is a single-element run at the end.\n+                 * This is single-element run at the end.\n@@ -1913,1 +1973,1 @@\n-\/\/ [byte]\n+\/\/ #[byte]\n@@ -1972,1 +2032,1 @@\n-         * Compute histogram for all values.\n+         * Compute the histogram for all values.\n@@ -1977,1 +2037,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2001,1 +2061,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -2087,0 +2147,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2188,1 +2251,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -2295,1 +2358,1 @@\n-         * Compute histogram for all values.\n+         * Compute the histogram for all values.\n@@ -2300,1 +2363,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2320,1 +2383,1 @@\n-\/\/ [short]\n+\/\/ #[short]\n@@ -2406,0 +2469,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2507,1 +2573,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -2619,1 +2685,1 @@\n-         * Compute histogram for all values.\n+         * Compute the histogram for all values.\n@@ -2624,1 +2690,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -2648,1 +2714,1 @@\n-\/\/ [float]\n+\/\/ #[float]\n@@ -2764,2 +2830,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -2816,1 +2882,1 @@\n-             * Insert the last element.\n+             * Insert the third element.\n@@ -2833,1 +2899,1 @@\n-             * Try radix sort on large random data.\n+             * Try Radix sort on large random data.\n@@ -2934,1 +3000,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -3057,1 +3123,1 @@\n-                if (p > i && ai > pin) { \/\/ Element larger than pin\n+                if (p > i && ai > pin) { \/\/ Element, larger than pin\n@@ -3060,1 +3126,1 @@\n-                     * Find element smaller than pin.\n+                     * Find element, smaller than pin.\n@@ -3142,45 +3208,2 @@\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array using radix sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -3191,1 +3214,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -3196,0 +3219,3 @@\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n@@ -3209,0 +3235,3 @@\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n@@ -3221,4 +3250,7 @@\n-        boolean passLevel1 = passLevel(count1, 255, -size, high);\n-        boolean passLevel2 = passLevel(count2, 255, -size, high);\n-        boolean passLevel3 = passLevel(count3, 255, -size, high);\n-        boolean passLevel4 = passLevel(count4, 255, -size, high);\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 255, -size, high);\n+        boolean processDigit2 = processDigit(count2, 255, -size, high);\n+        boolean processDigit3 = processDigit(count3, 255, -size, high);\n+        boolean processDigit4 = processDigit(count4, 255, -size, high);\n@@ -3226,1 +3258,4 @@\n-        if (passLevel1) {\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n@@ -3232,2 +3267,5 @@\n-        if (passLevel2) {\n-            if (passLevel1) {\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n@@ -3244,2 +3282,5 @@\n-        if (passLevel3) {\n-            if (passLevel1 ^ passLevel2) {\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n@@ -3256,2 +3297,5 @@\n-        if (passLevel4) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -3268,1 +3312,4 @@\n-        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n@@ -3286,1 +3333,45 @@\n-     * Tries to sort the specified range of the array.\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3292,1 +3383,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -3294,1 +3385,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {\n@@ -3355,1 +3446,1 @@\n-                \/\/ min 127, max 1023, ext 5120\n+                \/\/ Min 127, max 1023, extend to 5120\n@@ -3387,1 +3478,1 @@\n-                 * There is a single-element run at the end.\n+                 * This is single-element run at the end.\n@@ -3563,1 +3654,1 @@\n-\/\/ [double]\n+\/\/ #[double]\n@@ -3679,2 +3770,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)\n+                    && tryMergingSort(sorter, a, low, size)) {\n@@ -3731,1 +3822,1 @@\n-             * Insert the last element.\n+             * Insert the third element.\n@@ -3748,1 +3839,1 @@\n-             * Try radix sort on large random data.\n+             * Try Radix sort on large random data.\n@@ -3849,1 +3940,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot for repeated data\n@@ -3972,1 +4063,1 @@\n-                if (p > i && ai > pin) { \/\/ Element larger than pin\n+                if (p > i && ai > pin) { \/\/ Element, larger than pin\n@@ -3975,1 +4066,1 @@\n-                     * Find element smaller than pin.\n+                     * Find element, smaller than pin.\n@@ -4057,1 +4148,2 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (Least Significant Digit) Radix sort.\n@@ -4062,45 +4154,1 @@\n-     *\/\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array using radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -4111,0 +4159,3 @@\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n@@ -4124,0 +4175,3 @@\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n@@ -4140,6 +4194,9 @@\n-        boolean passLevel1 = passLevel(count1, 1023, -size, high);\n-        boolean passLevel2 = passLevel(count2, 2047, -size, high);\n-        boolean passLevel3 = passLevel(count3, 2047, -size, high);\n-        boolean passLevel4 = passLevel(count4, 2047, -size, high);\n-        boolean passLevel5 = passLevel(count5, 2047, -size, high);\n-        boolean passLevel6 = passLevel(count6, 1023, -size, high);\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, 1023, -size, high);\n+        boolean processDigit2 = processDigit(count2, 2047, -size, high);\n+        boolean processDigit3 = processDigit(count3, 2047, -size, high);\n+        boolean processDigit4 = processDigit(count4, 2047, -size, high);\n+        boolean processDigit5 = processDigit(count5, 2047, -size, high);\n+        boolean processDigit6 = processDigit(count6, 1023, -size, high);\n@@ -4147,1 +4204,4 @@\n-        if (passLevel1) {\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n@@ -4153,2 +4213,5 @@\n-        if (passLevel2) {\n-            if (passLevel1) {\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n@@ -4165,2 +4228,5 @@\n-        if (passLevel3) {\n-            if (passLevel1 ^ passLevel2) {\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n@@ -4177,2 +4243,5 @@\n-        if (passLevel4) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n@@ -4189,2 +4258,5 @@\n-        if (passLevel5) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n@@ -4201,2 +4273,5 @@\n-        if (passLevel6) {\n-            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5) {\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n@@ -4213,1 +4288,4 @@\n-        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5 ^ passLevel6) {\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n@@ -4231,1 +4309,45 @@\n-     * Tries to sort the specified range of the array.\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -4237,1 +4359,1 @@\n-     * @return true if finally sorted, false otherwise\n+     * @return true if the array is finally sorted, false otherwise\n@@ -4239,1 +4361,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n+    private static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {\n@@ -4300,1 +4422,1 @@\n-                \/\/ min 127, max 1023, ext 5120\n+                \/\/ Min 127, max 1023, extend to 5120\n@@ -4332,1 +4454,1 @@\n-                 * There is a single-element run at the end.\n+                 * This is single-element run at the end.\n@@ -4508,1 +4630,1 @@\n-\/\/ [class]\n+\/\/ #[class]\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":442,"deletions":320,"binary":false,"changes":762,"status":"modified"}]}