{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * sort, counting sort and parallel merge sort.\n+ * sort, radix sort, counting sort and parallel merge sort.\n@@ -47,1 +47,1 @@\n- * @version 2018.08.18\n+ * @version 2020.06.14\n@@ -49,1 +49,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 & 18\n@@ -114,1 +114,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Min array size to use radix sort.\n@@ -116,1 +116,11 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MIN_RADIX_SORT_SIZE = 6 << 10;\n+\n+    \/**\n+     * Threshold of mixed insertion sort is increased by this value.\n+     *\/\n+    private static final int DEPTH = 3 << 1;\n+\n+    \/**\n+     * Min depth to invoke radix sort.\n+     *\/\n+    private static final int MIN_RADIX_SORT_DEPTH = DEPTH << 2;\n@@ -121,1 +131,1 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_RECURSION_DEPTH = 64 * DEPTH;\n@@ -160,1 +170,1 @@\n-            int[] b = depth == 0 ? null : new int[size];\n+            int[] b = depth == 0 ? null : (int[]) tryAllocate(a, size);\n@@ -169,1 +179,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -208,1 +218,1 @@\n-             * Switch to heap sort if execution\n+             * Switch to heap sort, if execution\n@@ -211,1 +221,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -253,0 +263,3 @@\n+            \/*\n+             * Insert the last element.\n+             *\/\n@@ -267,0 +280,10 @@\n+            \/*\n+             * Try radix sort on large random data.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -272,1 +295,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -457,1 +480,1 @@\n-            for (int i; ++low < end; ) {\n+            for (int i; ++low < high; ) {\n@@ -465,0 +488,1 @@\n+\n@@ -469,6 +493,0 @@\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n@@ -481,13 +499,7 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                \/*\n+                 * Put elements larger than an element called pin\n+                 * to the end of array (the proper area for them).\n+                 * It avoids expensive movements of these elements\n+                 * through the whole array.\n+                 *\/\n+                if (p > i && ai > pin) { \/\/ Element larger than pin\n@@ -501,1 +513,1 @@\n-                     * Swap it with large element.\n+                     * Swap it with larger element.\n@@ -507,0 +519,1 @@\n+                }\n@@ -508,7 +521,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                \/*\n+                 * Insert element into sorted part.\n+                 *\/\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -516,0 +527,1 @@\n+                a[i + 1] = ai;\n@@ -621,0 +633,120 @@\n+    \/**\n+     * Tries to sort the specified range of the array using radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n+\n+        if (sorter == null || (b = (int[]) sorter.b) == null) {\n+            b = (int[]) tryAllocate(a, size);\n+\n+            if (b == null) {\n+                return false;\n+            }\n+        } else {\n+            offset = sorter.offset;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        int[] count1 = new int[256];\n+        int[] count2 = new int[256];\n+        int[] count3 = new int[256];\n+        int[] count4 = new int[256];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ a[i]         & 0xFF]--;\n+            count2[(a[i] >>>  8) & 0xFF]--;\n+            count3[(a[i] >>> 16) & 0xFF]--;\n+            count4[(a[i] >>> 24) ^ 0x80]--;\n+        }\n+\n+        boolean passLevel1 = passLevel(count1, 255, -size, high);\n+        boolean passLevel2 = passLevel(count2, 255, -size, high);\n+        boolean passLevel3 = passLevel(count3, 255, -size, high);\n+        boolean passLevel4 = passLevel(count4, 255, -size, high);\n+\n+        if (passLevel1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[a[i] & 0xFF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        if (passLevel2) {\n+            if (passLevel1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(b[i] >>> 8) & 0xFF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(a[i] >>> 8) & 0xFF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel3) {\n+            if (passLevel1 ^ passLevel2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(b[i] >>> 16) & 0xFF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(a[i] >>> 16) & 0xFF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel4) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(b[i] >>> 24) ^ 0x80]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(a[i] >>> 24) ^ 0x80]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Scans count array and creates histogram.\n+     *\n+     * @param count the count array\n+     * @param last the last index of count\n+     * @param total the total number of elements\n+     * @param high the index of the last element, exclusive\n+     * @return false if the level can be skipped, true otherwise\n+     *\/\n+    private static boolean passLevel(int[] count, int last, int total, int high) {\n+        for (int c : count) {\n+            if (c == 0) {\n+                continue;\n+            }\n+            if (c == total) { \/\/ All elements are equal\n+                return false;\n+            }\n+            break;\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[last] += high;\n+\n+        for (int i = last; i > 0; --i) {\n+            count[i - 1] += count[i];\n+        }\n+        return true;\n+    }\n+\n@@ -676,1 +808,0 @@\n-\n@@ -685,1 +816,0 @@\n-\n@@ -693,0 +823,1 @@\n+                \/\/ min 127, max 1023, ext 5120\n@@ -696,1 +827,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -699,1 +830,0 @@\n-\n@@ -708,1 +838,0 @@\n-\n@@ -716,1 +845,0 @@\n-\n@@ -724,0 +852,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * There is a single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -733,1 +868,5 @@\n-                b = new int[size];\n+                b = (int[]) tryAllocate(a, size);\n+\n+                if (b == null) {\n+                    return false;\n+                }\n@@ -914,1 +1053,1 @@\n-            long[] b = depth == 0 ? null : new long[size];\n+            long[] b = depth == 0 ? null : (long[]) tryAllocate(a, size);\n@@ -923,1 +1062,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -962,1 +1101,1 @@\n-             * Switch to heap sort if execution\n+             * Switch to heap sort, if execution\n@@ -965,1 +1104,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -1007,0 +1146,3 @@\n+            \/*\n+             * Insert the last element.\n+             *\/\n@@ -1021,0 +1163,10 @@\n+            \/*\n+             * Try radix sort on large random data.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -1026,1 +1178,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -1211,1 +1363,1 @@\n-            for (int i; ++low < end; ) {\n+            for (int i; ++low < high; ) {\n@@ -1219,0 +1371,1 @@\n+\n@@ -1223,6 +1376,0 @@\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n@@ -1235,13 +1382,7 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                \/*\n+                 * Put elements larger than an element called pin\n+                 * to the end of array (the proper area for them).\n+                 * It avoids expensive movements of these elements\n+                 * through the whole array.\n+                 *\/\n+                if (p > i && ai > pin) { \/\/ Element larger than pin\n@@ -1255,1 +1396,1 @@\n-                     * Swap it with large element.\n+                     * Swap it with larger element.\n@@ -1261,0 +1402,1 @@\n+                }\n@@ -1262,7 +1404,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                \/*\n+                 * Insert element into sorted part.\n+                 *\/\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1270,0 +1410,1 @@\n+                a[i + 1] = ai;\n@@ -1375,0 +1516,119 @@\n+    \/**\n+     * Tries to sort the specified range of the array using radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n+\n+        if (sorter == null || (b = (long[]) sorter.b) == null) {\n+            b = (long[]) tryAllocate(a, size);\n+\n+            if (b == null) {\n+                return false;\n+            }\n+        } else {\n+            offset = sorter.offset;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (a[i]         & 0x3FF)]--;\n+            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;\n+            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;\n+            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;\n+            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;\n+            count6[(int) ((a[i] >>> 54) ^ 0x200)]--;\n+        }\n+\n+        boolean passLevel1 = passLevel(count1, 1023, -size, high);\n+        boolean passLevel2 = passLevel(count2, 2047, -size, high);\n+        boolean passLevel3 = passLevel(count3, 2047, -size, high);\n+        boolean passLevel4 = passLevel(count4, 2047, -size, high);\n+        boolean passLevel5 = passLevel(count5, 2047, -size, high);\n+        boolean passLevel6 = passLevel(count6, 1023, -size, high);\n+\n+        if (passLevel1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        if (passLevel2) {\n+            if (passLevel1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel3) {\n+            if (passLevel1 ^ passLevel2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel4) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel5) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel6) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5 ^ passLevel6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n@@ -1430,1 +1690,0 @@\n-\n@@ -1439,1 +1698,0 @@\n-\n@@ -1447,0 +1705,1 @@\n+                \/\/ min 127, max 1023, ext 5120\n@@ -1450,1 +1709,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -1453,1 +1712,0 @@\n-\n@@ -1462,1 +1720,0 @@\n-\n@@ -1470,1 +1727,0 @@\n-\n@@ -1478,0 +1734,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * There is a single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -1487,1 +1750,5 @@\n-                b = new long[size];\n+                b = (long[]) tryAllocate(a, size);\n+\n+                if (b == null) {\n+                    return false;\n+                }\n@@ -1705,1 +1972,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute histogram for all values.\n@@ -1754,1 +2021,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -1778,1 +2045,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -1839,1 +2106,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2028,1 +2295,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute histogram for all values.\n@@ -2073,1 +2340,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -2097,1 +2364,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -2158,1 +2425,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2352,1 +2619,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute histogram for all values.\n@@ -2426,1 +2693,1 @@\n-            float[] b = depth == 0 ? null : new float[size];\n+            float[] b = depth == 0 ? null : (float[]) tryAllocate(a, size);\n@@ -2464,1 +2731,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -2503,1 +2770,1 @@\n-             * Switch to heap sort if execution\n+             * Switch to heap sort, if execution\n@@ -2506,1 +2773,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -2548,0 +2815,3 @@\n+            \/*\n+             * Insert the last element.\n+             *\/\n@@ -2562,0 +2832,10 @@\n+            \/*\n+             * Try radix sort on large random data.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -2567,1 +2847,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -2752,1 +3032,1 @@\n-            for (int i; ++low < end; ) {\n+            for (int i; ++low < high; ) {\n@@ -2760,0 +3040,1 @@\n+\n@@ -2764,6 +3045,0 @@\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n@@ -2776,13 +3051,7 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                \/*\n+                 * Put elements larger than an element called pin\n+                 * to the end of array (the proper area for them).\n+                 * It avoids expensive movements of these elements\n+                 * through the whole array.\n+                 *\/\n+                if (p > i && ai > pin) { \/\/ Element larger than pin\n@@ -2796,1 +3065,1 @@\n-                     * Swap it with large element.\n+                     * Swap it with larger element.\n@@ -2802,0 +3071,1 @@\n+                }\n@@ -2803,7 +3073,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                \/*\n+                 * Insert element into sorted part.\n+                 *\/\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -2811,0 +3079,1 @@\n+                a[i + 1] = ai;\n@@ -2916,0 +3185,100 @@\n+    \/**\n+     * Tries to sort the specified range of the array using radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n+\n+        if (sorter == null || (b = (float[]) sorter.b) == null) {\n+            b = (float[]) tryAllocate(a, size);\n+\n+            if (b == null) {\n+                return false;\n+            }\n+        } else {\n+            offset = sorter.offset;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        int[] count1 = new int[256];\n+        int[] count2 = new int[256];\n+        int[] count3 = new int[256];\n+        int[] count4 = new int[256];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[ fti(a[i])         & 0xFF]--;\n+            count2[(fti(a[i]) >>>  8) & 0xFF]--;\n+            count3[(fti(a[i]) >>> 16) & 0xFF]--;\n+            count4[(fti(a[i]) >>> 24) & 0xFF]--;\n+        }\n+\n+        boolean passLevel1 = passLevel(count1, 255, -size, high);\n+        boolean passLevel2 = passLevel(count2, 255, -size, high);\n+        boolean passLevel3 = passLevel(count3, 255, -size, high);\n+        boolean passLevel4 = passLevel(count4, 255, -size, high);\n+\n+        if (passLevel1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[fti(a[i]) & 0xFF]++ - offset] = a[i];\n+            }\n+        }\n+\n+        if (passLevel2) {\n+            if (passLevel1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(fti(b[i]) >>> 8) & 0xFF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(fti(a[i]) >>> 8) & 0xFF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel3) {\n+            if (passLevel1 ^ passLevel2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(fti(b[i]) >>> 16) & 0xFF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(fti(a[i]) >>> 16) & 0xFF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel4) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(fti(b[i]) >>> 24) & 0xFF]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(fti(a[i]) >>> 24) & 0xFF]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the float number.\n+     *\n+     * @param f the given number\n+     * @return masked bits\n+     *\/\n+    private static int fti(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x ^ ((x >> 31) | 0x80000000);\n+    }\n+\n@@ -2971,1 +3340,0 @@\n-\n@@ -2980,1 +3348,0 @@\n-\n@@ -2988,0 +3355,1 @@\n+                \/\/ min 127, max 1023, ext 5120\n@@ -2991,1 +3359,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -2994,1 +3362,0 @@\n-\n@@ -3003,1 +3370,0 @@\n-\n@@ -3011,1 +3377,0 @@\n-\n@@ -3019,0 +3384,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * There is a single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -3028,1 +3400,5 @@\n-                b = new float[size];\n+                b = (float[]) tryAllocate(a, size);\n+\n+                if (b == null) {\n+                    return false;\n+                }\n@@ -3232,1 +3608,1 @@\n-            double[] b = depth == 0 ? null : new double[size];\n+            double[] b = depth == 0 ? null : (double[]) tryAllocate(a, size);\n@@ -3270,1 +3646,1 @@\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * other sorts in special cases, possibly with parallel partitions.\n@@ -3309,1 +3685,1 @@\n-             * Switch to heap sort if execution\n+             * Switch to heap sort, if execution\n@@ -3312,1 +3688,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {\n@@ -3354,0 +3730,3 @@\n+            \/*\n+             * Insert the last element.\n+             *\/\n@@ -3368,0 +3747,10 @@\n+            \/*\n+             * Try radix sort on large random data.\n+             *\/\n+            if (size > MIN_RADIX_SORT_SIZE\n+                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n@@ -3373,1 +3762,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of random elements.\n@@ -3558,1 +3947,1 @@\n-            for (int i; ++low < end; ) {\n+            for (int i; ++low < high; ) {\n@@ -3566,0 +3955,1 @@\n+\n@@ -3570,6 +3960,0 @@\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n@@ -3582,13 +3966,7 @@\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n+                \/*\n+                 * Put elements larger than an element called pin\n+                 * to the end of array (the proper area for them).\n+                 * It avoids expensive movements of these elements\n+                 * through the whole array.\n+                 *\/\n+                if (p > i && ai > pin) { \/\/ Element larger than pin\n@@ -3602,1 +3980,1 @@\n-                     * Swap it with large element.\n+                     * Swap it with larger element.\n@@ -3608,0 +3986,1 @@\n+                }\n@@ -3609,7 +3988,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n+                \/*\n+                 * Insert element into sorted part.\n+                 *\/\n+                while (ai < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3617,0 +3994,1 @@\n+                a[i + 1] = ai;\n@@ -3722,0 +4100,130 @@\n+    \/**\n+     * Tries to sort the specified range of the array using radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return true if finally sorted, false otherwise\n+     *\/\n+    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n+\n+        if (sorter == null || (b = (double[]) sorter.b) == null) {\n+            b = (double[]) tryAllocate(a, size);\n+\n+            if (b == null) {\n+                return false;\n+            }\n+        } else {\n+            offset = sorter.offset;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            count1[(int)  (dtl(a[i])         & 0x3FF)]--;\n+            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;\n+            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;\n+            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;\n+            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;\n+            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;\n+        }\n+\n+        boolean passLevel1 = passLevel(count1, 1023, -size, high);\n+        boolean passLevel2 = passLevel(count2, 2047, -size, high);\n+        boolean passLevel3 = passLevel(count3, 2047, -size, high);\n+        boolean passLevel4 = passLevel(count4, 2047, -size, high);\n+        boolean passLevel5 = passLevel(count5, 2047, -size, high);\n+        boolean passLevel6 = passLevel(count6, 1023, -size, high);\n+\n+        if (passLevel1) {\n+            for (int i = low; i < high; ++i) {\n+                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];\n+            }\n+        }\n+\n+        if (passLevel2) {\n+            if (passLevel1) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel3) {\n+            if (passLevel1 ^ passLevel2) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel4) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel5) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel6) {\n+            if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5) {\n+                for (int i = start; i < last; ++i) {\n+                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];\n+                }\n+            } else {\n+                for (int i = low; i < high; ++i) {\n+                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        if (passLevel1 ^ passLevel2 ^ passLevel3 ^ passLevel4 ^ passLevel5 ^ passLevel6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the double number.\n+     *\n+     * @param f the given number\n+     * @return masked bits\n+     *\/\n+    private static long dtl(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\n+    }\n+\n@@ -3777,1 +4285,0 @@\n-\n@@ -3786,1 +4293,0 @@\n-\n@@ -3794,0 +4300,1 @@\n+                \/\/ min 127, max 1023, ext 5120\n@@ -3797,1 +4304,1 @@\n-            } else if (a[last - 1] > a[last]) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start new run\n@@ -3800,1 +4307,0 @@\n-\n@@ -3809,1 +4315,0 @@\n-\n@@ -3817,1 +4322,0 @@\n-\n@@ -3825,0 +4329,7 @@\n+\n+            if (++k == high) {\n+                \/*\n+                 * There is a single-element run at the end.\n+                 *\/\n+                --k;\n+            }\n@@ -3834,1 +4345,5 @@\n-                b = new double[size];\n+                b = (double[]) tryAllocate(a, size);\n+\n+                if (b == null) {\n+                    return false;\n+                }\n@@ -3999,1 +4514,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 31415926L;\n@@ -4011,1 +4526,1 @@\n-            this.depth = depth;\n+            this.depth = b == null ? 0 : depth;\n@@ -4031,2 +4546,1 @@\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                    throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n@@ -4059,1 +4573,1 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n+            Object a = this.a; \/\/ Use local variable for better performance\n@@ -4068,1 +4582,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 31415926L;\n@@ -4100,2 +4614,1 @@\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+                throw new IllegalArgumentException(\"Unknown type: \" + dst.getClass().getName());\n@@ -4117,1 +4630,1 @@\n-        private static final long serialVersionUID = 20180818L;\n+        private static final long serialVersionUID = 31415926L;\n@@ -4147,2 +4660,1 @@\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n+            throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n@@ -4161,0 +4673,27 @@\n+\n+    \/**\n+     * Tries to allocate memory for new array.\n+     *\n+     * @param a the array of given type\n+     * @param size the new array size\n+     * @return null if there is not enough memory, created array otherwise\n+     *\/\n+    private static Object tryAllocate(Object a, int size) {\n+        try {\n+            if (a instanceof int[]) {\n+                return new int[size];\n+            }\n+            if (a instanceof long[]) {\n+                return new long[size];\n+            }\n+            if (a instanceof float[]) {\n+                return new float[size];\n+            }\n+            if (a instanceof double[]) {\n+                return new double[size];\n+            }\n+            throw new IllegalArgumentException(\"Unknown type: \" + a.getClass().getName());\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":726,"deletions":187,"binary":false,"changes":913,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -47,1 +47,1 @@\n-    \/\/ Array lengths used in a long run (default)\n+    \/\/ Lengths of arrays for long run (default)\n@@ -51,1 +51,1 @@\n-    \/\/ Array lengths used in a short run\n+    \/\/ Lengths of arrays for short run\n@@ -55,1 +55,1 @@\n-    \/\/ Random initial values used in a long run (default)\n+    \/\/ Initial random values for long run (default)\n@@ -59,1 +59,1 @@\n-    \/\/ Random initial values used in a short run\n+    \/\/ Initial random values for short run\n@@ -63,1 +63,1 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Constant to fill the left part of array\n@@ -65,0 +65,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -83,0 +85,1 @@\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -124,1 +127,0 @@\n-            testMergingSort(length, random);\n@@ -126,0 +128,1 @@\n+            testMergingSort(length, random);\n@@ -142,1 +145,0 @@\n-            testRange(length, random);\n@@ -144,0 +146,1 @@\n+            testOutOfBounds(length, random);\n@@ -320,1 +323,1 @@\n-    private void testRange(int length, TestRandom random) {\n+    private void testOutOfBounds(int length, TestRandom random) {\n@@ -333,1 +336,1 @@\n-                checkRange(test[i], m);\n+                checkOutOfBounds(test[i], m);\n@@ -476,1 +479,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -479,1 +482,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -486,1 +490,1 @@\n-                            if (a + g + z + n + p != length) {\n+                            if (a + g + z + n + p + s != length) {\n@@ -498,1 +502,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], a, n + 2, g);\n@@ -505,2 +509,1 @@\n-\n-        for (int m = 13; m > 4; m--) {\n+        for (int m = MAX; m > 4; m--) {\n@@ -509,1 +512,1 @@\n-            int a = length - g - z - n - p;\n+            int a = length - g - z - n - p - s;\n@@ -520,1 +523,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], a, n + 2, g);\n@@ -1348,1 +1351,1 @@\n-    private void checkRange(Object a, int m) {\n+    private void checkOutOfBounds(Object a, int m) {\n@@ -1350,1 +1353,1 @@\n-            checkRange((int[]) a, m);\n+            checkOutOfBounds((int[]) a, m);\n@@ -1352,1 +1355,1 @@\n-            checkRange((long[]) a, m);\n+            checkOutOfBounds((long[]) a, m);\n@@ -1354,1 +1357,1 @@\n-            checkRange((byte[]) a, m);\n+            checkOutOfBounds((byte[]) a, m);\n@@ -1356,1 +1359,1 @@\n-            checkRange((char[]) a, m);\n+            checkOutOfBounds((char[]) a, m);\n@@ -1358,1 +1361,1 @@\n-            checkRange((short[]) a, m);\n+            checkOutOfBounds((short[]) a, m);\n@@ -1360,1 +1363,1 @@\n-            checkRange((float[]) a, m);\n+            checkOutOfBounds((float[]) a, m);\n@@ -1362,1 +1365,1 @@\n-            checkRange((double[]) a, m);\n+            checkOutOfBounds((double[]) a, m);\n@@ -1368,1 +1371,1 @@\n-    private void checkRange(int[] a, int m) {\n+    private void checkOutOfBounds(int[] a, int m) {\n@@ -1388,1 +1391,1 @@\n-    private void checkRange(long[] a, int m) {\n+    private void checkOutOfBounds(long[] a, int m) {\n@@ -1408,1 +1411,1 @@\n-    private void checkRange(byte[] a, int m) {\n+    private void checkOutOfBounds(byte[] a, int m) {\n@@ -1428,1 +1431,1 @@\n-    private void checkRange(char[] a, int m) {\n+    private void checkOutOfBounds(char[] a, int m) {\n@@ -1448,1 +1451,1 @@\n-    private void checkRange(short[] a, int m) {\n+    private void checkOutOfBounds(short[] a, int m) {\n@@ -1468,1 +1471,1 @@\n-    private void checkRange(float[] a, int m) {\n+    private void checkOutOfBounds(float[] a, int m) {\n@@ -1488,1 +1491,1 @@\n-    private void checkRange(double[] a, int m) {\n+    private void checkOutOfBounds(double[] a, int m) {\n@@ -1565,0 +1568,1 @@\n+\n@@ -1645,0 +1649,1 @@\n+\n@@ -1653,0 +1658,14 @@\n+        PERMUTATION {\n+            void build(int[] a, int m, Random random) {\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; i--) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1]; a[i - 1] = a[k]; a[k] = t;\n+                }\n+            }\n+        },\n+\n@@ -1677,1 +1696,21 @@\n-        SAW {\n+        UNIFORM {\n+            void build(int[] a, int m, Random random) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n+                }\n+            }\n+        },\n+\n+        MASKED {\n+            void build(int[] a, int m, Random random) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i ^ 0xFF) & mask;\n+                }\n+            }\n+        },\n+\n+        SAWTOOTH {\n@@ -1752,1 +1791,1 @@\n-                int x = 0, y = 0;\n+                int k = 0, j = 0;\n@@ -1755,1 +1794,1 @@\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n+                    a[i] = random.nextBoolean() ? (k += 2) : (j += 2);\n@@ -1775,0 +1814,1 @@\n+\n@@ -1876,0 +1916,1 @@\n+\n@@ -1900,0 +1941,1 @@\n+\n@@ -1904,1 +1946,1 @@\n-                float[] x = (float[]) o;\n+                float[] data = (float[]) o;\n@@ -1907,1 +1949,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                writeValue(data, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, negativeValue, fromIndex, n);\n@@ -1910,1 +1958,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                writeValue(data, -0.0f, fromIndex, g);\n@@ -1913,1 +1961,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                writeValue(data, 0.0f, fromIndex, z);\n@@ -1916,1 +1964,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                writeValue(data, positiveValue, fromIndex, p);\n@@ -1919,1 +1967,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                writeValue(data, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, Float.NaN, fromIndex, a);\n@@ -1927,1 +1981,1 @@\n-                double[] x = (double[]) o;\n+                double[] data = (double[]) o;\n@@ -1930,1 +1984,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                writeValue(data, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                writeValue(data, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                writeValue(data, negativeValue, fromIndex, n);\n@@ -1933,1 +1993,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                writeValue(data, -0.0d, fromIndex, g);\n@@ -1936,1 +1996,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                writeValue(data, 0.0d, fromIndex, z);\n@@ -1939,1 +1999,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                writeValue(data, positiveValue, fromIndex, p);\n@@ -1942,1 +2002,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                writeValue(data, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                writeValue(data, Double.NaN, fromIndex, a);\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":115,"deletions":49,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @version 2019.09.19\n+ * @version 2020.06.14\n@@ -36,1 +36,1 @@\n- * @since 14\n+ * @since 14 & 18\n@@ -83,10 +83,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -138,10 +128,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -193,0 +173,3 @@\n+    },\n+\n+    RADIX_SORT(\"Radix sort\") {\n@@ -195,2 +178,18 @@\n-        public void sort(Object[] a) {\n-            fail(a);\n+        public void sort(Object a) {\n+            if (a instanceof int[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (int[]) a, 0, ((int[]) a).length);\n+            } else if (a instanceof long[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (long[]) a, 0, ((long[]) a).length);\n+            } else if (a instanceof byte[]) {\n+                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+            } else if (a instanceof char[]) {\n+                DualPivotQuicksort.sort((char[]) a, 0, ((char[]) a).length);\n+            } else if (a instanceof short[]) {\n+                DualPivotQuicksort.sort((short[]) a, 0, ((short[]) a).length);\n+            } else if (a instanceof float[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (float[]) a, 0, ((float[]) a).length);\n+            } else if (a instanceof double[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (double[]) a, 0, ((double[]) a).length);\n+            } else {\n+                fail(a);\n+            }\n@@ -200,2 +199,18 @@\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n+        public void sort(Object a, int low, int high) {\n+            if (a instanceof int[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high);\n+            } else if (a instanceof long[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high);\n+            } else if (a instanceof byte[]) {\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\n+            } else if (a instanceof char[]) {\n+                DualPivotQuicksort.sort((char[]) a, 0, low, high);\n+            } else if (a instanceof short[]) {\n+                DualPivotQuicksort.sort((short[]) a, 0, low, high);\n+            } else if (a instanceof float[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high);\n+            } else if (a instanceof double[]) {\n+                DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high);\n+            } else {\n+                fail(a);\n+            }\n@@ -322,1 +337,3 @@\n-    abstract public void sort(Object[] a);\n+    public void sort(Object[] a) {\n+        fail(a);\n+    }\n@@ -324,1 +341,3 @@\n-    abstract public void sort(Object[] a, Comparator comparator);\n+    public void sort(Object[] a, Comparator comparator) {\n+        fail(a);\n+    }\n@@ -342,1 +361,1 @@\n-     * Parallelism level for sequential and parallel sorting.\n+     * Parallelism level for sequential sorting.\n@@ -345,1 +364,5 @@\n-    private static final int PARALLEL = 87;\n+\n+    \/**\n+     * Parallelism level for parallel sorting.\n+     *\/\n+    private static final int PARALLEL = 88;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":54,"deletions":31,"binary":false,"changes":85,"status":"modified"}]}