{"files":[{"patch":"@@ -68,1 +68,2 @@\n-  G1ThreadLocalData::satb_mark_queue(Thread::current()).enqueue(pre_val);\n+  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(Thread::current());\n+  G1BarrierSet::satb_mark_queue_set().enqueue(queue, pre_val);\n@@ -102,1 +103,2 @@\n-    G1ThreadLocalData::dirty_card_queue(thr).enqueue(byte);\n+    G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thr);\n+    G1BarrierSet::dirty_card_queue_set().enqueue(queue, byte);\n@@ -119,0 +121,1 @@\n+    G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n@@ -125,1 +128,1 @@\n-        queue.enqueue(byte);\n+        qset.enqueue(queue, byte);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-  G1ThreadLocalData::satb_mark_queue(thread).enqueue(orig);\n+  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(thread);\n+  G1BarrierSet::satb_mark_queue_set().enqueue(queue, orig);\n@@ -59,2 +60,4 @@\n-JRT_LEAF(void, G1BarrierSetRuntime::write_ref_field_post_entry(void* card_addr, JavaThread* thread))\n-  G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);\n+JRT_LEAF(void, G1BarrierSetRuntime::write_ref_field_post_entry(volatile G1CardTable::CardValue* card_addr,\n+                                                               JavaThread* thread))\n+  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thread);\n+  G1BarrierSet::dirty_card_queue_set().enqueue(queue, card_addr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"gc\/g1\/g1CardTable.hpp\"\n+#include \"memory\/allStatic.hpp\"\n@@ -38,0 +39,2 @@\n+  using CardValue = G1CardTable::CardValue;\n+\n@@ -45,1 +48,1 @@\n-  static void write_ref_field_post_entry(void* card_addr, JavaThread* thread);\n+  static void write_ref_field_post_entry(volatile CardValue* card_addr, JavaThread* thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1BarrierSet.inline.hpp\"\n@@ -74,8 +75,0 @@\n-void G1DirtyCardQueue::handle_completed_buffer() {\n-  assert(!is_empty(), \"precondition\");\n-  _refinement_stats->inc_dirtied_cards(size());\n-  BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());\n-  allocate_buffer();\n-  dirty_card_qset()->handle_completed_buffer(node, _refinement_stats);\n-}\n-\n@@ -109,0 +102,19 @@\n+void G1DirtyCardQueueSet::enqueue(G1DirtyCardQueue& queue,\n+                                  volatile CardValue* card_ptr) {\n+  CardValue* value = const_cast<CardValue*>(card_ptr);\n+  if (!try_enqueue(queue, value)) {\n+    handle_zero_index(queue);\n+    retry_enqueue(queue, value);\n+  }\n+}\n+\n+void G1DirtyCardQueueSet::handle_zero_index(G1DirtyCardQueue& queue) {\n+  assert(queue.index() == 0, \"precondition\");\n+  BufferNode* old_node = exchange_buffer_with_new(queue);\n+  if (old_node != nullptr) {\n+    G1ConcurrentRefineStats* stats = queue.refinement_stats();\n+    stats->inc_dirtied_cards(buffer_size());\n+    handle_completed_buffer(old_node, stats);\n+  }\n+}\n+\n@@ -110,1 +122,2 @@\n-  G1ThreadLocalData::dirty_card_queue(t).handle_zero_index();\n+  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n+  G1BarrierSet::dirty_card_queue_set().handle_zero_index(queue);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardTable.hpp\"\n@@ -44,3 +45,0 @@\n-protected:\n-  virtual void handle_completed_buffer();\n-\n@@ -266,0 +264,13 @@\n+  \/\/ Called when queue is full or has no buffer.\n+  void handle_zero_index(G1DirtyCardQueue& queue);\n+\n+  \/\/ Enqueue the buffer, and optionally perform refinement by the mutator.\n+  \/\/ Mutator refinement is only done by Java threads, and only if there\n+  \/\/ are more than max_cards (possibly padded) cards in the completed\n+  \/\/ buffers.  Updates stats.\n+  \/\/\n+  \/\/ Mutator refinement, if performed, stops processing a buffer if\n+  \/\/ SuspendibleThreadSet::should_yield(), recording the incompletely\n+  \/\/ processed buffer for later processing of the remainder.\n+  void handle_completed_buffer(BufferNode* node, G1ConcurrentRefineStats* stats);\n+\n@@ -305,10 +316,2 @@\n-  \/\/ Helper for G1DirtyCardQueue::handle_completed_buffer().\n-  \/\/ Enqueue the buffer, and optionally perform refinement by the mutator.\n-  \/\/ Mutator refinement is only done by Java threads, and only if there\n-  \/\/ are more than max_cards (possibly padded) cards in the completed\n-  \/\/ buffers.  Updates stats.\n-  \/\/\n-  \/\/ Mutator refinement, if performed, stops processing a buffer if\n-  \/\/ SuspendibleThreadSet::should_yield(), recording the incompletely\n-  \/\/ processed buffer for later processing of the remainder.\n-  void handle_completed_buffer(BufferNode* node, G1ConcurrentRefineStats* stats);\n+  using CardValue = G1CardTable::CardValue;\n+  void enqueue(G1DirtyCardQueue& queue, volatile CardValue* card_ptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  G1RedirtyCardsLocalQueueSet* _rdc_local_qset;\n@@ -51,2 +52,7 @@\n-  UpdateLogBuffersDeferred(G1RedirtyCardsQueue* rdcq) :\n-    _g1h(G1CollectedHeap::heap()), _rdcq(rdcq), _ct(_g1h->card_table()), _last_enqueued_card(SIZE_MAX) {}\n+  UpdateLogBuffersDeferred(G1RedirtyCardsLocalQueueSet* rdc_local_qset,\n+                           G1RedirtyCardsQueue* rdcq) :\n+    _g1h(G1CollectedHeap::heap()),\n+    _rdc_local_qset(rdc_local_qset),\n+    _rdcq(rdcq),\n+    _ct(_g1h->card_table()),\n+    _last_enqueued_card(SIZE_MAX) {}\n@@ -70,1 +76,1 @@\n-      _rdcq->enqueue(_ct->byte_for_index(card_index));\n+      _rdc_local_qset->enqueue(*_rdcq, _ct->byte_for_index(card_index));\n@@ -212,1 +218,1 @@\n-    _log_buffer_cl(&_rdcq) {\n+    _log_buffer_cl(&_rdc_local_qset, &_rdcq) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-  G1RedirtyCardsQueue& redirty_cards_queue()     { return _rdcq; }\n-  G1CardTable* ct()                              { return _ct; }\n+  G1CardTable* ct() { return _ct; }\n@@ -152,1 +151,1 @@\n-      redirty_cards_queue().enqueue(ct()->byte_for_index(card_index));\n+      _rdc_local_qset.enqueue(_rdcq, ct()->byte_for_index(card_index));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/\/ G1RedirtyCardsQueueBase::LocalQSet\n+\/\/ G1RedirtyCardsLocalQueueSet\n@@ -56,0 +56,10 @@\n+void G1RedirtyCardsLocalQueueSet::enqueue(G1RedirtyCardsQueue& queue, void* value) {\n+  if (!try_enqueue(queue, value)) {\n+    BufferNode* old_node = exchange_buffer_with_new(queue);\n+    if (old_node != nullptr) {\n+      enqueue_completed_buffer(old_node);\n+    }\n+    retry_enqueue(queue, value);\n+  }\n+}\n+\n@@ -73,4 +83,0 @@\n-void G1RedirtyCardsQueue::handle_completed_buffer() {\n-  enqueue_completed_buffer();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class G1RedirtyCardsQueue;\n@@ -45,0 +46,2 @@\n+  void enqueue(G1RedirtyCardsQueue& queue, void* value);\n+\n@@ -54,3 +57,0 @@\n-protected:\n-  virtual void handle_completed_buffer();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1BarrierSet.inline.hpp\"\n@@ -40,1 +41,2 @@\n-  G1ThreadLocalData::satb_mark_queue(t).handle_zero_index();\n+  G1SATBMarkQueueSet& qset = G1BarrierSet::satb_mark_queue_set();\n+  qset.handle_zero_index(qset.satb_queue_for_thread(t));\n@@ -43,1 +45,1 @@\n-SATBMarkQueue& G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const{\n+SATBMarkQueue& G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const {\n@@ -116,1 +118,1 @@\n-void G1SATBMarkQueueSet::filter(SATBMarkQueue* queue) {\n+void G1SATBMarkQueueSet::filter(SATBMarkQueue& queue) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  virtual void filter(SATBMarkQueue* queue);\n+  virtual void filter(SATBMarkQueue& queue);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,22 +64,0 @@\n-void PtrQueue::enqueue_known_active(void* ptr) {\n-  while (_index == 0) {\n-    handle_zero_index();\n-  }\n-\n-  assert(_buf != NULL, \"postcondition\");\n-  assert(index() > 0, \"postcondition\");\n-  assert(index() <= capacity(), \"invariant\");\n-  _index -= _element_size;\n-  _buf[index()] = ptr;\n-}\n-\n-void PtrQueue::handle_zero_index() {\n-  assert(index() == 0, \"precondition\");\n-\n-  if (_buf != NULL) {\n-    handle_completed_buffer();\n-  } else {\n-    allocate_buffer();\n-  }\n-}\n-\n@@ -252,0 +230,33 @@\n+bool PtrQueueSet::try_enqueue(PtrQueue& queue, void* value) {\n+  size_t index = queue.index();\n+  if (index == 0) return false;\n+  void** buffer = queue.buffer();\n+  assert(buffer != nullptr, \"no buffer but non-zero index\");\n+  buffer[--index] = value;\n+  queue.set_index(index);\n+  return true;\n+}\n+\n+void PtrQueueSet::retry_enqueue(PtrQueue& queue, void* value) {\n+  assert(queue.index() != 0, \"precondition\");\n+  assert(queue.buffer() != nullptr, \"precondition\");\n+  size_t index = queue.index();\n+  queue.buffer()[--index] = value;\n+  queue.set_index(index);\n+}\n+\n+BufferNode* PtrQueueSet::exchange_buffer_with_new(PtrQueue& queue) {\n+  BufferNode* node = nullptr;\n+  void** buffer = queue.buffer();\n+  if (buffer != nullptr) {\n+    node = BufferNode::make_node_from_buffer(buffer, queue.index());\n+  }\n+  install_new_buffer(queue);\n+  return node;\n+}\n+\n+void PtrQueueSet::install_new_buffer(PtrQueue& queue) {\n+  queue.set_buffer(allocate_buffer());\n+  queue.set_index(buffer_size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-class Mutex;\n-class Monitor;\n-\n@@ -86,14 +83,0 @@\n-  size_t index() const {\n-    return byte_index_to_index(_index);\n-  }\n-\n-  void set_index(size_t new_index) {\n-    size_t byte_index = index_to_byte_index(new_index);\n-    assert(byte_index <= capacity_in_bytes(), \"precondition\");\n-    _index = byte_index;\n-  }\n-\n-  size_t capacity() const {\n-    return byte_index_to_index(capacity_in_bytes());\n-  }\n-\n@@ -105,4 +88,0 @@\n-  \/\/ Process (some of) the buffer and leave it in place for further use,\n-  \/\/ or enqueue the buffer and allocate a new one.\n-  virtual void handle_completed_buffer() = 0;\n-\n@@ -123,5 +102,5 @@\n-  \/\/ Forcibly set empty.\n-  void reset() {\n-    if (_buf != NULL) {\n-      _index = capacity_in_bytes();\n-    }\n+  void** buffer() const { return _buf; }\n+  void set_buffer(void** buffer) { _buf = buffer; }\n+\n+  size_t index_in_bytes() const {\n+    return _index;\n@@ -130,2 +109,4 @@\n-  void enqueue(volatile void* ptr) {\n-    enqueue((void*)(ptr));\n+  void set_index_in_bytes(size_t new_index) {\n+    assert(is_aligned(new_index, _element_size), \"precondition\");\n+    assert(new_index <= capacity_in_bytes(), \"precondition\");\n+    _index = new_index;\n@@ -134,4 +115,2 @@\n-  \/\/ Enqueues the given \"obj\".\n-  void enqueue(void* ptr) {\n-    if (!_active) return;\n-    else enqueue_known_active(ptr);\n+  size_t index() const {\n+    return byte_index_to_index(index_in_bytes());\n@@ -140,1 +119,3 @@\n-  void handle_zero_index();\n+  void set_index(size_t new_index) {\n+    set_index_in_bytes(index_to_byte_index(new_index));\n+  }\n@@ -142,1 +123,10 @@\n-  void enqueue_known_active(void* ptr);\n+  size_t capacity() const {\n+    return byte_index_to_index(capacity_in_bytes());\n+  }\n+\n+  \/\/ Forcibly set empty.\n+  void reset() {\n+    if (_buf != NULL) {\n+      _index = capacity_in_bytes();\n+    }\n+  }\n@@ -309,0 +299,15 @@\n+  \/\/ Add value to queue's buffer, returning true.  If buffer is full\n+  \/\/ or if queue doesn't have a buffer, does nothing and returns false.\n+  bool try_enqueue(PtrQueue& queue, void* value);\n+\n+  \/\/ Add value to queue's buffer.  The queue must have a non-full buffer.\n+  \/\/ Used after an initial try_enqueue has failed and the situation resolved.\n+  void retry_enqueue(PtrQueue& queue, void* value);\n+\n+  \/\/ Installs a new buffer into queue.\n+  \/\/ Returns the old buffer, or null if queue didn't have a buffer.\n+  BufferNode* exchange_buffer_with_new(PtrQueue& queue);\n+\n+  \/\/ Installs a new buffer into queue.\n+  void install_new_buffer(PtrQueue& queue);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":39,"deletions":34,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,26 +57,0 @@\n-\/\/ This method will first apply filtering to the buffer. If filtering\n-\/\/ retains a small enough collection in the buffer, we can continue to\n-\/\/ use the buffer as-is, instead of enqueueing and replacing it.\n-\n-void SATBMarkQueue::handle_completed_buffer() {\n-  \/\/ This method should only be called if there is a non-NULL buffer\n-  \/\/ that is full.\n-  assert(index() == 0, \"pre-condition\");\n-  assert(_buf != NULL, \"pre-condition\");\n-\n-  filter();\n-\n-  size_t threshold = satb_qset()->buffer_enqueue_threshold();\n-  \/\/ Ensure we'll enqueue completely full buffers.\n-  assert(threshold > 0, \"enqueue threshold = 0\");\n-  \/\/ Ensure we won't enqueue empty buffers.\n-  assert(threshold <= capacity(),\n-         \"enqueue threshold \" SIZE_FORMAT \" exceeds capacity \" SIZE_FORMAT,\n-         threshold, capacity());\n-\n-  if (index() < threshold) {\n-    \/\/ Buffer is sufficiently full; enqueue and allocate a new one.\n-    enqueue_completed_buffer();\n-  } \/\/ Else continue to accumulate in buffer.\n-}\n-\n@@ -257,0 +231,35 @@\n+void SATBMarkQueueSet::enqueue_known_active(SATBMarkQueue& queue, oop obj) {\n+  assert(queue.is_active(), \"precondition\");\n+  void* value = cast_from_oop<void*>(obj);\n+  if (!try_enqueue(queue, value)) {\n+    handle_zero_index(queue);\n+    retry_enqueue(queue, value);\n+  }\n+}\n+\n+void SATBMarkQueueSet::handle_zero_index(SATBMarkQueue& queue) {\n+  assert(queue.index() == 0, \"precondition\");\n+  if (queue.buffer() == nullptr) {\n+    install_new_buffer(queue);\n+  } else {\n+    filter(queue);\n+    if (should_enqueue_buffer(queue)) {\n+      enqueue_completed_buffer(exchange_buffer_with_new(queue));\n+    } \/\/ Else continue to use the existing buffer.\n+  }\n+  assert(queue.buffer() != nullptr, \"post condition\");\n+  assert(queue.index() > 0, \"post condition\");\n+}\n+\n+bool SATBMarkQueueSet::should_enqueue_buffer(SATBMarkQueue& queue) {\n+  \/\/ Keep the current buffer if filtered index >= threshold.\n+  size_t threshold = buffer_enqueue_threshold();\n+  \/\/ Ensure we'll enqueue completely full buffers.\n+  assert(threshold > 0, \"enqueue threshold = 0\");\n+  \/\/ Ensure we won't enqueue empty buffers.\n+  assert(threshold <= buffer_size(),\n+         \"enqueue threshold %zu exceeds capacity %zu\",\n+         threshold, buffer_size());\n+  return queue.index() < threshold;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":36,"deletions":27,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -54,7 +55,0 @@\n-  \/\/ Removes entries from the buffer that are no longer needed.\n-  template<typename Filter>\n-  inline void apply_filter(Filter filter_out);\n-\n-protected:\n-  virtual void handle_completed_buffer();\n-\n@@ -118,0 +112,6 @@\n+  void handle_zero_index(SATBMarkQueue& queue);\n+\n+  \/\/ Return true if the queue's buffer should be enqueued, even if not full.\n+  \/\/ The default method uses the buffer enqueue threshold.\n+  virtual bool should_enqueue_buffer(SATBMarkQueue& queue);\n+\n@@ -119,3 +119,1 @@\n-  void apply_filter(Filter filter, SATBMarkQueue* queue) {\n-    queue->apply_filter(filter);\n-  }\n+  void apply_filter(Filter filter, SATBMarkQueue& queue);\n@@ -137,2 +135,0 @@\n-  virtual void filter(SATBMarkQueue* queue) = 0;\n-\n@@ -145,0 +141,5 @@\n+  void enqueue(SATBMarkQueue& queue, oop obj) {\n+    if (queue.is_active()) enqueue_known_active(queue, obj);\n+  }\n+  void enqueue_known_active(SATBMarkQueue& queue, oop obj);\n+  virtual void filter(SATBMarkQueue& queue) = 0;\n@@ -172,1 +173,1 @@\n-  satb_qset()->filter(this);\n+  satb_qset()->filter(*this);\n@@ -175,2 +176,2 @@\n-\/\/ Removes entries from the buffer that are no longer needed, as\n-\/\/ determined by filter. If e is a void* entry in the buffer,\n+\/\/ Removes entries from queue's buffer that are no longer needed, as\n+\/\/ determined by filter. If e is a void* entry in queue's buffer,\n@@ -181,2 +182,2 @@\n-inline void SATBMarkQueue::apply_filter(Filter filter_out) {\n-  void** buf = this->_buf;\n+inline void SATBMarkQueueSet::apply_filter(Filter filter_out, SATBMarkQueue& queue) {\n+  void** buf = queue.buffer();\n@@ -190,2 +191,2 @@\n-  void** src = &buf[this->index()];\n-  void** dst = &buf[this->capacity()];\n+  void** src = &buf[queue.index()];\n+  void** dst = &buf[buffer_size()];\n@@ -209,1 +210,1 @@\n-  this->set_index(dst - buf);\n+  queue.set_index(dst - buf);\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -145,1 +145,2 @@\n-  ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);\n+  SATBMarkQueue& queue = ShenandoahThreadLocalData::satb_mark_queue(Thread::current());\n+  _satb_mark_queue_set.enqueue_known_active(queue, obj);\n@@ -352,1 +353,1 @@\n-        queue.enqueue_known_active(obj);\n+        _satb_mark_queue_set.enqueue_known_active(queue, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-  ShenandoahThreadLocalData::satb_mark_queue(thread).enqueue_known_active(orig);\n+  SATBMarkQueue& queue = ShenandoahThreadLocalData::satb_mark_queue(thread);\n+  ShenandoahBarrierSet::satb_mark_queue_set().enqueue_known_active(queue, orig);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-void ShenandoahSATBMarkQueueSet::filter(SATBMarkQueue* queue) {\n+void ShenandoahSATBMarkQueueSet::filter(SATBMarkQueue& queue) {\n@@ -57,3 +57,4 @@\n-void ShenandoahSATBMarkQueue::handle_completed_buffer() {\n-  SATBMarkQueue::handle_completed_buffer();\n-  if (!is_empty()) {\n+bool ShenandoahSATBMarkQueueSet::should_enqueue_buffer(SATBMarkQueue& queue) {\n+  if (SATBMarkQueueSet::should_enqueue_buffer(queue)) {\n+    return true;\n+  } else if (queue.index() < buffer_size()) { \/\/ Is buffer not empty?\n@@ -67,1 +68,1 @@\n-      enqueue_completed_buffer();\n+      return true;\n@@ -70,0 +71,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ShenandoahSATBMarkQueue: public SATBMarkQueue {\n+class ShenandoahSATBMarkQueueSet : public SATBMarkQueueSet {\n@@ -35,4 +35,1 @@\n-  virtual void handle_completed_buffer();\n-public:\n-  ShenandoahSATBMarkQueue(SATBMarkQueueSet* qset) : SATBMarkQueue(qset) {}\n-};\n+  virtual bool should_enqueue_buffer(SATBMarkQueue& queue);\n@@ -40,1 +37,0 @@\n-class ShenandoahSATBMarkQueueSet : public SATBMarkQueueSet {\n@@ -45,1 +41,1 @@\n-  virtual void filter(SATBMarkQueue* queue);\n+  virtual void filter(SATBMarkQueue& queue);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  ShenandoahSATBMarkQueue _satb_mark_queue;\n+  SATBMarkQueue           _satb_mark_queue;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n@@ -485,3 +485,3 @@\n-JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))\n-  G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);\n-JRT_END\n+void JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj) {\n+  G1BarrierSetRuntime::write_ref_field_pre_entry(obj, thread);\n+}\n@@ -489,3 +489,3 @@\n-JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))\n-  G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);\n-JRT_END\n+void JVMCIRuntime::write_barrier_post(JavaThread* thread, volatile CardValue* card_addr) {\n+  G1BarrierSetRuntime::write_ref_field_post_entry(card_addr, thread);\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+#if INCLUDE_G1GC\n+#include \"gc\/g1\/g1CardTable.hpp\"\n+#endif \/\/ INCLUDE_G1GC\n@@ -399,0 +402,1 @@\n+  using CardValue = G1CardTable::CardValue;\n@@ -400,1 +404,1 @@\n-  static void write_barrier_post(JavaThread* thread, void* card);\n+  static void write_barrier_post(JavaThread* thread, volatile CardValue* card);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}