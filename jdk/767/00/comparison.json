{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import sun.invoke.util.VerifyAccess;\n@@ -69,1 +70,0 @@\n-    private static final String DESCR_SET_IMPL_METHOD = \"(Ljava\/lang\/invoke\/MethodHandle;)V\";\n@@ -172,2 +172,2 @@\n-        useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())\n-                                && !Modifier.isPublic(implInfo.getModifiers());\n+        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n+                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8227415\n- * @run main p.SuperMethodTest\n+ * @bug 8227415 8254975\n+ * @run testng\/othervm p.SuperMethodTest\n@@ -29,2 +29,2 @@\n- *          superclass in a different package must be accessed via\n- *          a bridge method.  Lambda proxy class has no access to it.\n+ *          superclass in a different runtime package where\n+ *          lambda proxy class has no access to it.\n@@ -38,0 +38,8 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n@@ -42,0 +50,3 @@\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n@@ -43,1 +54,2 @@\n-    public static void main(String... args) {\n+    @Test\n+    public static void remotePackageSameLoader() {\n@@ -65,0 +77,64 @@\n+\n+    @Test\n+    public static void splitPackage() throws Throwable {\n+        ClassLoader parent = new Loader(\"loader-A\", null, A.class);\n+        ClassLoader loader = new Loader(\"loader-B\", parent, B.class);\n+        Class<?> aClass = Class.forName(A.class.getName(), false, loader);\n+        Class<?> bClass = Class.forName(B.class.getName(), false, loader);\n+        assertTrue(aClass.getClassLoader() == parent);\n+        assertTrue(bClass.getClassLoader() == loader);\n+        assertEquals(aClass.getPackageName(), bClass.getPackageName());\n+\n+        Object b = bClass.getDeclaredConstructor().newInstance();\n+\n+        \/\/ verify subclass can access a protected member inherited from\n+        \/\/ its superclass in a split package\n+        MethodHandle test = MethodHandles.lookup()\n+                .findVirtual(bClass, \"test\", MethodType.methodType(void.class));\n+        test.invoke(b);\n+\n+        \/\/ verify lambda can access a protected member inherited from\n+        \/\/ a superclass of the host class where the superclass is in\n+        \/\/ a split package (not the same runtime package as the host class)\n+        MethodHandle get = MethodHandles.lookup()\n+                .findVirtual(bClass, \"get\", MethodType.methodType(Runnable.class));\n+        ((Runnable) get.invoke(b)).run();\n+    }\n+\n+    static class Loader extends URLClassLoader {\n+        static final Path CLASSES_DIR = Paths.get(System.getProperty(\"test.class.path\"));\n+        private final Class<?> c;\n+        Loader(String name, ClassLoader parent, Class<?> c) {\n+            super(name, new URL[]{}, parent);\n+            this.c = c;\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.equals(c.getName())) {\n+                try {\n+                    String path = name.replace('.', '\/') + \".class\";\n+                    byte[] bytes = Files.readAllBytes(CLASSES_DIR.resolve(path));\n+                    return defineClass(name, bytes, 0, bytes.length);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+\n+            return super.findClass(name);\n+        }\n+\n+    }\n+\n+    public static class A {\n+        protected void func() { }\n+    }\n+\n+    public static class B extends A {\n+        public Runnable get() {\n+            return this::func;\n+        }\n+        public void test() {\n+            func();\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/superProtectedMethod\/SuperMethodTest.java","additions":82,"deletions":6,"binary":false,"changes":88,"status":"modified"}]}