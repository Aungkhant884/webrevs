{"files":[{"patch":"@@ -170,19 +170,21 @@\n-\/\/ annotation processing support\n-\n-enum {  \/\/ initial annotation layout\n-  atype_off = 0,      \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n-  count_off = 2,      \/\/ u2   such as 1 (one value)\n-  member_off = 4,     \/\/ utf8 such as 'value'\n-  tag_off = 6,        \/\/ u1   such as 'c' (type) or 'e' (enum)\n-  e_tag_val = 'e',\n-  e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n-  e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n-  e_size = 11,     \/\/ end of 'e' annotation\n-  c_tag_val = 'c',    \/\/ payload is type\n-  c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n-  c_size = 9,       \/\/ end of 'c' annotation\n-  s_tag_val = 's',    \/\/ payload is String\n-  s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n-  s_size = 9,\n-  min_size = 6        \/\/ smallest possible size (zero members)\n-};\n+\/*\n+  Annotation layout.\n+\n+  enum {  \/\/ initial annotation layout\n+    atype_off = 0,      \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n+    count_off = 2,      \/\/ u2   such as 1 (one value)\n+    member_off = 4,     \/\/ utf8 such as 'value'\n+    tag_off = 6,        \/\/ u1   such as 'c' (type) or 'e' (enum)\n+    e_tag_val = 'e',\n+    e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n+    e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n+    e_size = 11,     \/\/ end of 'e' annotation\n+    c_tag_val = 'c',    \/\/ payload is type\n+    c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n+    c_size = 9,       \/\/ end of 'c' annotation\n+    s_tag_val = 's',    \/\/ payload is String\n+    s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n+    s_size = 9,\n+    min_size = 6        \/\/ smallest possible size (zero members)\n+  };\n+*\/\n@@ -199,1 +201,1 @@\n-  int nof_members = JfrBigEndian::read<u2>(buffer + index - 2);\n+  int nof_members = JfrBigEndian::read<int, u2>(buffer + index - 2);\n@@ -243,1 +245,1 @@\n-        int nof_values = JfrBigEndian::read<u2>(buffer + index - 2);\n+        int nof_values = JfrBigEndian::read<int, u2>(buffer + index - 2);\n@@ -258,5 +260,5 @@\n-static const u2 number_of_elements_offset = (u2)2;\n-static const u2 element_name_offset = (u2)(number_of_elements_offset + 2);\n-static const u2 element_name_size = (u2)2;\n-static const u2 value_type_relative_offset = (u2)2;\n-static const u2 value_relative_offset = (u2)(value_type_relative_offset + 1);\n+static constexpr const int number_of_elements_offset = 2;\n+static constexpr const int element_name_offset = number_of_elements_offset + 2;\n+static constexpr const int element_name_size = 2;\n+static constexpr const int value_type_relative_offset = 2;\n+static constexpr const int value_relative_offset = value_type_relative_offset + 1;\n@@ -270,5 +272,6 @@\n-  const u2 _limit; \/\/ length of annotation\n-  mutable u2 _current; \/\/ element\n-  mutable u2 _next; \/\/ element\n-  u2 value_index() const {\n-    return JfrBigEndian::read<u2>(_buffer + _current + value_relative_offset);\n+  const int _limit; \/\/ length of annotation\n+  mutable int _current; \/\/ element\n+  mutable int _next; \/\/ element\n+\n+  int value_index() const {\n+    return JfrBigEndian::read<int, u2>(_buffer + _current + value_relative_offset);\n@@ -278,5 +281,5 @@\n-  AnnotationElementIterator(const InstanceKlass* ik, address buffer, u2 limit) : _ik(ik),\n-                                                                                 _buffer(buffer),\n-                                                                                 _limit(limit),\n-                                                                                 _current(element_name_offset),\n-                                                                                 _next(element_name_offset) {\n+  AnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit) : _ik(ik),\n+                                                                                  _buffer(buffer),\n+                                                                                  _limit(limit),\n+                                                                                  _current(element_name_offset),\n+                                                                                  _next(element_name_offset) {\n@@ -302,2 +305,2 @@\n-  u2 number_of_elements() const {\n-    return JfrBigEndian::read<u2>(_buffer + number_of_elements_offset);\n+  int number_of_elements() const {\n+    return JfrBigEndian::read<int, u2>(_buffer + number_of_elements_offset);\n@@ -308,1 +311,1 @@\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<u2>(_buffer + _current));\n+    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n@@ -312,1 +315,1 @@\n-    return JfrBigEndian::read<u1>(_buffer + _current + value_type_relative_offset);\n+    return JfrBigEndian::read<char, u1>(_buffer + _current + value_type_relative_offset);\n@@ -328,1 +331,1 @@\n-  u2 _limit; \/\/ length of annotations array\n+  int _limit; \/\/ length of annotations array\n@@ -330,2 +333,2 @@\n-  mutable u2 _current; \/\/ annotation\n-  mutable u2 _next; \/\/ annotation\n+  mutable int _current; \/\/ annotation\n+  mutable int _next; \/\/ annotation\n@@ -356,0 +359,1 @@\n+\n@@ -360,0 +364,1 @@\n+\n@@ -363,1 +368,1 @@\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<u2>(_buffer + _current));\n+    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n@@ -479,1 +484,1 @@\n-  for (u2 index = 1; index < cp_len; ++index) {\n+  for (int index = 1; index < cp_len; ++index) {\n@@ -485,1 +490,1 @@\n-        return index;\n+        return checked_cast<u2>(index);\n@@ -683,1 +688,1 @@\n-        u2 utf8_length = stream->get_u2_fast();\n+        int utf8_length = checked_cast<int>(stream->get_u2_fast());\n@@ -728,2 +733,1 @@\n-      const u4 attrib_len = stream->get_u4_fast();\n-      stream->skip_u1_fast(attrib_len);\n+      stream->skip_u1_fast(checked_cast<int>(stream->get_u4_fast()));\n@@ -757,1 +761,1 @@\n-  orig_method_len_offset += sizeof(u2);\n+  orig_method_len_offset += 2;\n@@ -766,2 +770,1 @@\n-      const u4 attrib_len = stream->get_u4_fast();\n-      stream->skip_u1_fast(attrib_len);\n+      stream->skip_u1_fast(checked_cast<int>(stream->get_u4_fast()));\n@@ -856,1 +859,1 @@\n-enum StackMapFrameTypes {\n+enum StackMapFrameTypes : u1 {\n@@ -898,1 +901,2 @@\n-    writer.write<u2>((frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN) + bci_adjustment_offset);\n+    const u2 value = frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_BEGIN;\n+    writer.write<u2>(value + bci_adjustment_offset);\n@@ -912,1 +916,1 @@\n-  u4 stack_map_attrib_len = writer.current_offset() - stack_map_attrib_len_offset;\n+  u4 stack_map_attrib_len = checked_cast<u4>(writer.current_offset() - stack_map_attrib_len_offset);\n@@ -914,1 +918,1 @@\n-  stack_map_attrib_len -= sizeof(u4);\n+  stack_map_attrib_len -= 4;\n@@ -941,1 +945,1 @@\n-  u4 lnt_table_attributes_len = writer.current_offset() - lnt_attributes_length_offset;\n+  u4 lnt_table_attributes_len = checked_cast<u4>(writer.current_offset() - lnt_attributes_length_offset);\n@@ -943,1 +947,1 @@\n-  lnt_table_attributes_len -= sizeof(u4);\n+  lnt_table_attributes_len -= 4;\n@@ -974,1 +978,1 @@\n-  u4 lvt_table_attributes_len = writer.current_offset() - lvt_attributes_length_offset;\n+  u4 lvt_table_attributes_len = checked_cast<u4>(writer.current_offset() - lvt_attributes_length_offset);\n@@ -976,1 +980,1 @@\n-  lvt_table_attributes_len -= sizeof(u4);\n+  lvt_table_attributes_len -= 4;\n@@ -1004,1 +1008,1 @@\n-  u4 lvtt_table_attributes_len = writer.current_offset() - lvtt_attributes_length_offset;\n+  u4 lvtt_table_attributes_len = checked_cast<u4>(writer.current_offset() - lvtt_attributes_length_offset);\n@@ -1006,1 +1010,1 @@\n-  lvtt_table_attributes_len -= sizeof(u4);\n+  lvtt_table_attributes_len -= 4;\n@@ -1064,2 +1068,2 @@\n-  const u2 max_stack = MAX2(clinit_method != nullptr ? clinit_method->verifier_max_stack() : 1, 1);\n-  const u2 max_locals = MAX2(clinit_method != nullptr ? clinit_method->max_locals() : 0, 0);\n+  const u2 max_stack = MAX2<u2>(clinit_method != nullptr ? clinit_method->verifier_max_stack() : 1, 1);\n+  const u2 max_locals = MAX2<u2>(clinit_method != nullptr ? clinit_method->max_locals() : 0, 0);\n@@ -1114,1 +1118,1 @@\n-  u4 code_attribute_len = writer.current_offset() - code_attribute_length_offset;\n+  u4 code_attribute_len = checked_cast<u4>(writer.current_offset() - code_attribute_length_offset);\n@@ -1116,1 +1120,1 @@\n-  code_attribute_len -= sizeof(u4);\n+  code_attribute_len -= 4;\n@@ -1215,1 +1219,1 @@\n-  const int utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);\n+  const u2 utf8_orig_idx = utf8_info_index(ik, utf8_sym, THREAD);\n@@ -1322,1 +1326,1 @@\n-      \" bytes failed in JfrEventClassTransformer::on_klass_creation\", static_cast<size_t>(new_buffer_size));\n+      \" bytes failed in JfrEventClassTransformer::on_klass_creation\", checked_cast<size_t>(new_buffer_size));\n@@ -1408,0 +1412,3 @@\n+    if (clinit_method == nullptr) {\n+      ++number_of_new_methods;\n+    }\n@@ -1409,1 +1416,0 @@\n-  number_of_new_methods += clinit_method != nullptr ? 0 : register_klass ? 1 : 0;\n@@ -1486,1 +1492,1 @@\n-    const jclass super = static_cast<jclass>(JfrJavaSupport::local_jni_handle(ik->super()->java_mirror(), THREAD));\n+    const jclass super = checked_cast<jclass>(JfrJavaSupport::local_jni_handle(ik->super()->java_mirror(), THREAD));\n@@ -1529,1 +1535,1 @@\n-  const jclass clazz = static_cast<jclass>(JfrJavaSupport::local_jni_handle(existing_klass->java_mirror(), THREAD));\n+  const jclass clazz = checked_cast<jclass>(JfrJavaSupport::local_jni_handle(existing_klass->java_mirror(), THREAD));\n@@ -1561,1 +1567,1 @@\n-      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n+      checked_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":78,"deletions":72,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  traceid _stack_trace_id;\n@@ -56,1 +55,2 @@\n-  int _index;\n+  traceid _stack_trace_id;\n+  traceid _stack_trace_hash;\n@@ -60,1 +60,1 @@\n-  unsigned int _stack_trace_hash;\n+  int _index;\n@@ -78,1 +78,0 @@\n-                   _stack_trace_id(0),\n@@ -80,1 +79,2 @@\n-                   _index(0),\n+                   _stack_trace_id(0),\n+                   _stack_trace_hash(0),\n@@ -84,1 +84,1 @@\n-                   _stack_trace_hash(0),\n+                   _index(0),\n@@ -173,1 +173,1 @@\n-  unsigned int stack_trace_hash() const {\n+  traceid stack_trace_hash() const {\n@@ -177,1 +177,1 @@\n-  void set_stack_trace_hash(unsigned int hash) {\n+  void set_stack_trace_hash(traceid hash) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  const unsigned int stacktrace_hash = tl->cached_stack_trace_hash();\n+  const traceid stacktrace_hash = tl->cached_stack_trace_hash();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-          event.set_origin(static_cast<u8>(flag->get_origin()));  \\\n+          event.set_origin(checked_cast<u8>(flag->get_origin()));  \\\n@@ -419,1 +419,1 @@\n-  event.set_gcTimeRatio(conf.gc_time_ratio());\n+  event.set_gcTimeRatio(checked_cast<unsigned int>(conf.gc_time_ratio()));\n@@ -436,2 +436,2 @@\n-  event.set_maxTenuringThreshold(conf.max_tenuring_threshold());\n-  event.set_initialTenuringThreshold(conf.initial_tenuring_threshold());\n+  event.set_maxTenuringThreshold(checked_cast<u1>(conf.max_tenuring_threshold()));\n+  event.set_initialTenuringThreshold(checked_cast<u1>(conf.initial_tenuring_threshold()));\n@@ -450,1 +450,1 @@\n-  event.set_heapAddressBits(conf.heap_address_size_in_bits());\n+  event.set_heapAddressBits(checked_cast<u1>(conf.heap_address_size_in_bits()));\n@@ -460,1 +460,1 @@\n-  event.set_newRatio(conf.new_ratio());\n+  event.set_newRatio(checked_cast<unsigned int>(conf.new_ratio()));\n@@ -663,1 +663,1 @@\n-  event.set_threadCount(CICompilerCount);\n+  event.set_threadCount(checked_cast<s4>(CICompilerCount));\n@@ -671,2 +671,2 @@\n-  for (int bt_index = 0; bt_index < static_cast<int>(CodeBlobType::NumTypes); ++bt_index) {\n-    const CodeBlobType bt = static_cast<CodeBlobType>(bt_index);\n+  for (int bt_index = 0; bt_index < checked_cast<int>(CodeBlobType::NumTypes); ++bt_index) {\n+    const CodeBlobType bt = checked_cast<CodeBlobType>(bt_index);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  jlong total_available_time = wallclock_time * processor_count;\n+  const float total_available_time = checked_cast<float>(wallclock_time * processor_count);\n@@ -100,2 +100,2 @@\n-  event.set_user(total_available_time > 0 ? (double)user_time \/ total_available_time : 0);\n-  event.set_system(total_available_time > 0 ? (double)system_time \/ total_available_time : 0);\n+  event.set_user(total_available_time > 0 ? checked_cast<float>(user_time) \/ total_available_time : 0);\n+  event.set_system(total_available_time > 0 ? checked_cast<float>(system_time) \/ total_available_time : 0);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-  return JfrBigEndian::read<Return>(data);\n+  return JfrBigEndian::read<Return, Return>(data);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  int parent_thread_group_id = 0;\n+  traceid parent_thread_group_id = 0;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jni.h\"\n@@ -38,1 +37,1 @@\n-  static void store(jbyte bits, const T* ptr);\n+  static void store(uint8_t bits, const T* ptr);\n@@ -41,1 +40,1 @@\n-  static void cas(jbyte bits, const T* ptr);\n+  static void cas(uint8_t bits, const T* ptr);\n@@ -44,1 +43,1 @@\n-  static void meta_store(jbyte bits, const T* ptr);\n+  static void meta_store(uint8_t bits, const T* ptr);\n@@ -47,1 +46,1 @@\n-  static void mask_store(jbyte mask, const T* ptr);\n+  static void mask_store(uint8_t mask, const T* ptr);\n@@ -50,1 +49,1 @@\n-  static void meta_mask_store(jbyte mask, const T* ptr);\n+  static void meta_mask_store(uint8_t mask, const T* ptr);\n@@ -53,1 +52,1 @@\n-  static void clear(jbyte bits, const T* ptr);\n+  static void clear(uint8_t bits, const T* ptr);\n@@ -56,1 +55,1 @@\n-  static void clear_cas(jbyte bits, const T* ptr);\n+  static void clear_cas(uint8_t bits, const T* ptr);\n@@ -59,1 +58,1 @@\n-  static void meta_clear(jbyte bits, const T* ptr);\n+  static void meta_clear(uint8_t bits, const T* ptr);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-inline jbyte* low_addr(jbyte* addr) {\n+inline uint8_t* low_addr(uint8_t* addr) {\n@@ -47,2 +47,2 @@\n-inline jbyte* low_addr(traceid* addr) {\n-  return low_addr((jbyte*)addr);\n+inline uint8_t* low_addr(traceid* addr) {\n+  return low_addr(reinterpret_cast<uint8_t*>(addr));\n@@ -51,1 +51,1 @@\n-inline jbyte* meta_addr(jbyte* addr) {\n+inline uint8_t* meta_addr(uint8_t* addr) {\n@@ -56,2 +56,2 @@\n-inline jbyte* meta_addr(traceid* addr) {\n-  return meta_addr((jbyte*)addr);\n+inline uint8_t* meta_addr(traceid* addr) {\n+  return meta_addr(reinterpret_cast<uint8_t*>(addr));\n@@ -61,1 +61,1 @@\n-inline jbyte* traceid_tag_byte(const T* ptr) {\n+inline uint8_t* traceid_tag_byte(const T* ptr) {\n@@ -67,1 +67,1 @@\n-inline jbyte* traceid_tag_byte<Method>(const Method* ptr) {\n+inline uint8_t* traceid_tag_byte<Method>(const Method* ptr) {\n@@ -73,1 +73,1 @@\n-inline jbyte* traceid_meta_byte(const T* ptr) {\n+inline uint8_t* traceid_meta_byte(const T* ptr) {\n@@ -79,1 +79,1 @@\n-inline jbyte* traceid_meta_byte<Method>(const Method* ptr) {\n+inline uint8_t* traceid_meta_byte<Method>(const Method* ptr) {\n@@ -84,1 +84,1 @@\n-inline jbyte traceid_and(jbyte bits, jbyte current) {\n+inline uint8_t traceid_and(uint8_t bits, uint8_t current) {\n@@ -88,1 +88,1 @@\n-inline jbyte traceid_or(jbyte bits, jbyte current) {\n+inline uint8_t traceid_or(uint8_t bits, uint8_t current) {\n@@ -92,1 +92,1 @@\n-inline jbyte traceid_xor(jbyte bits, jbyte current) {\n+inline uint8_t traceid_xor(uint8_t bits, uint8_t current) {\n@@ -96,2 +96,2 @@\n-template <jbyte op(jbyte, jbyte)>\n-inline void set_form(jbyte bits, jbyte* dest) {\n+template <uint8_t op(uint8_t, uint8_t)>\n+inline void set_form(uint8_t bits, uint8_t* dest) {\n@@ -103,2 +103,2 @@\n-template <jbyte op(jbyte, jbyte)>\n-inline void set_cas_form(jbyte bits, jbyte volatile* dest) {\n+template <uint8_t op(uint8_t, uint8_t)>\n+inline void set_cas_form(uint8_t bits, uint8_t volatile* dest) {\n@@ -107,2 +107,2 @@\n-    const jbyte current = *dest;\n-    const jbyte new_value = op(bits, current);\n+    const uint8_t current = *dest;\n+    const uint8_t new_value = op(bits, current);\n@@ -116,1 +116,1 @@\n-inline void JfrTraceIdBits::cas(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::cas(uint8_t bits, const T* ptr) {\n@@ -127,1 +127,1 @@\n-inline void set(jbyte bits, jbyte* dest) {\n+inline void set(uint8_t bits, uint8_t* dest) {\n@@ -133,1 +133,1 @@\n-inline void JfrTraceIdBits::store(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::store(uint8_t bits, const T* ptr) {\n@@ -147,1 +147,1 @@\n-inline void JfrTraceIdBits::meta_store(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::meta_store(uint8_t bits, const T* ptr) {\n@@ -152,1 +152,1 @@\n-inline void set_mask(jbyte mask, jbyte* dest) {\n+inline void set_mask(uint8_t mask, uint8_t* dest) {\n@@ -157,1 +157,1 @@\n-inline void JfrTraceIdBits::mask_store(jbyte mask, const T* ptr) {\n+inline void JfrTraceIdBits::mask_store(uint8_t mask, const T* ptr) {\n@@ -163,1 +163,1 @@\n-inline void JfrTraceIdBits::meta_mask_store(jbyte mask, const T* ptr) {\n+inline void JfrTraceIdBits::meta_mask_store(uint8_t mask, const T* ptr) {\n@@ -168,1 +168,1 @@\n-inline void clear_bits(jbyte bits, jbyte* dest) {\n+inline void clear_bits(uint8_t bits, uint8_t* dest) {\n@@ -173,1 +173,1 @@\n-inline void JfrTraceIdBits::clear(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::clear(uint8_t bits, const T* ptr) {\n@@ -178,1 +178,1 @@\n-inline void clear_bits_cas(jbyte bits, jbyte* dest) {\n+inline void clear_bits_cas(uint8_t bits, uint8_t* dest) {\n@@ -183,1 +183,1 @@\n-inline void JfrTraceIdBits::clear_cas(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::clear_cas(uint8_t bits, const T* ptr) {\n@@ -189,1 +189,1 @@\n-inline void JfrTraceIdBits::meta_clear(jbyte bits, const T* ptr) {\n+inline void JfrTraceIdBits::meta_clear(uint8_t bits, const T* ptr) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.inline.hpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  static traceid this_epoch_bit() {\n+  static uint8_t this_epoch_bit() {\n@@ -103,1 +103,1 @@\n-  static traceid previous_epoch_bit() {\n+  static uint8_t previous_epoch_bit() {\n@@ -107,1 +107,1 @@\n-  static traceid this_epoch_method_bit() {\n+  static uint8_t this_epoch_method_bit() {\n@@ -111,1 +111,1 @@\n-  static traceid previous_epoch_method_bit() {\n+  static uint8_t previous_epoch_method_bit() {\n@@ -115,1 +115,1 @@\n-  static traceid this_epoch_method_and_class_bits() {\n+  static uint8_t this_epoch_method_and_class_bits() {\n@@ -119,1 +119,1 @@\n-  static traceid previous_epoch_method_and_class_bits() {\n+  static uint8_t previous_epoch_method_and_class_bits() {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-template <typename T>\n-static inline void store_traceid(T* element, traceid id, bool uncompressed) {\n+static inline void store_traceid(JfrEpochQueueKlassElement* element, traceid id) {\n@@ -129,1 +128,9 @@\n-  element->id = uncompressed ? id | UNCOMPRESSED : id;\n+  element->id = id | UNCOMPRESSED;\n+}\n+\n+static inline void store_traceid(JfrEpochQueueNarrowKlassElement* element, traceid id) {\n+  assert(id < uncompressed_threshold, \"invariant\");\n+#ifdef VM_LITTLE_ENDIAN\n+  id <<= METADATA_SHIFT;\n+#endif\n+  element->id = static_cast<u4>(id);\n@@ -135,1 +142,1 @@\n-  store_traceid(element, id, false);\n+  store_traceid(element, id);\n@@ -141,1 +148,1 @@\n-  store_traceid(element, id, true);\n+  store_traceid(element, id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,0 @@\n-#define THIS_EPOCH_METHOD_FLAG_BIT                ((jbyte)THIS_EPOCH_BIT)\n-#define PREVIOUS_EPOCH_METHOD_FLAG_BIT            ((jbyte)PREVIOUS_EPOCH_BIT)\n@@ -105,1 +103,1 @@\n-#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (THIS_EPOCH_METHOD_FLAG_BIT)))\n+#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (THIS_EPOCH_BIT)))\n@@ -107,1 +105,1 @@\n-#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (PREVIOUS_EPOCH_METHOD_FLAG_BIT)))\n+#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (PREVIOUS_EPOCH_BIT)))\n@@ -113,1 +111,1 @@\n-#define SET_METHOD_FLAG_USED_THIS_EPOCH(method)   (METHOD_FLAG_TAG(method, THIS_EPOCH_METHOD_FLAG_BIT))\n+#define SET_METHOD_FLAG_USED_THIS_EPOCH(method)   (METHOD_FLAG_TAG(method, THIS_EPOCH_BIT))\n@@ -116,1 +114,1 @@\n-#define CLEAR_PREVIOUS_EPOCH_METHOD_FLAG(method)  (METHOD_FLAG_CLEAR(method, PREVIOUS_EPOCH_METHOD_FLAG_BIT))\n+#define CLEAR_PREVIOUS_EPOCH_METHOD_FLAG(method)  (METHOD_FLAG_CLEAR(method, PREVIOUS_EPOCH_BIT))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  const u4 checkpoint_size = current_offset() - event_size_offset;\n+  const u4 checkpoint_size = checked_cast<u4>(current_offset() - event_size_offset);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  return lookback_count <= 1 ? 1 : static_cast<double>(1) \/ static_cast<double>(lookback_count);\n+  return lookback_count <= 1 ? 1 : checked_cast<double>(1) \/ checked_cast<double>(lookback_count);\n@@ -250,1 +250,1 @@\n-    *sample_size_ewma = exponentially_weighted_moving_average(expired->sample_size(), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n+    *sample_size_ewma = exponentially_weighted_moving_average(checked_cast<double>(expired->sample_size()), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n@@ -253,1 +253,1 @@\n-      expired->population_size() == 0 ? 0 : (double)expired->sample_size() \/ (double)expired->population_size(),\n+      expired->population_size() == 0 ? 0 : checked_cast<double>(expired->sample_size()) \/ checked_cast<double>(expired->population_size()),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-JfrStackFrame::JfrStackFrame(const traceid& id, int bci, int type, const InstanceKlass* ik) :\n+JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* ik) :\n@@ -52,1 +52,1 @@\n-JfrStackFrame::JfrStackFrame(const traceid& id, int bci, int type, int lineno, const InstanceKlass* ik) :\n+JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* ik) :\n@@ -259,1 +259,1 @@\n-    int type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n+    u1 type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n@@ -310,1 +310,1 @@\n-    int type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n+    u1 type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  JfrStackFrame(const traceid& id, int bci, int type, const InstanceKlass* klass);\n-  JfrStackFrame(const traceid& id, int bci, int type, int lineno, const InstanceKlass* klass);\n+  JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* klass);\n+  JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* klass);\n@@ -55,1 +55,1 @@\n-  enum {\n+  enum : u1 {\n@@ -75,1 +75,1 @@\n-  unsigned int _hash;\n+  traceid _hash;\n@@ -108,1 +108,1 @@\n-  unsigned int hash() const { return _hash; }\n+  traceid hash() const { return _hash; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  const unsigned int hash = stacktrace.hash();\n+  const traceid hash = stacktrace.hash();\n@@ -225,1 +225,1 @@\n-const JfrStackTrace* JfrStackTraceRepository::lookup_for_leak_profiler(unsigned int hash, traceid id) {\n+const JfrStackTrace* JfrStackTraceRepository::lookup_for_leak_profiler(traceid hash, traceid id) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  static const JfrStackTrace* lookup_for_leak_profiler(unsigned int hash, traceid id);\n+  static const JfrStackTrace* lookup_for_leak_profiler(traceid hash, traceid id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  const size_t ordinal = Atomic::add(&_measured_population_size, static_cast<size_t>(1));\n+  const size_t ordinal = Atomic::add(&_measured_population_size, checked_cast<size_t>(1));\n@@ -174,1 +174,1 @@\n-  return lookback_count <= 1 ? 1 : static_cast<double>(1) \/ static_cast<double>(lookback_count);\n+  return lookback_count <= 1 ? 1 : checked_cast<double>(1) \/ checked_cast<double>(lookback_count);\n@@ -200,1 +200,1 @@\n-    Atomic::store(&_end_ticks, static_cast<int64_t>(0));\n+    Atomic::store(&_end_ticks, checked_cast<int64_t>(0));\n@@ -203,1 +203,1 @@\n-  Atomic::store(&_measured_population_size, static_cast<size_t>(0));\n+  Atomic::store(&_measured_population_size, checked_cast<size_t>(0));\n@@ -225,1 +225,1 @@\n-  next->_sampling_interval = derive_sampling_interval(sample_size, expired);\n+  next->_sampling_interval = derive_sampling_interval(checked_cast<double>(sample_size), expired);\n@@ -286,1 +286,1 @@\n-  return _projected_population_size == 0 ? 0 : static_cast<intptr_t>(_params.sample_points_per_window - max_sample_size()) + debt();\n+  return _projected_population_size == 0 ? 0 : checked_cast<intptr_t>(_params.sample_points_per_window - max_sample_size()) + debt();\n@@ -290,1 +290,1 @@\n-  return _projected_population_size == 0 ? 0 : static_cast<intptr_t>(sample_size() - _params.sample_points_per_window);\n+  return _projected_population_size == 0 ? 0 : checked_cast<intptr_t>(sample_size() - _params.sample_points_per_window);\n@@ -313,1 +313,1 @@\n-  return ceil(log(1.0 - u) \/ log(1.0 - p));\n+  return checked_cast<size_t>(ceil(log(1.0 - u) \/ log(1.0 - p)));\n@@ -318,1 +318,1 @@\n-  const size_t population_size = project_population_size(expired);\n+  const double population_size = project_population_size(expired);\n@@ -328,1 +328,1 @@\n-inline size_t JfrAdaptiveSampler::project_population_size(const JfrSamplerWindow* expired) {\n+inline double JfrAdaptiveSampler::project_population_size(const JfrSamplerWindow* expired) {\n@@ -330,1 +330,1 @@\n-  _avg_population_size = exponentially_weighted_moving_average(expired->population_size(), _ewma_population_size_alpha, _avg_population_size);\n+  _avg_population_size = exponentially_weighted_moving_average(checked_cast<double>(expired->population_size()), _ewma_population_size_alpha, _avg_population_size);\n@@ -365,1 +365,1 @@\n-    *sample_size_ewma = exponentially_weighted_moving_average(expired->sample_size(), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n+    *sample_size_ewma = exponentially_weighted_moving_average(checked_cast<double>(expired->sample_size()), compute_ewma_alpha_coefficient(expired->params().window_lookback_count), *sample_size_ewma);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-  size_t project_population_size(const JfrSamplerWindow* expired);\n+  double project_population_size(const JfrSamplerWindow* expired);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  unsigned int _previous_hash;\n+  traceid _previous_hash;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrStackTraceMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  _stack_trace_hash(0),\n@@ -71,1 +72,0 @@\n-  _stack_trace_hash(0),\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  traceid _stack_trace_hash;\n@@ -65,1 +66,0 @@\n-  unsigned int _stack_trace_hash;\n@@ -190,1 +190,1 @@\n-  void set_cached_stack_trace_id(traceid id, unsigned int hash = 0) {\n+  void set_cached_stack_trace_id(traceid id, traceid hash = 0) {\n@@ -208,1 +208,1 @@\n-  unsigned int cached_stack_trace_hash() const {\n+  traceid cached_stack_trace_hash() const {\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  mutable jshort _flags;\n+  mutable uint16_t _flags;\n@@ -52,1 +52,1 @@\n-  bool is_set(jshort flag) const {\n+  bool is_set(uint16_t flag) const {\n@@ -56,1 +56,1 @@\n-  jshort flags() const {\n+  uint16_t flags() const {\n@@ -60,1 +60,1 @@\n-  void set_flags(jshort flags) const {\n+  void set_flags(uint16_t flags) const {\n@@ -64,1 +64,1 @@\n-  jbyte* flags_addr() const {\n+  uint8_t* flags_addr() const {\n@@ -66,1 +66,1 @@\n-    return (jbyte*)&_flags;\n+    return reinterpret_cast<uint8_t*>(&_flags);\n@@ -68,1 +68,1 @@\n-    return ((jbyte*)&_flags) + 1;\n+    return reinterpret_cast<uint8_t*>(&_flags) + 1;\n@@ -72,1 +72,1 @@\n-  jbyte* meta_addr() const {\n+  uint8_t* meta_addr() const {\n@@ -74,1 +74,1 @@\n-    return ((jbyte*)&_flags) + 1;\n+    return reinterpret_cast<uint8_t*>(&_flags) + 1;\n@@ -76,1 +76,1 @@\n-    return (jbyte*)&_flags;\n+    return reinterpret_cast<uint8_t*>(&_flags);\n@@ -84,1 +84,1 @@\n-  bool is_trace_flag_set(jshort flag) const {      \\\n+  bool is_trace_flag_set(uint16_t flag) const {    \\\n@@ -87,1 +87,1 @@\n-  jshort trace_flags() const {                     \\\n+  uint16_t trace_flags() const {                   \\\n@@ -90,1 +90,1 @@\n-  void set_trace_flags(jshort flags) const {       \\\n+  void set_trace_flags(uint16_t flags) const {     \\\n@@ -93,1 +93,1 @@\n-  jbyte* trace_flags_addr() const {                \\\n+  uint8_t* trace_flags_addr() const {              \\\n@@ -96,1 +96,1 @@\n-  jbyte* trace_meta_addr() const {                 \\\n+  uint8_t* trace_meta_addr() const {               \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-  template <typename T>\n-  static T read_unaligned(const address location);\n+  template <typename R, typename T>\n+  static R read_unaligned(const address location);\n@@ -52,2 +52,2 @@\n-  template <typename T>\n-  static T read(const void* location);\n+  template <typename R, typename T>\n+  static R read(const void* location);\n@@ -85,2 +85,2 @@\n-template <typename T>\n-inline T JfrBigEndian::read_unaligned(const address location) {\n+template <typename R, typename T>\n+inline R JfrBigEndian::read_unaligned(const address location) {\n@@ -90,1 +90,1 @@\n-      return read_bytes<u1>(location);\n+      return checked_cast<R>(read_bytes<u1>(location));\n@@ -92,1 +92,1 @@\n-      return read_bytes<u2>(location);\n+      return checked_cast<R>(read_bytes<u2>(location));\n@@ -94,1 +94,1 @@\n-      return read_bytes<u4>(location);\n+      return checked_cast<R>(read_bytes<u4>(location));\n@@ -96,1 +96,1 @@\n-      return read_bytes<u8>(location);\n+      return checked_cast<R>(read_bytes<u8>(location));\n@@ -114,2 +114,2 @@\n-template<typename T>\n-inline T JfrBigEndian::read(const void* location) {\n+template<typename R, typename T>\n+inline R JfrBigEndian::read(const void* location) {\n@@ -119,1 +119,1 @@\n-    return *(T*)location;\n+    return checked_cast<R>(*(u1*)location);\n@@ -124,2 +124,2 @@\n-      case sizeof(u1):\n-        return *(T*)location;\n+      case sizeof(u1) :\n+        return checked_cast<R>(*(u1*)location);\n@@ -127,1 +127,1 @@\n-        return bigendian_16(*(T*)(location));\n+        return checked_cast<R>(bigendian_16(*(u2*)location));\n@@ -129,1 +129,1 @@\n-        return bigendian_32(*(T*)(location));\n+        return checked_cast<R>(bigendian_32(*(u4*)location));\n@@ -131,1 +131,1 @@\n-        return bigendian_64(*(T*)(location));\n+        return checked_cast<R>(bigendian_64(*(u8*)location));\n@@ -134,1 +134,1 @@\n-  return read_unaligned<T>((const address)location);\n+  return read_unaligned<R, T>((const address)location);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrBigEndian.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-       Bytes::put_Java_u2(dest, value);\n+       Bytes::put_Java_u2(dest, checked_cast<u2>(value));\n@@ -84,1 +84,1 @@\n-       Bytes::put_Java_u4(dest, value);\n+       Bytes::put_Java_u4(dest, checked_cast<u4>(value));\n@@ -88,1 +88,1 @@\n-       Bytes::put_Java_u8(dest, value);\n+       Bytes::put_Java_u8(dest, checked_cast<u8>(value));\n@@ -186,1 +186,1 @@\n-     return static_cast<u8>(static_cast<u1>(value) & static_cast<u1>(0xff));\n+     return checked_cast<u8>(checked_cast<u1>(value) & checked_cast<u1>(0xff));\n@@ -188,1 +188,1 @@\n-      return static_cast<u8>(static_cast<u2>(value) & static_cast<u2>(0xffff));\n+      return checked_cast<u8>(checked_cast<u2>(value) & checked_cast<u2>(0xffff));\n@@ -190,1 +190,1 @@\n-      return static_cast<u8>(static_cast<u4>(value) & static_cast<u4>(0xffffffff));\n+      return checked_cast<u8>(checked_cast<u4>(value) & checked_cast<u4>(0xffffffff));\n@@ -192,1 +192,1 @@\n-      return static_cast<u8>(value);\n+      return checked_cast<u8>(value);\n@@ -210,1 +210,1 @@\n-    *dest = static_cast<u1>(v); \/\/ set bit 0-6, no extension\n+    *dest = checked_cast<u1>(v); \/\/ set bit 0-6, no extension\n@@ -213,1 +213,1 @@\n-  *dest = static_cast<u1>(v | ext_bit); \/\/ set bit 0-6, with extension\n+  *dest = checked_cast<u1>(v | ext_bit); \/\/ set bit 0-6, with extension\n@@ -215,1 +215,1 @@\n-    *(dest + 1) = static_cast<u1>(v >> 7); \/\/ set bit 7-13, no extension\n+    *(dest + 1) = checked_cast<u1>(v >> 7); \/\/ set bit 7-13, no extension\n@@ -218,1 +218,1 @@\n-  *(dest + 1) = static_cast<u1>((v >> 7) | ext_bit); \/\/ set bit 7-13, with extension\n+  *(dest + 1) = checked_cast<u1>((v >> 7) | ext_bit); \/\/ set bit 7-13, with extension\n@@ -220,1 +220,1 @@\n-    *(dest + 2) = static_cast<u1>(v >> 14); \/\/ set bit 14-20, no extension\n+    *(dest + 2) = checked_cast<u1>(v >> 14); \/\/ set bit 14-20, no extension\n@@ -223,1 +223,1 @@\n-  *(dest + 2) = static_cast<u1>((v >> 14) | ext_bit); \/\/ set bit 14-20, with extension\n+  *(dest + 2) = checked_cast<u1>((v >> 14) | ext_bit); \/\/ set bit 14-20, with extension\n@@ -225,1 +225,1 @@\n-    *(dest + 3) = static_cast<u1>(v >> 21); \/\/ set bit 21-27, no extension\n+    *(dest + 3) = checked_cast<u1>(v >> 21); \/\/ set bit 21-27, no extension\n@@ -228,1 +228,1 @@\n-  *(dest + 3) = static_cast<u1>((v >> 21) | ext_bit); \/\/ set bit 21-27, with extension\n+  *(dest + 3) = checked_cast<u1>((v >> 21) | ext_bit); \/\/ set bit 21-27, with extension\n@@ -230,1 +230,1 @@\n-    *(dest + 4) = static_cast<u1>(v >> 28); \/\/ set bit 28-34, no extension\n+    *(dest + 4) = checked_cast<u1>(v >> 28); \/\/ set bit 28-34, no extension\n@@ -233,1 +233,1 @@\n-  *(dest + 4) = static_cast<u1>((v >> 28) | ext_bit); \/\/ set bit 28-34, with extension\n+  *(dest + 4) = checked_cast<u1>((v >> 28) | ext_bit); \/\/ set bit 28-34, with extension\n@@ -235,1 +235,1 @@\n-    *(dest + 5) = static_cast<u1>(v >> 35); \/\/ set bit 35-41, no extension\n+    *(dest + 5) = checked_cast<u1>(v >> 35); \/\/ set bit 35-41, no extension\n@@ -238,1 +238,1 @@\n-  *(dest + 5) = static_cast<u1>((v >> 35) | ext_bit); \/\/ set bit 35-41, with extension\n+  *(dest + 5) = checked_cast<u1>((v >> 35) | ext_bit); \/\/ set bit 35-41, with extension\n@@ -240,1 +240,1 @@\n-    *(dest + 6) = static_cast<u1>(v >> 42); \/\/ set bit 42-48, no extension\n+    *(dest + 6) = checked_cast<u1>(v >> 42); \/\/ set bit 42-48, no extension\n@@ -243,1 +243,1 @@\n-  *(dest + 6) = static_cast<u1>((v >> 42) | ext_bit); \/\/ set bit 42-48, with extension\n+  *(dest + 6) = checked_cast<u1>((v >> 42) | ext_bit); \/\/ set bit 42-48, with extension\n@@ -245,1 +245,1 @@\n-    *(dest + 7) = static_cast<u1>(v >> 49); \/\/ set bit 49-55, no extension\n+    *(dest + 7) = checked_cast<u1>(v >> 49); \/\/ set bit 49-55, no extension\n@@ -248,1 +248,1 @@\n-  *(dest + 7) = static_cast<u1>((v >> 49) | ext_bit); \/\/ set bit 49-55, with extension\n+  *(dest + 7) = checked_cast<u1>((v >> 49) | ext_bit); \/\/ set bit 49-55, with extension\n@@ -250,1 +250,1 @@\n-  *(dest + 8) = static_cast<u1>(v >> 56);  \/\/ set bit 56-63\n+  *(dest + 8) = checked_cast<u1>(v >> 56);  \/\/ set bit 56-63\n@@ -273,1 +273,1 @@\n-      dest[0] = static_cast<u1>(v);\n+      dest[0] = checked_cast<u1>(v);\n@@ -276,2 +276,2 @@\n-      dest[0] = static_cast<u1>(v | 0x80);\n-      dest[1] = static_cast<u1>(v >> 7);\n+      dest[0] = checked_cast<u1>(v | 0x80);\n+      dest[1] = checked_cast<u1>(v >> 7);\n@@ -280,4 +280,4 @@\n-      dest[0] = static_cast<u1>(v | 0x80);\n-      dest[1] = static_cast<u1>(v >> 7 | 0x80);\n-      dest[2] = static_cast<u1>(v >> 14 | 0x80);\n-      dest[3] = static_cast<u1>(v >> 21);\n+      dest[0] = checked_cast<u1>(v | 0x80);\n+      dest[1] = checked_cast<u1>(v >> 7 | 0x80);\n+      dest[2] = checked_cast<u1>(v >> 14 | 0x80);\n+      dest[3] = checked_cast<u1>(v >> 21);\n@@ -286,8 +286,8 @@\n-      dest[0] = static_cast<u1>(v | 0x80);\n-      dest[1] = static_cast<u1>(v >> 7 | 0x80);\n-      dest[2] = static_cast<u1>(v >> 14 | 0x80);\n-      dest[3] = static_cast<u1>(v >> 21 | 0x80);\n-      dest[4] = static_cast<u1>(v >> 28 | 0x80);\n-      dest[5] = static_cast<u1>(v >> 35 | 0x80);\n-      dest[6] = static_cast<u1>(v >> 42 | 0x80);\n-      dest[7] = static_cast<u1>(v >> 49);\n+      dest[0] = checked_cast<u1>(v | 0x80);\n+      dest[1] = checked_cast<u1>(v >> 7 | 0x80);\n+      dest[2] = checked_cast<u1>(v >> 14 | 0x80);\n+      dest[3] = checked_cast<u1>(v >> 21 | 0x80);\n+      dest[4] = checked_cast<u1>(v >> 28 | 0x80);\n+      dest[5] = checked_cast<u1>(v >> 35 | 0x80);\n+      dest[6] = checked_cast<u1>(v >> 42 | 0x80);\n+      dest[7] = checked_cast<u1>(v >> 49);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    event.set_iterations(iterations);\n+    event.set_iterations(checked_cast<u4>(iterations));\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-      return c * NANOS_PER_MILLISEC;\n+      return c * (jlong)NANOS_PER_MILLISEC;\n@@ -131,2 +131,2 @@\n-    double population_mean = population_sum \/ (double)population_size;\n-    double sample_mean = sample_sum \/ (double)sample_size;\n+    double population_mean = (double)population_sum \/ (double)population_size;\n+    double sample_mean = (double)sample_sum \/ (double)sample_size;\n@@ -138,1 +138,1 @@\n-      population_variance = population[i] * population_diff * population_diff;\n+      population_variance = (double)population[i] * population_diff * population_diff;\n@@ -141,1 +141,1 @@\n-      sample_variance = sample[i] * sample_diff * sample_diff;\n+      sample_variance = (double)sample[i] * sample_diff * sample_diff;\n@@ -143,2 +143,2 @@\n-    population_variance = population_variance \/ (population_size - 1);\n-    sample_variance = sample_variance \/ (sample_size - 1);\n+    population_variance = population_variance \/ (double)(population_size - 1);\n+    sample_variance = sample_variance \/ (double)(sample_size - 1);\n@@ -230,1 +230,1 @@\n-  EXPECT_NEAR(target_sample_size, sample_size, expected_sample_points * error_factor) << output;\n+  EXPECT_NEAR((double)target_sample_size, (double)sample_size, (double)expected_sample_points * error_factor) << output;\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}