{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+            encoding.addInt(groupName.hashCode());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/EncodedSpeculationReason.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,13 @@\n+\n+\/**\n+ * @test\n+ * @requires vm.jvmci\n+ * @library ..\/..\/..\/..\/..\/\n+ * @modules java.base\/jdk.internal.reflect\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.common\n+ *          java.base\/jdk.internal.misc\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestSpeculationLog\n+ *\/\n@@ -34,0 +47,1 @@\n+import jdk.vm.ci.meta.EncodedSpeculationReason;\n@@ -35,0 +49,1 @@\n+import jdk.vm.ci.meta.MetaAccessProvider;\n@@ -131,0 +146,24 @@\n+\n+    @Test\n+    public void testEncodedSpeculationReasonIncludesGroupName() {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        CodeCacheProvider codeCache = JVMCI.getRuntime().getHostJVMCIBackend().getCodeCache();\n+        SpeculationLog log = codeCache.createSpeculationLog();\n+        Object[] context = {\"context\"};\n+        SpeculationLog.SpeculationReason sr1 = new EncodedSpeculationReason(0, \"group0\", context);\n+        SpeculationLog.SpeculationReason sr2 = new EncodedSpeculationReason(0, \"group1\", context);\n+        SpeculationLog.Speculation s1 = log.speculate(sr1);\n+        SpeculationLog.Speculation s2 = log.speculate(sr2);\n+        JavaConstant es1 = metaAccess.encodeSpeculation(s1);\n+        JavaConstant es2 = metaAccess.encodeSpeculation(s2);\n+        if (es1.equals(es2)) {\n+            Assert.fail(\n+                String.format(\"EncodedSpeculationReasons with different groupName should produce unique encoded speculations:%n\" +\n+                \"  Reason 1: %s%n\" +\n+                \"  Reason 2: %s%n\" +\n+                \"  Speculation 1: %s%n\" +\n+                \"  Speculation 2: %s%n\" +\n+                \"  Encoded speculation 1: %s%n\" +\n+                \"  Encoded speculation 2: %s%n\", sr1, sr2, s1, s2, es1, es2));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestSpeculationLog.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"}]}