{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\/native -agentlib:redefclass031 nsk.jvmti.RedefineClasses.redefclass031\n+ * @run main\/othervm\/native -agentlib:redefclass031 nsk.jvmti.RedefineClasses.redefclass031 -v\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass031\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+static jthread test_thread = NULL;\n@@ -45,1 +46,1 @@\n-static void set_watch_ev(int value) {\n+static void set_watch_ev(JNIEnv *env, int value) {\n@@ -48,0 +49,13 @@\n+    if (value) {\n+        jvmtiError err = jvmti->GetCurrentThread(&test_thread);\n+        if (err != JVMTI_ERROR_NONE) {\n+            printf(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n+            result = STATUS_FAILED;\n+        } else {\n+            test_thread = env->NewGlobalRef(test_thread);\n+        }\n+    } else if (test_thread != NULL) {\n+        env->DeleteGlobalRef(test_thread);\n+        test_thread = NULL;\n+    }\n+\n@@ -57,3 +71,25 @@\n-    if (watch_ev && isThreadExpected(jvmti_env, thr)) {\n-        printf(\"#### JVMTI_EVENT_NATIVE_METHOD_BIND occured ####\\n\");\n-        gen_ev++;\n+    if (watch_ev) {\n+        \/\/ we are interested only in events on the test thread and VMThread.\n+        \/\/ In case of VMThread we most likely get crash (VMThread is not a Java Thread),\n+        \/\/ but lets check GetThreadInfo - it returns error for non-Java threads.\n+        if (env->IsSameObject(test_thread, thr)) {\n+            printf(\"#### JVMTI_EVENT_NATIVE_METHOD_BIND occured on test thread ####\\n\");\n+            gen_ev++;\n+        } else {\n+            jvmtiThreadInfo inf;\n+            jvmtiError err = jvmti_env->GetThreadInfo(thr, &inf);\n+            if (err != JVMTI_ERROR_NONE) {\n+                printf(\"#### JVMTI_EVENT_NATIVE_METHOD_BIND: Failed to get thread info: %s (%d) ####\\n\",\n+                    TranslateError(err), err);\n+                result = STATUS_FAILED;\n+            } else {\n+                printf(\"got JVMTI_EVENT_NATIVE_METHOD_BIND event on thread '%s', ignoring\", inf.name);\n+                jvmti_env->Deallocate((unsigned char *)inf.name);\n+                if (inf.thread_group != NULL) {\n+                    env->DeleteLocalRef(inf.thread_group);\n+                }\n+                if (inf.context_class_loader != NULL) {\n+                    env->DeleteLocalRef(inf.context_class_loader);\n+                }\n+            }\n+        }\n@@ -156,1 +192,1 @@\n-    set_watch_ev(1); \/* watch JVMTI events *\/\n+    set_watch_ev(env, 1); \/* watch JVMTI events *\/\n@@ -171,1 +207,1 @@\n-    set_watch_ev(0); \/* again ignore JVMTI events *\/\n+    set_watch_ev(env, 0); \/* again ignore JVMTI events *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass031\/redefclass031.cpp","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\/native -agentlib:ji01t001 nsk.jvmti.scenarios.jni_interception.JI01.ji01t001\n+ * @run main\/othervm\/native -agentlib:ji01t001=-verbose nsk.jvmti.scenarios.jni_interception.JI01.ji01t001\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI01\/ji01t001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+\/\/ test thread\n+static jthread testThread = NULL;\n+\n@@ -57,0 +60,17 @@\n+void setTestThread(JNIEnv *env) {\n+    jthread curThread = NULL;\n+    NSK_JVMTI_VERIFY(jvmti->GetCurrentThread(&curThread));\n+    testThread = env->NewGlobalRef(curThread);\n+}\n+\n+void resetTestThread(JNIEnv *env) {\n+     env->DeleteGlobalRef(testThread);\n+     testThread = NULL;\n+}\n+\n+bool isOnTestThread(JNIEnv *env) {\n+    jthread curThread = NULL;\n+    NSK_JVMTI_VERIFY(jvmti->GetCurrentThread(&curThread));\n+    return env->IsSameObject(testThread, curThread);\n+}\n+\n@@ -60,1 +80,1 @@\n-    if (isThreadExpected(jvmti, NULL)) {\n+    if (isOnTestThread(env) && strcmp(name, classSig) == 0) {\n@@ -195,0 +215,3 @@\n+    setTestThread(env);\n+    fnd_calls = 0;\n+\n@@ -203,1 +226,3 @@\n-    \/\/ The check should pass if the actual number of invocations is not less that the expected number (fnd_calls >= exFndCalls).\n+    resetTestThread(env);\n+\n+    \/\/ The check should pass if the actual number of invocations is the same as the expected number (fnd_calls == exFndCalls).\n@@ -205,1 +230,1 @@\n-    if ((exFndCalls > 0 && fnd_calls >= exFndCalls) || (fnd_calls == exFndCalls)) {\n+    if (fnd_calls == exFndCalls) {\n@@ -213,7 +238,0 @@\n-\n-            if (fnd_calls != exFndCalls) {\n-                NSK_COMPLAIN2(\"WARNING: the number of occured calls (%d) exceeds the expected number of calls (%d).\\n\"\n-                             , fnd_calls\n-                             , exFndCalls\n-                             );\n-            }\n@@ -247,1 +265,0 @@\n-    fnd_calls = 0;\n@@ -252,1 +269,0 @@\n-    fnd_calls = 0;\n@@ -271,1 +287,0 @@\n-    fnd_calls = 0;\n@@ -276,1 +291,0 @@\n-    fnd_calls = 0;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI01\/ji01t001\/ji01t001.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/native -agentlib:ji03t003 nsk.jvmti.scenarios.jni_interception.JI03.ji03t003\n+ * @run main\/othervm\/native -agentlib:ji03t003=-verbose nsk.jvmti.scenarios.jni_interception.JI03.ji03t003 -verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+\/\/ test thread\n+static jthread testThread = NULL;\n@@ -58,0 +60,17 @@\n+void setTestThread(JNIEnv *env) {\n+    jthread curThread = NULL;\n+    NSK_JVMTI_VERIFY(jvmti->GetCurrentThread(&curThread));\n+    testThread = env->NewGlobalRef(curThread);\n+}\n+\n+void resetTestThread(JNIEnv *env) {\n+     env->DeleteGlobalRef(testThread);\n+     testThread = NULL;\n+}\n+\n+bool isOnTestThread(JNIEnv *env) {\n+    jthread curThread = NULL;\n+    NSK_JVMTI_VERIFY(jvmti->GetCurrentThread(&curThread));\n+    return env->IsSameObject(testThread, curThread);\n+}\n+\n@@ -62,4 +81,10 @@\n-    throw_calls++;\n-    if (verbose)\n-        printf(\"\\nMyThrow: the function called successfully: number of calls=%d\\n\",\n-            throw_calls);\n+    if (isOnTestThread(env)) {\n+        throw_calls++;\n+        if (verbose) {\n+            printf(\"\\nMyThrow: the function called successfully: number of calls=%d\\n\", throw_calls);\n+        }\n+    } else {\n+        if (verbose) {\n+            printf(\"\\nMyThrow: the function called on non-test thread, ignoring\\n\");\n+        }\n+    }\n@@ -77,4 +102,10 @@\n-    thrownew_calls++;\n-    if (verbose)\n-        printf(\"\\nMyThrowNew: the function called successfully: number of calls=%d\\n\",\n-            thrownew_calls);\n+    if (isOnTestThread(env)) {\n+        thrownew_calls++;\n+        if (verbose) {\n+            printf(\"\\nMyThrowNew: the function called successfully: number of calls=%d\\n\", thrownew_calls);\n+        }\n+    } else {\n+        if (verbose) {\n+            printf(\"\\nMyThrowNew: the function called on non-test thread, ignoring\\n\");\n+        }\n+    }\n@@ -90,1 +121,1 @@\n-    if (isThreadExpected(jvmti, NULL)) {\n+    if (isOnTestThread(env)) {\n@@ -92,3 +123,7 @@\n-        if (verbose)\n-            printf(\"\\nMyExceptionOccurred: the function called successfully: number of calls=%d\\n\",\n-                   excoccur_calls);\n+        if (verbose) {\n+            printf(\"\\nMyExceptionOccurred: the function called successfully: number of calls=%d\\n\", excoccur_calls);\n+        }\n+    } else {\n+        if (verbose) {\n+            printf(\"\\nMyExceptionOccurred: the function called on non-test thread, ignoring\\n\");\n+        }\n@@ -287,0 +322,2 @@\n+    setTestThread(env);\n+\n@@ -304,0 +341,2 @@\n+    resetTestThread(env);\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t003\/ji03t003.cpp","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- *      -agentlib:ma10t001=-waittime=5\n- *      -agentlib:ma10t001a=-waittime=5\n+ *      -agentlib:ma10t001=-waittime=5,-verbose\n+ *      -agentlib:ma10t001a=-waittime=5,-verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t001\/TestDescription.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+\/\/ test thread\n+static const char *testThreadName = \"Debuggee Thread\";\n+\n@@ -46,0 +49,28 @@\n+void releaseThreadInfo(jvmtiEnv *jvmti_env, JNIEnv *jni_env, jvmtiThreadInfo *info) {\n+    jvmti_env->Deallocate((unsigned char *)info->name);\n+    if (info->thread_group != NULL) {\n+        jni_env->DeleteLocalRef(info->thread_group);\n+    }\n+    if (info->context_class_loader != NULL) {\n+        jni_env->DeleteLocalRef(info->context_class_loader);\n+    }\n+}\n+\n+static bool isTestThread(const char *msg, jvmtiEnv *jvmti_env, JNIEnv *jni_env, jthread thread) {\n+    jvmtiThreadInfo inf;\n+    jvmtiError err = jvmti_env->GetThreadInfo(thread, &inf);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"%s: Failed to get thread info: %s (%d)\\n\", msg, TranslateError(err), err);\n+        return false;\n+    }\n+\n+    bool result = strcmp(testThreadName, inf.name) == 0;\n+    if (!result) {\n+        NSK_DISPLAY2(\"%s: event on unexpected thread %s\\n\", msg, inf.name);\n+    }\n+\n+    releaseThreadInfo(jvmti_env, jni_env, &inf);\n+\n+    return result;\n+}\n+\n@@ -55,1 +86,1 @@\n-    if (!isThreadExpected(jvmti_env, thread)) {\n+    if (!isTestThread(\"Exception\", jvmti_env, jni_env, thread)) {\n@@ -80,1 +111,1 @@\n-    if (!isThreadExpected(jvmti_env, thread)) {\n+    if (!isTestThread(\"ExceptionCatch\", jvmti_env, jni_env, thread)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t001\/ma10t001.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,27 +584,0 @@\n-int isThreadExpected(jvmtiEnv *jvmti, jthread thread) {\n-    static const char *vm_jfr_buffer_thread_name = \"VM JFR Buffer Thread\";\n-    static const char *jfr_request_timer_thread_name = \"JFR request timer\";\n-    static const char *graal_management_bean_registration_thread_name =\n-                                            \"HotSpotGraalManagement Bean Registration\";\n-    static const char *graal_compiler_thread_name_prefix = \"JVMCI CompilerThread\";\n-    static const size_t prefixLength = strlen(graal_compiler_thread_name_prefix);\n-\n-    jvmtiThreadInfo threadinfo;\n-    NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(thread, &threadinfo));\n-\n-    if (strcmp(threadinfo.name, vm_jfr_buffer_thread_name) == 0)\n-        return 0;\n-\n-    if (strcmp(threadinfo.name, jfr_request_timer_thread_name) == 0)\n-        return 0;\n-\n-    if (strcmp(threadinfo.name, graal_management_bean_registration_thread_name) == 0)\n-        return 0;\n-\n-    if ((strlen(threadinfo.name) > prefixLength) &&\n-         strncmp(threadinfo.name, graal_compiler_thread_name_prefix, prefixLength) == 0)\n-        return 0;\n-\n-    return 1;\n-}\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_tools.cpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,2 +372,0 @@\n-int isThreadExpected(jvmtiEnv *jvmti, jthread thread);\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_tools.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}