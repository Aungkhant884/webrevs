{"files":[{"patch":"@@ -456,1 +456,1 @@\n-  \/\/ Check that JVMCI compiler supports selested GC.\n+  \/\/ Check that JVMCI supports selected GC.\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -638,0 +638,25 @@\n+jboolean JVMCIEnv::call_HotSpotJVMCIRuntime_isGCSupported (JVMCIObject runtime, jint gcIdentifier) {\n+  JavaThread* THREAD = JavaThread::current();\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));\n+    jargs.push_int(gcIdentifier);\n+    JavaValue result(T_BOOLEAN);\n+    JavaCalls::call_special(&result,\n+                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                            vmSymbols::isGCSupported_name(),\n+                            vmSymbols::int_bool_signature(), &jargs, CHECK_0);\n+    return result.get_jboolean();\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jboolean result = jni()->CallNonvirtualBooleanMethod(runtime.as_jobject(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::isGCSupported_method(),\n+                                                     gcIdentifier);\n+    if (jni()->ExceptionCheck()) {\n+      return false;\n+    }\n+    return result;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+  jboolean call_HotSpotJVMCIRuntime_isGCSupported(JVMCIObject runtime, jint gcIdentifier);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature, (JVMCIObject runtime, int gcIdentifier)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1518,0 +1518,9 @@\n+bool JVMCIRuntime::is_gc_supported(JVMCIEnv* JVMCIENV, CollectedHeap::Name name) {\n+  JVMCI_EXCEPTION_CONTEXT\n+\n+  JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);\n+  if (JVMCIENV->has_pending_exception()) {\n+    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+  }\n+  return JVMCIENV->call_HotSpotJVMCIRuntime_isGCSupported(receiver, (int) name);\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -282,0 +283,3 @@\n+  \/\/ Determines if the GC identified by `name` is supported by the JVMCI compiler.\n+  bool is_gc_supported(JVMCIEnv* JVMCIENV, CollectedHeap::Name name);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-      vm_exit_during_initialization(\"JVMCI Compiler does not support selected GC\", GCConfig::hs_err_name());\n+      log_warning(gc, jvmci)(\"Setting EnableJVMCI to false as selected GC does not support JVMCI: %s\", GCConfig::hs_err_name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-  \/\/ Check and exit VM with error if selected GC is not supported by JVMCI.\n+  \/\/ Check and turn off EnableJVMCI if selected GC does not support JVMCI.\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,8 @@\n+  declare_constant(CollectedHeap::None)                                   \\\n+  declare_constant(CollectedHeap::Serial)                                 \\\n+  declare_constant(CollectedHeap::Parallel)                               \\\n+  declare_constant(CollectedHeap::G1)                                     \\\n+  declare_constant(CollectedHeap::Epsilon)                                \\\n+  declare_constant(CollectedHeap::Z)                                      \\\n+  declare_constant(CollectedHeap::Shenandoah)                             \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  template(isGCSupported_name,                                    \"isGCSupported\")                                                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+  LOG_TAG(jvmci) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,0 +110,4 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -357,0 +361,10 @@\n+WB_ENTRY(jboolean, WB_IsGCSupportedByJVMCI(JNIEnv* env, jobject o, jint name))\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    JVMCIEnv jvmciEnv(thread, env, __FILE__, __LINE__);\n+    return jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name);\n+  }\n+#endif\n+  return false;\n+WB_END\n+\n@@ -2517,0 +2531,1 @@\n+  {CC\"isGCSupportedByJVMCI\",      CC\"(I)Z\",           (void*)&WB_IsGCSupportedByJVMCI},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+\n+        @Override\n+        public boolean isGCSupported(int gcIdentifier) {\n+            return false;\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -713,0 +713,5 @@\n+\n+        @Override\n+        public boolean isGCSupported(int gcIdentifier) {\n+            return false;\n+        }\n@@ -815,0 +820,6 @@\n+    @SuppressWarnings(\"try\")\n+    @VMEntryPoint\n+    private boolean isGCSupported(int gcIdentifier) {\n+        return getCompiler().isGCSupported(gcIdentifier);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,11 @@\n+\n+    \/**\n+     * Determines if this compiler supports the {@code gcIdentifier} garbage collector. The default\n+     * implementation of this method returns true as that is the effective answer given by a\n+     * {@link JVMCICompiler} before this method was added.\n+     *\n+     * @param gcIdentifier a VM dependent GC identifier\n+     *\/\n+    default boolean isGCSupported(int gcIdentifier) {\n+        return true;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.runtime\/src\/jdk\/vm\/ci\/runtime\/JVMCICompiler.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;\n@@ -326,0 +327,9 @@\n+\n+    @Override\n+    public boolean isGCSupported(int gcIdentifier) {\n+        HotSpotGC gc = HotSpotGC.forName(gcIdentifier, graalRuntime.getVMConfig());\n+        if (gc != null) {\n+            return gc.supported;\n+        }\n+        return false;\n+    }\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/HotSpotGraalCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -250,1 +250,2 @@\n-     * Constants denoting the GC algorithms available in HotSpot.\n+     * Constants denoting the GC algorithms available in HotSpot. The names of the constants match\n+     * the constants in the {@code CollectedHeap::Name} C++ enum.\n@@ -254,4 +255,4 @@\n-        Serial(true, \"UseSerialGC\", true),\n-        Parallel(true, \"UseParallelGC\", true, \"UseParallelOldGC\", JDK < 15, \"UseParNewGC\", JDK < 10),\n-        CMS(true, \"UseConcMarkSweepGC\", JDK < 14),\n-        G1(true, \"UseG1GC\", true),\n+        Serial(true, JDK >= 11, \"UseSerialGC\", true),\n+        Parallel(true, JDK >= 11, \"UseParallelGC\", true, \"UseParallelOldGC\", JDK < 15, \"UseParNewGC\", JDK < 10),\n+        CMS(true, JDK >= 11 && JDK <= 14, \"UseConcMarkSweepGC\", JDK < 14),\n+        G1(true, JDK >= 11, \"UseG1GC\", true),\n@@ -260,2 +261,3 @@\n-        Epsilon(false, \"UseEpsilonGC\", JDK >= 11),\n-        Z(false, \"UseZGC\", JDK >= 11);\n+        Epsilon(false, JDK >= 11, \"UseEpsilonGC\", JDK >= 11),\n+        Z(false, JDK >= 11, \"UseZGC\", JDK >= 11),\n+        Shenandoah(false, JDK >= 12, \"UseShenandoahGC\", JDK >= 12);\n@@ -263,1 +265,1 @@\n-        HotSpotGC(boolean supported,\n+        HotSpotGC(boolean supported, boolean expectNamePresent,\n@@ -268,0 +270,1 @@\n+            this.expectNamePresent = expectNamePresent;\n@@ -272,1 +275,1 @@\n-        HotSpotGC(boolean supported, String flag, boolean expectFlagPresent) {\n+        HotSpotGC(boolean supported, boolean expectNamePresent, String flag, boolean expectFlagPresent) {\n@@ -274,0 +277,1 @@\n+            this.expectNamePresent = expectNamePresent;\n@@ -278,0 +282,3 @@\n+        \/**\n+         * Specifies if this GC supported by Graal.\n+         *\/\n@@ -279,1 +286,10 @@\n-        final boolean[] expectFlagsPresent;\n+\n+        \/**\n+         * Specifies if {@link #name()} is expected to be present in the {@code CollectedHeap::Name}\n+         * C++ enum.\n+         *\/\n+        final boolean expectNamePresent;\n+\n+        \/**\n+         * The VM flags that will select this GC.\n+         *\/\n@@ -282,0 +298,5 @@\n+        \/**\n+         * Specifies which {@link #flags} are expected to be present in the VM.\n+         *\/\n+        final boolean[] expectFlagsPresent;\n+\n@@ -296,0 +317,14 @@\n+\n+        \/**\n+         * Gets the GC matching {@code name}.\n+         *\n+         * @param name the ordinal of a {@code CollectedHeap::Name} value\n+         *\/\n+        static HotSpotGC forName(int name, GraalHotSpotVMConfig config) {\n+            for (HotSpotGC gc : HotSpotGC.values()) {\n+                if (config.getConstant(\"CollectedHeap::\" + gc.name(), Integer.class, -1, gc.expectNamePresent) == name) {\n+                    return gc;\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/HotSpotGraalRuntime.java","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -238,16 +238,1 @@\n-        if (WB.getBooleanVMFlag(\"EnableJVMCI\") == null) {\n-            return \"false\";\n-        }\n-\n-        switch (GC.selected()) {\n-            case Serial:\n-            case Parallel:\n-            case G1:\n-                \/\/ These GCs are supported with JVMCI\n-                return \"true\";\n-            default:\n-                break;\n-        }\n-\n-        \/\/ Every other GC is not supported\n-        return \"false\";\n+        return WB.getBooleanVMFlag(\"EnableJVMCI\") != null ? \"true\" : \"false\";\n@@ -274,15 +259,0 @@\n-    private boolean isGcSupportedByGraal(GC gc) {\n-        switch (gc) {\n-            case Serial:\n-            case Parallel:\n-            case G1:\n-                return true;\n-            case Epsilon:\n-            case Z:\n-            case Shenandoah:\n-                return false;\n-            default:\n-                throw new IllegalStateException(\"Unknown GC \" + gc.name());\n-        }\n-    }\n-\n@@ -299,1 +269,2 @@\n-        var isGraalEnabled = Compiler.isGraalEnabled();\n+        Boolean flag = WB.getBooleanVMFlag(\"EnableJVMCI\");\n+        var isJVMCIEnabled = flag != null && flag;\n@@ -303,1 +274,1 @@\n-                            && (!isGraalEnabled || isGcSupportedByGraal(gc))\n+                            && (!isJVMCIEnabled || gc.isSupportedByJVMCI())\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":33,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -418,0 +418,1 @@\n+  public native boolean isGCSupportedByJVMCI(int name);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,8 @@\n+    \/**\n+     * @return true if this GC is supported by JVMCI.\n+     * @throws UnsupportedOperationException if JVMCI is not built into the VM or EnableJVMCI is false\n+     *\/\n+    public boolean isSupportedByJVMCI() {\n+        return WB.isGCSupportedByJVMCI(name);\n+    }\n+\n","filename":"test\/lib\/sun\/hotspot\/gc\/GC.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}