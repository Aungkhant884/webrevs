{"files":[{"patch":"@@ -456,4 +456,0 @@\n-  \/\/ Check that JVMCI compiler supports selested GC.\n-  \/\/ Should be done after GCConfig::initialize() was called.\n-  JVMCIGlobals::check_jvmci_supported_gc();\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -185,0 +189,9 @@\n+#if INCLUDE_JVMCI\n+      if (EnableJVMCI) {\n+        JavaThread *thread = JavaThread::current();\n+        JVMCIEnv jvmciEnv(thread, thread->jni_environment(), __FILE__, __LINE__);\n+        if (!jvmciEnv.runtime()->is_gc_supported(&jvmciEnv, (CollectedHeap::Name)name)) {\n+          return false;\n+        }\n+      }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/gcConfig.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -638,0 +638,25 @@\n+jboolean JVMCIEnv::call_HotSpotJVMCIRuntime_isGCSupported (JVMCIObject runtime, jint gcIdentifier) {\n+  JavaThread* THREAD = JavaThread::current();\n+  if (is_hotspot()) {\n+    JavaCallArguments jargs;\n+    jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));\n+    jargs.push_int(gcIdentifier);\n+    JavaValue result(T_BOOLEAN);\n+    JavaCalls::call_special(&result,\n+                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),\n+                            vmSymbols::isGCSupported_name(),\n+                            vmSymbols::int_bool_signature(), &jargs, CHECK_0);\n+    return result.get_jboolean();\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jboolean result = jni()->CallNonvirtualBooleanMethod(runtime.as_jobject(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::clazz(),\n+                                                     JNIJVMCI::HotSpotJVMCIRuntime::isGCSupported_method(),\n+                                                     gcIdentifier);\n+    if (jni()->ExceptionCheck()) {\n+      return false;\n+    }\n+    return result;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+  jboolean call_HotSpotJVMCIRuntime_isGCSupported(JVMCIObject runtime, jint gcIdentifier);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,0 +351,1 @@\n+    jvmci_method(CallNonvirtualObjectMethod, GetMethodID, call_special, JVMCIObject, HotSpotJVMCIRuntime, isGCSupported, int_bool_signature, (JVMCIObject runtime, int gcIdentifier)) \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1518,0 +1518,9 @@\n+bool JVMCIRuntime::is_gc_supported(JVMCIEnv* JVMCIENV, CollectedHeap::Name name) {\n+  JVMCI_EXCEPTION_CONTEXT\n+\n+  JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);\n+  if (JVMCIENV->has_pending_exception()) {\n+    fatal_exception(JVMCIENV, \"Exception during HotSpotJVMCIRuntime initialization\");\n+  }\n+  return JVMCIENV->call_HotSpotJVMCIRuntime_isGCSupported(receiver, (int) name);\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -282,0 +283,3 @@\n+  \/\/ Determines if the GC identified by `name` is supported by the JVMCI compiler.\n+  bool is_gc_supported(JVMCIEnv* JVMCIENV, CollectedHeap::Name name);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -202,11 +202,0 @@\n-\n-void JVMCIGlobals::check_jvmci_supported_gc() {\n-  if (EnableJVMCI) {\n-    \/\/ Check if selected GC is supported by JVMCI and Java compiler\n-    if (!(UseSerialGC || UseParallelGC || UseG1GC)) {\n-      vm_exit_during_initialization(\"JVMCI Compiler does not support selected GC\", GCConfig::hs_err_name());\n-      FLAG_SET_DEFAULT(EnableJVMCI, false);\n-      FLAG_SET_DEFAULT(UseJVMCICompiler, false);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -158,3 +158,0 @@\n-  \/\/ Check and exit VM with error if selected GC is not supported by JVMCI.\n-  static void check_jvmci_supported_gc();\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -485,0 +485,8 @@\n+  declare_constant(CollectedHeap::None)                                   \\\n+  declare_constant(CollectedHeap::Serial)                                 \\\n+  declare_constant(CollectedHeap::Parallel)                               \\\n+  declare_constant(CollectedHeap::G1)                                     \\\n+  declare_constant(CollectedHeap::Epsilon)                                \\\n+  declare_constant(CollectedHeap::Z)                                      \\\n+  declare_constant(CollectedHeap::Shenandoah)                             \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  template(isGCSupported_name,                                    \"isGCSupported\")                                                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+\n+        @Override\n+        public boolean isGCSupported(int gcIdentifier) {\n+            return false;\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -713,0 +713,5 @@\n+\n+        @Override\n+        public boolean isGCSupported(int gcIdentifier) {\n+            return false;\n+        }\n@@ -815,0 +820,6 @@\n+    @SuppressWarnings(\"try\")\n+    @VMEntryPoint\n+    private boolean isGCSupported(int gcIdentifier) {\n+        return getCompiler().isGCSupported(gcIdentifier);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,11 @@\n+\n+    \/**\n+     * Determines if this compiler supports the {@code gcIdentifier} garbage collector. The default\n+     * implementation of this method returns true as that is the effective answer given by a\n+     * {@link JVMCICompiler} before this method was added.\n+     *\n+     * @param gcIdentifier a VM dependent GC identifier\n+     *\/\n+    default boolean isGCSupported(int gcIdentifier) {\n+        return true;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.runtime\/src\/jdk\/vm\/ci\/runtime\/JVMCICompiler.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -238,16 +238,1 @@\n-        if (WB.getBooleanVMFlag(\"EnableJVMCI\") == null) {\n-            return \"false\";\n-        }\n-\n-        switch (GC.selected()) {\n-            case Serial:\n-            case Parallel:\n-            case G1:\n-                \/\/ These GCs are supported with JVMCI\n-                return \"true\";\n-            default:\n-                break;\n-        }\n-\n-        \/\/ Every other GC is not supported\n-        return \"false\";\n+        return WB.getBooleanVMFlag(\"EnableJVMCI\") != null ? \"true\" : \"false\";\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"}]}