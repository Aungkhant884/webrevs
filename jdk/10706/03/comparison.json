{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,18 +288,0 @@\n-    List<Object> classDataValues() {\n-        final List<ClassData> cd = classData;\n-        return switch(cd.size()) {\n-            case 0 -> List.of();\n-            case 1 -> List.of(cd.get(0).value);\n-            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n-            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n-            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n-            default -> {\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n-                    data[i] = classData.get(i).value;\n-                }\n-                yield List.of(data);\n-            }\n-        };\n-    }\n-\n@@ -363,0 +345,26 @@\n+    \/**\n+     * Returns the class data object that will be passed to `Lookup.defineHiddenClassWithClassData`.\n+     * The classData is loaded in the <clinit> method of the generated class.\n+     * If the class data contains only one single object, this method returns  that single object.\n+     * If the class data contains more than one objects, this method returns a List.\n+     *\n+     * This method returns null if no class data.\n+     *\/\n+    private Object classDataValues() {\n+        final List<ClassData> cd = classData;\n+        return switch (cd.size()) {\n+            case 0 -> null;             \/\/ special case (classData is not used by <clinit>)\n+            case 1 -> cd.get(0).value;  \/\/ special case (single object)\n+            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n+            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n+            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n+            default -> {\n+                Object[] data = new Object[classData.size()];\n+                for (int i = 0; i < classData.size(); i++) {\n+                    data[i] = classData.get(i).value;\n+                }\n+                yield List.of(data);\n+            }\n+        };\n+    }\n+\n@@ -382,10 +390,2 @@\n-        \/\/ we should optimize one single element case that does not need to create a List\n-        mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n-        mv.visitVarInsn(Opcodes.ASTORE, 0);\n-        int index = 0;\n-        for (ClassData p : classData) {\n-            \/\/ initialize the static field\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\n-            emitIconstInsn(mv, index++);\n-            mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n-                               \"get\", \"(I)Ljava\/lang\/Object;\", true);\n+        if (classData.size() == 1) {\n+            ClassData p = classData.get(0);\n@@ -394,0 +394,13 @@\n+        } else {\n+            mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n+            mv.visitVarInsn(Opcodes.ASTORE, 0);\n+            int index = 0;\n+            for (ClassData p : classData) {\n+                \/\/ initialize the static field\n+                mv.visitVarInsn(Opcodes.ALOAD, 0);\n+                emitIconstInsn(mv, index++);\n+                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n+                                   \"get\", \"(I)Ljava\/lang\/Object;\", true);\n+                mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n+                mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":42,"deletions":29,"binary":false,"changes":71,"status":"modified"}]}