{"files":[{"patch":"@@ -153,8 +153,0 @@\n-\n-    \/**\n-     * Some implementations required reduction operations to be requested\n-     * by the client at certain times. This method reduces the representation.\n-     *\n-     * @return this\n-     *\/\n-    MutableIntegerModuloP setReduced();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/MutableIntegerModuloP.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n- * to multiplication must be less than 32 bits. All IntegerPolynomial\n- * implementations allow at most one addition before multiplication. Additions\n- * after that will result in an ArithmeticException.\n+ * to multiplication must be less than 32 bits.\n@@ -555,4 +553,0 @@\n-        protected boolean isSummand() {\n-            return numAdds < maxAdds;\n-        }\n-\n@@ -562,3 +556,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -599,1 +603,12 @@\n-            Element b = (Element) genB;\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            if (b.numAdds > maxAdds) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n+            }\n@@ -608,0 +623,6 @@\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n@@ -615,3 +636,6 @@\n-            Element other = (Element) arg;\n-            if (!(isSummand() && other.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element other = (Element)arg;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > 32 - bitsPerLimb) {\n+                reduce(limbs);\n+                numAdds = 0;\n@@ -619,0 +643,6 @@\n+\n+            if (other.numAdds > 32 - bitsPerLimb) {\n+                reduce(other.limbs);\n+                other.numAdds = 0;\n+            }\n+\n@@ -623,2 +653,4 @@\n-            if (!isSummand()) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            \/\/ Reduce if required.\n+            if (numAdds != 0) {\n+                reduce(limbs);\n+                numAdds = 0;\n@@ -626,0 +658,1 @@\n+\n@@ -696,1 +729,13 @@\n-            Element b = (Element) genB;\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            if (b.numAdds > maxAdds) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n+            }\n+\n@@ -704,1 +749,7 @@\n-            int value = ((Limb) v).value;\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            int value = ((Limb)v).value;\n@@ -713,3 +764,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -729,3 +790,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -744,0 +815,6 @@\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n@@ -756,7 +833,0 @@\n-\n-        @Override\n-        public MutableElement setReduced() {\n-            reduce(limbs);\n-            numAdds = 0;\n-            return this;\n-        }\n@@ -793,2 +863,0 @@\n-\n-\n@@ -796,0 +864,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":102,"deletions":33,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -309,1 +309,0 @@\n-        p.getY().setReduced();\n@@ -320,1 +319,0 @@\n-        t2.setReduced();\n@@ -324,1 +322,0 @@\n-        p.getZ().setReduced();\n@@ -371,1 +368,0 @@\n-        p.getX().setReduced();\n@@ -385,1 +381,0 @@\n-        p.getX().setReduced();\n@@ -395,1 +390,0 @@\n-        t2.setReduced();\n@@ -399,1 +393,0 @@\n-        p.getY().setReduced();\n@@ -452,1 +445,0 @@\n-        p.getY().setReduced();\n@@ -459,1 +451,0 @@\n-        p.getX().setReduced();\n@@ -466,1 +457,0 @@\n-        t2.setReduced();\n@@ -470,1 +460,0 @@\n-        p.getY().setReduced();\n@@ -490,1 +479,0 @@\n-\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-        t2.setValue(p.getX()).setSum(p.getY()).setReduced();\n+        t2.setValue(p.getX()).setSum(p.getY());\n@@ -201,1 +201,1 @@\n-        t1.setValue(p.getX()).setDifference(p.getY()).setReduced();\n+        t1.setValue(p.getX()).setDifference(p.getY());\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        p1.getX().setDifference(t1).setReduced().setDifference(p1.getY());\n+        p1.getX().setDifference(t1).setDifference(p1.getY());\n@@ -188,1 +188,1 @@\n-        t1.setValue(t2).setSum(p.getY()).setReduced();\n+        t1.setValue(t2).setSum(p.getY());\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-        \/\/ need to be reduced before output conversion\n-        S.setReduced();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAOperations.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,7 +261,0 @@\n-\n-        @Override\n-        public MutableElement setReduced() {\n-            \/\/ do nothing\n-            return this;\n-        }\n-\n","filename":"test\/jdk\/sun\/security\/util\/math\/BigIntegerModuloP.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-                int numAdds = field.getMaxAdds();\n+                int numAdds = 10;   \/\/ check for addition overflow\n","filename":"test\/jdk\/sun\/security\/util\/math\/TestIntegerModuloP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class KeyPairGenerators {\n+    private KeyPairGenerator kpg;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(256);\n+    }\n+\n+    @Benchmark\n+    public KeyPair keyPairGen() {\n+        return kpg.generateKeyPair();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/KeyPairGenerators.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.*;\n+import java.security.spec.ECGenParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 3)\n+public class Signatures {\n+    private Signature signer;\n+\n+    @Param({\"64\", \"512\", \"2048\", \"16384\"})\n+    private int messageLength;\n+\n+    @Param({\"secp256r1\", \"secp384r1\", \"secp521r1\", \"Ed25519\", \"Ed448\"})\n+    private String curveName;\n+\n+    private byte[] message;\n+\n+    record CurveSpec(String curveName, String signName) {\n+        \/\/ blank\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        message = new byte[messageLength];\n+        (new Random(System.nanoTime())).nextBytes(message);\n+\n+        String signName = switch (curveName) {\n+            case \"secp256r1\" -> \"Sha256WithECDSA\";\n+            case \"secp384r1\" -> \"Sha384WithECDSA\";\n+            case \"secp521r1\" -> \"Sha512WithECDSA\";\n+            case \"Ed25519\" -> \"Ed25519\";\n+            case \"Ed448\" -> \"Ed448\";\n+            default -> throw new RuntimeException();\n+        };\n+\n+        KeyPair kp;\n+        if (curveName.startsWith(\"secp\")) {\n+            AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n+            params.init(new ECGenParameterSpec(curveName));\n+            ECGenParameterSpec ecParams =\n+                    params.getParameterSpec(ECGenParameterSpec.class);\n+\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n+            kpg.initialize(ecParams);\n+            kp = kpg.generateKeyPair();\n+        } else {\n+            KeyPairGenerator kpg =\n+                    KeyPairGenerator.getInstance(curveName, \"SunEC\");\n+            NamedParameterSpec spec = new NamedParameterSpec(curveName);\n+            kpg.initialize(spec);\n+            kp = kpg.generateKeyPair();\n+        }\n+\n+        signer = Signature.getInstance(signName, \"SunEC\");\n+        signer.initSign(kp.getPrivate());\n+    }\n+\n+    @Benchmark\n+    public byte[] sign() throws SignatureException {\n+        signer.update(message);\n+        return signer.sign();\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/Signatures.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}