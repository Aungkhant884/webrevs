{"files":[{"patch":"@@ -57,1 +57,3 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+  log_info(cds)(\"Parsing %s%s\", file,\n+                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n@@ -76,0 +78,1 @@\n+  _parse_mode = parse_mode;\n@@ -107,0 +110,4 @@\n+    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,7 @@\n+public:\n+  enum ParseMode {\n+    _parse_all,\n+    _parse_lambda_forms_invokers_only,\n+  };\n+\n+private:\n@@ -110,0 +117,1 @@\n+  ParseMode           _parse_mode;\n@@ -127,2 +135,1 @@\n-public:\n-  ClassListParser(const char* file);\n+  ClassListParser(const char* file, ParseMode _parse_mode);\n@@ -131,0 +138,6 @@\n+public:\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+    ClassListParser parser(classlist_path, parse_mode);\n+    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -736,0 +736,27 @@\n+void MetaspaceShared::get_default_classlist(char* default_classlist, const size_t buf_size) {\n+  \/\/ Construct the path to the class list (in jre\/lib)\n+  \/\/ Walk up two directories from the location of the VM and\n+  \/\/ optionally tack on \"lib\" (depending on platform)\n+  os::jvm_path(default_classlist, (jint)(buf_size));\n+  for (int i = 0; i < 3; i++) {\n+    char *end = strrchr(default_classlist, *os::file_separator());\n+    if (end != NULL) *end = '\\0';\n+  }\n+  size_t classlist_path_len = strlen(default_classlist);\n+  if (classlist_path_len >= 3) {\n+    if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+      if (classlist_path_len < buf_size - 4) {\n+        jio_snprintf(default_classlist + classlist_path_len,\n+                     buf_size - classlist_path_len,\n+                     \"%slib\", os::file_separator());\n+        classlist_path_len += 4;\n+      }\n+    }\n+  }\n+  if (classlist_path_len < buf_size - 10) {\n+    jio_snprintf(default_classlist + classlist_path_len,\n+                 buf_size - classlist_path_len,\n+                 \"%sclasslist\", os::file_separator());\n+  }\n+}\n+\n@@ -740,0 +767,1 @@\n+  get_default_classlist(default_classlist, sizeof(default_classlist));\n@@ -741,24 +769,0 @@\n-    \/\/ Construct the path to the class list (in jre\/lib)\n-    \/\/ Walk up two directories from the location of the VM and\n-    \/\/ optionally tack on \"lib\" (depending on platform)\n-    os::jvm_path(default_classlist, sizeof(default_classlist));\n-    for (int i = 0; i < 3; i++) {\n-      char *end = strrchr(default_classlist, *os::file_separator());\n-      if (end != NULL) *end = '\\0';\n-    }\n-    int classlist_path_len = (int)strlen(default_classlist);\n-    if (classlist_path_len >= 3) {\n-      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n-        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n-          jio_snprintf(default_classlist + classlist_path_len,\n-                       sizeof(default_classlist) - classlist_path_len,\n-                       \"%slib\", os::file_separator());\n-          classlist_path_len += 4;\n-        }\n-      }\n-    }\n-    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n-      jio_snprintf(default_classlist + classlist_path_len,\n-                   sizeof(default_classlist) - classlist_path_len,\n-                   \"%sclasslist\", os::file_separator());\n-    }\n@@ -772,1 +776,2 @@\n-  int class_count = parse_classlist(classlist_path, CHECK);\n+  int class_count = ClassListParser::parse_classlist(classlist_path,\n+                                                     ClassListParser::_parse_all, CHECK);\n@@ -774,1 +779,10 @@\n-    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                                    ClassListParser::_parse_all, CHECK);\n+  }\n+  if (classlist_path != default_classlist) {\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      \/\/ File exists, let's use it.\n+      class_count += ClassListParser::parse_classlist(default_classlist,\n+                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n@@ -817,6 +831,0 @@\n-\n-int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n-  ClassListParser parser(classlist_path);\n-  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -91,3 +91,0 @@\n-  static int parse_classlist(const char * classlist_path,\n-                              TRAPS) NOT_CDS_RETURN_(0);\n-\n@@ -205,0 +202,1 @@\n+  static void get_default_classlist(char* default_classlist, const size_t buf_size);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+ -runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -748,0 +748,33 @@\n+\n+    public static void stdoutMustMatch(OutputAnalyzer a, OutputAnalyzer b) {\n+        linesMustMatch(a.getStdout().split(\"\\n\"),\n+                             b.getStdout().split(\"\\n\"));\n+    }\n+\n+    public static void linesMustMatch(String a[], String b[]) {\n+        int limit = Math.min(a.length, b.length);\n+\n+        \/\/ Check the lines that are in both a[] and b[]\n+        for (int i = 0; i < limit; i++) {\n+            if (!a[i].equals(b[i])) {\n+                System.out.println(\"a:\" + i + \" \" + a[i]);\n+                System.out.println(\"b:\" + i + \" \" + b[i]);\n+                throw new RuntimeException(\"Output mismatch on line \" + i\n+                                           + \": a=\" + a[i]\n+                                           + \", b=\" + b[i]);\n+            }\n+        }\n+\n+        \/\/ Report the first line that is in one array but not in the other\n+        if (a.length > b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=\" + a[limit]\n+                                       + \", b=<none>\");\n+\n+        }\n+        if (a.length < b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=<none>\"\n+                                       + \", b=\" + b[limit]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295102\n+ * @summary Always load the lambda-form-invoker lines from default classlist\n+ * @requires vm.cds\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build DefaultClassListLFInvokers\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             DefaultClassListLFInvokersApp DefaultClassListLFInvokersApp$CompMethods\n+ * @run driver DefaultClassListLFInvokers\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class DefaultClassListLFInvokers {\n+    static final String appClass = DefaultClassListLFInvokersApp.class.getName();\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+\n+    static final String[] classlist = {\n+        appClass,\n+        \/\/ If we have at least one line of @lambda-form-invoker in the classlist, it triggers\n+        \/\/ the regeneration of the 4 XXX$Holder during -Xshare:dump.\n+        \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L_V\"\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        File classListFile = CDSTestUtils.makeClassList(classlist);\n+\n+        OutputAnalyzer dump =\n+            CDSTestUtils.createArchive(\"-XX:SharedClassListFile=\" + classListFile.getPath(),\n+                                       \"-cp\", appJar);\n+        CDSTestUtils.checkDump(dump);\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addSuffix(\"-showversion\", \"-Xlog:cds:stderr\", \"-cp\", appJar, appClass)\n+            .setUseVersion(false);\n+\n+        opts.setXShareMode(\"auto\");\n+        opts.setUseSystemArchive(false);\n+        OutputAnalyzer withcds = CDSTestUtils.run(opts).getOutput();\n+        withcds.shouldContain(DefaultClassListLFInvokersApp.FLAG);\n+        withcds.shouldHaveExitValue(0);\n+\n+        opts.setXShareMode(\"off\");\n+        opts.setUseSystemArchive(true);\n+        OutputAnalyzer nocds = CDSTestUtils.run(opts).getOutput();\n+        nocds.shouldContain(DefaultClassListLFInvokersApp.FLAG);\n+        withcds.shouldHaveExitValue(0);\n+\n+        \/\/ Make sure we still have all the LF invoker methods as when CDS is disabled,\n+        \/\/ in which case the XXX$Holder classes are loaded from $JAVA_HOME\/lib\/modules\n+\n+        System.out.println(\"\\n\\n============================== Checking output: withcds vs nocds\");\n+        TestCommon.stdoutMustMatch(withcds, nocds);\n+\n+        opts.setXShareMode(\"auto\");\n+        opts.setUseSystemArchive(true);\n+        OutputAnalyzer defcds = CDSTestUtils.run(opts).getOutput();\n+        defcds.shouldContain(DefaultClassListLFInvokersApp.FLAG);\n+        withcds.shouldHaveExitValue(0);\n+\n+        \/\/ We should also have all the LF invoker methods as when the default CDS archive is used\n+        \/\/ in which case the XXX$Holder classes are loaded from the default archive,\n+        \/\/ e.g., $JAVA_HOME\/lib\/server\/classes.jsa\n+\n+        System.out.println(\"\\n\\n============================== Checking output: withcds vs defcds\");\n+        TestCommon.stdoutMustMatch(withcds, defcds);\n+    }\n+}\n+\n+class DefaultClassListLFInvokersApp {\n+    public static final String FLAG = \"Test Success!\";\n+\n+    static class CompMethods implements Comparator<Method> {\n+        public int compare(Method a, Method b) {\n+            return a.toString().compareTo(b.toString());\n+        }\n+    }\n+    static final CompMethods compMethods = new CompMethods();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"java.lang.invoke.Invokers$Holder\");\n+        test(\"java.lang.invoke.DirectMethodHandle$Holder\");\n+        test(\"java.lang.invoke.DelegatingMethodHandle$Holder\");\n+        test(\"java.lang.invoke.LambdaForm$Holder\");\n+        System.out.println(FLAG);\n+    }\n+\n+    static void test(String className) throws Exception {\n+        Class c = Class.forName(className);\n+        Method[] methods = c.getDeclaredMethods();\n+        System.out.println(\"Dumping all methods in \" + c);\n+        Arrays.sort(methods, 0, methods.length, compMethods);\n+        for (Method m : methods) {\n+            System.out.println(m);\n+        }\n+        System.out.println(\"Found \" + methods.length + \" methods\\n\\n\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -207,0 +207,4 @@\n+\n+        public OutputAnalyzer getOutput() {\n+            return output;\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}