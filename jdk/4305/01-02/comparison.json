{"files":[{"patch":"@@ -94,1 +94,0 @@\n-public:\n@@ -96,0 +95,36 @@\n+  \/\/ Returns whether the given humongous object defined by the start region index\n+  \/\/ is reclaimable.\n+  \/\/\n+  \/\/ At this point in the garbage collection, checking whether the humongous object\n+  \/\/ is still a candidate is sufficient because:\n+  \/\/\n+  \/\/ - if it has not been a candidate at the start of collection, it will never\n+  \/\/ changed to be a candidate during the gc (and live).\n+  \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n+  \/\/ references will set the candidate state to false.\n+  \/\/ - there can be no references from within humongous starts regions referencing\n+  \/\/ the object because we never allocate other objects into them.\n+  \/\/ (I.e. there can be no intra-region references)\n+  \/\/\n+  \/\/ It is not required to check whether the object has been found dead by marking\n+  \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n+  \/\/ all objects allocated during that time are considered live.\n+  \/\/ SATB marking is even more conservative than the remembered set.\n+  \/\/ So if at this point in the collection we did not find a reference during gc\n+  \/\/ (or it had enough references to not be a candidate, having many remembered\n+  \/\/ set entries), nobody has a reference to it.\n+  \/\/ At the start of collection we flush all refinement logs, and remembered sets\n+  \/\/ are completely up-to-date wrt to references to the humongous object.\n+  \/\/\n+  \/\/ So there is no need to re-check remembered set size of the humongous region.\n+  \/\/\n+  \/\/ Other implementation considerations:\n+  \/\/ - never consider object arrays at this time because they would pose\n+  \/\/ considerable effort for cleaning up the the remembered sets. This is\n+  \/\/ required because stale remembered sets might reference locations that\n+  \/\/ are currently allocated into.\n+  bool is_reclaimable(uint region_idx) const {\n+    return G1CollectedHeap::heap()->is_humongous_reclaim_candidate(region_idx);\n+  }\n+\n+public:\n@@ -107,33 +142,0 @@\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-\n-    oop obj = cast_to_oop(r->bottom());\n-\n-    \/\/ The following check whether the humongous object is live is sufficient.\n-    \/\/\n-    \/\/ A humongous object can only be live if it is (still) a humongous reclaim\n-    \/\/ candidate because:\n-    \/\/ - if it has not been a candidate at the start of collection, it will never\n-    \/\/ be a candidate (and live).\n-    \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n-    \/\/ references will set the candidate state to false.\n-    \/\/ - there can be no references from within humongous starts regions referencing\n-    \/\/ the object because we never allocate other objects into them.\n-    \/\/ (I.e. there can be no intra-region references)\n-    \/\/\n-    \/\/ It is not required to check whether the object has been found dead by marking\n-    \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n-    \/\/ all objects allocated during that time are considered live.\n-    \/\/ SATB marking is even more conservative than the remembered set.\n-    \/\/ So if at this point in the collection we did not find a reference during gc\n-    \/\/ (or it had enough references to not be a candidate, having many remembered\n-    \/\/ set entries), nobody has a reference to it.\n-    \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-    \/\/ are completely up-to-date wrt to references to the humongous object.\n-    \/\/\n-    \/\/ So there is no need to re-check remembered set size of the humongous region.\n-    \/\/\n-    \/\/ Other implementation considerations:\n-    \/\/ - never consider object arrays at this time because they would pose\n-    \/\/ considerable effort for cleaning up the the remembered sets. This is\n-    \/\/ required because stale remembered sets might reference locations that\n-    \/\/ are currently allocated into.\n@@ -141,1 +143,1 @@\n-    if (!g1h->is_humongous_reclaim_candidate(region_idx)) {\n+    if (!is_reclaimable(region_idx)) {\n@@ -145,0 +147,1 @@\n+    oop obj = cast_to_oop(r->bottom());\n@@ -149,0 +152,1 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"}]}