{"files":[{"patch":"@@ -3396,0 +3396,10 @@\n+      log_debug(gc, humongous)(\"Humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \") remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" marked %d reclaim candidate %d type array %d\",\n+                               index,\n+                               (size_t)cast_to_oop(hr->bottom())->size() * HeapWordSize,\n+                               p2i(hr->bottom()),\n+                               hr->rem_set()->occupied(),\n+                               hr->rem_set()->strong_code_roots_list_length(),\n+                               _g1h->concurrent_mark()->next_mark_bitmap()->is_marked(hr->bottom()),\n+                               _g1h->is_humongous_reclaim_candidate(index),\n+                               cast_to_oop(hr->bottom())->is_typeArray()\n+                              );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-public:\n@@ -96,0 +95,36 @@\n+  \/\/ Returns whether the given humongous object defined by the start region index\n+  \/\/ is reclaimable.\n+  \/\/\n+  \/\/ At this point in the garbage collection, checking whether the humongous object\n+  \/\/ is still a candidate is sufficient because:\n+  \/\/\n+  \/\/ - if it has not been a candidate at the start of collection, it will never\n+  \/\/ changed to be a candidate during the gc (and live).\n+  \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n+  \/\/ references will set the candidate state to false.\n+  \/\/ - there can be no references from within humongous starts regions referencing\n+  \/\/ the object because we never allocate other objects into them.\n+  \/\/ (I.e. there can be no intra-region references)\n+  \/\/\n+  \/\/ It is not required to check whether the object has been found dead by marking\n+  \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n+  \/\/ all objects allocated during that time are considered live.\n+  \/\/ SATB marking is even more conservative than the remembered set.\n+  \/\/ So if at this point in the collection we did not find a reference during gc\n+  \/\/ (or it had enough references to not be a candidate, having many remembered\n+  \/\/ set entries), nobody has a reference to it.\n+  \/\/ At the start of collection we flush all refinement logs, and remembered sets\n+  \/\/ are completely up-to-date wrt to references to the humongous object.\n+  \/\/\n+  \/\/ So there is no need to re-check remembered set size of the humongous region.\n+  \/\/\n+  \/\/ Other implementation considerations:\n+  \/\/ - never consider object arrays at this time because they would pose\n+  \/\/ considerable effort for cleaning up the the remembered sets. This is\n+  \/\/ required because stale remembered sets might reference locations that\n+  \/\/ are currently allocated into.\n+  bool is_reclaimable(uint region_idx) const {\n+    return G1CollectedHeap::heap()->is_humongous_reclaim_candidate(region_idx);\n+  }\n+\n+public:\n@@ -107,33 +142,0 @@\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-\n-    oop obj = cast_to_oop(r->bottom());\n-    G1CMBitMap* next_bitmap = g1h->concurrent_mark()->next_mark_bitmap();\n-\n-    \/\/ The following checks whether the humongous object is live are sufficient.\n-    \/\/ The main additional check (in addition to having a reference from the roots\n-    \/\/ or the young gen) is whether the humongous object has a remembered set entry.\n-    \/\/\n-    \/\/ A humongous object cannot be live if there is no remembered set for it\n-    \/\/ because:\n-    \/\/ - there can be no references from within humongous starts regions referencing\n-    \/\/ the object because we never allocate other objects into them.\n-    \/\/ (I.e. there are no intra-region references that may be missed by the\n-    \/\/ remembered set)\n-    \/\/ - as soon there is a remembered set entry to the humongous starts region\n-    \/\/ (i.e. it has \"escaped\" to an old object) this remembered set entry will stay\n-    \/\/ until the end of a concurrent mark.\n-    \/\/\n-    \/\/ It is not required to check whether the object has been found dead by marking\n-    \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n-    \/\/ all objects allocated during that time are considered live.\n-    \/\/ SATB marking is even more conservative than the remembered set.\n-    \/\/ So if at this point in the collection there is no remembered set entry,\n-    \/\/ nobody has a reference to it.\n-    \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-    \/\/ are completely up-to-date wrt to references to the humongous object.\n-    \/\/\n-    \/\/ Other implementation considerations:\n-    \/\/ - never consider object arrays at this time because they would pose\n-    \/\/ considerable effort for cleaning up the the remembered sets. This is\n-    \/\/ required because stale remembered sets might reference locations that\n-    \/\/ are currently allocated into.\n@@ -141,12 +143,1 @@\n-    if (!g1h->is_humongous_reclaim_candidate(region_idx) ||\n-        !r->rem_set()->is_empty()) {\n-      log_debug(gc, humongous)(\"Live humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \"  with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                               region_idx,\n-                               (size_t)obj->size() * HeapWordSize,\n-                               p2i(r->bottom()),\n-                               r->rem_set()->occupied(),\n-                               r->rem_set()->strong_code_roots_list_length(),\n-                               next_bitmap->is_marked(r->bottom()),\n-                               g1h->is_humongous_reclaim_candidate(region_idx),\n-                               obj->is_typeArray()\n-                              );\n+    if (!is_reclaimable(region_idx)) {\n@@ -156,0 +147,1 @@\n+    oop obj = cast_to_oop(r->bottom());\n@@ -160,11 +152,1 @@\n-    log_debug(gc, humongous)(\"Dead humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \" with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                             region_idx,\n-                             (size_t)obj->size() * HeapWordSize,\n-                             p2i(r->bottom()),\n-                             r->rem_set()->occupied(),\n-                             r->rem_set()->strong_code_roots_list_length(),\n-                             next_bitmap->is_marked(r->bottom()),\n-                             g1h->is_humongous_reclaim_candidate(region_idx),\n-                             obj->is_typeArray()\n-                            );\n-\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -189,0 +171,5 @@\n+    log_debug(gc, humongous)(\"Reclaimed humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \")\",\n+                             region_idx,\n+                             (size_t)obj->size() * HeapWordSize,\n+                             p2i(r->bottom())\n+                            );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":44,"deletions":57,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    System.out.println(output.getStdout());\n@@ -63,2 +64,2 @@\n-    output.shouldContain(\"Live humongous\");\n-    output.shouldContain(\"Dead humongous region\");\n+    output.shouldContain(\"Humongous region\");\n+    output.shouldContain(\"Reclaimed humongous region\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1TraceEagerReclaimHumongousObjects.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}