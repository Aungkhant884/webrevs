{"files":[{"patch":"@@ -3396,0 +3396,10 @@\n+      log_debug(gc, humongous)(\"Humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \") remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" marked %d reclaim candidate %d type array %d\",\n+                               index,\n+                               (size_t)cast_to_oop(hr->bottom())->size() * HeapWordSize,\n+                               p2i(hr->bottom()),\n+                               hr->rem_set()->occupied(),\n+                               hr->rem_set()->strong_code_roots_list_length(),\n+                               _g1h->concurrent_mark()->next_mark_bitmap()->is_marked(hr->bottom()),\n+                               _g1h->is_humongous_reclaim_candidate(index),\n+                               cast_to_oop(hr->bottom())->is_typeArray()\n+                              );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-    G1CMBitMap* next_bitmap = g1h->concurrent_mark()->next_mark_bitmap();\n@@ -112,3 +111,1 @@\n-    \/\/ The following checks whether the humongous object is live are sufficient.\n-    \/\/ The main additional check (in addition to having a reference from the roots\n-    \/\/ or the young gen) is whether the humongous object has a remembered set entry.\n+    \/\/ The following check whether the humongous object is live is sufficient.\n@@ -116,2 +113,6 @@\n-    \/\/ A humongous object cannot be live if there is no remembered set for it\n-    \/\/ because:\n+    \/\/ A humongous object can only be live if it is (still) a humongous reclaim\n+    \/\/ candidate because:\n+    \/\/ - if it has not been a candidate at the start of collection, it will never\n+    \/\/ be a candidate (and live).\n+    \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n+    \/\/ references will set the candidate state to false.\n@@ -120,5 +121,1 @@\n-    \/\/ (I.e. there are no intra-region references that may be missed by the\n-    \/\/ remembered set)\n-    \/\/ - as soon there is a remembered set entry to the humongous starts region\n-    \/\/ (i.e. it has \"escaped\" to an old object) this remembered set entry will stay\n-    \/\/ until the end of a concurrent mark.\n+    \/\/ (I.e. there can be no intra-region references)\n@@ -130,2 +127,3 @@\n-    \/\/ So if at this point in the collection there is no remembered set entry,\n-    \/\/ nobody has a reference to it.\n+    \/\/ So if at this point in the collection we did not find a reference during gc\n+    \/\/ (or it had enough references to not be a candidate, having many remembered\n+    \/\/ set entries), nobody has a reference to it.\n@@ -135,0 +133,2 @@\n+    \/\/ So there is no need to re-check remembered set size of the humongous region.\n+    \/\/\n@@ -141,12 +141,1 @@\n-    if (!g1h->is_humongous_reclaim_candidate(region_idx) ||\n-        !r->rem_set()->is_empty()) {\n-      log_debug(gc, humongous)(\"Live humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \"  with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                               region_idx,\n-                               (size_t)obj->size() * HeapWordSize,\n-                               p2i(r->bottom()),\n-                               r->rem_set()->occupied(),\n-                               r->rem_set()->strong_code_roots_list_length(),\n-                               next_bitmap->is_marked(r->bottom()),\n-                               g1h->is_humongous_reclaim_candidate(region_idx),\n-                               obj->is_typeArray()\n-                              );\n+    if (!g1h->is_humongous_reclaim_candidate(region_idx)) {\n@@ -160,11 +149,0 @@\n-    log_debug(gc, humongous)(\"Dead humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \" with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                             region_idx,\n-                             (size_t)obj->size() * HeapWordSize,\n-                             p2i(r->bottom()),\n-                             r->rem_set()->occupied(),\n-                             r->rem_set()->strong_code_roots_list_length(),\n-                             next_bitmap->is_marked(r->bottom()),\n-                             g1h->is_humongous_reclaim_candidate(region_idx),\n-                             obj->is_typeArray()\n-                            );\n-\n@@ -189,0 +167,5 @@\n+    log_debug(gc, humongous)(\"Reclaimed humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \")\",\n+                             region_idx,\n+                             (size_t)obj->size() * HeapWordSize,\n+                             p2i(r->bottom())\n+                            );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    System.out.println(output.getStdout());\n@@ -63,2 +64,2 @@\n-    output.shouldContain(\"Live humongous\");\n-    output.shouldContain(\"Dead humongous region\");\n+    output.shouldContain(\"Humongous region\");\n+    output.shouldContain(\"Reclaimed humongous region\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1TraceEagerReclaimHumongousObjects.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}