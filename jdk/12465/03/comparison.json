{"files":[{"patch":"@@ -747,0 +747,140 @@\n+        }\n+    }\n+\n+    \/**\n+     * Return the (natural) logarithm of x\n+     *\n+     * Method :\n+     *   1. Argument Reduction: find k and f such that\n+     *                      x = 2^k * (1+f),\n+     *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+     *\n+     *   2. Approximation of log(1+f).\n+     *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+     *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+     *               = 2s + s*R\n+     *      We use a special Reme algorithm on [0,0.1716] to generate\n+     *      a polynomial of degree 14 to approximate R The maximum error\n+     *      of this polynomial approximation is bounded by 2**-58.45. In\n+     *      other words,\n+     *                      2      4      6      8      10      12      14\n+     *          R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s\n+     *      (the values of Lg1 to Lg7 are listed in the program)\n+     *      and\n+     *          |      2          14          |     -58.45\n+     *          | Lg1*s +...+Lg7*s    -  R(z) | <= 2\n+     *          |                             |\n+     *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+     *      In order to guarantee error in log below 1ulp, we compute log\n+     *      by\n+     *              log(1+f) = f - s*(f - R)        (if f is not too large)\n+     *              log(1+f) = f - (hfsq - s*(hfsq+R)).     (better accuracy)\n+     *\n+     *      3. Finally,  log(x) = k*ln2 + log(1+f).\n+     *                          = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+     *         Here ln2 is split into two floating point number:\n+     *                      ln2_hi + ln2_lo,\n+     *         where n*ln2_hi is always exact for |n| < 2000.\n+     *\n+     * Special cases:\n+     *      log(x) is NaN with signal if x < 0 (including -INF) ;\n+     *      log(+INF) is +INF; log(0) is -INF with signal;\n+     *      log(NaN) is that NaN with no signal.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static final class Log {\n+        private Log() {throw new UnsupportedOperationException();}\n+\n+        private static final double\n+            ln2_hi = 0x1.62e42feep-1,       \/\/ 6.93147180369123816490e-01\n+            ln2_lo = 0x1.a39ef35793c76p-33, \/\/ 1.90821492927058770002e-10\n+\n+            Lg1    = 0x1.5555555555593p-1,  \/\/ 6.666666666666735130e-01\n+            Lg2    = 0x1.999999997fa04p-2,  \/\/ 3.999999999940941908e-01\n+            Lg3    = 0x1.2492494229359p-2,  \/\/ 2.857142874366239149e-01\n+            Lg4    = 0x1.c71c51d8e78afp-3,  \/\/ 2.222219843214978396e-01\n+            Lg5    = 0x1.7466496cb03dep-3,  \/\/ 1.818357216161805012e-01\n+            Lg6    = 0x1.39a09d078c69fp-3,  \/\/ 1.531383769920937332e-01\n+            Lg7    = 0x1.2f112df3e5244p-3;  \/\/ 1.479819860511658591e-01\n+\n+        private static final double zero = 0.0;\n+\n+        static double compute(double x) {\n+            double hfsq, f, s, z, R, w, t1, t2, dk;\n+            int k, hx, i, j;\n+            \/*unsigned*\/ int lx;\n+\n+            hx = __HI(x);           \/\/ high word of x\n+            lx = __LO(x);           \/\/ low  word of x\n+\n+            k=0;\n+            if (hx < 0x0010_0000) {                  \/\/ x < 2**-1022\n+                if (((hx & 0x7fff_ffff) | lx) == 0) { \/\/ log(+-0) = -inf\n+                    return -TWO54\/zero;\n+                }\n+                if (hx < 0) {                        \/\/ log(-#) = NaN\n+                    return (x - x)\/zero;\n+                }\n+                k -= 54;\n+                x *= TWO54;    \/\/ subnormal number, scale up x\n+                hx = __HI(x);  \/\/ high word of x\n+            }\n+            if (hx >= 0x7ff0_0000) {\n+                return x + x;\n+            }\n+            k += (hx >> 20) - 1023;\n+            hx &= 0x000f_ffff;\n+            i = (hx + 0x9_5f64) & 0x10_0000;\n+            x =__HI(x, hx | (i ^ 0x3ff0_0000));  \/\/ normalize x or x\/2\n+            k += (i >> 20);\n+            f = x - 1.0;\n+            if ((0x000f_ffff & (2 + hx)) < 3) {\/\/ |f| < 2**-20\n+                if (f == zero) {\n+                    if (k == 0) {\n+                        return zero;\n+                    } else {\n+                        dk = (double)k;\n+                        return dk*ln2_hi + dk*ln2_lo;\n+                    }\n+                }\n+                R = f*f*(0.5 - 0.33333333333333333*f);\n+                if (k == 0) {\n+                    return f - R;\n+                } else {\n+                    dk = (double)k;\n+                    return dk*ln2_hi - ((R - dk*ln2_lo) - f);\n+                }\n+            }\n+            s = f\/(2.0 + f);\n+            dk = (double)k;\n+            z = s*s;\n+            i = hx - 0x6_147a;\n+            w = z*z;\n+            j = 0x6b851 - hx;\n+            t1= w*(Lg2 + w*(Lg4 + w*Lg6));\n+            t2= z*(Lg1 + w*(Lg3 + w*(Lg5 + w*Lg7)));\n+            i |= j;\n+            R = t2 + t1;\n+            if (i > 0) {\n+                hfsq = 0.5*f*f;\n+                if (k == 0) {\n+                    return f-(hfsq - s*(hfsq + R));\n+                } else {\n+                    return dk*ln2_hi - ((hfsq - (s*(hfsq + R) + dk*ln2_lo)) - f);\n+                }\n+            } else {\n+                if (k == 0) {\n+                    return f - s*(f - R);\n+                } else {\n+                    return dk*ln2_hi - ((s*(f - R) - dk*ln2_lo) - f);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -262,1 +262,3 @@\n-    public static native double log(double a);\n+    public static double log(double a) {\n+        return FdLibm.Log.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301202\n+ * @build Tests\n+ * @build LogTests\n+ * @run main LogTests\n+ * @summary Tests for {Math, StrictMath}.log\n+ *\/\n+\n+public class LogTests {\n+    private LogTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testLogSpecialCases();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing log incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double infinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd = Double.NaN;\n+\n+    \/**\n+     * From the spec for Math.log:\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN or less than zero, then the result is NaN.\n+     * If the argument is positive infinity, then the result is positive infinity.\n+     * If the argument is positive zero or negative zero, then the result is negative infinity.\n+     * If the argument is 1.0, then the result is positive zero.\n+     *\/\n+    private static int testLogSpecialCases() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {Double.NaN,                NaNd},\n+            {Double.NEGATIVE_INFINITY,  NaNd},\n+            {-Double.MAX_VALUE,         NaNd},\n+            {-1.0,                      NaNd},\n+            {-Double.MIN_NORMAL,        NaNd},\n+            {-Double.MIN_VALUE,         NaNd},\n+\n+            {Double.POSITIVE_INFINITY,  infinityD},\n+\n+            {-0.0,                      -infinityD},\n+            {+0.0,                      -infinityD},\n+\n+            {+1.0,                      0.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testLogCase(testCases[i][0],\n+                                    testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testLogCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.log\",       input, Math::log,       expected);\n+        failures+=Tests.test(\"StrictMath.log\", input, StrictMath::log, expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/LogTests.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -81,0 +81,4 @@\n+    public static double log(double x) {\n+        return Log.compute(x);\n+    }\n+\n@@ -404,0 +408,119 @@\n+    \/**\n+     * Return the logarithm of x\n+     *\n+     * Method :\n+     *   1. Argument Reduction: find k and f such that\n+     *                      x = 2^k * (1+f),\n+     *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+     *\n+     *   2. Approximation of log(1+f).\n+     *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+     *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+     *               = 2s + s*R\n+     *      We use a special Reme algorithm on [0,0.1716] to generate\n+     *      a polynomial of degree 14 to approximate R The maximum error\n+     *      of this polynomial approximation is bounded by 2**-58.45. In\n+     *      other words,\n+     *                      2      4      6      8      10      12      14\n+     *          R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s\n+     *      (the values of Lg1 to Lg7 are listed in the program)\n+     *      and\n+     *          |      2          14          |     -58.45\n+     *          | Lg1*s +...+Lg7*s    -  R(z) | <= 2\n+     *          |                             |\n+     *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+     *      In order to guarantee error in log below 1ulp, we compute log\n+     *      by\n+     *              log(1+f) = f - s*(f - R)        (if f is not too large)\n+     *              log(1+f) = f - (hfsq - s*(hfsq+R)).     (better accuracy)\n+     *\n+     *      3. Finally,  log(x) = k*ln2 + log(1+f).\n+     *                          = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+     *         Here ln2 is split into two floating point number:\n+     *                      ln2_hi + ln2_lo,\n+     *         where n*ln2_hi is always exact for |n| < 2000.\n+     *\n+     * Special cases:\n+     *      log(x) is NaN with signal if x < 0 (including -INF) ;\n+     *      log(+INF) is +INF; log(0) is -INF with signal;\n+     *      log(NaN) is that NaN with no signal.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    private static final class Log {\n+        private static final  double\n+            ln2_hi  =  6.93147180369123816490e-01,  \/* 3fe62e42 fee00000 *\/\n+            ln2_lo  =  1.90821492927058770002e-10,  \/* 3dea39ef 35793c76 *\/\n+            two54   =  1.80143985094819840000e+16,  \/* 43500000 00000000 *\/\n+            Lg1 = 6.666666666666735130e-01,  \/* 3FE55555 55555593 *\/\n+            Lg2 = 3.999999999940941908e-01,  \/* 3FD99999 9997FA04 *\/\n+            Lg3 = 2.857142874366239149e-01,  \/* 3FD24924 94229359 *\/\n+            Lg4 = 2.222219843214978396e-01,  \/* 3FCC71C5 1D8E78AF *\/\n+            Lg5 = 1.818357216161805012e-01,  \/* 3FC74664 96CB03DE *\/\n+            Lg6 = 1.531383769920937332e-01,  \/* 3FC39A09 D078C69F *\/\n+            Lg7 = 1.479819860511658591e-01;  \/* 3FC2F112 DF3E5244 *\/\n+\n+        private static double zero   =  0.0;\n+\n+        static double compute(double x) {\n+            double hfsq,f,s,z,R,w,t1,t2,dk;\n+            int k,hx,i,j;\n+            \/*unsigned*\/ int lx;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            lx = __LO(x);           \/* low  word of x *\/\n+\n+            k=0;\n+            if (hx < 0x00100000) {                  \/* x < 2**-1022  *\/\n+                if (((hx&0x7fffffff)|lx)==0)\n+                    return -two54\/zero;             \/* log(+-0)=-inf *\/\n+                if (hx<0) return (x-x)\/zero;        \/* log(-#) = NaN *\/\n+                k -= 54; x *= two54; \/* subnormal number, scale up x *\/\n+                hx = __HI(x);               \/* high word of x *\/\n+            }\n+            if (hx >= 0x7ff00000) return x+x;\n+            k += (hx>>20)-1023;\n+            hx &= 0x000fffff;\n+            i = (hx+0x95f64)&0x100000;\n+            \/\/ __HI(x) = hx|(i^0x3ff00000);    \/* normalize x or x\/2 *\/\n+            x =__HI(x, hx|(i^0x3ff00000));    \/* normalize x or x\/2 *\/\n+            k += (i>>20);\n+            f = x-1.0;\n+            if((0x000fffff&(2+hx))<3) {     \/* |f| < 2**-20 *\/\n+                if(f==zero) {\n+                    if (k==0) return zero;\n+                    else {dk=(double)k; return dk*ln2_hi+dk*ln2_lo;}\n+                }\n+                R = f*f*(0.5-0.33333333333333333*f);\n+                if(k==0) return f-R; else {dk=(double)k;\n+                    return dk*ln2_hi-((R-dk*ln2_lo)-f);}\n+            }\n+            s = f\/(2.0+f);\n+            dk = (double)k;\n+            z = s*s;\n+            i = hx-0x6147a;\n+            w = z*z;\n+            j = 0x6b851-hx;\n+            t1= w*(Lg2+w*(Lg4+w*Lg6));\n+            t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));\n+            i |= j;\n+            R = t2+t1;\n+            if(i>0) {\n+                hfsq=0.5*f*f;\n+                if(k==0) return f-(hfsq-s*(hfsq+R)); else\n+                    return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);\n+            } else {\n+                if(k==0) return f-s*(f-R); else\n+                    return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);\n+            }\n+        }\n+    }\n+\n@@ -467,1 +590,1 @@\n-            z  = y*log10_2lo + ivln10*StrictMath.log(x); \/\/ TOOD: switch to Translit.log when available\n+            z  = y*log10_2lo + ivln10*log(x);\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":124,"deletions":1,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301202\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build LogTests\n+ * @run main LogTests\n+ * @summary Tests for StrictMath.log\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+\n+public class LogTests {\n+    private LogTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testLog();\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing log incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static int testLogCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.log(double)\", input,\n+                          StrictMath::log, expected);\n+    }\n+\n+    \/\/ Inputs where Math.log and StrictMath.log differ for at least\n+    \/\/ one Math.log implementation.\n+    static int testLog() {\n+        int failures = 0;\n+\n+        double [][] testCases = {\n+            {0x1.000000089cd6fp-43, -0x1.dce2a0697a102p4},\n+            {0x1.0000000830698p182,  0x1.f89c7428dd67ap6},\n+            {0x1.0000000744b3ap632,  0x1.b611ab2bd53cep8},\n+            {0x1.000000037d81fp766,  0x1.0979b1dbc4a42p9},\n+            {0x1.000000024028p991,   0x1.577455642bb92p9},\n+        };\n+\n+        for (double[] testCase: testCases)\n+            failures+=testLogCase(testCase[0], testCase[1]);\n+\n+        return failures;\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.log against transliteration port of log.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+\n+        \/\/ ... and just below subnormal threshold ...\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0x1.0p-1022,\n+\n+            0x1.0p-20,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+         x = Tests.createRandomDouble(random);\n+\n+         \/\/ Make the increment twice the ulp value in case the random\n+         \/\/ value is near an exponent threshold. Don't worry about test\n+         \/\/ elements overflowing to infinity if the starting value is\n+         \/\/ near Double.MAX_VALUE.\n+         failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testLogCase(x, FdlibmTranslit.log(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testLogCase(x, FdlibmTranslit.log(x));\n+        }\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/LogTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}