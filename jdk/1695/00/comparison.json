{"files":[{"patch":"@@ -41,0 +41,6 @@\n+#ifdef ZERO\n+\/\/ See stubGenerator_zero.cpp\n+#include <setjmp.h>\n+extern sigjmp_buf* get_jmp_buf_for_continuation();\n+#endif\n+\n@@ -549,1 +555,2 @@\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n+  if (!signal_was_handled &&\n+      ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison)) {\n@@ -554,0 +561,21 @@\n+  if (!signal_was_handled) {\n+    \/\/ Handle SafeFetch access.\n+#ifndef ZERO\n+    if (uc != NULL) {\n+      address pc = os::Posix::ucontext_get_pc(uc);\n+      if (StubRoutines::is_safefetch_fault(pc)) {\n+        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+        signal_was_handled = true;\n+      }\n+    }\n+#else\n+    \/\/ See JDK-8076185\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n+      if (pjb) {\n+        siglongjmp(*pjb, 1);\n+      }\n+    }\n+#endif \/\/ ZERO\n+  }\n+\n@@ -555,1 +583,2 @@\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n+  if (!signal_was_handled &&\n+      (sig == SIGPIPE || sig == SIGXFSZ)) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -183,11 +183,0 @@\n-  \/\/ SafeFetch 32 handling:\n-  \/\/ - make it work if _thread is null\n-  \/\/ - make it use the standard os::...::ucontext_get\/set_pc APIs\n-  if (uc) {\n-    address const pc = os::Posix::ucontext_get_pc(uc);\n-    if (pc && StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -414,5 +414,0 @@\n-    if (StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,4 +60,0 @@\n-\/\/ See stubGenerator_zero.cpp\n-#include <setjmp.h>\n-extern sigjmp_buf* get_jmp_buf_for_continuation();\n-\n@@ -121,8 +117,0 @@\n-  \/\/ handle SafeFetch faults the zero way\n-  if (sig == SIGSEGV || sig == SIGBUS) {\n-    sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n-    if (pjb) {\n-      siglongjmp(*pjb, 1);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -188,5 +188,0 @@\n-    if (StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -271,4 +271,0 @@\n-      if (StubRoutines::is_safefetch_fault(pc)) {\n-        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-        return true;\n-      }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,10 +213,0 @@\n-    }\n-  }\n-\n-  \/\/ Moved SafeFetch32 handling outside thread!=NULL conditional block to make\n-  \/\/ it work if no associated JavaThread object exists.\n-  if (uc) {\n-    address const pc = os::Posix::ucontext_get_pc(uc);\n-    if (pc && StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -210,10 +210,0 @@\n-  \/\/ Moved SafeFetch32 handling outside thread!=NULL conditional block to make\n-  \/\/ it work if no associated JavaThread object exists.\n-  if (uc) {\n-    address const pc = os::Posix::ucontext_get_pc(uc);\n-    if (pc && StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -224,5 +224,0 @@\n-    if (StubRoutines::is_safefetch_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-      return true;\n-    }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,4 +56,0 @@\n-\/\/ See stubGenerator_zero.cpp\n-#include <setjmp.h>\n-extern sigjmp_buf* get_jmp_buf_for_continuation();\n-\n@@ -117,8 +113,0 @@\n-  \/\/ handle SafeFetch faults\n-  if (sig == SIGSEGV || sig == SIGBUS) {\n-    sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n-    if (pjb) {\n-      siglongjmp(*pjb, 1);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"unittest.hpp\"\n+\n+static const intptr_t pattern = LP64_ONLY(0xABCDABCDABCDABCDULL) NOT_LP64(0xABCDABCD);\n+static intptr_t* invalid_address = (intptr_t*)(intptr_t)os::min_page_size();\n+\n+TEST_VM(os, safefetch_positive) {\n+  intptr_t v = pattern;\n+  intptr_t a = SafeFetchN(&v, 1);\n+  ASSERT_EQ(v, a);\n+}\n+\n+TEST_VM(os, safefetch_negative) {\n+  intptr_t a = SafeFetchN(invalid_address, pattern);\n+  ASSERT_EQ(pattern, a);\n+  a = SafeFetchN(invalid_address, ~pattern);\n+  ASSERT_EQ(~pattern, a);\n+}\n+\n+class VM_TestSafeFetchAtSafePoint : public VM_GTestExecuteAtSafepoint {\n+public:\n+  void doit() {\n+    \/\/ Regression test for JDK-8257828\n+    \/\/ Should not crash.\n+    intptr_t a = SafeFetchN(invalid_address, pattern);\n+    ASSERT_EQ(pattern, a);\n+    a = SafeFetchN(invalid_address, ~pattern);\n+    ASSERT_EQ(~pattern, a);\n+  }\n+};\n+\n+TEST_VM(os, safefetch_negative_at_safepoint) {\n+  VM_TestSafeFetchAtSafePoint op;\n+  ThreadInVMfromNative invm(JavaThread::current());\n+  VMThread::execute(&op);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}