{"files":[{"patch":"@@ -863,0 +863,2 @@\n+  ResourceMark rm;\n+\n@@ -996,2 +998,0 @@\n-  ResourceMark rm;      \/\/ Needed for tracing.\n-\n@@ -1002,17 +1002,7 @@\n-    \/\/ The reference has already been discovered...\n-    log_develop_trace(gc, ref)(\"Already discovered reference (\" INTPTR_FORMAT \": %s)\",\n-                               p2i(obj), obj->klass()->internal_name());\n-    if (RefDiscoveryPolicy == ReferentBasedDiscovery) {\n-      \/\/ assumes that an object is not processed twice;\n-      \/\/ if it's been already discovered it must be on another\n-      \/\/ generation's discovered list; so we won't discover it.\n-      return false;\n-    } else {\n-      assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,\n-             \"Unrecognized policy\");\n-      \/\/ Check assumption that an object is not potentially\n-      \/\/ discovered twice except by concurrent collectors that potentially\n-      \/\/ trace the same Reference object twice.\n-      assert(UseG1GC, \"Only possible with a concurrent marking collector\");\n-      return true;\n-    }\n+    \/\/ A non-strong ref is \"rediscovered\". This is possible only for G1 in the\n+    \/\/ following two cases:\n+    \/\/  1. `G1CMTask::make_reference_grey` can push the same oop twice onto the\n+    \/\/     mark stack.\n+    \/\/  2. CM restarts after mark-stack overflow.\n+    assert(UseG1GC, \"inv\");\n+    return true;\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"}]}