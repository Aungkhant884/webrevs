{"files":[{"patch":"@@ -33,1 +33,1 @@\n-import java.net.http.HttpTimeoutException;\n+import java.net.http.HttpConnectTimeoutException;\n@@ -200,1 +200,1 @@\n-            HttpTimeoutException hte = new HttpTimeoutException(\"HTTP connection idle, no active streams. Shutting down.\");\n+            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\"HTTP connection idle, no active streams. Shutting down.\");\n@@ -728,1 +728,3 @@\n-            if (!(t instanceof EOFException) || isActive()) {\n+            if (idleConnectionTimeoutEvent != null) {\n+                Log.logTrace(\"idleConnectionTimeout timeout fired, shutting down connection: {0}\", t.getMessage());\n+            } else if (!(t instanceof EOFException) || isActive()) {\n@@ -1222,1 +1224,0 @@\n-                    System.err.println(\"Http2Connection: Timer Event Cancelled\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1525,1 +1525,1 @@\n-    public Optional<Duration> idleConnectionTimeout() {\n+    Optional<Duration> idleConnectionTimeout() {\n@@ -1695,3 +1695,8 @@\n-        String s = Utils.getNetProperty(\"jdk.httpclient.idleConnectionTimeout\");\n-        if (s != null)\n-            return Duration.ofMillis(Long.parseLong(s));\n+        String s = Utils.getNetProperty(\"jdk.httpclient.keepalive.timeout\");\n+        if (s != null) {\n+            try {\n+                long val = Long.parseLong(s);\n+                if (val >= 0)\n+                    return Duration.ofMillis(Long.parseLong(s));\n+            } catch (NumberFormatException ignored) {}\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,4 +26,4 @@\n- * @bug 8263031\n- * @summary Tests that the HttpClient can correctly receive a Push Promise\n- *          Frame with the END_HEADERS flag unset followed by one or more\n- *          Continuation Frames.\n+ * @bug 8288717\n+ * @summary Tests that when the idleConnectionTimeoutEvent is configured in HTTP\/2,\n+ *          an HTTP\/2 connection will close within the specified interval if there\n+ *          are no active streams on the connection.\n@@ -31,1 +31,0 @@\n- * @build jdk.test.lib.net.SimpleSSLContext\n@@ -36,1 +35,3 @@\n- * @run testng\/othervm IdleConnectionTimeoutTest\n+ * @run testng\/othervm -Djdk.httpclient.keepalive.timeout=800 IdleConnectionTimeoutTest\n+ * @run testng\/othervm -Djdk.httpclient.keepalive.timeout=100 IdleConnectionTimeoutTest\n+ * @run testng\/othervm  IdleConnectionTimeoutTest\n@@ -60,1 +61,1 @@\n-    final String IDLE_CONN_PROPERTY = \"jdk.httpclient.idleConnectionTimeout\";\n+    final String IDLE_CONN_PROPERTY = \"jdk.httpclient.keepalive.timeout\";\n@@ -63,1 +64,0 @@\n-    static boolean expectTimeout;\n@@ -81,1 +81,1 @@\n-       was made to carry out the second request by the client. Otherwise, the old connection was reused.\n+       was made to carry out the second request by the client.\n@@ -84,16 +84,3 @@\n-    public void testTimeoutFires() throws InterruptedException {\n-        expectTimeout = true;\n-        System.setProperty(IDLE_CONN_PROPERTY, \"100\");\n-        HttpClient hc = HttpClient.newBuilder().version(HTTP_2).build();\n-        HttpRequest hreq = HttpRequest.newBuilder(timeoutUri).version(HTTP_2).GET().build();\n-\n-        CompletableFuture<HttpResponse<String>> request = hc.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        HttpResponse<String> hresp = request.join();\n-        assertEquals(hresp.statusCode(), 200);\n-        \/\/ Sleep for 4x the timeout value to ensure that it occurs\n-        Thread.sleep(800);\n-\n-        request = hc.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        hresp = request.join();\n-        assertEquals(hresp.statusCode(), 200);\n-    }\n+    public void test() throws InterruptedException {\n+        String timeoutVal = System.getProperty(IDLE_CONN_PROPERTY);\n+        testLog.println(\"Test run for jdk.httpclient.keepalive.timeout=\" + timeoutVal);\n@@ -101,8 +88,1 @@\n-    \/*\n-        The opposite of testTimeoutFires(), if the same connection is used for both requests then the\n-        idleConnectionTimeoutEvent did not occur.\n-     *\/\n-    @Test\n-    public void testTimeoutDoesNotFire() throws InterruptedException {\n-        expectTimeout = false;\n-        System.setProperty(IDLE_CONN_PROPERTY, \"800\");\n+        int sleepTime = 0;\n@@ -110,1 +90,24 @@\n-        HttpRequest hreq = HttpRequest.newBuilder(noTimeoutUri).version(HTTP_2).GET().build();\n+        HttpRequest hreq;\n+        HttpResponse<String> hresp;\n+        if (timeoutVal != null) {\n+            if (timeoutVal.equals(\"100\")) {\n+                testLog.println(\"This one\");\n+                hreq = HttpRequest.newBuilder(timeoutUri).version(HTTP_2).GET().build();\n+                sleepTime = 800;\n+                hresp = runRequest(hc, hreq, sleepTime);\n+                assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent was expected but did not occur\");\n+            } else if (timeoutVal.equals(\"800\")) {\n+                testLog.println(\"This two\");\n+                hreq = HttpRequest.newBuilder(noTimeoutUri).version(HTTP_2).GET().build();\n+                sleepTime = 100;\n+                hresp = runRequest(hc, hreq, sleepTime);\n+                assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent was not expected but occurred\");\n+            }\n+        } else {\n+            \/\/ When a poorly formatted property value is given or no value is specified\n+            \/\/ then no timeout should occur\n+            hreq = HttpRequest.newBuilder(noTimeoutUri).version(HTTP_2).GET().build();\n+            hresp = runRequest(hc, hreq, sleepTime);\n+            assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent should not occur, no value was specified for this property\");\n+        }\n+    }\n@@ -112,1 +115,2 @@\n-        CompletableFuture<HttpResponse<String>> request = hc.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8));\n+    private HttpResponse<String> runRequest(HttpClient hc, HttpRequest req, int sleepTime) throws InterruptedException {\n+        CompletableFuture<HttpResponse<String>> request = hc.sendAsync(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n@@ -115,2 +119,0 @@\n-        \/\/ Sleep for 1\/8th of the timeout value to ensure it does not occur\n-        Thread.sleep(100);\n@@ -118,3 +120,3 @@\n-        request = hc.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        hresp = request.join();\n-        assertEquals(hresp.statusCode(), 200);\n+        Thread.sleep(sleepTime);\n+        request = hc.sendAsync(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        return request.join();\n@@ -153,1 +155,1 @@\n-                testLog.println(\"ServerTimeoutHandler: Same Connection was used, idleConnectionTimeoutEvent did not fire.\"\n+                testLog.println(\"ServerNoTimeoutHandler: Same Connection was used, idleConnectionTimeoutEvent did not fire.\"\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/IdleConnectionTimeoutTest.java","additions":43,"deletions":41,"binary":false,"changes":84,"status":"modified"}]}