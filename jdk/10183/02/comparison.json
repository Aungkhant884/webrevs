{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-            \"jdk.httpclient.keepalive.timeout\", 1200); \/\/ seconds\n+            \"jdk.httpclient.keepalive.timeout\", 600); \/\/ seconds\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.net.http.HttpConnectTimeoutException;\n@@ -35,0 +36,1 @@\n+import java.time.Duration;\n@@ -124,0 +126,1 @@\n+    private IdleConnectionTimeoutEvent idleConnectionTimeoutEvent;  \/\/ may be null\n@@ -184,0 +187,30 @@\n+    \/\/ An Idle connection is one that has no active streams\n+    \/\/ and has not sent the final stream flag\n+    final class IdleConnectionTimeoutEvent extends TimeoutEvent {\n+\n+        private boolean fired;\n+\n+        IdleConnectionTimeoutEvent(Duration duration) {\n+            super(duration);\n+            fired = false;\n+        }\n+\n+        @Override\n+        public void handle() {\n+            fired = true;\n+            if (debug.on()) {\n+                debug.log(\"HTTP connection idle for too long\");\n+            }\n+            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\"HTTP connection idle, no active streams. Shutting down.\");\n+            shutdown(hte);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"IdleConnectionTimeoutEvent, \" + super.toString();\n+        }\n+\n+        public boolean isFired() {\n+            return fired;\n+        }\n+    }\n@@ -703,1 +736,3 @@\n-            if (!(t instanceof EOFException) || isActive()) {\n+            if (idleConnectionTimeoutEvent != null && idleConnectionTimeoutEvent.isFired()) {\n+                Log.logError(\"idleConnectionTimeout timeout fired, shutting down connection: {0}\", t.getMessage());\n+            } else if (!(t instanceof EOFException) || isActive()) {\n@@ -985,0 +1020,2 @@\n+    \/\/ Check if this is the last stream aside from stream 0,\n+    \/\/ arm timeout\n@@ -1008,0 +1045,12 @@\n+        } else {\n+            \/\/ Start timer if property present and not already created\n+            synchronized (this) {\n+                \/\/ idleConnectionTimerEvent is always accessed within a synchronized block\n+                if (streams.isEmpty() && idleConnectionTimeoutEvent == null) {\n+                    idleConnectionTimeoutEvent = client().idleConnectionTimeout()\n+                            .map(IdleConnectionTimeoutEvent::new).orElse(null);\n+                    if (idleConnectionTimeoutEvent != null) {\n+                        client().registerTimer(idleConnectionTimeoutEvent);\n+                    }\n+                }\n+            }\n@@ -1180,0 +1229,5 @@\n+                \/\/ idleConnectionTimerEvent is always accessed within a synchronized block\n+                if (idleConnectionTimeoutEvent != null) {\n+                    client().cancelTimer(idleConnectionTimeoutEvent);\n+                    idleConnectionTimeoutEvent = null;\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1525,0 +1525,4 @@\n+    Optional<Duration> idleConnectionTimeout() {\n+        return Optional.ofNullable(getIdleConnectionTimeoutProp());\n+    }\n+\n@@ -1689,0 +1693,13 @@\n+    private Duration getIdleConnectionTimeoutProp() {\n+        \/\/ Http 2 in prop name somewhere\n+        String s = Utils.getNetProperty(\"jdk.httpclient.keepalive.timeout\");\n+        if (s != null) {\n+            try {\n+                long val = Long.parseLong(s);\n+                if (val >= 0)\n+                    return Duration.ofMillis(Long.parseLong(s));\n+            } catch (NumberFormatException ignored) {}\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8288717\n+ * @summary Tests that when the idleConnectionTimeoutEvent is configured in HTTP\/2,\n+ *          an HTTP\/2 connection will close within the specified interval if there\n+ *          are no active streams on the connection.\n+ * @library \/test\/lib server\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm -Djdk.httpclient.keepalive.timeout=800 IdleConnectionTimeoutTest\n+ * @run testng\/othervm -Djdk.httpclient.keepalive.timeout=100 IdleConnectionTimeoutTest\n+ * @run testng\/othervm  IdleConnectionTimeoutTest\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.testng.Assert.assertEquals;\n+\n+public class IdleConnectionTimeoutTest {\n+\n+    Http2TestServer http2TestServer;\n+    URI timeoutUri;\n+    URI noTimeoutUri;\n+    final String IDLE_CONN_PROPERTY = \"jdk.httpclient.keepalive.timeout\";\n+    final String TIMEOUT_PATH = \"\/serverTimeoutHandler\";\n+    final String NO_TIMEOUT_PATH = \"\/noServerTimeoutHandler\";\n+    static final PrintStream testLog = System.err;\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        http2TestServer = new Http2TestServer(false, 0);\n+        http2TestServer.addHandler(new ServerTimeoutHandler(), TIMEOUT_PATH);\n+        http2TestServer.addHandler(new ServerNoTimeoutHandler(), NO_TIMEOUT_PATH);\n+\n+        http2TestServer.start();\n+        int port = http2TestServer.getAddress().getPort();\n+        timeoutUri = new URI(\"http:\/\/localhost:\" + port + TIMEOUT_PATH);\n+        noTimeoutUri = new URI(\"http:\/\/localhost:\" + port + NO_TIMEOUT_PATH);\n+    }\n+\n+    \/*\n+       If the InetSocketAddress of the first remote connection is not equal to the address of the\n+       second remote connection, then the idleConnectionTimeoutEvent has occurred and a new connection\n+       was made to carry out the second request by the client.\n+    *\/\n+    @Test\n+    public void test() throws InterruptedException {\n+        String timeoutVal = System.getProperty(IDLE_CONN_PROPERTY);\n+        testLog.println(\"Test run for jdk.httpclient.keepalive.timeout=\" + timeoutVal);\n+\n+        int sleepTime = 0;\n+        HttpClient hc = HttpClient.newBuilder().version(HTTP_2).build();\n+        HttpRequest hreq;\n+        HttpResponse<String> hresp;\n+        if (timeoutVal != null) {\n+            if (timeoutVal.equals(\"100\")) {\n+                testLog.println(\"This one\");\n+                hreq = HttpRequest.newBuilder(timeoutUri).version(HTTP_2).GET().build();\n+                sleepTime = 800;\n+                hresp = runRequest(hc, hreq, sleepTime);\n+                assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent was expected but did not occur\");\n+            } else if (timeoutVal.equals(\"800\")) {\n+                testLog.println(\"This two\");\n+                hreq = HttpRequest.newBuilder(noTimeoutUri).version(HTTP_2).GET().build();\n+                sleepTime = 100;\n+                hresp = runRequest(hc, hreq, sleepTime);\n+                assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent was not expected but occurred\");\n+            }\n+        } else {\n+            \/\/ When a poorly formatted property value is given or no value is specified\n+            \/\/ then no timeout should occur\n+            hreq = HttpRequest.newBuilder(noTimeoutUri).version(HTTP_2).GET().build();\n+            hresp = runRequest(hc, hreq, sleepTime);\n+            assertEquals(hresp.statusCode(), 200, \"idleConnectionTimeoutEvent should not occur, no value was specified for this property\");\n+        }\n+    }\n+\n+    private HttpResponse<String> runRequest(HttpClient hc, HttpRequest req, int sleepTime) throws InterruptedException {\n+        CompletableFuture<HttpResponse<String>> request = hc.sendAsync(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        HttpResponse<String> hresp = request.join();\n+        assertEquals(hresp.statusCode(), 200);\n+\n+        Thread.sleep(sleepTime);\n+        request = hc.sendAsync(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        return request.join();\n+    }\n+\n+    static class ServerTimeoutHandler implements Http2Handler {\n+\n+        InetSocketAddress remote;\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (remote == null) {\n+                remote = exchange.getRemoteAddress();\n+                exchange.sendResponseHeaders(200, 0);\n+            } else if (!remote.equals(exchange.getRemoteAddress())) {\n+                testLog.println(\"ServerTimeoutHandler: New Connection was used, idleConnectionTimeoutEvent fired.\"\n+                        + \" First remote: \" + remote + \", Second Remote: \" + exchange.getRemoteAddress());\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(400, 0);\n+            }\n+        }\n+    }\n+\n+    static class ServerNoTimeoutHandler implements Http2Handler {\n+\n+        InetSocketAddress oldRemote;\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            InetSocketAddress newRemote = exchange.getRemoteAddress();\n+            if (oldRemote == null) {\n+                oldRemote = newRemote;\n+                exchange.sendResponseHeaders(200, 0);\n+            } else if (oldRemote.equals(newRemote)) {\n+                testLog.println(\"ServerNoTimeoutHandler: Same Connection was used, idleConnectionTimeoutEvent did not fire.\"\n+                        + \" First remote: \" + oldRemote + \", Second Remote: \" + newRemote);\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(400, 0);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/IdleConnectionTimeoutTest.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}