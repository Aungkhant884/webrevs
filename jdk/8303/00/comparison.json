{"files":[{"patch":"@@ -542,1 +542,0 @@\n-java\/lang\/Enum\/ConstantDirectoryOptimalCapacity.java            8282120 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8200696\n- * @summary Initial capacity of Class.enumConstantDirectory is not optimal\n- * @library \/test\/lib\n- * @modules java.base\/java.lang:open\n- *          java.base\/java.util:open\n- * @build jdk.test.lib.util.OptimalCapacity\n- * @run main ConstantDirectoryOptimalCapacity\n- *\/\n-\n-import jdk.test.lib.util.OptimalCapacity;\n-\n-public class ConstantDirectoryOptimalCapacity {\n-\n-    public static void main(String[] args) throws Throwable {\n-        test(E1.class);\n-        test(E2.class);\n-        test(E3.class);\n-        test(E4.class);\n-        test(E5.class);\n-        test(E6.class);\n-        test(E7.class);\n-        test(E8.class);\n-        test(E9.class);\n-        test(E10.class);\n-        test(E11.class);\n-        test(E12.class);\n-        test(E13.class);\n-        test(E14.class);\n-        test(E15.class);\n-        test(E16.class);\n-        test(E17.class);\n-        test(E18.class);\n-        test(E19.class);\n-        test(E20.class);\n-        test(E21.class);\n-        test(E22.class);\n-        test(E23.class);\n-        test(E24.class);\n-        test(E25.class);\n-        test(E26.class);\n-    }\n-\n-    private static void test(Class<? extends Enum> e) {\n-        Enum.valueOf(e, \"V0\"); \/\/ trigger init of enumConstantDirectory\n-\n-        int initialCapacity = (int)(e.getEnumConstants().length \/ 0.75f) + 1;\n-        OptimalCapacity.ofHashMap(e.getClass(), e, \"enumConstantDirectory\",\n-            initialCapacity);\n-    }\n-\n-    enum E1 { V0 }\n-    enum E2 { V0, V1 }\n-    enum E3 { V0, V1, V2 }\n-    enum E4 { V0, V1, V2, V3 }\n-    enum E5 { V0, V1, V2, V3, V4 }\n-    enum E6 { V0, V1, V2, V3, V4, V5 }\n-    enum E7 { V0, V1, V2, V3, V4, V5, V6 }\n-    enum E8 { V0, V1, V2, V3, V4, V5, V6, V7 }\n-    enum E9 { V0, V1, V2, V3, V4, V5, V6, V7, V8 }\n-    enum E10 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9 }\n-    enum E11 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10 }\n-    enum E12 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11 }\n-    enum E13 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12 }\n-    enum E14 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13 }\n-    enum E15 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14 }\n-    enum E16 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15 }\n-    enum E17 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16 }\n-    enum E18 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17 }\n-    enum E19 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18 }\n-    enum E20 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19 }\n-    enum E21 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20 }\n-    enum E22 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20, V21 }\n-    enum E23 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20, V21, V22 }\n-    enum E24 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20, V21, V22, V23 }\n-    enum E25 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20, V21, V22, V23, V24 }\n-    enum E26 { V0, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13,\n-               V14, V15, V16, V17, V18, V19, V20, V21, V22, V23, V24, V25 }\n-}\n","filename":"test\/jdk\/java\/lang\/Enum\/ConstantDirectoryOptimalCapacity.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.util;\n-\n-import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-\n-\/**\n- * Utility functions to check that the static storages are pre-sized\n- * optimally.\n- *\/\n-public final class OptimalCapacity {\n-\n-    private OptimalCapacity() {}\n-\n-    \/**\n-     * Checks adequacy of the initial capacity of a static field\n-     * of type {@code ArrayList}.\n-     *\n-     * Having\n-     * <pre>\n-     * class XClass {\n-     *     static ArrayList theList = new ArrayList(N);\n-     * }\n-     * <\/pre>\n-     *\n-     * you should call from the test\n-     *\n-     * <pre>\n-     * OptimalCapacity.assertProperlySized(XClass.class, \"theList\", N);\n-     * <\/pre>\n-     *\/\n-    public static void ofArrayList(Class<?> clazz, String fieldName,\n-            int initialCapacity)\n-    {\n-        try {\n-            Field field = clazz.getDeclaredField(fieldName);\n-            field.setAccessible(true);\n-            Object obj = field.get(null);\n-            if (!ArrayList.class.equals(obj.getClass())) {\n-                throw new RuntimeException(\"'\" + field +\n-                    \"' expected to be of type ArrayList\");\n-            }\n-            ArrayList<?> list = (ArrayList<?>)obj;\n-\n-            \/\/ For ArrayList the optimal capacity is its final size\n-            if (list.size() != initialCapacity) {\n-                throw new RuntimeException(\"Size of '\" + field +\n-                    \"' is \" + list.size() +\n-                    \", but expected to be \" + initialCapacity);\n-            }\n-            if (internalArraySize(list) != initialCapacity) {\n-                throw new RuntimeException(\"Capacity of '\" + field +\n-                    \"' is \" + internalArraySize(list) +\n-                    \", but expected to be \" + initialCapacity);\n-            }\n-        } catch (ReflectiveOperationException roe) {\n-            throw new RuntimeException(roe);\n-        }\n-    }\n-\n-    \/**\n-     * Checks adequacy of the initial capacity of a static field\n-     * of type {@code HashMap}.\n-     *\n-     * Having\n-     * <pre>\n-     * class XClass {\n-     *     static HashMap theMap = new HashMap(N);\n-     * }\n-     * <\/pre>\n-     *\n-     * you should call from the test\n-     *\n-     * <pre>\n-     * OptimalCapacity.ofHashMap(XClass.class, \"theMap\", N);\n-     * <\/pre>\n-     *\/\n-    public static void ofHashMap(Class<?> clazz, String fieldName,\n-            int initialCapacity)\n-    {\n-        ofHashMap(clazz, null, fieldName, initialCapacity);\n-    }\n-\n-    \/**\n-     * Checks adequacy of the initial capacity of a non-static field\n-     * of type {@code HashMap}.\n-     *\n-     * Having\n-     * <pre>\n-     * class XClass {\n-     *     HashMap theMap = new HashMap(N);\n-     * }\n-     * XClass instance = ...\n-     * <\/pre>\n-     *\n-     * you should call from the test\n-     *\n-     * <pre>\n-     * OptimalCapacity.ofHashMap(XClass.class, instance, \"theMap\", N);\n-     * <\/pre>\n-     *\/\n-    public static void ofHashMap(Class<?> clazz, Object instance,\n-            String fieldName, int initialCapacity)\n-    {\n-        try {\n-            Field field = clazz.getDeclaredField(fieldName);\n-            field.setAccessible(true);\n-            Object obj = field.get(instance);\n-            if (!HashMap.class.equals(obj.getClass())) {\n-                throw new RuntimeException(field +\n-                    \" expected to be of type HashMap\");\n-            }\n-            HashMap<?,?> map = (HashMap<?,?>)obj;\n-\n-            \/\/ Check that the map allocates only necessary amount of space\n-            HashMap<Object, Object> tmp = new HashMap<>(map);\n-            if (internalArraySize(map) != internalArraySize(tmp)) {\n-                throw new RuntimeException(\"Final capacity of '\" + field +\n-                    \"' is \" + internalArraySize(map) +\n-                    \", which exceeds necessary minimum \" + internalArraySize(tmp));\n-            }\n-\n-            \/\/ Check that map is initially properly sized\n-            tmp = new HashMap<>(initialCapacity);\n-            tmp.put(new Object(), new Object()); \/\/ trigger storage init\n-            if (internalArraySize(map) != internalArraySize(tmp)) {\n-                throw new RuntimeException(\"Requested capacity of '\" + field +\n-                    \"' was \" + initialCapacity +\n-                    \", which resulted in final capacity \" + internalArraySize(tmp) +\n-                    \", which differs from necessary minimum \" + internalArraySize(map));\n-            }\n-\n-        } catch (ReflectiveOperationException roe) {\n-            throw new RuntimeException(roe);\n-        }\n-    }\n-\n-    \/**\n-     * Checks adequacy of the expected maximum size of a static field\n-     * of type {@code IdentityHashMap}.\n-     *\n-     * Having\n-     * <pre>\n-     * class XClass {\n-     *     static IdentityHashMap theMap = new IdentityHashMap(M);\n-     * }\n-     * <\/pre>\n-     *\n-     * you should call from the test\n-     *\n-     * <pre>\n-     * OptimalCapacity.ofIdentityHashMap(XClass.class, \"theMap\", M);\n-     * <\/pre>\n-     *\/\n-    public static void ofIdentityHashMap(Class<?> clazz, String fieldName,\n-            int expectedMaxSize)\n-    {\n-        try {\n-            Field field = clazz.getDeclaredField(fieldName);\n-            field.setAccessible(true);\n-            Object obj = field.get(null);\n-            if (!IdentityHashMap.class.equals(obj.getClass())) {\n-                throw new RuntimeException(\"'\" + field +\n-                    \"' expected to be of type IdentityHashMap\");\n-            }\n-            IdentityHashMap<?,?> map = (IdentityHashMap<?,?>)obj;\n-\n-            \/\/ Check that size of map is what was expected\n-            if (map.size() != expectedMaxSize) {\n-                throw new RuntimeException(\"Size of '\" + field +\n-                    \"' is \" + map.size() +\n-                    \", which differs from expected \" + expectedMaxSize);\n-            }\n-\n-            \/\/ Check that the map allocated only necessary amount of memory\n-            IdentityHashMap<Object, Object> tmp = new IdentityHashMap<>(map);\n-            if (internalArraySize(map) != internalArraySize(tmp)) {\n-                throw new RuntimeException(\"Final capacity of '\" + field +\n-                    \"' is \" + internalArraySize(map) +\n-                    \", which exceeds necessary minimum \" + internalArraySize(tmp));\n-            }\n-\n-            \/\/ Check that map was initially properly sized\n-            tmp = new IdentityHashMap<>(expectedMaxSize);\n-            tmp.put(new Object(), new Object()); \/\/ trigger storage init\n-            if (internalArraySize(map) != internalArraySize(tmp)) {\n-                throw new RuntimeException(\"Requested number of elements in '\" + field +\n-                    \"' was \" + expectedMaxSize +\n-                    \", which resulted in final capacity \" + internalArraySize(tmp) +\n-                    \", which differs from necessary minimum \" + internalArraySize(map));\n-            }\n-        } catch (ReflectiveOperationException roe) {\n-            throw new RuntimeException(roe);\n-        }\n-    }\n-\n-    \/**\n-     * Returns size of the internal storage.\n-     *\/\n-    private static int internalArraySize(Object container)\n-            throws ReflectiveOperationException {\n-        Field field;\n-        if (ArrayList.class.equals(container.getClass())) {\n-            field = ArrayList.class.getDeclaredField(\"elementData\");\n-        } else if (HashMap.class.equals(container.getClass())) {\n-            field = HashMap.class.getDeclaredField(\"table\");\n-        } else if (IdentityHashMap.class.equals(container.getClass())) {\n-            field = IdentityHashMap.class.getDeclaredField(\"table\");\n-        } else {\n-            throw new RuntimeException(\"Unexpected class \" +\n-                    container.getClass());\n-        }\n-        field.setAccessible(true);\n-        return ((Object[])field.get(container)).length;\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/util\/OptimalCapacity.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"}]}