{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/z\/zValue.inline.hpp\"\n@@ -145,0 +146,4 @@\n+static void free_pages(ZArray<ZPage*>* pages) {\n+  ZHeap::heap()->free_pages(pages, true \/* reclaimed *\/);\n+}\n+\n@@ -156,0 +161,10 @@\n+  ZPerWorker<ZArray<ZPage*>> _empty_pages;\n+  static const int BULK_FREE_LIMIT = 64;\n+\n+  void free_empty_pages(bool free_all) {\n+    if ((free_all && _empty_pages.get().is_nonempty()) ||\n+        (_empty_pages.get().length() == BULK_FREE_LIMIT)) {\n+      free_pages(_empty_pages.addr());\n+      _empty_pages.get().clear();\n+    }\n+  }\n@@ -162,0 +177,6 @@\n+    if (_empty_pages.get().is_nonempty()) {\n+      ZPage* const page = _empty_pages.get().pop();\n+      page->reset();\n+      return page;\n+    }\n+\n@@ -176,1 +197,1 @@\n-      free_page(page);\n+      _empty_pages.get().push(page);\n@@ -178,0 +199,2 @@\n+\n+    free_empty_pages(true \/* free_all *\/);\n@@ -181,1 +204,3 @@\n-    free_page(page);\n+    _empty_pages.get().push(page);\n+\n+    free_empty_pages(Atomic::load(&_in_place_count) > 0);\n@@ -193,1 +218,1 @@\n-    return Atomic::load(&_in_place_count);\n+    return _in_place_count;\n@@ -270,1 +295,1 @@\n-    return Atomic::load(&_in_place_count);\n+    return _in_place_count;\n@@ -280,35 +305,0 @@\n-  ZArray<ZPage*>   _relocated_pages;\n-  bool             _bulk_free_mode;\n-  static const int BULK_FREE_LEN = 64;\n-\n-  inline bool should_bulk_free() {\n-    return std::is_same<Allocator, ZRelocateSmallAllocator>::value && _bulk_free_mode;\n-  }\n-\n-  inline void append_relocated_pages(ZPage* page) {\n-    _relocated_pages.append(page);\n-  }\n-\n-  inline void bulk_free_relocated_page(int bulk) {\n-    if (_relocated_pages.length() >= bulk && _relocated_pages.is_nonempty()) {\n-      ZHeap::heap()->free_pages(&_relocated_pages, true \/* reclaimed *\/);\n-      _relocated_pages.clear();\n-    }\n-  }\n-\n-  inline ZPage* alloc_bulk_free_page() {\n-    if (_relocated_pages.length() > 0) {\n-      ZPage* result = _relocated_pages.last();\n-      _relocated_pages.pop();\n-      result->reset();\n-      return result;\n-    }\n-    return NULL;\n-  }\n-\n-  inline void bulk_free_mode_check() {\n-    if (_bulk_free_mode && _allocator->in_place_count() > 0) {\n-      _bulk_free_mode = false;\n-      bulk_free_relocated_page(0);\n-    }\n-  }\n@@ -355,7 +345,0 @@\n-      if (should_bulk_free()) {\n-        _target = alloc_bulk_free_page();\n-        bulk_free_mode_check();\n-        if (_target != NULL) {\n-          continue;\n-        }\n-      }\n@@ -383,3 +366,1 @@\n-      _target(NULL),\n-      _relocated_pages(BULK_FREE_LEN),\n-      _bulk_free_mode(true) {}\n+      _target(NULL) {}\n@@ -388,3 +369,0 @@\n-    if (should_bulk_free()) {\n-      bulk_free_relocated_page(0);\n-    }\n@@ -422,7 +400,1 @@\n-      if (should_bulk_free()) {\n-        append_relocated_pages(page);\n-        bulk_free_relocated_page(BULK_FREE_LEN);\n-        bulk_free_mode_check();\n-      } else {\n-        _allocator->free_relocated_page(page);\n-      }\n+      _allocator->free_relocated_page(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":31,"deletions":59,"binary":false,"changes":90,"status":"modified"}]}