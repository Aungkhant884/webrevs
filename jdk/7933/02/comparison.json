{"files":[{"patch":"@@ -252,0 +252,1 @@\n+    PhaseStringOpts::print_statistics();\n@@ -1840,1 +1841,1 @@\n-    PhaseStringOpts pso(initial_gvn(), for_igvn());\n+    PhaseStringOpts pso(initial_gvn());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"opto\/callGenerator.hpp\"\n@@ -32,1 +30,0 @@\n-#include \"opto\/divnode.hpp\"\n@@ -38,2 +35,1 @@\n-#include \"opto\/subnode.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -47,1 +43,0 @@\n-  Node*               _string_alloc;\n@@ -74,1 +69,0 @@\n-    _string_alloc(NULL),\n@@ -85,23 +79,0 @@\n-  void merge_add() {\n-#if 0\n-    \/\/ XXX This is place holder code for reusing an existing String\n-    \/\/ allocation but the logic for checking the state safety is\n-    \/\/ probably inadequate at the moment.\n-    CallProjections endprojs;\n-    sc->end()->extract_projections(&endprojs, false);\n-    if (endprojs.resproj != NULL) {\n-      for (SimpleDUIterator i(endprojs.resproj); i.has_next(); i.next()) {\n-        CallStaticJavaNode *use = i.get()->isa_CallStaticJava();\n-        if (use != NULL && use->method() != NULL &&\n-            use->method()->intrinsic_id() == vmIntrinsics::_String_String &&\n-            use->in(TypeFunc::Parms + 1) == endprojs.resproj) {\n-          \/\/ Found useless new String(sb.toString()) so reuse the newly allocated String\n-          \/\/ when creating the result instead of allocating a new one.\n-          sc->set_string_alloc(use->in(TypeFunc::Parms));\n-          sc->set_end(use);\n-        }\n-      }\n-    }\n-#endif\n-  }\n-\n@@ -212,1 +183,0 @@\n-  Node* string_alloc() { return _string_alloc; }\n@@ -221,4 +191,1 @@\n-      log->head(\"replace_string_concat arguments='%d' string_alloc='%d' multiple='%d'\",\n-                num_arguments(),\n-                _string_alloc != NULL,\n-                _multiple);\n+      log->head(\"replace_string_concat arguments='%d' multiple='%d'\", num_arguments(), _multiple);\n@@ -417,0 +384,1 @@\n+  uint encountered = 0;\n@@ -422,0 +390,1 @@\n+      encountered++;\n@@ -434,0 +403,3 @@\n+#ifndef PRODUCT\n+  Atomic::add(&_stropts_total, encountered);\n+#endif\n@@ -437,1 +409,22 @@\n-\n+\/\/ Recognize a fluent-chain of StringBuilder\/Buffer. They are either explicit usages\n+\/\/ of them or the legacy bytecodes of string concatenation prior to JEP-280. eg.\n+\/\/\n+\/\/ String result = new StringBuilder()\n+\/\/   .append(\"foo\")\n+\/\/   .append(\"bar\")\n+\/\/   .append(123)\n+\/\/   .toString(); \/\/ \"foobar123\"\n+\/\/\n+\/\/ PS: Only a certain subset of constructor and append methods are acceptable.\n+\/\/ The criterion is that the length of argument is easy to work out in this phrase.\n+\/\/ It will drop complex cases such as Object.\n+\/\/\n+\/\/ Since it walks along the receivers of fluent-chain, it will give up if the codeshape is\n+\/\/ not \"fluent\" enough. eg.\n+\/\/   StringBuilder sb = new StringBuilder();\n+\/\/   sb.append(\"foo\");\n+\/\/   sb.toString();\n+\/\/\n+\/\/ The receiver of toString method is the result of Allocation Node(CheckCastPP).\n+\/\/ The append method is overlooked. It will fail at validate_control_flow() test.\n+\/\/\n@@ -462,1 +455,0 @@\n-\n@@ -464,1 +456,0 @@\n-  InitializeNode* init = NULL;\n@@ -641,1 +632,1 @@\n-PhaseStringOpts::PhaseStringOpts(PhaseGVN* gvn, Unique_Node_List*):\n+PhaseStringOpts::PhaseStringOpts(PhaseGVN* gvn):\n@@ -694,0 +685,1 @@\n+              Atomic::inc(&_stropts_merged);\n@@ -2034,3 +2026,1 @@\n-    \/\/ If we're not reusing an existing String allocation then allocate one here.\n-    result = sc->string_alloc();\n-    if (result == NULL) {\n+    {\n@@ -2063,0 +2053,3 @@\n+#ifndef PRODUCT\n+  Atomic::inc(&_stropts_replaced);\n+#endif\n@@ -2064,0 +2057,10 @@\n+\n+#ifndef PRODUCT\n+uint PhaseStringOpts::_stropts_replaced = 0;\n+uint PhaseStringOpts::_stropts_merged = 0;\n+uint PhaseStringOpts::_stropts_total = 0;\n+\n+void PhaseStringOpts::print_statistics() {\n+  tty->print_cr(\"StringConcat: %4d\/%4d\/%4d(replaced\/merged\/total)\", _stropts_replaced, _stropts_merged, _stropts_total);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":46,"deletions":43,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,9 @@\n-  PhaseStringOpts(PhaseGVN* gvn, Unique_Node_List* worklist);\n+  PhaseStringOpts(PhaseGVN* gvn);\n+\n+#ifndef PRODUCT\n+  static void print_statistics();\n+ private:\n+  static uint _stropts_replaced;\n+  static uint _stropts_merged;\n+  static uint _stropts_total;\n+#endif\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}