{"files":[{"patch":"@@ -252,0 +252,1 @@\n+    PhaseStringOpts::print_statistics();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"opto\/callGenerator.hpp\"\n@@ -32,1 +30,0 @@\n-#include \"opto\/divnode.hpp\"\n@@ -38,2 +35,1 @@\n-#include \"opto\/subnode.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -47,1 +43,0 @@\n-  Node*               _string_alloc;\n@@ -51,2 +46,0 @@\n-  bool                _multiple;       \/\/ indicates this is a fusion of two or more\n-                                       \/\/ separate StringBuilders\n@@ -74,1 +67,0 @@\n-    _string_alloc(NULL),\n@@ -76,2 +68,1 @@\n-    _end(end),\n-    _multiple(false) {\n+    _end(end) {\n@@ -85,23 +76,0 @@\n-  void merge_add() {\n-#if 0\n-    \/\/ XXX This is place holder code for reusing an existing String\n-    \/\/ allocation but the logic for checking the state safety is\n-    \/\/ probably inadequate at the moment.\n-    CallProjections endprojs;\n-    sc->end()->extract_projections(&endprojs, false);\n-    if (endprojs.resproj != NULL) {\n-      for (SimpleDUIterator i(endprojs.resproj); i.has_next(); i.next()) {\n-        CallStaticJavaNode *use = i.get()->isa_CallStaticJava();\n-        if (use != NULL && use->method() != NULL &&\n-            use->method()->intrinsic_id() == vmIntrinsics::_String_String &&\n-            use->in(TypeFunc::Parms + 1) == endprojs.resproj) {\n-          \/\/ Found useless new String(sb.toString()) so reuse the newly allocated String\n-          \/\/ when creating the result instead of allocating a new one.\n-          sc->set_string_alloc(use->in(TypeFunc::Parms));\n-          sc->set_end(use);\n-        }\n-      }\n-    }\n-#endif\n-  }\n-\n@@ -212,1 +180,0 @@\n-  Node* string_alloc() { return _string_alloc; }\n@@ -221,4 +188,1 @@\n-      log->head(\"replace_string_concat arguments='%d' string_alloc='%d' multiple='%d'\",\n-                num_arguments(),\n-                _string_alloc != NULL,\n-                _multiple);\n+      log->head(\"replace_string_concat arguments='%d'\", num_arguments());\n@@ -342,1 +306,0 @@\n-  result->_multiple = true;\n@@ -416,1 +379,1 @@\n-\n+  uint encount = 0;\n@@ -422,0 +385,1 @@\n+      encount++;\n@@ -434,0 +398,3 @@\n+#ifndef PRODUCT\n+  Atomic::add(&_stropts_encount, encount);\n+#endif\n@@ -437,1 +404,22 @@\n-\n+\/\/ Recognize a fluent-chain of StringBuilder\/Buffer. They are either explicit usages\n+\/\/ of them or the legacy bytecodes of string concatenation prior to JEP-280. eg.\n+\/\/\n+\/\/ String result = new StringBuilder()\n+\/\/   .append(\"foo\")\n+\/\/   .append(\"bar\")\n+\/\/   .append(123)\n+\/\/   .toString(); \/\/ \"foobar123\"\n+\/\/\n+\/\/ PS: Only a certain subset of constructor and append methods are acceptable.\n+\/\/ The criterion is that the length of argument is easy to work out in this phrase.\n+\/\/ It will drop complex cases such as Object.\n+\/\/\n+\/\/ Since it walks along the receivers of fluent-chain, it will give up if the codeshape is\n+\/\/ not \"fluent\" enough. eg.\n+\/\/   StringBuilder sb = new StringBuilder();\n+\/\/   sb.append(\"foo\");\n+\/\/   sb.toString();\n+\/\/\n+\/\/ The receiver of toString method is the result of Allocation Node(CheckedCastPP).\n+\/\/ The append method is overlooked. It will fail at validate_control_flow() test.\n+\/\/\n@@ -462,1 +450,0 @@\n-\n@@ -464,1 +451,0 @@\n-  InitializeNode* init = NULL;\n@@ -694,0 +680,1 @@\n+              Atomic::inc(&_stropts_merged);\n@@ -2034,3 +2021,1 @@\n-    \/\/ If we're not reusing an existing String allocation then allocate one here.\n-    result = sc->string_alloc();\n-    if (result == NULL) {\n+    {\n@@ -2063,0 +2048,3 @@\n+#ifndef PRODUCT\n+  Atomic::inc(&_stropts_replaced);\n+#endif\n@@ -2064,0 +2052,10 @@\n+\n+#ifndef PRODUCT\n+uint PhaseStringOpts::_stropts_replaced = 0;\n+uint PhaseStringOpts::_stropts_merged = 0;\n+uint PhaseStringOpts::_stropts_encount = 0;\n+\n+void PhaseStringOpts::print_statistics() {\n+  tty->print_cr(\"StringConcat: %4d\/%4d\/%4d(replaced\/merged\/encounter)\", _stropts_replaced, _stropts_merged, _stropts_encount);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":46,"deletions":48,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,8 @@\n+\n+#ifndef PRODUCT\n+  static void print_statistics();\n+ private:\n+  static uint _stropts_replaced;\n+  static uint _stropts_merged;\n+  static uint _stropts_encount;\n+#endif\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}