{"files":[{"patch":"@@ -49,1 +49,6 @@\n-GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+GrowableArrayCHeap<char*, mtClassShared>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+#define NUM_FILTER 4\n+static const char* filter[NUM_FILTER] = {\"java.lang.invoke.Invokers$Holder\",\n+                                         \"java.lang.invoke.DirectMethodHandle$Holder\",\n+                                         \"java.lang.invoke.DelegatingMethodHandle$Holder\",\n+                                         \"java.lang.invoke.LambdaForm$Holder\"};\n@@ -53,1 +58,1 @@\n-    _lambdaform_lines = new GrowableArray<char*>(100);\n+    _lambdaform_lines = new GrowableArrayCHeap<char*, mtClassShared>(150);\n@@ -58,0 +63,10 @@\n+void LambdaFormInvokers::append_filtered(char* line) {\n+  for (int k = 0; k < NUM_FILTER; k++) {\n+    if (strstr(line, filter[k]) != nullptr) {\n+        append(line);\n+        break;\n+    }\n+  }\n+}\n+#undef NUM_FILTER\n+\n@@ -66,0 +81,2 @@\n+  log_info(cds)(\"Total lambdaform lines %d  and total bytes \" SIZE_FORMAT, _lambdaform_lines->length(), total_bytes());\n+  HandleMark hm(THREAD);\n@@ -150,0 +167,1 @@\n+  SystemDictionaryShared::init_dumptime_info(result);\n@@ -152,0 +170,13 @@\n+\n+size_t LambdaFormInvokers::total_bytes() {\n+  if (_lambdaform_lines != nullptr) {\n+    size_t total = 0;\n+    for (int i = 0; i < _lambdaform_lines->length(); i ++) {\n+      char* str = _lambdaform_lines->at(i);\n+      total += strlen(str) + 1; \/\/ including ending '\\0'\n+    }\n+    return total;\n+  } else {\n+    return 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -30,2 +31,0 @@\n-template <class T>\n-class GrowableArray;\n@@ -36,1 +35,1 @@\n-  static GrowableArray<char*>* _lambdaform_lines;\n+  static GrowableArrayCHeap<char*, mtClassShared>* _lambdaform_lines;\n@@ -38,1 +37,0 @@\n- public:\n@@ -40,0 +38,1 @@\n+ public:\n@@ -41,0 +40,1 @@\n+  static void append_filtered(char* line);\n@@ -42,1 +42,1 @@\n-  static GrowableArray<char*>* lambdaform_lines() {\n+  static GrowableArrayCHeap<char*, mtClassShared>* lambdaform_lines() {\n@@ -45,0 +45,5 @@\n+  static size_t total_bytes();\n+  static bool should_regenerate_holder_classes() {\n+    assert(DynamicDumpSharedSpaces, \"Dynamic dump only\");\n+    return _lambdaform_lines != nullptr && _lambdaform_lines->length() > 0;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2198,0 +2198,13 @@\n+  if (DynamicArchive::is_mapped()) {\n+    \/\/ Those regenerated holder classes are in dynamic archive\n+    if (name == vmSymbols::java_lang_invoke_Invokers_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DirectMethodHandle_Holder() ||\n+        name == vmSymbols::java_lang_invoke_LambdaForm_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DelegatingMethodHandle_Holder()) {\n+      record = dynamic_dict->lookup(name, hash, 0);\n+      if (record != nullptr) {\n+        return record;\n+      }\n+    }\n+  }\n+\n@@ -2254,1 +2267,1 @@\n-    _st->print_cr(\"%4d: %s %s\", (_index++), record->_klass->external_name(),\n+    _st->print_cr(\"%4d: %s %s\", ++_index, record->_klass->external_name(),\n@@ -2271,1 +2284,1 @@\n-        _st->print_cr(\"%4d: %s %s\", (++_index), k->external_name(),\n+        _st->print_cr(\"%4d: %s %s\", _index, k->external_name(),\n@@ -2274,0 +2287,1 @@\n+        _index++;\n@@ -2292,1 +2306,1 @@\n-    SharedLambdaDictionaryPrinter ldp(st, p.index());\n+    SharedLambdaDictionaryPrinter ldp(st, p.index() + 1);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -299,6 +299,0 @@\n-  \/* used by CDS *\/                                                                               \\\n-  template(jdk_internal_misc_CDS,                     \"jdk\/internal\/misc\/CDS\")                    \\\n-  template(generateLambdaFormHolderClasses,           \"generateLambdaFormHolderClasses\")          \\\n-  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n-  template(dumpSharedArchive,                         \"dumpSharedArchive\")                        \\\n-  template(dumpSharedArchive_signature,               \"(ZLjava\/lang\/String;)V\")                   \\\n@@ -696,7 +690,16 @@\n-  \/* cds *\/                                                                                                       \\\n-  template(jdk_internal_loader_ClassLoaders,       \"jdk\/internal\/loader\/ClassLoaders\")                            \\\n-  template(java_util_concurrent_ConcurrentHashMap, \"java\/util\/concurrent\/ConcurrentHashMap\")                      \\\n-  template(java_util_ArrayList,                    \"java\/util\/ArrayList\")                                         \\\n-  template(toFileURL_name,                         \"toFileURL\")                                                   \\\n-  template(toFileURL_signature,                    \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                          \\\n-  template(url_void_signature,                     \"(Ljava\/net\/URL;)V\")                                           \\\n+  \/* CDS *\/                                                                                                       \\\n+  template(dumpSharedArchive,                               \"dumpSharedArchive\")                                  \\\n+  template(dumpSharedArchive_signature,                     \"(ZLjava\/lang\/String;)V\")                             \\\n+  template(generateLambdaFormHolderClasses,                 \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature,       \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")           \\\n+  template(java_lang_invoke_Invokers_Holder,                \"java\/lang\/invoke\/Invokers$Holder\")                   \\\n+  template(java_lang_invoke_DirectMethodHandle_Holder,      \"java\/lang\/invoke\/DirectMethodHandle$Holder\")         \\\n+  template(java_lang_invoke_LambdaForm_Holder,              \"java\/lang\/invoke\/LambdaForm$Holder\")                 \\\n+  template(java_lang_invoke_DelegatingMethodHandle_Holder,  \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\")     \\\n+  template(jdk_internal_loader_ClassLoaders,                \"jdk\/internal\/loader\/ClassLoaders\")                   \\\n+  template(jdk_internal_misc_CDS,                           \"jdk\/internal\/misc\/CDS\")                              \\\n+  template(java_util_concurrent_ConcurrentHashMap,          \"java\/util\/concurrent\/ConcurrentHashMap\")             \\\n+  template(java_util_ArrayList,                             \"java\/util\/ArrayList\")                                \\\n+  template(toFileURL_name,                                  \"toFileURL\")                                          \\\n+  template(toFileURL_signature,                             \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                 \\\n+  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -262,0 +263,1 @@\n+  log_info(cds)(\"    symbols = %5d\", _symbols->length());\n@@ -1098,0 +1100,5 @@\n+  if (mapinfo->is_static()) {\n+    mapinfo->set_lambdaform_invokers_offset();\n+    mapinfo->set_size_lambdaform_invokers(LambdaFormInvokers::total_bytes());\n+    mapinfo->write_lambdaform_invokers();\n+  }\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -370,0 +371,9 @@\n+  \/\/ regenerate lambdaform holder classes\n+  if (LambdaFormInvokers::should_regenerate_holder_classes()) {\n+    JavaThread* THREAD = JavaThread::current();\n+    assert(THREAD->is_Java_thread(), \"Should be JavaThread\");\n+    log_info(cds, dynamic)(\"Regenerate lambdaform holder classes ...\");\n+    LambdaFormInvokers::regenerate_holder_classes(THREAD);\n+    log_info(cds, dynamic)(\"Regenerate lambdaform holder classes ...done\");\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -302,0 +303,2 @@\n+  st->print_cr(\"- lambdaform_invokers_offset:     \" SIZE_FORMAT, _lambdaform_invokers_offset);\n+  st->print_cr(\"- size_lambdaform_invokers        \" SIZE_FORMAT, _size_lambdaform_invokers);\n@@ -1233,1 +1236,0 @@\n-\n@@ -1235,1 +1237,0 @@\n-\n@@ -1250,0 +1251,46 @@\n+\/\/ Write all lambdafor_invoker_lines into static archive.\n+void FileMapInfo::write_lambdaform_invokers() {\n+  GrowableArrayCHeap<char*, mtClassShared>* all_lines = LambdaFormInvokers::lambdaform_lines();\n+  log_info(cds)(\"lambdaform_invokers file_offset = \" SIZE_FORMAT, header()->lambdaform_invokers_offset());\n+  log_info(cds)(\"lambdaform_invokers size = \" SIZE_FORMAT, header()->size_lambdaform_invokers());\n+  assert(_file_offset == header()->lambdaform_invokers_offset(), \"Anything writen after file offset set?\");\n+  if (all_lines != nullptr) {\n+    int len = all_lines->length();\n+    for (int i = 0; i < len; i++) {\n+      char* line = all_lines->at(i);\n+      write_bytes(line, strlen(line) + 1); \/\/ including ending '\\0'.\n+    }\n+  }\n+}\n+\n+void FileMapInfo::read_lambdaform_invokers() {\n+  assert(UseSharedSpaces, \"Must be shared mod\");\n+  size_t offset = header()->lambdaform_invokers_offset();\n+  size_t size   = header()->size_lambdaform_invokers();\n+  char* base = os::map_memory(_fd, _full_path, offset,  nullptr, size,\n+                                true\/*read only*\/, true\/*exec*\/, mtClassShared);\n+  if (base == nullptr) {\n+    \/\/ read content from file\n+    base = (char*)os::malloc(header()->size_lambdaform_invokers(), mtClassShared);\n+    if (base == nullptr) {\n+      vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"failed to allocate memory for lambdaform_invokers, out of memory.\");\n+    }\n+    if (lseek(_fd, (long)header()->lambdaform_invokers_offset(), SEEK_SET) !=\n+                   (long)header()->lambdaform_invokers_offset()  ||\n+      read_bytes(base, size) != size) {\n+      vm_exit_during_initialization(\"Could not read lambdaform_invvokers from file!\");\n+    }\n+  }\n+\n+  size_t count = 0;\n+  size_t len;\n+  int    index = 0;\n+  while (count < size) {\n+    len = strlen(base) + 1;\n+    LambdaFormInvokers::append_filtered(base);\n+    count += len;\n+    base  += len;\n+  }\n+  log_info(cds)(\"Total lambdaform lines (filtered)  from static archive %d  and total bytes \" SIZE_FORMAT, index, size);\n+}\n+\n@@ -2123,2 +2170,2 @@\n-FileMapInfo* FileMapInfo::_current_info = NULL;\n-FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;\n+FileMapInfo* FileMapInfo::_current_info = nullptr;\n+FileMapInfo* FileMapInfo::_dynamic_archive_info = nullptr;\n@@ -2130,2 +2177,1 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = NULL;\n-\n+GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -239,0 +239,3 @@\n+  size_t _lambdaform_invokers_offset;   \/\/ lambdaform_invoker lines offset.\n+  size_t _size_lambdaform_invokers;     \/\/ total size of lambdainvoker lines, string saved as char*, ends with '\\0'.\n+\n@@ -283,0 +286,2 @@\n+  size_t lambdaform_invokers_offset()      const { return _lambdaform_invokers_offset; }\n+  size_t size_lambdaform_invokers()        const { return _size_lambdaform_invokers; }\n@@ -293,0 +298,2 @@\n+  void set_lambdaform_invokers_offset(size_t offset) { _lambdaform_invokers_offset = offset; }\n+  void set_size_lambdaform_invokers(size_t size)     { _size_lambdaform_invokers = size; }\n@@ -347,1 +354,0 @@\n-\n@@ -452,0 +458,1 @@\n+  void  write_lambdaform_invokers();\n@@ -464,0 +471,1 @@\n+  void  read_lambdaform_invokers();\n@@ -549,0 +557,17 @@\n+  size_t lambdaform_invokers_offset() const {\n+    return header()->lambdaform_invokers_offset();\n+  }\n+\n+  \/\/ Set current file offset. Must be assigned before write header.\n+  void set_lambdaform_invokers_offset() {\n+    align_file_position();\n+    header()->set_lambdaform_invokers_offset(_file_offset);\n+  }\n+\n+  size_t size_lambdaform_invokers() const {\n+    return header()->size_lambdaform_invokers();\n+  }\n+  void set_size_lambdaform_invokers(size_t size) {\n+    header()->set_size_lambdaform_invokers(size);\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -908,0 +908,5 @@\n+    _requested_base_address = static_mapinfo->requested_base_address();\n+    if (DynamicDumpSharedSpaces) {\n+      \/\/ Read stored LF format lines stored in static archive\n+      static_mapinfo->read_lambdaform_invokers();\n+    }\n@@ -913,1 +918,0 @@\n-    _requested_base_address = static_mapinfo->requested_base_address();\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -3687,1 +3688,1 @@\n-  return ClassListWriter::is_enabled();\n+  return ClassListWriter::is_enabled() || DynamicDumpSharedSpaces;\n@@ -3695,1 +3696,1 @@\n-  assert(ClassListWriter::is_enabled(), \"Should be set and open\");\n+  assert(ClassListWriter::is_enabled() || DynamicDumpSharedSpaces,  \"Should be set and open or do dynamic dump\");\n@@ -3700,2 +3701,6 @@\n-    ClassListWriter w;\n-    w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    if (DynamicDumpSharedSpaces) {\n+      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+    } else {\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary LambHello World test for regenerate lambda holder classes in dynamic archive\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambHello sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar lambhello.jar LambHello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. TestDynamicRegenerateHolderClasses\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestDynamicRegenerateHolderClasses extends DynamicArchiveTestBase {\n+    static String CHECK_MESSAGES[] = {\"java.lang.invoke.Invokers$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DirectMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DelegatingMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.LambdaForm$Holder source: shared objects file (top)\"};\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestDynamicRegenerateHolderClasses::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"lambhello.jar\");\n+        String mainClass = \"LambHello\";\n+        dump(topArchiveName,\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=debug\",\n+              \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+        run(topArchiveName,\n+             \"-Xlog:class+load\",\n+             \"-Xlog:cds+dynamic=debug,cds=debug,class+load\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"LambHello source: shared objects file (top)\")\n+                          .shouldHaveExitValue(0);\n+                    for (String s : CHECK_MESSAGES) {\n+                          output.shouldContain(s);\n+                    }\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestDynamicRegenerateHolderClasses.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}