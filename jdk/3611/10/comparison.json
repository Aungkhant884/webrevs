{"files":[{"patch":"@@ -262,0 +262,1 @@\n+  log_info(cds)(\"               symbols = %5d\", _symbols->length());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/lambdaFormInvokers.hpp\"\n@@ -347,7 +348,6 @@\n-  }\n-  ArchiveClassesAtExit = archive_name;\n-  if (Arguments::init_shared_archive_paths()) {\n-    dump();\n-  } else {\n-    ArchiveClassesAtExit = nullptr;\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+    ArchiveClassesAtExit = archive_name;\n+    if (Arguments::init_shared_archive_paths()) {\n+      DynamicArchive::dump(CHECK);\n+    } else {\n+      ArchiveClassesAtExit = nullptr;\n+      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n@@ -355,5 +355,5 @@\n-  }\n-  \/\/ prevent do dynamic dump at exit.\n-  ArchiveClassesAtExit = nullptr;\n-  if (!Arguments::init_shared_archive_paths()) {\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+    }\n+    \/\/ prevent do dynamic dump at exit.\n+    ArchiveClassesAtExit = nullptr;\n+    if (!Arguments::init_shared_archive_paths()) {\n+      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n@@ -361,0 +361,1 @@\n+    }\n@@ -364,1 +365,1 @@\n-void DynamicArchive::dump() {\n+void DynamicArchive::dump(TRAPS) {\n@@ -370,0 +371,5 @@\n+  \/\/ regenerate lambdaform holder classes\n+  log_info(cds, dynamic)(\"Regenerate lambdaform holder classes ...\");\n+  LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+  log_info(cds, dynamic)(\"Regenerate lambdaform holder classes ...done\");\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static void dump();\n+  static void dump(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -49,1 +50,24 @@\n-GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+GrowableArrayCHeap<char*, mtClassShared>* LambdaFormInvokers::_lambdaform_lines = nullptr;\n+Array<Array<char>*>* LambdaFormInvokers::_static_archive_invokers = nullptr;\n+\n+#define NUM_FILTER 4\n+static const char* filter[NUM_FILTER] = {\"java.lang.invoke.Invokers$Holder\",\n+                                         \"java.lang.invoke.DirectMethodHandle$Holder\",\n+                                         \"java.lang.invoke.DelegatingMethodHandle$Holder\",\n+                                         \"java.lang.invoke.LambdaForm$Holder\"};\n+\n+static bool should_be_archived(char* line) {\n+  for (int k = 0; k < NUM_FILTER; k++) {\n+    if (strstr(line, filter[k]) != nullptr) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LambdaFormInvokers::append_filtered(char* line) {\n+  if (should_be_archived(line)) {\n+      append(line);\n+  }\n+}\n+#undef NUM_FILTER\n@@ -53,1 +77,1 @@\n-    _lambdaform_lines = new GrowableArray<char*>(100);\n+    _lambdaform_lines = new GrowableArrayCHeap<char*, mtClassShared>(150);\n@@ -58,0 +82,10 @@\n+#define HANDLE_IF_HAS_EXCEPTION                                                                         \\\n+  if (HAS_PENDING_EXCEPTION) {                                                                          \\\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {                                \\\n+      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),                             \\\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\\\n+      CLEAR_PENDING_EXCEPTION;                                                                          \\\n+    }                                                                                                   \\\n+    return;                                                                                             \\\n+  }\n+\n@@ -59,1 +93,5 @@\n-  assert(_lambdaform_lines != NULL, \"Bad List\");\n+  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n+    log_info(cds)(\"Nothing to regenerate for holder classes\");\n+    return;\n+  }\n+\n@@ -65,0 +103,1 @@\n+  log_debug(cds)(\"Total lambdaform lines %d\", _lambdaform_lines->length());\n@@ -66,0 +105,1 @@\n+  HandleMark hm(THREAD);\n@@ -83,6 +123,1 @@\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_info(cds)(\"%s: %s\", THREAD->pending_exception()->klass()->external_name(),\n-                            java_lang_String::as_utf8_string(java_lang_Throwable::message(THREAD->pending_exception())));\n-    CLEAR_PENDING_EXCEPTION;\n-    return;\n-  }\n+  HANDLE_IF_HAS_EXCEPTION;\n@@ -102,1 +137,1 @@\n-    char *buf = resource_allocate_bytes(THREAD, len);\n+    char *buf = NEW_RESOURCE_ARRAY(char, len);\n@@ -105,1 +140,0 @@\n-\n@@ -107,9 +141,1 @@\n-    \/\/ free buf\n-    resource_free_bytes(buf, len);\n-\n-    if (HAS_PENDING_EXCEPTION) {\n-      log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n-      log_info(cds)(\"Could not create InstanceKlass for class %s\", class_name);\n-      CLEAR_PENDING_EXCEPTION;\n-      return;\n-    }\n+    HANDLE_IF_HAS_EXCEPTION;\n@@ -150,1 +176,47 @@\n-  log_info(cds, lambda)(\"Replaced class %s, old: %p  new: %p\", name, klass, result);\n+  SystemDictionaryShared::init_dumptime_info(result);\n+  log_debug(cds, lambda)(\"Replaced class %s, old: %p  new: %p\", name, klass, result);\n+}\n+\n+void LambdaFormInvokers::dump_static_archive_invokers() {\n+  if (_lambdaform_lines != nullptr && _lambdaform_lines->length() > 0) {\n+    int count = 0;\n+    int len   = _lambdaform_lines->length();\n+    for (int i = 0; i < len; i++) {\n+      char* str = _lambdaform_lines->at(i);\n+      if (should_be_archived(str)) {\n+        count++;\n+      }\n+    }\n+    log_debug(cds)(\"Number of LF invoker lines stored: %d\", count);\n+    if (count > 0) {\n+      _static_archive_invokers = ArchiveBuilder::new_ro_array<Array<char>*>(count);\n+      int index = 0;\n+      for (int i = 0; i < len; i++) {\n+        char* str = _lambdaform_lines->at(i);\n+        if (should_be_archived(str)) {\n+          size_t str_len = strlen(str) + 1;  \/\/ including terminating zero\n+          Array<char>* line = ArchiveBuilder::new_ro_array<char>((int)str_len);\n+          strncpy(line->adr_at(0), str, str_len);\n+\n+          _static_archive_invokers->at_put(index, line);\n+          ArchivePtrMarker::mark_pointer(_static_archive_invokers->adr_at(index));\n+          index++;\n+        }\n+      }\n+      assert(index == count, \"Should match\");\n+    }\n+  }\n+}\n+\n+void LambdaFormInvokers::read_static_archive_invokers() {\n+  if (_static_archive_invokers != nullptr) {\n+    for (int i = 0; i < _static_archive_invokers->length(); i++) {\n+      Array<char>* line = _static_archive_invokers->at(i);\n+      char* str = line->adr_at(0);\n+      append_filtered(str);\n+    }\n+  }\n+}\n+\n+void LambdaFormInvokers::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_static_archive_invokers);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":93,"deletions":21,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -30,2 +31,0 @@\n-template <class T>\n-class GrowableArray;\n@@ -33,0 +32,1 @@\n+template <class T> class Array;\n@@ -36,1 +36,3 @@\n-  static GrowableArray<char*>* _lambdaform_lines;\n+  static GrowableArrayCHeap<char*, mtClassShared>* _lambdaform_lines;\n+  \/\/ for storing LF form lines (LF_RESOLVE only) in read only table.\n+  static Array<Array<char>*>* _static_archive_invokers;\n@@ -39,1 +41,0 @@\n-\n@@ -41,0 +42,3 @@\n+  static void append_filtered(char* line);\n+  \/\/ All exceptions except for OOM will be suppressed in the fucntion, the\n+  \/\/ non-OOM failure should not affect normal archiving.\n@@ -42,1 +46,1 @@\n-  static GrowableArray<char*>* lambdaform_lines() {\n+  static GrowableArrayCHeap<char*, mtClassShared>* lambdaform_lines() {\n@@ -45,0 +49,3 @@\n+  static void dump_static_archive_invokers();\n+  static void read_static_archive_invokers();\n+  static void serialize(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+  LambdaFormInvokers::serialize(soc);\n@@ -463,0 +464,2 @@\n+  \/\/ Write lambform lines into archive\n+  LambdaFormInvokers::dump_static_archive_invokers();\n@@ -928,0 +931,1 @@\n+    _requested_base_address = static_mapinfo->requested_base_address();\n@@ -933,1 +937,0 @@\n-    _requested_base_address = static_mapinfo->requested_base_address();\n@@ -1447,0 +1450,6 @@\n+  \/\/ Set up LambdaFormInvokers::_lambdaform_lines for dynamic dump\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Read stored LF format lines stored in static archive\n+    LambdaFormInvokers::read_static_archive_invokers();\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2208,0 +2208,13 @@\n+  if (DynamicArchive::is_mapped()) {\n+    \/\/ Those regenerated holder classes are in dynamic archive\n+    if (name == vmSymbols::java_lang_invoke_Invokers_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DirectMethodHandle_Holder() ||\n+        name == vmSymbols::java_lang_invoke_LambdaForm_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DelegatingMethodHandle_Holder()) {\n+      record = dynamic_dict->lookup(name, hash, 0);\n+      if (record != nullptr) {\n+        return record;\n+      }\n+    }\n+  }\n+\n@@ -2264,1 +2277,1 @@\n-    _st->print_cr(\"%4d: %s %s\", (_index++), record->_klass->external_name(),\n+    _st->print_cr(\"%4d: %s %s\", _index++, record->_klass->external_name(),\n@@ -2281,1 +2294,1 @@\n-        _st->print_cr(\"%4d: %s %s\", (++_index), k->external_name(),\n+        _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -299,6 +299,0 @@\n-  \/* used by CDS *\/                                                                               \\\n-  template(jdk_internal_misc_CDS,                     \"jdk\/internal\/misc\/CDS\")                    \\\n-  template(generateLambdaFormHolderClasses,           \"generateLambdaFormHolderClasses\")          \\\n-  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n-  template(dumpSharedArchive,                         \"dumpSharedArchive\")                        \\\n-  template(dumpSharedArchive_signature,               \"(ZLjava\/lang\/String;)V\")                   \\\n@@ -696,7 +690,16 @@\n-  \/* cds *\/                                                                                                       \\\n-  template(jdk_internal_loader_ClassLoaders,       \"jdk\/internal\/loader\/ClassLoaders\")                            \\\n-  template(java_util_concurrent_ConcurrentHashMap, \"java\/util\/concurrent\/ConcurrentHashMap\")                      \\\n-  template(java_util_ArrayList,                    \"java\/util\/ArrayList\")                                         \\\n-  template(toFileURL_name,                         \"toFileURL\")                                                   \\\n-  template(toFileURL_signature,                    \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                          \\\n-  template(url_void_signature,                     \"(Ljava\/net\/URL;)V\")                                           \\\n+  \/* CDS *\/                                                                                                       \\\n+  template(dumpSharedArchive,                               \"dumpSharedArchive\")                                  \\\n+  template(dumpSharedArchive_signature,                     \"(ZLjava\/lang\/String;)V\")                             \\\n+  template(generateLambdaFormHolderClasses,                 \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature,       \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")           \\\n+  template(java_lang_invoke_Invokers_Holder,                \"java\/lang\/invoke\/Invokers$Holder\")                   \\\n+  template(java_lang_invoke_DirectMethodHandle_Holder,      \"java\/lang\/invoke\/DirectMethodHandle$Holder\")         \\\n+  template(java_lang_invoke_LambdaForm_Holder,              \"java\/lang\/invoke\/LambdaForm$Holder\")                 \\\n+  template(java_lang_invoke_DelegatingMethodHandle_Holder,  \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\")     \\\n+  template(jdk_internal_loader_ClassLoaders,                \"jdk\/internal\/loader\/ClassLoaders\")                   \\\n+  template(jdk_internal_misc_CDS,                           \"jdk\/internal\/misc\/CDS\")                              \\\n+  template(java_util_concurrent_ConcurrentHashMap,          \"java\/util\/concurrent\/ConcurrentHashMap\")             \\\n+  template(java_util_ArrayList,                             \"java\/util\/ArrayList\")                                \\\n+  template(toFileURL_name,                                  \"toFileURL\")                                          \\\n+  template(toFileURL_signature,                             \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                 \\\n+  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/lambdaFormInvokers.hpp\"\n@@ -3648,1 +3649,1 @@\n-  return ClassListWriter::is_enabled();\n+  return ClassListWriter::is_enabled() || DynamicDumpSharedSpaces;\n@@ -3656,1 +3657,1 @@\n-  assert(ClassListWriter::is_enabled(), \"Should be set and open\");\n+  assert(ClassListWriter::is_enabled() || DynamicDumpSharedSpaces,  \"Should be set and open or do dynamic dump\");\n@@ -3661,2 +3662,9 @@\n-    ClassListWriter w;\n-    w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    if (DynamicDumpSharedSpaces) {\n+      \/\/ Note: LambdaFormInvokers::append_filtered and LambdaFormInvokers::append take same format which is not\n+      \/\/ same as below the print format. The line does not include LAMBDA_FORM_TAG.\n+      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+    }\n+    if (ClassListWriter::is_enabled()) {\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -506,1 +506,9 @@\n-    DynamicArchive::dump();\n+    ExceptionMark em(thread);\n+    DynamicArchive::dump(thread);\n+    if (thread->has_pending_exception()) {\n+      ResourceMark rm(thread);\n+      oop pending_exception = thread->pending_exception();\n+      log_error(cds)(\"ArchiveClassesAtExit has failed %s: %s\", pending_exception->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(pending_exception)));\n+      thread->clear_pending_exception();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255493\n+ * @summary LambHello World test for regenerate lambda holder classes in dynamic archive\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambHello sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar lambhello.jar LambHello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. TestDynamicRegenerateHolderClasses\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestDynamicRegenerateHolderClasses extends DynamicArchiveTestBase {\n+    static String CHECK_MESSAGES[] = {\"java.lang.invoke.Invokers$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DirectMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DelegatingMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.LambdaForm$Holder source: shared objects file (top)\"};\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestDynamicRegenerateHolderClasses::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"lambhello.jar\");\n+        String mainClass = \"LambHello\";\n+        dump(topArchiveName,\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=debug\",\n+              \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+        run(topArchiveName,\n+             \"-Xlog:class+load\",\n+             \"-Xlog:cds+dynamic=debug,cds=debug,class+load\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"LambHello source: shared objects file (top)\")\n+                          .shouldHaveExitValue(0);\n+                    for (String s : CHECK_MESSAGES) {\n+                          output.shouldContain(s);\n+                    }\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestDynamicRegenerateHolderClasses.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}