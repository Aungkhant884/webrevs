{"files":[{"patch":"@@ -87,0 +87,1 @@\n+  static CardValue g1_scanned_card_val() { return g1_card_already_scanned; }\n@@ -106,2 +107,2 @@\n-  \/\/ Mark the given range of cards as Scanned. All of these cards must be Dirty.\n-  inline void mark_as_scanned(size_t start_card_index, size_t num_cards);\n+  \/\/ Change the given range of dirty cards to \"which\". All of these cards must be Dirty.\n+  inline void change_dirty_cards_to(size_t start_card_index, size_t num_cards, CardValue which);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-inline void G1CardTable::mark_as_scanned(size_t start_card_index, size_t num_cards) {\n+inline void G1CardTable::change_dirty_cards_to(size_t start_card_index, size_t num_cards, CardValue which) {\n@@ -87,1 +87,1 @@\n-    *start++ = g1_card_already_scanned;\n+    *start++ = which;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3048,0 +3048,1 @@\n+        bool may_do_optional_evacuation = _collection_set.optional_region_length() != 0;\n@@ -3049,1 +3050,1 @@\n-        evacuate_initial_collection_set(&per_thread_states);\n+        evacuate_initial_collection_set(&per_thread_states, may_do_optional_evacuation);\n@@ -3051,1 +3052,1 @@\n-        if (_collection_set.optional_region_length() != 0) {\n+        if (may_do_optional_evacuation) {\n@@ -3823,0 +3824,1 @@\n+  bool _has_optional_evacuation_work;\n@@ -3826,1 +3828,1 @@\n-    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ObjCopy);\n+    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ObjCopy, _has_optional_evacuation_work);\n@@ -3847,1 +3849,2 @@\n-                        uint num_workers) :\n+                        uint num_workers,\n+                        bool has_optional_evacuation_work) :\n@@ -3849,1 +3852,2 @@\n-    _root_processor(root_processor)\n+    _root_processor(root_processor),\n+    _has_optional_evacuation_work(has_optional_evacuation_work)\n@@ -3853,1 +3857,2 @@\n-void G1CollectedHeap::evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states) {\n+void G1CollectedHeap::evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states,\n+                                                      bool has_optional_evacuation_work) {\n@@ -3868,1 +3873,6 @@\n-    G1EvacuateRegionsTask g1_par_task(this, per_thread_states, _task_queues, &root_processor, num_workers);\n+    G1EvacuateRegionsTask g1_par_task(this,\n+                                      per_thread_states,\n+                                      _task_queues,\n+                                      &root_processor,\n+                                      num_workers,\n+                                      has_optional_evacuation_work);\n@@ -3878,0 +3888,2 @@\n+\n+  rem_set()->complete_evac_phase(has_optional_evacuation_work);\n@@ -3883,1 +3895,1 @@\n-    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::OptObjCopy);\n+    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::OptObjCopy, true \/* remember_already_scanned_cards *\/);\n@@ -3943,0 +3955,2 @@\n+\n+    rem_set()->complete_evac_phase(true \/* has_more_than_one_evacuation_phase *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -785,1 +785,17 @@\n-  void evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states);\n+  \/\/ The has_optional_evacuation_work flag for the initial collection set\n+  \/\/ evacuation indicates whether one or more optional evacuation steps may\n+  \/\/ follow.\n+  \/\/ If not set, G1 can avoid clearing the card tables of regions that we scan\n+  \/\/ for roots from the heap: when scanning the card table for dirty cards after\n+  \/\/ all remembered sets have been dumped onto it, for optional evacuation we\n+  \/\/ mark these cards as \"Scanned\" to know that we do not need to re-scan them\n+  \/\/ in the additional optional evacuation passes. This means that in the \"Clear\n+  \/\/ Card Table\" phase we need to clear those marks. However, if there is no\n+  \/\/ optional evacuation, g1 can immediately clean the dirty cards it encounters\n+  \/\/ as nobody else will be looking at them again, saving the clear card table\n+  \/\/ work later.\n+  \/\/ This case is very common (young only collections and most mixed gcs), so\n+  \/\/ depending on the ratio between scanned and evacuated regions (which g1 always\n+  \/\/ needs to clear), this is a big win.\n+  void evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states,\n+                                       bool has_optional_evacuation_work);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -134,2 +134,11 @@\n-  \/\/ The complete set of regions which card table needs to be cleared at the end of GC because\n-  \/\/ we scribbled all over them.\n+  \/\/ The complete set of regions which card table needs to be cleared at the end\n+  \/\/ of GC because we scribbled over these card tables.\n+  \/\/\n+  \/\/ Regions may be added for two reasons:\n+  \/\/ - they were part of the collection set: they may contain g1_young_card_val\n+  \/\/ or regular card marks that we never scan so we must always clear their card\n+  \/\/ table\n+  \/\/ - or in case g1 does an optional evacuation pass, g1 marks the cards in there\n+  \/\/ as g1_scanned_card_val. If G1 only did an initial evacuation pass, the\n+  \/\/ scanning already cleared these cards. In that case they are not in this set\n+  \/\/ at the end of the collection.\n@@ -324,1 +333,1 @@\n-    _all_dirty_regions->merge(_next_dirty_regions);\n+    assert(_next_dirty_regions->size() == 0, \"next dirty regions must be empty\");\n@@ -326,1 +335,0 @@\n-    _next_dirty_regions->reset();\n@@ -334,0 +342,7 @@\n+  void complete_evac_phase(bool merge_dirty_regions) {\n+    if (merge_dirty_regions) {\n+      _all_dirty_regions->merge(_next_dirty_regions);\n+    }\n+    _next_dirty_regions->reset();\n+  }\n+\n@@ -377,2 +392,0 @@\n-    _all_dirty_regions->merge(_next_dirty_regions);\n-\n@@ -451,1 +464,1 @@\n-           \"Only add young regions to all dirty regions directly but %u is %s\",\n+           \"Only add collection set regions to all dirty regions directly but %u is %s\",\n@@ -644,0 +657,1 @@\n+  G1CardTable::CardValue _scanned_card_value;\n@@ -680,1 +694,1 @@\n-    _ct->mark_as_scanned(first_card, num_cards);\n+    _ct->change_dirty_cards_to(first_card, num_cards, _scanned_card_value);\n@@ -730,1 +744,2 @@\n-                           G1GCPhaseTimes::GCParPhases phase) :\n+                           G1GCPhaseTimes::GCParPhases phase,\n+                           bool remember_already_scanned_cards) :\n@@ -743,1 +758,3 @@\n-    _scanned_to(NULL) {\n+    _scanned_to(NULL),\n+    _scanned_card_value(remember_already_scanned_cards ? G1CardTable::g1_scanned_card_val()\n+                                                       : G1CardTable::clean_card_val()) {\n@@ -768,4 +785,5 @@\n-                            uint worker_id,\n-                            G1GCPhaseTimes::GCParPhases scan_phase,\n-                            G1GCPhaseTimes::GCParPhases objcopy_phase) {\n-  G1ScanHRForRegionClosure cl(_scan_state, pss, worker_id, scan_phase);\n+                               uint worker_id,\n+                               G1GCPhaseTimes::GCParPhases scan_phase,\n+                               G1GCPhaseTimes::GCParPhases objcopy_phase,\n+                               bool remember_already_scanned_cards) {\n+  G1ScanHRForRegionClosure cl(_scan_state, pss, worker_id, scan_phase, remember_already_scanned_cards);\n@@ -894,9 +912,1 @@\n-  if (region->in_collection_set()) {\n-    \/\/ Young regions had their card table marked as young at their allocation;\n-    \/\/ we need to make sure that these marks are cleared at the end of GC, *but*\n-    \/\/ they should not be scanned for cards.\n-    \/\/ So directly add them to the \"all_dirty_regions\".\n-    \/\/ Same for regions in the (initial) collection set: they may contain cards from\n-    \/\/ the log buffers, make sure they are cleaned.\n-    _scan_state->add_all_dirty_region(hrm_index);\n-  } else if (region->is_old_or_humongous_or_archive()) {\n+  if (region->is_old_or_humongous_or_archive()) {\n@@ -905,1 +915,2 @@\n-    assert(region->is_free(), \"Should only be free region at this point %s\", region->get_type_str());\n+    assert(region->in_collection_set() || region->is_free(),\n+           \"Should only be free or in the collection set at this point %s\", region->get_type_str());\n@@ -987,1 +998,15 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n+    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ table.\n+    \/\/\n+    \/\/ Called directly for humongous starts regions because we should not add\n+    \/\/ humongous eager reclaim candidates to the \"all\" list of regions to\n+    \/\/ clear the card table by default as we do not know yet whether this region\n+    \/\/ will be reclaimed (and reused).\n+    \/\/ If the humongous region contains dirty cards, g1 will scan them\n+    \/\/ because dumping the remembered set entries onto the card table will add\n+    \/\/ the humongous region to the \"dirty\" region list to scan. Then scanning\n+    \/\/ either clears the card during scan (if there is only an initial evacuation\n+    \/\/ pass) or the \"dirty\" list will be merged with the \"all\" list later otherwise.\n+    \/\/ (And there is no problem either way if the region does not contain dirty\n+    \/\/ cards).\n+    void dump_rem_set_for_region(HeapRegion* r) {\n@@ -994,0 +1019,7 @@\n+    }\n+\n+    virtual bool do_heap_region(HeapRegion* r) {\n+      assert(r->in_collection_set(), \"must be\");\n+\n+      _scan_state->add_all_dirty_region(r->hrm_index());\n+      dump_rem_set_for_region(r);\n@@ -1025,1 +1057,1 @@\n-      _cl.do_heap_region(r);\n+      _cl.dump_rem_set_for_region(r);\n@@ -1242,0 +1274,4 @@\n+void G1RemSet::complete_evac_phase(bool has_more_than_one_evacuation_phase) {\n+  _scan_state->complete_evac_phase(has_more_than_one_evacuation_phase);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":62,"deletions":26,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-                       G1GCPhaseTimes::GCParPhases objcopy_phase);\n+                       G1GCPhaseTimes::GCParPhases objcopy_phase,\n+                       bool remember_already_scanned_cards);\n@@ -94,0 +95,1 @@\n+  void complete_evac_phase(bool has_more_than_one_evacuation_phase);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}