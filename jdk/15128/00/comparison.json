{"files":[{"patch":"@@ -579,1 +579,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, ARGUMENT_PAIR(accessing_klass), jboolean resolve))\n+C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, ARGUMENT_PAIR(accessing_klass), jint accessing_klass_loader, jboolean resolve))\n@@ -596,2 +596,7 @@\n-    \/\/ Use the System class loader\n-    class_loader = Handle(THREAD, SystemDictionary::java_system_loader());\n+    switch (accessing_klass_loader) {\n+      case 0: break; \/\/ class_loader is already null, the boot loader\n+      case 1: class_loader = Handle(THREAD, SystemDictionary::java_platform_loader()); break;\n+      case 2: class_loader = Handle(THREAD, SystemDictionary::java_system_loader()); break;\n+      default:\n+        JVMCI_THROW_MSG_0(InternalError, err_msg(\"Illegal class loader value: %d\", accessing_klass_loader));\n+    }\n@@ -604,1 +609,1 @@\n-      JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);\n+      JVMCI_THROW_MSG_NULL(NoClassDefFoundError, str);\n@@ -3111,1 +3116,1 @@\n-  {CC \"lookupType\",                                   CC \"(\" STRING HS_KLASS2 \"Z)\" HS_RESOLVED_TYPE,                                        FN_PTR(lookupType)},\n+  {CC \"lookupType\",                                   CC \"(\" STRING HS_KLASS2 \"IZ)\" HS_RESOLVED_TYPE,                                       FN_PTR(lookupType)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-DO_THROW(ClassNotFoundException)\n+DO_THROW(NoClassDefFoundError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  DO_THROW(ClassNotFoundException)\n+  DO_THROW(NoClassDefFoundError)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,2 +246,2 @@\n-  start_class(OutOfMemoryError, java_lang_OutOfMemoryError)                                                         \\\n-    jvmci_constructor(OutOfMemoryError, \"(Ljava\/lang\/String;)V\")                                                 \\\n+  start_class(OutOfMemoryError, java_lang_OutOfMemoryError)                                                   \\\n+    jvmci_constructor(OutOfMemoryError, \"(Ljava\/lang\/String;)V\")                                              \\\n@@ -249,2 +249,2 @@\n-  start_class(ClassNotFoundException, java_lang_ClassNotFoundException)                                       \\\n-    jvmci_constructor(ClassNotFoundException, \"(Ljava\/lang\/String;)V\")                                        \\\n+  start_class(NoClassDefFoundError, java_lang_NoClassDefFoundError)                                           \\\n+    jvmci_constructor(NoClassDefFoundError, \"(Ljava\/lang\/String;)V\")                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -243,3 +243,1 @@\n-     * @param accessingClass the context of resolution. A value of {@code null} implies that the\n-     *            class should be resolved with the {@linkplain ClassLoader#getSystemClassLoader()\n-     *            system class loader}.\n+     * @param accessingClass the class loader of this class is used for resolution. Must not be null.\n@@ -249,1 +247,1 @@\n-     * @throws ClassNotFoundException if {@code resolve == true} and the resolution failed\n+     * @throws NoClassDefFoundError if {@code resolve == true} and the resolution failed\n@@ -251,2 +249,2 @@\n-    HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException {\n-        return lookupType(name, accessingClass, accessingClass != null ? accessingClass.getKlassPointer() : 0L, resolve);\n+    HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws NoClassDefFoundError {\n+        return lookupType(name, accessingClass, accessingClass.getKlassPointer(), -1, resolve);\n@@ -255,1 +253,22 @@\n-    private native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, long klassPointer, boolean resolve) throws ClassNotFoundException;\n+    \/**\n+     * Converts a name to a type.\n+     *\n+     * @param classLoader the class loader to use for resolution. Must not be {@code null},\n+     *           {@link ClassLoader#getPlatformClassLoader} or {@link ClassLoader#getSystemClassLoader}\n+     * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format\n+     * @return the type for {@code name}\n+     * @throws NoClassDefFoundError if resolution failed\n+     *\/\n+    HotSpotResolvedJavaType lookupType(ClassLoader classLoader, String name) throws NoClassDefFoundError {\n+        int accessingClassLoader;\n+        if (classLoader == null) {\n+            accessingClassLoader = 0;\n+        } else if (classLoader == ClassLoader.getPlatformClassLoader()) {\n+            accessingClassLoader = 1;\n+        } else if (classLoader == ClassLoader.getSystemClassLoader()) {\n+            accessingClassLoader = 2;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported class loader for lookup: \" + classLoader);\n+        }\n+        return lookupType(name, null, 0L, accessingClassLoader, true);\n+    }\n@@ -257,0 +276,13 @@\n+    \/**\n+     * @param accessingClassLoader ignored if {@code accessingKlassPointer != 0L}. Otherwise, the supported values are:\n+     *            0 - boot class loader\n+     *            1 - {@linkplain ClassLoader#getPlatformClassLoader() platform class loader}\n+     *            2 - {@linkplain ClassLoader#getSystemClassLoader() system class loader}\n+     *\/\n+    private native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, long accessingKlassPointer, int accessingClassLoader, boolean resolve) throws NoClassDefFoundError;\n+\n+    \/**\n+     * Converts {@code javaClass} to a HotSpotResolvedJavaType.\n+     *\n+     * Must not be called if {@link Services#IS_IN_NATIVE_IMAGE} is {@code true}.\n+     *\/\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -630,5 +630,1 @@\n-            try {\n-                return compilerToVm.lookupType(javaClass.getName().replace('.', '\/'), null, true);\n-            } catch (ClassNotFoundException e) {\n-                throw new JVMCIError(e);\n-            }\n+            return compilerToVm.lookupType(javaClass.getClassLoader(), javaClass.getName().replace('.', '\/'));\n@@ -872,2 +868,1 @@\n-        try {\n-            final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);\n+        final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);\n@@ -875,7 +870,3 @@\n-            if (klass == null) {\n-                assert resolve == false : name;\n-                return UnresolvedJavaType.create(name);\n-            }\n-            return klass;\n-        } catch (ClassNotFoundException e) {\n-            throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);\n+        if (klass == null) {\n+            assert resolve == false : name;\n+            return UnresolvedJavaType.create(name);\n@@ -883,0 +874,1 @@\n+        return klass;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-        private static ResolvedJavaType resolveType(String className) {\n-            return (ResolvedJavaType) runtime().lookupTypeInternal(className, null, true);\n+        private static ResolvedJavaType resolveType(String className, HotSpotResolvedObjectType accessingType) {\n+            return (ResolvedJavaType) runtime().lookupTypeInternal(className, accessingType, true);\n@@ -86,3 +86,4 @@\n-                ResolvedJavaType methodHandleType = resolveType(\"Ljava\/lang\/invoke\/MethodHandle;\");\n-                ResolvedJavaType memberNameType = resolveType(\"Ljava\/lang\/invoke\/MemberName;\");\n-                lambdaFormType = resolveType(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+                HotSpotResolvedObjectType accessingType = runtime().getJavaLangObject();\n+                ResolvedJavaType methodHandleType = resolveType(\"Ljava\/lang\/invoke\/MethodHandle;\", accessingType);\n+                ResolvedJavaType memberNameType = resolveType(\"Ljava\/lang\/invoke\/MemberName;\", accessingType);\n+                lambdaFormType = resolveType(\"Ljava\/lang\/invoke\/LambdaForm;\", accessingType);\n@@ -92,1 +93,1 @@\n-                ResolvedJavaType methodType = resolveType(\"Ljava\/lang\/invoke\/ResolvedMethodName;\");\n+                ResolvedJavaType methodType = resolveType(\"Ljava\/lang\/invoke\/ResolvedMethodName;\", accessingType);\n@@ -94,1 +95,1 @@\n-                vmtargetField = (HotSpotResolvedJavaField) findFieldInClass(methodType, \"vmtarget\", resolveType(Character.toString(HotSpotJVMCIRuntime.getHostWordKind().getTypeChar())));\n+                vmtargetField = (HotSpotResolvedJavaField) findFieldInClass(methodType, \"vmtarget\", resolveType(Character.toString(HotSpotJVMCIRuntime.getHostWordKind().getTypeChar()), accessingType));\n@@ -96,1 +97,1 @@\n-                ResolvedJavaType callSiteType = resolveType(\"Ljava\/lang\/invoke\/CallSite;\");\n+                ResolvedJavaType callSiteType = resolveType(\"Ljava\/lang\/invoke\/CallSite;\", accessingType);\n@@ -98,2 +99,2 @@\n-                ResolvedJavaType constantCallSiteType = resolveType(\"Ljava\/lang\/invoke\/ConstantCallSite;\");\n-                ResolvedJavaType booleanType = resolveType(\"Z\");\n+                ResolvedJavaType constantCallSiteType = resolveType(\"Ljava\/lang\/invoke\/ConstantCallSite;\", accessingType);\n+                ResolvedJavaType booleanType = resolveType(\"Z\", accessingType);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodHandleAccessProvider.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -191,10 +191,2 @@\n-            try {\n-                String name = theClass.getName().replace('.', '\/');\n-                HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) runtime().compilerToVm.lookupType(name, null, true);\n-                if (type == null) {\n-                    throw new InternalError(name);\n-                }\n-                return type;\n-            } catch (ClassNotFoundException e) {\n-                throw new InternalError(e);\n-            }\n+            String name = theClass.getName().replace('.', '\/');\n+            return (HotSpotResolvedObjectTypeImpl) runtime().compilerToVm.lookupType(theClass.getClassLoader(), name);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/SharedLibraryJVMCIReflection.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}