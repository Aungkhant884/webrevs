{"files":[{"patch":"@@ -2161,1 +2161,1 @@\n-char* os::vm_min_address() {\n+size_t os::vm_min_address() {\n@@ -2166,1 +2166,2 @@\n-  return (char*)(MAX2(os::vm_allocation_granularity(), 16 * M));\n+  assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+  return _vm_min_address_default;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1825,1 +1825,1 @@\n-char* os::vm_min_address() {\n+size_t os::vm_min_address() {\n@@ -1829,1 +1829,1 @@\n-  return (char*)((size_t)4 * G);\n+  return 4 * G;\n@@ -1831,1 +1831,2 @@\n-  return (char*)(MAX2(os::vm_allocation_granularity(), 16 * M));\n+  assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+  return _vm_min_address_default;\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4219,10 +4219,15 @@\n-char* os::vm_min_address() {\n-  \/\/ Determined by sysctl vm.mmap_min_addr. The usual value is 64 KB. Kernel prevents\n-  \/\/ mappings below that point. The reason for this forbidden zone is to improve safety\n-  \/\/ in case of NULL pointer dereferences.\n-  \/\/ This value is rarely changed from its default, and instead of retrieving the\n-  \/\/ parameter, we save a syscall and just return a sensible default. That default\n-  \/\/ is chosen to be somewhat larger than the typical 64 KB for increased protection\n-  \/\/ against NULL pointer dereferences: 16 MB is comfortably larger than any fixed-sized\n-  \/\/ structure we use but still affords us most of the valuable low-address space.\n-  return (char*)(MAX2(os::vm_allocation_granularity(), 16 * M));\n+size_t os::vm_min_address() {\n+  \/\/ Determined by sysctl vm.mmap_min_addr. It exists as a safety zone to prevent\n+  \/\/ NULL pointer dereferences.\n+  \/\/ Most distros set this value to 64 KB. It *can* be zero, but rarely is. Here,\n+  \/\/ we impose a minimum value if vm.mmap_min_addr is too low, for increased protection.\n+  static size_t value = 0;\n+  if (value == 0) {\n+    assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+    FILE* f = fopen(\"\/proc\/sys\/vm\/mmap_min_addr\", \"r\");\n+    if (fscanf(f, \"%zu\", &value) != 1) {\n+      value = _vm_min_address_default;\n+    }\n+    value = MAX2(_vm_min_address_default, value);\n+  }\n+  return value;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3426,2 +3426,3 @@\n-char* os::vm_min_address() {\n-  return (char*)(MAX2(os::vm_allocation_granularity(), 16 * M));\n+size_t os::vm_min_address() {\n+  assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+  return _vm_min_address_default;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1331,2 +1331,6 @@\n-      \/\/ Reserve anywhere, but mapping start address must be directly encodable as encoding base.\n-      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, true);\n+      \/\/ We did not manage to reserve at the preferred address, or were instructed to relocate. In that\n+      \/\/ case we reserve whereever, but the start address needs to be encodable as narrow Klass encoding base\n+      \/\/ since the archived heap objects contain nKlass IDs precalculated toward the start of the shared Metaspace.\n+      \/\/ The \"cds_runtime\" parameter expresses that.\n+      constexpr bool cds_runtime = true;\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, cds_runtime);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -594,2 +594,3 @@\n-  \/\/ If strict_base, there is no need bothering with low-address reservation since we cannot set\n-  \/\/ the encoding base to zero.\n+  \/\/ At CDS runtime, there is no need bothering with low-address reservation since we cannot set\n+  \/\/ the encoding base to zero anyway: the encoding base has to be the base of the mapped archive\n+  \/\/ (ultimately, the start address of the region we are reserving here).\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1840,1 +1840,1 @@\n-  char* const absolute_min = os::vm_min_address();\n+  char* const absolute_min = (char*) os::vm_min_address();\n@@ -1947,1 +1947,1 @@\n-    assert(result >= os::vm_min_address(), \"OOB vm.map min (\" ERRFMT \")\", ERRFMTARGS);\n+    assert(result >= (char*)os::vm_min_address(), \"OOB vm.map min (\" ERRFMT \")\", ERRFMTARGS);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+  \/\/ The default value for os::vm_min_address() unless the platform knows better. This value\n+  \/\/ is chosen to give us reasonable protection against NULL pointer dereferences while being\n+  \/\/ low enough to leave most of the valuable low-4gb address space open.\n+  static constexpr size_t _vm_min_address_default = 16 * M;\n+\n@@ -423,1 +428,2 @@\n-  static char* vm_min_address();\n+  \/\/ Returns the lowest address the process is allowed to map against.\n+  static size_t vm_min_address();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -927,0 +927,10 @@\n+\n+TEST_VM(os, vm_min_address) {\n+  size_t s = os::vm_min_address();\n+  ASSERT_GE(s, M);\n+  \/\/ Test upper limit. On Linux, its adjustable, so we just test for absurd values to prevent errors\n+  \/\/ with high vm.mmap_min_addr settings.\n+#if defined(_LP64)\n+  ASSERT_LE(s, NOT_LINUX(G * 4) LINUX_ONLY(G * 1024));\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    EXPECT_GE(addr, os::vm_min_address()) << ERRINFO;\n+    EXPECT_GE(addr, (char*)os::vm_min_address()) << ERRINFO;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_reserve_between.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}