{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,42 @@\n+    \/**\n+     * Forces a call to the native implementation of the connection\n+     * channel to verify that this channel is still open.\n+     * <p>\n+     * This method should only be called just after an HTTP\/1.1\n+     * connection is retrieved from the HTTP\/1.1 connection pool.\n+     * It is used to trigger an early detection of the channel state,\n+     * before handling the connection over to the HTTP stack.\n+     * It helps minimizing race conditions where the selector manager\n+     * thread hasn't woken up - or hasn't raised the event, before\n+     * the connection was retrieved from the pool. It helps reduce\n+     * the occurrence of \"HTTP\/1.1 parser received no bytes\"\n+     * exception, when the server closes the connection while\n+     * it's being taken out of the pool.\n+     * <p>\n+     * This method attempts to read one byte from the underlying\n+     * channel. Because the connection was in the pool - there\n+     * should be nothing to read.\n+     * <p>\n+     * If {@code read} manages to read a byte off the connection, this is a\n+     * protocol error: the method closes the connection and returns false.\n+     * If {@code read} returns EOF, the method closes the connection and\n+     * returns false.\n+     * If {@code read} throws an exception, the method returns false.\n+     * Otherwise, {@code read} returns 0, the channel appears to be\n+     * still open, and the method returns true.\n+     * @return true if the channel appears to be still open.\n+     *\/\n+    final boolean checkOpen() {\n+        if (isOpen()) {\n+            try {\n+                \/\/ channel is non blocking\n+                int read = channel().read(ByteBuffer.allocate(1));\n+                if (read == 0) return true;\n+                close();\n+            } catch (IOException x) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -209,1 +251,1 @@\n-            if (c != null && c.isOpen() \/* may have been eof\/closed when in the pool *\/) {\n+            if (c != null && c.checkOpen() \/* may have been eof\/closed when in the pool *\/) {\n@@ -353,1 +395,1 @@\n-        if (keepAlive && isOpen()) {\n+        if (keepAlive && checkOpen()) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.ProxySelector;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @test\n+ * @bug 8262027\n+ * @summary Verify that it's possible to handle proxy authentication manually\n+ *          even when using an HTTPS tunnel. This test uses an authenticating\n+ *          proxy (basic auth) serving an authenticated server (basic auth).\n+ *          The test also helps verifying the fix for 8262027.\n+ * @library \/test\/lib http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters ProxyServer HttpsTunnelAuthTest\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ * @run main\/othervm -Djdk.httpclient.HttpClient.log=requests,headers,errors\n+ *                   -Djdk.http.auth.tunneling.disabledSchemes\n+ *                   -Djdk.httpclient.allowRestrictedHeaders=connection\n+ *                   -Djdk.internal.httpclient.debug=true\n+ *                   HttpsTunnelAuthTest\n+ *\n+ *\/\n+\/\/-Djdk.internal.httpclient.debug=true -Dtest.debug=true\n+public class HttpsTunnelAuthTest implements HttpServerAdapters, AutoCloseable {\n+\n+    static final String data[] = {\n+        \"Lorem ipsum\",\n+        \"dolor sit amet\",\n+        \"consectetur adipiscing elit, sed do eiusmod tempor\",\n+        \"quis nostrud exercitation ullamco\",\n+        \"laboris nisi\",\n+        \"ut\",\n+        \"aliquip ex ea commodo consequat.\" +\n+        \"Duis aute irure dolor in reprehenderit in voluptate velit esse\" +\n+        \"cillum dolore eu fugiat nulla pariatur.\",\n+        \"Excepteur sint occaecat cupidatat non proident.\"\n+    };\n+\n+    static final SSLContext context;\n+    static {\n+        try {\n+            context = new SimpleSSLContext().get();\n+            SSLContext.setDefault(context);\n+        } catch (Exception x) {\n+            throw new ExceptionInInitializerError(x);\n+        }\n+    }\n+\n+    final String realm = \"earth\";\n+    final String sUserName = \"arthur\";\n+    final String pUserName = \"porpoise\";\n+    final String sPassword = \"dent\";\n+    final String pPassword = \"fish\";\n+    final String proxyAuth = \"Basic \" + Base64.getEncoder().withoutPadding()\n+            .encodeToString((pUserName+\":\"+pPassword).getBytes(StandardCharsets.US_ASCII));\n+    final String serverAuth = \"Basic \" + Base64.getEncoder().withoutPadding()\n+            .encodeToString((sUserName+\":\"+sPassword).getBytes(StandardCharsets.UTF_8));\n+    final DigestEchoServer.HttpTestAuthenticator testAuth =\n+            new DigestEchoServer.HttpTestAuthenticator(realm, sUserName);\n+\n+    DigestEchoServer http1Server;\n+    DigestEchoServer https1Server;\n+    DigestEchoServer https2Server;\n+    ProxyServer proxy;\n+    ProxySelector proxySelector;\n+    HttpClient client;\n+\n+    HttpsTunnelAuthTest() {\n+    }\n+\n+    void setUp() throws IOException {\n+        \/\/ Creates an HTTP\/1.1 Server that will authenticate for\n+        \/\/ arthur with password dent\n+        http1Server = DigestEchoServer.createServer(Version.HTTP_1_1,\n+                \"http\",\n+                DigestEchoServer.HttpAuthType.SERVER,\n+                testAuth,\n+                DigestEchoServer.HttpAuthSchemeType.BASICSERVER,\n+                new HttpTestEchoHandler(),\n+                \"\/\");\n+\n+        \/\/ Creates a TLS HTTP\/1.1 Server that will authenticate for\n+        \/\/ arthur with password dent\n+        https1Server = DigestEchoServer.createServer(Version.HTTP_1_1,\n+                        \"https\",\n+                        DigestEchoServer.HttpAuthType.SERVER,\n+                        testAuth,\n+                        DigestEchoServer.HttpAuthSchemeType.BASICSERVER,\n+                        new HttpTestEchoHandler(),\n+                        \"\/\");\n+\n+        \/\/ Creates a TLS HTTP\/2 Server that will authenticate for\n+        \/\/ arthur with password dent\n+        https2Server = DigestEchoServer.createServer(Version.HTTP_2,\n+                        \"https\",\n+                        DigestEchoServer.HttpAuthType.SERVER,\n+                        testAuth,\n+                        DigestEchoServer.HttpAuthSchemeType.BASICSERVER,\n+                        new HttpTestEchoHandler(), \"\/\");\n+\n+        \/\/ Creates a proxy server that will authenticate for\n+        \/\/ porpoise with password fish.\n+        proxy = new ProxyServer(0, true, pUserName, pPassword);\n+\n+        \/\/ Creates a proxy selector that unconditionally select the\n+        \/\/ above proxy.\n+        var ps = proxySelector = ProxySelector.of(proxy.getProxyAddress());\n+\n+        \/\/ Creates a client that uses the above proxy selector\n+        client = newHttpClient(ps);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        if (proxy != null) close(proxy::stop);\n+        if (http1Server != null) close(http1Server::stop);\n+        if (https1Server != null) close(https1Server::stop);\n+        if (https2Server != null) close(https2Server::stop);\n+    }\n+\n+    private void close(AutoCloseable closeable) {\n+        try {\n+            closeable.close();\n+        } catch (Exception x) {\n+            \/\/ OK.\n+        }\n+    }\n+\n+    public HttpClient newHttpClient(ProxySelector ps) {\n+        HttpClient.Builder builder = HttpClient\n+                .newBuilder()\n+                .sslContext(context)\n+                .proxy(ps);\n+        return builder.build();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (HttpsTunnelAuthTest test = new HttpsTunnelAuthTest()) {\n+            test.setUp();\n+\n+            \/\/ tests proxy and server authentication through:\n+            \/\/ - plain proxy connection to plain HTTP\/1.1 server,\n+            test.test(Version.HTTP_1_1, \"http\", \"\/foo\/http1\");\n+\n+            \/\/ can't really test plain proxy connection to plain HTTP\/2 server:\n+            \/\/ this is not supported: we downgrade to HTTP\/1.1 in that case\n+            \/\/ so that is actually somewhat equivalent to the first case:\n+            \/\/ therefore we will use a new client to force re-authentication\n+            \/\/ of the proxy connection.\n+            test.client = test.newHttpClient(test.proxySelector);\n+            test.test(Version.HTTP_2, \"http\", \"\/foo\/http2\");\n+\n+            \/\/ - proxy tunnel SSL connection to HTTP\/1.1 server\n+            test.test(Version.HTTP_1_1, \"https\", \"\/foo\/https1\");\n+\n+            \/\/ - proxy tunnel SSl connection to HTTP\/2 server\n+            test.test(Version.HTTP_2, \"https\", \"\/foo\/https2\");\n+        }\n+    }\n+\n+    DigestEchoServer server(String scheme, Version version) {\n+        return switch (scheme) {\n+            case \"https\" -> secure(version);\n+            case \"http\" -> unsecure(version);\n+            default -> throw new IllegalArgumentException(scheme);\n+        };\n+    }\n+\n+    DigestEchoServer unsecure(Version version) {\n+        return switch (version) {\n+            \/\/ when accessing HTTP\/2 through a proxy we downgrade to HTTP\/1.1\n+            case HTTP_1_1, HTTP_2 -> http1Server;\n+            default -> throw new IllegalArgumentException(String.valueOf(version));\n+        };\n+    }\n+\n+    DigestEchoServer secure(Version version) {\n+        return switch (version) {\n+            case HTTP_1_1 -> https1Server;\n+            case HTTP_2 -> https2Server;\n+            default -> throw new IllegalArgumentException(String.valueOf(version));\n+        };\n+    }\n+\n+    Version expectedVersion(String scheme, Version version) {\n+        \/\/ when trying to send a plain HTTP\/2 request through a proxy\n+        \/\/ it should be downgraded to HTTP\/1\n+        return \"http\".equals(scheme) ? Version.HTTP_1_1 : version;\n+    }\n+\n+    public void test(Version version, String scheme, String path) throws Exception {\n+        System.out.printf(\"%nTesting %s, %s, %s%n\", version, scheme, path);\n+        DigestEchoServer server = server(scheme, version);\n+        try {\n+\n+            URI uri = jdk.test.lib.net.URIBuilder.newBuilder()\n+                    .scheme(scheme)\n+                    .host(\"localhost\")\n+                    .port(server.getServerAddress().getPort())\n+                    .path(path).build();\n+\n+            out.println(\"Proxy is: \" + proxySelector.select(uri));\n+\n+            List<String> lines = List.of(Arrays.copyOfRange(data, 0, data.length));\n+            assert lines.size() == data.length;\n+            String body = lines.stream().collect(Collectors.joining(\"\\r\\n\"));\n+            HttpRequest.BodyPublisher reqBody = HttpRequest.BodyPublishers.ofString(body);\n+\n+            \/\/ Build first request, with no authorization header\n+            HttpRequest.Builder req1Builder = HttpRequest\n+                    .newBuilder(uri)\n+                    .version(Version.HTTP_2)\n+                    .POST(reqBody);\n+            HttpRequest req1 = req1Builder.build();\n+            out.printf(\"%nPosting to %s server at: %s%n\", expectedVersion(scheme, version), req1);\n+\n+            \/\/ send first request, with no authorization: we expect 407\n+            HttpResponse<Stream<String>> response = client.send(req1, BodyHandlers.ofLines());\n+            out.println(\"Checking response: \" + response);\n+            if (response.body() != null) response.body().sequential().forEach(out::println);\n+\n+            \/\/ check that we got 407, and check that we got the expected\n+            \/\/ Proxy-Authenticate header\n+            if (response.statusCode() != 407) {\n+                throw new RuntimeException(\"Unexpected status code: \" + response);\n+            }\n+            var pAuthenticate = response.headers().firstValue(\"proxy-authenticate\").get();\n+            if (!pAuthenticate.equals(\"Basic realm=\\\"proxy realm\\\"\")) {\n+                throw new RuntimeException(\"Unexpected proxy-authenticate: \" + pAuthenticate);\n+            }\n+\n+            \/\/ Second request will have Proxy-Authorization, no Authorization.\n+            \/\/ We should get 401 from the server this time.\n+            out.printf(\"%nPosting with Proxy-Authorization to %s server at: %s%n\", expectedVersion(scheme, version), req1);\n+            HttpRequest authReq1 = HttpRequest.newBuilder(req1, (k, v)-> true)\n+                    .header(\"proxy-authorization\", proxyAuth).build();\n+            response = client.send(authReq1, BodyHandlers.ofLines());\n+            out.println(\"Checking response: \" + response);\n+            if (response.body() != null) response.body().sequential().forEach(out::println);\n+\n+            \/\/ Check that we have 401, and that we got the expected\n+            \/\/ WWW-Authenticate header\n+            if (response.statusCode() != 401) {\n+                throw new RuntimeException(\"Unexpected status code: \" + response);\n+            }\n+            var sAuthenticate = response.headers().firstValue(\"www-authenticate\").get();\n+            if (!sAuthenticate.startsWith(\"Basic realm=\\\"earth\\\"\")) {\n+                throw new RuntimeException(\"Unexpected authenticate: \" + sAuthenticate);\n+            }\n+\n+            \/\/ Third request has both Proxy-Authorization and Authorization,\n+            \/\/ so we now expect 200\n+            out.printf(\"%nPosting with Authorization to %s server at: %s%n\", expectedVersion(scheme, version), req1);\n+            HttpRequest authReq2 = HttpRequest.newBuilder(authReq1, (k, v)-> true)\n+                    .header(\"authorization\", serverAuth).build();\n+            response = client.send(authReq2, BodyHandlers.ofLines());\n+            out.println(\"Checking response: \" + response);\n+\n+            \/\/ Check that we have 200 and the expected body echoed back.\n+            \/\/ Check that the response version is as expected too.\n+            if (response.statusCode() != 200) {\n+                throw new RuntimeException(\"Unexpected status code: \" + response);\n+            }\n+\n+            if (response.version() != expectedVersion(scheme, version)) {\n+                throw new RuntimeException(\"Unexpected protocol version: \"\n+                        + response.version());\n+            }\n+            List<String> respLines = response.body().collect(Collectors.toList());\n+            if (!lines.equals(respLines)) {\n+                throw new RuntimeException(\"Unexpected response 1: \" + respLines);\n+            }\n+        } catch(Throwable t) {\n+            out.println(\"Unexpected exception: exiting: \" + t);\n+            t.printStackTrace(out);\n+            throw t;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpsTunnelAuthTest.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -29,0 +32,2 @@\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -30,0 +35,1 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -41,1 +47,16 @@\n-    ServerSocket listener;\n+    \/\/ could use the test library here - Platform.isWindows(),\n+    \/\/ but it would force all tests that use ProxyServer to\n+    \/\/ build it. Let's keep it simple.\n+    static final boolean IS_WINDOWS;\n+    static {\n+        PrivilegedAction<String> action =\n+                () -> System.getProperty(\"os.name\", \"unknown\");\n+        String osName = AccessController.doPrivileged(action);\n+        IS_WINDOWS = osName.toLowerCase(Locale.ROOT).startsWith(\"win\");\n+    }\n+\n+    public static boolean isWindows() {\n+        return IS_WINDOWS;\n+    }\n+\n+    ServerSocketChannel listener;\n@@ -87,2 +108,2 @@\n-        listener = new ServerSocket();\n-        listener.setReuseAddress(false);\n+        listener = ServerSocketChannel.open();\n+        listener.setOption(StandardSocketOptions.SO_REUSEADDR, false);\n@@ -90,1 +111,1 @@\n-        this.port = listener.getLocalPort();\n+        this.port = ((InetSocketAddress)listener.getLocalAddress()).getPort();\n@@ -110,0 +131,4 @@\n+    public InetSocketAddress getProxyAddress() throws IOException  {\n+        return (InetSocketAddress)listener.getLocalAddress();\n+    }\n+\n@@ -146,1 +171,1 @@\n-                Socket s = listener.accept();\n+                SocketChannel s = listener.accept();\n@@ -150,1 +175,1 @@\n-                    System.out.println(\"Proxy: accepted new connection: \" + s);\n+                    System.out.println(\"Proxy: accepted new connection: \" + c);\n@@ -168,1 +193,1 @@\n-        Socket clientSocket, serverSocket;\n+        SocketChannel clientSocket, serverSocket;\n@@ -176,1 +201,1 @@\n-        Connection(Socket s, int id) throws IOException {\n+        Connection(SocketChannel s, int id) throws IOException {\n@@ -179,2 +204,2 @@\n-            this.clientIn = new BufferedInputStream(s.getInputStream());\n-            this.clientOut = s.getOutputStream();\n+            this.clientIn = new BufferedInputStream(s.socket().getInputStream());\n+            this.clientOut = s.socket().getOutputStream();\n@@ -291,0 +316,3 @@\n+                String host;\n+                List<String> headers;\n+                boolean authorized = false;\n@@ -296,1 +324,1 @@\n-                                    + new String(buf, UTF_8) + \"]\" );\n+                                    + new String(buf, ISO_8859_1) + \"]\" );\n@@ -301,1 +329,2 @@\n-                    List<String> headers = asList(new String(buf, UTF_8).split(\"\\r\\n\"));\n+                    headers = asList(new String(buf, ISO_8859_1).split(\"\\r\\n\"));\n+                    host = findFirst(headers, \"host\");\n@@ -303,6 +332,23 @@\n-                    if (credentials != null && !authorized(credentials, headers)) {\n-                        String resp = \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n-                                      \"Content-Length: 0\\r\\n\" +\n-                                      \"Proxy-Authenticate: Basic realm=\\\"proxy realm\\\"\\r\\n\\r\\n\";\n-\n-                        clientOut.write(resp.getBytes(UTF_8));\n+                    if (credentials != null) {\n+                        if (!authorized(credentials, headers)) {\n+                            String resp = \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+                                    \"Content-Length: 0\\r\\n\" +\n+                                    \"Proxy-Authenticate: Basic realm=\\\"proxy realm\\\"\\r\\n\\r\\n\";\n+                            clientSocket.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                            clientSocket.setOption(StandardSocketOptions.SO_LINGER, 2);\n+                            var buffer = ByteBuffer.wrap(resp.getBytes(ISO_8859_1));\n+                            clientSocket.write(buffer);\n+                            if (debug) {\n+                                var linger = clientSocket.getOption(StandardSocketOptions.SO_LINGER);\n+                                var nodelay = clientSocket.getOption(StandardSocketOptions.TCP_NODELAY);\n+                                System.out.printf(\"Proxy: unauthorized; 407 sent (%s\/%s), linger: %s, nodelay: %s%n\",\n+                                        buffer.position(), buffer.position() + buffer.remaining(), linger, nodelay);\n+                            }\n+                            if (shouldCloseAfter407(headers)) {\n+                                closeConnection();\n+                                return;\n+                            }\n+                            continue;\n+                        }\n+                        authorized = true;\n+                        break;\n@@ -315,1 +361,1 @@\n-                String cmd = new String(buf, 0, p, \"US-ASCII\");\n+                String cmd = new String(buf, 0, p, ISO_8859_1);\n@@ -321,1 +367,10 @@\n-                    doProxy(params[1], buf, p, cmd);\n+                    \/\/ TODO:\n+                    \/\/ this does not really work as it should: it also establishes\n+                    \/\/ a tunnel (proxyCommon). So it works as long as the client only\n+                    \/\/ sends a single plain request through the proxy - as all\n+                    \/\/ other requests would otherwise be tunneled to the\n+                    \/\/ server identified in the first request.\n+                    \/\/ It seems enough for our purpose for now, though.\n+                    \/\/ Fixing this would imply dealing with Content-Length, Transfer-Encoding,\n+                    \/\/ etc, both when writing to and reading from the server.\n+                    doProxy(params[1], cmd, headers, host, authorized);\n@@ -332,1 +387,113 @@\n-        void doProxy(String dest, byte[] buf, int p, String cmdLine)\n+        String findFirst(List<String> headers, String key) {\n+            var h = key.toLowerCase(Locale.ROOT) + \": \";\n+            return headers.stream()\n+                    .filter((s) -> s.toLowerCase(Locale.ROOT).startsWith(h))\n+                    .findFirst()\n+                    .map((s) -> s.substring(h.length()))\n+                    .map(String::trim)\n+                    .orElse(null);\n+        }\n+\n+        private long drain(SocketChannel socket) throws IOException {\n+            boolean isBlocking = socket.isBlocking();\n+            if (isBlocking) {\n+                socket.configureBlocking(false);\n+            }\n+            try {\n+                ByteBuffer buffer = ByteBuffer.allocate(1024);\n+                int read;\n+                long drained = 0;\n+                while ((read = socket.read(buffer)) > 0) {\n+                    drained += read;\n+                    buffer.position(0);\n+                    buffer.limit(buffer.capacity());\n+                }\n+                return drained;\n+            } finally {\n+                if (isBlocking) {\n+                    socket.configureBlocking(true);\n+                }\n+            }\n+        }\n+\n+        void closeConnection() throws IOException {\n+            if (debug) {\n+                var linger = clientSocket.getOption(StandardSocketOptions.SO_LINGER);\n+                var nodelay = clientSocket.getOption(StandardSocketOptions.TCP_NODELAY);\n+                System.out.printf(\"Proxy: closing connection id=%s, linger: %s, nodelay: %s%n\",\n+                        id, linger, nodelay);\n+            }\n+            long drained = drain(clientSocket);\n+            if (debug) {\n+                System.out.printf(\"Proxy: drained: %s%n\", drained);\n+            }\n+            clientSocket.shutdownOutput();\n+            try {\n+                \/\/ On windows, we additionally need to delay before\n+                \/\/ closing the socket. Otherwise we get a reset on the\n+                \/\/ client side (The connection was aborted by a software\n+                \/\/ on the host machine).\n+                \/\/ Delay 500ms before actually closing the socket\n+                if (isWindows()) Thread.sleep(500);\n+            } catch (InterruptedException x) {\n+                \/\/ OK\n+            }\n+            clientSocket.shutdownInput();\n+            close();\n+        }\n+\n+        \/\/ If the client sends a request body we will need to close the connection\n+        \/\/ otherwise, we can keep it open.\n+        private boolean shouldCloseAfter407(List<String> headers) throws IOException {\n+            var te = findFirst(headers, \"transfer-encoding\");\n+            if (te != null) {\n+                \/\/ processing transfer encoding not implemented\n+                if (debug) {\n+                    System.out.println(\"Proxy: transfer-encoding with 407, closing connection\");\n+                }\n+                return true; \/\/ should close\n+            }\n+            var cl = findFirst(headers, \"content-length\");\n+            int n = -1;\n+            try {\n+                n = Integer.parseInt(cl);\n+                if (debug) {\n+                    System.out.printf(\"Proxy: content-length: %d%n\", cl);\n+                }\n+            } catch (IllegalFormatException x) {\n+                if (debug) {\n+                    System.out.println(\"Proxy: bad content-length, closing connection\");\n+                }\n+                return true;  \/\/ should close\n+            }\n+            if (n > 0 || n < -1) {\n+                if (debug) {\n+                    System.out.println(\"Proxy: request body with 407, closing connection\");\n+                }\n+                return true;  \/\/ should close\n+            }\n+            var cmdline = headers.get(0);\n+            int m = cmdline.indexOf(' ');\n+            var method = (m > 0) ? cmdline.substring(0, m) : null;\n+            var nobody = List.of(\"GET\", \"HEAD\");\n+            if (n == 0 || nobody.contains(m)) {\n+                var available = clientIn.available();\n+                var drained = drain(clientSocket);\n+                if (drained > 0 || available > 0) {\n+                    if (debug) {\n+                        System.out.printf(\"Proxy: unexpected bytes (%d) with 407, closing connection%n\",\n+                                drained + available);\n+                    }\n+                    return true;  \/\/ should close\n+                }\n+                \/\/ can keep open: CL=0 or no CL and GET or HEAD\n+                return false;\n+            } else {\n+                if (debug) {\n+                    System.out.println(\"Proxy: possible body with 407, closing connection\");\n+                }\n+                return true; \/\/ should close\n+            }\n+        }\n+\n+        void doProxy(String dest, String cmdLine, List<String> headers, String host, boolean authorized)\n@@ -338,1 +505,5 @@\n-                    throw new IOException(\"request URI not absolute\");\n+                    if (host == null) {\n+                        throw new IOException(\"request URI not absolute\");\n+                    } else {\n+                        uri = new URI(\"http:\/\/\" + host + dest);\n+                    }\n@@ -340,0 +511,1 @@\n+                if (debug) System.out.printf(\"Proxy: uri=%s%n\", uri);\n@@ -345,6 +517,0 @@\n-                int x = cmdLine.length() - 1;\n-                int i = p;\n-                while (x >=0) {\n-                    buf[i--] = (byte)cmdLine.charAt(x--);\n-                }\n-                i++;\n@@ -359,2 +525,19 @@\n-                sout.write(buf, i, buf.length-i);\n-                proxyCommon();\n+                byte[] CRLF = new byte[] { (byte) '\\r', (byte) '\\n'};\n+                sout.write(cmdLine.getBytes(ISO_8859_1));\n+                sout.write(CRLF);\n+                if (debug) System.out.printf(\"Proxy Forwarding: %s%n\", cmdLine);\n+                for (int l=1; l<headers.size(); l++) {\n+                    var s = headers.get(l);\n+                    if (!authorized || !s.toLowerCase(Locale.ROOT).startsWith(\"proxy-authorization\")) {\n+                        sout.write(s.getBytes(ISO_8859_1));\n+                        sout.write(CRLF);\n+                        if (debug) System.out.printf(\"Proxy Forwarding: %s%n\", s);\n+                    } else {\n+                        if (debug) System.out.printf(\"Proxy Skipping: %s%n\", s);\n+                    }\n+                }\n+                sout.write(CRLF);\n+                if (debug) System.out.printf(\"Proxy Forwarding: %n\");\n+\n+                \/\/ This will now establish a tunnel :-(\n+                proxyCommon(debug);\n@@ -378,2 +561,3 @@\n-            serverSocket = new Socket(hostport[0], port);\n-            serverOut = serverSocket.getOutputStream();\n+            serverSocket = SocketChannel.open();\n+            serverSocket.connect(new InetSocketAddress(hostport[0], port));\n+            serverOut = serverSocket.socket().getOutputStream();\n@@ -381,1 +565,1 @@\n-            serverIn = new BufferedInputStream(serverSocket.getInputStream());\n+            serverIn = new BufferedInputStream(serverSocket.socket().getInputStream());\n@@ -384,1 +568,1 @@\n-        synchronized void proxyCommon() throws IOException {\n+        synchronized void proxyCommon(boolean log) throws IOException {\n@@ -390,0 +574,1 @@\n+                    int body = 0;\n@@ -392,0 +577,3 @@\n+                        body += n;\n+                        if (log)\n+                            System.out.printf(\"Proxy Forwarding [request body]: total %d%n\", body);\n@@ -407,0 +595,1 @@\n+                    int resp = 0;\n@@ -409,0 +598,3 @@\n+                        resp += n;\n+                        if (log) System.out.printf(\"Proxy Forwarding [response]: %s%n\", new String(bb, 0, n, UTF_8));\n+                        if (log) System.out.printf(\"Proxy Forwarding [response]: total %d%n\", resp);\n@@ -433,1 +625,1 @@\n-            proxyCommon();\n+            proxyCommon(false);\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":228,"deletions":36,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,1 +405,1 @@\n-            return error();\n+            return isConnected() ? 0 : -1;\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}