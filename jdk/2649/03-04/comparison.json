{"files":[{"patch":"@@ -313,22 +313,0 @@\n-        private long drain(SocketChannel socket) throws IOException {\n-            boolean isBlocking = socket.isBlocking();\n-            if (isBlocking) {\n-                socket.configureBlocking(false);\n-            }\n-            try {\n-                ByteBuffer buffer = ByteBuffer.allocate(1024);\n-                int read;\n-                long drained = 0;\n-                while ((read = socket.read(buffer)) > 0) {\n-                    drained += read;\n-                    buffer.position(0);\n-                    buffer.limit(buffer.capacity());\n-                }\n-                return drained;\n-            } finally {\n-                if (isBlocking) {\n-                    socket.configureBlocking(true);\n-                }\n-            }\n-        }\n-\n@@ -352,6 +330,1 @@\n-                    host = headers.stream()\n-                            .filter((s) -> s.toLowerCase().startsWith(\"host: \"))\n-                            .findFirst()\n-                            .map((s) -> s.substring(\"host: \".length()))\n-                            .map(String::trim)\n-                            .orElse(null);\n+                    host = findFirst(headers, \"host\");\n@@ -365,1 +338,1 @@\n-                            clientSocket.setOption(StandardSocketOptions.SO_LINGER, 5);\n+                            clientSocket.setOption(StandardSocketOptions.SO_LINGER, 2);\n@@ -371,6 +344,2 @@\n-                                System.out.printf(\"Proxy: unauthorized, 407 sent back (%s\/%s bytes); linger: %s, nodelay: %s%n\",\n-                                                  buffer.position(), buffer.limit(), linger, nodelay);\n-                            }\n-                            long drained = drain(clientSocket);\n-                            if (debug) {\n-                                System.out.printf(\"Proxy: drained: %s%n\", drained);\n+                                System.out.printf(\"Proxy: unauthorized; 407 sent (%s\/%s), linger: %s, nodelay: %s%n\",\n+                                        buffer.position(), buffer.position() + buffer.remaining(), linger, nodelay);\n@@ -378,10 +347,3 @@\n-                            clientSocket.shutdownOutput();\n-                            try {\n-                                \/\/ On windows, we additionally need to delay before\n-                                \/\/ closing the socket. Otherwise we get a reset on the\n-                                \/\/ client side (The connection was aborted by a software\n-                                \/\/ on the host machine).\n-                                \/\/ Delay 500ms before actually closing the socket\n-                                if (isWindows()) Thread.sleep(500);\n-                            } catch (InterruptedException x) {\n-                                \/\/ OK\n+                            if (shouldCloseAfter407(headers)) {\n+                                closeConnection();\n+                                return;\n@@ -389,3 +351,1 @@\n-                            clientSocket.shutdownInput();\n-                            close();\n-                            return;\n+                            continue;\n@@ -427,0 +387,112 @@\n+        String findFirst(List<String> headers, String key) {\n+            var h = key.toLowerCase(Locale.ROOT) + \": \";\n+            return headers.stream()\n+                    .filter((s) -> s.toLowerCase(Locale.ROOT).startsWith(h))\n+                    .findFirst()\n+                    .map((s) -> s.substring(h.length()))\n+                    .map(String::trim)\n+                    .orElse(null);\n+        }\n+\n+        private long drain(SocketChannel socket) throws IOException {\n+            boolean isBlocking = socket.isBlocking();\n+            if (isBlocking) {\n+                socket.configureBlocking(false);\n+            }\n+            try {\n+                ByteBuffer buffer = ByteBuffer.allocate(1024);\n+                int read;\n+                long drained = 0;\n+                while ((read = socket.read(buffer)) > 0) {\n+                    drained += read;\n+                    buffer.position(0);\n+                    buffer.limit(buffer.capacity());\n+                }\n+                return drained;\n+            } finally {\n+                if (isBlocking) {\n+                    socket.configureBlocking(true);\n+                }\n+            }\n+        }\n+\n+        void closeConnection() throws IOException {\n+            if (debug) {\n+                var linger = clientSocket.getOption(StandardSocketOptions.SO_LINGER);\n+                var nodelay = clientSocket.getOption(StandardSocketOptions.TCP_NODELAY);\n+                System.out.printf(\"Proxy: closing connection id=%s, linger: %s, nodelay: %s%n\",\n+                        id, linger, nodelay);\n+            }\n+            long drained = drain(clientSocket);\n+            if (debug) {\n+                System.out.printf(\"Proxy: drained: %s%n\", drained);\n+            }\n+            clientSocket.shutdownOutput();\n+            try {\n+                \/\/ On windows, we additionally need to delay before\n+                \/\/ closing the socket. Otherwise we get a reset on the\n+                \/\/ client side (The connection was aborted by a software\n+                \/\/ on the host machine).\n+                \/\/ Delay 500ms before actually closing the socket\n+                if (isWindows()) Thread.sleep(500);\n+            } catch (InterruptedException x) {\n+                \/\/ OK\n+            }\n+            clientSocket.shutdownInput();\n+            close();\n+        }\n+\n+        \/\/ If the client sends a request body we will need to close the connection\n+        \/\/ otherwise, we can keep it open.\n+        private boolean shouldCloseAfter407(List<String> headers) throws IOException {\n+            var te = findFirst(headers, \"transfer-encoding\");\n+            if (te != null) {\n+                \/\/ processing transfer encoding not implemented\n+                if (debug) {\n+                    System.out.println(\"Proxy: transfer-encoding with 407, closing connection\");\n+                }\n+                return true; \/\/ should close\n+            }\n+            var cl = findFirst(headers, \"content-length\");\n+            int n = -1;\n+            try {\n+                n = Integer.parseInt(cl);\n+                if (debug) {\n+                    System.out.printf(\"Proxy: content-length: %d%n\", cl);\n+                }\n+            } catch (IllegalFormatException x) {\n+                if (debug) {\n+                    System.out.println(\"Proxy: bad content-length, closing connection\");\n+                }\n+                return true;  \/\/ should close\n+            }\n+            if (n > 0 || n < -1) {\n+                if (debug) {\n+                    System.out.println(\"Proxy: request body with 407, closing connection\");\n+                }\n+                return true;  \/\/ should close\n+            }\n+            var cmdline = headers.get(0);\n+            int m = cmdline.indexOf(' ');\n+            var method = (m > 0) ? cmdline.substring(0, m) : null;\n+            var nobody = List.of(\"GET\", \"HEAD\");\n+            if (n == 0 || nobody.contains(m)) {\n+                var available = clientIn.available();\n+                var drained = drain(clientSocket);\n+                if (drained > 0 || available > 0) {\n+                    if (debug) {\n+                        System.out.printf(\"Proxy: unexpected bytes (%d) with 407, closing connection%n\",\n+                                drained + available);\n+                    }\n+                    return true;  \/\/ should close\n+                }\n+                \/\/ can keep open: CL=0 or no CL and GET or HEAD\n+                return false;\n+            } else {\n+                if (debug) {\n+                    System.out.println(\"Proxy: possible body with 407, closing connection\");\n+                }\n+                return true; \/\/ should close\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":120,"deletions":48,"binary":false,"changes":168,"status":"modified"}]}