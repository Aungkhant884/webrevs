[{"commit":{"message":"8307572: AArch64: Vector registers are clobbered by some macroassemblers\n\nI found that MacroAssembler::arrays_equals() would call stubcode, which\nmay use vector registers. However, the call site in match rule does not\nclaim the use of vector registers. Since c2 will allocate v16-v31\nfirst [1], it's rare that using of v0-v7 will cause problem, but I did\ncreate a test case to expose the bug.\n\nApart from arrays_equals, I also checked other macroassemblers, and\nfound several similar issues. Fixed by claiming those vector register\nbeing killed in match rules call sites, which should have minimal\nperformance impact compared to always saving\/restoring those vector\nregisters, since those V0-Vx registers are rarely allocated and live\ncross the macroassembler call.\n\nA jtreg test case is also added to demonstrate the failure. Test will\nfail without this patch, and pass with this patch.\n\nTest: I tried to update the allocation order in [1] to allocate V0-V15\nfirst and then V16-V31, and full jtreg tests passed with the allocation\norder changed. I have also eyeballed and checked other macroassembler\ncalls, and other macroassembler calls seemed fine.\n\n[1] https:\/\/github.com\/openjdk\/jdk\/blob\/master\/src\/hotspot\/cpu\/aarch64\/aarch64.ad#L424\n\nChange-Id: I0feb0c3f3761732a642b3080eb383e0d6ce77825"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestIntrinsicsRegStress.java"}],"sha":"e8a6b07be115ab970ad22b02e2075bfbc4acc60c"}]