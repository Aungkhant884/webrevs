{"files":[{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/logStream.hpp\"\n+\n+template<typename BackingLog>\n+LogStreamImpl<BackingLog>::~LogStreamImpl() {\n+  if (!_current_line.is_empty()) {\n+    _backing_log.print(\"%s\", _current_line.buffer());\n+    _current_line.reset();\n+  }\n+}\n+\n+template<typename BackingLog>\n+void LogStreamImpl<BackingLog>::write(const char* s, size_t len) {\n+  if (len > 0 && s[len - 1] == '\\n') {\n+    _current_line.append(s, len - 1); \/\/ omit the newline.\n+    _backing_log.print(\"%s\", _current_line.buffer());\n+    _current_line.reset();\n+  } else {\n+    _current_line.append(s, len);\n+  }\n+  update_position(s, len);\n+}\n+\n+LogStreamImplBase::LineBuffer::LineBuffer()\n+  : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0) {\n+  _buf[0] = '\\0';\n+}\n+\n+LogStreamImplBase::LineBuffer::~LineBuffer() {\n+  assert(_pos == 0, \"still outstanding bytes in the line buffer\");\n+  if (_buf != _smallbuf) {\n+    os::free(_buf);\n+  }\n+}\n+\n+\/\/ try_ensure_cap tries to enlarge the capacity of the internal buffer\n+\/\/ to the given atleast value. May fail if either OOM happens or atleast\n+\/\/ is larger than a reasonable max of 1 M.\n+\/\/ Returns whether the capacity is at least atleast bytes.\n+bool LogStreamImplBase::LineBuffer::try_ensure_cap(size_t atleast) {\n+  \/\/ Cap out at a reasonable max to prevent runaway leaks.\n+  const size_t reasonable_max = 1 * M;\n+\n+  assert(_cap >= sizeof(_smallbuf), \"sanity\");\n+  assert(_cap <= reasonable_max, \"sanity\");\n+\n+  if (_cap >= atleast) {\n+    return true;\n+  }\n+  if (_cap == reasonable_max) {\n+    return false;\n+  }\n+\n+  const size_t additional_expansion = 256;\n+  size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n+\n+  if (newcap > reasonable_max) {\n+    log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n+                      _buf, (_pos >= 100 ? \"...\" : \"\"));\n+    newcap = reasonable_max;\n+  }\n+\n+  char* const newbuf = (char*)os::malloc(newcap, mtLogging);\n+  if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n+    return false;\n+  }\n+  if (_pos > 0) { \/\/ preserve old content\n+    memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n+  }\n+  if (_buf != _smallbuf) {\n+    os::free(_buf);\n+  }\n+  _buf = newbuf;\n+  _cap = newcap;\n+\n+  return _cap >= atleast;\n+}\n+\n+void LogStreamImplBase::LineBuffer::append(const char* s, size_t len) {\n+  assert(_buf[_pos] == '\\0', \"sanity\");\n+  assert(_pos < _cap, \"sanity\");\n+  const size_t minimum_capacity_needed = _pos + len + 1;\n+  bool has_capacity = try_ensure_cap(minimum_capacity_needed);\n+  \/\/ try_ensure_cap may not have enlarged the capacity to the full requested\n+  \/\/ extent or may have not worked at all. In that case, just gracefully work\n+  \/\/ with what we have already; just truncate if necessary.\n+  if (!has_capacity) {\n+    len = _cap - _pos - 1;\n+    if (len == 0) {\n+      return;\n+    }\n+  }\n+  memcpy(_buf + _pos, s, len);\n+  _pos += len;\n+  _buf[_pos] = '\\0';\n+}\n+\n+void LogStreamImplBase::LineBuffer::reset() {\n+  _pos = 0;\n+  _buf[_pos] = '\\0';\n+}\n+\n+template class LogStreamImpl<LogTargetHandle>;\n+template class LogStreamImpl<LogMessageHandle>;\n","filename":"src\/hotspot\/share\/logging\/logStream.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -35,2 +35,1 @@\n-template<typename BackingLog>\n-class LogStreamImpl : public outputStream {\n+class LogStreamImplBase : public outputStream {\n@@ -68,1 +67,1 @@\n-private:\n+protected:\n@@ -70,0 +69,1 @@\n+};\n@@ -71,1 +71,3 @@\n-protected:\n+template<typename BackingLog>\n+class LogStreamImpl : public LogStreamImplBase {\n+private:\n@@ -78,6 +80,1 @@\n-  virtual ~LogStreamImpl() {\n-    if (!_current_line.is_empty()) {\n-      _backing_log.print(\"%s\", _current_line.buffer());\n-      _current_line.reset();\n-    }\n-  }\n+  ~LogStreamImpl() override;\n@@ -89,10 +86,1 @@\n-  void write(const char* s, size_t len) override {\n-    if (len > 0 && s[len - 1] == '\\n') {\n-      _current_line.append(s, len - 1); \/\/ omit the newline.\n-      _backing_log.print(\"%s\", _current_line.buffer());\n-      _current_line.reset();\n-    } else {\n-      _current_line.append(s, len);\n-    }\n-    update_position(s, len);\n-  }\n+  void write(const char* s, size_t len) override;\n@@ -101,84 +89,0 @@\n-template<typename T>\n-LogStreamImpl<T>::LineBuffer::LineBuffer()\n-  : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0) {\n-  _buf[0] = '\\0';\n-}\n-\n-template<typename T>\n-LogStreamImpl<T>::LineBuffer::~LineBuffer() {\n-  assert(_pos == 0, \"still outstanding bytes in the line buffer\");\n-  if (_buf != _smallbuf) {\n-    os::free(_buf);\n-  }\n-}\n-\n-\/\/ try_ensure_cap tries to enlarge the capacity of the internal buffer\n-\/\/ to the given atleast value. May fail if either OOM happens or atleast\n-\/\/ is larger than a reasonable max of 1 M.\n-\/\/ Returns whether the capacity is at least atleast bytes.\n-template<typename T>\n-bool LogStreamImpl<T>::LineBuffer::try_ensure_cap(size_t atleast) {\n-  \/\/ Cap out at a reasonable max to prevent runaway leaks.\n-  const size_t reasonable_max = 1 * M;\n-\n-  assert(_cap >= sizeof(_smallbuf), \"sanity\");\n-  assert(_cap <= reasonable_max, \"sanity\");\n-\n-  if (_cap >= atleast) {\n-    return true;\n-  }\n-  if (_cap == reasonable_max) {\n-    return false;\n-  }\n-\n-  const size_t additional_expansion = 256;\n-  size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n-\n-  if (newcap > reasonable_max) {\n-    log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n-                      _buf, (_pos >= 100 ? \"...\" : \"\"));\n-    newcap = reasonable_max;\n-  }\n-\n-  char* const newbuf = (char*)os::malloc(newcap, mtLogging);\n-  if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n-    return false;\n-  }\n-  if (_pos > 0) { \/\/ preserve old content\n-    memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n-  }\n-  if (_buf != _smallbuf) {\n-    os::free(_buf);\n-  }\n-  _buf = newbuf;\n-  _cap = newcap;\n-\n-  return _cap >= atleast;\n-}\n-\n-template<typename T>\n-void LogStreamImpl<T>::LineBuffer::append(const char* s, size_t len) {\n-  assert(_buf[_pos] == '\\0', \"sanity\");\n-  assert(_pos < _cap, \"sanity\");\n-  const size_t minimum_capacity_needed = _pos + len + 1;\n-  bool has_capacity = try_ensure_cap(minimum_capacity_needed);\n-  \/\/ try_ensure_cap may not have enlarged the capacity to the full requested\n-  \/\/ extent or may have not worked at all. In that case, just gracefully work\n-  \/\/ with what we have already; just truncate if necessary.\n-  if (!has_capacity) {\n-    len = _cap - _pos - 1;\n-    if (len == 0) {\n-      return;\n-    }\n-  }\n-  memcpy(_buf + _pos, s, len);\n-  _pos += len;\n-  _buf[_pos] = '\\0';\n-}\n-\n-template<typename T>\n-void LogStreamImpl<T>::LineBuffer::reset() {\n-  _pos = 0;\n-  _buf[_pos] = '\\0';\n-}\n-\n@@ -190,3 +94,0 @@\n-  \/\/ No heap allocation of LogStream.\n-  static void* operator new   (size_t) = delete;\n-  static void* operator new[] (size_t) = delete;\n@@ -196,1 +97,0 @@\n-  virtual ~LogStream() {};\n@@ -237,1 +137,0 @@\n-\n@@ -250,0 +149,1 @@\n+\n@@ -253,0 +153,1 @@\n+\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":10,"deletions":109,"binary":false,"changes":119,"status":"modified"}]}