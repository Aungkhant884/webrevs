{"files":[{"patch":"@@ -53,1 +53,1 @@\n-    void try_ensure_cap(size_t cap);\n+    bool try_ensure_cap(size_t cap);\n@@ -117,2 +117,2 @@\n-\/\/ is larger than a reasonable max of 1 M. Caller must not assume\n-\/\/ capacity without checking.\n+\/\/ is larger than a reasonable max of 1 M.\n+\/\/ Returns whether the capacity is at least atleast bytes.\n@@ -120,1 +120,4 @@\n-void LogStreamImpl<T>::LineBuffer::try_ensure_cap(size_t atleast) {\n+bool LogStreamImpl<T>::LineBuffer::try_ensure_cap(size_t atleast) {\n+  \/\/ Cap out at a reasonable max to prevent runaway leaks.\n+  const size_t reasonable_max = 1 * M;\n+\n@@ -122,7 +125,1 @@\n-  if (_cap < atleast) {\n-    \/\/ Cap out at a reasonable max to prevent runaway leaks.\n-    const size_t reasonable_max = 1 * M;\n-    assert(_cap <= reasonable_max, \"sanity\");\n-    if (_cap == reasonable_max) {\n-      return;\n-    }\n+  assert(_cap <= reasonable_max, \"sanity\");\n@@ -130,7 +127,6 @@\n-    const size_t additional_expansion = 256;\n-    size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n-    if (newcap > reasonable_max) {\n-      log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n-                        _buf, (_pos >= 100 ? \"...\" : \"\"));\n-      newcap = reasonable_max;\n-    }\n+  if (_cap >= atleast) {\n+    return true;\n+  }\n+  if (_cap == reasonable_max) {\n+    return false;\n+  }\n@@ -138,12 +134,15 @@\n-    char* const newbuf = (char*)os::malloc(newcap, mtLogging);\n-    if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n-      return;\n-    }\n-    if (_pos > 0) { \/\/ preserve old content\n-      memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n-    }\n-    if (_buf != _smallbuf) {\n-      os::free(_buf);\n-    }\n-    _buf = newbuf;\n-    _cap = newcap;\n+  const size_t additional_expansion = 256;\n+  size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n+\n+  if (newcap > reasonable_max) {\n+    log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n+                      _buf, (_pos >= 100 ? \"...\" : \"\"));\n+    newcap = reasonable_max;\n+  }\n+\n+  char* const newbuf = (char*)os::malloc(newcap, mtLogging);\n+  if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n+    return false;\n+  }\n+  if (_pos > 0) { \/\/ preserve old content\n+    memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n@@ -151,1 +150,7 @@\n-  assert(_cap >= atleast, \"sanity\");\n+  if (_buf != _smallbuf) {\n+    os::free(_buf);\n+  }\n+  _buf = newbuf;\n+  _cap = newcap;\n+\n+  return _cap >= atleast;\n@@ -159,1 +164,1 @@\n-  try_ensure_cap(minimum_capacity_needed);\n+  bool has_capacity = try_ensure_cap(minimum_capacity_needed);\n@@ -161,1 +166,1 @@\n-  \/\/ extend or may have not worked at all. In that case, just gracefully work\n+  \/\/ extent or may have not worked at all. In that case, just gracefully work\n@@ -163,1 +168,1 @@\n-  if (_cap < minimum_capacity_needed) {\n+  if (!has_capacity) {\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":39,"deletions":34,"binary":false,"changes":73,"status":"modified"}]}