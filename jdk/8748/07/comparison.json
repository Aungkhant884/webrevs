{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  LogTagSet* const _tagset;\n+  LogTagSet& _tagset;\n@@ -39,2 +39,2 @@\n-  LogHandle(const LogImpl<T0, T1, T2, T3, T4, GuardTag>& type_carrier) :\n-      _tagset(&LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+  LogHandle(const LogImpl<T0, T1, T2, T3, T4, GuardTag>& type_carrier)\n+    : _tagset(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n@@ -43,1 +43,1 @@\n-    return _tagset->is_level(level);\n+    return _tagset.is_level(level);\n@@ -46,1 +46,1 @@\n-  LogTagSet* const tagset() const {\n+  LogTagSet& tagset() const {\n@@ -52,1 +52,1 @@\n-    _tagset->vwrite(LogLevel::level, fmt, args); \\\n+    _tagset.vwrite(LogLevel::level, fmt, args); \\\n@@ -58,1 +58,1 @@\n-    _tagset->vwrite(LogLevel::level, fmt, args); \\\n+    _tagset.vwrite(LogLevel::level, fmt, args); \\\n@@ -63,1 +63,1 @@\n-    return _tagset->is_level(LogLevel::level); \\\n+    return _tagset.is_level(LogLevel::level); \\\n@@ -76,2 +76,1 @@\n-  LogTagSet* const   _tagset;\n-\n+  LogTagSet&   _tagset;\n@@ -79,1 +78,2 @@\n-  LogTargetHandle(LogLevelType level, LogTagSet* const tagset) : _level(level), _tagset(tagset) {}\n+  LogTargetHandle(LogLevelType level, LogTagSet& tagset)\n+    : _level(level), _tagset(tagset) {}\n@@ -82,3 +82,3 @@\n-  LogTargetHandle(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier) :\n-      _level(level),\n-      _tagset(&LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+  LogTargetHandle(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier)\n+    : _level(level),\n+      _tagset(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n@@ -95,1 +95,1 @@\n-      _tagset->vwrite(_level, fmt, args);\n+      _tagset.vwrite(_level, fmt, args);\n@@ -101,1 +101,1 @@\n-    return _tagset->is_level(_level);\n+    return _tagset.is_level(_level);\n","filename":"src\/hotspot\/share\/logging\/logHandle.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,2 @@\n-#define LogMessage(...) LogMessageImpl<LOG_TAGS(__VA_ARGS__)>\n-template <LogTagType T0, LogTagType T1 = LogTag::__NO_TAG, LogTagType T2 = LogTag::__NO_TAG,\n-          LogTagType T3 = LogTag::__NO_TAG, LogTagType T4 = LogTag::__NO_TAG, LogTagType GuardTag = LogTag::__NO_TAG>\n+#define LogMessage(...) LogMessageTemplate<LOG_TAGS(__VA_ARGS__)>\n+\n@@ -64,2 +63,1 @@\n- private:\n-  bool _has_content;\n+private:\n@@ -67,6 +65,6 @@\n- public:\n-  LogMessageImpl() :\n-    _has_content(false),\n-    _tagset(LogTagSetMapping<T0, T1, T2, T3, T4, GuardTag>::tagset())\n-  {}\n-\n+  bool _has_content;\n+protected:\n+  LogMessageImpl(LogTagSet& tagset)\n+    : _tagset(tagset),\n+      _has_content(false) {};\n+public:\n@@ -93,1 +91,1 @@\n-      set_prefix(LogPrefix<T0, T1, T2, T3, T4>::prefix);\n+      set_prefix(_tagset.write_prefix());\n@@ -98,0 +96,3 @@\n+  bool is_level(LogLevelType level) const {\n+    return _tagset.is_level(level);\n+  }\n@@ -106,0 +107,11 @@\n+template <LogTagType T0, LogTagType T1 = LogTag::__NO_TAG,\n+          LogTagType T2 = LogTag::__NO_TAG, LogTagType T3 = LogTag::__NO_TAG,\n+          LogTagType T4 = LogTag::__NO_TAG,\n+          LogTagType GuardTag = LogTag::__NO_TAG>\n+class LogMessageTemplate : public LogMessageImpl {\n+public:\n+  LogMessageTemplate (LogMessageTemplate&&) = default;\n+  LogMessageTemplate()\n+      : LogMessageImpl(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+};\n+\n","filename":"src\/hotspot\/share\/logging\/logMessage.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"logging\/log.hpp\"\n@@ -28,2 +27,0 @@\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/align.hpp\"\n@@ -31,3 +28,22 @@\n-LogStream::LineBuffer::LineBuffer()\n- : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0)\n-{\n+template<typename BackingLog>\n+LogStreamImpl<BackingLog>::~LogStreamImpl() {\n+  if (!_current_line.is_empty()) {\n+    _backing_log.print(\"%s\", _current_line.buffer());\n+    _current_line.reset();\n+  }\n+}\n+\n+template<typename BackingLog>\n+void LogStreamImpl<BackingLog>::write(const char* s, size_t len) {\n+  if (len > 0 && s[len - 1] == '\\n') {\n+    _current_line.append(s, len - 1); \/\/ omit the newline.\n+    _backing_log.print(\"%s\", _current_line.buffer());\n+    _current_line.reset();\n+  } else {\n+    _current_line.append(s, len);\n+  }\n+  update_position(s, len);\n+}\n+\n+LogStreamImplBase::LineBuffer::LineBuffer()\n+  : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0) {\n@@ -37,1 +53,1 @@\n-LogStream::LineBuffer::~LineBuffer() {\n+LogStreamImplBase::LineBuffer::~LineBuffer() {\n@@ -46,3 +62,6 @@\n-\/\/ is larger than a reasonable max of 1 M. Caller must not assume\n-\/\/ capacity without checking.\n-void LogStream::LineBuffer::try_ensure_cap(size_t atleast) {\n+\/\/ is larger than a reasonable max of 1 M.\n+\/\/ Returns whether the capacity is at least atleast bytes.\n+bool LogStreamImplBase::LineBuffer::try_ensure_cap(size_t atleast) {\n+  \/\/ Cap out at a reasonable max to prevent runaway leaks.\n+  const size_t reasonable_max = 1 * M;\n+\n@@ -50,7 +69,1 @@\n-  if (_cap < atleast) {\n-    \/\/ Cap out at a reasonable max to prevent runaway leaks.\n-    const size_t reasonable_max = 1 * M;\n-    assert(_cap <= reasonable_max, \"sanity\");\n-    if (_cap == reasonable_max) {\n-      return;\n-    }\n+  assert(_cap <= reasonable_max, \"sanity\");\n@@ -58,7 +71,6 @@\n-    const size_t additional_expansion = 256;\n-    size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n-    if (newcap > reasonable_max) {\n-      log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n-              _buf, (_pos >= 100 ? \"...\" : \"\"));\n-      newcap = reasonable_max;\n-    }\n+  if (_cap >= atleast) {\n+    return true;\n+  }\n+  if (_cap == reasonable_max) {\n+    return false;\n+  }\n@@ -66,12 +78,12 @@\n-    char* const newbuf = (char*) os::malloc(newcap, mtLogging);\n-    if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n-      return;\n-    }\n-    if (_pos > 0) { \/\/ preserve old content\n-      memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n-    }\n-    if (_buf != _smallbuf) {\n-      os::free(_buf);\n-    }\n-    _buf = newbuf;\n-    _cap = newcap;\n+  const size_t additional_expansion = 256;\n+  size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n+\n+  if (newcap > reasonable_max) {\n+    log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n+                      _buf, (_pos >= 100 ? \"...\" : \"\"));\n+    newcap = reasonable_max;\n+  }\n+\n+  char* const newbuf = (char*)os::malloc(newcap, mtLogging);\n+  if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n+    return false;\n@@ -79,1 +91,10 @@\n-  assert(_cap >= atleast, \"sanity\");\n+  if (_pos > 0) { \/\/ preserve old content\n+    memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n+  }\n+  if (_buf != _smallbuf) {\n+    os::free(_buf);\n+  }\n+  _buf = newbuf;\n+  _cap = newcap;\n+\n+  return _cap >= atleast;\n@@ -82,1 +103,1 @@\n-void LogStream::LineBuffer::append(const char* s, size_t len) {\n+void LogStreamImplBase::LineBuffer::append(const char* s, size_t len) {\n@@ -86,1 +107,1 @@\n-  try_ensure_cap(minimum_capacity_needed);\n+  bool has_capacity = try_ensure_cap(minimum_capacity_needed);\n@@ -88,1 +109,1 @@\n-  \/\/ extend or may have not worked at all. In that case, just gracefully work\n+  \/\/ extent or may have not worked at all. In that case, just gracefully work\n@@ -90,1 +111,1 @@\n-  if (_cap < minimum_capacity_needed) {\n+  if (!has_capacity) {\n@@ -101,1 +122,1 @@\n-void LogStream::LineBuffer::reset() {\n+void LogStreamImplBase::LineBuffer::reset() {\n@@ -106,20 +127,2 @@\n-void LogStream::write(const char* s, size_t len) {\n-  if (len > 0 && s[len - 1] == '\\n') {\n-    _current_line.append(s, len - 1); \/\/ omit the newline.\n-    _log_handle.print(\"%s\", _current_line.buffer());\n-    _current_line.reset();\n-  } else {\n-    _current_line.append(s, len);\n-  }\n-  update_position(s, len);\n-}\n-\n-\/\/ Destructor writes any unfinished output left in the line buffer.\n-LogStream::~LogStream() {\n-  if (_current_line.is_empty() == false) {\n-    _log_handle.print(\"%s\", _current_line.buffer());\n-    _current_line.reset();\n-  }\n-}\n-\n-\n+template class LogStreamImpl<LogTargetHandle>;\n+template class LogStreamImpl<LogMessageHandle>;\n","filename":"src\/hotspot\/share\/logging\/logStream.cpp","additions":66,"deletions":63,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+#include \"logging\/logMessage.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -32,3 +35,1 @@\n-\n-class LogStream : public outputStream {\n-  \/\/ see test\/hotspot\/gtest\/logging\/test_logStream.cpp\n+class LogStreamImplBase : public outputStream {\n@@ -38,0 +39,4 @@\n+  \/\/ No heap allocation of LogStream.\n+  static void* operator new   (size_t) = delete;\n+  static void* operator new[] (size_t) = delete;\n+\n@@ -47,1 +52,2 @@\n-    void try_ensure_cap(size_t cap);\n+    bool try_ensure_cap(size_t cap);\n+\n@@ -51,2 +57,6 @@\n-    bool is_empty() const { return _pos == 0; }\n-    const char* buffer() const { return _buf; }\n+    bool is_empty() const {\n+      return _pos == 0;\n+    }\n+    const char* buffer() const {\n+      return _buf;\n+    }\n@@ -56,2 +66,0 @@\n-  LineBuffer  _current_line;\n-  LogTargetHandle _log_handle;\n@@ -59,3 +67,28 @@\n-  \/\/ Prevent operator new for LogStream.\n-  static void* operator new (size_t);\n-  static void* operator new[] (size_t);\n+protected:\n+  LineBuffer _current_line;\n+};\n+\n+template<typename BackingLog>\n+class LogStreamImpl : public LogStreamImplBase {\n+private:\n+  BackingLog _backing_log;\n+\n+public:\n+  explicit LogStreamImpl(BackingLog bl)\n+    : _backing_log(bl) {};\n+\n+  ~LogStreamImpl() override;\n+\n+  bool is_enabled() {\n+    return _backing_log.is_enabled();\n+  }\n+\n+  void write(const char* s, size_t len) override;\n+};\n+\n+class LogStream : public LogStreamImpl<LogTargetHandle> {\n+  \/\/ see test\/hotspot\/gtest\/logging\/test_logStream.cpp\n+  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;\n+  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;\n+\n+  NONCOPYABLE(LogStream);\n@@ -68,3 +101,4 @@\n-  template <LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3, LogTagType T4, LogTagType GuardTag>\n-  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier) :\n-      _log_handle(level, &LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+  template<LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3,\n+           LogTagType T4, LogTagType GuardTag>\n+  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier)\n+    : LogStreamImpl(LogTargetHandle(level, LogTagSetMapping<T0, T1, T2, T3, T4>::tagset())) {}\n@@ -77,6 +111,4 @@\n-  template <LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3, LogTagType T4, LogTagType GuardTag>\n-  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>* type_carrier) :\n-      _log_handle(level, &LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n-\n-  \/\/ Destructor writes any unfinished output left in the line buffer.\n-  ~LogStream();\n+  template<LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3,\n+           LogTagType T4, LogTagType GuardTag>\n+  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>* type_carrier)\n+    : LogStreamImpl(LogTargetHandle(level, LogTagSetMapping<T0, T1, T2, T3, T4>::tagset())) {}\n@@ -89,1 +121,2 @@\n-  LogStream(LogTargetHandle handle) : _log_handle(handle) {}\n+  LogStream(LogTargetHandle handle)\n+    : LogStreamImpl(handle) {}\n@@ -94,7 +127,2 @@\n-  LogStream(LogLevelType level, LogTagSet* const tagset) : _log_handle(level, tagset) {}\n-\n-  bool is_enabled() const {\n-    return _log_handle.is_enabled();\n-  }\n-\n-  void write(const char* s, size_t len);\n+  LogStream(LogLevelType level, LogTagSet& tagset)\n+    : LogStreamImpl(LogTargetHandle(level, tagset)) {}\n@@ -106,1 +134,2 @@\n-template <LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3, LogTagType T4, LogTagType GuardTag>\n+template<LogLevelType level, LogTagType T0, LogTagType T1, LogTagType T2, LogTagType T3,\n+         LogTagType T4, LogTagType GuardTag>\n@@ -109,1 +138,35 @@\n-  LogStreamTemplate() : LogStream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)NULL) {}\n+  LogStreamTemplate()\n+    : LogStream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)NULL) {}\n+};\n+\n+class LogMessageHandle {\n+  const LogLevelType _level;\n+  LogMessageImpl& _lm;\n+\n+public:\n+  LogMessageHandle(const LogLevelType level, LogMessageImpl& lm)\n+    : _level(level), _lm(lm) {}\n+\n+  bool is_enabled() {\n+    return _lm.is_level(_level);\n+  }\n+\n+  void print(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3) {\n+    va_list args;\n+    va_start(args, fmt);\n+    if (is_enabled()) {\n+      _lm.vwrite(_level, fmt, args);\n+    }\n+    va_end(args);\n+  }\n+};\n+\n+class NonInterleavingLogStream : public LogStreamImpl<LogMessageHandle> {\n+  static void* operator new   (size_t) = delete;\n+  static void* operator new[] (size_t) = delete;\n+\n+public:\n+  NonInterleavingLogStream(LogLevelType level, LogMessageImpl& lm)\n+    : LogStreamImpl(LogMessageHandle(level, lm)) {}\n+\n+  virtual ~NonInterleavingLogStream() {};\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":94,"deletions":31,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,4 @@\n+  PrefixWriter write_prefix() {\n+    return _write_prefix;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"logging\/logMessage.hpp\"\n@@ -30,1 +31,1 @@\n-#include \"unittest.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -93,0 +94,43 @@\n+\/\/ LogStream allows interleaving of other messages.\n+\/\/ Compare this to NonInterLeavingLogStreamTest_NonInterleavingStream\n+TEST_VM_F(LogStreamTest, InterleavingStream) {\n+  set_log_config(TestLogFileName, \"gc=info\");\n+  const char* message_order[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", NULL};\n+  {\n+    LogStream foo(Log(gc)::info());\n+    if (foo.is_enabled()) {\n+      foo.print(\"I am\");\n+      log_info(gc)(\"1\");\n+      foo.print_cr(\" one line\");\n+      log_info(gc)(\"2\");\n+      foo.print_cr(\"but\");\n+      log_info(gc)(\"3\");\n+      foo.print_cr(\"I am not\");\n+    }\n+  }\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, message_order));\n+}\n+\n+\/\/ NonInterleavingLogStream does not allow interleaving of other messages.\n+\/\/ Compare this to LogStreamTest_InterleavingStream\n+TEST_VM_F(LogStreamTest, NonInterleavingStream) {\n+  set_log_config(TestLogFileName, \"gc=info\");\n+  const char* message_order[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", NULL};\n+  {\n+    LogMessage(gc) lm ;\n+    NonInterleavingLogStream foo{LogLevelType::Info, lm};\n+    if (foo.is_enabled()) {\n+      foo.print(\"I am\");\n+      log_info(gc)(\"1\");\n+      foo.print_cr(\" one line\");\n+      log_info(gc)(\"2\");\n+      foo.print_cr(\"but\");\n+      log_info(gc)(\"3\");\n+      foo.print_cr(\"I am not\");\n+    }\n+  }\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, message_order));\n+}\n+\n+\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"}]}