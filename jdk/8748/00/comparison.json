{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  LogTagSet* const _tagset;\n+  LogTagSet& _tagset;\n@@ -40,1 +40,1 @@\n-      _tagset(&LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+      _tagset(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n@@ -43,1 +43,1 @@\n-    return _tagset->is_level(level);\n+    return _tagset.is_level(level);\n@@ -46,1 +46,1 @@\n-  LogTagSet* const tagset() const {\n+  LogTagSet& tagset() const {\n@@ -52,1 +52,1 @@\n-    _tagset->vwrite(LogLevel::level, fmt, args); \\\n+    _tagset.vwrite(LogLevel::level, fmt, args); \\\n@@ -58,1 +58,1 @@\n-    _tagset->vwrite(LogLevel::level, fmt, args); \\\n+    _tagset.vwrite(LogLevel::level, fmt, args); \\\n@@ -63,1 +63,1 @@\n-    return _tagset->is_level(LogLevel::level); \\\n+    return _tagset.is_level(LogLevel::level); \\\n@@ -76,2 +76,1 @@\n-  LogTagSet* const   _tagset;\n-\n+  LogTagSet&   _tagset;\n@@ -79,1 +78,1 @@\n-  LogTargetHandle(LogLevelType level, LogTagSet* const tagset) : _level(level), _tagset(tagset) {}\n+  LogTargetHandle(LogLevelType level, LogTagSet& tagset) : _level(level), _tagset(tagset) {}\n@@ -84,1 +83,2 @@\n-      _tagset(&LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+      _tagset(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {\n+  }\n@@ -95,1 +95,1 @@\n-      _tagset->vwrite(_level, fmt, args);\n+      _tagset.vwrite(_level, fmt, args);\n@@ -101,1 +101,1 @@\n-    return _tagset->is_level(_level);\n+    return _tagset.is_level(_level);\n","filename":"src\/hotspot\/share\/logging\/logHandle.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,2 @@\n-#define LogMessage(...) LogMessageImpl<LOG_TAGS(__VA_ARGS__)>\n-template <LogTagType T0, LogTagType T1 = LogTag::__NO_TAG, LogTagType T2 = LogTag::__NO_TAG,\n-          LogTagType T3 = LogTag::__NO_TAG, LogTagType T4 = LogTag::__NO_TAG, LogTagType GuardTag = LogTag::__NO_TAG>\n+#define LogMessage(...) LogMessageTemplate<LOG_TAGS(__VA_ARGS__)>\n+\n@@ -65,1 +64,0 @@\n-  bool _has_content;\n@@ -67,0 +65,5 @@\n+  bool _has_content;\n+protected:\n+  LogMessageImpl(LogTagSet& tagset):\n+    _tagset(tagset),\n+    _has_content(false) {};\n@@ -68,5 +71,0 @@\n-  LogMessageImpl() :\n-    _has_content(false),\n-    _tagset(LogTagSetMapping<T0, T1, T2, T3, T4, GuardTag>::tagset())\n-  {}\n-\n@@ -93,1 +91,1 @@\n-      set_prefix(LogPrefix<T0, T1, T2, T3, T4>::prefix);\n+      set_prefix(_tagset.get_prefix_fn());\n@@ -98,0 +96,3 @@\n+  bool is_level(LogLevelType level) const {\n+    return _tagset.is_level(level);\n+  }\n@@ -106,0 +107,11 @@\n+template <LogTagType T0, LogTagType T1 = LogTag::__NO_TAG,\n+          LogTagType T2 = LogTag::__NO_TAG, LogTagType T3 = LogTag::__NO_TAG,\n+          LogTagType T4 = LogTag::__NO_TAG,\n+          LogTagType GuardTag = LogTag::__NO_TAG>\n+class LogMessageTemplate : public LogMessageImpl {\n+public:\n+  LogMessageTemplate (LogMessageTemplate&&) = default;\n+  LogMessageTemplate()\n+      : LogMessageImpl(LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+};\n+\n","filename":"src\/hotspot\/share\/logging\/logMessage.hpp","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/align.hpp\"\n-\n-LogStream::LineBuffer::LineBuffer()\n- : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0)\n-{\n-  _buf[0] = '\\0';\n-}\n-\n-LogStream::LineBuffer::~LineBuffer() {\n-  assert(_pos == 0, \"still outstanding bytes in the line buffer\");\n-  if (_buf != _smallbuf) {\n-    os::free(_buf);\n-  }\n-}\n-\n-\/\/ try_ensure_cap tries to enlarge the capacity of the internal buffer\n-\/\/ to the given atleast value. May fail if either OOM happens or atleast\n-\/\/ is larger than a reasonable max of 1 M. Caller must not assume\n-\/\/ capacity without checking.\n-void LogStream::LineBuffer::try_ensure_cap(size_t atleast) {\n-  assert(_cap >= sizeof(_smallbuf), \"sanity\");\n-  if (_cap < atleast) {\n-    \/\/ Cap out at a reasonable max to prevent runaway leaks.\n-    const size_t reasonable_max = 1 * M;\n-    assert(_cap <= reasonable_max, \"sanity\");\n-    if (_cap == reasonable_max) {\n-      return;\n-    }\n-\n-    const size_t additional_expansion = 256;\n-    size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n-    if (newcap > reasonable_max) {\n-      log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n-              _buf, (_pos >= 100 ? \"...\" : \"\"));\n-      newcap = reasonable_max;\n-    }\n-\n-    char* const newbuf = (char*) os::malloc(newcap, mtLogging);\n-    if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n-      return;\n-    }\n-    if (_pos > 0) { \/\/ preserve old content\n-      memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n-    }\n-    if (_buf != _smallbuf) {\n-      os::free(_buf);\n-    }\n-    _buf = newbuf;\n-    _cap = newcap;\n-  }\n-  assert(_cap >= atleast, \"sanity\");\n-}\n-\n-void LogStream::LineBuffer::append(const char* s, size_t len) {\n-  assert(_buf[_pos] == '\\0', \"sanity\");\n-  assert(_pos < _cap, \"sanity\");\n-  const size_t minimum_capacity_needed = _pos + len + 1;\n-  try_ensure_cap(minimum_capacity_needed);\n-  \/\/ try_ensure_cap may not have enlarged the capacity to the full requested\n-  \/\/ extend or may have not worked at all. In that case, just gracefully work\n-  \/\/ with what we have already; just truncate if necessary.\n-  if (_cap < minimum_capacity_needed) {\n-    len = _cap - _pos - 1;\n-    if (len == 0) {\n-      return;\n-    }\n-  }\n-  memcpy(_buf + _pos, s, len);\n-  _pos += len;\n-  _buf[_pos] = '\\0';\n-}\n-\n-void LogStream::LineBuffer::reset() {\n-  _pos = 0;\n-  _buf[_pos] = '\\0';\n-}\n-\n-void LogStream::write(const char* s, size_t len) {\n-  if (len > 0 && s[len - 1] == '\\n') {\n-    _current_line.append(s, len - 1); \/\/ omit the newline.\n-    _log_handle.print(\"%s\", _current_line.buffer());\n-    _current_line.reset();\n-  } else {\n-    _current_line.append(s, len);\n-  }\n-  update_position(s, len);\n-}\n-\n-\/\/ Destructor writes any unfinished output left in the line buffer.\n-LogStream::~LogStream() {\n-  if (_current_line.is_empty() == false) {\n-    _log_handle.print(\"%s\", _current_line.buffer());\n-    _current_line.reset();\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/logging\/logStream.cpp","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"logging\/logMessage.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -32,3 +35,2 @@\n-\n-class LogStream : public outputStream {\n-  \/\/ see test\/hotspot\/gtest\/logging\/test_logStream.cpp\n+template<typename BackingLog>\n+class LogStreamImpl : public outputStream {\n@@ -38,0 +40,4 @@\n+  \/\/ No heap allocation of LogStream.\n+  static void *operator new     (size_t) = delete;\n+  static void *operator new[]   (size_t) = delete;\n+\n@@ -56,0 +62,2 @@\n+\n+private:\n@@ -57,1 +65,102 @@\n-  LogTargetHandle _log_handle;\n+protected:\n+  BackingLog _backing_log;\n+public:\n+  explicit LogStreamImpl(BackingLog bl): _backing_log(bl) {};\n+\n+  virtual ~LogStreamImpl() {\n+    if (_current_line.is_empty() == false) {\n+      _backing_log.print(\"%s\", _current_line.buffer());\n+      _current_line.reset();\n+    }\n+  }\n+\n+  bool is_enabled() {\n+    return _backing_log.is_enabled();\n+  }\n+\n+  void write(const char* s, size_t len) override {\n+    if (len > 0 && s[len - 1] == '\\n') {\n+      _current_line.append(s, len - 1); \/\/ omit the newline.\n+      _backing_log.print(\"%s\", _current_line.buffer());\n+      _current_line.reset();\n+    } else {\n+      _current_line.append(s, len);\n+    }\n+    update_position(s, len);\n+  }\n+};\n+\n+template<typename T>\n+LogStreamImpl<T>::LineBuffer::LineBuffer()\n+ : _buf(_smallbuf), _cap(sizeof(_smallbuf)), _pos(0)\n+{\n+  _buf[0] = '\\0';\n+}\n+\n+template<typename T>\n+LogStreamImpl<T>::LineBuffer::~LineBuffer() {\n+  assert(_pos == 0, \"still outstanding bytes in the line buffer\");\n+  if (_buf != _smallbuf) {\n+    os::free(_buf);\n+  }\n+}\n+\n+\/\/ try_ensure_cap tries to enlarge the capacity of the internal buffer\n+\/\/ to the given atleast value. May fail if either OOM happens or atleast\n+\/\/ is larger than a reasonable max of 1 M. Caller must not assume\n+\/\/ capacity without checking.\n+template<typename T>\n+void LogStreamImpl<T>::LineBuffer::try_ensure_cap(size_t atleast) {\n+  assert(_cap >= sizeof(_smallbuf), \"sanity\");\n+  if (_cap < atleast) {\n+    \/\/ Cap out at a reasonable max to prevent runaway leaks.\n+    const size_t reasonable_max = 1 * M;\n+    assert(_cap <= reasonable_max, \"sanity\");\n+    if (_cap == reasonable_max) {\n+      return;\n+    }\n+\n+    const size_t additional_expansion = 256;\n+    size_t newcap = align_up(atleast + additional_expansion, additional_expansion);\n+    if (newcap > reasonable_max) {\n+      log_info(logging)(\"Suspiciously long log line: \\\"%.100s%s\",\n+              _buf, (_pos >= 100 ? \"...\" : \"\"));\n+      newcap = reasonable_max;\n+    }\n+\n+    char* const newbuf = (char*) os::malloc(newcap, mtLogging);\n+    if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n+      return;\n+    }\n+    if (_pos > 0) { \/\/ preserve old content\n+      memcpy(newbuf, _buf, _pos + 1); \/\/ ..including trailing zero\n+    }\n+    if (_buf != _smallbuf) {\n+      os::free(_buf);\n+    }\n+    _buf = newbuf;\n+    _cap = newcap;\n+  }\n+  assert(_cap >= atleast, \"sanity\");\n+}\n+\n+\n+template<typename T>\n+void LogStreamImpl<T>::LineBuffer::append(const char* s, size_t len) {\n+  assert(_buf[_pos] == '\\0', \"sanity\");\n+  assert(_pos < _cap, \"sanity\");\n+  const size_t minimum_capacity_needed = _pos + len + 1;\n+  try_ensure_cap(minimum_capacity_needed);\n+  \/\/ try_ensure_cap may not have enlarged the capacity to the full requested\n+  \/\/ extend or may have not worked at all. In that case, just gracefully work\n+  \/\/ with what we have already; just truncate if necessary.\n+  if (_cap < minimum_capacity_needed) {\n+    len = _cap - _pos - 1;\n+    if (len == 0) {\n+      return;\n+    }\n+  }\n+  memcpy(_buf + _pos, s, len);\n+  _pos += len;\n+  _buf[_pos] = '\\0';\n+}\n@@ -59,3 +168,5 @@\n-  \/\/ Prevent operator new for LogStream.\n-  static void* operator new (size_t);\n-  static void* operator new[] (size_t);\n+template<typename T>\n+void LogStreamImpl<T>::LineBuffer::reset() {\n+  _pos = 0;\n+  _buf[_pos] = '\\0';\n+}\n@@ -63,0 +174,9 @@\n+\n+class LogStream : public LogStreamImpl<LogTargetHandle>  {\n+  \/\/ see test\/hotspot\/gtest\/logging\/test_logStream.cpp\n+  friend class LogStreamTest_TestLineBufferAllocation_vm_Test;\n+  friend class LogStreamTest_TestLineBufferAllocationCap_vm_Test;\n+\n+  \/\/ No heap allocation of LogStream.\n+  static void *operator new     (size_t) = delete;\n+  static void *operator new[]   (size_t) = delete;\n@@ -64,0 +184,2 @@\n+  LogStream(const LogStream&) = delete;\n+  virtual ~LogStream() {};\n@@ -69,2 +191,2 @@\n-  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier) :\n-      _log_handle(level, &LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n+  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>& type_carrier):\n+    LogStreamImpl(LogTargetHandle(level, LogTagSetMapping<T0, T1, T2, T3, T4>::tagset())) {}\n@@ -78,5 +200,2 @@\n-  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>* type_carrier) :\n-      _log_handle(level, &LogTagSetMapping<T0, T1, T2, T3, T4>::tagset()) {}\n-\n-  \/\/ Destructor writes any unfinished output left in the line buffer.\n-  ~LogStream();\n+  LogStream(const LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>* type_carrier):\n+    LogStreamImpl(LogTargetHandle(level, LogTagSetMapping<T0, T1, T2, T3, T4>::tagset())){}\n@@ -89,1 +208,1 @@\n-  LogStream(LogTargetHandle handle) : _log_handle(handle) {}\n+  LogStream(LogTargetHandle handle) : LogStreamImpl(handle) {}\n@@ -94,7 +213,3 @@\n-  LogStream(LogLevelType level, LogTagSet* const tagset) : _log_handle(level, tagset) {}\n-\n-  bool is_enabled() const {\n-    return _log_handle.is_enabled();\n-  }\n-\n-  void write(const char* s, size_t len);\n+  LogStream(LogLevelType level, LogTagSet& tagset):\n+    LogStreamImpl(LogTargetHandle(level, tagset))\n+  {}\n@@ -103,0 +218,1 @@\n+\n@@ -112,0 +228,31 @@\n+class LogMessageHandle {\n+  const LogLevelType _level;\n+  LogMessageImpl& _lm;\n+public:\n+  LogMessageHandle(const LogLevelType level, LogMessageImpl& lm):\n+    _level(level), _lm(lm) {}\n+  bool is_enabled() {\n+    return _lm.is_level(_level);\n+  }\n+  void print(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3) {\n+    va_list args;\n+    va_start(args, fmt);\n+    if (is_enabled()) {\n+      _lm.vwrite(_level, fmt, args);\n+    }\n+    va_end(args);\n+  }\n+};\n+\n+\n+class NonInterleavingLogStream : public LogStreamImpl<LogMessageHandle> {\n+  static void *operator new     (size_t) = delete;\n+  static void *operator new[]   (size_t) = delete;\n+public:\n+  NonInterleavingLogStream(LogLevelType level, LogMessageImpl& lm) :\n+    LogStreamImpl(LogMessageHandle(level, lm)){}\n+\n+  virtual ~NonInterleavingLogStream() {};\n+};\n+\n+\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":170,"deletions":23,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,4 @@\n+  PrefixWriter get_prefix_fn() {\n+    return this->_write_prefix;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"logging\/logMessage.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"unittest.hpp\"\n@@ -93,0 +94,43 @@\n+\/\/ LogStream allows interleaving of other messages.\n+\/\/ Compare this to NonInterLeavingLogStreamTest_NonInterleavingStream\n+TEST_VM_F(LogStreamTest, InterleavingStream) {\n+  set_log_config(TestLogFileName, \"gc=info\");\n+  const char* strs[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", NULL};\n+  {\n+    LogStream foo(Log(gc)::info());\n+    if(foo.is_enabled()) {\n+      foo.print(\"I am\");\n+      log_info(gc)(\"1\");\n+      foo.print_cr(\" one line\");\n+      log_info(gc)(\"2\");\n+      foo.print_cr(\"but\");\n+      log_info(gc)(\"3\");\n+      foo.print_cr(\"I am not\");\n+    }\n+  }\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+}\n+\n+\/\/ NonInterleavingLogStream does not allow interleaving of other messages.\n+\/\/ Compare this to LogStreamTest_InterleavingStream\n+TEST_VM_F(LogStreamTest, NonInterleavingStream) {\n+  set_log_config(TestLogFileName, \"gc=info\");\n+  const char* strs[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", NULL};\n+  {\n+    LogMessage(gc) lm ;\n+    NonInterleavingLogStream foo{LogLevelType::Info, lm};\n+    if(foo.is_enabled()) {\n+      foo.print(\"I am\");\n+      log_info(gc)(\"1\");\n+      foo.print_cr(\" one line\");\n+      log_info(gc)(\"2\");\n+      foo.print_cr(\"but\");\n+      log_info(gc)(\"3\");\n+      foo.print_cr(\"I am not\");\n+    }\n+  }\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+}\n+\n+\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"}]}