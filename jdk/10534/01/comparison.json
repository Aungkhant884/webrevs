{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,4 +507,17 @@\n-                                        \"this handler\");\n-        } else if (host != null && u.isBuiltinStreamHandler(this)) {\n-            String s = IPAddressUtil.checkHostString(host);\n-            if (s != null) throw new IllegalArgumentException(s);\n+                    \"this handler\");\n+        }\n+        \/\/ if early parsing, perform additional checks here rather than waiting\n+        \/\/ for openConnection()\n+        boolean earlyURLParsing = IPAddressUtil.earlyURLParsing();\n+        boolean isBuiltInHandler = u.isBuiltinStreamHandler(this);\n+        if (host != null && isBuiltInHandler) {\n+            String errMsg = IPAddressUtil.checkHostString(host);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n+        }\n+        if (userInfo != null && isBuiltInHandler && earlyURLParsing) {\n+            String errMsg = IPAddressUtil.checkUserInfo(userInfo);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n+        }\n+        if (authority != null && isBuiltInHandler && earlyURLParsing) {\n+            String errMsg = IPAddressUtil.checkAuth(authority);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLStreamHandler.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -430,0 +430,10 @@\n+    \/\/ excluded delims: \"<>\\\" \" - we don't include % and # here\n+    private static final long L_EXCLUDED_DELIMS = 0x5000000500000000L;\n+    private static final long H_EXCLUDED_DELIMS = 0x0L;\n+    \/\/ unwise \"{}|\\\\^[]`\";\n+    private static final long L_UNWISE = 0x0L;\n+    private static final long H_UNWISE = 0x3800000178000000L;\n+    private static final long L_FRAGMENT = 0x0000000800000000L;\n+    private static final long H_FRAGMENT = 0x0L;\n+    private static final long L_QUERY = 0x8000000000000000L;\n+    private static final long H_QUERY = 0x0L;\n@@ -482,1 +492,5 @@\n-    private static String checkUserInfo(String str) {\n+    \/\/ Check user-info component.\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n+    public static String checkUserInfo(String str) {\n@@ -484,2 +498,2 @@\n-        int index = scan(str, L_EXCLUDE & ~L_COLON,\n-                H_EXCLUDE & ~H_COLON);\n+        int index = scan(str, MASKS.L_USERINFO_MASK,\n+                MASKS.H_USERINFO_MASK);\n@@ -501,2 +515,1 @@\n-                            L_NON_PRINTABLE | L_IPV6_DELIMS,\n-                            H_NON_PRINTABLE | H_IPV6_DELIMS);\n+                            MASKS.L_SCOPE_MASK, MASKS.H_SCOPE_MASK);\n@@ -512,1 +525,2 @@\n-            index = scan(str, L_EXCLUDE, H_EXCLUDE);\n+            index = scan(str, L_EXCLUDE | MASKS.L_HOSTNAME_MASK,\n+                    H_EXCLUDE | MASKS.H_HOSTNAME_MASK, OTHERS);\n@@ -521,1 +535,8 @@\n-    private static String checkAuth(String str) {\n+    \/\/ Simple checks for the authority component.\n+    \/\/ Deeper checks on the various parts of a server-based\n+    \/\/ authority component may be performed by calling\n+    \/\/ #checkAuthority(URL url)\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n+    public static String checkAuth(String str) {\n@@ -532,2 +553,5 @@\n-    \/\/ check authority of hierarchical URL. Appropriate for\n-    \/\/ HTTP-like protocol handlers\n+    \/\/ check authority of hierarchical (server based) URL.\n+    \/\/ Appropriate for HTTP-like protocol handlers\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -549,2 +573,6 @@\n-    \/\/ minimal syntax checks - deeper check may be performed\n-    \/\/ by the appropriate protocol handler\n+    \/\/ minimal syntax checks if delayed parsing is\n+    \/\/ enabled - deeper check will be performed\n+    \/\/ later by the appropriate protocol handler\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -554,6 +582,12 @@\n-        int index = scan(s = url.getUserInfo(),\n-                L_NON_PRINTABLE | L_SLASH,\n-                H_NON_PRINTABLE | H_SLASH);\n-        if (index >= 0) {\n-            return \"Illegal character found in authority: \"\n-                    + describeChar(s.charAt(index));\n+        boolean earlyURLParsing = earlyURLParsing();\n+        String userInfo = url.getUserInfo();\n+        if (earlyURLParsing) {\n+            if ((s = checkUserInfo(userInfo)) != null) return s;\n+        } else {\n+            int index = scan(s = userInfo,\n+                    L_NON_PRINTABLE | L_SLASH,\n+                    H_NON_PRINTABLE | H_SLASH);\n+            if (index >= 0) {\n+                return \"Illegal character found in authority: \"\n+                        + describeChar(s.charAt(index));\n+            }\n@@ -561,1 +595,2 @@\n-        if ((s = checkHostString(url.getHost())) != null) {\n+        String host = url.getHost();\n+        if ((s = checkHostString(host)) != null) {\n@@ -567,0 +602,4 @@\n+    \/\/ Check host component.\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -569,7 +608,12 @@\n-        int index = scan(host,\n-                L_NON_PRINTABLE | L_SLASH,\n-                H_NON_PRINTABLE | H_SLASH,\n-                OTHERS);\n-        if (index >= 0) {\n-            return \"Illegal character found in host: \"\n-                    + describeChar(host.charAt(index));\n+        if (earlyURLParsing()) {\n+            \/\/ also validate IPv6 literal format if present\n+            return checkHost(host);\n+        } else {\n+            int index = scan(host,\n+                    MASKS.L_HOSTNAME_MASK,\n+                    MASKS.H_HOSTNAME_MASK,\n+                    OTHERS);\n+            if (index >= 0) {\n+                return \"Illegal character found in host: \"\n+                        + describeChar(host.charAt(index));\n+            }\n@@ -806,0 +850,8 @@\n+    public static boolean earlyURLParsing() {\n+        return !MASKS.DELAY_URL_PARSING_SP_VALUE;\n+    }\n+\n+    public static boolean delayURLParsing() {\n+        return MASKS.DELAY_URL_PARSING_SP_VALUE;\n+    }\n+\n@@ -820,0 +872,29 @@\n+    private static class MASKS {\n+        private static final String DELAY_URL_PARSING_SP = \"jdk.net.url.delayParsing\";\n+        private static final boolean DELAY_URL_PARSING_SP_VALUE;\n+        static final long L_USERINFO_MASK = L_EXCLUDE & ~L_COLON;\n+        static final long H_USERINFO_MASK = H_EXCLUDE & ~H_COLON;\n+        static final long L_HOSTNAME_MASK;\n+        static final long H_HOSTNAME_MASK;\n+        static final long L_SCOPE_MASK;\n+        static final long H_SCOPE_MASK;\n+        static {\n+            var value = GetPropertyAction.privilegedGetProperty(\n+                    DELAY_URL_PARSING_SP, \"false\");\n+            DELAY_URL_PARSING_SP_VALUE = value.isEmpty()\n+                    || Boolean.parseBoolean(value);\n+            if (DELAY_URL_PARSING_SP_VALUE) {\n+                L_HOSTNAME_MASK = L_NON_PRINTABLE | L_SLASH;\n+                H_HOSTNAME_MASK = H_NON_PRINTABLE | H_SLASH;\n+                L_SCOPE_MASK = L_NON_PRINTABLE | L_IPV6_DELIMS;\n+                H_SCOPE_MASK = H_NON_PRINTABLE | H_IPV6_DELIMS;\n+            } else {\n+                \/\/ the hostname mask can also forbid [ ] brackets, because IPv6 should be\n+                \/\/ checked early before the mask is used when earlier parsing checks are performed\n+                L_HOSTNAME_MASK = L_NON_PRINTABLE | L_SLASH | L_UNWISE | L_EXCLUDED_DELIMS;\n+                H_HOSTNAME_MASK = H_NON_PRINTABLE | H_SLASH | H_UNWISE | H_EXCLUDED_DELIMS;\n+                L_SCOPE_MASK = L_NON_PRINTABLE | L_IPV6_DELIMS | L_SLASH | L_BACKSLASH | L_FRAGMENT | L_QUERY;\n+                H_SCOPE_MASK = H_NON_PRINTABLE | H_IPV6_DELIMS | H_SLASH | H_BACKSLASH | H_FRAGMENT | H_QUERY;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":106,"deletions":25,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    static URL checkURL(URL u) throws IllegalArgumentException {\n+    private static URL checkURL(URL u) throws MalformedURLException {\n@@ -165,2 +165,1 @@\n-                Exception mfue = new MalformedURLException(\"Illegal character in URL\");\n-                throw new IllegalArgumentException(mfue.getMessage(), mfue);\n+                throw new MalformedURLException(\"Illegal character in URL\");\n@@ -169,4 +168,3 @@\n-        String s = IPAddressUtil.checkAuthority(u);\n-        if (s != null) {\n-            Exception mfue = new MalformedURLException(s);\n-            throw new IllegalArgumentException(mfue.getMessage(), mfue);\n+        String errMsg = IPAddressUtil.checkAuthority(u);\n+        if (errMsg != null) {\n+            throw new MalformedURLException(errMsg);\n@@ -182,1 +180,1 @@\n-    public FtpURLConnection(URL url) {\n+    public FtpURLConnection(URL url) throws MalformedURLException {\n@@ -189,1 +187,1 @@\n-    FtpURLConnection(URL url, Proxy p) {\n+    FtpURLConnection(URL url, Proxy p) throws MalformedURLException {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/FtpURLConnection.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,507 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293590\n+ * @summary URL built-in protocol handlers should parse the URL early\n+ *          to avoid constructing URLs for which openConnection\n+ *          would later throw an exception, when possible.\n+ *          A jdk.net.url.delayParsing property allows to switch that\n+ *          behavior off to mitigate risks of regression\n+ * @run junit  EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing=true EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing=false EarlyOrDelayedParsing\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.System.err;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class EarlyOrDelayedParsing {\n+\n+    public final boolean EARLY_PARSING;\n+    {\n+        String value = System.getProperty(\"jdk.net.url.delayParsing\", \"false\");\n+        EARLY_PARSING = !value.isEmpty() && !Boolean.parseBoolean(value);\n+    }\n+\n+    \/\/ Some characters that when included at the wrong place\n+    \/\/ in the authority component, without being escaped, would\n+    \/\/ cause an exception.\n+    private static final String EXCLUDED_DELIMS = \"<>\\\" \";\n+    private static final String UNWISE = \"{}|\\\\^`\";\n+    private static final String DELIMS = \"[]\/?#@\";\n+\n+    \/\/ Test data used to test exceptions thrown by URL\n+    \/\/ at some point, when constructed with some illegal input.\n+    sealed interface URLArgTest\n+            permits OneArgTest, TwoArgsTest, ThreeArgsTest, FourArgsTest {\n+\n+        \/\/ Some character that is expected to cause an exception\n+        \/\/ at some point, and which this test case is built for\n+        int character();\n+\n+        \/\/ An URL string containing the illegal character\n+        String url();\n+\n+        \/\/ Some characters are already checked at construction\n+        \/\/ time. They will cause an exception to be thrown,\n+        \/\/ whether delayed parsing is activated or not.\n+        \/\/ This method returns true if an exception is\n+        \/\/ expected at construction time for this test case,\n+        \/\/ even when delayed parsing is activated.\n+        boolean early(int c);\n+\n+        \/\/ The URL scheme this test case is built for.\n+        \/\/ Typically, one of \"http\", \"https\", \"ftp\"...\n+        default String scheme() {\n+            return scheme(url());\n+        }\n+\n+        \/\/ Return the URL string of this test case, after\n+        \/\/ substituting its scheme with the given scheme.\n+        default String urlWithScheme(String scheme) {\n+            String url = url();\n+            int colon = url.indexOf(':');\n+            String urlWithScheme = scheme + url.substring(colon);\n+            return urlWithScheme;\n+        }\n+\n+        \/\/ Which exception to expect when parsing is delayed\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return exception instanceof MalformedURLException\n+                    || exception instanceof UnknownHostException;\n+        }\n+\n+        default String describe() {\n+            return this.getClass().getSimpleName() + \"(url=\" + url() + \")\";\n+        }\n+\n+        static int port(String protocol) {\n+            return switch (protocol) {\n+                case \"http\" -> 80;\n+                case \"https\" -> 443;\n+                case \"ftp\" -> 21;\n+                default -> -1;\n+            };\n+        }\n+\n+        static String scheme(String url) {\n+            return url.substring(0, url.indexOf(':'));\n+        }\n+    }\n+\n+    \/\/ Test data for the one arg constructor\n+    \/\/ public URL(String spec) throws MalformedURLException\n+    sealed interface OneArgTest extends URLArgTest {\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme\n+        default OneArgTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHost) {\n+                return new OfHost(character(), urlWithScheme);\n+            }\n+            if (this instanceof OfUserInfo) {\n+                return new OfUserInfo(character(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return this instanceof OfHost &&\n+                    (c < 31 || c == 127);\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && character() == '\\\\'\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHost(int character, String url) implements OneArgTest { }\n+        record OfUserInfo(int character, String url) implements OneArgTest { }\n+\n+        static OneArgTest ofHost(int c) {\n+            return new OfHost(c, \"http:\/\/local%shost\/\".formatted(Character.toString(c)));\n+        }\n+        static OneArgTest ofUserInfo(int c) {\n+            return new OfUserInfo(c, \"http:\/\/user%sinfo@localhost:9999\/\".formatted(Character.toString(c)));\n+        }\n+    }\n+\n+    \/\/ Test data for the two arg constructor\n+    \/\/ public URL(URL context, String spec) throws MalformedURLException\n+    sealed interface TwoArgsTest extends URLArgTest {\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme\n+        default TwoArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfTwoArgsHost) {\n+                return new OfTwoArgsHost(character(), urlWithScheme);\n+            }\n+            if (this instanceof OfTwoArgsUserInfo) {\n+                return new OfTwoArgsUserInfo(character(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return this instanceof OfTwoArgsHost &&\n+                    (c < 31 || c == 127);\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && character() == '\\\\'\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfTwoArgsHost(int character, String url) implements TwoArgsTest { }\n+        record OfTwoArgsUserInfo(int character, String url) implements TwoArgsTest { }\n+\n+        static TwoArgsTest ofHost(int c) {\n+            return new OfTwoArgsHost(c, \"http:\/\/local%shost\/\".formatted(Character.toString(c)));\n+        }\n+        static TwoArgsTest ofUserInfo(int c) {\n+            return new OfTwoArgsUserInfo(c, \"http:\/\/user%sinfo@localhost:9999\/\".formatted(Character.toString(c)));\n+        }\n+        static TwoArgsTest ofOneArgTest(OneArgTest test) {\n+            if (test instanceof OneArgTest.OfHost) {\n+                return ofHost(test.character());\n+            } else if (test instanceof OneArgTest.OfUserInfo) {\n+                return ofUserInfo(test.character());\n+            }\n+            throw new AssertionError(\"can't convert to TwoArgsTest: \"\n+                    + test.getClass());\n+        }\n+    }\n+\n+\n+    \/\/ Test data for the three args constructor\n+    \/\/ public URL(String scheme, String host, String file)\n+    \/\/     throws MalformedURLException\n+    sealed interface ThreeArgsTest extends URLArgTest {\n+\n+        \/\/ the host component\n+        String host();\n+\n+        \/\/ the path + query components\n+        String file();\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme and port\n+        default ThreeArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHostFile) {\n+                return new OfHostFile(character(), host(), file(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return (c < 31 || c == 127 || c == '\/');\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHostFile(int character, String host, String file, String url)\n+                implements ThreeArgsTest {\n+        }\n+\n+        static ThreeArgsTest ofHostFile(int c) {\n+            String host = \"local%shost\".formatted(Character.toString(c));\n+            String url = \"http:\/\/\" + host + \"\/\";\n+            return new OfHostFile(c, host, \"\/\", url);\n+        }\n+    }\n+\n+    \/\/ Test data for the four args constructor\n+    \/\/ public URL(String scheme, String host, int port, String file)\n+    \/\/     throws MalformedURLException\n+    sealed interface FourArgsTest extends URLArgTest {\n+\n+        \/\/ the host component\n+        String host();\n+\n+        \/\/ the port component\n+        int port();\n+\n+        \/\/ the path + query components\n+        String file();\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme and port\n+        default FourArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHostFilePort) {\n+                int port = URLArgTest.port(scheme);\n+                return new OfHostFilePort(character(), host(), port, file(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return (c < 31 || c == 127 || c == '\/');\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHostFilePort(int character, String host, int port, String file, String url)\n+                implements FourArgsTest {\n+        }\n+\n+        static FourArgsTest ofHostPortFile(int c) {\n+            String host = \"local%shost\".formatted(Character.toString(c));\n+            String url = \"http:\/\/\" + host + \"\/\";\n+            int port = URLArgTest.port(URLArgTest.scheme(url));\n+            return new OfHostFilePort(c, host, port, \"\/\", url);\n+        }\n+    }\n+\n+\n+    \/\/ Generate test data for the URL one arg constructor, with variations\n+    \/\/ of the host component.\n+    static Stream<OneArgTest> oneArgHostTests() {\n+        List<OneArgTest> tests = new ArrayList<>();\n+        List<OneArgTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS).chars()\n+                .mapToObj(OneArgTest::ofHost).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(OneArgTest::ofHost).toList());\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Generate test data for the URL one arg constructor, with variations\n+    \/\/ of the user info component.\n+    static Stream<OneArgTest> oneArgUserInfoTests() {\n+        List<OneArgTest> tests = new ArrayList<>();\n+        List<OneArgTest> urls = new ArrayList<>();\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(OneArgTest::ofUserInfo).toList());\n+        urls.add(OneArgTest.ofUserInfo('\\\\'));\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Test data with all variations for the URL one arg\n+    \/\/ constructor (spec)\n+    static Stream<OneArgTest> oneArgTests() {\n+        return Stream.concat(oneArgHostTests(), oneArgUserInfoTests());\n+    }\n+\n+    \/\/ Test data with all variations for the URL two arg\n+    \/\/ constructor (URL, spec)\n+    static Stream<TwoArgsTest> twoArgTests() {\n+        return oneArgTests().map(TwoArgsTest::ofOneArgTest);\n+    }\n+\n+    \/\/ Generate test data for the URL three arguments constructor\n+    \/\/ (scheme, host, file)\n+    static Stream<ThreeArgsTest> threeArgsTests() {\n+        List<ThreeArgsTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS + DELIMS).chars()\n+                .mapToObj(ThreeArgsTest::ofHostFile).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(ThreeArgsTest::ofHostFile).toList());\n+        List<ThreeArgsTest> tests = new ArrayList<>();\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\", \"file\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Generate test data for the URL four arguments constructor\n+    \/\/ (scheme, host, port, file)\n+    static Stream<FourArgsTest> fourArgsTests() {\n+        List<FourArgsTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS + DELIMS).chars()\n+                .mapToObj(FourArgsTest::ofHostPortFile).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(FourArgsTest::ofHostPortFile).toList());\n+        List<FourArgsTest> tests = new ArrayList<>();\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\", \"file\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"oneArgTests\")\n+    public void testOneArgConstructor(OneArgTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + test.describe());\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(url);\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + test.describe());\n+            URL u = new URL(url);\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                    err.println(\"unexpected exception type: \" + exception);\n+                    throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"twoArgTests\")\n+    public void testTwoArgConstructor(TwoArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        String scheme = URLArgTest.scheme(url);\n+        URL u = new URL(scheme, null,\"\");\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + test.describe());\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(u, url);\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + test.describe());\n+            URL u2 = new URL(u, url);\n+            var exception = assertThrows(IOException.class, () -> {\n+                u2.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"threeArgsTests\")\n+    public void testThreeArgsConstructor(ThreeArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + url);\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(test.scheme(), test.host(), test.file());\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + url);\n+            URL u = new URL(test.scheme(), test.host(), test.file());\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"fourArgsTests\")\n+    public void testFourArgsConstructor(FourArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + url);\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(test.scheme(), test.host(), test.port(), test.file());\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + url);\n+            URL u = new URL(test.scheme(), test.host(), test.port(), test.file());\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/URL\/EarlyOrDelayedParsing.java","additions":507,"deletions":0,"binary":false,"changes":507,"status":"added"}]}