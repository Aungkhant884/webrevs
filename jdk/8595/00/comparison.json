{"files":[{"patch":"@@ -96,2 +96,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)(f.real_fp() - 1);\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -262,0 +262,1 @@\n+\n@@ -266,0 +267,1 @@\n+\n@@ -268,1 +270,2 @@\n-  assert(_pc == *pc_addr || pc == *pc_addr, \"must be\");\n+  assert(_pc == *pc_addr || pc == *pc_addr || *pc_addr == 0, \"must be\");\n+  DEBUG_ONLY(address old_pc = _pc;)\n@@ -270,0 +273,1 @@\n+  _pc = pc; \/\/ must be set before call to get_deopt_original_pc\n@@ -272,1 +276,1 @@\n-    assert(original_pc == _pc, \"expected original PC to be stored before patching\");\n+    assert(original_pc == old_pc, \"expected original PC to be stored before patching\");\n@@ -274,1 +278,1 @@\n-    \/\/ leave _pc as is\n+    _pc = original_pc;\n@@ -277,1 +281,0 @@\n-    _pc = pc;\n@@ -381,0 +384,1 @@\n+#ifdef ASSERT\n@@ -397,0 +401,2 @@\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  void adjust_unextended_sp();\n+  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n@@ -192,0 +192,1 @@\n+  void setup(address pc);\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -57,0 +58,4 @@\n+  _oop_map = NULL;\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n+\n@@ -59,0 +64,4 @@\n+  setup(pc);\n+}\n+\n+inline void frame::setup(address pc) {\n@@ -65,0 +74,2 @@\n+    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n@@ -66,1 +77,5 @@\n-    _deopt_state = not_deoptimized;\n+    if (_cb == SharedRuntime::deopt_blob()) {\n+      _deopt_state = is_deoptimized;\n+    } else {\n+      _deopt_state = not_deoptimized;\n+    }\n@@ -68,3 +83,0 @@\n-\n-  _on_heap = false;\n-  DEBUG_ONLY(_frame_index = -1;)\n@@ -86,12 +98,1 @@\n-  adjust_unextended_sp();\n-\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n-  if (original_pc != NULL) {\n-    _pc = original_pc;\n-    assert(_cb->as_compiled_method()->insts_contains_inclusive(_pc),\n-           \"original PC must be in the main code section of the the compiled method (or must be immediately following it)\");\n-    _deopt_state = is_deoptimized;\n-  } else {\n-    _deopt_state = not_deoptimized;\n-  }\n-\n+  _oop_map = NULL;\n@@ -100,0 +101,2 @@\n+\n+  setup(pc);\n@@ -296,1 +299,5 @@\n-  Unimplemented();\n+  if (_cb == NULL) return NULL;\n+  if (_cb->oop_maps() != NULL) {\n+    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+    return oop_map;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/continuation.hpp\"\n@@ -198,1 +199,1 @@\n-  inline bool is_nop();\n+  inline bool is_nop() const;\n@@ -497,1 +498,1 @@\n-inline bool NativeInstruction::is_nop()         {\n+inline bool NativeInstruction::is_nop() const {\n@@ -574,2 +575,2 @@\n-  bool check() const { Unimplemented(); return false; }\n-  int displacement() const { Unimplemented(); return 0; }\n+  bool check() const { return is_nop(); }\n+  int displacement() const { return 0; }\n@@ -581,1 +582,4 @@\n-  Unimplemented();\n+  NativePostCallNop* nop = (NativePostCallNop*) address;\n+  if (nop->check()) {\n+    return nop;\n+  }\n@@ -593,0 +597,1 @@\n+    if (!Continuations::enabled()) return false;\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3703,0 +3703,94 @@\n+  address generate_cont_thaw() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_returnBarrier_exception() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  RuntimeStub* generate_cont_doYield() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+#if INCLUDE_JFR\n+\n+#undef __\n+#define __ _masm->\n+\n+  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n+    __ set_last_Java_frame(sp, fp, the_pc, t0);\n+    __ mv(c_rarg0, thread);\n+  }\n+\n+  static void jfr_epilogue(MacroAssembler* _masm, Register thread) {\n+    __ reset_last_Java_frame(true);\n+    Label null_jobject;\n+    __ beqz(x10, null_jobject);\n+    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->load_at(_masm, decorators, T_OBJECT, x10, Address(x10, 0), c_rarg0, thread);\n+    __ bind(null_jobject);\n+  }\n+\n+  static RuntimeStub* generate_jfr_stub(const char* name, address entrypoint) {\n+    enum layout {\n+      fp_off,\n+      fp_off2,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    int insts_size = 512;\n+    int locs_size = 64;\n+    CodeBuffer code(name, insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm, xthread);\n+    __ call_VM_leaf(entrypoint, 1);\n+    jfr_epilogue(_masm, xthread);\n+    __ leave();\n+    __ ret();\n+\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n+#undef __\n+\n+  RuntimeStub* generate_jfr_write_checkpoint() {\n+    return generate_jfr_stub(\"jfr_write_checkpoint\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint));\n+  }\n+\n+  RuntimeStub* generate_jfr_get_event_writer() {\n+    return generate_jfr_stub(\"jfr_get_event_writer\",\n+                              CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::event_writer));\n+  }\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -3732,0 +3826,17 @@\n+  void generate_phase1() {\n+    \/\/ Continuation stubs:\n+    StubRoutines::_cont_thaw             = generate_cont_thaw();\n+    StubRoutines::_cont_returnBarrier    = generate_cont_returnBarrier();\n+    StubRoutines::_cont_returnBarrierExc = generate_cont_returnBarrier_exception();\n+    StubRoutines::_cont_doYield_stub     = generate_cont_doYield();\n+    StubRoutines::_cont_doYield = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n+                                   : StubRoutines::_cont_doYield_stub->entry_point();\n+\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub == nullptr ? nullptr\n+                                                    : StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer_stub = generate_jfr_get_event_writer();)\n+    JFR_ONLY(StubRoutines::_jfr_get_event_writer = StubRoutines::_jfr_get_event_writer_stub == nullptr ? nullptr\n+                                                    : StubRoutines::_jfr_get_event_writer_stub->entry_point();)\n+  }\n+\n@@ -3801,4 +3912,2 @@\n-  StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {\n-    if (all) {\n-      generate_all();\n-    } else {\n+  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n+    if (phase == 0) {\n@@ -3806,0 +3915,4 @@\n+    } else if (phase == 1) {\n+      generate_phase1(); \/\/ stubs that must be available for the interpreter\n+    } else {\n+      generate_all();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":117,"deletions":4,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -801,0 +801,1 @@\n+  if (!Continuations::enabled()) return nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}