{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -948,0 +948,1 @@\n+        private long estimatedSize; \/\/ estimated size, to help to split evenly\n@@ -974,0 +975,9 @@\n+            this.estimatedSize = -1;\n+        }\n+\n+        private ArraySpliterator(Object[] array, int origin, int fence, int characteristics, long estimatedSize) {\n+            this.array = array;\n+            this.index = origin;\n+            this.fence = fence;\n+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n+            this.estimatedSize = estimatedSize;\n@@ -979,3 +989,7 @@\n-            return (lo >= mid)\n-                   ? null\n-                   : new ArraySpliterator<>(array, lo, index = mid, characteristics);\n+            if (lo >= mid) return null;\n+            if (estimatedSize == -1) {\n+                return new ArraySpliterator<>(array, lo, index = mid, characteristics);\n+            }\n+            long prefixEstimatedSize = estimatedSize >>> 1;\n+            estimatedSize -= prefixEstimatedSize;\n+            return new ArraySpliterator<>(array, lo, index = mid, characteristics, prefixEstimatedSize);\n@@ -1009,1 +1023,3 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() {\n+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);\n+        }\n@@ -1033,0 +1049,1 @@\n+        private long estimatedSize; \/\/ estimated size, to help to split evenly\n@@ -1059,0 +1076,9 @@\n+            this.estimatedSize = -1;\n+        }\n+\n+        private IntArraySpliterator(int[] array, int origin, int fence, int characteristics, long estimatedSize) {\n+            this.array = array;\n+            this.index = origin;\n+            this.fence = fence;\n+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n+            this.estimatedSize = estimatedSize;\n@@ -1064,3 +1090,7 @@\n-            return (lo >= mid)\n-                   ? null\n-                   : new IntArraySpliterator(array, lo, index = mid, characteristics);\n+            if (lo >= mid) return null;\n+            if (estimatedSize == -1) {\n+                return new IntArraySpliterator(array, lo, index = mid, characteristics);\n+            }\n+            long prefixEstimatedSize = estimatedSize >>> 1;\n+            estimatedSize -= prefixEstimatedSize;\n+            return new IntArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);\n@@ -1092,1 +1122,3 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() {\n+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);\n+        }\n@@ -1116,0 +1148,1 @@\n+        private long estimatedSize; \/\/ estimated size, to help to split evenly\n@@ -1142,0 +1175,9 @@\n+            this.estimatedSize = -1;\n+        }\n+\n+        private LongArraySpliterator(long[] array, int origin, int fence, int characteristics, long estimatedSize) {\n+            this.array = array;\n+            this.index = origin;\n+            this.fence = fence;\n+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n+            this.estimatedSize = estimatedSize;\n@@ -1147,3 +1189,7 @@\n-            return (lo >= mid)\n-                   ? null\n-                   : new LongArraySpliterator(array, lo, index = mid, characteristics);\n+            if (lo >= mid) return null;\n+            if (estimatedSize == -1) {\n+                return new LongArraySpliterator(array, lo, index = mid, characteristics);\n+            }\n+            long prefixEstimatedSize = estimatedSize >>> 1;\n+            estimatedSize -= prefixEstimatedSize;\n+            return new LongArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);\n@@ -1175,1 +1221,3 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() {\n+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);\n+        }\n@@ -1199,0 +1247,1 @@\n+        private long estimatedSize; \/\/ estimated size, to help to split evenly\n@@ -1225,0 +1274,9 @@\n+            this.estimatedSize = -1;\n+        }\n+\n+        private DoubleArraySpliterator(double[] array, int origin, int fence, int characteristics, long estimatedSize) {\n+            this.array = array;\n+            this.index = origin;\n+            this.fence = fence;\n+            this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n+            this.estimatedSize = estimatedSize;\n@@ -1230,3 +1288,7 @@\n-            return (lo >= mid)\n-                   ? null\n-                   : new DoubleArraySpliterator(array, lo, index = mid, characteristics);\n+            if (lo >= mid) return null;\n+            if (estimatedSize == -1) {\n+                return new DoubleArraySpliterator(array, lo, index = mid, characteristics);\n+            }\n+            long prefixEstimatedSize = estimatedSize >>> 1;\n+            estimatedSize -= prefixEstimatedSize;\n+            return new DoubleArraySpliterator(array, lo, index = mid, characteristics, prefixEstimatedSize);\n@@ -1258,1 +1320,3 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() {\n+            return estimatedSize >= 0 ? estimatedSize : (long)(fence - index);\n+        }\n@@ -1365,1 +1429,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1367,1 +1431,3 @@\n-                return new ArraySpliterator<>(a, 0, j, characteristics());\n+                    return new ArraySpliterator<>(a, 0, j, characteristics);\n+                }\n+                return new ArraySpliterator<>(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -1475,1 +1541,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1477,1 +1543,3 @@\n-                return new IntArraySpliterator(a, 0, j, characteristics());\n+                    return new IntArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new IntArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -1585,1 +1653,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1587,1 +1655,3 @@\n-                return new LongArraySpliterator(a, 0, j, characteristics());\n+                    return new LongArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new LongArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -1695,1 +1765,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1697,1 +1767,3 @@\n-                return new DoubleArraySpliterator(a, 0, j, characteristics());\n+                    return new DoubleArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new DoubleArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -1830,1 +1902,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1832,1 +1904,3 @@\n-                return new ArraySpliterator<>(a, 0, j, characteristics);\n+                    return new ArraySpliterator<>(a, 0, j, characteristics);\n+                }\n+                return new ArraySpliterator<>(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -1942,1 +2016,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -1944,1 +2018,3 @@\n-                return new IntArraySpliterator(a, 0, j, characteristics);\n+                    return new IntArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new IntArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -2036,1 +2112,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -2038,1 +2114,3 @@\n-                return new LongArraySpliterator(a, 0, j, characteristics);\n+                    return new LongArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new LongArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n@@ -2130,1 +2208,1 @@\n-                if (est != Long.MAX_VALUE)\n+                if (est != Long.MAX_VALUE) {\n@@ -2132,1 +2210,3 @@\n-                return new DoubleArraySpliterator(a, 0, j, characteristics);\n+                    return new DoubleArraySpliterator(a, 0, j, characteristics);\n+                }\n+                return new DoubleArraySpliterator(a, 0, j, characteristics, Long.MAX_VALUE \/ 2);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":113,"deletions":33,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.stream.Collector;\n@@ -100,0 +101,17 @@\n+\n+    @Test\n+    public void testParallelize() {\n+        checkHasSplit(Stream.iterate(0, x -> x < 10, x -> x + 1));\n+        checkHasSplit(IntStream.iterate(0, x -> x < 10, x -> x + 1).boxed());\n+        checkHasSplit(LongStream.iterate(0, x -> x < 10, x -> x + 1).boxed());\n+        checkHasSplit(DoubleStream.iterate(0, x -> x < 10, x -> x + 1).boxed());\n+    }\n+\n+    private void checkHasSplit(Stream<?> stream) {\n+        int[] numberOfNonEmptyParts = stream.parallel().collect(\n+                Collector.of(() -> new int[1], (acc, e) -> acc[0] = 1, (acc1, acc2) -> {\n+                  acc1[0] += acc2[0];\n+                  return acc1;\n+                }));\n+        assertTrue(numberOfNonEmptyParts[0] >= 2);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/IterateTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.math.BigInteger;\n+import java.util.SplittableRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Benchmark for checking Pattern::splitAsStream performance\n+ * with CPU-bound downstream operation in sequential and parallel streams\n+ *\n+ * See JDK-8280915\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class PatternSplit {\n+    @Param({\"10\", \"100\", \"1000\", \"10000\"})\n+    private int size;\n+\n+    private String input;\n+\n+    private static final Pattern PATTERN = Pattern.compile(\",\");\n+\n+    @Setup\n+    public void setup() {\n+        input = new SplittableRandom(1).ints(size, 1000, 2000)\n+                .mapToObj(String::valueOf).collect(Collectors.joining(\",\"));\n+    }\n+\n+    @Benchmark\n+    public BigInteger sumOf1000thPowers() {\n+        return PATTERN.splitAsStream(input).map(BigInteger::new).map(v -> v.pow(1000))\n+                .reduce(BigInteger.ZERO, BigInteger::add);\n+    }\n+\n+    @Benchmark\n+    public BigInteger sumOf1000thPowersParallel() {\n+        return PATTERN.splitAsStream(input).parallel().map(BigInteger::new).map(v -> v.pow(1000))\n+                .reduce(BigInteger.ZERO, BigInteger::add);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/PatternSplit.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}