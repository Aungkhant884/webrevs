{"files":[{"patch":"@@ -268,2 +268,3 @@\n-                \/\/ There are 4 contiguous 31-bit set, and thus imp^(2^31 - 1)\n-                \/\/ is pre-computed to speed up the computation.\n+                \/\/ There are 3 contiguous 32-bit set, and 1 contiguous 30-bit\n+                \/\/ set. Thus values imp^(2^32 - 1) and imp^(2^30 - 1) are\n+                \/\/ pre-computed to speed up the computation.\n@@ -271,1 +272,1 @@\n-                \/\/ calculate imp ^ (2^31 - 1)\n+                \/\/ calculate imp ^ (2^32 - 1)\n@@ -273,1 +274,3 @@\n-                for (int i = 30; i != 0; i--) {\n+                MutableIntegerModuloP v = null;\n+                MutableIntegerModuloP w = null;\n+                for (int i = 0; i < 31; i++) {\n@@ -275,1 +278,18 @@\n-                    t.setProduct(imp);\n+                    switch (i) {\n+                        case 0 -> {\n+                            t.setProduct(imp);\n+                            v = t.mutable();    \/\/ 2: imp ^ (2^2 - 1)\n+                        }\n+                        case 4 -> {\n+                            t.setProduct(v);\n+                            w = t.mutable();    \/\/ 4: imp ^ (2^6 - 1)\n+                        }\n+                        case 12, 28 -> {\n+                            t.setProduct(w);\n+                            w = t.mutable();    \/\/ 12: imp ^ (2^14 - 1)\n+                                                \/\/ 28: imp ^ (2^30 - 1)\n+                        }\n+                        case 2, 6, 14, 30 -> {\n+                            t.setProduct(v);\n+                        }\n+                    }\n@@ -278,0 +298,5 @@\n+                \/\/ here we have:\n+                \/\/     v = imp ^ (2^2 - 1)\n+                \/\/     w = imp ^ (2^30 - 1)\n+                \/\/     t = imp ^ (2^32 - 1)\n+\n@@ -280,1 +305,1 @@\n-                for (int i = 31; i < 256; i++) {\n+                for (int i = 32; i < 256; i++) {\n@@ -283,2 +308,2 @@\n-                        \/\/ For contiguous 31-bit set.\n-                        case 190, 221, 252 -> {\n+                        \/\/ For contiguous 32-bit set.\n+                        case 191, 223 -> {\n@@ -287,0 +312,4 @@\n+                        \/\/ For contiguous 30-bit set.\n+                        case 253 -> {\n+                            d.setProduct(w);\n+                        }\n@@ -288,1 +317,1 @@\n-                        case 31, 63, 253, 255 -> {\n+                        case 63, 255 -> {\n@@ -311,1 +340,1 @@\n-                \/\/ There are 3 contiguous 32-bit set, and imp^(2^16 - 1)\n+                \/\/ There are 3 contiguous 32-bit set, and imp^(2^32 - 1)\n@@ -314,1 +343,3 @@\n-                \/\/ calculate imp ^ (2^16 - 1)\n+                \/\/ calculate and cache imp ^ (2^2 - 1) - imp ^ (2^4 - 1)\n+                IntegerModuloP[] w = new IntegerModuloP[4];\n+                w[0] = imp.fixed();\n@@ -316,1 +347,1 @@\n-                for (int i = 15; i != 0; i--) {\n+                for (int i = 1; i < 4; i++) {\n@@ -319,0 +350,1 @@\n+                    w[i] = t.fixed();\n@@ -321,1 +353,22 @@\n-                \/\/ calculate (1 \/ imp)\n+                \/\/ calculate imp ^ (2^32 - 1)\n+                MutableIntegerModuloP d = null;\n+                for (int i = 4; i < 32; i++) {\n+                    t.setSquare();\n+                    switch (i) {\n+                        case 7 -> {\n+                            t.setProduct(w[3]);\n+                            d = t.mutable();   \/\/ 7: imp ^ (2^8 - 1)\n+                        }\n+                        case 15 -> {\n+                            t.setProduct(d);\n+                            d = t.mutable();   \/\/ 15: imp ^ (2^16 - 1)\n+                        }\n+                        case 31 -> {\n+                            t.setProduct(d); \/\/ 31: imp ^ (2^32 - 1)\n+                        }\n+                    }\n+                }\n+\n+                \/\/ Here we have:\n+                \/\/    w[i] = imp ^ (2 ^ ( i + 1) - 1), i = {0, 1, 2, 3}\n+                \/\/       t = imp ^ (2^32 - 1)\n@@ -323,2 +376,2 @@\n-                \/\/ calculate for bit 16-128, for contiguous 16-bit set.\n-                MutableIntegerModuloP d = t.mutable();\n+                \/\/ calculate for bit 32-128, for contiguous 32-bit set.\n+                d = t.mutable();\n@@ -327,2 +380,2 @@\n-                    if (i == 31 || i == 79 || i == 95 || i == 111 || i == 127) {\n-                            d.setProduct(t);\n+                    if (i == 95 || i == 127) {\n+                        d.setProduct(t);\n@@ -333,2 +386,1 @@\n-                for (int i = 127; i >= 0; i--) {\n-                    d.setSquare();\n+                for (int k = -1, i = 127; i >= 0; i--) {\n@@ -336,1 +388,16 @@\n-                        d.setProduct(imp);\n+                        if (k == w.length - 2) {\n+                            \/\/ calculate the current & reserved bits\n+                            d.setSquare();\n+                            d.setProduct(w[w.length - 1]);\n+                            k = -1;\n+                        } else {\n+                            k++;\n+                            d.setSquare();\n+                        }\n+                    } else {    \/\/ calculate the reserved bits\n+                        if (k >= 0) {\n+                            \/\/ add back the reserved bits\n+                            d.setProduct(w[k]);\n+                            k = -1;\n+                        }\n+                        d.setSquare();\n@@ -340,0 +407,5 @@\n+                \/\/ Note that the last 4 bits was handled in the for-lopp above\n+                \/\/ as it hapeens to be 4. For bit set other than 4 bits, for\n+                \/\/ example, 3 bits set (0x8), the value should be added back.\n+                \/\/ d.setProduct(w[2]);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerModuloP.java","additions":92,"deletions":20,"binary":false,"changes":112,"status":"modified"}]}