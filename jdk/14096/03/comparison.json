{"files":[{"patch":"@@ -727,3 +727,3 @@\n-    if (can_create_pairs(mem_ref, iv_adjustment, align_to_ref_p,\n-                         best_align_to_mem_ref, best_iv_adjustment,\n-                         align_to_refs)) {\n+    if (mem_ref_has_no_alignment_violation(mem_ref, iv_adjustment, align_to_ref_p,\n+                                           best_align_to_mem_ref, best_iv_adjustment,\n+                                           align_to_refs)) {\n@@ -839,39 +839,7 @@\n-\/\/ Check if we can create the pack pairs for mem_ref:\n-\/\/ If required, enforce strict alignment requirements of hardware.\n-\/\/ Else, only enforce alignment within a memory slice, so that there cannot be any\n-\/\/ memory-dependence between different vector \"lanes\".\n-bool SuperWord::can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n-                                 MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                 Node_List &align_to_refs) {\n-  bool is_aligned_with_best = memory_alignment(mem_ref, best_iv_adjustment) == 0;\n-\n-  if (vectors_should_be_aligned()) {\n-    \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n-    \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n-    \/\/\n-    \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n-    \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n-    \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n-    \/\/ we check the following 3 conditions.\n-\n-    \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n-    if (!is_aligned_with_best) {\n-      return false;\n-    }\n-    \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n-    int vw = vector_width(mem_ref);\n-    int vw_best = vector_width(best_align_to_mem_ref);\n-    if (vw > vw_best) {\n-      \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n-      \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n-      return false;\n-    }\n-    \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n-    \/\/     address = base + k*iv + constant [+ invar]\n-    \/\/     memory_alignment ignores the invariant.\n-    SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n-    if (!align_to_ref_p.invar_equals(p2)) {\n-      \/\/ Do not vectorize memory accesses with different invariants\n-      \/\/ if unaligned memory accesses are not allowed.\n-      return false;\n-    }\n+\/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n+\/\/ mem_ref is aligned with best_align_to_mem_ref.\n+bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                                   MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                                   Node_List &align_to_refs) {\n+  if (!vectors_should_be_aligned()) {\n+    \/\/ Alignment is not required by the hardware. No violation possible.\n@@ -879,31 +847,0 @@\n-  } else {\n-    \/\/ Alignment is not required by the hardware.\n-\n-    \/\/ However, we need to ensure that the pack for mem_ref is independent, i.e. all members\n-    \/\/ of the pack are mutually independent.\n-\n-    if (_do_vector_loop) {\n-      \/\/ Wait until combine_packs to check independence of packs. For now we just know that\n-      \/\/ the adjacent pairs are independent. This allows us to vectorize when we do not have\n-      \/\/ alignment modulo vector_width. For example (forward read):\n-      \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n-      \/\/ The following will be filtered out in combine_packs (forward write):\n-      \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n-      return true;\n-    }\n-\n-    \/\/ If all mem_ref's are modulo vector_width aligned with all other mem_ref's of their\n-    \/\/ memory slice, then the VectorLoad \/ VectorStore regions are either exactly overlapping\n-    \/\/ or completely non-overlapping. This ensures that there cannot be memory-dependencies\n-    \/\/ between different vector \"lanes\".\n-    \/\/ During SuperWord::filter_packs -> SuperWord::profitable -> SuperWord::is_vector_use,\n-    \/\/ we check that all inputs are vectors that match on every element (with some reasonable\n-    \/\/ exceptions). This ensures that every \"lane\" is isomorpic and independent to all other\n-    \/\/ \"lanes\". This allows us to vectorize these cases:\n-    \/\/ for (int i ...) { v[i] = v[i] + 5; }      \/\/ same alignment\n-    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector_width\n-    if (same_memory_slice(mem_ref, best_align_to_mem_ref)) {\n-      return is_aligned_with_best;\n-    } else {\n-      return is_mem_ref_aligned_with_same_memory_slice(mem_ref, iv_adjustment, align_to_refs);\n-    }\n@@ -911,1 +848,0 @@\n-}\n@@ -913,11 +849,28 @@\n-\/\/ Check if alignment of mem_ref is consistent with the other packs of the same memory slice\n-bool SuperWord::is_mem_ref_aligned_with_same_memory_slice(MemNode* mem_ref, int iv_adjustment,\n-                                                          Node_List &align_to_refs) {\n-  for (uint i = 0; i < align_to_refs.size(); i++) {\n-    MemNode* mr = align_to_refs.at(i)->as_Mem();\n-    if (mr != mem_ref &&\n-        same_memory_slice(mr, mem_ref) &&\n-        memory_alignment(mr, iv_adjustment) != 0) {\n-      \/\/ mem_ref is misaligned with mr, another ref of the same memory slice.\n-      return false;\n-    }\n+  \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n+  \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n+  \/\/\n+  \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n+  \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n+  \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n+  \/\/ we check the following 3 conditions.\n+\n+  \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n+  if (memory_alignment(mem_ref, best_iv_adjustment) != 0) {\n+    return false;\n+  }\n+  \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n+  int vw = vector_width(mem_ref);\n+  int vw_best = vector_width(best_align_to_mem_ref);\n+  if (vw > vw_best) {\n+    \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n+    \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n+    return false;\n+  }\n+  \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n+  \/\/     address = base + k*iv + constant [+ invar]\n+  \/\/     memory_alignment ignores the invariant.\n+  SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n+  if (!align_to_ref_p.invar_equals(p2)) {\n+    \/\/ Do not vectorize memory accesses with different invariants\n+    \/\/ if unaligned memory accesses are not allowed.\n+    return false;\n@@ -925,1 +878,0 @@\n-  \/\/ No misalignment found.\n@@ -1904,3 +1856,8 @@\n-        \/\/ Skip pack which can't be vector.\n-        \/\/ case1: for(...) { a[i] = i; }    elements values are different (i+x)\n-        \/\/ case2: for(...) { a[i] = b[i+1]; }  can't align both, load and store\n+        \/\/ We currently only support power-of-2 sizes for vectors.\n+#ifndef PRODUCT\n+        if (TraceSuperWord) {\n+          tty->cr();\n+          tty->print_cr(\"WARNING: Removed pack[%d] with size that is not a power of 2:\", i);\n+          print_pack(p1);\n+        }\n+#endif\n@@ -1925,10 +1882,25 @@\n-  if (_do_vector_loop) {\n-    \/\/ Since we did not enforce exact alignment of the packsets, we only know that there\n-    \/\/ is no dependence with distance 1, because we have checked independent(s1, s2) for\n-    \/\/ all adjacent memops. But there could be a dependence of a different distance.\n-    \/\/ Hence: remove the pack if there is a dependence.\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p = _packset.at(i);\n-      if (p != nullptr) {\n-        Node* dependence = find_dependence(p);\n-        if (dependence != nullptr) {\n+  \/\/ We know that the nodes in a pair pack were independent - this gives us independence\n+  \/\/ at distance 1. But now that we may have more than 2 nodes in a pack, we need to check\n+  \/\/ if they are all mutually independent. If there is a dependence we remove the pack.\n+  \/\/ This is better than giving up completely - we can have partial vectorization if some\n+  \/\/ are rejected and others still accepted.\n+  \/\/\n+  \/\/ Examples with dependence at distance 1 (pack pairs are not created):\n+  \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n+  \/\/ for (int i ...) { v[i] = v[i - 1] + 5; }\n+  \/\/\n+  \/\/ Example with independence at distance 1, but dependence at distance 2 (pack pairs are\n+  \/\/ created and we need to filter them out now):\n+  \/\/ for (int i ...) { v[i + 2] = v[i] + 5; }\n+  \/\/ for (int i ...) { v[i] = v[i - 2] + 5; }\n+  \/\/\n+  \/\/ Note: dependencies are created when a later load may reference the same memory location\n+  \/\/ as an earlier store. This happens in \"read backward\" or \"store forward\" cases. On the\n+  \/\/ other hand, \"read forward\" or \"store backward\" cases do not have such dependencies:\n+  \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n+  \/\/ for (int i ...) { v[i - 1] = v[i] + 5; }\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      Node* dependence = find_dependence(p);\n+      if (dependence != nullptr) {\n@@ -1936,10 +1908,6 @@\n-          if (TraceSuperWord) {\n-            tty->cr();\n-            tty->print_cr(\"WARNING: Found dependency.\");\n-            tty->print_cr(\"Cannot vectorize despite compile directive Vectorize.\");\n-            dependence->dump();\n-            tty->print_cr(\"In pack[%d]\", i);\n-            print_pack(p);\n-          }\n-#endif\n-          _packset.at_put(i, nullptr);\n+        if (TraceSuperWord) {\n+          tty->cr();\n+          tty->print_cr(\"WARNING: Found dependency at distance greater than 1.\");\n+          dependence->dump();\n+          tty->print_cr(\"In pack[%d]\", i);\n+          print_pack(p);\n@@ -1947,0 +1915,2 @@\n+#endif\n+        _packset.at_put(i, nullptr);\n@@ -3760,1 +3730,1 @@\n-    tty->print_cr(\"SWPointer::memory_alignment: off_rem = %d, off_mod = %d\", off_rem, off_mod);\n+    tty->print_cr(\"SWPointer::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":80,"deletions":110,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -516,9 +516,5 @@\n-  \/\/ Check if we can create the pack pairs for mem_ref:\n-  \/\/ If required, enforce strict alignment requirements of hardware.\n-  \/\/ Else, only enforce alignment within a memory slice, so that there cannot be any\n-  \/\/ memory-dependence between different vector \"lanes\".\n-  bool can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n-                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                        Node_List &align_to_refs);\n-  \/\/ Check if alignment of mem_ref is consistent with the other packs of the same memory slice.\n-  bool is_mem_ref_aligned_with_same_memory_slice(MemNode* mem_ref, int iv_adjustment, Node_List &align_to_refs);\n+  \/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n+  \/\/ mem_ref is aligned with best_align_to_mem_ref.\n+  bool mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                          MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                          Node_List &align_to_refs);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *   Note: CompileCommand Option Vectorize is enabled.\n@@ -31,1 +30,1 @@\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8298935\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8308606\n@@ -94,1 +93,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -103,1 +102,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -112,1 +111,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -123,1 +122,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -134,1 +133,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -145,1 +144,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -156,1 +155,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -167,1 +166,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -178,1 +177,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -189,1 +188,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -200,1 +199,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -211,1 +210,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -222,1 +221,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -233,1 +232,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -244,1 +243,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -255,1 +254,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -266,1 +265,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -277,1 +276,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -288,1 +287,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -299,1 +298,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -310,1 +309,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -321,1 +320,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -332,1 +331,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -343,1 +342,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -354,1 +353,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -365,1 +364,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -376,1 +375,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -386,1 +385,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -396,1 +395,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -406,1 +405,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -416,1 +415,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -426,1 +425,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -436,1 +435,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -446,1 +445,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -456,1 +455,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -466,1 +465,1 @@\n- * @bug 8298935\n+ * @bug 8298935 8308606\n@@ -1265,1 +1264,0 @@\n-                           \"-XX:CompileCommand=option,compiler.loopopts.superword.TestDependencyOffsets::test*,Vectorize\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":37,"deletions":39,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -164,3 +164,5 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    public int[] indexWithDifferentConstants() {\n+    \/\/ No true dependency in read-forward case.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public int[] indexWithDifferentConstantsPos() {\n@@ -174,0 +176,11 @@\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public int[] indexWithDifferentConstantsNeg() {\n+        int[] res = new int[SIZE];\n+        for (int i = 1; i < SIZE \/ 4; i++) {\n+            res[i] = ints[i - 1];\n+        }\n+        return res;\n+    }\n+\n@@ -249,0 +262,1 @@\n+\n@@ -250,3 +264,5 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    public short[] shortArrayWithDependence() {\n+    \/\/ No true dependency in read-forward case.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public short[] shortArrayWithDependencePos() {\n@@ -264,1 +280,15 @@\n-    public char[] charArrayWithDependence() {\n+    public short[] shortArrayWithDependenceNeg() {\n+        short[] res = new short[SIZE];\n+        System.arraycopy(shorts, 0, res, 0, SIZE);\n+        for (int i = 1; i < SIZE \/ 2; i++) {\n+            res[i] *= shorts[i - 1];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ No true dependency in read-forward case.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public char[] charArrayWithDependencePos() {\n@@ -276,1 +306,15 @@\n-    public byte[] byteArrayWithDependence() {\n+    public char[] charArrayWithDependenceNeg() {\n+        char[] res = new char[SIZE];\n+        System.arraycopy(chars, 0, res, 0, SIZE);\n+        for (int i = 2; i < SIZE \/ 2; i++) {\n+            res[i] *= chars[i - 2];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ No true dependency in read-forward case.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public byte[] byteArrayWithDependencePos() {\n@@ -285,0 +329,1 @@\n+\n@@ -288,1 +333,15 @@\n-    public boolean[] booleanArrayWithDependence() {\n+    public byte[] byteArrayWithDependenceNeg() {\n+        byte[] res = new byte[SIZE];\n+        System.arraycopy(bytes, 0, res, 0, SIZE);\n+        for (int i = 3; i < SIZE \/ 2; i++) {\n+            res[i] *= bytes[i - 3];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ No true dependency in read-forward case.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public boolean[] booleanArrayWithDependencePos() {\n@@ -297,0 +356,12 @@\n+    @Test\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public boolean[] booleanArrayWithDependenceNeg() {\n+        boolean[] res = new boolean[SIZE];\n+        System.arraycopy(booleans, 0, res, 0, SIZE);\n+        for (int i = 4; i < SIZE \/ 2; i++) {\n+            res[i] |= booleans[i - 4];\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":80,"deletions":9,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorAlignment {\n+    @Param({\/*\"512\",  \"1024\", *\/  \"2048\"})\n+    public int COUNT;\n+\n+    private int[] aI;\n+    private int[] bI;\n+    private int[] rI;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aI = new int[COUNT];\n+        bI = new int[COUNT];\n+        rI = new int[COUNT];\n+\n+        for (int i = 0; i < COUNT; i++) {\n+            aI[i] = r.nextInt();\n+            bI[i] = r.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Control: should always vectorize with SuperWord\n+    public void bench000_control() {\n+        for (int i = 0; i < COUNT; i++) {\n+            \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+            rI[i] = aI[i] * aI[i] * aI[i] * aI[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Control: should always vectorize with SuperWord\n+    public void bench001_control() {\n+        for (int i = 0; i < COUNT; i++) {\n+            \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+            rI[i] = aI[i] * aI[i] * aI[i] * aI[i] + bI[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes without AlignVector\n+    public void bench100_misaligned_load() {\n+        for (int i = 0; i < COUNT-1; i++) {\n+            rI[i] = aI[i+1] * aI[i+1] * aI[i+1] * aI[i+1];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Only without \"Vectorize\" (confused by hand-unrolling)\n+    public void bench200_hand_unrolled_aligned() {\n+        for (int i = 0; i < COUNT-10; i+=2) {\n+            rI[i+0] = aI[i+0] * aI[i+0] * aI[i+0] * aI[i+0];\n+            rI[i+1] = aI[i+1] * aI[i+1] * aI[i+1] * aI[i+1];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Only with \"Vectorize\", without we get issues with modulo computation of alignment for bI\n+    public void bench300_multiple_misaligned_loads() {\n+        for (int i = 0; i < COUNT-10; i++) {\n+            rI[i] = aI[i] * aI[i] * aI[i] * aI[i] + bI[i+1];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Only with \"Vectorize\", without we may confuse aI[5] with aI[4+1] and pack loads in wrong pack\n+    public void bench301_multiple_misaligned_loads() {\n+        for (int i = 0; i < COUNT-10; i++) {\n+            rI[i] = aI[i] * aI[i] * aI[i] * aI[i] + aI[i+1];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Only with \"Vectorize\", without we get mix of aI[i] and a[i-2]\n+    public void bench302_multiple_misaligned_loads_and_stores() {\n+        for (int i = 2; i < COUNT; i++) {\n+            rI[i - 2] = aI[i-2] * aI[i-2] * aI[i-2] * aI[i-2]; \/\/ can do this for all iterations\n+            rI[i] = aI[i] + 3;                                 \/\/ before doing this second line\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Currently does not vectorize:\n+    \/\/   hand-unrolled confuses Vectorize -> adjacent loads not from same original node (not even same line)\n+    \/\/   multiple unaligned loads confuses non-Vectorize: aI[5+1] confused with aI[4+2] (plus modulo alignment issue)\n+    public void bench400_hand_unrolled_misaligned() {\n+        for (int i = 0; i < COUNT-10; i+=2) {\n+            rI[i+0] = aI[i+1] * aI[i+1] * aI[i+1] * aI[i+1] + aI[i];\n+            rI[i+1] = aI[i+2] * aI[i+2] * aI[i+2] * aI[i+2] + aI[i+1];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Currently does not vectorize:\n+    \/\/   hand-unrolled confuses Vectorize -> adjacent loads not from same original node (not even same line)\n+    \/\/   non-Vectorize: plus modulo alignment issue\n+    public void bench401_hand_unrolled_misaligned() {\n+        for (int i = 0; i < COUNT-10; i+=2) {\n+            rI[i+0] = aI[i+1] * aI[i+1] * aI[i+1] * aI[i+1] + bI[i];\n+            rI[i+1] = aI[i+2] * aI[i+2] * aI[i+2] * aI[i+2] + bI[i+1];\n+        }\n+    }\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:+UseSuperWord\", \"-XX:CompileCommand=Option,*::*,Vectorize\"\n+    })\n+    public static class VectorAlignmentSuperWordWithVectorize extends VectorAlignment {}\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:+UseSuperWord\", \"-XX:+AlignVector\"\n+    })\n+    public static class VectorAlignmentSuperWordAlignVector extends VectorAlignment {}\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorAlignmentSuperWord extends VectorAlignment {}\n+\n+    @Fork(value = 1, jvmArgsPrepend = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorAlignmentNoSuperWord extends VectorAlignment {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAlignment.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}