{"files":[{"patch":"@@ -66,0 +66,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1654,4 +1655,1 @@\n-  if (deoptee_thread != thread) {\n-    \/\/ Process stack of deoptee thread as we will access oops during object deoptimization.\n-    StackWatermarkSet::start_processing(deoptee_thread, StackWatermarkKind::gc);\n-  }\n+  assert(KeepStackGCProcessedMark::stack_is_kept_gc_processed(deoptee_thread), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,16 @@\n+\n+#ifdef ASSERT\n+bool KeepStackGCProcessedMark::stack_is_kept_gc_processed(JavaThread* jt) {\n+  if (!Thread::current()->is_Java_thread()) {\n+    assert(SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread(),\n+           \"must be either Java thread or VM thread in a safepoint\");\n+    return true;\n+  }\n+  StackWatermark* our_watermark = StackWatermarkSet::get(JavaThread::current(), StackWatermarkKind::gc);\n+  if (our_watermark == nullptr) {\n+    return true;\n+  }\n+  StackWatermark* their_watermark = StackWatermarkSet::get(jt, StackWatermarkKind::gc);\n+  return our_watermark->linked_watermark() == their_watermark;\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+\n+  static bool stack_is_kept_gc_processed(JavaThread* jt) NOT_DEBUG({ return true; }) ;\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  DEBUG_ONLY(StackWatermark* linked_watermark() const { return _linked_watermark; })\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}