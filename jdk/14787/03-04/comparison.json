{"files":[{"patch":"@@ -151,1 +151,0 @@\n-        private final boolean failOnMod;\n@@ -165,1 +164,0 @@\n-                                  boolean failOnMod,\n@@ -171,1 +169,0 @@\n-            this.failOnMod = failOnMod;\n@@ -201,4 +198,0 @@\n-        public boolean failOnMod() {\n-            return failOnMod;\n-        }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -187,3 +187,0 @@\n-        new Option<JlinkTask>(false, (task, opt, arg) -> {\n-            task.options.runImageOnlyWarning = true;\n-        }, \"--run-image-only-warnings\"),\n@@ -192,1 +189,1 @@\n-        }, \"--run-image-ignore-single-hop\"),\n+        }, \"--unlock-run-image\"),\n@@ -234,1 +231,0 @@\n-        boolean runImageOnlyWarning = false;\n@@ -406,1 +402,0 @@\n-                                      !options.runImageOnlyWarning,\n@@ -599,1 +594,1 @@\n-                               config.failOnMod(), config.singleHop());\n+                               config.singleHop());\n@@ -870,1 +865,0 @@\n-        final boolean failOnMod;\n@@ -879,1 +873,0 @@\n-                    boolean failOnMod,\n@@ -885,1 +878,0 @@\n-            this.failOnMod = failOnMod;\n@@ -942,1 +934,1 @@\n-                return new JmodLessArchive(module, path, failOnMod, singleHop);\n+                return new RunImageArchive(module, path, singleHop);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,366 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.tools.jlink.internal;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.lang.module.ModuleFinder;\n-import java.lang.module.ModuleReference;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HexFormat;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n-\n-public class JmodLessArchive implements Archive {\n-\n-    private static final String JAVA_BASE_MODULE = \"java.base\";\n-    \/\/ File marker in lib\/modules file for java.base indicating it got created\n-    \/\/ with a run-image-type link.\n-    private static final String JMODLESS_SINGLE_HOP_STAMP = \".runimage.stamp\";\n-    private static final String OTHER_RESOURCES_FILE = \"jmod_resources\";\n-    private final String module;\n-    private final Path path;\n-    private final ModuleReference ref;\n-    private final List<JmodLessFile> files = new ArrayList<>();\n-    private final boolean failOnMod;\n-    private final boolean singleHop;\n-\n-    JmodLessArchive(String module, Path path, boolean failOnMod, boolean singleHop) {\n-        this.module = module;\n-        this.path = path;\n-        this.ref = ModuleFinder.ofSystem()\n-                    .find(module)\n-                    .orElseThrow(() ->\n-                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n-        this.failOnMod = failOnMod;\n-        this.singleHop = singleHop;\n-    }\n-\n-    @Override\n-    public String moduleName() {\n-        return module;\n-    }\n-\n-    @Override\n-    public Path getPath() {\n-        return path;\n-    }\n-\n-    @Override\n-    public Stream<Entry> entries() {\n-        try {\n-            collectFiles();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        } catch (RunImageLinkException e) {\n-            \/\/ populate single-hop issue\n-            throw e.getReason();\n-        }\n-        return files.stream()\n-                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n-                    .map(f -> { return f.toEntry();});\n-    }\n-\n-    @Override\n-    public void open() throws IOException {\n-        if (files.isEmpty()) {\n-            collectFiles();\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        if (!files.isEmpty()) {\n-            files.clear();\n-        }\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(module, path);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj instanceof JmodLessArchive) {\n-            JmodLessArchive other = (JmodLessArchive)obj;\n-            return Objects.equals(module, other.module) &&\n-                   Objects.equals(path, other.path);\n-        }\n-\n-        return false;\n-    }\n-\n-    private void collectFiles() throws IOException {\n-        if (files.isEmpty()) {\n-            addNonClassResources();\n-            \/\/ Add classes\/resources from image module\n-            files.addAll(ref.open().list()\n-                                   .map(s -> {\n-                return new JmodLessFile(JmodLessArchive.this, s,\n-                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, failOnMod);\n-            }).collect(Collectors.toList()));\n-            \/\/ if we use single-hop and we find a stamp file we fail the link\n-            if (files.stream().anyMatch(f -> { return JMODLESS_SINGLE_HOP_STAMP.equals(f.resPath);})) {\n-                String msg = \"Run image links only allow single-hop.\";\n-                IllegalArgumentException ise = new IllegalArgumentException(msg);\n-                throw new RunImageLinkException(ise);\n-            };\n-            \/\/ add\/persist a special, empty file for java.base so as to support\n-            \/\/ the single-hop-only runimage-jlink\n-            if (singleHop && JAVA_BASE_MODULE.equals(module)) {\n-                files.add(createJmodLessSingleHopStamp());\n-            }\n-        }\n-    }\n-\n-    private JmodLessFile createJmodLessSingleHopStamp() {\n-        return new JmodLessStampFile(this, JMODLESS_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, failOnMod);\n-    }\n-\n-    private void addNonClassResources() throws IOException {\n-        Optional<InputStream> jmodsResources = ref.open().open(OTHER_RESOURCES_FILE);\n-        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n-        \/\/ files. In that case the file won't exist in the modules image.\n-        if (jmodsResources.isPresent()) {\n-            try (InputStream inStream = jmodsResources.get()) {\n-                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n-                files.addAll(Arrays.asList(input.split(\"\\n\")).stream()\n-                        .map(s -> {\n-                            TypePathMapping m = mappingResource(s);\n-                            return new JmodLessFile(JmodLessArchive.this, m.resPath, m.resType, m.sha, m.symlink, failOnMod);\n-                        })\n-                        .filter(m -> m != null)\n-                        .collect(Collectors.toList()));\n-            }\n-        }\n-    }\n-\n-    \/**\n-     *  line: <int>|<int>|<sha>|<path>\n-     *\n-     *  Take the integer before '|' convert it to a Type. The second\n-     *  token is an integer representing symlinks (or not). The third token is\n-     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n-     *\/\n-    private static TypePathMapping mappingResource(String line) {\n-        if (line.isEmpty()) {\n-            return null;\n-        }\n-        String[] tokens = line.split(\"\\\\|\", 4);\n-        Type type = null;\n-        int symlinkNum = -1;\n-        try {\n-            Integer typeInt = Integer.valueOf(tokens[0]);\n-            type = Type.fromOrdinal(typeInt);\n-            symlinkNum = Integer.valueOf(tokens[1]);\n-        } catch (NumberFormatException e) {\n-            throw new AssertionError(e); \/\/ must not happen\n-        }\n-        if (symlinkNum < 0 || symlinkNum > 1) {\n-            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n-        }\n-        boolean isSymlink = symlinkNum > 0;\n-        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n-    }\n-\n-    static class TypePathMapping {\n-        final String resPath;\n-        final String sha;\n-        final Type resType;\n-        final boolean symlink;\n-        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n-            this.resPath = resPath;\n-            this.resType = resType;\n-            this.sha = Objects.requireNonNull(sha);\n-            this.symlink = symlink;\n-        }\n-    }\n-\n-    static class JmodLessFile {\n-        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n-        private static final Path BASE = Paths.get(JAVA_HOME);\n-        final String resPath;\n-        final Archive.Entry.EntryType resType;\n-        final Archive archive;\n-        final String sha; \/\/ Checksum for non-resource files\n-        final boolean symlink;\n-        final boolean failOnMod;\n-\n-        JmodLessFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n-            this.resPath = resPath;\n-            this.resType = toEntryType(resType);\n-            this.archive = archive;\n-            this.sha = sha;\n-            this.symlink = symlink;\n-            this.failOnMod = failOnMod;\n-        }\n-\n-        Entry toEntry() {\n-            return new Entry(archive, resPath, resPath, resType) {\n-\n-                private boolean warningProduced = false;\n-\n-                @Override\n-                public long size() {\n-                    try {\n-                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n-                            \/\/ Read from the base JDK image, special casing\n-                            \/\/ symlinks, which have the link target in the sha field\n-                            if (symlink) {\n-                                return Files.size(BASE.resolve(sha));\n-                            }\n-                            return Files.size(BASE.resolve(resPath));\n-                        } else {\n-                            \/\/ Read from the module image. This works, because\n-                            \/\/ the underlying base path is a JrtPath with the\n-                            \/\/ JrtFileSystem underneath which is able to handle\n-                            \/\/ this size query\n-                            return Files.size(archive.getPath().resolve(resPath));\n-                        }\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }\n-\n-                @Override\n-                public InputStream stream() throws IOException {\n-                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n-                        \/\/ Read from the base JDK image.\n-                        Path path = BASE.resolve(resPath);\n-                        if (shaSumMismatch(path, sha, symlink)) {\n-                            String msg = String.format(\"%s has been modified. Please double check!%n\", path.toString());\n-                            if (failOnMod) {\n-                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n-                                throw new RunImageLinkException(ise);\n-                            } else if (!warningProduced) {\n-                                System.err.printf(\"WARNING: %s\", msg);\n-                                warningProduced = true;\n-                            }\n-                        }\n-                        if (symlink) {\n-                            path = BASE.resolve(sha);\n-                            return Files.newInputStream(path);\n-                        }\n-                        return Files.newInputStream(path);\n-                    } else {\n-                        \/\/ Read from the module image.\n-                        String module = archive.moduleName();\n-                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n-                        return mRef.open().open(resPath).orElseThrow();\n-                    }\n-                }\n-\n-                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n-                    if (isSymlink) {\n-                        return false;\n-                    }\n-                    \/\/ handle non-symlink resources\n-                    try {\n-                        HexFormat format = HexFormat.of();\n-                        byte[] expected = format.parseHex(expectedSha);\n-                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n-                        try (InputStream is = Files.newInputStream(res)) {\n-                            byte[] buf = new byte[1024];\n-                            int readBytes = -1;\n-                            while ((readBytes = is.read(buf)) != -1) {\n-                                digest.update(buf, 0, readBytes);\n-                            }\n-                        }\n-                        byte[] actual = digest.digest();\n-                        return !MessageDigest.isEqual(expected, actual);\n-                    } catch (Exception e) {\n-                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n-                    }\n-                }\n-\n-            };\n-        }\n-\n-        private static Archive.Entry.EntryType toEntryType(Type input) {\n-            switch(input) {\n-            case CLASS_OR_RESOURCE:\n-                return Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n-            case CONFIG:\n-                return Archive.Entry.EntryType.CONFIG;\n-            case HEADER_FILE:\n-                return Archive.Entry.EntryType.HEADER_FILE;\n-            case LEGAL_NOTICE:\n-                return Archive.Entry.EntryType.LEGAL_NOTICE;\n-            case MAN_PAGE:\n-                return Archive.Entry.EntryType.MAN_PAGE;\n-            case NATIVE_CMD:\n-                return Archive.Entry.EntryType.NATIVE_CMD;\n-            case NATIVE_LIB:\n-                return Archive.Entry.EntryType.NATIVE_LIB;\n-            case TOP:\n-                throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n-            default:\n-                throw new IllegalArgumentException(\"Unknown type: \" + input);\n-            }\n-        }\n-    }\n-\n-    \/\/ Stamp file marker for single-hop implementation\n-    static class JmodLessStampFile extends JmodLessFile {\n-        JmodLessStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n-            super(archive, resPath, resType, sha, symlink, failOnMod);\n-        }\n-\n-        @Override\n-        Entry toEntry() {\n-            return new Entry(archive, resPath, resPath, resType) {\n-\n-                @Override\n-                public long size() {\n-                    \/\/ empty file\n-                    return 0;\n-                }\n-\n-                @Override\n-                public InputStream stream() throws IOException {\n-                    \/\/ empty content\n-                    return new ByteArrayInputStream(new byte[0]);\n-                }\n-\n-            };\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JmodLessArchive.java","additions":0,"deletions":366,"binary":false,"changes":366,"status":"deleted"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+public class RunImageArchive implements Archive {\n+\n+    private static final String JAVA_BASE_MODULE = \"java.base\";\n+    \/\/ File marker in lib\/modules file for java.base indicating it got created\n+    \/\/ with a run-image-type link.\n+    private static final String RUNIMAGE_SINGLE_HOP_STAMP = \".runimage.stamp\";\n+    private static final String OTHER_RESOURCES_FILE = \"jmod_resources\";\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    private final List<RunImageFile> files = new ArrayList<>();\n+    private final boolean singleHop;\n+\n+    RunImageArchive(String module, Path path, boolean singleHop) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                    .find(module)\n+                    .orElseThrow(() ->\n+                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n+        this.singleHop = singleHop;\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RunImageLinkException e) {\n+            \/\/ populate single-hop issue\n+            throw e.getReason();\n+        }\n+        return files.stream()\n+                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n+                    .map(f -> { return f.toEntry();});\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof RunImageArchive) {\n+            RunImageArchive other = (RunImageArchive)obj;\n+            return Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path);\n+        }\n+\n+        return false;\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module\n+            files.addAll(ref.open().list()\n+                                   .map(s -> {\n+                return new RunImageFile(RunImageArchive.this, s,\n+                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, singleHop);\n+            }).collect(Collectors.toList()));\n+            \/\/ if we use single-hop and we find a stamp file we fail the link\n+            if (files.stream().anyMatch(f -> { return RUNIMAGE_SINGLE_HOP_STAMP.equals(f.resPath);})) {\n+                String msg = \"Recursive links based on the current run-image are not allowed.\";\n+                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                throw new RunImageLinkException(ise);\n+            };\n+            \/\/ add\/persist a special, empty file for java.base so as to support\n+            \/\/ the single-hop-only runimage-jlink\n+            if (singleHop && JAVA_BASE_MODULE.equals(module)) {\n+                files.add(createRunImageSingleHopStamp());\n+            }\n+        }\n+    }\n+\n+    private RunImageFile createRunImageSingleHopStamp() {\n+        return new RunImageStampFile(this, RUNIMAGE_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, singleHop);\n+    }\n+\n+    private void addNonClassResources() throws IOException {\n+        Optional<InputStream> runImageResources = ref.open().open(OTHER_RESOURCES_FILE);\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the file won't exist in the modules image.\n+        if (runImageResources.isPresent()) {\n+            try (InputStream inStream = runImageResources.get()) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                files.addAll(Arrays.asList(input.split(\"\\n\")).stream()\n+                        .map(s -> {\n+                            TypePathMapping m = mappingResource(s);\n+                            return new RunImageFile(RunImageArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n+                        })\n+                        .filter(m -> m != null)\n+                        .collect(Collectors.toList()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     *  line: <int>|<int>|<sha>|<path>\n+     *\n+     *  Take the integer before '|' convert it to a Type. The second\n+     *  token is an integer representing symlinks (or not). The third token is\n+     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+     *\/\n+    private static TypePathMapping mappingResource(String line) {\n+        if (line.isEmpty()) {\n+            return null;\n+        }\n+        String[] tokens = line.split(\"\\\\|\", 4);\n+        Type type = null;\n+        int symlinkNum = -1;\n+        try {\n+            Integer typeInt = Integer.valueOf(tokens[0]);\n+            type = Type.fromOrdinal(typeInt);\n+            symlinkNum = Integer.valueOf(tokens[1]);\n+        } catch (NumberFormatException e) {\n+            throw new AssertionError(e); \/\/ must not happen\n+        }\n+        if (symlinkNum < 0 || symlinkNum > 1) {\n+            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n+        }\n+        boolean isSymlink = symlinkNum > 0;\n+        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n+    }\n+\n+    static class TypePathMapping {\n+        final String resPath;\n+        final String sha;\n+        final Type resType;\n+        final boolean symlink;\n+        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n+            this.resPath = resPath;\n+            this.resType = resType;\n+            this.sha = Objects.requireNonNull(sha);\n+            this.symlink = symlink;\n+        }\n+    }\n+\n+    static class RunImageFile {\n+        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+        private static final Path BASE = Paths.get(JAVA_HOME);\n+        final String resPath;\n+        final Archive.Entry.EntryType resType;\n+        final Archive archive;\n+        final String sha; \/\/ Checksum for non-resource files\n+        final boolean symlink;\n+        final boolean failOnMod; \/\/ Only allow non-failure in multi-hop mode\n+\n+        RunImageFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            this.resPath = resPath;\n+            this.resType = toEntryType(resType);\n+            this.archive = archive;\n+            this.sha = sha;\n+            this.symlink = symlink;\n+            this.failOnMod = failOnMod;\n+        }\n+\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                private boolean warningProduced = false;\n+\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the sha field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(resPath);\n+                        if (shaSumMismatch(path, sha, symlink)) {\n+                            String msg = String.format(\"%s has been modified. Please double check!%n\", path.toString());\n+                            if (failOnMod) {\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RunImageLinkException(ise);\n+                            } else if (!warningProduced) {\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                                warningProduced = true;\n+                            }\n+                        }\n+                        if (symlink) {\n+                            path = BASE.resolve(sha);\n+                            return Files.newInputStream(path);\n+                        }\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image.\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+                    if (isSymlink) {\n+                        return false;\n+                    }\n+                    \/\/ handle non-symlink resources\n+                    try {\n+                        HexFormat format = HexFormat.of();\n+                        byte[] expected = format.parseHex(expectedSha);\n+                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                        try (InputStream is = Files.newInputStream(res)) {\n+                            byte[] buf = new byte[1024];\n+                            int readBytes = -1;\n+                            while ((readBytes = is.read(buf)) != -1) {\n+                                digest.update(buf, 0, readBytes);\n+                            }\n+                        }\n+                        byte[] actual = digest.digest();\n+                        return !MessageDigest.isEqual(expected, actual);\n+                    } catch (Exception e) {\n+                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        private static Archive.Entry.EntryType toEntryType(Type input) {\n+            switch(input) {\n+            case CLASS_OR_RESOURCE:\n+                return Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n+            case CONFIG:\n+                return Archive.Entry.EntryType.CONFIG;\n+            case HEADER_FILE:\n+                return Archive.Entry.EntryType.HEADER_FILE;\n+            case LEGAL_NOTICE:\n+                return Archive.Entry.EntryType.LEGAL_NOTICE;\n+            case MAN_PAGE:\n+                return Archive.Entry.EntryType.MAN_PAGE;\n+            case NATIVE_CMD:\n+                return Archive.Entry.EntryType.NATIVE_CMD;\n+            case NATIVE_LIB:\n+                return Archive.Entry.EntryType.NATIVE_LIB;\n+            case TOP:\n+                throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n+            default:\n+                throw new IllegalArgumentException(\"Unknown type: \" + input);\n+            }\n+        }\n+    }\n+\n+    \/\/ Stamp file marker for single-hop implementation\n+    static class RunImageStampFile extends RunImageFile {\n+        RunImageStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            super(archive, resPath, resType, sha, symlink, failOnMod);\n+        }\n+\n+        @Override\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                @Override\n+                public long size() {\n+                    \/\/ empty file\n+                    return 0;\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    \/\/ empty content\n+                    return new ByteArrayInputStream(new byte[0]);\n+                }\n+\n+            };\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageArchive.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-    \/\/ is being used in JmodLessArchive class\n+    \/\/ is being used in RunImageArchive class\n@@ -167,1 +167,1 @@\n-            \/\/ JmodLessArchive::JmodLessFile.content() may throw this when\n+            \/\/ RunImageArchive::RunImageFile.content() may throw this when\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddJmodResourcesPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,8 +92,2 @@\n-main.opt.run-image-only-warnings=\\\n-\\      --run-image-only-warnings         Only produce a warning for a modified\\n\\\n-\\                                        file taken from the current run-image\\n\\\n-\\                                        in a link using only the JDK run-image.\\n\\\n-\\                                        Default is a fatal error.\n-\n-main.opt.run-image-ignore-single-hop=\\\n-\\      --run-image-ignore-single-hop     Allow for multi-hop run-image based links.\\n\\\n+main.opt.unlock-run-image=\\\n+\\      --unlock-run-image                Allow for multiple run-image-based links.\\n\\\n@@ -103,1 +97,1 @@\n-\\                                        equivalent as it doesn't add a stamp file to\\n\\\n+\\                                        equivalent as it does not add a stamp file to\\n\\\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods, true), true, false, true);\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods, true), true, true);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                .addExtraOption(\"--run-image-ignore-single-hop\")\n+                .addExtraOption(\"--unlock-run-image\")\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                                .extraJlinkOpt(\"--run-image-only-warnings\") \/\/ only generate a warning\n+                                .extraJlinkOpt(\"--unlock-run-image\") \/\/ only generate a warning\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        handler.analyzer().stdoutShouldContain(\"Run image links only allow single-hop.\");\n+        handler.analyzer().stdoutShouldContain(\"Recursive links based on the current run-image are not allowed.\");\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                                                            .addExtraOption(\"--run-image-ignore-single-hop\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                                                            .addExtraOption(\"--run-image-ignore-single-hop\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}