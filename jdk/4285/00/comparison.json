{"files":[{"patch":"@@ -212,19 +212,11 @@\n-        SocketException ex = null;\n-        switch (data[1]) {\n-        case 90:\n-            \/\/ Success!\n-            external_address = endpoint;\n-            break;\n-        case 91:\n-            ex = new SocketException(\"SOCKS request rejected\");\n-            break;\n-        case 92:\n-            ex = new SocketException(\"SOCKS server couldn't reach destination\");\n-            break;\n-        case 93:\n-            ex = new SocketException(\"SOCKS authentication failed\");\n-            break;\n-        default:\n-            ex = new SocketException(\"Reply from SOCKS server contains bad status\");\n-            break;\n-        }\n+        SocketException ex = switch (data[1]) {\n+            case 90 -> {\n+                \/\/ Success!\n+                external_address = endpoint;\n+                yield null;\n+            }\n+            case 91 -> new SocketException(\"SOCKS request rejected\");\n+            case 92 -> new SocketException(\"SOCKS server couldn't reach destination\");\n+            case 93 -> new SocketException(\"SOCKS authentication failed\");\n+            default -> new SocketException(\"Reply from SOCKS server contains bad status\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocksSocketImpl.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -190,27 +190,40 @@\n-            case '+':\n-                sb.append(' ');\n-                i++;\n-                needToChange = true;\n-                break;\n-            case '%':\n-                \/*\n-                 * Starting with this instance of %, process all\n-                 * consecutive substrings of the form %xy. Each\n-                 * substring %xy will yield a byte. Convert all\n-                 * consecutive  bytes obtained this way to whatever\n-                 * character(s) they represent in the provided\n-                 * encoding.\n-                 *\/\n-\n-                try {\n-\n-                    \/\/ (numChars-i)\/3 is an upper bound for the number\n-                    \/\/ of remaining bytes\n-                    if (bytes == null)\n-                        bytes = new byte[(numChars-i)\/3];\n-                    int pos = 0;\n-\n-                    while ( ((i+2) < numChars) &&\n-                            (c=='%')) {\n-                        int v = Integer.parseInt(s, i + 1, i + 3, 16);\n-                        if (v < 0)\n+                case '+' -> {\n+                    sb.append(' ');\n+                    i++;\n+                    needToChange = true;\n+                }\n+                case '%' -> {\n+                    \/*\n+                     * Starting with this instance of %, process all\n+                     * consecutive substrings of the form %xy. Each\n+                     * substring %xy will yield a byte. Convert all\n+                     * consecutive  bytes obtained this way to whatever\n+                     * character(s) they represent in the provided\n+                     * encoding.\n+                     *\/\n+\n+                    try {\n+\n+                        \/\/ (numChars-i)\/3 is an upper bound for the number\n+                        \/\/ of remaining bytes\n+                        if (bytes == null)\n+                            bytes = new byte[(numChars - i) \/ 3];\n+                        int pos = 0;\n+\n+                        while (((i + 2) < numChars) &&\n+                                (c == '%')) {\n+                            int v = Integer.parseInt(s, i + 1, i + 3, 16);\n+                            if (v < 0)\n+                                throw new IllegalArgumentException(\n+                                        \"URLDecoder: Illegal hex characters in escape \"\n+                                                + \"(%) pattern - negative value\");\n+                            bytes[pos++] = (byte) v;\n+                            i += 3;\n+                            if (i < numChars)\n+                                c = s.charAt(i);\n+                        }\n+\n+                        \/\/ A trailing, incomplete byte encoding such as\n+                        \/\/ \"%x\" will cause an exception to be thrown\n+\n+                        if ((i < numChars) && (c == '%'))\n@@ -218,10 +231,1 @@\n-                                    \"URLDecoder: Illegal hex characters in escape \"\n-                                            + \"(%) pattern - negative value\");\n-                        bytes[pos++] = (byte) v;\n-                        i+= 3;\n-                        if (i < numChars)\n-                            c = s.charAt(i);\n-                    }\n-\n-                    \/\/ A trailing, incomplete byte encoding such as\n-                    \/\/ \"%x\" will cause an exception to be thrown\n+                                    \"URLDecoder: Incomplete trailing escape (%) pattern\");\n@@ -229,1 +233,2 @@\n-                    if ((i < numChars) && (c=='%'))\n+                        sb.append(new String(bytes, 0, pos, charset));\n+                    } catch (NumberFormatException e) {\n@@ -231,7 +236,8 @@\n-                         \"URLDecoder: Incomplete trailing escape (%) pattern\");\n-\n-                    sb.append(new String(bytes, 0, pos, charset));\n-                } catch (NumberFormatException e) {\n-                    throw new IllegalArgumentException(\n-                    \"URLDecoder: Illegal hex characters in escape (%) pattern - \"\n-                    + e.getMessage());\n+                                \"URLDecoder: Illegal hex characters in escape (%) pattern - \"\n+                                        + e.getMessage());\n+                    }\n+                    needToChange = true;\n+                }\n+                default -> {\n+                    sb.append(c);\n+                    i++;\n@@ -239,6 +245,0 @@\n-                needToChange = true;\n-                break;\n-            default:\n-                sb.append(c);\n-                i++;\n-                break;\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLDecoder.java","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2806,1 +2806,1 @@\n-                    case ENTRY :\n+                    case ENTRY -> {\n@@ -2814,3 +2814,2 @@\n-                        break;\n-\n-                    case START_DIRECTORY :\n+                    }\n+                    case START_DIRECTORY -> {\n@@ -2823,1 +2822,1 @@\n-                            result == FileVisitResult.SKIP_SIBLINGS)\n+                                result == FileVisitResult.SKIP_SIBLINGS)\n@@ -2825,3 +2824,2 @@\n-                        break;\n-\n-                    case END_DIRECTORY :\n+                    }\n+                    case END_DIRECTORY -> {\n@@ -2833,4 +2831,2 @@\n-                        break;\n-\n-                    default :\n-                        throw new AssertionError(\"Should not get here\");\n+                    }\n+                    default -> throw new AssertionError(\"Should not get here\");\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -235,16 +235,8 @@\n-                case DAYS:\n-                    secs = scale(value, SECONDS_PER_DAY,\n-                                 Long.MAX_VALUE\/SECONDS_PER_DAY);\n-                    break;\n-                case HOURS:\n-                    secs = scale(value, SECONDS_PER_HOUR,\n-                                 Long.MAX_VALUE\/SECONDS_PER_HOUR);\n-                    break;\n-                case MINUTES:\n-                    secs = scale(value, SECONDS_PER_MINUTE,\n-                                 Long.MAX_VALUE\/SECONDS_PER_MINUTE);\n-                    break;\n-                case SECONDS:\n-                    secs = value;\n-                    break;\n-                case MILLISECONDS:\n+                case DAYS    -> secs = scale(value, SECONDS_PER_DAY,\n+                        Long.MAX_VALUE \/ SECONDS_PER_DAY);\n+                case HOURS   -> secs = scale(value, SECONDS_PER_HOUR,\n+                        Long.MAX_VALUE \/ SECONDS_PER_HOUR);\n+                case MINUTES -> secs = scale(value, SECONDS_PER_MINUTE,\n+                        Long.MAX_VALUE \/ SECONDS_PER_MINUTE);\n+                case SECONDS -> secs = value;\n+                case MILLISECONDS -> {\n@@ -252,1 +244,1 @@\n-                    nanos = (int)Math.floorMod(value, MILLIS_PER_SECOND)\n+                    nanos = (int) Math.floorMod(value, MILLIS_PER_SECOND)\n@@ -254,2 +246,2 @@\n-                    break;\n-                case MICROSECONDS:\n+                }\n+                case MICROSECONDS -> {\n@@ -257,1 +249,1 @@\n-                    nanos = (int)Math.floorMod(value, MICROS_PER_SECOND)\n+                    nanos = (int) Math.floorMod(value, MICROS_PER_SECOND)\n@@ -259,2 +251,2 @@\n-                    break;\n-                case NANOSECONDS:\n+                }\n+                case NANOSECONDS  -> {\n@@ -262,3 +254,3 @@\n-                    nanos = (int)Math.floorMod(value, NANOS_PER_SECOND);\n-                    break;\n-                default : throw new AssertionError(\"Unit not handled\");\n+                    nanos = (int) Math.floorMod(value, NANOS_PER_SECOND);\n+                }\n+                default -> throw new AssertionError(\"Unit not handled\");\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/attribute\/FileTime.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"}]}