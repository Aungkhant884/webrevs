{"files":[{"patch":"@@ -190,40 +190,27 @@\n-                case '+' -> {\n-                    sb.append(' ');\n-                    i++;\n-                    needToChange = true;\n-                }\n-                case '%' -> {\n-                    \/*\n-                     * Starting with this instance of %, process all\n-                     * consecutive substrings of the form %xy. Each\n-                     * substring %xy will yield a byte. Convert all\n-                     * consecutive  bytes obtained this way to whatever\n-                     * character(s) they represent in the provided\n-                     * encoding.\n-                     *\/\n-\n-                    try {\n-\n-                        \/\/ (numChars-i)\/3 is an upper bound for the number\n-                        \/\/ of remaining bytes\n-                        if (bytes == null)\n-                            bytes = new byte[(numChars - i) \/ 3];\n-                        int pos = 0;\n-\n-                        while (((i + 2) < numChars) &&\n-                                (c == '%')) {\n-                            int v = Integer.parseInt(s, i + 1, i + 3, 16);\n-                            if (v < 0)\n-                                throw new IllegalArgumentException(\n-                                        \"URLDecoder: Illegal hex characters in escape \"\n-                                                + \"(%) pattern - negative value\");\n-                            bytes[pos++] = (byte) v;\n-                            i += 3;\n-                            if (i < numChars)\n-                                c = s.charAt(i);\n-                        }\n-\n-                        \/\/ A trailing, incomplete byte encoding such as\n-                        \/\/ \"%x\" will cause an exception to be thrown\n-\n-                        if ((i < numChars) && (c == '%'))\n+            case '+':\n+                sb.append(' ');\n+                i++;\n+                needToChange = true;\n+                break;\n+            case '%':\n+                \/*\n+                 * Starting with this instance of %, process all\n+                 * consecutive substrings of the form %xy. Each\n+                 * substring %xy will yield a byte. Convert all\n+                 * consecutive  bytes obtained this way to whatever\n+                 * character(s) they represent in the provided\n+                 * encoding.\n+                 *\/\n+\n+                try {\n+\n+                    \/\/ (numChars-i)\/3 is an upper bound for the number\n+                    \/\/ of remaining bytes\n+                    if (bytes == null)\n+                        bytes = new byte[(numChars-i)\/3];\n+                    int pos = 0;\n+\n+                    while ( ((i+2) < numChars) &&\n+                            (c=='%')) {\n+                        int v = Integer.parseInt(s, i + 1, i + 3, 16);\n+                        if (v < 0)\n@@ -231,1 +218,10 @@\n-                                    \"URLDecoder: Incomplete trailing escape (%) pattern\");\n+                                    \"URLDecoder: Illegal hex characters in escape \"\n+                                            + \"(%) pattern - negative value\");\n+                        bytes[pos++] = (byte) v;\n+                        i+= 3;\n+                        if (i < numChars)\n+                            c = s.charAt(i);\n+                    }\n+\n+                    \/\/ A trailing, incomplete byte encoding such as\n+                    \/\/ \"%x\" will cause an exception to be thrown\n@@ -233,2 +229,1 @@\n-                        sb.append(new String(bytes, 0, pos, charset));\n-                    } catch (NumberFormatException e) {\n+                    if ((i < numChars) && (c=='%'))\n@@ -236,8 +231,7 @@\n-                                \"URLDecoder: Illegal hex characters in escape (%) pattern - \"\n-                                        + e.getMessage());\n-                    }\n-                    needToChange = true;\n-                }\n-                default -> {\n-                    sb.append(c);\n-                    i++;\n+                         \"URLDecoder: Incomplete trailing escape (%) pattern\");\n+\n+                    sb.append(new String(bytes, 0, pos, charset));\n+                } catch (NumberFormatException e) {\n+                    throw new IllegalArgumentException(\n+                    \"URLDecoder: Illegal hex characters in escape (%) pattern - \"\n+                    + e.getMessage());\n@@ -245,0 +239,6 @@\n+                needToChange = true;\n+                break;\n+            default:\n+                sb.append(c);\n+                i++;\n+                break;\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLDecoder.java","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-                        Long.MAX_VALUE \/ SECONDS_PER_DAY);\n+                                             Long.MAX_VALUE \/ SECONDS_PER_DAY);\n@@ -238,1 +238,1 @@\n-                        Long.MAX_VALUE \/ SECONDS_PER_HOUR);\n+                                             Long.MAX_VALUE \/ SECONDS_PER_HOUR);\n@@ -240,1 +240,1 @@\n-                        Long.MAX_VALUE \/ SECONDS_PER_MINUTE);\n+                                             Long.MAX_VALUE \/ SECONDS_PER_MINUTE);\n@@ -242,0 +242,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/attribute\/FileTime.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}