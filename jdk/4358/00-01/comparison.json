{"files":[{"patch":"@@ -1846,63 +1846,0 @@\n-source %{\n-\n-static Assembler::SIMD_Arrangement elemBytes_to_Arrangement(int esize, bool isX) {\n-  switch(esize) {\n-    case 1:\n-      return isX ? Assembler::T16B : Assembler::T8B;\n-    case 2:\n-      return isX ? Assembler::T8H : Assembler::T4H;\n-    case 4:\n-      return isX ? Assembler::T4S : Assembler::T2S;\n-    case 8:\n-      assert(isX, \"unsupported\");\n-      return Assembler::T2D;\n-    default:\n-      assert(false, \"unsupported\");\n-      ShouldNotReachHere();\n-  }\n-  return Assembler::INVALID_ARRANGEMENT;\n-}\n-\n-static void neon_compare(C2_MacroAssembler masm, FloatRegister dst, BasicType bt,\n-                         FloatRegister src1, FloatRegister src2, int cond, bool isX) {\n-  Assembler::SIMD_Arrangement size = elemBytes_to_Arrangement(type2aelembytes(bt), isX);\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: masm.fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        masm.fcmeq(dst, size, src1, src2);\n-        masm.notr(dst, Assembler::T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: masm.fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: masm.fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: masm.fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: masm.fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  } else {\n-    switch (cond) {\n-      case BoolTest::eq: masm.cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        masm.cmeq(dst, size, src1, src2);\n-        masm.notr(dst, Assembler::T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: masm.cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: masm.cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: masm.cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: masm.cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: masm.cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: masm.cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: masm.cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: masm.cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  }\n-}\n-%}\n-\n@@ -1917,2 +1854,3 @@\n-    neon_compare(C2_MacroAssembler(&cbuf), as_FloatRegister($dst$$reg), bt,\n-                 as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isX*\/ false);\n+    assert(type2aelembytes(bt) != 8, \"not supported\");\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n@@ -1931,2 +1869,2 @@\n-    neon_compare(C2_MacroAssembler(&cbuf), as_FloatRegister($dst$$reg), bt,\n-                 as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isX*\/ true);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":5,"deletions":67,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -868,63 +868,0 @@\n-source %{\n-\n-static Assembler::SIMD_Arrangement elemBytes_to_Arrangement(int esize, bool isX) {\n-  switch(esize) {\n-    case 1:\n-      return isX ? Assembler::T16B : Assembler::T8B;\n-    case 2:\n-      return isX ? Assembler::T8H : Assembler::T4H;\n-    case 4:\n-      return isX ? Assembler::T4S : Assembler::T2S;\n-    case 8:\n-      assert(isX, \"unsupported\");\n-      return Assembler::T2D;\n-    default:\n-      assert(false, \"unsupported\");\n-      ShouldNotReachHere();\n-  }\n-  return Assembler::INVALID_ARRANGEMENT;\n-}\n-\n-static void neon_compare(C2_MacroAssembler masm, FloatRegister dst, BasicType bt,\n-                         FloatRegister src1, FloatRegister src2, int cond, bool isX) {\n-  Assembler::SIMD_Arrangement size = elemBytes_to_Arrangement(type2aelembytes(bt), isX);\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: masm.fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        masm.fcmeq(dst, size, src1, src2);\n-        masm.notr(dst, Assembler::T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: masm.fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: masm.fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: masm.fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: masm.fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  } else {\n-    switch (cond) {\n-      case BoolTest::eq: masm.cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        masm.cmeq(dst, size, src1, src2);\n-        masm.notr(dst, Assembler::T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: masm.cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: masm.cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: masm.cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: masm.cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: masm.cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: masm.cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: masm.cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: masm.cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  }\n-}\n-%}\n-\n@@ -939,2 +876,3 @@\n-    neon_compare(C2_MacroAssembler(&cbuf), as_FloatRegister($dst$$reg), bt,\n-                 as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isX*\/ false);\n+    assert(type2aelembytes(bt) != 8, \"not supported\");\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n@@ -953,2 +891,2 @@\n-    neon_compare(C2_MacroAssembler(&cbuf), as_FloatRegister($dst$$reg), bt,\n-                 as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isX*\/ true);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":5,"deletions":67,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -5342,0 +5342,60 @@\n+Assembler::SIMD_Arrangement elemBytes_to_Arrangement(int esize, bool isQ) {\n+  switch(esize) {\n+    case 1:\n+      return isQ ? Assembler::T16B : Assembler::T8B;\n+    case 2:\n+      return isQ ? Assembler::T8H : Assembler::T4H;\n+    case 4:\n+      return isQ ? Assembler::T4S : Assembler::T2S;\n+    case 8:\n+      return isQ ? Assembler::T2D : Assembler::T1D;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+  return Assembler::INVALID_ARRANGEMENT;\n+}\n+\n+void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                  FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = elemBytes_to_Arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1060,0 +1060,3 @@\n+\n+  \/\/ SIMD&FP comparison\n+  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1, FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}