{"files":[{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1924,1 +1924,1 @@\n-  if (C->output()->need_stack_bang(bangsize) && UseStackBanging)\n+  if (C->output()->need_stack_bang(bangsize))\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1502,5 +1502,1 @@\n-  if (UseStackBanging) {\n-    __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n-  } else {\n-    Unimplemented();\n-  }\n+  __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n@@ -2416,4 +2412,2 @@\n-  if (UseStackBanging) {\n-    __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(r19, r2);\n-  }\n+  __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(r19, r2);\n@@ -2633,6 +2627,4 @@\n-  if (UseStackBanging) {\n-    __ ldrw(r1, Address(r4,\n-                        Deoptimization::UnrollBlock::\n-                        total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(r1, r2);\n-  }\n+  __ ldrw(r1, Address(r4,\n+                      Deoptimization::UnrollBlock::\n+                      total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(r1, r2);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,8 +1124,6 @@\n-  if (UseStackBanging) {\n-    const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size());\n-    const int start_page = native_call ? n_shadow_pages : 1;\n-    const int page_size = os::vm_page_size();\n-    for (int pages = start_page; pages <= n_shadow_pages ; pages++) {\n-      __ sub(rscratch2, sp, pages*page_size);\n-      __ str(zr, Address(rscratch2));\n-    }\n+  const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size());\n+  const int start_page = native_call ? n_shadow_pages : 1;\n+  const int page_size = os::vm_page_size();\n+  for (int pages = start_page; pages <= n_shadow_pages ; pages++) {\n+    __ sub(rscratch2, sp, pages*page_size);\n+    __ str(zr, Address(rscratch2));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -980,2 +980,1 @@\n-  if (UseStackBanging) {\n-    const int page_size = os::vm_page_size();\n+  const int page_size = os::vm_page_size();\n@@ -983,5 +982,4 @@\n-    sub_slow(tmp, SP, StackOverflow::stack_shadow_zone_size());\n-    strb(R0, Address(tmp));\n-    for (; frame_size_in_bytes >= page_size; frame_size_in_bytes -= 0xff0) {\n-      strb(R0, Address(tmp, -0xff0, pre_indexed));\n-    }\n+  sub_slow(tmp, SP, StackOverflow::stack_shadow_zone_size());\n+  strb(R0, Address(tmp));\n+  for (; frame_size_in_bytes >= page_size; frame_size_in_bytes -= 0xff0) {\n+    strb(R0, Address(tmp, -0xff0, pre_indexed));\n@@ -992,2 +990,1 @@\n-  if (UseStackBanging) {\n-    Label loop;\n+  Label loop;\n@@ -995,7 +992,6 @@\n-    mov(tmp, SP);\n-    add_slow(Rsize, Rsize, StackOverflow::stack_shadow_zone_size() - os::vm_page_size());\n-    bind(loop);\n-    subs(Rsize, Rsize, 0xff0);\n-    strb(R0, Address(tmp, -0xff0, pre_indexed));\n-    b(loop, hi);\n-  }\n+  mov(tmp, SP);\n+  add_slow(Rsize, Rsize, StackOverflow::stack_shadow_zone_size() - os::vm_page_size());\n+  bind(loop);\n+  subs(Rsize, Rsize, 0xff0);\n+  strb(R0, Address(tmp, -0xff0, pre_indexed));\n+  b(loop, hi);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1507,12 +1507,11 @@\n-  \/\/ See if it is enough stack to push deoptimized frames\n-  if (UseStackBanging) {\n-    \/\/ The compiled method that we are deoptimizing was popped from the stack.\n-    \/\/ If the stack bang results in a stack overflow, we don't return to the\n-    \/\/ method that is being deoptimized. The stack overflow exception is\n-    \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n-    \/\/ from the caller in LR and restore FP.\n-    __ ldr(LR, Address(R2, 0));\n-    __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n-    __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ arm_stack_overflow_check(R8, Rtemp);\n-  }\n+  \/\/ See if it is enough stack to push deoptimized frames.\n+  \/\/\n+  \/\/ The compiled method that we are deoptimizing was popped from the stack.\n+  \/\/ If the stack bang results in a stack overflow, we don't return to the\n+  \/\/ method that is being deoptimized. The stack overflow exception is\n+  \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n+  \/\/ from the caller in LR and restore FP.\n+  __ ldr(LR, Address(R2, 0));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ arm_stack_overflow_check(R8, Rtemp);\n@@ -1703,1 +1702,1 @@\n-  \/\/ See if it is enough stack to push deoptimized frames\n+  \/\/ See if it is enough stack to push deoptimized frames.\n@@ -1708,11 +1707,10 @@\n-  if (UseStackBanging) {\n-    \/\/ The compiled method that we are deoptimizing was popped from the stack.\n-    \/\/ If the stack bang results in a stack overflow, we don't return to the\n-    \/\/ method that is being deoptimized. The stack overflow exception is\n-    \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n-    \/\/ from the caller in LR and restore FP.\n-    __ ldr(LR, Address(R2, 0));\n-    __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n-    __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ arm_stack_overflow_check(R8, Rtemp);\n-  }\n+  \/\/\n+  \/\/ The compiled method that we are deoptimizing was popped from the stack.\n+  \/\/ If the stack bang results in a stack overflow, we don't return to the\n+  \/\/ method that is being deoptimized. The stack overflow exception is\n+  \/\/ propagated to the caller of the deoptimized method. Need to get the pc\n+  \/\/ from the caller in LR and restore FP.\n+  __ ldr(LR, Address(R2, 0));\n+  __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));\n+  __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ arm_stack_overflow_check(R8, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1433,1 +1433,1 @@\n-  if (C->output()->need_stack_bang(bangsize) && UseStackBanging) {\n+  if (C->output()->need_stack_bang(bangsize)) {\n@@ -1487,1 +1487,1 @@\n-  } \/\/ C->output()->need_stack_bang(framesize) && UseStackBanging\n+  } \/\/ C->output()->need_stack_bang(framesize)\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,8 +1188,6 @@\n-  if (UseStackBanging) {\n-    const int page_size = os::vm_page_size();\n-    const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n-    const int start_page = native_call ? n_shadow_pages : 1;\n-    BLOCK_COMMENT(\"bang_stack_shadow_pages:\");\n-    for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n-      __ bang_stack_with_offset(pages*page_size);\n-    }\n+  const int page_size = os::vm_page_size();\n+  const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n+  const int start_page = native_call ? n_shadow_pages : 1;\n+  BLOCK_COMMENT(\"bang_stack_shadow_pages:\");\n+  for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n+    __ bang_stack_with_offset(pages*page_size);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -865,1 +865,1 @@\n-  if (C->output()->need_stack_bang(bangsize) && UseStackBanging) {\n+  if (C->output()->need_stack_bang(bangsize)) {\n@@ -906,1 +906,1 @@\n-  if (C->output()->need_stack_bang(bangsize) && UseStackBanging) {\n+  if (C->output()->need_stack_bang(bangsize)) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2069,7 +2069,5 @@\n-  if (UseStackBanging) {\n-    const int page_size      = os::vm_page_size();\n-    const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size()\/page_size);\n-    const int start_page_num = native_call ? n_shadow_pages : 1;\n-    for (int pages = start_page_num; pages <= n_shadow_pages; pages++) {\n-      __ bang_stack_with_offset(pages*page_size);\n-    }\n+  const int page_size      = os::vm_page_size();\n+  const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size()\/page_size);\n+  const int start_page_num = native_call ? n_shadow_pages : 1;\n+  for (int pages = start_page_num; pages <= n_shadow_pages; pages++) {\n+    __ bang_stack_with_offset(pages*page_size);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-  if (C1Breakpoint || VerifyFPU || !UseStackBanging) {\n+  if (C1Breakpoint || VerifyFPU) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1599,7 +1599,1 @@\n-\n-  if (UseStackBanging) {\n-    __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n-  } else {\n-    \/\/ need a 5 byte instruction to allow MT safe patching to non-entrant\n-    __ fat_nop();\n-  }\n+  __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n@@ -2432,4 +2426,2 @@\n-  if (UseStackBanging) {\n-    __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(rbx, rcx);\n-  }\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(rbx, rcx);\n@@ -2658,4 +2650,2 @@\n-  if (UseStackBanging) {\n-    __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(rbx, rcx);\n-  }\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(rbx, rcx);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1961,7 +1961,1 @@\n-\n-  if (UseStackBanging) {\n-    __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n-  } else {\n-    \/\/ need a 5 byte instruction to allow MT safe patching to non-entrant\n-    __ fat_nop();\n-  }\n+  __ bang_stack_with_offset((int)StackOverflow::stack_shadow_zone_size());\n@@ -2877,4 +2871,2 @@\n-  if (UseStackBanging) {\n-    __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(rbx, rcx);\n-  }\n+  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(rbx, rcx);\n@@ -3080,4 +3072,2 @@\n-  if (UseStackBanging) {\n-    __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n-    __ bang_stack_size(rbx, rcx);\n-  }\n+  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));\n+  __ bang_stack_size(rbx, rcx);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -774,7 +774,5 @@\n-  if (UseStackBanging) {\n-    const int page_size = os::vm_page_size();\n-    const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n-    const int start_page = native_call ? n_shadow_pages : 1;\n-    for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n-      __ bang_stack_with_offset(pages*page_size);\n-    }\n+  const int page_size = os::vm_page_size();\n+  const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n+  const int start_page = native_call ? n_shadow_pages : 1;\n+  for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n+    __ bang_stack_with_offset(pages*page_size);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,30 +124,28 @@\n-  if (UseStackBanging) {\n-    \/\/ Each code entry causes one stack bang n pages down the stack where n\n-    \/\/ is configurable by StackShadowPages.  The setting depends on the maximum\n-    \/\/ depth of VM call stack or native before going back into java code,\n-    \/\/ since only java code can raise a stack overflow exception using the\n-    \/\/ stack banging mechanism.  The VM and native code does not detect stack\n-    \/\/ overflow.\n-    \/\/ The code in JavaCalls::call() checks that there is at least n pages\n-    \/\/ available, so all entry code needs to do is bang once for the end of\n-    \/\/ this shadow zone.\n-    \/\/ The entry code may need to bang additional pages if the framesize\n-    \/\/ is greater than a page.\n-\n-    const int page_size = os::vm_page_size();\n-    int bang_end = (int)StackOverflow::stack_shadow_zone_size();\n-\n-    \/\/ This is how far the previous frame's stack banging extended.\n-    const int bang_end_safe = bang_end;\n-\n-    if (frame_size_in_bytes > page_size) {\n-      bang_end += frame_size_in_bytes;\n-    }\n-\n-    int bang_offset = bang_end_safe;\n-    while (bang_offset <= bang_end) {\n-      \/\/ Need at least one stack bang at end of shadow zone.\n-      bang_stack_with_offset(bang_offset);\n-      bang_offset += page_size;\n-    }\n-  } \/\/ end (UseStackBanging)\n+  \/\/ Each code entry causes one stack bang n pages down the stack where n\n+  \/\/ is configurable by StackShadowPages.  The setting depends on the maximum\n+  \/\/ depth of VM call stack or native before going back into java code,\n+  \/\/ since only java code can raise a stack overflow exception using the\n+  \/\/ stack banging mechanism.  The VM and native code does not detect stack\n+  \/\/ overflow.\n+  \/\/ The code in JavaCalls::call() checks that there is at least n pages\n+  \/\/ available, so all entry code needs to do is bang once for the end of\n+  \/\/ this shadow zone.\n+  \/\/ The entry code may need to bang additional pages if the framesize\n+  \/\/ is greater than a page.\n+\n+  const int page_size = os::vm_page_size();\n+  int bang_end = (int)StackOverflow::stack_shadow_zone_size();\n+\n+  \/\/ This is how far the previous frame's stack banging extended.\n+  const int bang_end_safe = bang_end;\n+\n+  if (frame_size_in_bytes > page_size) {\n+    bang_end += frame_size_in_bytes;\n+  }\n+\n+  int bang_offset = bang_end_safe;\n+  while (bang_offset <= bang_end) {\n+    \/\/ Need at least one stack bang at end of shadow zone.\n+    bang_stack_with_offset(bang_offset);\n+    bang_offset += page_size;\n+  }\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  do_bool_flag(UseStackBanging)                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -443,1 +443,1 @@\n-  return (UseStackBanging && C->stub_function() == NULL &&\n+  return (C->stub_function() == NULL &&\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -976,5 +976,0 @@\n-  develop(bool, UseStackBanging, true,                                      \\\n-          \"use stack banging for stack overflow checks (required for \"      \\\n-          \"proper StackOverflow handling; disable only to measure cost \"    \\\n-          \"of stackbanging)\")                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,1 +256,0 @@\n-    public final boolean useStackBanging = getFlag(\"UseStackBanging\", Boolean.class);\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,33 +133,31 @@\n-        if (config.useStackBanging) {\n-            \/\/ Each code entry causes one stack bang n pages down the stack where n\n-            \/\/ is configurable by StackShadowPages. The setting depends on the maximum\n-            \/\/ depth of VM call stack or native before going back into java code,\n-            \/\/ since only java code can raise a stack overflow exception using the\n-            \/\/ stack banging mechanism. The VM and native code does not detect stack\n-            \/\/ overflow.\n-            \/\/ The code in JavaCalls::call() checks that there is at least n pages\n-            \/\/ available, so all entry code needs to do is bang once for the end of\n-            \/\/ this shadow zone.\n-            \/\/ The entry code may need to bang additional pages if the framesize\n-            \/\/ is greater than a page.\n-\n-            int pageSize = config.vmPageSize;\n-            int bangEnd = NumUtil.roundUp(config.stackShadowPages * 4 * K, pageSize);\n-\n-            \/\/ This is how far the previous frame's stack banging extended.\n-            int bangEndSafe = bangEnd;\n-\n-            int frameSize = Math.max(crb.frameMap.frameSize(), crb.compilationResult.getMaxInterpreterFrameSize());\n-            if (frameSize > pageSize) {\n-                bangEnd += frameSize;\n-            }\n-\n-            int bangOffset = bangEndSafe;\n-            if (bangOffset <= bangEnd) {\n-                crb.blockComment(\"[stack overflow check]\");\n-            }\n-            while (bangOffset <= bangEnd) {\n-                \/\/ Need at least one stack bang at end of shadow zone.\n-                bangStackWithOffset(crb, bangOffset);\n-                bangOffset += pageSize;\n-            }\n+        \/\/ Each code entry causes one stack bang n pages down the stack where n\n+        \/\/ is configurable by StackShadowPages. The setting depends on the maximum\n+        \/\/ depth of VM call stack or native before going back into java code,\n+        \/\/ since only java code can raise a stack overflow exception using the\n+        \/\/ stack banging mechanism. The VM and native code does not detect stack\n+        \/\/ overflow.\n+        \/\/ The code in JavaCalls::call() checks that there is at least n pages\n+        \/\/ available, so all entry code needs to do is bang once for the end of\n+        \/\/ this shadow zone.\n+        \/\/ The entry code may need to bang additional pages if the framesize\n+        \/\/ is greater than a page.\n+\n+        int pageSize = config.vmPageSize;\n+        int bangEnd = NumUtil.roundUp(config.stackShadowPages * 4 * K, pageSize);\n+\n+        \/\/ This is how far the previous frame's stack banging extended.\n+        int bangEndSafe = bangEnd;\n+\n+        int frameSize = Math.max(crb.frameMap.frameSize(), crb.compilationResult.getMaxInterpreterFrameSize());\n+        if (frameSize > pageSize) {\n+            bangEnd += frameSize;\n+        }\n+\n+        int bangOffset = bangEndSafe;\n+        if (bangOffset <= bangEnd) {\n+            crb.blockComment(\"[stack overflow check]\");\n+        }\n+        while (bangOffset <= bangEnd) {\n+            \/\/ Need at least one stack bang at end of shadow zone.\n+            bangStackWithOffset(crb, bangOffset);\n+            bangOffset += pageSize;\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/HotSpotHostBackend.java","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"}]}