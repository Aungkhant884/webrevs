{"files":[{"patch":"@@ -463,1 +463,1 @@\n-  Label IsInflated, DONE_LABEL;\n+  Label IsInflated, DONE_LABEL, NO_COUNT, COUNT;\n@@ -491,1 +491,1 @@\n-    jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n+    jcc(Assembler::equal, COUNT);           \/\/ Success\n@@ -547,1 +547,1 @@\n-  jccb  (Assembler::notZero, DONE_LABEL);\n+  jccb  (Assembler::notZero, NO_COUNT);\n@@ -570,1 +570,1 @@\n-  jcc(Assembler::equal, DONE_LABEL);           \/\/ CAS above succeeded; propagate ZF = 1 (success)\n+  jccb(Assembler::equal, COUNT);          \/\/ CAS above succeeded; propagate ZF = 1 (success)\n@@ -572,2 +572,2 @@\n-  cmpptr(r15_thread, rax);                     \/\/ Check if we are already the owner (recursive lock)\n-  jcc(Assembler::notEqual, DONE_LABEL);        \/\/ If not recursive, ZF = 0 at this point (fail)\n+  cmpptr(r15_thread, rax);                \/\/ Check if we are already the owner (recursive lock)\n+  jccb(Assembler::notEqual, NO_COUNT);    \/\/ If not recursive, ZF = 0 at this point (fail)\n@@ -587,1 +587,18 @@\n-  \/\/ At DONE_LABEL the icc ZFlag is set as follows ...\n+  \/\/ ZFlag == 1 count in fast path\n+  \/\/ ZFlag == 0 count in slow path\n+  jccb(Assembler::notZero, NO_COUNT); \/\/ jump if ZFlag == 0\n+\n+  bind(COUNT);\n+  \/\/ Count monitors in fast path\n+#ifndef _LP64\n+  get_thread(tmpReg);\n+  incrementl(Address(tmpReg, JavaThread::held_monitor_count_offset()));\n+#else \/\/ _LP64\n+  incrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+#endif\n+\n+  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n+\n+  bind(NO_COUNT);\n+\n+  \/\/ At NO_COUNT the icc ZFlag is set as follows ...\n@@ -629,1 +646,1 @@\n-  Label DONE_LABEL, Stacked, CheckSucc;\n+  Label DONE_LABEL, Stacked, CheckSucc, COUNT, NO_COUNT;\n@@ -647,1 +664,1 @@\n-    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+    jcc   (Assembler::zero, COUNT);                                   \/\/ 0 indicates recursive stack-lock\n@@ -649,1 +666,1 @@\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Examine the object's markword\n+  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));   \/\/ Examine the object's markword\n@@ -652,1 +669,1 @@\n-    jccb  (Assembler::zero, Stacked);\n+    jccb   (Assembler::zero, Stacked);\n@@ -803,0 +820,17 @@\n+\n+  \/\/ ZFlag == 1 count in fast path\n+  \/\/ ZFlag == 0 count in slow path\n+  jccb(Assembler::notZero, NO_COUNT);\n+\n+  bind(COUNT);\n+  \/\/ Count monitors in fast path\n+#ifndef _LP64\n+  get_thread(tmpReg);\n+  decrementl(Address(tmpReg, JavaThread::held_monitor_count_offset()));\n+#else \/\/ _LP64\n+  decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+#endif\n+\n+  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n+\n+  bind(NO_COUNT);\n@@ -1994,0 +2028,33 @@\n+void C2_MacroAssembler::vmovmask(BasicType elem_bt, XMMRegister dst, Address src, XMMRegister mask,\n+                                 int vec_enc) {\n+  switch(elem_bt) {\n+    case T_INT:\n+    case T_FLOAT:\n+      vmaskmovps(dst, src, mask, vec_enc);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmaskmovpd(dst, src, mask, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vmovmask(BasicType elem_bt, Address dst, XMMRegister src, XMMRegister mask,\n+                                 int vec_enc) {\n+  switch(elem_bt) {\n+    case T_INT:\n+    case T_FLOAT:\n+      vmaskmovps(dst, src, mask, vec_enc);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmaskmovpd(dst, src, mask, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n@@ -4186,0 +4253,22 @@\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(\n+                                                             XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                             Register scratch, AddressLiteral double_sign_flip,\n+                                                             int vec_enc) {\n+  Label done;\n+  evmovdquq(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  Assembler::evpcmpeqq(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmpps(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmpps(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4246,0 +4335,29 @@\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  evcvttps2qq(dst, src, vec_enc);\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                            AddressLiteral double_sign_flip, Register scratch, int vec_enc) {\n+  vector_castD2L_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, double_sign_flip, scratch, vec_enc);\n+  if (to_elem_bt != T_LONG) {\n+    switch(to_elem_bt) {\n+      case T_INT:\n+        evpmovsqd(dst, dst, vec_enc);\n+        break;\n+      case T_SHORT:\n+        evpmovsqd(dst, dst, vec_enc);\n+        evpmovdw(dst, dst, vec_enc);\n+        break;\n+      case T_BYTE:\n+        evpmovsqd(dst, dst, vec_enc);\n+        evpmovdb(dst, dst, vec_enc);\n+        break;\n+      default: assert(false, \"%s\", type2name(to_elem_bt));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":129,"deletions":11,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -377,2 +377,4 @@\n-      \/\/ Map the maximal common vector\n-      if (VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n+      \/\/ Map the maximal common vector except conversion nodes, because we can't get\n+      \/\/ the precise basic type for conversion nodes in the stage of early analysis.\n+      if (!VectorNode::is_convert_opcode(n->Opcode()) &&\n+          VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n@@ -1008,0 +1010,6 @@\n+  \/\/ Check for special case where there is a type conversion between different data size.\n+  int vectsize = max_vector_size_in_def_use_chain(s);\n+  if (vectsize < max_vector_size(btype)) {\n+    vw = MIN2(vectsize * type2aelembytes(btype), vw);\n+  }\n+\n@@ -1196,1 +1204,3 @@\n-  if (Matcher::max_vector_size(bt1) < 2) {\n+  BasicType longer_bt = longer_type_for_conversion(s1);\n+  if (max_vector_size(bt1) < 2 ||\n+      (longer_bt != T_ILLEGAL && max_vector_size(longer_bt) < 2)) {\n@@ -1439,0 +1449,10 @@\n+\/\/------------------------------adjust_alignment_for_type_conversion---------------------------------\n+\/\/ Adjust the target alignment if conversion between different data size exists in def-use nodes.\n+int SuperWord::adjust_alignment_for_type_conversion(Node* s, Node* t, int align) {\n+  if (longer_type_for_conversion(s) != T_ILLEGAL ||\n+      longer_type_for_conversion(t) != T_ILLEGAL) {\n+    align = align \/ data_size(s) * data_size(t);\n+  }\n+  return align;\n+}\n+\n@@ -1450,2 +1470,1 @@\n-  int align = alignment(s1);\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, align);)\n+  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n@@ -1456,0 +1475,1 @@\n+    int align = alignment(s1);\n@@ -1460,0 +1480,1 @@\n+    align = adjust_alignment_for_type_conversion(s1, t1, align);\n@@ -1503,1 +1524,3 @@\n-      if (stmts_can_pack(t1, t2, align)) {\n+      int adjusted_align = alignment(s1);\n+      adjusted_align = adjust_alignment_for_type_conversion(s1, t1, adjusted_align);\n+      if (stmts_can_pack(t1, t2, adjusted_align)) {\n@@ -1509,0 +1532,1 @@\n+          align = adjusted_align;\n@@ -1701,2 +1725,1 @@\n-      BasicType bt = velt_basic_type(p1->at(0));\n-      uint max_vlen = max_vector_size(bt); \/\/ Max elements in vector\n+      uint max_vlen = max_vector_size_in_def_use_chain(p1->at(0)); \/\/ Max elements in vector\n@@ -2025,0 +2048,2 @@\n+    } else if (VectorNode::is_convert_opcode(opc)) {\n+      retValue = VectorCastNode::implemented(opc, size, velt_basic_type(p0->in(1)), velt_basic_type(p0));\n@@ -2621,2 +2646,1 @@\n-      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n-                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+      } else if (VectorNode::is_convert_opcode(opc)) {\n@@ -2625,1 +2649,1 @@\n-        int vopc = VectorNode::opcode(opc, bt);\n+        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n@@ -3139,1 +3163,0 @@\n-\n@@ -3142,0 +3165,18 @@\n+\n+  if (longer_type_for_conversion(use) != T_ILLEGAL) {\n+    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ another size - hence the special checks on alignment and size.\n+    for (uint i = 0; i < u_pk->size(); i++) {\n+      Node* ui = u_pk->at(i);\n+      Node* di = d_pk->at(i);\n+      if (ui->in(u_idx) != di) {\n+        return false;\n+      }\n+      if (alignment(ui) \/ type2aelembytes(velt_basic_type(ui)) !=\n+          alignment(di) \/ type2aelembytes(velt_basic_type(di))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n@@ -3374,0 +3415,57 @@\n+BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+  int opcode = n->Opcode();\n+  switch (opcode) {\n+    case Op_ConvD2I:\n+    case Op_ConvI2D:\n+    case Op_ConvF2D:\n+    case Op_ConvD2F: return T_DOUBLE;\n+    case Op_ConvF2L:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L: return T_LONG;\n+    case Op_ConvI2F: {\n+      BasicType src_t = velt_basic_type(n->in(1));\n+      if (src_t == T_BYTE || src_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+    case Op_ConvF2I: {\n+      BasicType dst_t = velt_basic_type(n);\n+      if (dst_t == T_BYTE || dst_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+  }\n+  return T_ILLEGAL;\n+}\n+\n+int SuperWord::max_vector_size_in_def_use_chain(Node* n) {\n+  BasicType bt = velt_basic_type(n);\n+  BasicType vt = bt;\n+\n+  \/\/ find the longest type among def nodes.\n+  uint start, end;\n+  VectorNode::vector_operands(n, &start, &end);\n+  for (uint i = start; i < end; ++i) {\n+    Node* input = n->in(i);\n+    if (!in_bb(input)) continue;\n+    BasicType newt = longer_type_for_conversion(input);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  \/\/ find the longest type among use nodes.\n+  for (uint i = 0; i < n->outcnt(); ++i) {\n+    Node* output = n->raw_out(i);\n+    if (!in_bb(output)) continue;\n+    BasicType newt = longer_type_for_conversion(output);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  int max = max_vector_size(vt);\n+  \/\/ If now there is no vectors for the longest type, the nodes with the longest\n+  \/\/ type in the def-use chain are not packed in SuperWord::stmts_can_pack.\n+  return max < 2 ? max_vector_size(bt) : max;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":110,"deletions":12,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -252,8 +252,0 @@\n-  case Op_ConvI2F:\n-    return Op_VectorCastI2X;\n-  case Op_ConvL2D:\n-    return Op_VectorCastL2X;\n-  case Op_ConvF2I:\n-    return Op_VectorCastF2X;\n-  case Op_ConvD2L:\n-    return Op_VectorCastD2X;\n@@ -272,0 +264,3 @@\n+    assert(!VectorNode::is_convert_opcode(sopc),\n+           \"Convert node %s should be processed by VectorCastNode::opcode()\",\n+           NodeClassNames[sopc]);\n@@ -319,1 +314,1 @@\n-    return vopc > 0 && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n+    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n@@ -464,0 +459,20 @@\n+bool VectorNode::is_convert_opcode(int opc) {\n+  switch (opc) {\n+    case Op_ConvI2F:\n+    case Op_ConvL2D:\n+    case Op_ConvF2I:\n+    case Op_ConvD2L:\n+    case Op_ConvI2D:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L:\n+    case Op_ConvF2L:\n+    case Op_ConvD2F:\n+    case Op_ConvF2D:\n+    case Op_ConvD2I:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -817,1 +832,1 @@\n-static bool is_con_M1(Node* n) {\n+static bool is_con(Node* n, long con) {\n@@ -820,1 +835,1 @@\n-    if (t->isa_int() && t->is_int()->get_con() == -1) {\n+    if (t->isa_int() && t->is_int()->get_con() == (int)con) {\n@@ -823,1 +838,1 @@\n-    if (t->isa_long() && t->is_long()->get_con() == -1) {\n+    if (t->isa_long() && t->is_long()->get_con() == con) {\n@@ -830,0 +845,1 @@\n+\/\/ Return true if every bit in this vector is 1.\n@@ -836,1 +852,16 @@\n-    return is_con_M1(n->in(1));\n+  case Op_MaskAll:\n+    return is_con(n->in(1), -1);\n+  default:\n+    return false;\n+  }\n+}\n+\n+\/\/ Return true if every bit in this vector is 0.\n+bool VectorNode::is_all_zeros_vector(Node* n) {\n+  switch (n->Opcode()) {\n+  case Op_ReplicateB:\n+  case Op_ReplicateS:\n+  case Op_ReplicateI:\n+  case Op_ReplicateL:\n+  case Op_MaskAll:\n+    return is_con(n->in(1), 0);\n@@ -850,0 +881,56 @@\n+Node* VectorNode::try_to_gen_masked_vector(PhaseGVN* gvn, Node* node, const TypeVect* vt) {\n+  int vopc = node->Opcode();\n+  uint vlen = vt->length();\n+  BasicType bt = vt->element_basic_type();\n+\n+  \/\/ Predicated vectors do not need to add another mask input\n+  if (node->is_predicated_vector() || !Matcher::has_predicated_vectors() ||\n+      !Matcher::match_rule_supported_vector_masked(vopc, vlen, bt) ||\n+      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, bt)) {\n+    return NULL;\n+  }\n+\n+  Node* mask = NULL;\n+  \/\/ Generate a vector mask for vector operation whose vector length is lower than the\n+  \/\/ hardware supported max vector length.\n+  if (vt->length_in_bytes() < (uint)MaxVectorSize) {\n+    Node* length = gvn->transform(new ConvI2LNode(gvn->makecon(TypeInt::make(vlen))));\n+    mask = gvn->transform(VectorMaskGenNode::make(length, bt, vlen));\n+  } else {\n+    return NULL;\n+  }\n+\n+  \/\/ Generate the related masked op for vector load\/store\/load_gather\/store_scatter.\n+  \/\/ Or append the mask to the vector op's input list by default.\n+  switch(vopc) {\n+  case Op_LoadVector:\n+    return new LoadVectorMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                    node->as_LoadVector()->adr_type(), vt, mask,\n+                                    node->as_LoadVector()->control_dependency());\n+  case Op_LoadVectorGather:\n+    return new LoadVectorGatherMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                          node->as_LoadVector()->adr_type(), vt,\n+                                          node->in(3), mask);\n+  case Op_StoreVector:\n+    return new StoreVectorMaskedNode(node->in(0), node->in(1), node->in(2), node->in(3),\n+                                     node->as_StoreVector()->adr_type(), mask);\n+  case Op_StoreVectorScatter:\n+    return new StoreVectorScatterMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                            node->as_StoreVector()->adr_type(),\n+                                            node->in(3), node->in(4), mask);\n+  default:\n+    \/\/ Add the mask as an additional input to the original vector node by default.\n+    \/\/ This is used for almost all the vector nodes.\n+    node->add_req(mask);\n+    node->add_flag(Node::Flag_is_predicated_vector);\n+    return node;\n+  }\n+}\n+\n+Node* VectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (Matcher::vector_needs_partial_operations(this, vect_type())) {\n+    return try_to_gen_masked_vector(phase, this, vect_type());\n+  }\n+  return NULL;\n+}\n+\n@@ -920,0 +1007,8 @@\n+Node* LoadVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* vt = vect_type();\n+  if (Matcher::vector_needs_partial_operations(this, vt)) {\n+    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  }\n+  return LoadNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -921,3 +1016,2 @@\n-StoreVectorNode* StoreVectorNode::make(int opc, Node* ctl, Node* mem,\n-                                       Node* adr, const TypePtr* atyp, Node* val,\n-                                       uint vlen) {\n+StoreVectorNode* StoreVectorNode::make(int opc, Node* ctl, Node* mem, Node* adr,\n+                                       const TypePtr* atyp, Node* val, uint vlen) {\n@@ -927,0 +1021,8 @@\n+Node* StoreVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* vt = vect_type();\n+  if (Matcher::vector_needs_partial_operations(this, vt)) {\n+    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  }\n+  return StoreNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -943,1 +1045,1 @@\n-  return NULL;\n+  return LoadVectorNode::Ideal(phase, can_reshape);\n@@ -963,1 +1065,1 @@\n-  return NULL;\n+  return StoreVectorNode::Ideal(phase, can_reshape);\n@@ -1182,0 +1284,8 @@\n+Node* ReductionNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* vt = vect_type();\n+  if (Matcher::vector_needs_partial_operations(this, vt)) {\n+    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  }\n+  return NULL;\n+}\n+\n@@ -1236,1 +1346,1 @@\n-      assert(false, \"unknown type: %s\", type2name(bt));\n+      assert(bt == T_CHAR || bt == T_BOOLEAN, \"unknown type: %s\", type2name(bt));\n@@ -1241,0 +1351,10 @@\n+bool VectorCastNode::implemented(int opc, uint vlen, BasicType src_type, BasicType dst_type) {\n+  if (is_java_primitive(dst_type) &&\n+      (vlen > 1) && is_power_of_2(vlen) &&\n+      VectorNode::vector_size_supported(dst_type, vlen)) {\n+    int vopc = VectorCastNode::opcode(src_type);\n+    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, dst_type);\n+  }\n+  return false;\n+}\n+\n@@ -1330,1 +1450,1 @@\n-    return vopc != opc && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n+    return vopc != opc && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n@@ -1563,1 +1683,5 @@\n-  const TypeVectMask* t_vmask = TypeVectMask::make(mask_bt, max_vector);\n+  return make(length, mask_bt, max_vector);\n+}\n+\n+Node* VectorMaskGenNode::make(Node* length, BasicType mask_bt, int mask_len) {\n+  const TypeVectMask* t_vmask = TypeVectMask::make(mask_bt, mask_len);\n@@ -1583,0 +1707,8 @@\n+Node* VectorMaskOpNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* vt = vect_type();\n+  if (Matcher::vector_needs_partial_operations(this, vt)) {\n+    return VectorNode::try_to_gen_masked_vector(phase, this, vt);\n+  }\n+  return NULL;\n+}\n+\n@@ -1590,1 +1722,0 @@\n-\n@@ -1754,0 +1885,89 @@\n+Node* AndVNode::Identity(PhaseGVN* phase) {\n+  \/\/ (AndV src (Replicate m1))   => src\n+  \/\/ (AndVMask src (MaskAll m1)) => src\n+  if (VectorNode::is_all_ones_vector(in(2))) {\n+    return in(1);\n+  }\n+  \/\/ (AndV (Replicate zero) src)   => (Replicate zero)\n+  \/\/ (AndVMask (MaskAll zero) src) => (MaskAll zero)\n+  if (VectorNode::is_all_zeros_vector(in(1))) {\n+    return in(1);\n+  }\n+  \/\/ The following transformations are only applied to\n+  \/\/ the un-predicated operation, since the VectorAPI\n+  \/\/ masked operation requires the unmasked lanes to\n+  \/\/ save the same values in the first operand.\n+  if (!is_predicated_vector()) {\n+    \/\/ (AndV (Replicate m1) src)   => src\n+    \/\/ (AndVMask (MaskAll m1) src) => src\n+    if (VectorNode::is_all_ones_vector(in(1))) {\n+      return in(2);\n+    }\n+    \/\/ (AndV src (Replicate zero))   => (Replicate zero)\n+    \/\/ (AndVMask src (MaskAll zero)) => (MaskAll zero)\n+    if (VectorNode::is_all_zeros_vector(in(2))) {\n+      return in(2);\n+    }\n+  }\n+\n+  \/\/ (AndV src src)     => src\n+  \/\/ (AndVMask src src) => src\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* OrVNode::Identity(PhaseGVN* phase) {\n+  \/\/ (OrV (Replicate m1) src)   => (Replicate m1)\n+  \/\/ (OrVMask (MaskAll m1) src) => (MaskAll m1)\n+  if (VectorNode::is_all_ones_vector(in(1))) {\n+    return in(1);\n+  }\n+  \/\/ (OrV src (Replicate zero))   => src\n+  \/\/ (OrVMask src (MaskAll zero)) => src\n+  if (VectorNode::is_all_zeros_vector(in(2))) {\n+    return in(1);\n+  }\n+  \/\/ The following transformations are only applied to\n+  \/\/ the un-predicated operation, since the VectorAPI\n+  \/\/ masked operation requires the unmasked lanes to\n+  \/\/ save the same values in the first operand.\n+  if (!is_predicated_vector()) {\n+    \/\/ (OrV src (Replicate m1))   => (Replicate m1)\n+    \/\/ (OrVMask src (MaskAll m1)) => (MaskAll m1)\n+    if (VectorNode::is_all_ones_vector(in(2))) {\n+      return in(2);\n+    }\n+    \/\/ (OrV (Replicate zero) src)   => src\n+    \/\/ (OrVMask (MaskAll zero) src) => src\n+    if (VectorNode::is_all_zeros_vector(in(1))) {\n+      return in(2);\n+    }\n+  }\n+\n+  \/\/ (OrV src src)     => src\n+  \/\/ (OrVMask src src) => src\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* XorVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ (XorV src src)      => (Replicate zero)\n+  \/\/ (XorVMask src src)  => (MaskAll zero)\n+  \/\/\n+  \/\/ The transformation is only applied to the un-predicated\n+  \/\/ operation, since the VectorAPI masked operation requires\n+  \/\/ the unmasked lanes to save the same values in the first\n+  \/\/ operand.\n+  if (!is_predicated_vector() && (in(1) == in(2))) {\n+    BasicType bt = vect_type()->element_basic_type();\n+    Node* zero = phase->transform(phase->zerocon(bt));\n+    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n+                                     bottom_type()->isa_vectmask() != NULL);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":242,"deletions":22,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    private int bound;\n@@ -64,0 +65,1 @@\n+        bound = 50;\n@@ -152,0 +154,16 @@\n+    @Benchmark\n+    public void compareUnsignedIndirect(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            int r = (Integer.compareUnsigned(intsSmall[i], bound - 16) < 0) ? 1 : 0;\n+            bh.consume(r);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void compareUnsignedDirect(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            int r = Integer.compareUnsigned(intsSmall[i], bound - 16);\n+            bh.consume(r);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    private long bound;\n@@ -60,0 +61,1 @@\n+        bound = 20000L;\n@@ -147,0 +149,16 @@\n+    @Benchmark\n+    public void compareUnsignedIndirect(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            int r = (Long.compareUnsigned(longArraySmall[i], bound - 16) < 0) ? 1 : 0;\n+            bh.consume(r);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void compareUnsignedDirect(Blackhole bh) {\n+        for (int i = 0; i < size; i++) {\n+            int r = Long.compareUnsigned(longArraySmall[i], bound - 16);\n+            bh.consume(r);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}