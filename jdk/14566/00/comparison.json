{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.io.FileOutputStream;\n@@ -37,1 +38,0 @@\n-import java.nio.channels.WritableByteChannel;\n@@ -63,0 +63,7 @@\n+    \/**\n+     * Return the underlying channel.\n+     *\/\n+    ReadableByteChannel channel() {\n+        return ch;\n+    }\n+\n@@ -227,39 +234,5 @@\n-        if (ch instanceof FileChannel fc) {\n-            \/\/ FileChannel -> SocketChannel\n-            if (out instanceof SocketOutputStream sos) {\n-                SocketChannelImpl sc = sos.channel();\n-                synchronized (sc.blockingLock()) {\n-                    if (!sc.isBlocking())\n-                        throw new IllegalBlockingModeException();\n-                    return transfer(fc, sc);\n-                }\n-            }\n-\n-            \/\/ FileChannel -> WritableByteChannel\n-            if (out instanceof ChannelOutputStream cos) {\n-                WritableByteChannel wbc = cos.channel();\n-\n-                if (wbc instanceof SelectableChannel sc) {\n-                    synchronized (sc.blockingLock()) {\n-                        if (!sc.isBlocking())\n-                            throw new IllegalBlockingModeException();\n-                        return transfer(fc, wbc);\n-                    }\n-                }\n-\n-                return transfer(fc, wbc);\n-            }\n-        }\n-\n-        if (out instanceof ChannelOutputStream cos && cos.channel() instanceof FileChannel fc) {\n-            ReadableByteChannel rbc = ch;\n-\n-            if (rbc instanceof SelectableChannel sc) {\n-                synchronized (sc.blockingLock()) {\n-                    if (!sc.isBlocking())\n-                        throw new IllegalBlockingModeException();\n-                    return transfer(rbc, fc);\n-                }\n-            }\n-\n-            return transfer(rbc, fc);\n+        \/\/ use FileChannel.transferFrom if output stream is based on a FileChannel\n+        if (out instanceof FileChannelOutputStream fcos) {\n+            return transferTo(fcos.channel());\n+        } else if (out instanceof FileOutputStream fos) {\n+            return transferTo(fos.getChannel());\n@@ -272,3 +245,1 @@\n-     * Transfers all bytes from a channel's file to a target writeable byte channel.\n-     * If the writeable byte channel is a selectable channel then it must be in\n-     * blocking mode.\n+     * Transfers all bytes to the target channel's file.\n@@ -276,8 +247,6 @@\n-    private static long transfer(FileChannel fc, WritableByteChannel target)\n-        throws IOException\n-    {\n-        long initialPos = fc.position();\n-        long pos = initialPos;\n-        try {\n-            while (pos < fc.size()) {\n-                pos += fc.transferTo(pos, Long.MAX_VALUE, target);\n+    private long transferTo(FileChannel fc) throws IOException {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                return implTransferTo(fc);\n@@ -285,2 +254,2 @@\n-        } finally {\n-            fc.position(pos);\n+        } else {\n+            return implTransferTo(fc);\n@@ -288,1 +257,0 @@\n-        return pos - initialPos;\n@@ -292,3 +260,2 @@\n-     * Transfers all bytes from a readable byte channel to a target channel's file.\n-     * If the readable byte channel is a selectable channel then it must be in\n-     * blocking mode.\n+     * Transfers all bytes to the target channel's file. If the source channel\n+     * is a selectable channel then it's in blocking mode.\n@@ -296,2 +263,2 @@\n-    private static long transfer(ReadableByteChannel src, FileChannel dst) throws IOException {\n-        long initialPos = dst.position();\n+    private long implTransferTo(FileChannel fc) throws IOException {\n+        long initialPos = fc.position();\n@@ -301,1 +268,1 @@\n-            while ((n = dst.transferFrom(src, pos, Long.MAX_VALUE)) > 0) {\n+            while ((n = fc.transferFrom(ch, pos, Long.MAX_VALUE)) > 0) {\n@@ -305,1 +272,1 @@\n-            dst.position(pos);\n+            fc.position(pos);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-     * @return The channel wrapped by this stream.\n+     * Return the underlying channel.\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+\/**\n+ * An InputStream that reads bytes from a file channel.\n+ *\/\n+class FileChannelInputStream extends ChannelInputStream {\n+    \/**\n+     * Initialize a FileChannelInputStream that reads from the given file channel.\n+     *\/\n+    FileChannelInputStream(FileChannel fc) {\n+        super(fc);\n+    }\n+\n+    @Override\n+    FileChannel channel() {\n+        return (FileChannel) super.channel();\n+    }\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        \/\/ transferTo(SocketChannel)\n+        if (out instanceof SocketOutputStream sos) {\n+            return transferTo(sos.channel());\n+        }\n+\n+        \/\/ transferTo(WritableByteChannel)\n+        if (out instanceof ChannelOutputStream cos) {\n+            return transferTo(cos.channel());\n+        }\n+\n+        \/\/ transferTo(FileChannel)\n+        if (out instanceof FileOutputStream fos) {\n+            return implTransferTo(fos.getChannel());\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    \/**\n+     * Transfers all bytes to the given target channel.\n+     *\/\n+    private long transferTo(WritableByteChannel target) throws IOException {\n+        if (target instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                return implTransferTo(target);\n+            }\n+        } else {\n+            return implTransferTo(target);\n+        }\n+    }\n+\n+    \/**\n+     * Transfers all bytes to the given target channel. If the target channel is a\n+     * selectable channel then it's in blocking mode.\n+     *\/\n+    private long implTransferTo(WritableByteChannel target) throws IOException {\n+        FileChannel fc = channel();\n+        long initialPos = fc.position();\n+        long pos = initialPos;\n+        try {\n+            while (pos < fc.size()) {\n+                pos += fc.transferTo(pos, Long.MAX_VALUE, target);\n+            }\n+        } finally {\n+            fc.position(pos);\n+        }\n+        return pos - initialPos;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelInputStream.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import java.nio.channels.FileChannel;\n+\n+\/**\n+ * An OutputStream that write bytes to a file channel.\n+ *\/\n+class FileChannelOutputStream extends ChannelOutputStream {\n+    \/**\n+     * Initialize a FileChannelOutputStream that writes to the given file channel.\n+     *\/\n+    FileChannelOutputStream(FileChannel fc) {\n+        super(fc);\n+    }\n+\n+    @Override\n+    FileChannel channel() {\n+        return (FileChannel) super.channel();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelOutputStream.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.io.FileOutputStream;\n@@ -29,0 +30,4 @@\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.ReadableByteChannel;\n@@ -83,0 +88,33 @@\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        \/\/ use FileChannel.transferFrom if output stream is based on a FileChannel\n+        if (out instanceof FileChannelOutputStream fcos) {\n+            return transferTo(fcos.channel());\n+        } else if (out instanceof FileOutputStream fos) {\n+            return transferTo(fos.getChannel());\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    \/**\n+     * Transfers all bytes to the target channel's file.\n+     *\/\n+    private long transferTo(FileChannel fc) throws IOException {\n+        synchronized (sc.blockingLock()) {\n+            if (!sc.isBlocking())\n+                throw new IllegalBlockingModeException();\n+            long initialPos = fc.position();\n+            long pos = initialPos;\n+            try {\n+                long n;\n+                while ((n = fc.transferFrom(sc, pos, Long.MAX_VALUE)) > 0) {\n+                    pos += n;\n+                }\n+            } finally {\n+                fc.position(pos);\n+            }\n+            return pos - initialPos;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketInputStream.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.channels.FileChannel;\n@@ -42,1 +43,4 @@\n-        if (ch instanceof SocketChannelImpl sc) {\n+        \/\/ avoid switch expression due to recursive initialization issues\n+        if (ch instanceof FileChannel fc) {\n+            return new FileChannelInputStream(fc);\n+        } else if (ch instanceof SocketChannelImpl sc) {\n@@ -53,1 +57,4 @@\n-        if (ch instanceof SocketChannelImpl sc) {\n+        \/\/ avoid switch expression due to recursive initialization issues\n+        if (ch instanceof FileChannel fc) {\n+            return new FileChannelOutputStream(fc);\n+        } else if (ch instanceof SocketChannelImpl sc) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Streams.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.io.FileOutputStream;\n@@ -52,2 +53,1 @@\n- * @summary Tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n- *          InputStream.transferTo specification\n+ * @summary Tests Channels.newInputStream.transferTo\n@@ -65,1 +65,1 @@\n-            \/\/ tests FileChannel.transferTo(FileChannel) optimized case\n+            \/\/ should use FileChannel.transferTo(FileChannel)\n@@ -68,2 +68,4 @@\n-            \/\/ tests FileChannel.transferTo(SelectableChannelOutput)\n-            \/\/ optimized case\n+            \/\/ should use FileChannel.transferTo(FileChannel)\n+            {fileChannelInput(), fileOutputStream()},\n+\n+            \/\/ should use FileChannel.transferTo(SelectableChannel)\n@@ -72,2 +74,1 @@\n-            \/\/ tests FileChannel.transferTo(WritableByteChannelOutput)\n-            \/\/ optimized case\n+            \/\/ should use FileChannel.transferTo(WritableByteChannel)\n@@ -76,0 +77,6 @@\n+            \/\/ should use FileChannel.transferFrom(ReadableByteChannel)\n+            {readableByteChannelInput(), fileChannelOutput()},\n+\n+            \/\/ should use FileChannel.transferFrom(ReadableByteChannel)\n+            {readableByteChannelInput(), fileOutputStream()},\n+\n@@ -107,1 +114,1 @@\n-            OutputStreamProvider outputStreamProvider) throws Exception {\n+                                   OutputStreamProvider outputStreamProvider) throws IOException {\n@@ -121,3 +128,3 @@\n-                InputStream is = Channels.newInputStream(fc);\n-                SelectableChannel sc = pipe.sink().configureBlocking(false);\n-                OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n+                 InputStream in = Channels.newInputStream(fc);\n+                 SelectableChannel sc = pipe.sink().configureBlocking(false);\n+                 OutputStream out = Channels.newOutputStream((WritableByteChannel) sc)) {\n@@ -127,1 +134,1 @@\n-                assertThrows(IllegalBlockingModeException.class, () -> is.transferTo(os));\n+                assertThrows(IllegalBlockingModeException.class, () -> in.transferTo(out));\n@@ -133,2 +140,2 @@\n-                InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n-                OutputStream os = new ByteArrayOutputStream()) {\n+                InputStream in = Channels.newInputStream((ReadableByteChannel) sc);\n+                OutputStream out = new ByteArrayOutputStream()) {\n@@ -138,1 +145,1 @@\n-                assertThrows(IllegalBlockingModeException.class, () -> is.transferTo(os));\n+                assertThrows(IllegalBlockingModeException.class, () -> in.transferTo(out));\n@@ -150,1 +157,1 @@\n-        return spy -> {\n+        return supplier -> {\n@@ -152,1 +159,1 @@\n-            spy.accept(outputStream::toByteArray);\n+            supplier.accept(outputStream::toByteArray);\n@@ -173,1 +180,1 @@\n-        return spy -> {\n+        return supplier -> {\n@@ -177,2 +184,2 @@\n-                    InputStream is = Channels.newInputStream(pipe.source());\n-                    return is.readAllBytes();\n+                    InputStream in = Channels.newInputStream(pipe.source());\n+                    return in.readAllBytes();\n@@ -183,2 +190,2 @@\n-            final OutputStream os = Channels.newOutputStream(pipe.sink());\n-            spy.accept(() -> {\n+            OutputStream out = Channels.newOutputStream(pipe.sink());\n+            supplier.accept(() -> {\n@@ -186,1 +193,1 @@\n-                    os.close();\n+                    out.close();\n@@ -192,1 +199,1 @@\n-            return os;\n+            return out;\n@@ -197,1 +204,1 @@\n-     * Creates a provider for an output stream which wraps a writable byte channel but is not a file channel\n+     * Creates a provider for an output stream that wraps a writable byte channel but is not a file channel\n@@ -200,1 +207,1 @@\n-        return spy -> {\n+        return supplier -> {\n@@ -202,1 +209,1 @@\n-            spy.accept(outputStream::toByteArray);\n+            supplier.accept(outputStream::toByteArray);\n@@ -207,0 +214,17 @@\n+    \/**\n+     * Returns a provider for a FileOutputStream.\n+     *\/\n+    private static OutputStreamProvider fileOutputStream() {\n+        return supplier -> {\n+            Path path = Files.createTempFile(CWD, \"fosOutput\", null);\n+            supplier.accept(() -> {\n+                try {\n+                    return Files.readAllBytes(path);\n+                } catch (IOException e) {\n+                    throw new AssertionError(\"Failed to verify output file\", e);\n+                }\n+            });\n+            return new FileOutputStream(path.toFile());\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":51,"deletions":27,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+                                         OutputStreamProvider outputStreamProvider,\n+                                         byte[] inBytes) throws IOException {\n@@ -80,1 +81,4 @@\n-            OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn, int posOut) throws Exception {\n+                                         OutputStreamProvider outputStreamProvider,\n+                                         byte[] inBytes,\n+                                         int posIn,\n+                                         int posOut) throws IOException {\n@@ -110,1 +114,1 @@\n-        InputStream input(byte... bytes) throws Exception;\n+        InputStream input(byte... bytes) throws IOException;\n@@ -114,1 +118,1 @@\n-        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+        OutputStream output(Consumer<Supplier<byte[]>> supplier) throws IOException;\n@@ -129,1 +133,1 @@\n-        return spy -> {\n+        return supplier -> {\n@@ -132,1 +136,1 @@\n-            spy.accept(() -> {\n+            supplier.accept(() -> {\n@@ -163,1 +167,1 @@\n-            OutputStreamProvider outputStreamProvider) throws Exception {\n+                                     OutputStreamProvider outputStreamProvider) throws IOException {\n@@ -193,3 +197,4 @@\n-    static void testMoreThanTwoGB(String direction, BiFunction<Path, Path, InputStream> inputStreamProvider,\n-            BiFunction<Path, Path, OutputStream> outputStreamProvider,\n-            ToLongBiFunction<InputStream, OutputStream> transfer) throws IOException {\n+    static void testMoreThanTwoGB(String direction,\n+                                  BiFunction<Path, Path, InputStream> inputStreamProvider,\n+                                  BiFunction<Path, Path, OutputStream> outputStreamProvider,\n+                                  ToLongBiFunction<InputStream, OutputStream> transfer) throws IOException {\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferToBase.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"}]}