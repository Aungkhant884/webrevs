{"files":[{"patch":"@@ -53,2 +53,1 @@\n-  template <class WorkerType>\n-  static uint add_workers (WorkerType* holder,\n+  static uint add_workers (WorkGang* workers,\n@@ -62,2 +61,1 @@\n-  template <class WorkerType>\n-  static void log_worker_creation(WorkerType* holder,\n+  static void log_worker_creation(WorkGang* workers,\n@@ -70,2 +68,1 @@\n-template <class WorkerType>\n-uint WorkerManager::add_workers(WorkerType* holder,\n+uint WorkerManager::add_workers(WorkGang* workers,\n@@ -82,1 +79,1 @@\n-      new_worker = holder->install_worker(worker_id);\n+      new_worker = workers->install_worker(worker_id);\n@@ -88,3 +85,1 @@\n-      if (new_worker != NULL) {\n-        delete new_worker;\n-      }\n+      delete new_worker;\n@@ -106,2 +101,1 @@\n-template <class WorkerType>\n-void WorkerManager::log_worker_creation(WorkerType* holder,\n+void WorkerManager::log_worker_creation(WorkGang* workers,\n@@ -115,1 +109,1 @@\n-                        initializing_msg, holder->group_name(), previous_created_workers, active_workers, created_workers);\n+                        initializing_msg, workers->group_name(), previous_created_workers, active_workers, created_workers);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerManager.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,71 +37,0 @@\n-\/\/ Definitions of WorkGang methods.\n-\n-AbstractWorkGang::AbstractWorkGang(const char* name, uint workers, bool are_GC_task_threads, bool are_ConcurrentGC_threads) :\n-      _workers(NULL),\n-      _total_workers(workers),\n-      _active_workers(UseDynamicNumberOfGCThreads ? 1U : workers),\n-      _created_workers(0),\n-      _name(name),\n-      _are_GC_task_threads(are_GC_task_threads),\n-      _are_ConcurrentGC_threads(are_ConcurrentGC_threads)\n-  { }\n-\n-\n-\/\/ The current implementation will exit if the allocation\n-\/\/ of any worker fails.\n-void  AbstractWorkGang::initialize_workers() {\n-  log_develop_trace(gc, workgang)(\"Constructing work gang %s with %u threads\", name(), total_workers());\n-  _workers = NEW_C_HEAP_ARRAY(AbstractGangWorker*, total_workers(), mtInternal);\n-  add_workers(true);\n-}\n-\n-\n-AbstractGangWorker* AbstractWorkGang::install_worker(uint worker_id) {\n-  AbstractGangWorker* new_worker = allocate_worker(worker_id);\n-  set_thread(worker_id, new_worker);\n-  return new_worker;\n-}\n-\n-void AbstractWorkGang::add_workers(bool initializing) {\n-  add_workers(_active_workers, initializing);\n-}\n-\n-void AbstractWorkGang::add_workers(uint active_workers, bool initializing) {\n-\n-  os::ThreadType worker_type;\n-  if (are_ConcurrentGC_threads()) {\n-    worker_type = os::cgc_thread;\n-  } else {\n-    worker_type = os::pgc_thread;\n-  }\n-  uint previous_created_workers = _created_workers;\n-\n-  _created_workers = WorkerManager::add_workers(this,\n-                                                active_workers,\n-                                                _total_workers,\n-                                                _created_workers,\n-                                                worker_type,\n-                                                initializing);\n-  _active_workers = MIN2(_created_workers, _active_workers);\n-\n-  WorkerManager::log_worker_creation(this, previous_created_workers, _active_workers, _created_workers, initializing);\n-}\n-\n-AbstractGangWorker* AbstractWorkGang::worker(uint i) const {\n-  \/\/ Array index bounds checking.\n-  AbstractGangWorker* result = NULL;\n-  assert(_workers != NULL, \"No workers for indexing\");\n-  assert(i < total_workers(), \"Worker index out of bounds\");\n-  result = _workers[i];\n-  assert(result != NULL, \"Indexing to null worker\");\n-  return result;\n-}\n-\n-void AbstractWorkGang::threads_do(ThreadClosure* tc) const {\n-  assert(tc != NULL, \"Null ThreadClosure\");\n-  uint workers = created_workers();\n-  for (uint i = 0; i < workers; i++) {\n-    tc->do_thread(worker(i));\n-  }\n-}\n-\n@@ -201,0 +130,1 @@\n+\/\/ Definitions of WorkGang methods.\n@@ -202,5 +132,8 @@\n-WorkGang::WorkGang(const char* name,\n-                   uint  workers,\n-                   bool  are_GC_task_threads,\n-                   bool  are_ConcurrentGC_threads) :\n-    AbstractWorkGang(name, workers, are_GC_task_threads, are_ConcurrentGC_threads),\n+WorkGang::WorkGang(const char* name, uint workers, bool are_GC_task_threads, bool are_ConcurrentGC_threads) :\n+    _workers(NULL),\n+    _total_workers(workers),\n+    _active_workers(UseDynamicNumberOfGCThreads ? 1U : workers),\n+    _created_workers(0),\n+    _name(name),\n+    _are_GC_task_threads(are_GC_task_threads),\n+    _are_ConcurrentGC_threads(are_ConcurrentGC_threads),\n@@ -208,1 +141,1 @@\n-{ }\n+  { }\n@@ -214,1 +147,54 @@\n-AbstractGangWorker* WorkGang::allocate_worker(uint worker_id) {\n+\/\/ The current implementation will exit if the allocation\n+\/\/ of any worker fails.\n+void WorkGang::initialize_workers() {\n+  log_develop_trace(gc, workgang)(\"Constructing work gang %s with %u threads\", name(), total_workers());\n+  _workers = NEW_C_HEAP_ARRAY(GangWorker*, total_workers(), mtInternal);\n+  add_workers(true);\n+}\n+\n+\n+GangWorker* WorkGang::install_worker(uint worker_id) {\n+  GangWorker* new_worker = allocate_worker(worker_id);\n+  set_thread(worker_id, new_worker);\n+  return new_worker;\n+}\n+\n+void WorkGang::add_workers(bool initializing) {\n+  os::ThreadType worker_type;\n+  if (are_ConcurrentGC_threads()) {\n+    worker_type = os::cgc_thread;\n+  } else {\n+    worker_type = os::pgc_thread;\n+  }\n+  uint previous_created_workers = _created_workers;\n+\n+  _created_workers = WorkerManager::add_workers(this,\n+                                                _active_workers,\n+                                                _total_workers,\n+                                                _created_workers,\n+                                                worker_type,\n+                                                initializing);\n+  _active_workers = MIN2(_created_workers, _active_workers);\n+\n+  WorkerManager::log_worker_creation(this, previous_created_workers, _active_workers, _created_workers, initializing);\n+}\n+\n+GangWorker* WorkGang::worker(uint i) const {\n+  \/\/ Array index bounds checking.\n+  GangWorker* result = NULL;\n+  assert(_workers != NULL, \"No workers for indexing\");\n+  assert(i < total_workers(), \"Worker index out of bounds\");\n+  result = _workers[i];\n+  assert(result != NULL, \"Indexing to null worker\");\n+  return result;\n+}\n+\n+void WorkGang::threads_do(ThreadClosure* tc) const {\n+  assert(tc != NULL, \"Null ThreadClosure\");\n+  uint workers = created_workers();\n+  for (uint i = 0; i < workers; i++) {\n+    tc->do_thread(worker(i));\n+  }\n+}\n+\n+GangWorker* WorkGang::allocate_worker(uint worker_id) {\n@@ -233,1 +219,1 @@\n-AbstractGangWorker::AbstractGangWorker(AbstractWorkGang* gang, uint id) {\n+GangWorker::GangWorker(WorkGang* gang, uint id) {\n@@ -239,1 +225,1 @@\n-void AbstractGangWorker::run() {\n+void GangWorker::run() {\n@@ -244,1 +230,1 @@\n-void AbstractGangWorker::initialize() {\n+void GangWorker::initialize() {\n@@ -252,16 +238,0 @@\n-bool AbstractGangWorker::is_GC_task_thread() const {\n-  return gang()->are_GC_task_threads();\n-}\n-\n-bool AbstractGangWorker::is_ConcurrentGC_thread() const {\n-  return gang()->are_ConcurrentGC_threads();\n-}\n-\n-void AbstractGangWorker::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n-void AbstractGangWorker::print() const { print_on(tty); }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":67,"deletions":97,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -43,3 +43,1 @@\n-\/\/   AbstractWorkGang\n-\/\/     WorkGang\n-\/\/     YieldingFlexibleWorkGang (defined in another file)\n+\/\/   WorkGang\n@@ -48,3 +46,1 @@\n-\/\/   AbstractGangWorker (subclass of WorkerThread)\n-\/\/     GangWorker\n-\/\/     YieldingFlexibleGangWorker   (defined in another file)\n+\/\/   GangWorker (subclass of WorkerThread)\n@@ -54,1 +50,1 @@\n-class AbstractGangWorker;\n+class GangWorker;\n@@ -57,1 +53,0 @@\n-class WorkGang;\n@@ -89,3 +84,2 @@\n-\/\/ while \"_total_workers\" is the number of available of workers.\n-class AbstractWorkGang : public CHeapObj<mtInternal> {\n- protected:\n+\/\/ while \"_total_workers\" is the number of available workers.\n+class WorkGang : public CHeapObj<mtInternal> {\n@@ -93,1 +87,1 @@\n-  AbstractGangWorker** _workers;\n+  GangWorker** _workers;\n@@ -103,3 +97,0 @@\n-  ~AbstractWorkGang() {}\n-\n- private:\n@@ -110,1 +101,7 @@\n-  void set_thread(uint worker_id, AbstractGangWorker* worker) {\n+  \/\/ To get access to the GangTaskDispatcher instance.\n+  friend class GangWorker;\n+  GangTaskDispatcher* const _dispatcher;\n+\n+  GangTaskDispatcher* dispatcher() const { return _dispatcher; }\n+\n+  void set_thread(uint worker_id, GangWorker* worker) {\n@@ -114,0 +111,7 @@\n+  \/\/ Add GC workers when _created_workers < _active_workers; otherwise, no-op.\n+  \/\/ If there's no memory\/thread allocation failure, _created_worker is\n+  \/\/ adjusted to match _active_workers (_created_worker == _active_workers).\n+  void add_workers(bool initializing);\n+\n+  GangWorker* allocate_worker(uint which);\n+\n@@ -115,1 +119,4 @@\n-  AbstractWorkGang(const char* name, uint workers, bool are_GC_task_threads, bool are_ConcurrentGC_threads);\n+  WorkGang(const char* name, uint workers, bool are_GC_task_threads, bool are_ConcurrentGC_threads);\n+\n+  ~WorkGang();\n+\n@@ -128,1 +135,2 @@\n-  virtual uint active_workers() const {\n+  uint active_workers() const {\n+    assert(_active_workers != 0, \"zero active workers\");\n@@ -137,2 +145,0 @@\n-    _active_workers = MIN2(v, _total_workers);\n-    add_workers(false \/* exit_on_failure *\/);\n@@ -140,0 +146,2 @@\n+    _active_workers = v;\n+    add_workers(false \/* initializing *\/);\n@@ -144,6 +152,0 @@\n-  \/\/ Add GC workers as needed.\n-  void add_workers(bool initializing);\n-\n-  \/\/ Add GC workers as needed to reach the specified number of workers.\n-  void add_workers(uint active_workers, bool initializing);\n-\n@@ -151,1 +153,1 @@\n-  AbstractGangWorker* worker(uint i) const;\n+  GangWorker* worker(uint i) const;\n@@ -159,1 +161,1 @@\n-  virtual AbstractGangWorker* install_worker(uint which);\n+  virtual GangWorker* install_worker(uint which);\n@@ -164,22 +166,0 @@\n- protected:\n-  virtual AbstractGangWorker* allocate_worker(uint which) = 0;\n-};\n-\n-\/\/ An class representing a gang of workers.\n-class WorkGang: public AbstractWorkGang {\n-  \/\/ To get access to the GangTaskDispatcher instance.\n-  friend class GangWorker;\n-\n-  GangTaskDispatcher* const _dispatcher;\n-  GangTaskDispatcher* dispatcher() const {\n-    return _dispatcher;\n-  }\n-\n-public:\n-  WorkGang(const char* name,\n-           uint workers,\n-           bool are_GC_task_threads,\n-           bool are_ConcurrentGC_threads);\n-\n-  ~WorkGang();\n-\n@@ -187,1 +167,2 @@\n-  virtual void run_task(AbstractGangTask* task);\n+  void run_task(AbstractGangTask* task);\n+\n@@ -194,3 +175,0 @@\n-\n-protected:\n-  virtual AbstractGangWorker* allocate_worker(uint which);\n@@ -204,1 +182,1 @@\n-  AbstractWorkGang* const _gang;\n+  WorkGang* const _gang;\n@@ -208,1 +186,1 @@\n-  WithUpdatedActiveWorkers(AbstractWorkGang* gang, uint requested_num_workers) :\n+  WithUpdatedActiveWorkers(WorkGang* gang, uint requested_num_workers) :\n@@ -221,21 +199,3 @@\n-class AbstractGangWorker: public WorkerThread {\n-public:\n-  AbstractGangWorker(AbstractWorkGang* gang, uint id);\n-\n-  \/\/ The only real method: run a task for the gang.\n-  virtual void run();\n-  \/\/ Predicate for Thread\n-  virtual bool is_GC_task_thread() const;\n-  virtual bool is_ConcurrentGC_thread() const;\n-  \/\/ Printing\n-  void print_on(outputStream* st) const;\n-  virtual void print() const;\n-\n-protected:\n-  AbstractWorkGang* _gang;\n-\n-  virtual void initialize();\n-  virtual void loop() = 0;\n-\n-  AbstractWorkGang* gang() const { return _gang; }\n-};\n+class GangWorker: public WorkerThread {\n+private:\n+  WorkGang* _gang;\n@@ -243,3 +203,2 @@\n-class GangWorker: public AbstractGangWorker {\n-public:\n-  GangWorker(WorkGang* gang, uint id) : AbstractGangWorker(gang, id) {}\n+  void initialize();\n+  void loop();\n@@ -247,2 +206,1 @@\n-protected:\n-  virtual void loop();\n+  WorkGang* gang() const { return _gang; }\n@@ -250,1 +208,0 @@\n-private:\n@@ -255,1 +212,10 @@\n-  WorkGang* gang() const { return (WorkGang*)_gang; }\n+protected:\n+  \/\/ The only real method: run a task for the gang.\n+  void run() override;\n+\n+public:\n+  GangWorker(WorkGang* gang, uint id);\n+\n+  \/\/ Predicate for Thread\n+  bool is_GC_task_thread() const override { return gang()->are_GC_task_threads(); }\n+  bool is_ConcurrentGC_thread() const override { return gang()->are_ConcurrentGC_threads(); }\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":50,"deletions":84,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-AbstractGangWorker* ShenandoahWorkGang::install_worker(uint which) {\n-  AbstractGangWorker* worker = WorkGang::install_worker(which);\n+GangWorker* ShenandoahWorkGang::install_worker(uint which) {\n+  GangWorker* worker = WorkGang::install_worker(which);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,11 +67,1 @@\n-  AbstractGangWorker* install_worker(uint which);\n-\n-  \/\/ We allow _active_workers < _total_workers when UseDynamicNumberOfGCThreads is off.\n-  \/\/ We use the same WorkGang for concurrent and parallel processing, and honor\n-  \/\/ ConcGCThreads and ParallelGCThreads settings\n-  virtual uint active_workers() const {\n-    assert(_active_workers > 0, \"no active worker\");\n-    assert(_active_workers <= _total_workers,\n-           \"_active_workers: %u > _total_workers: %u\", _active_workers, _total_workers);\n-    return _active_workers;\n-  }\n+  GangWorker* install_worker(uint which);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}