{"files":[{"patch":"@@ -704,3 +704,7 @@\n-        if (minWidth == maxWidth && decimalPoint == false) {\n-            \/\/ adjacent parsing\n-            appendValue(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n+        if (field == NANO_OF_SECOND) {\n+            if (minWidth == maxWidth && decimalPoint == false) {\n+                \/\/ adjacent parsing\n+                appendValue(new NanosPrinterParser(minWidth, maxWidth, decimalPoint));\n+            } else {\n+                appendInternal(new NanosPrinterParser(minWidth, maxWidth, decimalPoint));\n+            }\n@@ -708,1 +712,6 @@\n-            appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n+            if (minWidth == maxWidth && decimalPoint == false) {\n+                \/\/ adjacent parsing\n+                appendValue(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n+            } else {\n+                appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n+            }\n@@ -2761,0 +2770,18 @@\n+        \/*\n+         * Copied from Long.stringSize\n+         *\/\n+        private static int stringSize(long x) {\n+            int d = 1;\n+            if (x >= 0) {\n+                d = 0;\n+                x = -x;\n+            }\n+            long p = -10;\n+            for (int i = 1; i < 19; i++) {\n+                if (x > p)\n+                    return i + d;\n+                p = 10 * p;\n+            }\n+            return 19 + d;\n+        }\n+\n@@ -2769,2 +2796,6 @@\n-            String str = (value == Long.MIN_VALUE ? \"9223372036854775808\" : Long.toString(Math.abs(value)));\n-            if (str.length() > maxWidth) {\n+            int size = stringSize(value);\n+            if (value < 0) {\n+                size--;\n+            }\n+\n+            if (size > maxWidth) {\n@@ -2775,1 +2806,0 @@\n-            str = decimalStyle.convertNumberToI18N(str);\n@@ -2780,1 +2810,1 @@\n-                        if (minWidth < 19 && value >= EXCEED_POINTS[minWidth]) {\n+                        if (minWidth < 19 && size > minWidth) {\n@@ -2796,2 +2826,9 @@\n-            for (int i = 0; i < minWidth - str.length(); i++) {\n-                buf.append(decimalStyle.getZeroDigit());\n+            char zeroDigit = decimalStyle.getZeroDigit();\n+            for (int i = 0; i < minWidth - size; i++) {\n+                buf.append(zeroDigit);\n+            }\n+            if (zeroDigit == '0' && value != Long.MIN_VALUE) {\n+                buf.append(Math.abs(value));\n+            } else {\n+                String str = value == Long.MIN_VALUE ? \"9223372036854775808\" : Long.toString(Math.abs(value));\n+                buf.append(decimalStyle.convertNumberToI18N(str));\n@@ -2799,1 +2836,0 @@\n-            buf.append(str);\n@@ -3114,0 +3150,202 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Prints and parses a NANO_OF_SECOND field with optional padding.\n+     *\/\n+    static final class NanosPrinterParser extends NumberPrinterParser {\n+        private final boolean decimalPoint;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param minWidth  the minimum width to output, from 0 to 9\n+         * @param maxWidth  the maximum width to output, from 0 to 9\n+         * @param decimalPoint  whether to output the localized decimal point symbol\n+         *\/\n+        NanosPrinterParser(int minWidth, int maxWidth, boolean decimalPoint) {\n+            this(minWidth, maxWidth, decimalPoint, 0);\n+            if (minWidth < 0 || minWidth > 9) {\n+                throw new IllegalArgumentException(\"Minimum width must be from 0 to 9 inclusive but was \" + minWidth);\n+            }\n+            if (maxWidth < 1 || maxWidth > 9) {\n+                throw new IllegalArgumentException(\"Maximum width must be from 1 to 9 inclusive but was \" + maxWidth);\n+            }\n+            if (maxWidth < minWidth) {\n+                throw new IllegalArgumentException(\"Maximum width must exceed or equal the minimum width but \" +\n+                        maxWidth + \" < \" + minWidth);\n+            }\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param minWidth  the minimum width to output, from 0 to 9\n+         * @param maxWidth  the maximum width to output, from 0 to 9\n+         * @param decimalPoint  whether to output the localized decimal point symbol\n+         * @param subsequentWidth the subsequentWidth for this instance\n+         *\/\n+        NanosPrinterParser(int minWidth, int maxWidth, boolean decimalPoint, int subsequentWidth) {\n+            super(NANO_OF_SECOND, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth);\n+            this.decimalPoint = decimalPoint;\n+        }\n+\n+        \/**\n+         * Returns a new instance with fixed width flag set.\n+         *\n+         * @return a new updated printer-parser, not null\n+         *\/\n+        @Override\n+        NanosPrinterParser withFixedWidth() {\n+            if (subsequentWidth == -1) {\n+                return this;\n+            }\n+            return new NanosPrinterParser(minWidth, maxWidth, decimalPoint, -1);\n+        }\n+\n+        \/**\n+         * Returns a new instance with an updated subsequent width.\n+         *\n+         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater\n+         * @return a new updated printer-parser, not null\n+         *\/\n+        @Override\n+        NanosPrinterParser withSubsequentWidth(int subsequentWidth) {\n+            return new NanosPrinterParser(minWidth, maxWidth, decimalPoint, this.subsequentWidth + subsequentWidth);\n+        }\n+\n+        \/**\n+         * For NanosPrinterParser, the width is fixed if context is strict,\n+         * minWidth equal to maxWidth and decimalpoint is absent.\n+         * @param context the context\n+         * @return if the field is fixed width\n+         * @see #appendFraction(java.time.temporal.TemporalField, int, int, boolean)\n+         *\/\n+        @Override\n+        boolean isFixedWidth(DateTimeParseContext context) {\n+            if (context.isStrict() && minWidth == maxWidth && decimalPoint == false) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        \/\/ Simplified variant of Integer.stringSize that assumes positive values\n+        private static int stringSize(int x) {\n+            int p = 10;\n+            for (int i = 1; i < 10; i++) {\n+                if (x < p)\n+                    return i;\n+                p = 10 * p;\n+            }\n+            return 10;\n+        }\n+\n+        private static final int[] TENS = new int[] {\n+            1,\n+            10,\n+            100,\n+            1000,\n+            10000,\n+            100000,\n+            1000000,\n+            10000000,\n+            100000000\n+        };\n+\n+        @Override\n+        public boolean format(DateTimePrintContext context, StringBuilder buf) {\n+            Long value = context.getValue(field);\n+            if (value == null) {\n+                return false;\n+            }\n+            int val = field.range().checkValidIntValue(value, field);\n+            DecimalStyle decimalStyle = context.getDecimalStyle();\n+            int stringSize = stringSize(val);\n+            char zero = decimalStyle.getZeroDigit();\n+            if (val == 0 || stringSize < 10 - maxWidth) {\n+                \/\/ 0 or would round down to 0\n+                \/\/ to get output identical to FractionPrinterParser use minWidth if the\n+                \/\/ value is zero, maxWidth otherwise\n+                int width = val == 0 ? minWidth : maxWidth;\n+                if (width > 0) {\n+                    if (decimalPoint) {\n+                        buf.append(decimalStyle.getDecimalSeparator());\n+                    }\n+                    for (int i = 0; i < width; i++) {\n+                        buf.append(zero);\n+                    }\n+                }\n+            } else {\n+                if (decimalPoint) {\n+                    buf.append(decimalStyle.getDecimalSeparator());\n+                }\n+                \/\/ add leading zeros\n+                for (int i = 9 - stringSize; i > 0; i--) {\n+                    buf.append(zero);\n+                }\n+                \/\/ truncate unwanted digits\n+                if (maxWidth < 9) {\n+                    val \/= TENS[9 - maxWidth];\n+                }\n+                \/\/ truncate zeros\n+                for (int i = maxWidth; i > minWidth; i--) {\n+                    if ((val % 10) != 0) {\n+                        break;\n+                    }\n+                    val \/= 10;\n+                }\n+                if (zero == '0') {\n+                    buf.append(val);\n+                } else {\n+                    buf.append(decimalStyle.convertNumberToI18N(Integer.toString(val)));\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public int parse(DateTimeParseContext context, CharSequence text, int position) {\n+            int effectiveMin = (context.isStrict() || isFixedWidth(context) ? minWidth : 0);\n+            int effectiveMax = (context.isStrict() || isFixedWidth(context) ? maxWidth : 9);\n+            int length = text.length();\n+            if (position == length) {\n+                \/\/ valid if whole field is optional, invalid if minimum width\n+                return (effectiveMin > 0 ? ~position : position);\n+            }\n+            if (decimalPoint) {\n+                if (text.charAt(position) != context.getDecimalStyle().getDecimalSeparator()) {\n+                    \/\/ valid if whole field is optional, invalid if minimum width\n+                    return (effectiveMin > 0 ? ~position : position);\n+                }\n+                position++;\n+            }\n+            int minEndPos = position + effectiveMin;\n+            if (minEndPos > length) {\n+                return ~position;  \/\/ need at least min width digits\n+            }\n+            int maxEndPos = Math.min(position + effectiveMax, length);\n+            int total = 0;  \/\/ can use int because we are only parsing up to 9 digits\n+            int pos = position;\n+            while (pos < maxEndPos) {\n+                char ch = text.charAt(pos);\n+                int digit = context.getDecimalStyle().convertToDigit(ch);\n+                if (digit < 0) {\n+                    if (pos < minEndPos) {\n+                        return ~position;  \/\/ need at least min width digits\n+                    }\n+                    break;\n+                }\n+                pos++;\n+                total = total * 10 + digit;\n+            }\n+            for (int i = 9 - (pos - position); i > 0; i--) {\n+                total *= 10;\n+            }\n+            return context.setParsedField(field, total, position, pos);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String decimal = (decimalPoint ? \",DecimalPoint\" : \"\");\n+            return \"Fraction(\" + field + \",\" + minWidth + \",\" + maxWidth + decimal + \")\";\n+        }\n+    }\n+\n@@ -3120,0 +3358,2 @@\n+        private final BigDecimal minBD;\n+        private final BigDecimal rangeBD;\n@@ -3159,0 +3399,3 @@\n+            ValueRange range = field.range();\n+            this.minBD = BigDecimal.valueOf(range.getMinimum());\n+            this.rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);\n@@ -3220,2 +3463,0 @@\n-                String str = fraction.toPlainString().substring(2);\n-                str = decimalStyle.convertNumberToI18N(str);\n@@ -3225,1 +3466,3 @@\n-                buf.append(str);\n+                String str = fraction.toPlainString();\n+                str = decimalStyle.convertNumberToI18N(str);\n+                buf.append(str, 2, str.length());\n@@ -3287,4 +3530,1 @@\n-            ValueRange range = field.range();\n-            range.checkValidValue(value, field);\n-            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());\n-            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);\n+            field.range().checkValidValue(value, field);\n@@ -3314,3 +3554,0 @@\n-            ValueRange range = field.range();\n-            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());\n-            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":258,"deletions":21,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    private TemporalAccessor temporal;\n+    private final TemporalAccessor temporal;\n@@ -105,1 +105,1 @@\n-    private DateTimeFormatter formatter;\n+    private final DateTimeFormatter formatter;\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimePrintContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n- * @bug 8230136\n+ * @bug 8230136 8276220\n@@ -128,0 +128,25 @@\n+            {0, 9, 9,           \".000000009\"},\n+            {0, 9, 99,          \".000000099\"},\n+            {0, 9, 999,         \".000000999\"},\n+            {0, 9, 9999,        \".000009999\"},\n+            {0, 9, 99999,       \".000099999\"},\n+            {0, 9, 999999,      \".000999999\"},\n+            {0, 9, 9999999,     \".009999999\"},\n+            {0, 9, 99999999,    \".099999999\"},\n+            {0, 9, 999999999,   \".999999999\"},\n+            {0, 8, 9,           \".00000000\"},\n+            {0, 7, 99,          \".0000000\"},\n+            {0, 6, 999,         \".000000\"},\n+            {0, 5, 9999,        \".00000\"},\n+            {0, 4, 99999,       \".0000\"},\n+            {0, 3, 999999,      \".000\"},\n+            {0, 2, 9999999,     \".00\"},\n+            {0, 1, 99999999,    \".0\"},\n+            {0, 8, 1,           \".00000000\"},\n+            {0, 7, 11,          \".0000000\"},\n+            {0, 6, 111,         \".000000\"},\n+            {0, 5, 1111,        \".00000\"},\n+            {0, 4, 11111,       \".0000\"},\n+            {0, 3, 111111,      \".000\"},\n+            {0, 2, 1111111,     \".00\"},\n+            {0, 1, 11111111,    \".0\"},\n@@ -139,0 +164,18 @@\n+            {1, 9, 1,           \".000000001\"},\n+            {1, 9, 10,          \".00000001\"},\n+            {1, 9, 100,         \".0000001\"},\n+            {1, 9, 1000,        \".000001\"},\n+            {1, 9, 10000,       \".00001\"},\n+            {1, 9, 100000,      \".0001\"},\n+            {1, 9, 1000000,     \".001\"},\n+            {1, 9, 10000000,    \".01\"},\n+            {1, 9, 100000000,   \".1\"},\n+            {1, 9, 9,           \".000000009\"},\n+            {1, 9, 99,          \".000000099\"},\n+            {1, 9, 999,         \".000000999\"},\n+            {1, 9, 9999,        \".000009999\"},\n+            {1, 9, 99999,       \".000099999\"},\n+            {1, 9, 999999,      \".000999999\"},\n+            {1, 9, 9999999,     \".009999999\"},\n+            {1, 9, 99999999,    \".099999999\"},\n+            {1, 9, 999999999,   \".999999999\"},\n@@ -179,0 +222,3 @@\n+            {7, 7, 123456789,   \".1234567\"},\n+            {8, 8, 123456789,   \".12345678\"},\n+            {9, 9, 123456789,   \".123456789\"},\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestFractionPrinterParser.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+package org.openjdk.bench.java.time.format;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class DateTimeFormatterBench {\n+\n+    private static final TimeZone TIME_ZONE = TimeZone.getTimeZone(\"UTC\");\n+\n+    private static final Instant[] INSTANTS = createInstants();\n+\n+    private static final ZonedDateTime[] ZONED_DATE_TIMES = createZonedDateTimes();\n+\n+    @Param({\n+            \"HH:mm:ss\",\n+            \"HH:mm:ss.SSS\",\n+            \"yyyy-MM-dd'T'HH:mm:ss\",\n+            \"yyyy-MM-dd'T'HH:mm:ss.SSS\"\n+    })\n+    public String pattern;\n+\n+    private static Instant[] createInstants() {\n+        \/\/ Various instants during the same day\n+        final Instant loInstant = Instant.EPOCH.plus(Duration.ofDays(365*50)); \/\/ 2020-01-01\n+        final Instant hiInstant = loInstant.plus(Duration.ofDays(1));\n+        final long maxOffsetNanos = Duration.between(loInstant, hiInstant).toNanos();\n+        final Random random = new Random(0);\n+        return IntStream\n+                .range(0, 1_000)\n+                .mapToObj(ignored -> {\n+                    final long offsetNanos = (long) Math.floor(random.nextDouble() * maxOffsetNanos);\n+                    return loInstant.plus(offsetNanos, ChronoUnit.NANOS);\n+                })\n+                .toArray(Instant[]::new);\n+    }\n+\n+    private static ZonedDateTime[] createZonedDateTimes() {\n+        return Stream.of(INSTANTS)\n+                .map(instant -> ZonedDateTime.ofInstant(instant, TIME_ZONE.toZoneId()))\n+                .toArray(ZonedDateTime[]::new);\n+    }\n+\n+    private StringBuilder stringBuilder = new StringBuilder(100);\n+    private DateTimeFormatter dateTimeFormatter;\n+\n+    @Setup\n+    public void setup() {\n+        dateTimeFormatter = DateTimeFormatter\n+                .ofPattern(pattern, Locale.US)\n+                .withZone(TIME_ZONE.toZoneId());\n+    }\n+\n+    @Benchmark\n+    public void formatInstants(final Blackhole blackhole) {\n+        for (final Instant instant : INSTANTS) {\n+            stringBuilder.setLength(0);\n+            dateTimeFormatter.formatTo(instant, stringBuilder);\n+            blackhole.consume(stringBuilder);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void formatZonedDateTime(final Blackhole blackhole) {\n+        for (final ZonedDateTime zonedDateTime : ZONED_DATE_TIMES) {\n+            stringBuilder.setLength(0);\n+            dateTimeFormatter.formatTo(zonedDateTime, stringBuilder);\n+            blackhole.consume(stringBuilder);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/format\/DateTimeFormatterBench.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}