{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  if (SystemDictionary::java_system_loader() == NULL) {\n+  if (SystemDictionary::java_system_loader() == nullptr) {\n@@ -72,1 +72,1 @@\n-  if (sl_handle != NULL || !load) {\n+  if (sl_handle != nullptr || !load) {\n@@ -77,2 +77,2 @@\n-  path = NULL;\n-  if (_shared_library_handle == NULL) {\n+  path = nullptr;\n+  if (_shared_library_handle == nullptr) {\n@@ -81,1 +81,1 @@\n-    if (JVMCILibPath != NULL) {\n+    if (JVMCILibPath != nullptr) {\n@@ -92,1 +92,1 @@\n-    if (handle == NULL) {\n+    if (handle == nullptr) {\n@@ -106,1 +106,1 @@\n-    JNIJVMCI::initialize_ids(NULL);\n+    JNIJVMCI::initialize_ids(nullptr);\n@@ -178,1 +178,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -180,1 +180,1 @@\n-      if (state != NULL) {\n+      if (state != nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  \/\/ never returns nullptr.\n+  \/\/ never returns null.\n@@ -101,1 +101,1 @@\n-  \/\/ Gets the Thread* value for the current thread or NULL if it's not available.\n+  \/\/ Gets the Thread* value for the current thread or null if it's not available.\n@@ -133,1 +133,1 @@\n-  \/\/ Gets the name of the opened JVMCI shared library crash data file or NULL\n+  \/\/ Gets the name of the opened JVMCI shared library crash data file or null\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (mtJVMCI) ConstantOopWriteValue(NULL);\n+ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (mtJVMCI) ConstantOopWriteValue(nullptr);\n@@ -255,1 +255,1 @@\n-    if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {\n+    if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == nullptr) {\n@@ -380,1 +380,1 @@\n-    JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly NULL\", Handle());\n+    JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly null\", Handle());\n@@ -388,1 +388,1 @@\n-  second = NULL;\n+  second = nullptr;\n@@ -487,1 +487,1 @@\n-    ScopeValue* cur_second = NULL;\n+    ScopeValue* cur_second = nullptr;\n@@ -509,1 +509,1 @@\n-    if (isLongArray && cur_second == NULL) {\n+    if (isLongArray && cur_second == nullptr) {\n@@ -515,1 +515,1 @@\n-    if (isByteArray && cur_second != NULL && (type == T_DOUBLE || type == T_LONG)) {\n+    if (isByteArray && cur_second != nullptr && (type == T_DOUBLE || type == T_LONG)) {\n@@ -518,1 +518,1 @@\n-      cur_second = NULL;\n+      cur_second = nullptr;\n@@ -521,1 +521,1 @@\n-    if (cur_second != NULL) {\n+    if (cur_second != nullptr) {\n@@ -524,1 +524,1 @@\n-    assert(value != NULL, \"missing value\");\n+    assert(value != nullptr, \"missing value\");\n@@ -576,1 +576,1 @@\n-    ScopeValue* second = NULL;\n+    ScopeValue* second = nullptr;\n@@ -578,1 +578,1 @@\n-    assert(second == NULL, \"monitor cannot occupy two stack slots\");\n+    assert(second == nullptr, \"monitor cannot occupy two stack slots\");\n@@ -592,1 +592,1 @@\n-  CompilerThread* compilerThread = thread->is_Compiler_thread() ? CompilerThread::cast(thread) : NULL;\n+  CompilerThread* compilerThread = thread->is_Compiler_thread() ? CompilerThread::cast(thread) : nullptr;\n@@ -594,1 +594,1 @@\n-  _dependencies = new Dependencies(&_arena, _oop_recorder, compilerThread != NULL ? compilerThread->log() : NULL);\n+  _dependencies = new Dependencies(&_arena, _oop_recorder, compilerThread != nullptr ? compilerThread->log() : nullptr);\n@@ -717,1 +717,1 @@\n-    if (compile_state != NULL) {\n+    if (compile_state != nullptr) {\n@@ -731,1 +731,1 @@\n-    nmethod* nm = NULL; \/\/ nm is an out parameter of register_method\n+    nmethod* nm = nullptr; \/\/ nm is an out parameter of register_method\n@@ -757,1 +757,1 @@\n-      if (compile_state == NULL) {\n+      if (compile_state == nullptr) {\n@@ -766,1 +766,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -864,1 +864,1 @@\n-  if (buffer.blob() == NULL) {\n+  if (buffer.blob() == nullptr) {\n@@ -1020,1 +1020,1 @@\n-  GrowableArray<ScopeValue*> *objects = new GrowableArray<ScopeValue*>(length, length, NULL);\n+  GrowableArray<ScopeValue*> *objects = new GrowableArray<ScopeValue*>(length, length, nullptr);\n@@ -1079,3 +1079,3 @@\n-      DebugToken* locals_token = NULL;\n-      DebugToken* stack_token = NULL;\n-      DebugToken* monitors_token = NULL;\n+      DebugToken* locals_token = nullptr;\n+      DebugToken* stack_token = nullptr;\n+      DebugToken* monitors_token = nullptr;\n@@ -1103,1 +1103,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-JVMCICompiler* JVMCICompiler::_instance = NULL;\n+JVMCICompiler* JVMCICompiler::_instance = nullptr;\n@@ -43,1 +43,1 @@\n-  assert(_instance == NULL, \"only one instance allowed\");\n+  assert(_instance == nullptr, \"only one instance allowed\");\n@@ -51,1 +51,1 @@\n-  if (_instance == NULL && require_non_null) {\n+  if (_instance == nullptr && require_non_null) {\n@@ -130,1 +130,1 @@\n-    if (runtime != NULL) {\n+    if (runtime != nullptr) {\n@@ -135,1 +135,1 @@\n-      JVMCIEnv* ignored_env = NULL;\n+      JVMCIEnv* ignored_env = nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -80,1 +80,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -130,1 +130,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -151,1 +151,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -159,1 +159,1 @@\n-#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)\n+#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, nullptr)\n@@ -202,1 +202,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -332,1 +332,1 @@\n-  oop mirror = NULL;\n+  oop mirror = nullptr;\n@@ -350,1 +350,1 @@\n-  Method* method = NULL;\n+  Method* method = nullptr;\n@@ -362,1 +362,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -371,1 +371,1 @@\n-  ConstantPool* cp = NULL;\n+  ConstantPool* cp = nullptr;\n@@ -422,1 +422,1 @@\n-  assert (klass == NULL || klass->is_klass(), \"invalid read\");\n+  assert (klass == nullptr || klass->is_klass(), \"invalid read\");\n@@ -837,1 +837,1 @@\n-      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.\n+      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns null in this case.\n@@ -866,1 +866,1 @@\n-    \/\/ Return NULL if there was a problem with lookup (uninitialized class, etc.)\n+    \/\/ Return null if there was a problem with lookup (uninitialized class, etc.)\n@@ -940,1 +940,1 @@\n-  CodeBlob* cb = NULL;\n+  CodeBlob* cb = nullptr;\n@@ -980,1 +980,1 @@\n-    assert(cb == NULL, \"should be\");\n+    assert(cb == nullptr, \"should be\");\n@@ -1009,1 +1009,1 @@\n-  if (installedCode == NULL) {\n+  if (installedCode == nullptr) {\n@@ -1015,2 +1015,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -1030,1 +1030,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1054,1 +1054,1 @@\n-  if (nm == NULL || !nm->is_in_use()) {\n+  if (nm == nullptr || !nm->is_in_use()) {\n@@ -1067,1 +1067,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1097,1 +1097,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1137,1 +1137,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1143,1 +1143,1 @@\n-  if (code != NULL) {\n+  if (code != nullptr) {\n@@ -1148,1 +1148,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -1197,1 +1197,1 @@\n-  return mdo != NULL && mdo->is_mature();\n+  return mdo != nullptr && mdo->is_mature();\n@@ -1202,1 +1202,1 @@\n-  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;\n+  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != nullptr;\n@@ -1224,1 +1224,1 @@\n-    Method* resolved_method = NULL;\n+    Method* resolved_method = nullptr;\n@@ -1240,1 +1240,1 @@\n-  if (resolved_methods == NULL) {\n+  if (resolved_methods == nullptr) {\n@@ -1244,1 +1244,1 @@\n-  assert(method != NULL, \"method should not be NULL\");\n+  assert(method != nullptr, \"method should not be nullptr\");\n@@ -1262,1 +1262,1 @@\n-  Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();\n+  Klass* recvrKlass = receiver.is_null() ? (Klass*)nullptr : receiver->klass();\n@@ -1295,1 +1295,1 @@\n- * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or null if none.\n@@ -1298,1 +1298,1 @@\n-  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  GrowableArray<ScopeValue*>* unallocated = nullptr;\n@@ -1302,1 +1302,1 @@\n-      if (unallocated == NULL) {\n+      if (unallocated == nullptr) {\n@@ -1314,1 +1314,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1325,1 +1325,1 @@\n-  GrowableArray<Method*>* resolved_methods = NULL;\n+  GrowableArray<Method*>* resolved_methods = nullptr;\n@@ -1332,1 +1332,1 @@\n-    compiledVFrame* prev_cvf = NULL;\n+    compiledVFrame* prev_cvf = nullptr;\n@@ -1340,1 +1340,1 @@\n-      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+      if (methods == nullptr || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n@@ -1346,1 +1346,1 @@\n-        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+        if (prev_cvf != nullptr && prev_cvf->frame_pointer()->id() == frame_id) {\n@@ -1353,1 +1353,1 @@\n-        StackValueCollection* locals = NULL;\n+        StackValueCollection* locals = nullptr;\n@@ -1361,1 +1361,1 @@\n-          if (scope != NULL && scope->objects() != NULL) {\n+          if (scope != nullptr && scope->objects() != nullptr) {\n@@ -1364,1 +1364,1 @@\n-            GrowableArray<ScopeValue*>* objects = NULL;\n+            GrowableArray<ScopeValue*>* objects = nullptr;\n@@ -1372,1 +1372,1 @@\n-            if (objects != NULL) {\n+            if (objects != nullptr) {\n@@ -1437,1 +1437,1 @@\n-        if (result.get_oop() != NULL) {\n+        if (result.get_oop() != nullptr) {\n@@ -1442,2 +1442,2 @@\n-          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n-            resolved_methods = NULL;\n+          if (resolved_methods != nullptr && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = nullptr;\n@@ -1449,1 +1449,1 @@\n-          prev_cvf = NULL;\n+          prev_cvf = nullptr;\n@@ -1458,1 +1458,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1506,1 +1506,1 @@\n-      vmassert(cp_cache_entry->appendix_if_resolved(cp) == NULL, \"!\");\n+      vmassert(cp_cache_entry->appendix_if_resolved(cp) == nullptr, \"!\");\n@@ -1598,1 +1598,1 @@\n-  assert (virtualFrames->at(last_frame_number)->scope() != NULL,\"invalid scope\");\n+  assert (virtualFrames->at(last_frame_number)->scope() != nullptr,\"invalid scope\");\n@@ -1601,1 +1601,1 @@\n-  if (objects == NULL) {\n+  if (objects == nullptr) {\n@@ -1614,1 +1614,1 @@\n-    if (locals != NULL) {\n+    if (locals != nullptr) {\n@@ -1627,1 +1627,1 @@\n-    if (expressions != NULL) {\n+    if (expressions != nullptr) {\n@@ -1640,1 +1640,1 @@\n-    if (monitors != NULL) {\n+    if (monitors != nullptr) {\n@@ -1648,1 +1648,1 @@\n-  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);\n+  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, nullptr);\n@@ -1739,1 +1739,1 @@\n-  if (component_klass != NULL) {\n+  if (component_klass != nullptr) {\n@@ -1772,1 +1772,1 @@\n-  if (bytecode_frame_handle == NULL) {\n+  if (bytecode_frame_handle == nullptr) {\n@@ -1831,1 +1831,1 @@\n-  return (StringTable::lookup(name, len) != NULL);\n+  return (StringTable::lookup(name, len) != nullptr);\n@@ -1836,1 +1836,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1843,1 +1843,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1850,1 +1850,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1856,1 +1856,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1861,2 +1861,2 @@\n-  Klass* box_klass = NULL;\n-  Symbol* box_signature = NULL;\n+  Klass* box_klass = nullptr;\n+  Symbol* box_signature = nullptr;\n@@ -2059,1 +2059,1 @@\n-  \/\/ asConstant will throw an NPE if a constant contains NULL\n+  \/\/ asConstant will throw an NPE if a constant contains null\n@@ -2076,1 +2076,1 @@\n-  if (object == NULL || klass == nullptr) {\n+  if (object == nullptr || klass == nullptr) {\n@@ -2105,1 +2105,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2120,1 +2120,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2125,1 +2125,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2136,1 +2136,1 @@\n-  if (x == NULL || y == NULL) {\n+  if (x == nullptr || y == nullptr) {\n@@ -2154,1 +2154,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2166,1 +2166,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2174,1 +2174,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2201,1 +2201,1 @@\n-  return NULL;;\n+  return nullptr;;\n@@ -2241,1 +2241,1 @@\n-    if (sl_handle == NULL) {\n+    if (sl_handle == nullptr) {\n@@ -2246,1 +2246,1 @@\n-  if (mirror == NULL) {\n+  if (mirror == nullptr) {\n@@ -2250,1 +2250,1 @@\n-  if (klass == NULL || !klass->is_instance_klass()) {\n+  if (klass == nullptr || !klass->is_instance_klass()) {\n@@ -2267,1 +2267,1 @@\n-      guarantee(pure_name != NULL, \"Illegal native method name encountered\");\n+      guarantee(pure_name != nullptr, \"Illegal native method name encountered\");\n@@ -2274,1 +2274,1 @@\n-      if (entry == NULL) {\n+      if (entry == nullptr) {\n@@ -2278,1 +2278,1 @@\n-        guarantee(long_name != NULL, \"Illegal native method name encountered\");\n+        guarantee(long_name != nullptr, \"Illegal native method name encountered\");\n@@ -2285,1 +2285,1 @@\n-        if (entry == NULL) {\n+        if (entry == nullptr) {\n@@ -2330,1 +2330,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -2489,1 +2489,1 @@\n-  if (obj_handle == NULL) {\n+  if (obj_handle == nullptr) {\n@@ -2516,1 +2516,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -2518,1 +2518,1 @@\n-        if (data != NULL) {\n+        if (data != nullptr) {\n@@ -2522,1 +2522,1 @@\n-          if (nmethod_mirror != NULL) {\n+          if (nmethod_mirror != nullptr) {\n@@ -2535,1 +2535,1 @@\n-      const char* cstring = name_string.is_null() ? NULL : thisEnv->as_utf8_string(name_string);\n+      const char* cstring = name_string.is_null() ? nullptr : thisEnv->as_utf8_string(name_string);\n@@ -2541,1 +2541,1 @@\n-      } else if (nm == NULL) {\n+      } else if (nm == nullptr) {\n@@ -2549,1 +2549,1 @@\n-          if (data == NULL) {\n+          if (data == nullptr) {\n@@ -2552,1 +2552,1 @@\n-          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != NULL) {\n+          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != nullptr) {\n@@ -2577,1 +2577,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2596,2 +2596,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -2646,1 +2646,1 @@\n-  for (FailedSpeculation* fs = head; fs != NULL; fs = fs->next()) {\n+  for (FailedSpeculation* fs = head; fs != nullptr; fs = fs->next()) {\n@@ -2650,2 +2650,2 @@\n-  JVMCIObjectArray current_array = NULL;\n-  if (current != NULL) {\n+  JVMCIObjectArray current_array = nullptr;\n+  if (current != nullptr) {\n@@ -2662,1 +2662,1 @@\n-    assert(fs != NULL, \"npe\");\n+    assert(fs != nullptr, \"npe\");\n@@ -2678,1 +2678,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -2695,1 +2695,1 @@\n-  return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n+  return FailedSpeculation::add_failed_speculation(nullptr, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":102,"deletions":102,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-    assert(base != NULL, \"unexpected byte_map_base\");\n+    assert(base != nullptr, \"unexpected byte_map_base\");\n@@ -155,1 +155,1 @@\n-  if (StubRoutines::name() != NULL) {                           \\\n+  if (StubRoutines::name() != nullptr) {                        \\\n@@ -266,1 +266,1 @@\n-    if (e == NULL) { \\\n+    if (e == nullptr) { \\\n@@ -278,1 +278,1 @@\n-    if (value != NULL) { \\\n+    if (value != nullptr) { \\\n@@ -280,1 +280,1 @@\n-      if (e == NULL) { \\\n+      if (e == nullptr) { \\\n@@ -317,1 +317,1 @@\n-    if (vmField.isStatic && vmField.typeString != NULL) {\n+    if (vmField.isStatic && vmField.typeString != nullptr) {\n@@ -384,1 +384,1 @@\n-  assert(flag != NULL, \"No such flag named \" #name); \\\n+  assert(flag != nullptr, \"No such flag named \" #name); \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-  _failure_reason(NULL),\n+  _failure_reason(nullptr),\n@@ -64,1 +64,1 @@\n-  _target_method_is_old                 = _task != NULL && _task->method()->is_old();\n+  _target_method_is_old                 = _task != nullptr && _task->method()->is_old();\n@@ -176,2 +176,2 @@\n-  assert(thread != NULL, \"npe\");\n-  _env = NULL;\n+  assert(thread != nullptr, \"npe\");\n+  _env = nullptr;\n@@ -187,1 +187,1 @@\n-  if (parent_env != NULL) {\n+  if (parent_env != nullptr) {\n@@ -197,1 +197,1 @@\n-    assert(_runtime != NULL, \"npe\");\n+    assert(_runtime != nullptr, \"npe\");\n@@ -209,1 +209,1 @@\n-  if (_env != NULL) {\n+  if (_env != nullptr) {\n@@ -214,1 +214,1 @@\n-    if (parent_env != NULL) {\n+    if (parent_env != nullptr) {\n@@ -226,1 +226,1 @@\n-      attach_args.group = NULL;\n+      attach_args.group = nullptr;\n@@ -231,1 +231,1 @@\n-        _env = NULL;\n+        _env = nullptr;\n@@ -240,1 +240,1 @@\n-  assert(_env != NULL, \"missing env\");\n+  assert(_env != nullptr, \"missing env\");\n@@ -257,1 +257,1 @@\n-  init_env_mode_runtime(thread, NULL, false);\n+  init_env_mode_runtime(thread, nullptr, false);\n@@ -264,2 +264,2 @@\n-    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(NULL) {\n-  init_env_mode_runtime(thread, NULL);\n+    _throw_to_caller(false), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n+  init_env_mode_runtime(thread, nullptr);\n@@ -269,1 +269,1 @@\n-    _throw_to_caller(true), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(NULL) {\n+    _throw_to_caller(true), _file(file), _line(line), _attach_threw_OOME(false), _compile_state(nullptr) {\n@@ -271,1 +271,1 @@\n-  assert(_env == NULL || parent_env == _env, \"mismatched JNIEnvironment\");\n+  assert(_env == nullptr || parent_env == _env, \"mismatched JNIEnvironment\");\n@@ -275,1 +275,1 @@\n-  _compile_state = NULL;\n+  _compile_state = nullptr;\n@@ -281,1 +281,1 @@\n-    _env = NULL;\n+    _env = nullptr;\n@@ -287,1 +287,1 @@\n-    init_env_mode_runtime(thread, NULL);\n+    init_env_mode_runtime(thread, nullptr);\n@@ -297,1 +297,1 @@\n-      jthrowable ex = !clear ? jni()->ExceptionOccurred() : NULL;\n+      jthrowable ex = !clear ? jni()->ExceptionOccurred() : nullptr;\n@@ -299,1 +299,1 @@\n-      if (ex != NULL) {\n+      if (ex != nullptr) {\n@@ -313,2 +313,2 @@\n-  JVMCIEnv*  _from_env; \/\/ Source of translation. Can be nullptr.\n-  JVMCIEnv*  _to_env;   \/\/ Destination of translation. Never nullptr.\n+  JVMCIEnv*  _from_env; \/\/ Source of translation. Can be null.\n+  JVMCIEnv*  _to_env;   \/\/ Destination of translation. Never null.\n@@ -487,1 +487,1 @@\n-      jni()->PopLocalFrame(NULL);\n+      jni()->PopLocalFrame(nullptr);\n@@ -740,1 +740,1 @@\n-    assert(box != NULL, \"\");\n+    assert(box != nullptr, \"\");\n@@ -1031,1 +1031,1 @@\n-    if (file_name_sym != NULL) {\n+    if (file_name_sym != nullptr) {\n@@ -1047,2 +1047,2 @@\n-    jobject file_name = NULL;\n-    if (file_name_sym != NULL) {\n+    jobject file_name = nullptr;\n+    if (file_name_sym != nullptr) {\n@@ -1091,1 +1091,1 @@\n-    jobject nameStr = name == NULL ? NULL : jni()->NewStringUTF(name);\n+    jobject nameStr = name == nullptr ? nullptr : jni()->NewStringUTF(name);\n@@ -1162,1 +1162,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -1313,1 +1313,1 @@\n-    jobjectArray result = jni()->NewObjectArray(length, JNIJVMCI::byte_array(), NULL);\n+    jobjectArray result = jni()->NewObjectArray(length, JNIJVMCI::byte_array(), nullptr);\n@@ -1461,2 +1461,2 @@\n-    if (result == NULL) {\n-      JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly NULL\", Handle());\n+    if (result == nullptr) {\n+      JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly nullptr\", Handle());\n@@ -1475,1 +1475,1 @@\n-  assert(!obj.is_null(), \"should only create handle for non-NULL oops\");\n+  assert(!obj.is_null(), \"should only create handle for non-nullptr oops\");\n@@ -1482,1 +1482,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1571,1 +1571,1 @@\n-  if (nm == NULL) {\n+  if (nm == nullptr) {\n@@ -1618,2 +1618,2 @@\n-  if (code == NULL) {\n-    return NULL;\n+  if (code == nullptr) {\n+    return nullptr;\n@@ -1625,1 +1625,1 @@\n-    if (nm != NULL && (compile_id_snapshot == 0 || nm->compile_id() == compile_id_snapshot)) {\n+    if (nm != nullptr && (compile_id_snapshot == 0 || nm->compile_id() == compile_id_snapshot)) {\n@@ -1629,1 +1629,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1635,2 +1635,2 @@\n-  if (code == NULL) {\n-    return NULL;\n+  if (code == nullptr) {\n+    return nullptr;\n@@ -1641,1 +1641,1 @@\n-    if (nm != NULL && compile_id_snapshot != 0L && nm->is_not_entrant()) {\n+    if (nm != nullptr && compile_id_snapshot != 0L && nm->is_not_entrant()) {\n@@ -1650,1 +1650,1 @@\n-    if (nm == NULL) {\n+    if (nm == nullptr) {\n@@ -1668,1 +1668,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -1671,1 +1671,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1692,1 +1692,1 @@\n-      jobjectArray result = jni()->NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \\\n+      jobjectArray result = jni()->NewObjectArray(length, JNIJVMCI::className::clazz(), nullptr);                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-        if (::JVMCI::get_shared_library(sl_path, false) != NULL) { \\\n+        if (::JVMCI::get_shared_library(sl_path, false) != nullptr) { \\\n@@ -67,1 +67,1 @@\n-  Klass*        non_null_klass() const            { assert(_klass != NULL, \"resolving NULL _klass\"); return _klass; }\n+  Klass*        non_null_klass() const            { assert(_klass != nullptr, \"resolving null _klass\"); return _klass; }\n@@ -71,1 +71,1 @@\n-  JVMCIKlassHandle (Thread* thread) : _klass(NULL), _thread(thread) {}\n+  JVMCIKlassHandle (Thread* thread) : _klass(nullptr), _thread(thread) {}\n@@ -86,2 +86,2 @@\n-  bool    is_null() const                      { return _klass == NULL; }\n-  bool    not_null() const                     { return _klass != NULL; }\n+  bool    is_null() const                      { return _klass == nullptr; }\n+  bool    not_null() const                     { return _klass != nullptr; }\n@@ -302,4 +302,4 @@\n-  jobject get_jobject(JVMCIObject object)                       { assert(object.as_jobject() == NULL || is_hotspot() == object.is_hotspot(), \"mismatch\"); return object.as_jobject(); }\n-  jarray get_jarray(JVMCIArray array)                           { assert(array.as_jobject() == NULL || is_hotspot() == array.is_hotspot(), \"mismatch\"); return array.as_jobject(); }\n-  jobjectArray get_jobjectArray(JVMCIObjectArray objectArray)   { assert(objectArray.as_jobject() == NULL || is_hotspot() == objectArray.is_hotspot(), \"mismatch\"); return objectArray.as_jobject(); }\n-  jbyteArray get_jbyteArray(JVMCIPrimitiveArray primitiveArray) { assert(primitiveArray.as_jobject() == NULL || is_hotspot() == primitiveArray.is_hotspot(), \"mismatch\"); return primitiveArray.as_jbyteArray(); }\n+  jobject get_jobject(JVMCIObject object)                       { assert(object.as_jobject() == nullptr || is_hotspot() == object.is_hotspot(), \"mismatch\"); return object.as_jobject(); }\n+  jarray get_jarray(JVMCIArray array)                           { assert(array.as_jobject() == nullptr || is_hotspot() == array.is_hotspot(), \"mismatch\"); return array.as_jobject(); }\n+  jobjectArray get_jobjectArray(JVMCIObjectArray objectArray)   { assert(objectArray.as_jobject() == nullptr || is_hotspot() == objectArray.is_hotspot(), \"mismatch\"); return objectArray.as_jobject(); }\n+  jbyteArray get_jbyteArray(JVMCIPrimitiveArray primitiveArray) { assert(primitiveArray.as_jobject() == nullptr || is_hotspot() == primitiveArray.is_hotspot(), \"mismatch\"); return primitiveArray.as_jbyteArray(); }\n@@ -348,1 +348,1 @@\n-  void throw_##name(const char* msg = NULL);\n+  void throw_##name(const char* msg = nullptr);\n@@ -450,1 +450,1 @@\n-    assert(_compile_state == NULL, \"set only once\");\n+    assert(_compile_state == nullptr, \"set only once\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-#define JVMCI_CHECK_NULL                               JVMCI_CHECK_(NULL)\n+#define JVMCI_CHECK_NULL                               JVMCI_CHECK_(nullptr)\n@@ -61,1 +61,1 @@\n-#define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)\n+#define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(nullptr, __VA_ARGS__)\n@@ -65,1 +65,1 @@\n-#define JVMCI_THROW_NULL(name) { JVMCIENV->throw_##name(); return NULL; }\n+#define JVMCI_THROW_NULL(name) { JVMCIENV->throw_##name(); return nullptr; }\n@@ -67,1 +67,1 @@\n-#define JVMCI_THROW_MSG_NULL(name, msg) { JVMCIENV->throw_##name(msg); return NULL; }\n+#define JVMCI_THROW_MSG_NULL(name, msg) { JVMCIENV->throw_##name(msg); return nullptr; }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciExceptions.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  if (name_symbol == NULL || signature_symbol == NULL) {\n+  if (name_symbol == nullptr || signature_symbol == nullptr) {\n@@ -100,2 +100,2 @@\n-  Method* method = NULL;\n-  LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::AccessCheck::skip, LinkInfo::LoaderConstraintCheck::skip);\n+  Method* method = nullptr;\n+  LinkInfo link_info(resolved_klass, method_name, method_signature, nullptr, LinkInfo::AccessCheck::skip, LinkInfo::LoaderConstraintCheck::skip);\n@@ -111,1 +111,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -202,1 +202,1 @@\n-    assert(obj != NULL, \"NULL field access of %s.%s\", #className, field_name); \\\n+    assert(obj != nullptr, \"nullptr field access of %s.%s\", #className, field_name); \\\n@@ -206,1 +206,1 @@\n-  InstanceKlass* HotSpotJVMCI::className::_klass = NULL;\n+  InstanceKlass* HotSpotJVMCI::className::_klass = nullptr;\n@@ -228,1 +228,1 @@\n-      assert(className::klass() != NULL && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n+      assert(className::klass() != nullptr && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n@@ -235,2 +235,2 @@\n-      assert(className::klass() != NULL && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n-      assert(className::klass() != NULL, \"Class not yet loaded: \" #className);                                            \\\n+      assert(className::klass() != nullptr && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n+      assert(className::klass() != nullptr, \"Class not yet loaded: \" #className);                                            \\\n@@ -243,1 +243,1 @@\n-      assert(className::klass() != NULL && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n+      assert(className::klass() != nullptr && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n@@ -249,1 +249,1 @@\n-      assert(className::klass() != NULL && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n+      assert(className::klass() != nullptr && className::klass()->is_linked(), \"Class not yet linked: \" #className);         \\\n@@ -269,1 +269,1 @@\n- * InstanceKlass *HotSpotJVMCI::Architecture::_klass = NULL;\n+ * InstanceKlass *HotSpotJVMCI::Architecture::_klass = nullptr;\n@@ -299,1 +299,1 @@\n-  if (JVMCILibDumpJNIConfig != NULL) {\n+  if (JVMCILibDumpJNIConfig != nullptr) {\n@@ -358,1 +358,1 @@\n-#define END_CLASS current_class_name = NULL; }\n+#define END_CLASS current_class_name = nullptr; }\n@@ -422,1 +422,1 @@\n-    if (name == NULL) {\n+    if (name == nullptr) {\n@@ -426,1 +426,1 @@\n-    if (k != NULL && k->is_instance_klass()) {\n+    if (k != nullptr && k->is_instance_klass()) {\n@@ -429,1 +429,1 @@\n-        const char* class_name = NULL;\n+        const char* class_name = nullptr;\n@@ -436,1 +436,1 @@\n-            if (class_name == NULL) {\n+            if (class_name == nullptr) {\n@@ -454,1 +454,1 @@\n-  const char* current_class_name = NULL;\n+  const char* current_class_name = nullptr;\n@@ -489,1 +489,1 @@\n-  if (JVMCILibDumpJNIConfig == NULL) {                                                                            \\\n+  if (JVMCILibDumpJNIConfig == nullptr) {                                                                         \\\n@@ -493,1 +493,1 @@\n-    assert(_box_classes[basicType] != NULL, \"uninitialized\");                                                     \\\n+    assert(_box_classes[basicType] != nullptr, \"uninitialized\");                                                  \\\n@@ -505,1 +505,1 @@\n-  if (JVMCILibDumpJNIConfig == NULL) {\n+  if (JVMCILibDumpJNIConfig == nullptr) {\n@@ -509,1 +509,1 @@\n-    assert(_byte_array != NULL, \"uninitialized\");\n+    assert(_byte_array != nullptr, \"uninitialized\");\n@@ -528,1 +528,1 @@\n-  if (JVMCILibDumpJNIConfig != NULL) {\n+  if (JVMCILibDumpJNIConfig != nullptr) {\n@@ -551,1 +551,1 @@\n-  if (clazz == NULL) {\n+  if (clazz == nullptr) {\n@@ -570,1 +570,1 @@\n-    register_natives_for_class(env, NULL, \"jdk\/vm\/ci\/hotspot\/CompilerToVM\", CompilerToVM_nmethods, 1);\n+    register_natives_for_class(env, nullptr, \"jdk\/vm\/ci\/hotspot\/CompilerToVM\", CompilerToVM_nmethods, 1);\n@@ -624,1 +624,1 @@\n-    assert(obj.is_non_null(), \"NULL field access of %s.%s\", #className, field_name);                                     \\\n+    assert(obj.is_non_null(), \"nullptr field access of %s.%s\", #className, field_name);                                     \\\n@@ -628,1 +628,1 @@\n-  jclass JNIJVMCI::className::_class = NULL;\n+  jclass JNIJVMCI::className::_class = nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,8 +287,8 @@\n-#define HS_START_CLASS(simpleClassName, fullClassName)                               \\\n-  START_CLASS(simpleClassName, fullClassName)                                        \\\n-  friend class HotSpotJVMCI;                                                         \\\n- private:                                                                            \\\n-  static void check(oop obj, const char* field_name, int offset);                    \\\n-  static InstanceKlass* _klass;                                                      \\\n- public:                                                                             \\\n-  static InstanceKlass* klass() { assert(_klass != NULL, \"uninit\"); return _klass; } \\\n+#define HS_START_CLASS(simpleClassName, fullClassName)                                  \\\n+  START_CLASS(simpleClassName, fullClassName)                                           \\\n+  friend class HotSpotJVMCI;                                                            \\\n+ private:                                                                               \\\n+  static void check(oop obj, const char* field_name, int offset);                       \\\n+  static InstanceKlass* _klass;                                                         \\\n+ public:                                                                                \\\n+  static InstanceKlass* klass() { assert(_klass != nullptr, \"uninit\"); return _klass; } \\\n@@ -394,2 +394,2 @@\n- static jclass clazz() { assert(_class != NULL, #fullClassName \" uninitialized\"); return _class; }  \\\n- static jclass fullClassName ##_class()  { assert(_class != NULL, \"uninit\"); return _class; }\n+ static jclass clazz() { assert(_class != nullptr, #fullClassName \" uninitialized\"); return _class; }  \\\n+ static jclass fullClassName ##_class()  { assert(_class != nullptr, \"uninit\"); return _class; }\n@@ -476,1 +476,1 @@\n-  static jclass    byte_array()           { assert(_byte_array != NULL, \"uninit\");      return _byte_array; }\n+  static jclass    byte_array()           { assert(_byte_array != nullptr, \"uninit\");      return _byte_array; }\n@@ -478,3 +478,3 @@\n-  static jclass    box_class(BasicType type)       { assert(_box_classes[type]!= NULL, \"uninit\");      return _box_classes[type]; }\n-  static jfieldID  box_field(BasicType type)       { assert(_box_fields[type]!= NULL, \"uninit\");       return _box_fields[type]; }\n-  static jmethodID box_constructor(BasicType type) { assert(_box_constructors[type]!= NULL, \"uninit\"); return _box_constructors[type]; }\n+  static jclass    box_class(BasicType type)       { assert(_box_classes[type]!= nullptr, \"uninit\");      return _box_classes[type]; }\n+  static jfieldID  box_field(BasicType type)       { assert(_box_fields[type]!= nullptr, \"uninit\");       return _box_fields[type]; }\n+  static jmethodID box_constructor(BasicType type) { assert(_box_constructors[type]!= nullptr, \"uninit\"); return _box_constructors[type]; }\n@@ -482,4 +482,4 @@\n-  static jmethodID HotSpotResolvedJavaMethodImpl_fromMetaspace_method()     { assert(_HotSpotResolvedJavaMethodImpl_fromMetaspace_method     != NULL, \"uninit\"); return _HotSpotResolvedJavaMethodImpl_fromMetaspace_method; }\n-  static jmethodID HotSpotConstantPool_fromMetaspace_method()           { assert(_HotSpotConstantPool_fromMetaspace_method           != NULL, \"uninit\"); return _HotSpotConstantPool_fromMetaspace_method; }\n-  static jmethodID HotSpotResolvedObjectTypeImpl_fromMetaspace_method() { assert(_HotSpotResolvedObjectTypeImpl_fromMetaspace_method != NULL, \"uninit\"); return _HotSpotResolvedObjectTypeImpl_fromMetaspace_method; }\n-  static jmethodID HotSpotResolvedPrimitiveType_fromMetaspace_method()  { assert(_HotSpotResolvedPrimitiveType_fromMetaspace_method  != NULL, \"uninit\"); return _HotSpotResolvedPrimitiveType_fromMetaspace_method; }\n+  static jmethodID HotSpotResolvedJavaMethodImpl_fromMetaspace_method()     { assert(_HotSpotResolvedJavaMethodImpl_fromMetaspace_method     != nullptr, \"uninit\"); return _HotSpotResolvedJavaMethodImpl_fromMetaspace_method; }\n+  static jmethodID HotSpotConstantPool_fromMetaspace_method()           { assert(_HotSpotConstantPool_fromMetaspace_method           != nullptr, \"uninit\"); return _HotSpotConstantPool_fromMetaspace_method; }\n+  static jmethodID HotSpotResolvedObjectTypeImpl_fromMetaspace_method() { assert(_HotSpotResolvedObjectTypeImpl_fromMetaspace_method != nullptr, \"uninit\"); return _HotSpotResolvedObjectTypeImpl_fromMetaspace_method; }\n+  static jmethodID HotSpotResolvedPrimitiveType_fromMetaspace_method()  { assert(_HotSpotResolvedPrimitiveType_fromMetaspace_method  != nullptr, \"uninit\"); return _HotSpotResolvedPrimitiveType_fromMetaspace_method; }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  JVMCIObject(): _object(NULL), _is_hotspot(false) {}\n+  JVMCIObject(): _object(nullptr), _is_hotspot(false) {}\n@@ -50,2 +50,2 @@\n-  bool is_null() const { return _object == NULL; }\n-  bool is_non_null() const { return _object != NULL; }\n+  bool is_null() const { return _object == nullptr; }\n+  bool is_non_null() const { return _object != nullptr; }\n@@ -68,1 +68,1 @@\n-  JVMCIObjectArray(void* v): JVMCIArray() { assert(v == NULL, \"must be NULL\"); }\n+  JVMCIObjectArray(void* v): JVMCIArray() { assert(v == nullptr, \"must be nullptr\"); }\n@@ -77,1 +77,1 @@\n-  JVMCIPrimitiveArray(void* v): JVMCIArray() { assert(v == NULL, \"must be NULL\"); }\n+  JVMCIPrimitiveArray(void* v): JVMCIArray() { assert(v == nullptr, \"must be nullptr\"); }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciObject.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-\/\/ call is of the variety where allocation failure returns NULL without an\n+\/\/ call is of the variety where allocation failure returns null without an\n@@ -97,1 +97,1 @@\n-\/\/   2. NULL is written to JavaThread::_vm_result\n+\/\/   2. null is written to JavaThread::_vm_result\n@@ -109,1 +109,1 @@\n-      _thread = NULL;\n+      _thread = nullptr;\n@@ -113,1 +113,1 @@\n-    if (_thread != NULL) {\n+    if (_thread != nullptr) {\n@@ -125,1 +125,1 @@\n-        _thread->set_vm_result(NULL);\n+        _thread->set_vm_result(nullptr);\n@@ -214,1 +214,1 @@\n-  if (klass == NULL) {\n+  if (klass == nullptr) {\n@@ -262,1 +262,1 @@\n-  assert(cm != NULL, \"this is not a compiled method\");\n+  assert(cm != nullptr, \"this is not a compiled method\");\n@@ -274,1 +274,1 @@\n-  assert(exception.not_null(), \"NULL exceptions should be handled by throw_exception\");\n+  assert(exception.not_null(), \"null exceptions should be handled by throw_exception\");\n@@ -285,1 +285,1 @@\n-    assert(cm->method() != NULL, \"Unexpected null method()\");\n+    assert(cm->method() != nullptr, \"Unexpected null method()\");\n@@ -327,1 +327,1 @@\n-    if (fast_continuation != NULL) {\n+    if (fast_continuation != nullptr) {\n@@ -336,2 +336,2 @@\n-  \/\/ skip the exception cache update (i.e., just leave continuation==NULL).\n-  address continuation = NULL;\n+  \/\/ skip the exception cache update (i.e., just leave continuation==nullptr).\n+  address continuation = nullptr;\n@@ -361,1 +361,1 @@\n-    if (continuation != NULL && !recursive_exception && !SharedRuntime::deopt_blob()->contains(continuation)) {\n+    if (continuation != nullptr && !recursive_exception && !SharedRuntime::deopt_blob()->contains(continuation)) {\n@@ -389,2 +389,2 @@\n-  CompiledMethod* cm = NULL;\n-  address continuation = NULL;\n+  CompiledMethod* cm = nullptr;\n+  address continuation = nullptr;\n@@ -400,1 +400,1 @@\n-  if (cm != NULL && caller_is_deopted()) {\n+  if (cm != nullptr && caller_is_deopted()) {\n@@ -404,1 +404,1 @@\n-  assert(continuation != NULL, \"no handler found\");\n+  assert(continuation != nullptr, \"no handler found\");\n@@ -586,2 +586,2 @@\n-  if (obj == NULL) {\n-    tty->print(\"NULL\");\n+  if (obj == nullptr) {\n+    tty->print(\"null\");\n@@ -597,1 +597,1 @@\n-    assert(obj != NULL && java_lang_String::is_instance(obj), \"must be\");\n+    assert(obj != nullptr && java_lang_String::is_instance(obj), \"must be\");\n@@ -636,1 +636,1 @@\n-  char *detail_msg = NULL;\n+  char *detail_msg = nullptr;\n@@ -648,2 +648,2 @@\n-  assert(exception != NULL, \"npe\");\n-  thread->set_exception_oop(NULL);\n+  assert(exception != nullptr, \"npe\");\n+  thread->set_exception_oop(nullptr);\n@@ -690,1 +690,1 @@\n-    if (buf != NULL) {\n+    if (buf != nullptr) {\n@@ -695,1 +695,1 @@\n-  } else if (buf != NULL) {\n+  } else if (buf != nullptr) {\n@@ -763,1 +763,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -785,1 +785,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -797,2 +797,2 @@\n-  assert(new_mirror != NULL, \"use clear_nmethod_mirror to clear the mirror\");\n-  assert(*addr == NULL, \"cannot overwrite non-null mirror\");\n+  assert(new_mirror != nullptr, \"use clear_nmethod_mirror to clear the mirror\");\n+  assert(*addr == nullptr, \"cannot overwrite non-null mirror\");\n@@ -810,1 +810,1 @@\n-  if (nmethod_mirror == NULL) {\n+  if (nmethod_mirror == nullptr) {\n@@ -817,1 +817,1 @@\n-  JVMCIEnv* jvmciEnv = NULL;\n+  JVMCIEnv* jvmciEnv = nullptr;\n@@ -868,1 +868,1 @@\n-      NativeAccess<>::oop_store(oop_ptr, (oop) NULL);\n+      NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n@@ -1382,1 +1382,1 @@\n-  jbyte* properties = NULL;\n+  jbyte* properties = nullptr;\n@@ -1615,1 +1615,1 @@\n-    if (JVMCIENV != NULL) {\n+    if (JVMCIENV != nullptr) {\n@@ -1669,1 +1669,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -1704,1 +1704,1 @@\n-    if (elem_klass != NULL) {\n+    if (elem_klass != nullptr) {\n@@ -1710,1 +1710,1 @@\n-  if (found_klass == NULL && !cpool.is_null() && cpool->has_preresolution()) {\n+  if (found_klass == nullptr && !cpool.is_null() && cpool->has_preresolution()) {\n@@ -1745,2 +1745,2 @@\n-  Symbol* klass_name = NULL;\n-  if (klass == NULL) {\n+  Symbol* klass_name = nullptr;\n+  if (klass == nullptr) {\n@@ -1750,1 +1750,1 @@\n-  if (klass == NULL) {\n+  if (klass == nullptr) {\n@@ -1757,1 +1757,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -1760,1 +1760,1 @@\n-               get_klass_by_name_impl(accessor, cpool, k->name(), true) == NULL) {\n+               get_klass_by_name_impl(accessor, cpool, k->name(), true) == nullptr) {\n@@ -1768,1 +1768,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1826,1 +1826,1 @@\n-  if (canonical_holder == NULL) {\n+  if (canonical_holder == nullptr) {\n@@ -1867,1 +1867,1 @@\n-      return NULL; \/\/ silence compiler warnings\n+      return nullptr; \/\/ silence compiler warnings\n@@ -1886,1 +1886,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1910,1 +1910,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -1923,1 +1923,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1932,1 +1932,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1947,1 +1947,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1964,1 +1964,1 @@\n-  if (compile_state != NULL && compile_state->jvmti_state_changed()) {\n+  if (compile_state != nullptr && compile_state->jvmti_state_changed()) {\n@@ -1969,1 +1969,1 @@\n-  CompileTask* task = compile_state == NULL ? NULL : compile_state->task();\n+  CompileTask* task = compile_state == nullptr ? nullptr : compile_state->task();\n@@ -2092,1 +2092,1 @@\n-  char* failure_detail = NULL;\n+  char* failure_detail = nullptr;\n@@ -2097,1 +2097,1 @@\n-  const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV->as_utf8_string(name);\n+  const char* nmethod_mirror_name = name.is_null() ? nullptr : JVMCIENV->as_utf8_string(name);\n@@ -2102,1 +2102,1 @@\n-    nmethod_mirror_index = oop_recorder->allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);\n+    nmethod_mirror_index = oop_recorder->allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : nullptr);\n@@ -2111,1 +2111,1 @@\n-  if (method->get_method_counters(THREAD) == NULL) {\n+  if (method->get_method_counters(THREAD) == nullptr) {\n@@ -2142,1 +2142,1 @@\n-      if (mdp != NULL) {\n+      if (mdp != nullptr) {\n@@ -2171,1 +2171,1 @@\n-      if (nm == NULL) {\n+      if (nm == nullptr) {\n@@ -2185,1 +2185,1 @@\n-        assert(data != NULL, \"must be\");\n+        assert(data != nullptr, \"must be\");\n@@ -2187,1 +2187,1 @@\n-          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) == NULL, \"must be\");\n+          assert(!nmethod_mirror.is_hotspot() || data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) == nullptr, \"must be\");\n@@ -2191,1 +2191,1 @@\n-            if (TraceMethodReplacement && old != NULL) {\n+            if (TraceMethodReplacement && old != nullptr) {\n@@ -2196,1 +2196,1 @@\n-            if (old != NULL ) {\n+            if (old != nullptr ) {\n@@ -2241,1 +2241,1 @@\n-  if (failure_detail != NULL) {\n+  if (failure_detail != nullptr) {\n@@ -2249,1 +2249,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    if (nmethod_mirror_name != NULL) {\n+    if (nmethod_mirror_name != nullptr) {\n@@ -85,2 +85,2 @@\n-  \/\/ Gets the JVMCI name of the nmethod (which may be NULL).\n-  const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }\n+  \/\/ Gets the JVMCI name of the nmethod (which may be null).\n+  const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : nullptr; }\n@@ -213,1 +213,1 @@\n-  \/\/ If nullptr is returned, then `*count` contains the number of JVMCIRuntimes\n+  \/\/ If null is returned, then `*count` contains the number of JVMCIRuntimes\n@@ -238,1 +238,1 @@\n-  \/\/ interface pointer for the JavaVM is returned otherwise nullptr is returned.\n+  \/\/ interface pointer for the JavaVM is returned otherwise null is returned.\n@@ -341,1 +341,1 @@\n-  \/\/ `_HotSpotJVMCIRuntime_instance` is set to nullptr and `_init_state`\n+  \/\/ `_HotSpotJVMCIRuntime_instance` is set to null and `_init_state`\n@@ -352,1 +352,1 @@\n-  \/\/ If require_local, result must be defined in that class loader, or NULL.\n+  \/\/ If require_local, result must be defined in that class loader, or null.\n@@ -432,1 +432,1 @@\n-    JVMCIRuntime::fatal_exception(NULL, buf); \\\n+    JVMCIRuntime::fatal_exception(nullptr, buf); \\\n@@ -441,1 +441,1 @@\n-    JVMCIRuntime::fatal_exception(NULL, buf); \\\n+    JVMCIRuntime::fatal_exception(nullptr, buf); \\\n@@ -477,1 +477,1 @@\n-  \/\/ 2. Return NULL with a pending exception.\n+  \/\/ 2. Return null with a pending exception.\n@@ -486,1 +486,1 @@\n-  \/\/ When allocation fails, these stubs return NULL and have no pending exception. Compiled code\n+  \/\/ When allocation fails, these stubs return null and have no pending exception. Compiled code\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-fileStream* JVMCIGlobals::_jni_config_file = NULL;\n+fileStream* JVMCIGlobals::_jni_config_file = nullptr;\n@@ -154,1 +154,1 @@\n-  if (JVMCILibDumpJNIConfig != NULL) {\n+  if (JVMCILibDumpJNIConfig != nullptr) {\n@@ -156,1 +156,1 @@\n-    if (_jni_config_file == NULL || !_jni_config_file->is_open()) {\n+    if (_jni_config_file == nullptr || !_jni_config_file->is_open()) {\n@@ -187,1 +187,1 @@\n-    NULL\n+    nullptr\n@@ -190,1 +190,1 @@\n-  for (int i = 0; JVMCIFlags[i] != NULL; i++) {\n+  for (int i = 0; JVMCIFlags[i] != nullptr; i++) {\n@@ -192,1 +192,1 @@\n-    if (jvmciFlag == NULL) {\n+    if (jvmciFlag == nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-  product(ccstr, JVMCILibPath, NULL, EXPERIMENTAL,                          \\\n+  product(ccstr, JVMCILibPath, nullptr, EXPERIMENTAL,                       \\\n@@ -135,1 +135,1 @@\n-  product(ccstr, JVMCILibDumpJNIConfig, NULL, EXPERIMENTAL,                 \\\n+  product(ccstr, JVMCILibDumpJNIConfig, nullptr, EXPERIMENTAL,              \\\n@@ -150,1 +150,1 @@\n-  product(ccstr, JVMCINativeLibraryErrorFile, NULL, EXPERIMENTAL,           \\\n+  product(ccstr, JVMCINativeLibraryErrorFile, nullptr, EXPERIMENTAL,        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  if (_head == NULL) {\n+  if (_head == nullptr) {\n@@ -41,1 +41,1 @@\n-  if (handle != NULL) {\n+  if (handle != nullptr) {\n@@ -50,1 +50,1 @@\n-  if (_last->_next != NULL) {\n+  if (_last->_next != nullptr) {\n@@ -74,1 +74,1 @@\n-  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {\n+  for (MetadataHandleBlock* current = _head; current != nullptr; current = current->_next) {\n@@ -77,1 +77,1 @@\n-      if (handle->value() == NULL) {\n+      if (handle->value() == nullptr) {\n@@ -103,2 +103,2 @@\n-  if (_head != NULL) {\n-    for (MetadataHandleBlock* block = _head; block != NULL; block = block->_next) {\n+  if (_head != nullptr) {\n+    for (MetadataHandleBlock* block = _head; block != nullptr; block = block->_next) {\n@@ -113,1 +113,1 @@\n-  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {\n+  for (MetadataHandleBlock* current = _head; current != nullptr; current = current->_next) {\n@@ -119,1 +119,1 @@\n-      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {\n+      if (value != nullptr && ((intptr_t) value & ptr_tag) == 0) {\n@@ -134,1 +134,1 @@\n-  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {\n+  for (MetadataHandleBlock* current = _head; current != nullptr; current = current->_next) {\n@@ -140,2 +140,2 @@\n-      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {\n-        Klass* klass = NULL;\n+      if (value != nullptr && ((intptr_t) value & ptr_tag) == 0) {\n+        Klass* klass = nullptr;\n@@ -156,1 +156,1 @@\n-          \/\/ HandleCleaner will set this to NULL and\n+          \/\/ HandleCleaner will set this to null and\n","filename":"src\/hotspot\/share\/jvmci\/metadataHandles.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-    _value = NULL;\n-    _name = NULL;\n+    _value = nullptr;\n+    _name = nullptr;\n@@ -62,1 +62,1 @@\n-    if (_name != NULL) {\n+    if (_name != nullptr) {\n@@ -64,1 +64,1 @@\n-      _name = NULL;\n+      _name = nullptr;\n@@ -66,1 +66,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -86,1 +86,1 @@\n-  \/\/ on the free list has a NULL pointer with the tag bit set, so it's\n+  \/\/ on the free list has a null pointer with the tag bit set, so it's\n@@ -96,1 +96,1 @@\n-    _next = NULL;\n+    _next = nullptr;\n@@ -116,1 +116,1 @@\n-\/\/ passed back to the Java code which is responsible for setting the handle to NULL when it\n+\/\/ passed back to the Java code which is responsible for setting the handle to null when it\n@@ -143,1 +143,1 @@\n-    assert(_last != NULL, \"sanity\");\n+    assert(_last != nullptr, \"sanity\");\n@@ -152,1 +152,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -161,2 +161,2 @@\n-    _head = NULL;\n-    _last = NULL;\n+    _head = nullptr;\n+    _last = nullptr;\n@@ -181,1 +181,1 @@\n-    handle->set_name(NULL);\n+    handle->set_name(nullptr);\n","filename":"src\/hotspot\/share\/jvmci\/metadataHandles.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-   * The last entry has a NULL fieldName.\n+   * The last entry has a null fieldName.\n@@ -38,1 +38,1 @@\n-   * The last entry has a NULL typeName.\n+   * The last entry has a null typeName.\n@@ -44,1 +44,1 @@\n-   * The last entry has a NULL typeName.\n+   * The last entry has a null typeName.\n@@ -50,1 +50,1 @@\n-   * The last entry has a NULL typeName.\n+   * The last entry has a null typeName.\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}