{"files":[{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddINodeIdealizationTests\n+ *\/\n+public class AddINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public int additions(int x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Run(test = \"additions\")\n+    public void runAdditions() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    \/\/ Checks (x - x) + (x - x) => 0\n+    public int xMinusX(int x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Run(test = \"xMinusX\")\n+    public void runXMinusX() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(0, xMinusX(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(0, xMinusX(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(0, xMinusX(x));\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public int test1(int x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public int test2(int x, int y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public int test3(int x, int y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public int test4(int x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public int test5(int a, int b, int c, int d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public int test6(int a, int b, int c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public int test7(int a, int b, int c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public int test8(int a, int b, int c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public int test9(int a, int b, int c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public int test10(int x, int y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public int test11(int x, int y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public int test12(int x, int y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public int test13(int x, int y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public int test14(int x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public int test15(int x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public int test16(int a, int b, int c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public int test17(int a, int b, int c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public int test18(int a, int b, int c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public int test19(int a, int b, int c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddLNodeIdealizationTests\n+ *\/\n+public class AddLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public long additions(long x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Run(test = \"additions\")\n+    public void runAdditions() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public long xMinusX(long x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Run(test = \"xMinusX\")\n+    public void runXMinusX() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(0L, xMinusX(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(0L, xMinusX(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(0L, xMinusX(x));\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public long test1(long x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public long test2(long x, long y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public long test3(long x, long y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public long test4(long x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public long test5(long a, long b, long c, long d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public long test6(long a, long b, long c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public long test7(long a, long b, long c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public long test8(long a, long b, long c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public long test9(long x, long y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public long test10(long x, long y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public long test11(long x, long y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public long test12(long x, long y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public long test13(long x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public long test14(long x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public long test15(long a, long b, long c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public long test16(long a, long b, long c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public long test18(long a, long b, long c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivINodeIdealizationTests\n+ *\/\n+public class DivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return x \/ 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return x \/ (13 \/ 13);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public int divByNegOne(int x) {\n+        return x \/ -1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n+    public int divByPow2And(int x) {\n+        return (x & -4) \/ 2;\n+    }\n+\n+    @Run(test = \"divByPow2And\")\n+    public void runDivByPow2And() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n+    public int divByPow2And1(int x) {\n+        return (x & -2) \/ 2;\n+    }\n+\n+    @Run(test = \"divByPow2And1\")\n+    public void runDivByPow2And1() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n+    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n+    public int divByPow2(int x) {\n+        return x \/ 8;\n+    }\n+\n+    @Run(test = \"divByPow2\")\n+    public void runDivByPow2() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                  IRNode.SUB_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public int divByNegPow2(int x) {\n+        return x \/ -8;\n+    }\n+\n+    @Run(test = \"divByNegPow2\")\n+    public void runDivByNegPow2() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.URSHIFT})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONVI2L, \"1\",\n+                  IRNode.CONVL2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ More tests can be made to cover the specific cases for differences in the\n+    \/\/ graph that depend upon different values for the \"magic constant\" and the\n+    \/\/ \"shift constant\"\n+    public int magicDiv(int x) {\n+        return x \/ 13;\n+    }\n+\n+    @Run(test = \"magicDiv\")\n+    public void runMagicDiv() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivLNodeIdealizationTests\n+ *\/\n+public class DivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return x \/ 1L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return x \/ (13L \/ 13L);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public long divByNegOne(long x) {\n+        return x \/ -1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for\n+    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n+    public long divByPow2And(long x) {\n+        return (x & -4L) \/ 2L;\n+    }\n+\n+    @Run(test = \"divByPow2And\")\n+    public void runDivByPow2And() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then\n+    \/\/ the and can be removed as it only affects bits that will be shifted off\n+    public long divByPow2And1(long x) {\n+        return (x & -2L) \/ 2L;\n+    }\n+\n+    @Run(test = \"divByPow2And1\")\n+    public void runDivByPow2And1() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account\n+    \/\/ for rounding when dealing with negative numbers. Since x may be negative\n+    \/\/ in this method, an additional add, logical right shift, and signed shift\n+    \/\/ are needed to account for rounding.\n+    public long divByPow2(long x) {\n+        return x \/ 8L;\n+    }\n+\n+    @Run(test = \"divByPow2\")\n+    public void runDivByPow2() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public long divByNegPow2(long x) {\n+        return x \/ -8L;\n+    }\n+\n+    @Run(test = \"divByNegPow2\")\n+    public void runDivByNegPow2() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of MulINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulINodeIdealizationTests\n+ *\/\n+public class MulINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.CALL})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks Max(a,b) * min(a,b) => a*b\n+    public int excludeMaxMin(int x, int y){\n+        return Math.max(x, y) * Math.min(x, y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public int combineConstants(int x){\n+        return (x * 13) * 14;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public int moveConstants(int x, int y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public int moveConstantsAgain(int x, int y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 * x => 0\n+    public int multiplyZero(int x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 0 => 0\n+    public int multiplyZeroAgain(int x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public int distribute(int x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 1 * x => x\n+    public int identity(int x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 1 => x\n+    public int identityAgain(int x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwo(int x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwoAgain(int x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public int powerTwoPlusOne(int x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public int powerTwoMinusOne(int x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of MulLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulLNodeIdealizationTests\n+ *\/\n+public class MulLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.CALL})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks Max(a,b) * min(a,b) => a*b\n+    public long excludeMaxMin(long x, long y){\n+        return Math.max(x, y) * Math.min(x, y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public long combineConstants(long x){\n+        return (x * 13) * 14 * 15;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public long moveConstants(long x, long y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public long moveConstantsAgain(long x, long y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 * x => 0\n+    public long multiplyZero(long x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 0 => 0\n+    public long multiplyZeroAgain(long x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public long distribute(long x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 1 * x => x\n+    public long identity(long x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 1 => x\n+    public long identityAgain(long x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwo(long x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwoAgain(long x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public long powerTwoPlusOne(long x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public long powerTwoMinusOne(long x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulLNodeIdealizationTests.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubINodeIdealizationTests\n+ *\/\n+public class SubINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public int test1(int x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public int test2(int x, int y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public int test3(int x, int y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => -y\n+    public int test4(int x, int y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => -y\n+    public int test5(int x, int y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => -y\n+    public int test6(int x, int y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public int test7(int x, int y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public int test8(int x, int y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public int test9(int x, int a, int b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public int test10(int x, int a, int b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public int test11(int x, int a, int b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public int test12(int x, int a, int b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public int test13(int a, int b, int c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 31) => a >> 31\n+    public int test14(int a) {\n+        return 0 - (a >> 31);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public int test15(int x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => y\n+    public int test16(int x, int y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public int test17(int x, int y) {\n+        return (x + y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public int test18(int a, int b, int c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public int test19(int a, int b, int c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public int test20(int a, int b, int c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public int test21(int a, int b, int c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubINodeIdealizationTests.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubLNodeIdealizationTests\n+ *\/\n+public class SubLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public long test1(long x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public long test2(long x, long y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public long test3(long x, long y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public long test4(long x, long y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public long test5(long x, long y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public long test6(long x, long y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public long test7(long x, long y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public long test8(long x, long a, long b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public long test9(long x, long a, long b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public long test10(long x, long a, long b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public long test11(long x, long a, long b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public long test12(long a, long b, long c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 63) => a >>> 63\n+    public long test13(long a) {\n+        return 0 - (a >> 63);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public long test14(long x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public long test15(long a, long b, long c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public long test16(long a, long b, long c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public long test18(long a, long b, long c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubLNodeIdealizationTests.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.loopOpts;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of CountedLoopNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.loopOpts.LoopIdealizationTests\n+ *\/\n+public class LoopIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole() { }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop(){\n+        for(int i = 0; i < 0; i++){\n+            System.out.println(13 \/ 17 * 23 + 1);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop1(){\n+        for(int i = 0; i < 500; i++){\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop(){\n+        for(int i = 0; i < 1; i++){\n+            this.blackhole();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop1(){\n+        for(int i = 0; i < 500; i++){\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop2(){\n+        for(int i = 0; i < 500; i++){\n+            this.blackhole();\n+            if (i == 0){\n+                break;\n+           }else{\n+               this.blackhole();\n+               i++;\n+           }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop(){\n+        while (true){\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop1(){\n+        int i = 0;\n+        while (i < 1){\n+            this.blackhole();\n+            i++;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop2(){\n+        int i = 0;\n+        while (i < 500){\n+            this.blackhole();\n+            if (i == 0){\n+                 break;\n+            }else{\n+                this.blackhole();\n+                i++;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop(){\n+        do{\n+            this.blackhole();\n+            break;\n+        }while (true);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop1(){\n+        do {\n+            this.blackhole();\n+        }while (false);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop2(){\n+        int i = 0;\n+        do {\n+            this.blackhole();\n+            i++;\n+        }while (i == -1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/loopOpts\/LoopIdealizationTests.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Tests that Escape Analisys and Scalar Replacement is able to handle some simple cases.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementTests\n+ *\/\n+public class ScalarReplacementTests {\n+    private class Person {\n+        private String name;\n+        private int age;\n+\n+        public Person(Person p) {\n+            this.name = p.getName();\n+            this.age = p.getAge();\n+        }\n+\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+\n+        public String getName() { return name; }\n+        public int getAge() { return age; }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String stringConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int intConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String nestedStringConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedIntConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedConstants(int age1, int age2) {\n+        Person p = new Person(\n+                        new Person(\"Java\", age1).getName(),\n+                        new Person(\"Java\", age2).getAge());\n+        return p.getAge();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementTests.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -56,0 +56,28 @@\n+    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n+    public static final String ADD_I = START + \"AddI\" + MID + END;\n+    public static final String ADD_L = START + \"AddL\" + MID + END;\n+    public static final String ADD_F = START + \"AddF\" + MID + END;\n+    public static final String ADD_D = START + \"AddD\" + MID + END;\n+    public static final String ADD_P = START + \"AddP\" + MID + END;\n+    public static final String AND = START + \"And(I|L)\" + MID + END;\n+    public static final String AND_I = START + \"AndI\" + MID + END;\n+    public static final String AND_L = START + \"AndL\" + MID + END;\n+\n+    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_I = START + \"DivI\" + MID + END;\n+    public static final String DIV_L = START + \"DivL\" + MID + END;\n+    public static final String DIV_F = START + \"DivF\" + MID + END;\n+    public static final String DIV_D = START + \"DivD\" + MID + END;\n+\n+    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n+    public static final String MUL_I = START + \"MulI\" + MID + END;\n+    public static final String MUL_L = START + \"MulL\" + MID + END;\n+    public static final String MUL_F = START + \"MulF\" + MID + END;\n+    public static final String MUL_D = START + \"MulD\" + MID + END;\n+\n+    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n+    public static final String SUB_I = START + \"SubI\" + MID + END;\n+    public static final String SUB_L = START + \"SubL\" + MID + END;\n+    public static final String SUB_F = START + \"SubF\" + MID + END;\n+    public static final String SUB_D = START + \"SubD\" + MID + END;\n+\n@@ -61,0 +89,3 @@\n+    public static final String CONVI2L = START + \"ConvI2L\" + MID + END;\n+    public static final String CONVL2I = START + \"ConvL2I\" + MID + END;\n+\n@@ -132,0 +163,17 @@\n+    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n+    public static final String LSHIFT_I = START + \"LShiftI\" + MID + END;\n+    public static final String LSHIFT_L = START + \"LShiftL\" + MID + END;\n+    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n+    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n+    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n+    public static final String ULSHIFT = START + \"ULShift(B|S|I|L)\" + MID + END;\n+    public static final String ULSHIFT_B = START + \"ULShiftB\" + MID + END;\n+    public static final String ULSHIFT_S = START + \"ULShiftS\" + MID + END;\n+    public static final String ULSHIFT_I = START + \"ULShiftI\" + MID + END;\n+    public static final String ULSHIFT_L = START + \"ULShiftL\" + MID + END;\n+    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n+    public static final String URSHIFT_B = START + \"URShiftB\" + MID + END;\n+    public static final String URSHIFT_S = START + \"URShiftS\" + MID + END;\n+    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n+    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}