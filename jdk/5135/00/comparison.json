{"files":[{"patch":"@@ -284,10 +284,1 @@\n-    \/\/ Convert \"(a-b)+(c-d)\" into \"(a+c)-(b+d)\"\n-    if( op2 == Op_SubI ) {\n-      \/\/ Check for dead cycle: d = (a-b)+(c-d)\n-      assert( in1->in(2) != this && in2->in(2) != this,\n-              \"dead loop in AddINode::Ideal\" );\n-      Node *sub  = new SubINode(NULL, NULL);\n-      sub->init_req(1, phase->transform(new AddINode(in1->in(1), in2->in(1) ) ));\n-      sub->init_req(2, phase->transform(new AddINode(in1->in(2), in2->in(2) ) ));\n-      return sub;\n-    }\n+\n@@ -314,0 +305,10 @@\n+    \/\/ Convert \"(a-b)+(c-d)\" into \"(a+c)-(b+d)\"\n+    if( op2 == Op_SubI ) {\n+      \/\/ Check for dead cycle: d = (a-b)+(c-d)\n+      assert( in1->in(2) != this && in2->in(2) != this,\n+              \"dead loop in AddINode::Ideal\" );\n+      Node *sub  = new SubINode(NULL, NULL);\n+      sub->init_req(1, phase->transform(new AddINode(in1->in(1), in2->in(1) ) ));\n+      sub->init_req(2, phase->transform(new AddINode(in1->in(2), in2->in(2) ) ));\n+      return sub;\n+    }\n@@ -464,0 +465,1 @@\n+\n@@ -466,10 +468,1 @@\n-    \/\/ Convert \"(a-b)+(c-d)\" into \"(a+c)-(b+d)\"\n-    if( op2 == Op_SubL ) {\n-      \/\/ Check for dead cycle: d = (a-b)+(c-d)\n-      assert( in1->in(2) != this && in2->in(2) != this,\n-              \"dead loop in AddLNode::Ideal\" );\n-      Node *sub  = new SubLNode(NULL, NULL);\n-      sub->init_req(1, phase->transform(new AddLNode(in1->in(1), in2->in(1) ) ));\n-      sub->init_req(2, phase->transform(new AddLNode(in1->in(2), in2->in(2) ) ));\n-      return sub;\n-    }\n+\n@@ -496,0 +489,11 @@\n+\n+    \/\/ Convert \"(a-b)+(c-d)\" into \"(a+c)-(b+d)\"\n+    if( op2 == Op_SubL ) {\n+      \/\/ Check for dead cycle: d = (a-b)+(c-d)\n+      assert( in1->in(2) != this && in2->in(2) != this,\n+              \"dead loop in AddLNode::Ideal\" );\n+      Node *sub  = new SubLNode(NULL, NULL);\n+      sub->init_req(1, phase->transform(new AddLNode(in1->in(1), in2->in(1) ) ));\n+      sub->init_req(2, phase->transform(new AddLNode(in1->in(2), in2->in(2) ) ));\n+      return sub;\n+    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -469,0 +469,14 @@\n+  Node *in1 = in(1);\n+  Node *in2 = in(2);\n+  uint op1 = in1->Opcode();\n+\n+  \/\/ Converts (x * y) \/ y => x\n+  if (op1 == Op_MulI && in1->in(2) == in2) {\n+    return new AddINode(in1->in(1), phase->intcon(0));\n+  }\n+\n+  \/\/ Converts (x * y) \/ x => y\n+  if (op1 == Op_MulI && in1->in(1) == in2) {\n+    return new AddINode(in1->in(2), phase->intcon(0));\n+  }\n+\n@@ -575,0 +589,14 @@\n+  Node *in1 = in(1);\n+  Node *in2 = in(2);\n+  uint op1 = in1->Opcode();\n+\n+  \/\/ Converts (x * y) \/ y => x\n+  if (op1 == Op_MulL && in1->in(2) == in2) {\n+    return new AddLNode(in1->in(1), phase->longcon(0));\n+  }\n+\n+  \/\/ Converts (x * y) \/ x => y\n+  if (op1 == Op_MulL && in1->in(1) == in2) {\n+    return new AddLNode(in1->in(2), phase->longcon(0));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  if (in(1)->Opcode() == Op_AddI) {\n+  if (in(1)->Opcode() == Op_AddI || in(1)->Opcode() == Op_AddL) {\n@@ -406,0 +406,4 @@\n+  \/\/ Convert \"(x-y) - x\" into \"-y\"\n+  if (op1 == Op_SubL && in1->in(1) == in2) {\n+    return new SubLNode(phase->longcon(0), in1->in(2));\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+hotspot_ir_transformations = \\\n+  ir_transformations\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n-    private static final String MID = \".*)+(\\\\s){2}===.*\";\n-    private static final String END = \")\";\n@@ -52,0 +49,1 @@\n+    private static final String END = \")\";\n@@ -53,1 +51,0 @@\n-    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n@@ -55,0 +52,13 @@\n+    private static final String MID = \".*)+(\\\\s){2}===.*\";\n+    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+\n+    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n+    public static final String ADD_I = START + \"AddI\" + MID + END;\n+    public static final String ADD_L = START + \"AddL\" + MID + END;\n+    public static final String ADD_F = START + \"AddF\" + MID + END;\n+    public static final String ADD_D = START + \"AddD\" + MID + END;\n+    public static final String ADD_P = START + \"AddP\" + MID + END;\n+    public static final String AND = START + \"And(I|L)\" + MID + END;\n+    public static final String AND_I = START + \"AndI\" + MID + END;\n+    public static final String AND_L = START + \"AndL\" + MID + END;\n@@ -61,0 +71,1 @@\n+    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n@@ -65,0 +76,11 @@\n+    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n+    public static final String CONVI2L = START + \"ConvI2L\" + MID + END;\n+    public static final String CONVL2I = START + \"ConvL2I\" + MID + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + END;\n+    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+\n+    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_I = START + \"DivI\" + MID + END;\n+    public static final String DIV_L = START + \"DivL\" + MID + END;\n+    public static final String DIV_F = START + \"DivF\" + MID + END;\n+    public static final String DIV_D = START + \"DivD\" + MID + END;\n@@ -68,19 +90,2 @@\n-    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n-    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n-    public static final String STORE_C = START + \"StoreC\" + MID + END;\n-    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n-    public static final String STORE_L = START + \"StoreL\" + MID + END;\n-    public static final String STORE_F = START + \"StoreF\" + MID + END;\n-    public static final String STORE_D = START + \"StoreD\" + MID + END;\n-    public static final String STORE_P = START + \"StoreP\" + MID + END;\n-    public static final String STORE_N = START + \"StoreN\" + MID + END;\n-    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreB\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreC\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreI\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreL\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreF\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreD\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreP\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreN\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n-    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+    \/\/ Does not work for VM builds without JVMCI like x86_32 (a rule containing this regex will be skipped without having JVMCI built).\n+    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n@@ -112,1 +117,0 @@\n-\n@@ -114,2 +118,10 @@\n-    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + END;\n-    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n+    public static final String LSHIFT_I = START + \"LShiftI\" + MID + END;\n+    public static final String LSHIFT_L = START + \"LShiftL\" + MID + END;\n+\n+    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n+    public static final String MUL_I = START + \"MulI\" + MID + END;\n+    public static final String MUL_L = START + \"MulL\" + MID + END;\n+    public static final String MUL_F = START + \"MulF\" + MID + END;\n+    public static final String MUL_D = START + \"MulD\" + MID + END;\n+    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n@@ -117,5 +129,0 @@\n-    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n-    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n-    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n-    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n-    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n@@ -124,0 +131,3 @@\n+\n+    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n+\n@@ -125,3 +135,3 @@\n-    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n-    \/\/ Does not work for VM builds without JVMCI like x86_32 (a rule containing this regex will be skipped without having JVMCI built).\n-    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n+    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n+    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n+    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n@@ -130,1 +140,39 @@\n-    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n+    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n+    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n+    public static final String STORE_C = START + \"StoreC\" + MID + END;\n+    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n+    public static final String STORE_L = START + \"StoreL\" + MID + END;\n+    public static final String STORE_F = START + \"StoreF\" + MID + END;\n+    public static final String STORE_D = START + \"StoreD\" + MID + END;\n+    public static final String STORE_P = START + \"StoreP\" + MID + END;\n+    public static final String STORE_N = START + \"StoreN\" + MID + END;\n+    public static final String STORE_OF_CLASS = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_B_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreB\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_C_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreC\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_I_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreI\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_L_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreL\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_F_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreF\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_D_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreD\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_P_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreP\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_N_OF_CLASS = COMPOSITE_PREFIX + START + \"StoreN\" + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    public static final String STORE_OF_FIELD = COMPOSITE_PREFIX + START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\" + IS_REPLACED + \",.*\" + END;\n+    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n+    public static final String SUB_I = START + \"SubI\" + MID + END;\n+    public static final String SUB_L = START + \"SubL\" + MID + END;\n+    public static final String SUB_F = START + \"SubF\" + MID + END;\n+    public static final String SUB_D = START + \"SubD\" + MID + END;\n+\n+    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n+\n+    public static final String ULSHIFT = START + \"ULShift(B|S|I|L)\" + MID + END;\n+    public static final String ULSHIFT_B = START + \"ULShiftB\" + MID + END;\n+    public static final String ULSHIFT_S = START + \"ULShiftS\" + MID + END;\n+    public static final String ULSHIFT_I = START + \"ULShiftI\" + MID + END;\n+    public static final String ULSHIFT_L = START + \"ULShiftL\" + MID + END;\n+    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n+    public static final String URSHIFT_B = START + \"URShiftB\" + MID + END;\n+    public static final String URSHIFT_S = START + \"URShiftS\" + MID + END;\n+    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n+    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n+    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n+    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":83,"deletions":35,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.AddINodeIdealizationTests\n+ *\/\n+public class AddINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks\n+    public int simpleZero(int x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public int simpleZeroSub(int x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public int simpleOne(int x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public int simpleTwo(int x, int y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public int simpleThree(int x, int y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public int simpleFour(int x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public int simpleFive(int a, int b, int c, int d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public int simpleSix(int a, int b, int c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public int simpleSeven(int a, int b, int c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public int simpleEight(int a, int b, int c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public int simpleNine(int a, int b, int c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public int simpleTen(int x, int y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public int simpleEleven(int x, int y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public int simpleTwelve(int x, int y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public int simpleThirteen(int x, int y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public int simpleFourteen(int x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public int simpleFifteen(int x) {\n+        return 0 + x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/AddINodeIdealizationTests.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.AddLNodeIdealizationTests\n+ *\/\n+public class AddLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks\n+    public long simpleZero(long x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public long simpleZeroSub(long x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public long simpleOne(long x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public long simpleTwo(long x, long y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public long simpleThree(long x, long y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public long simpleFour(long x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public long simpleFive(long a, long b, long c, long d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public long simpleSix(long a, long b, long c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public long simpleSeven(long a, long b, long c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public long simpleEight(long a, long b, long c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public long simpleNine(long a, long b, long c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public long simpleTen(long x, long y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public long simpleEleven(long x, long y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public long simpleTwelve(long x, long y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public long simpleThirteen(long x, long y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public long simpleFourteen(long x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public long simpleFifteen(long x) {\n+        return 0 + x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/AddLNodeIdealizationTests.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.DivINodeIdealizationTests\n+ *\/\n+public class DivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return x \/ 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identity1(int x) {\n+        return x \/ (13 \/ 13);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identity2(int x, int y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x * c) \/ c => x\n+    public int cancelOutDenominatorConstant(int x) {\n+        return (x * 13) \/ 13;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x * y) \/ y => x\n+    \/\/ The denominator can only be cancelled out if it's different of zero.\n+    public int cancelOutDenominatorVariable(int x, int y) {\n+        if (y != 0) {\n+            return (x * y) \/ y;\n+        }\n+        else {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public int divByNegOne(int x) {\n+        return x \/ -1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n+    public int divByPow2And(int x) {\n+        return (x & -4) \/ 2;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n+    public int divByPow2And1(int x) {\n+        return (x & -2) \/ 2;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n+    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n+    public int divByPow2(int x) {\n+        return x \/ 8;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                  IRNode.SUB_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public int divByNegPow2(int x) {\n+        return x \/ -8;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.URSHIFT})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONVI2L, \"1\",\n+                  IRNode.CONVL2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ More tests can be made to cover the specific cases for differences in the\n+    \/\/ graph that depend upon different values for the \"magic constant\" and the\n+    \/\/ \"shift constant\"\n+    public int magicDiv(int x) {\n+        return x \/ 13;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/DivINodeIdealizationTests.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.DivLNodeIdealizationTests\n+ *\/\n+public class DivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return x \/ 1L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identity1(long x) {\n+        return x \/ (13L \/ 13L);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identity2(long x, long y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x * c) \/ c => x\n+    public long cancelOutDenominatorConstant(long x) {\n+        return (x * 13L) \/ 13L;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x * y) \/ y => x\n+    \/\/ The denominator can only be cancelled out if it's different of zero.\n+    public long cancelOutDenominatorVariable(long x, long y) {\n+        if (y != 0) {\n+            return (x * y) \/ y;\n+        }\n+        else {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public long divByNegOne(long x) {\n+        return x \/ -1L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for\n+    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n+    public long divByPow2And(long x) {\n+        return (x & -4L) \/ 2L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then\n+    \/\/ the and can be removed as it only affects bits that will be shifted off\n+    public long divByPow2And1(long x) {\n+        return (x & -2L) \/ 2L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account\n+    \/\/ for rounding when dealing with negative numbers. Since x may be negative\n+    \/\/ in this method, an additional add, logical right shift, and signed shift\n+    \/\/ are needed to account for rounding.\n+    public long divByPow2(long x) {\n+        return x \/ 8L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public long divByNegPow2(long x) {\n+        return x \/ -8L;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/DivLNodeIdealizationTests.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Tests that Escape Analisys and Scalar Replacement is able to handle some simple cases.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.EscapeAnalysisAndScalarReplacement\n+ *\/\n+public class EscapeAnalysisAndScalarReplacement {\n+    private class Person {\n+        private String name;\n+        private int age;\n+\n+        public Person(Person p) {\n+            this.name = p.getName();\n+            this.age = p.getAge();\n+        }\n+\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+\n+        public String getName() { return name; }\n+        public int getAge() { return age; }\n+        public String toString() { return \"Name: \" + name + \" \\t Age: \" + age; }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole(Person p) { }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String stringConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int intConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String nestedStringConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedIntConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedConstants(int age1, int age2) {\n+        Person p = new Person(\n+                        new Person(\"Java\", age1).getName(),\n+                        new Person(\"Java\", age2).getAge());\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    @IR(counts = {IRNode.TRAP, \"1\"})\n+    public int infrequentEscape(int age1, int age2) {\n+        Person p = new Person(\"Java\", age1);\n+\n+        if (age1 == age2) {\n+            this.blackhole(p);\n+        }\n+\n+        return p.getAge();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/EscapeAnalysisAndScalarReplacement.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of CountedLoopNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.LoopIdealizationTests\n+ *\/\n+public class LoopIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole() { }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop(){\n+        for(int i = 0; i < 0; i++){\n+            System.out.println(13 \/ 17 * 23 + 1);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop1(){\n+        for(int i = 0; i < 500; i++){\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop(){\n+        for(int i = 0; i < 1; i++){\n+            this.blackhole();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop1(){\n+        for(int i = 0; i < 500; i++){\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop2(){\n+        for(int i = 0; i < 500; i++){\n+            this.blackhole();\n+            if (i == 0){\n+                break;\n+           }else{\n+               this.blackhole();\n+               i++;\n+           }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop(){\n+        while (true){\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop1(){\n+        int i = 0;\n+        while (i < 1){\n+            this.blackhole();\n+            i++;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop2(){\n+        int i = 0;\n+        while (i < 500){\n+            this.blackhole();\n+            if (i == 0){\n+                 break;\n+            }else{\n+                this.blackhole();\n+                i++;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop(){\n+        do{\n+            this.blackhole();\n+            break;\n+        }while (true);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop1(){\n+        do {\n+            this.blackhole();\n+        }while (false);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop2(){\n+        int i = 0;\n+        do {\n+            this.blackhole();\n+            i++;\n+        }while (i == -1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/LoopIdealizationTests.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of MulINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.MulINodeIdealizationTests\n+ *\/\n+public class MulINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.CALL})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks Max(a,b) * min(a,b) => a*b\n+    public int excludeMaxMin(int x, int y){\n+        return Math.max(x, y) * Math.min(x, y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public int combineConstants(int x){\n+        return (x * 13) * 14;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public int moveConstants(int x, int y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public int moveConstants1(int x, int y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 * x => 0\n+    public int multiplyZero(int x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 0 => 0\n+    public int multiplyZero1(int x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public int distribute(int x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 1 * x => x\n+    public int identity(int x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 1 => x\n+    public int identity1(int x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwo(int x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwo1(int x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public int powerTwoPlusOne(int x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public int powerTwoMinusOne(int x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/MulINodeIdealizationTests.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of MulLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.MulLNodeIdealizationTests\n+ *\/\n+public class MulLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.CALL})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks Max(a,b) * min(a,b) => a*b\n+    public long excludeMaxMin(long x, long y){\n+        return Math.max(x, y) * Math.min(x, y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public long combineConstants(long x){\n+        return (x * 13) * 14 * 15;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public long moveConstants(long x, long y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public long moveConstants1(long x, long y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 * x => 0\n+    public long multiplyZero(long x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 0 => 0\n+    public long multiplyZero1(long x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV})\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public long distribute(long x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 1 * x => x\n+    public long identity(long x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x * 1 => x\n+    public long identity1(long x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwo(long x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL, IRNode.ADD})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwo1(long x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.SUB, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public long powerTwoPlusOne(long x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.DIV, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public long powerTwoMinusOne(long x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/MulLNodeIdealizationTests.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.SubINodeIdealizationTests\n+ *\/\n+public class SubINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public int simpleOne(int x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public int simpleTwo(int x, int y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public int simpleThree(int x, int y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => -y\n+    public int simpleFour(int x, int y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => -y\n+    public int simpleFive(int x, int y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => -y\n+    public int simpleSix(int x, int y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public int simpleSeven(int x, int y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public int simpleEight(int x, int y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public int simpleNine(int x, int a, int b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public int simpleTen(int x, int a, int b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public int simpleEleven(int x, int a, int b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public int simpleTwelve(int x, int a, int b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public int simpleThirteen(int a, int b, int c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 31) => a >> 31\n+    public int simpleFourteen(int a) {\n+        return 0 - (a >> 31);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public int simpleFifteen(int x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => y\n+    public int simpleSixteen(int x, int y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public int simpleSeventeen(int x, int y) {\n+        return (x + y) - x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/SubINodeIdealizationTests.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package ir_transformations;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver ir_transformations.SubLNodeIdealizationTests\n+ *\/\n+public class SubLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public long simpleOne(long x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public long simpleTwo(long x, long y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public long simpleThree(long x, long y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public long simpleFour(long x, long y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => 0 - y\n+    public long simpleFive(long x, long y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public long simpleSix(long x, long y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public long simpleSeven(long x, long y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public long simpleEight(long x, long y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public long simpleNine(long x, long a, long b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public long simpleTen(long x, long a, long b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public long simpleEleven(long x, long a, long b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public long simpleTwelve(long x, long a, long b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public long simpleThirteen(long a, long b, long c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 63) => a >>> 63\n+    public long simpleFourteen(long a) {\n+        return 0 - (a >> 63);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public long simpleFifteen(long x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => x\n+    public long simpleSixteen(long x, long y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public long simpleSeventeen(long x, long y) {\n+        return (x + y) - x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/SubLNodeIdealizationTests.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"}]}