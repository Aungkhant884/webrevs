{"files":[{"patch":"@@ -74,3 +74,0 @@\n-hotspot_ir_transformations = \\\n-  ir_transformations\n-\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddINodeIdealizationTests\n+ *\/\n+public class AddINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public int additions(int x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Run(test = \"additions\")\n+    public void runAdditions() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    \/\/ Checks (x - x) + (x - x) => 0\n+    public int xMinusX(int x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Run(test = \"xMinusX\")\n+    public void runXMinusX() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(0, xMinusX(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(0, xMinusX(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(0, xMinusX(x));\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public int test1(int x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public int test2(int x, int y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public int test3(int x, int y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public int test4(int x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public int test5(int a, int b, int c, int d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public int test6(int a, int b, int c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public int test7(int a, int b, int c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public int test8(int a, int b, int c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public int test9(int a, int b, int c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public int test10(int x, int y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public int test11(int x, int y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public int test12(int x, int y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public int test13(int x, int y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public int test14(int x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public int test15(int x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public int test16(int a, int b, int c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public int test17(int a, int b, int c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public int test18(int a, int b, int c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public int test19(int a, int b, int c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddLNodeIdealizationTests\n+ *\/\n+public class AddLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public long additions(long x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Run(test = \"additions\")\n+    public void runAdditions() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x+x) + (x+x)), additions(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public long xMinusX(long x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Run(test = \"xMinusX\")\n+    public void runXMinusX() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(0L, xMinusX(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(0L, xMinusX(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(0L, xMinusX(x));\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public long test1(long x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public long test2(long x, long y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public long test3(long x, long y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public long test4(long x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public long test5(long a, long b, long c, long d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public long test6(long a, long b, long c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public long test7(long a, long b, long c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public long test8(long a, long b, long c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public long test9(long x, long y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public long test10(long x, long y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public long test11(long x, long y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public long test12(long x, long y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x + 0 => x\n+    public long test13(long x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks 0 + x => x\n+    public long test14(long x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public long test15(long a, long b, long c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public long test16(long a, long b, long c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL, \"1\", IRNode.ADD, \"1\"})\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public long test18(long a, long b, long c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivINodeIdealizationTests\n+ *\/\n+public class DivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return x \/ 1;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return x \/ (13 \/ 13);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public int divByNegOne(int x) {\n+        return x \/ -1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n+    public int divByPow2And(int x) {\n+        return (x & -4) \/ 2;\n+    }\n+\n+    @Run(test = \"divByPow2And\")\n+    public void runDivByPow2And() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x & -4) \/ 2), divByPow2And(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n+    public int divByPow2And1(int x) {\n+        return (x & -2) \/ 2;\n+    }\n+\n+    @Run(test = \"divByPow2And1\")\n+    public void runDivByPow2And1() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ(((x & -2) \/ 2), divByPow2And1(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n+    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n+    public int divByPow2(int x) {\n+        return x \/ 8;\n+    }\n+\n+    @Run(test = \"divByPow2\")\n+    public void runDivByPow2() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 8), divByPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                  IRNode.SUB_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public int divByNegPow2(int x) {\n+        return x \/ -8;\n+    }\n+\n+    @Run(test = \"divByNegPow2\")\n+    public void runDivByNegPow2() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ -8), divByNegPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.URSHIFT})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONVI2L, \"1\",\n+                  IRNode.CONVL2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ More tests can be made to cover the specific cases for differences in the\n+    \/\/ graph that depend upon different values for the \"magic constant\" and the\n+    \/\/ \"shift constant\"\n+    public int magicDiv(int x) {\n+        return x \/ 13;\n+    }\n+\n+    @Run(test = \"magicDiv\")\n+    public void runMagicDiv() {\n+        int x = RunInfo.getRandom().nextInt();\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+\n+        x = Integer.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+\n+        x = Integer.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 13), magicDiv(x));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivLNodeIdealizationTests\n+ *\/\n+public class DivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return x \/ 1L;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return x \/ (13L \/ 13L);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public long divByNegOne(long x) {\n+        return x \/ -1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for\n+    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n+    public long divByPow2And(long x) {\n+        return (x & -4L) \/ 2L;\n+    }\n+\n+    @Run(test = \"divByPow2And\")\n+    public void runDivByPow2And() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x & -4L) \/ 2L), divByPow2And(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then\n+    \/\/ the and can be removed as it only affects bits that will be shifted off\n+    public long divByPow2And1(long x) {\n+        return (x & -2L) \/ 2L;\n+    }\n+\n+    @Run(test = \"divByPow2And1\")\n+    public void runDivByPow2And1() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ(((x & -2L) \/ 2L), divByPow2And1(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account\n+    \/\/ for rounding when dealing with negative numbers. Since x may be negative\n+    \/\/ in this method, an additional add, logical right shift, and signed shift\n+    \/\/ are needed to account for rounding.\n+    public long divByPow2(long x) {\n+        return x \/ 8L;\n+    }\n+\n+    @Run(test = \"divByPow2\")\n+    public void runDivByPow2() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ((x \/ 8L), divByPow2(x));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public long divByNegPow2(long x) {\n+        return x \/ -8L;\n+    }\n+\n+    @Run(test = \"divByNegPow2\")\n+    public void runDivByNegPow2() {\n+        long x = RunInfo.getRandom().nextLong();\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+\n+        x = Long.MIN_VALUE;\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+\n+        x = Long.MAX_VALUE;\n+        Asserts.assertEQ((x \/ -8L), divByNegPow2(x));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -23,1 +23,1 @@\n-package ir_transformations;\n+package compiler.c2.irTests;\n@@ -25,0 +25,1 @@\n+import jdk.test.lib.Asserts;\n@@ -31,1 +32,1 @@\n- * @run driver ir_transformations.MulINodeIdealizationTests\n+ * @run driver compiler.c2.irTests.MulINodeIdealizationTests\n@@ -70,1 +71,1 @@\n-    public int moveConstants1(int x, int y) {\n+    public int moveConstantsAgain(int x, int y) {\n@@ -86,1 +87,1 @@\n-    public int multiplyZero1(int x) {\n+    public int multiplyZeroAgain(int x) {\n@@ -113,1 +114,1 @@\n-    public int identity1(int x) {\n+    public int identityAgain(int x) {\n@@ -131,1 +132,1 @@\n-    public int powerTwo1(int x) {\n+    public int powerTwoAgain(int x) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":7,"deletions":6,"binary":false,"changes":13,"previous_filename":"test\/hotspot\/jtreg\/ir_transformations\/MulINodeIdealizationTests.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package ir_transformations;\n+package compiler.c2.irTests;\n@@ -25,0 +25,1 @@\n+import jdk.test.lib.Asserts;\n@@ -31,1 +32,1 @@\n- * @run driver ir_transformations.MulLNodeIdealizationTests\n+ * @run driver compiler.c2.irTests.MulLNodeIdealizationTests\n@@ -70,1 +71,1 @@\n-    public long moveConstants1(long x, long y) {\n+    public long moveConstantsAgain(long x, long y) {\n@@ -86,1 +87,1 @@\n-    public long multiplyZero1(long x) {\n+    public long multiplyZeroAgain(long x) {\n@@ -113,1 +114,1 @@\n-    public long identity1(long x) {\n+    public long identityAgain(long x) {\n@@ -131,1 +132,1 @@\n-    public long powerTwo1(long x) {\n+    public long powerTwoAgain(long x) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulLNodeIdealizationTests.java","additions":7,"deletions":6,"binary":false,"changes":13,"previous_filename":"test\/hotspot\/jtreg\/ir_transformations\/MulLNodeIdealizationTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubINodeIdealizationTests\n+ *\/\n+public class SubINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public int test1(int x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public int test2(int x, int y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public int test3(int x, int y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => -y\n+    public int test4(int x, int y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => -y\n+    public int test5(int x, int y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => -y\n+    public int test6(int x, int y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public int test7(int x, int y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public int test8(int x, int y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public int test9(int x, int a, int b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public int test10(int x, int a, int b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public int test11(int x, int a, int b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public int test12(int x, int a, int b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public int test13(int a, int b, int c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 31) => a >> 31\n+    public int test14(int a) {\n+        return 0 - (a >> 31);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public int test15(int x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => y\n+    public int test16(int x, int y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public int test17(int x, int y) {\n+        return (x + y) - x;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public int test18(int a, int b, int c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public int test19(int a, int b, int c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public int test20(int a, int b, int c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public int test21(int a, int b, int c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubINodeIdealizationTests.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubLNodeIdealizationTests\n+ *\/\n+public class SubLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public long test1(long x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public long test2(long x, long y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public long test3(long x, long y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public long test4(long x, long y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public long test5(long x, long y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public long test6(long x, long y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public long test7(long x, long y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public long test8(long x, long a, long b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public long test9(long x, long a, long b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public long test10(long x, long a, long b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public long test11(long x, long a, long b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public long test12(long a, long b, long c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (a >> 63) => a >>> 63\n+    public long test13(long a) {\n+        return 0 - (a >> 63);\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public long test14(long x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public long test15(long a, long b, long c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public long test16(long a, long b, long c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.ADD})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public long test18(long a, long b, long c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubLNodeIdealizationTests.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -23,1 +23,1 @@\n-package ir_transformations;\n+package compiler.c2.irTests.loopOpts;\n@@ -31,1 +31,1 @@\n- * @run driver ir_transformations.LoopIdealizationTests\n+ * @run driver compiler.c2.irTests.loopOpts.LoopIdealizationTests\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/loopOpts\/LoopIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/ir_transformations\/LoopIdealizationTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @summary Tests that Escape Analisys and Scalar Replacement is able to handle some simple cases.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementTests\n+ *\/\n+public class ScalarReplacementTests {\n+    private class Person {\n+        private String name;\n+        private int age;\n+\n+        public Person(Person p) {\n+            this.name = p.getName();\n+            this.age = p.getAge();\n+        }\n+\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+\n+        public String getName() { return name; }\n+        public int getAge() { return age; }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String stringConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int intConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public String nestedStringConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedIntConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n+    public int nestedConstants(int age1, int age2) {\n+        Person p = new Person(\n+                        new Person(\"Java\", age1).getName(),\n+                        new Person(\"Java\", age2).getAge());\n+        return p.getAge();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementTests.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.AddINodeIdealizationTests\n- *\/\n-public class AddINodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks\n-    public int simpleZero(int x) {\n-        return (x + x) + (x + x);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n-    public int simpleZeroSub(int x) {\n-        return (x - x) + (x - x);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n-    public int simpleOne(int x) {\n-        return (x + 1) + 2;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + c1) + y => (x + y) + c1\n-    public int simpleTwo(int x, int y) {\n-        return (x + 2021) + y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks x + (y + c1) => (x + y) + c1\n-    public int simpleThree(int x, int y) {\n-        return x + (y + 2021);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n-    public int simpleFour(int x) {\n-        return (1 - x) + 2;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"2\",\n-                 })\n-    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n-    public int simpleFive(int a, int b, int c, int d) {\n-        return (a - b) + (c - d);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (a - b) + (b + c) => (a + c)\n-    public int simpleSix(int a, int b, int c) {\n-        return (a - b) + (b + c);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (a - b) + (c + b) => (a + c)\n-    public int simpleSeven(int a, int b, int c) {\n-        return (a - b) + (c + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a - b) + (b - c) => (a - c)\n-    public int simpleEight(int a, int b, int c) {\n-        return (a - b) + (b - c);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a - b) + (c - a) => (c - b)\n-    public int simpleNine(int a, int b, int c) {\n-        return (a - b) + (c - a);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x + (0 - y) => (x - y)\n-    public int simpleTen(int x, int y) {\n-        return x + (0 - y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (0 - y) + x => (x - y)\n-    public int simpleEleven(int x, int y) {\n-        return (0 - y) + x;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks (x - y) + y => x\n-    public int simpleTwelve(int x, int y) {\n-        return (x - y) + y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks y + (x - y) => x\n-    public int simpleThirteen(int x, int y) {\n-        return y + (x - y);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x + 0 => x\n-    public int simpleFourteen(int x) {\n-        return x + 0;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks 0 + x => x\n-    public int simpleFifteen(int x) {\n-        return 0 + x;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/AddINodeIdealizationTests.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,178 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.AddLNodeIdealizationTests\n- *\/\n-public class AddLNodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks\n-    public long simpleZero(long x) {\n-        return (x + x) + (x + x);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.SUB})\n-    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n-    public long simpleZeroSub(long x) {\n-        return (x - x) + (x - x);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n-    public long simpleOne(long x) {\n-        return (x + 1) + 2;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks (x + c1) + y => (x + y) + c1\n-    public long simpleTwo(long x, long y) {\n-        return (x + 2021) + y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"2\"})\n-    \/\/ Checks x + (y + c1) => (x + y) + c1\n-    public long simpleThree(long x, long y) {\n-        return x + (y + 2021);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n-    public long simpleFour(long x) {\n-        return (1 - x) + 2;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"2\",\n-                 })\n-    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n-    public long simpleFive(long a, long b, long c, long d) {\n-        return (a - b) + (c - d);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (a - b) + (b + c) => (a + c)\n-    public long simpleSix(long a, long b, long c) {\n-        return (a - b) + (b + c);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (a - b) + (c + b) => (a + c)\n-    public long simpleSeven(long a, long b, long c) {\n-        return (a - b) + (c + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a - b) + (c - a) => (c - b)\n-    public long simpleNine(long a, long b, long c) {\n-        return (a - b) + (c - a);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x + (0 - y) => (x - y)\n-    public long simpleTen(long x, long y) {\n-        return x + (0 - y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (0 - y) + x => (x - y)\n-    public long simpleEleven(long x, long y) {\n-        return (0 - y) + x;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks (x - y) + y => x\n-    public long simpleTwelve(long x, long y) {\n-        return (x - y) + y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks y + (x - y) => x\n-    public long simpleThirteen(long x, long y) {\n-        return y + (x - y);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x + 0 => x\n-    public long simpleFourteen(long x) {\n-        return x + 0;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks 0 + x => x\n-    public long simpleFifteen(long x) {\n-        return 0 + x;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/AddLNodeIdealizationTests.java","additions":0,"deletions":178,"binary":false,"changes":178,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.DivINodeIdealizationTests\n- *\/\n-public class DivINodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ x => 1\n-    public int constant(int x) {\n-        return x \/ x;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ 1 => x\n-    public int identity(int x) {\n-        return x \/ 1;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ (c \/ c) => x\n-    public int identity1(int x) {\n-        return x \/ (13 \/ 13);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ (y \/ y) => x\n-    public int identity2(int x, int y) {\n-        return x \/ (y \/ y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n-    @IR(counts = {IRNode.MUL_I, \"1\",\n-                  IRNode.TRAP, \"1\"\n-                 })\n-    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n-    public int retainDenominator(int x, int y) {\n-        return (x * y) \/ y;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    \/\/ Checks x \/ -1 => 0 - x\n-    public int divByNegOne(int x) {\n-        return x \/ -1;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    @IR(counts = {IRNode.AND, \"1\",\n-                  IRNode.RSHIFT, \"1\",\n-                 })\n-    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n-    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n-    public int divByPow2And(int x) {\n-        return (x & -4) \/ 2;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n-    @IR(counts = {IRNode.RSHIFT, \"1\"})\n-    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n-    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n-    public int divByPow2And1(int x) {\n-        return (x & -2) \/ 2;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.URSHIFT, \"1\",\n-                  IRNode.RSHIFT, \"2\",\n-                  IRNode.ADD_I, \"1\",\n-                 })\n-    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n-    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n-    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n-    public int divByPow2(int x) {\n-        return x \/ 8;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.URSHIFT, \"1\",\n-                  IRNode.RSHIFT, \"2\",\n-                  IRNode.ADD_I, \"1\",\n-                  IRNode.SUB_I, \"1\",\n-                 })\n-    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n-    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n-    \/\/ After the transformations, 0 is subtracted by the whole expression\n-    \/\/ to account for the negative.\n-    public int divByNegPow2(int x) {\n-        return x \/ -8;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.DIV, IRNode.URSHIFT})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.MUL, \"1\",\n-                  IRNode.CONVI2L, \"1\",\n-                  IRNode.CONVL2I, \"1\",\n-                 })\n-    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n-    \/\/ More tests can be made to cover the specific cases for differences in the\n-    \/\/ graph that depend upon different values for the \"magic constant\" and the\n-    \/\/ \"shift constant\"\n-    public int magicDiv(int x) {\n-        return x \/ 13;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/DivINodeIdealizationTests.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.DivLNodeIdealizationTests\n- *\/\n-public class DivLNodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ x => 1\n-    public long constant(long x) {\n-        return x \/ x;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ 1 => x\n-    public long identity(long x) {\n-        return x \/ 1L;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ (c \/ c) => x\n-    public long identity1(long x) {\n-        return x \/ (13L \/ 13L);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    \/\/ Checks x \/ (y \/ y) => x\n-    public long identity2(long x, long y) {\n-        return x \/ (y \/ y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.ADD, IRNode.SUB})\n-    @IR(counts = {IRNode.MUL_L, \"1\",\n-                  IRNode.TRAP, \"1\"\n-                 })\n-    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n-    public long retainDenominator(long x, long y) {\n-        return (x * y) \/ y;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x \/ -1 => 0 - x\n-    public long divByNegOne(long x) {\n-        return x \/ -1L;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB})\n-    @IR(counts = {IRNode.AND, \"1\",\n-                  IRNode.RSHIFT, \"1\",\n-                 })\n-    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n-    \/\/ Having a large enough and in the dividend removes the need to account for\n-    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n-    public long divByPow2And(long x) {\n-        return (x & -4L) \/ 2L;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.SUB, IRNode.AND})\n-    @IR(counts = {IRNode.RSHIFT, \"1\"})\n-    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n-    \/\/ If the negative of the constant within the & equals the divisor then\n-    \/\/ the and can be removed as it only affects bits that will be shifted off\n-    public long divByPow2And1(long x) {\n-        return (x & -2L) \/ 2L;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.URSHIFT, \"1\",\n-                  IRNode.RSHIFT, \"2\",\n-                  IRNode.ADD, \"1\",\n-                 })\n-    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n-    \/\/ An additional (dividend - 1) needs to be added to the shift to account\n-    \/\/ for rounding when dealing with negative numbers. Since x may be negative\n-    \/\/ in this method, an additional add, logical right shift, and signed shift\n-    \/\/ are needed to account for rounding.\n-    public long divByPow2(long x) {\n-        return x \/ 8L;\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.URSHIFT, \"1\",\n-                  IRNode.RSHIFT, \"2\",\n-                  IRNode.ADD, \"1\",\n-                  IRNode.SUB, \"1\",\n-                 })\n-    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n-    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n-    \/\/ After the transformations, 0 is subtracted by the whole expression\n-    \/\/ to account for the negative.\n-    public long divByNegPow2(long x) {\n-        return x \/ -8L;\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/DivLNodeIdealizationTests.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Tests that Escape Analisys and Scalar Replacement is able to handle some simple cases.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.EscapeAnalysisAndScalarReplacement\n- *\/\n-public class EscapeAnalysisAndScalarReplacement {\n-    private class Person {\n-        private String name;\n-        private int age;\n-\n-        public Person(Person p) {\n-            this.name = p.getName();\n-            this.age = p.getAge();\n-        }\n-\n-        public Person(String name, int age) {\n-            this.name = name;\n-            this.age = age;\n-        }\n-\n-        public String getName() { return name; }\n-        public int getAge() { return age; }\n-        public String toString() { return \"Name: \" + name + \" \\t Age: \" + age; }\n-    }\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @DontInline\n-    private void blackhole(Person p) { }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    public String stringConstant(int age) {\n-        Person p = new Person(\"Java\", age);\n-        return p.getName();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    public int intConstant(int age) {\n-        Person p = new Person(\"Java\", age);\n-        return p.getAge();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    public String nestedStringConstant(int age) {\n-        Person p1 = new Person(\"Java\", age);\n-        Person p2 = new Person(p1);\n-        return p2.getName();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    public int nestedIntConstant(int age) {\n-        Person p1 = new Person(\"Java\", age);\n-        Person p2 = new Person(p1);\n-        return p2.getAge();\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    public int nestedConstants(int age1, int age2) {\n-        Person p = new Person(\n-                        new Person(\"Java\", age1).getName(),\n-                        new Person(\"Java\", age2).getAge());\n-        return p.getAge();\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS})\n-    @IR(counts = {IRNode.TRAP, \"1\"})\n-    public int infrequentEscape(int age1, int age2) {\n-        Person p = new Person(\"Java\", age1);\n-\n-        if (age1 == age2) {\n-            this.blackhole(p);\n-        }\n-\n-        return p.getAge();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/EscapeAnalysisAndScalarReplacement.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,192 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.SubINodeIdealizationTests\n- *\/\n-public class SubINodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (x - c0) => x + (-c0)\n-    public int simpleOne(int x) {\n-        return (x - 1);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.ADD, \"1\",\n-                  IRNode.SUB, \"1\"\n-                 })\n-    \/\/ Checks (x + c0) - y => (x - y) + c0\n-    public int simpleTwo(int x, int y) {\n-        return (x + 1) - y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"1\"\n-                 })\n-    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n-    public int simpleThree(int x, int y) {\n-        return x - (y + 2021);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x - (x + y) => -y\n-    public int simpleFour(int x, int y) {\n-        return x - (x + y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (x - y) - x => -y\n-    public int simpleFive(int x, int y) {\n-        return (x - y) - x;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x - (y + x) => -y\n-    public int simpleSix(int x, int y) {\n-        return x - (y + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks 0 - (x - y) => y - x\n-    public int simpleSeven(int x, int y) {\n-        return 0 - (x - y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks 0 - (x + 2021) => -2021 - x\n-    public int simpleEight(int x, int y) {\n-        return 0 - (x + 2021);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (x + a) - (x + b) => a - b;\n-    public int simpleNine(int x, int a, int b) {\n-        return (x + a) - (x + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a + x) - (b + x) => a - b\n-    public int simpleTen(int x, int a, int b) {\n-        return (a + x) - (b + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a + x) - (x + b) => a - b\n-    public int simpleEleven(int x, int a, int b) {\n-        return (a + x) - (x + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (x + a) - (b + x) => a - b\n-    public int simpleTwelve(int x, int a, int b) {\n-        return (x + a) - (b + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"1\"\n-                 })\n-    \/\/ Checks a - (b - c) => (a + c) - b\n-    public int simpleThirteen(int a, int b, int c) {\n-        return a - (b - c);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks 0 - (a >> 31) => a >> 31\n-    public int simpleFourteen(int a) {\n-        return 0 - (a >> 31);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks 0 - (0 - x) => x\n-    public int simpleFifteen(int x) {\n-        return 0 - (0 - x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks (x + y) - y => y\n-    public int simpleSixteen(int x, int y) {\n-        return (x + y) - y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks (x + y) - x => y\n-    public int simpleSeventeen(int x, int y) {\n-        return (x + y) - x;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/SubINodeIdealizationTests.java","additions":0,"deletions":192,"binary":false,"changes":192,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package ir_transformations;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver ir_transformations.SubLNodeIdealizationTests\n- *\/\n-public class SubLNodeIdealizationTests {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB})\n-    @IR(counts = {IRNode.ADD, \"1\"})\n-    \/\/ Checks (x - c0) => x + (-c0)\n-    public long simpleOne(long x) {\n-        return (x - 1);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.ADD, \"1\",\n-                  IRNode.SUB, \"1\"\n-                 })\n-    \/\/ Checks (x + c0) - y => (x - y) + c0\n-    public long simpleTwo(long x, long y) {\n-        return (x + 1) - y;\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"1\"\n-                 })\n-    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n-    public long simpleThree(long x, long y) {\n-        return x - (y + 2021);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x - (x + y) => 0 - y\n-    public long simpleFour(long x, long y) {\n-        return x - (x + y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks x - (y + x) => 0 - y\n-    public long simpleSix(long x, long y) {\n-        return x - (y + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks 0 - (x - y) => y - x\n-    public long simpleSeven(long x, long y) {\n-        return 0 - (x - y);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks 0 - (x + 2021) => -2021 - x\n-    public long simpleEight(long x, long y) {\n-        return 0 - (x + 2021);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (x + a) - (x + b) => a - b;\n-    public long simpleNine(long x, long a, long b) {\n-        return (x + a) - (x + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a + x) - (b + x) => a - b\n-    public long simpleTen(long x, long a, long b) {\n-        return (a + x) - (b + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (a + x) - (x + b) => a - b\n-    public long simpleEleven(long x, long a, long b) {\n-        return (a + x) - (x + b);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.ADD})\n-    @IR(counts = {IRNode.SUB, \"1\"})\n-    \/\/ Checks (x + a) - (b + x) => a - b\n-    public long simpleTwelve(long x, long a, long b) {\n-        return (x + a) - (b + x);\n-    }\n-\n-    @Test\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV})\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.ADD, \"1\"\n-                 })\n-    \/\/ Checks a - (b - c) => (a + c) - b\n-    public long simpleThirteen(long a, long b, long c) {\n-        return a - (b - c);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks 0 - (a >> 63) => a >>> 63\n-    public long simpleFourteen(long a) {\n-        return 0 - (a >> 63);\n-    }\n-\n-    @Test\n-    @Arguments(Argument.RANDOM_EACH)\n-    @IR(failOn = {IRNode.LOAD, IRNode.STORE, IRNode.MUL, IRNode.DIV, IRNode.SUB, IRNode.ADD})\n-    \/\/ Checks 0 - (0 - x) => x\n-    public long simpleFifteen(long x) {\n-        return 0 - (0 - x);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/ir_transformations\/SubLNodeIdealizationTests.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"}]}