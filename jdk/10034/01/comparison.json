{"files":[{"patch":"@@ -9456,0 +9456,16 @@\n+\n+void MacroAssembler::check_stack_alignment(Register sp, const char* msg, unsigned bias, Register tmp) {\n+  Label L_stack_ok;\n+  if (bias == 0) {\n+    testptr(sp, 2 * wordSize - 1);\n+  } else {\n+    \/\/ lea(tmp, Address(rsp, bias);\n+    mov(tmp, sp);\n+    addptr(tmp, bias);\n+    testptr(tmp, 2 * wordSize - 1);\n+  }\n+  jcc(Assembler::equal, L_stack_ok);\n+  block_comment(msg);\n+  stop(msg);\n+  bind(L_stack_ok);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2097,0 +2097,3 @@\n+\n+  void check_stack_alignment(Register sp, const char* msg, unsigned bias = 0, Register tmp = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -618,3 +618,1 @@\n-  \/\/ Interpreter::stackElementSize is the space we need. Plus 1 because\n-  \/\/ we also account for the return address location since\n-  \/\/ we store it first rather than hold it in rax across all the shuffling\n+  \/\/ Interpreter::stackElementSize is the space we need.\n@@ -622,1 +620,3 @@\n-  int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;\n+  assert(total_args_passed >= 0, \"total_args_passed is %d\", total_args_passed);\n+\n+  int extraspace = (total_args_passed * Interpreter::stackElementSize);\n@@ -625,0 +625,2 @@\n+  \/\/ This is not currently needed or enforced by the interpreter, but\n+  \/\/ we might as well conform to the ABI.\n@@ -627,3 +629,0 @@\n-  \/\/ Get return address\n-  __ pop(rax);\n-\n@@ -631,1 +630,1 @@\n-  __ mov(r13, rsp);\n+  __ lea(r13, Address(rsp, wordSize));\n@@ -633,1 +632,6 @@\n-  __ subptr(rsp, extraspace);\n+#ifdef ASSERT\n+  __ check_stack_alignment(r13, \"sender stack not aligned\");\n+#endif\n+  if (extraspace > 0) {\n+    \/\/ Pop the return address\n+    __ pop(rax);\n@@ -635,2 +639,13 @@\n-  \/\/ Store the return address in the expected location\n-  __ movptr(Address(rsp, 0), rax);\n+    __ subptr(rsp, extraspace);\n+\n+    \/\/ Push the return address\n+    __ push(rax);\n+\n+    \/\/ Account for the return address location since we store it first rather\n+    \/\/ than hold it in a register across all the shuffling\n+    extraspace += wordSize;\n+  }\n+\n+#ifdef ASSERT\n+  __ check_stack_alignment(rsp, \"callee stack not aligned\", wordSize, rax);\n+#endif\n@@ -782,3 +797,0 @@\n-  \/\/ Pick up the return address\n-  __ movptr(rax, Address(rsp, 0));\n-\n@@ -792,0 +804,2 @@\n+    \/\/ Pick up the return address\n+    __ movptr(rax, Address(rsp, 0));\n@@ -816,3 +830,6 @@\n-  \/\/ Cut-out for having no stack args.  Since up to 2 int\/oop args are passed\n-  \/\/ in registers, we will occasionally have no stack args.\n-  int comp_words_on_stack = 0;\n+  \/\/ Pick up the return address\n+  __ pop(rax);\n+\n+  \/\/ Convert 4-byte c2 stack slots to words.\n+  int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n+\n@@ -820,8 +837,0 @@\n-    \/\/ Sig words on the stack are greater-than VMRegImpl::stack0.  Those in\n-    \/\/ registers are below.  By subtracting stack0, we either get a negative\n-    \/\/ number (all values in registers) or the maximum stack slot accessed.\n-\n-    \/\/ Convert 4-byte c2 stack slots to words.\n-    comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n-    \/\/ Round up to miminum stack alignment, in wordSize\n-    comp_words_on_stack = align_up(comp_words_on_stack, 2);\n@@ -831,1 +840,0 @@\n-\n@@ -1757,9 +1765,1 @@\n-    {\n-      Label L;\n-      __ mov(rax, rsp);\n-      __ andptr(rax, -16); \/\/ must be 16 byte boundary (see amd64 ABI)\n-      __ cmpptr(rax, rsp);\n-      __ jcc(Assembler::equal, L);\n-      __ stop(\"improperly aligned stack\");\n-      __ bind(L);\n-    }\n+  __ check_stack_alignment(rsp, \"improperly aligned stack\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"}]}