{"files":[{"patch":"@@ -125,0 +125,2 @@\n+  _allocation_rate.allocation_counter_reset();\n+  _available_at_cycle_start = ShenandoahHeap::heap()->free_set()->available();\n@@ -130,1 +132,1 @@\n-  double available = ShenandoahHeap::heap()->free_set()->available();\n+  size_t available = ShenandoahHeap::heap()->free_set()->available();\n@@ -139,1 +141,1 @@\n-                      byte_size_in_proper_unit(size_t(available)), proper_unit_for_byte_size(size_t(available)),\n+                      byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n@@ -202,0 +204,1 @@\n+  size_t allocated = heap->bytes_allocated_since_gc_start();\n@@ -207,2 +210,0 @@\n-  size_t bytes_allocated_since_gc_start = heap->bytes_allocated_since_gc_start();\n-\n@@ -210,1 +211,1 @@\n-  _allocation_rate.sample(bytes_allocated_since_gc_start);\n+  _allocation_rate.sample(allocated);\n@@ -213,19 +214,0 @@\n-  if (is_available_below_min_threshold(capacity, available)) {\n-    return true;\n-  }\n-\n-  if (is_learning_necessary(capacity, available)) {\n-    return true;\n-  }\n-\n-  if (is_allocation_rate_too_high(capacity, available, bytes_allocated_since_gc_start)) {\n-    return true;\n-  }\n-\n-  return ShenandoahHeuristics::should_start_gc();\n-}\n-\n-bool ShenandoahAdaptiveHeuristics::is_available_below_min_threshold(size_t capacity,\n-                                                                    size_t available) const {\n-  \/\/ Check if we are falling below the worst limit, time to trigger the GC, regardless of\n-  \/\/ anything else.\n@@ -239,2 +221,0 @@\n-  return false;\n-}\n@@ -242,2 +222,0 @@\n-bool ShenandoahAdaptiveHeuristics::is_learning_necessary(size_t capacity,\n-                                                         size_t available) const {\n@@ -255,2 +233,0 @@\n-  return false;\n-}\n@@ -258,3 +234,0 @@\n-bool ShenandoahAdaptiveHeuristics::is_allocation_rate_too_high(size_t capacity,\n-                                                               size_t available,\n-                                                               size_t bytes_allocated_since_gc_start) {\n@@ -272,6 +245,6 @@\n-  double average_cycle_seconds = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n-  double bytes_allocated_per_second = _allocation_rate.upper_bound(_margin_of_error_sd);\n-  if (average_cycle_seconds > allocation_headroom \/ bytes_allocated_per_second) {\n-    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n-                 average_cycle_seconds * 1000,\n-                 byte_size_in_proper_unit(bytes_allocated_per_second), proper_unit_for_byte_size(bytes_allocated_per_second),\n+  double avg_cycle_time = _gc_time_history->davg() + (_margin_of_error_sd * _gc_time_history->dsd());\n+  double avg_alloc_rate = _allocation_rate.upper_bound(_margin_of_error_sd);\n+  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (margin of error = %.2f)\",\n+                 avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate),\n@@ -291,4 +264,5 @@\n-  double instantaneous_rate = _allocation_rate.instantaneous_rate(bytes_allocated_since_gc_start);\n-  if (_allocation_rate.is_spiking(instantaneous_rate) && average_cycle_seconds > allocation_headroom \/ instantaneous_rate) {\n-    log_info(gc)(\"Trigger: Instantaneous allocation rate (%.0f %sB\/s) will deplete free headroom (\" SIZE_FORMAT \"%s) before average time (%.2f ms) to complete GC cycle.\",\n-                 byte_size_in_proper_unit(instantaneous_rate), proper_unit_for_byte_size(instantaneous_rate),\n+  double instant_alloc_rate = _allocation_rate.instantaneous_rate(allocated);\n+  if (_allocation_rate.is_spiking(instant_alloc_rate) && avg_cycle_time > allocation_headroom \/ instant_alloc_rate) {\n+    log_info(gc)(\"Trigger: Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                 avg_cycle_time * 1000,\n+                 byte_size_in_proper_unit(instant_alloc_rate), proper_unit_for_byte_size(instant_alloc_rate),\n@@ -296,1 +270,1 @@\n-                 average_cycle_seconds * 1000);\n+                 _spike_threshold_sd);\n@@ -301,1 +275,1 @@\n-  return false;\n+  return ShenandoahHeuristics::should_start_gc();\n@@ -332,1 +306,1 @@\n-  _last_sample_time(os::javaTimeNanos()),\n+  _last_sample_time(os::elapsedTime()),\n@@ -334,1 +308,1 @@\n-  _interval_ns(NANOUNITS \/ ShenandoahAdaptiveSampleFrequencyHz),\n+  _interval_sec(1.0 \/ ShenandoahAdaptiveSampleFrequencyHz),\n@@ -339,9 +313,5 @@\n-void ShenandoahAllocationRate::sample(size_t bytes_allocated_since_gc_start) {\n-  jlong now = os::javaTimeNanos();\n-  if (now - _last_sample_time > _interval_ns) {\n-    if (bytes_allocated_since_gc_start > _last_sample_value) {\n-      size_t allocation_delta = bytes_allocated_since_gc_start - _last_sample_value;\n-      size_t time_delta_ns = now - _last_sample_time;\n-      double alloc_bytes_per_second = ((double) allocation_delta * NANOUNITS) \/ time_delta_ns;\n-\n-      _rate.add(alloc_bytes_per_second);\n+void ShenandoahAllocationRate::sample(size_t allocated) {\n+  jlong now = os::elapsedTime();\n+  if (now - _last_sample_time > _interval_sec) {\n+    if (allocated > _last_sample_value) {\n+      _rate.add(instantaneous_rate(now, allocated));\n@@ -352,1 +322,1 @@\n-    _last_sample_value = bytes_allocated_since_gc_start;\n+    _last_sample_value = allocated;\n@@ -365,1 +335,1 @@\n-  _last_sample_time = os::javaTimeNanos();\n+  _last_sample_time = os::elapsedTime();\n@@ -369,3 +339,3 @@\n-bool ShenandoahAllocationRate::is_spiking(double instantaneous_rate) const {\n-  double standard_deviation = _rate.sd();\n-  if (standard_deviation > 0) {\n+bool ShenandoahAllocationRate::is_spiking(double rate) const {\n+  double sd = _rate.sd();\n+  if (sd > 0) {\n@@ -374,1 +344,1 @@\n-    double z_score = (instantaneous_rate - _rate.avg()) \/ standard_deviation;\n+    double z_score = (rate - _rate.avg()) \/ sd;\n@@ -382,5 +352,2 @@\n-double ShenandoahAllocationRate::instantaneous_rate(size_t bytes_allocated_since_gc_start) const {\n-  size_t allocation_delta = bytes_allocated_since_gc_start - _last_sample_value;\n-  size_t time_delta_ns = os::javaTimeNanos() - _last_sample_time;\n-  double alloc_bytes_per_second = ((double) allocation_delta * NANOUNITS) \/ time_delta_ns;\n-  return alloc_bytes_per_second;\n+double ShenandoahAllocationRate::instantaneous_rate(size_t allocated) const {\n+  return instantaneous_rate(os::elapsedTime(), allocated);\n@@ -388,0 +355,6 @@\n+\n+double ShenandoahAllocationRate::instantaneous_rate(double time, size_t allocated) const {\n+  size_t allocation_delta = allocated - _last_sample_value;\n+  double time_delta_sec = time - _last_sample_time;\n+  return allocation_delta \/ time_delta_sec;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":40,"deletions":67,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  void sample(size_t bytes_allocated_since_gc_start);\n+  void sample(size_t allocated);\n@@ -44,1 +44,1 @@\n-  bool is_spiking(double instantaneous_rate) const;\n+  bool is_spiking(double rate) const;\n@@ -46,1 +46,1 @@\n-  double instantaneous_rate(size_t bytes_allocated_since_gc_start) const;\n+  double instantaneous_rate(size_t allocated) const;\n@@ -49,0 +49,3 @@\n+\n+  double instantaneous_rate(double time, size_t allocated) const;\n+\n@@ -50,1 +53,1 @@\n-  size_t _last_sample_time;\n+  double _last_sample_time;\n@@ -52,1 +55,1 @@\n-  uint _interval_ns;\n+  double _interval_sec;\n@@ -78,7 +81,0 @@\n- protected:\n-  bool is_available_below_min_threshold(size_t capacity, size_t available) const;\n-  bool is_learning_necessary(size_t capacity, size_t available) const;\n-  bool is_allocation_rate_too_high(size_t capacity,\n-                                   size_t available,\n-                                   size_t bytes_allocated_since_gc_start);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"}]}