{"files":[{"patch":"@@ -127,1 +127,1 @@\n-  if (ClassUnloadingWithConcurrentMark && obj_is_dead) {\n+  if (ClassUnloading && obj_is_dead) {\n@@ -144,1 +144,8 @@\n-  if (ClassUnloadingWithConcurrentMark) {\n+  \/\/ When class unloading is enabled it is not safe to only consider top() to conclude if the\n+  \/\/ given pointer is a valid object. The situation can occur both for class unloading in a\n+  \/\/ Full GC and during a concurrent cycle.\n+  \/\/ During a Full GC regions can be excluded from compaction due to high live ratio, and\n+  \/\/ because of this there can be stale objects for unloaded classes left in these regions.\n+  \/\/ During a concurrent cycle class unloading is done after marking is complete and objects\n+  \/\/ for the unloaded classes will be stale until the regions are collected.\n+  if (ClassUnloading) {\n@@ -151,1 +158,1 @@\n-  assert(ClassUnloadingWithConcurrentMark,\n+  assert(ClassUnloading,\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"}]}