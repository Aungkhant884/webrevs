{"files":[{"patch":"@@ -127,1 +127,1 @@\n-  if (ClassUnloadingWithConcurrentMark && obj_is_dead) {\n+  if (ClassUnloading && obj_is_dead) {\n@@ -144,5 +144,7 @@\n-  \/\/ In full gc, we might have skipped compacting some heap regions with high live ratio,\n-  \/\/ for objs in these regions, the corresponding class info might have been unloaded if\n-  \/\/ they're not marked in the full gc.\n-  \/\/ So, only when ClassUnloading is false, it's safe to tell an obj is indeed an obj when\n-  \/\/ it's under the top of the region, otherwise we have to go to the slow path below.\n+  \/\/ When class unloading is enabled it is not safe to only consider top() to conclude if the\n+  \/\/ given pointer is a valid object. The situation can occur both for class unloading in a\n+  \/\/ Full GC and during a concurrent cycle.\n+  \/\/ During a Full GC regions can be excluded from compaction due to high live ratio, and\n+  \/\/ because of this there can be stale objects for unloaded classes left in these regions.\n+  \/\/ During a concurrent cycle class unloading is done after marking is complete and objects\n+  \/\/ for the unloaded classes will be stale until the regions are collected.\n@@ -156,1 +158,1 @@\n-  assert(ClassUnloadingWithConcurrentMark,\n+  assert(ClassUnloading,\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"}]}