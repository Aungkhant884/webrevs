{"files":[{"patch":"@@ -39,1 +39,1 @@\n- * ASN.1 stream formatter; a debugging utility for visualizing the contents of ASN.1 streams.\n+ * ASN.1 stream formatter; a debugging utility for visualizing the contents of an ASN.1 stream.\n@@ -46,3 +46,5 @@\n- * The formatter reads the sequence of tagged items in the stream and prints\n- * a description of each tag and contents.  Generally, each tagged value is printed on\n- * a separate line. For constructed and application tags the nested tagged values are indented.\n+ * The formatter reads a single tag from the stream and prints a description\n+ * of the tag and its contents. If the tag is a constructed tag, set or sequence,\n+ * each of the contained tags is read and printed.\n+ * Generally, each tagged value is printed on a separate line. For constructed and application\n+ * tags the nested tagged values are indented.\n@@ -81,1 +83,0 @@\n- *                                  .withOffsetFormat(\"%04x: \")\n@@ -99,0 +100,1 @@\n+\n@@ -107,0 +109,1 @@\n+     * A single well formed tagged-value is read and annotated.\n@@ -122,0 +125,1 @@\n+     * A single well formed tagged-value is read and annotated.\n@@ -141,0 +145,1 @@\n+        int origAvailable = available;\n@@ -142,0 +147,1 @@\n+\/\/            System.out.println(prefix + \"avail: \" + available);\n@@ -163,2 +169,2 @@\n-                            \", Range of length error: \" + len + \"bytes. Attempting to continue\");\n-                    continue;\n+                            \", Range of length error: \" + len + \"bytes\");\n+                    return available;       \/\/ return the unread length\n@@ -166,9 +172,5 @@\n-                if (nbytes == 0) {\n-                    len = -1;       \/\/ indefinite length\n-                } else {\n-                    len = 0;\n-                    for (; nbytes > 0; nbytes--) {\n-                        int inc = in.readByte() & 0xff;\n-                        len = (len << 8) | (0xff & inc);\n-                        available -= nbytes;\n-                    }\n+                len = 0;\n+                for (; nbytes > 0; nbytes--) {\n+                    int inc = in.readByte() & 0xff;\n+                    len = (len << 8) | (0xff & inc);\n+                    available -= nbytes;\n@@ -181,0 +183,4 @@\n+            if (available < 0 && origAvailable < 0) {\n+                \/\/ started out unknown; set available to the length of this tagged value\n+                available = len;\n+            }\n@@ -183,1 +189,1 @@\n-                case TAG_EndOfContent:     \/\/ End-of-contents octets; len == 0\n+                case TAG_EndOfContent:    \/\/ End-of-contents octets; len == 0\n@@ -185,1 +191,2 @@\n-                    break;\n+                    \/\/ end of indefinite-length constructed, return any remaining\n+                    return available;\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ASN1Formatter.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-     * <LI>byte offset format: hexadecimal width 7 and a space, {@code \"%04x: \"},\n+     * <LI>byte offset format: hexadecimal width 4, colon, and a space, {@code \"%04x: \"},\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/HexPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}