{"files":[{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hexdump;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Base64;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary ASN.1 formatting\n+ * @library \/test\/lib\n+ * @compile ASN1FormatterTest.java\n+ * @run testng jdk.test.lib.hexdump.ASN1FormatterTest\n+ *\/\n+@Test\n+public class ASN1FormatterTest {\n+    private static final String DIR = System.getProperty(\"test.src\", \".\");\n+\n+    @Test\n+    static void testPEM() throws IOException {\n+        String certFile = \"openssl.p12.pem\";\n+        Path certPath = Path.of(DIR, certFile);\n+        System.out.println(\"certPath: \" + certPath);\n+\n+        try (InputStream certStream = Files.newInputStream(certPath)) {\n+            while (certStream.read() != '\\n') {\n+                \/\/ Skip first line \"-----BEGIN CERTIFICATE-----\"\n+            }\n+            \/\/ Mime decoder for Certificate\n+            InputStream wis = Base64.getMimeDecoder().wrap(certStream);\n+            DataInputStream is = new DataInputStream(wis);\n+            String result = ASN1Formatter.formatter().annotate(is);\n+            System.out.println(result);\n+\n+            Assert.assertEquals(result.lines().count(), 76, \"Lines\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(),24, \"Sequences\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), 17, \"ObjectIDs\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), 2, \"UTCTIME\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), 2, \"BitStrings\");\n+        } catch (EOFException eof) {\n+            \/\/ done\n+        }\n+    }\n+\n+    @Test\n+    static void dumpPEM() throws IOException {\n+        String file = \"openssl.p12.pem\";\n+        Path path = Path.of(DIR, file);\n+        System.out.println(\"path: \" + path);\n+\n+        try (InputStream certStream = Files.newInputStream(path)) {\n+            while (certStream.read() != '\\n') {\n+                \/\/ Skip first line \"-----BEGIN CERTIFICATE-----\"\n+            }\n+            \/\/ Mime decoder for Certificate\n+            InputStream wis = Base64.getMimeDecoder().wrap(certStream);\n+\n+            HexPrinter p = HexPrinter.simple()\n+                    .formatter(ASN1Formatter.formatter(), \"; \", 100);\n+            String result = p.toString(wis);\n+            System.out.println(result);\n+\n+            Assert.assertEquals(result.lines().count(), 126, \"Lines\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(), 24, \"Sequences\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), 17, \"ObjectIDs\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), 2, \"UTCTIME\");\n+            Assert.assertEquals(result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), 2, \"BitStrings\");\n+        } catch (EOFException eof) {\n+            \/\/ done\n+        }\n+    }\n+\n+    @Test\n+    static void testMain() {\n+        String file = \"openssl.p12.pem\";\n+        Path path = Path.of(DIR, file);\n+        String[] args = { path.toString() };\n+        System.out.println(\"path: \" + path);\n+        ASN1Formatter.main(args);\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/ASN1FormatterTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -81,1 +81,1 @@\n-                {\"simple\", \"%5d: \", \"%02x \", 16, \" \/\/ \", 64, HexPrinter.Formatters.ASCII,  System.lineSeparator()},\n+                {\"simple\", \"%04x: \", \"%02x \", 16, \" \/\/ \", 64, HexPrinter.Formatters.ASCII, System.lineSeparator()},\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/HexPrinterTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/openssl.p12.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/security\/KeyStore\/PKCS12\/openssl.p12.pem","status":"copied"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.hexdump;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Base64;\n+\n+\/**\n+ * ASN.1 stream formatter; a debugging utility for visualizing the contents of ASN.1 streams.\n+ * The ANS1Formatter can be used standalone by calling the {@link #annotate(DataInputStream)}\n+ * or {@link #annotate(DataInputStream, Appendable)} methods.\n+ * The ASN1Formatter implements the Formatter interface so it can be used\n+ * with the {@code HexPrinter} as a formatter to display the ASN.1 tagged values\n+ * with the corresponding bytes.\n+ * <p>\n+ * The formatter reads the sequence of tagged items in the stream and prints\n+ * a description of each tag and contents.  Generally, each tagged value is printed on\n+ * a separate line. For constructed and application tags the nested tagged values are indented.\n+ * There are few consistency checks and an improperly encoded stream may produce\n+ * unpredictable output.\n+ * <p>\n+ * For example, to show the contents of a stream from a file.\n+ * <pre>{@code\n+ *         Path path = Path.of(DIR, \"xxx.pem\");\n+ *         try (InputStream certStream = Files.newInputStream(path)) {\n+ *             while (certStream.read() != '\\n') {\n+ *                 \/\/ Skip first line \"-----BEGIN CERTIFICATE-----\"\n+ *             }\n+ *             \/\/ Mime decoder for Certificate\n+ *             InputStream wis = Base64.getMimeDecoder().wrap(certStream);\n+ *             DataInputStream dis = new DataInputStream(wis);\n+ *             String result = ASN1Formatter.formatter().annotate(dis);\n+ *             System.out.println(result);\n+ *         } catch (EOFException eof) {\n+ *             \/\/ done\n+ *         }\n+ * }<\/pre>\n+ * When used as the formatter with {@code jdk.test.lib.hexdump.HexPrinter},\n+ * the formatted ASN.1 stream is displayed with the corresponding hex dump\n+ * of the stream contents.\n+ * <pre>{@code\n+ *         Path path = Path.of(DIR, \"xxx.pem\");\n+ *         try (InputStream certStream = Files.newInputStream(path)) {\n+ *             while (certStream.read() != '\\n') {\n+ *                 \/\/ Skip first line \"-----BEGIN CERTIFICATE-----\"\n+ *             }\n+ *             \/\/ Mime decoder for Certificate\n+ *             InputStream wis = Base64.getMimeDecoder().wrap(certStream);\n+ *\n+ *             HexPrinter p = HexPrinter.simple()\n+ *                                  .withOffsetFormat(\"%04x: \")\n+ *                                  .formatter(ASN1Formatter.formatter(), \"; \", 100);\n+ *             String result = p.toString(wis);\n+ *             System.out.println(result);\n+ *         } catch (EOFException eof) {\n+ *             \/\/ done\n+ *         }\n+ * }<\/pre>\n+ *\/\n+public class ASN1Formatter implements HexPrinter.Formatter {\n+\n+    \/**\n+     * Returns an ASN1Formatter.\n+     * @return an ASN1Formatter\n+     *\/\n+    public static ASN1Formatter formatter() {\n+        return new ASN1Formatter();\n+    }\n+    \/**\n+     * Create a ANS1Formatter.\n+     *\/\n+    private ASN1Formatter() {\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as an ASN.1 stream.\n+     *\n+     * @param in  a DataInputStream\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public String annotate(DataInputStream in) throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        try {\n+            this.annotate(in, sb);\n+        } finally {\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as a ASN.1.\n+     *\n+     * @param in  a DataInputStream\n+     * @param out an Appendable for the output\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public void annotate(DataInputStream in, Appendable out) throws IOException {\n+        annotate(in, out, -1, \"\");\n+    }\n+\n+    \/**\n+     * Read bytes from the stream and annotate the stream as ASN.1.\n+     *\n+     * @param in  a DataInputStream\n+     * @param out an Appendable for the output\n+     * @param available the number of bytes to read from the stream (if greater than zero)\n+     * @param prefix a string to prefix each line of output, used for indentation\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private int annotate(DataInputStream in, Appendable out, int available, String prefix) throws IOException {\n+        while (available != 0) {\n+            \/\/ Read the tag\n+            int tag = in.readByte() & 0xff;\n+            available--;\n+            if ((tag & 0x1f) == 0x1f) {\n+                \/\/ Multi-byte tag\n+                tag = 0;\n+                int tagbits;\n+                do {\n+                    tagbits = in.readByte();\n+                    available--;\n+                    tag = (tag << 7) | (tagbits & 0x7f);\n+                } while ((tagbits & 0x80) == 0x80);\n+            }\n+            \/\/ Decode the length\n+            int len = in.readByte() & 0xff;\n+            available--;\n+            if (len > 0x80) {\n+                \/\/ multi-byte encoded length\n+                int nbytes = len & 0x7f;\n+                if (nbytes > 4) {\n+                    out.append(\"***** Tag: \" + tagName(tag) +\n+                            \", Range of length error: \" + len + \"bytes. Attempting to continue\");\n+                    continue;\n+                }\n+                if (nbytes == 0) {\n+                    len = -1;       \/\/ indefinite length\n+                } else {\n+                    len = 0;\n+                    for (; nbytes > 0; nbytes--) {\n+                        int inc = in.readByte() & 0xff;\n+                        len = (len << 8) | (0xff & inc);\n+                        available -= nbytes;\n+                    }\n+                }\n+            } else if (len == 0x80) {\n+                \/\/ Tag with Indefinite-length; note the tag and continue parsing tags.\n+                out.append(prefix).append(tagName(tag)).append(\": INDEFINITE-LENGTH CONTENT\\n\");\n+                continue;\n+            }\n+            out.append(prefix);     \/\/ start with indent\n+            switch (tag) {\n+                case TAG_EndOfContent:     \/\/ End-of-contents octets; len == 0\n+                    out.append(\"END-OF-CONTENT \");\n+                    break;\n+                case TAG_Integer:\n+                case TAG_Enumerated:\n+                    switch (len) {\n+                        case 1:\n+                            out.append(String.format(\"BYTE %d, \", in.readByte()));\n+                            available -= 1;\n+                            break;\n+                        case 2:\n+                            out.append(String.format(\"SHORT %d, \", in.readShort()));\n+                            available -= 2;\n+                            break;\n+                        case 4:\n+                            out.append(String.format(\"INTEGER %d, \", in.readInt()));\n+                            available -= 4;\n+                            break;\n+                        case 8:\n+                            out.append(String.format(\"LONG %d, \", in.readLong()));\n+                            available -= 8;\n+                            break;\n+                        default:\n+                            formatBytes(in, out, len);\n+                            available -= len;\n+                            break;\n+                    }\n+                    break;\n+                case TAG_ObjectId:\n+                    byte[] oid = new byte[len];\n+                    int l1 = in.read(oid);\n+                    available -= l1;\n+                    String s = oidName(oid);\n+                    out.append(tagName(tag) + \" [\" + len + \"] \");\n+                    out.append(s);\n+                    out.append(' ');\n+                    break;\n+\n+                case TAG_OctetString:\n+                case TAG_UtcTime:\n+                case TAG_GeneralizedTime:\n+                    out.append(tagName(tag) + \" [\" + len + \"] \");\n+                    \/\/ fall through\n+                case TAG_PrintableString:\n+                case TAG_IA5String:\n+                case TAG_GeneralString: {\n+                    \/\/ Check if the contents are too long or not printable\n+                    byte[] buf = new byte[Math.min(64, len)];\n+                    final int l = in.read(buf, 0, buf.length);\n+                    if (countPrintable(buf, l) > l \/ 2) {\n+                        \/\/ If more than 1\/2 are printable, show the string\n+                        out.append(\"'\");\n+                        for (int i = 0; i < len; i++) {\n+                            char c = toASNPrintable((char) buf[i]);\n+                            out.append((c > 0) ? c : '.');\n+                        }\n+                        out.append(\"'\");\n+                        if (l < len) {\n+                            out.append(\"...\"); \/\/ identify the truncation\n+                        }\n+                        out.append(' ');\n+                    } else {\n+                        out.append(\"<Unprintable> \");\n+                    }\n+                    if (l < len) {\n+                        in.skip(len - l);   \/\/ skip the rest\n+                    }\n+                    available -= len;\n+                    break;\n+                }\n+                case TAG_Null:\n+                    out.append(\"NULL \");\n+                    break;\n+                case TAG_Boolean:\n+                    int b = in.readByte();\n+                    available--;\n+                    out.append((b == 0) ? \"FALSE \" : \"TRUE \");\n+                    break;\n+                case TAG_UTF8String:\n+                    out.append(getString(in, len, StandardCharsets.UTF_8));\n+                    out.append(' ');\n+                    available -= len;\n+                    break;\n+                case TAG_T61String:\n+                    out.append(getString(in, len, StandardCharsets.ISO_8859_1));\n+                    out.append(' ');\n+                    available -= len;\n+                    break;\n+                case TAG_UniversalString:\n+                case TAG_BMPString:\n+                    out.append(getString(in, len, StandardCharsets.UTF_16BE));\n+                    out.append(' ');\n+                    available -= len;\n+                    break;\n+                case TAG_BitString:\n+                    out.append(String.format(\"%s [%d]\", tagName(tag), len));\n+                    in.skip(len);\n+                    available -= len;\n+                    break;\n+                default: {\n+                    if (tag == TAG_Sequence ||\n+                            tag == TAG_Set ||\n+                            isApplication(tag) ||\n+                            isConstructed(tag)) {\n+                        \/\/ Handle nesting\n+                        if (isApplication(tag)) {\n+                            out.append(String.format(\"APPLICATION %d. [%d] {\\n\", tag & 0x1f, len));\n+                        } else {\n+                            out.append(String.format(\"%s [%d]\\n\", tagName(tag), len));\n+                        }\n+                        int remaining = annotate(in, out, len, prefix + \"  \");\n+                        available -= len - remaining;\n+                        continue;\n+                    } else {\n+                        \/\/ Any other tag not already handled, dump the bytes\n+                        out.append(String.format(\"%s[%d]: \", tagName(tag), len));\n+                        formatBytes(in, out, len);\n+                        available -= len;\n+                        break;\n+                    }\n+                }\n+            }\n+            out.append(\"\\n\");   \/\/ End with EOL\n+        }\n+        return available;\n+    }\n+\n+    \/**\n+     * Reads bytes from the stream and annotates them as hexadecimal.\n+     * @param in an inputStream\n+     * @param out the Appendable for the formatted bytes\n+     * @param len the number of bytes to read\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private void formatBytes(DataInputStream in, Appendable out, int len) throws IOException {\n+        int b = in.readByte() & 0xff;\n+        out.append(String.format(\"%02x\", b));\n+        for (int i = 1; i < len; i++) {\n+            b = in.readByte() & 0xff;\n+            out.append(String.format(\",%02x\", b));\n+        }\n+    }\n+\n+    \/**\n+     * Returns a string read from the stream converted to the Charset.\n+     * @param in an inputStream\n+     * @param len the number of bytes to read\n+     * @param charset the Charset\n+     * @return a string read from the stream converted to the Charset.\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private String getString(DataInputStream in, int len, Charset charset) throws IOException {\n+        byte[] bytes = new byte[len];\n+        int l = in.read(bytes);\n+        return new String(bytes, charset);\n+    }\n+\n+    \/**\n+     * Returns the tagname based on the tag value.\n+     * @param tag the tag value\n+     * @return a String representation of the tag.\n+     *\/\n+    private String tagName(int tag) {\n+        String cons = isConstructed(tag) ? \"cons \" : \"\";\n+        if (tag > 0 && tag < tagNames.length)\n+            return tagNames[tag] + \" \" + cons;\n+        if (tag == TAG_Set)\n+            return \"SET\";\n+        if (tag == TAG_Sequence)\n+            return \"SEQUENCE\";\n+        switch (tag & 0xc0) {\n+            case TAG_APPLICATION:\n+                return \"APPLICATION \" + cons + (tag & 0x1f);\n+            case TAG_PRIVATE:\n+                return \"PRIVATE \" + cons + (tag & 0x1f);\n+            case TAG_CONTEXT:\n+                return \"CONTEXT \" + cons + (tag & 0x1f);\n+            case TAG_UNIVERSAL:\n+                return \"UNIVERSAL \" + cons + (tag & 0x1f);\n+            default:\n+                return \"TAG__\" + (tag & 0xc0);\n+        }\n+\n+\/\/        return \"TAG_\" + tag;\n+    }\n+\n+    \/**\n+     * Returns the string representation of the OID extracted from the bytes.\n+     * The numeric OID is looked up in the internal sun.security.util.KnownOIDs class.\n+     * If a name is found it is added to the returned string.\n+     * @param bytes bytes holding the OID\n+     * @return a string representing OID or the numeric OID\n+     *\/\n+    private static String oidName(byte[] bytes) {\n+        StringBuilder sb = new StringBuilder(bytes.length * 4);\n+        int first = bytes[0] \/ 40;\n+        int second = bytes[0] % 40;\n+        sb.append(first).append('.').append(second);\n+        int valn = 0;\n+        for (int i = 1; i < bytes.length; i++) {\n+            valn = valn * 128 + (bytes[i] & 0x7f);\n+            if ((bytes[i] & 0x80) == 0) {\n+                sb.append('.');\n+                sb.append(valn);\n+                valn = 0;\n+            }\n+        }\n+        String noid = sb.toString();\n+        try {\n+            \/\/ Look up the OID; if the class is not accessible just return the numeric form\n+            Class<?> cl = Class.forName(\"sun.security.util.KnownOIDs\");\n+            Method findMatch = cl.getDeclaredMethod(\"findMatch\", String.class);\n+            findMatch.setAccessible(true);\n+            Object oid = findMatch.invoke(null, noid);\n+            return (oid == null) ? noid : noid + \" (\" + oid.toString() + \")\";\n+        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            return noid;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a printable character or zero for unprintable.\n+     * @param ch a character\n+     * @return a printable character or zero for unprintable\n+     *\/\n+    private static char toASNPrintable(char ch) {\n+        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n+                (ch >= '0' && ch <= '9')) {\n+            return ch;\n+        } else {\n+            switch (ch) {\n+                case ' ':       \/* space *\/\n+                case '\\'':      \/* apostrophe *\/\n+                case '(':       \/* left paren *\/\n+                case ')':       \/* right paren *\/\n+                case '+':       \/* plus *\/\n+                case ',':       \/* comma *\/\n+                case '-':       \/* hyphen *\/\n+                case '.':       \/* period *\/\n+                case '\/':       \/* slash *\/\n+                case ':':       \/* colon *\/\n+                case '=':       \/* equals *\/\n+                case '?':       \/* question mark *\/\n+                    return ch;\n+                default:\n+                    return 0;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the number of printable characters in the buffer range.\n+     * @param bytes a byte array\n+     * @param len the length of the bytes to check\n+     * @return the count of printable bytes\n+     *\/\n+    private static int countPrintable(byte[] bytes, int len) {\n+        int count = 0;\n+        for (int i = 0; i < len; i++) {\n+            count += (toASNPrintable((char)bytes[i]) > 0) ? 1 : 0;\n+        }\n+        return count;\n+    }\n+\n+    \/** The tag class types *\/\n+    private static final int TAG_UNIVERSAL = 0x00;\n+    private static final int TAG_APPLICATION = 0x40;\n+    private static final int TAG_CONTEXT = 0x80;\n+    private static final int TAG_PRIVATE = 0xc0;\n+\n+    \/*\n+     * The type starts at the first byte of the encoding, and\n+     * is one of these TAG_* values.  That may be all the type\n+     * data that is needed.\n+     *\/\n+\n+    \/*\n+     * These tags are the \"universal\" tags ... they mean the same\n+     * in all contexts.  (Mask with 0x1f -- five bits.)\n+     *\/\n+\n+\n+    \/** Tag value indicating an ASN.1 \"EndOfContent\" value. *\/\n+    private static final byte    TAG_EndOfContent = 0x0;\n+\n+    \/** Tag value indicating an ASN.1 \"BOOLEAN\" value. *\/\n+    private static final byte    TAG_Boolean = 0x1;\n+\n+    \/** Tag value indicating an ASN.1 \"INTEGER\" value. *\/\n+    private static final byte    TAG_Integer = 0x2;\n+\n+    \/** Tag value indicating an ASN.1 \"BIT STRING\" value. *\/\n+    private static final byte    TAG_BitString = 0x3;\n+\n+    \/** Tag value indicating an ASN.1 \"OCTET STRING\" value. *\/\n+    private static final byte    TAG_OctetString = 0x4;\n+\n+    \/** Tag value indicating an ASN.1 \"NULL\" value. *\/\n+    private static final byte    TAG_Null = 0x5;\n+\n+    \/** Tag value indicating an ASN.1 \"OBJECT IDENTIFIER\" value. *\/\n+    private static final byte    TAG_ObjectId = 0x6;\n+\n+    \/** Tag value including an ASN.1 \"ENUMERATED\" value *\/\n+    private static final byte    TAG_Enumerated = 0xA;\n+\n+    \/** Tag value indicating an ASN.1 \"UTF8String\" value. *\/\n+    private static final byte    TAG_UTF8String = 0xC;\n+\n+    \/** Tag value including a \"printable\" string *\/\n+    private static final byte    TAG_PrintableString = 0x13;\n+\n+    \/** Tag value including a \"teletype\" string *\/\n+    private static final byte    TAG_T61String = 0x14;\n+\n+    \/** Tag value including an ASCII string *\/\n+    private static final byte    TAG_IA5String = 0x16;\n+\n+    \/** Tag value indicating an ASN.1 \"UTCTime\" value. *\/\n+    private static final byte    TAG_UtcTime = 0x17;\n+\n+    \/** Tag value indicating an ASN.1 \"GeneralizedTime\" value. *\/\n+    private static final byte    TAG_GeneralizedTime = 0x18;\n+\n+    \/** Tag value indicating an ASN.1 \"GenerallString\" value. *\/\n+    private static final byte    TAG_GeneralString = 0x1B;\n+\n+    \/** Tag value indicating an ASN.1 \"UniversalString\" value. *\/\n+    private static final byte    TAG_UniversalString = 0x1C;\n+\n+    \/** Tag value indicating an ASN.1 \"BMPString\" value. *\/\n+    private static final byte    TAG_BMPString = 0x1E;\n+\n+    \/\/ CONSTRUCTED seq\/set\n+\n+    \/**\n+     * Tag value indicating an ASN.1\n+     * \"SEQUENCE\" (zero to N elements, order is significant).\n+     *\/\n+    private static final byte    TAG_Sequence = 0x30;\n+\n+    \/**\n+     * Tag value indicating an ASN.1\n+     * \"SET\" (zero to N members, order does not matter).\n+     *\/\n+    private static final byte    TAG_Set = 0x31;\n+\n+    \/*\n+     * These values are the high order bits for the other kinds of tags.\n+     *\/\n+\n+    \/**\n+     * Returns true if the tag class is UNIVERSAL.\n+     *\/\n+    private boolean isUniversal(int tag)      { return ((tag & 0xc0) == 0x0); }\n+\n+    \/**\n+     * Returns true if the tag class is APPLICATION.\n+     *\/\n+    private boolean isApplication(int tag)    { return ((tag & 0xc0) == TAG_APPLICATION); }\n+\n+     \/** Returns true iff the CONSTRUCTED bit is set in the type tag. *\/\n+    private boolean isConstructed(int tag)    { return ((tag & 0x20) == 0x20); }\n+\n+    \/\/ Names for tags.\n+    private static final String[] tagNames = new String[] {\n+            \"ANY\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\n+            \"NULL\", \"OBJECT ID\", \"OBJECT DESCRIPTION\", \"EXTERNAL\", \"REAL\",\n+            \"ENUMERATION\", \"u11\", \"UTF8 STRING\", \"u13\", \"u14\",\n+            \"u15\", \"SEQUENCE\", \"SET\", \"NUMERIC STRING\", \"STRING\",\n+            \"T61\", \"VIDEOTEXT\", \"IA5\", \"UTCTIME\", \"GENERAL TIME\",\n+            \"GRAPHIC STRING\", \"ISO64STRING\", \"GENERAL STRING\", \"UNIVERSAL STRING\", \"u29\",\n+            \"BMP STRING\",\n+    };\n+\n+    \/**\n+     * Simple utility to open and print contents of a file as ASN.1.\n+     * If the first line of the file looks like a certificate\n+     * it will be Base64 decoded and passed to the ASN.1 formatter.\n+     * @param args file names\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length < 1) {\n+            System.out.println(\"Usage:  <asn.1 files>\");\n+            return;\n+        }\n+        ASN1Formatter fmt = ASN1Formatter.formatter();\n+        for (String file : args) {\n+            System.out.printf(\"%s%n\", file);\n+            try (InputStream fis = Files.newInputStream(Path.of(file));\n+                 BufferedInputStream is = new BufferedInputStream(fis);\n+                 InputStream in = wrapIfBase64Mime(is)) {\n+\n+                DataInputStream dis = new DataInputStream(in);\n+                fmt.annotate(dis, System.out);\n+            } catch (EOFException eof) {\n+                System.out.println();\n+            } catch (IOException ioe) {\n+                System.out.printf(\"%s: %s%n\", file, ioe);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns an InputStream, either the original on a wrapped to decode Base64Mime encoding.\n+     * @param bis an InputStream\n+     * @return the InputStream or the wrapped decoder of Base64Mime.\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private static InputStream wrapIfBase64Mime(BufferedInputStream bis) throws IOException {\n+        bis.mark(256);\n+        DataInputStream dis = new DataInputStream(bis);\n+        String line1 = dis.readLine(); \/\/ Good enough for our purposes\n+        if (line1.contains(\"CERTIFICATE\")) {\n+            \/\/ Probable Base64 Mime encoding\n+            return Base64.getMimeDecoder().wrap(bis);\n+        }\n+        bis.reset();\n+        return bis;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ASN1Formatter.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -165,1 +165,0 @@\n-    private static final String initOffsetFormat = \"%5d: \";\n@@ -268,1 +267,1 @@\n-     * <LI>byte offset format: signed decimal width 5 and a space, {@code \"%5d: \"},\n+     * <LI>byte offset format: hexadecimal width 7 and a space, {@code \"%04x: \"},\n@@ -291,1 +290,1 @@\n-        return new HexPrinter(Formatters.ASCII, initOffsetFormat,\n+        return new HexPrinter(Formatters.ASCII, \"%04x: \",\n@@ -607,1 +606,1 @@\n-     * @param bytesCount the maximum number of byte values per line\n+     * @param bytesCount the maximum number of byte values per line; greater than zero\n@@ -609,0 +608,1 @@\n+     * @throws IllegalArgumentException if bytesCount is less than or equal to zero\n@@ -612,0 +612,2 @@\n+        if (bytesCount <= 0)\n+            throw new IllegalArgumentException(\"bytesCount should be greater than zero\");\n@@ -949,0 +951,1 @@\n+        private final transient int bytesSingleWidth;\n@@ -969,1 +972,2 @@\n-            this.bytesColWidth = params.bytesCount * String.format(params.bytesFormat, 255).length();\n+            this.bytesSingleWidth = String.format(params.bytesFormat, 255).length();\n+            this.bytesColWidth = params.bytesCount * bytesSingleWidth;\n@@ -1065,1 +1069,1 @@\n-                long binColOffset = source.byteOffset();\n+                int binColOffset = (int)source.byteOffset();\n@@ -1067,3 +1071,8 @@\n-                    dest.append(String.format(params.offsetFormat, binColOffset + baseOffset));\n-                    int colWidth = 0;\n-                    int byteCount = Math.min(params.bytesCount, count);\n+                    int offset = binColOffset + baseOffset; \/\/ offset of first byte on the line\n+                    dest.append(String.format(params.offsetFormat, offset));\n+                    \/\/ Compute indent based on offset modulo bytesCount\n+                    int colOffset = offset % params.bytesCount;\n+                    int colWidth = colOffset * bytesSingleWidth;\n+                    dest.append(\" \".repeat(colWidth));\n+                    \/\/ Append the bytes that fit on this line\n+                    int byteCount = Math.min(params.bytesCount - colOffset, count);\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/HexPrinter.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"}]}