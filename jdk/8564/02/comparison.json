{"files":[{"patch":"@@ -3803,1 +3803,1 @@\n-      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type), &cbuf);\n+      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));\n@@ -3812,1 +3812,1 @@\n-      call = __ trampoline_call(Address(addr, rspec), &cbuf);\n+      call = __ trampoline_call(Address(addr, rspec));\n@@ -3818,1 +3818,1 @@\n-      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);\n+      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, call);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)), NULL, rscratch2);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)), rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {\n+void MacroAssembler::far_call(Address entry, Register tmp) {\n@@ -462,1 +462,0 @@\n-    if (cbuf) cbuf->set_insts_mark();\n@@ -465,1 +464,0 @@\n-    if (cbuf) cbuf->set_insts_mark();\n@@ -470,1 +468,1 @@\n-int MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {\n+int MacroAssembler::far_jump(Address entry, Register tmp) {\n@@ -484,1 +482,0 @@\n-    if (cbuf) cbuf->set_insts_mark();\n@@ -487,1 +484,0 @@\n-    if (cbuf) cbuf->set_insts_mark();\n@@ -616,1 +612,1 @@\n-address MacroAssembler::trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size) {\n+address MacroAssembler::trampoline_call(Address entry) {\n@@ -621,0 +617,3 @@\n+  \/\/ FIX: We are checking the target is in CodeCache to avoid bug 8286314.\n+  assert(CodeCache::find_blob(entry.target()) != NULL,\n+         \"destination of trampoline call not found in code cache\");\n@@ -626,1 +625,3 @@\n-    if (check_emit_size) {\n+    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n+    \/\/ trampoline stubs generated by Call LIR ops.\n+    if (StubRoutines::aarch64::complete() && Thread::current()->is_Compiler_thread()) {\n@@ -630,0 +631,3 @@\n+\n+      \/\/ We need to be at phase output when we check the size of emitted code.\n+      PhaseOutput* phase_output = Compile::current()->output();\n@@ -632,1 +636,1 @@\n-         Compile::current()->output()->in_scratch_emit_size());\n+         phase_output != NULL && phase_output->in_scratch_emit_size());\n@@ -644,1 +648,1 @@\n-  if (cbuf) cbuf->set_insts_mark();\n+  address call = pc();\n@@ -651,1 +655,0 @@\n-  \/\/ just need to return a non-null address\n@@ -653,1 +656,1 @@\n-  return pc();\n+  return call;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1116,1 +1116,34 @@\n-  \/\/ Calls\n+  \/\/ AArch64 OpenJDK uses four different types of calls:\n+  \/\/   - direct call: bl pc_relative_offset\n+  \/\/     This is the shortest and the fastest, but the offset has the range:\n+  \/\/     +\/-128MB for the release build, +\/-2MB for the debug build.\n+  \/\/\n+  \/\/   - far call: adrp reg, pc_relative_offset; add; bl reg\n+  \/\/     This is longer and slower than a direct call. The offset has\n+  \/\/     the range +\/-4GB. As the code cache size is limited to 4GB,\n+  \/\/     far calls can reach anywhere in the code cache. If the sematic of\n+  \/\/     the call is not needed, a far jump 'b reg' can be used instead.\n+  \/\/     All instructions are embedded at a call site.\n+  \/\/\n+  \/\/   - trampoline call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod). It is a combination\n+  \/\/     of a direct call, which is used if the destination of a call is in range,\n+  \/\/     and a register-indirect call. It has the advantages of reaching anywhere in\n+  \/\/     the AArch64 address space and being patchable at runtime when the generated\n+  \/\/     code is being executed by other threads.\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       bl trampoline\n+  \/\/     [Stub code section]\n+  \/\/     trampoline:\n+  \/\/       ldr reg, pc + 8\n+  \/\/       br reg\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/     A link-time optimization can be applied to a trampoline call when the generated\n+  \/\/     code is moved to the code cache. A trampoline call is replaced with by a direct call.\n+  \/\/     The optimization does not remove the trampoline from the stub section.\n+  \/\/\n+  \/\/   - indirect call: move reg, address; blr reg\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patch while code is running, so it must be used at a safepoint.\n@@ -1118,2 +1151,10 @@\n-  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL) { return trampoline_call1(entry, cbuf, true); }\n-  address trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size = true);\n+  \/\/ Emit a direct call if the entry address is always in range,\n+  \/\/ otherwise a trampoline call.\n+  \/\/ Supported entry.rspec():\n+  \/\/ - relocInfo::runtime_call_type\n+  \/\/ - relocInfo::opt_virtual_call_type\n+  \/\/ - relocInfo::static_call_type\n+  \/\/ - relocInfo::virtual_call_type\n+  \/\/\n+  \/\/ Return: address of the generated call in the code section of CodeBuffer.\n+  address trampoline_call(Address entry);\n@@ -1130,1 +1171,2 @@\n-  \/\/ Far_call and far_jump generate a call of\/jump to the provided address.\n+  \/\/ Emit a direct call\/jump if the entry address is always in range,\n+  \/\/ otherwise a far call\/jump.\n@@ -1136,9 +1178,6 @@\n-  \/\/ If the distance to the address can exceed the branch range\n-  \/\/ (128M for the release build, 2M for the debug build; see branch_range definition)\n-  \/\/ for direct calls(BL)\/jumps(B), a call(BLR)\/jump(BR) with the address put in\n-  \/\/ the tmp register is generated. Instructions putting the address in the tmp register\n-  \/\/ are embedded at a call site. The tmp register is invalidated.\n-  \/\/ This differs from trampoline_call which puts additional code (trampoline) including\n-  \/\/ BR into the stub code section and a BL to the trampoline at a call site.\n-  void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n-  int far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+  \/\/ In the case of a far call\/jump, the entry address is put in the tmp register.\n+  \/\/ The tmp register is invalidated.\n+  \/\/\n+  \/\/ Far_jump returns the amount of the emitted code.\n+  void far_call(Address entry, Register tmp = rscratch1);\n+  int far_jump(Address entry, Register tmp = rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1042,1 +1042,1 @@\n-  __ trampoline_call1(resolve, NULL, false);\n+  __ trampoline_call(resolve);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}