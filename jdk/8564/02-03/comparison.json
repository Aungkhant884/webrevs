{"files":[{"patch":"@@ -3803,1 +3803,1 @@\n-      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));\n+      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type), &cbuf);\n@@ -3812,1 +3812,1 @@\n-      call = __ trampoline_call(Address(addr, rspec));\n+      call = __ trampoline_call(Address(addr, rspec), &cbuf);\n@@ -3818,1 +3818,1 @@\n-      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, call);\n+      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)), rscratch2);\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(_stub)), NULL, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-void MacroAssembler::far_call(Address entry, Register tmp) {\n+void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {\n@@ -462,0 +462,1 @@\n+    if (cbuf) cbuf->set_insts_mark();\n@@ -464,0 +465,1 @@\n+    if (cbuf) cbuf->set_insts_mark();\n@@ -468,1 +470,1 @@\n-int MacroAssembler::far_jump(Address entry, Register tmp) {\n+int MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {\n@@ -482,0 +484,1 @@\n+    if (cbuf) cbuf->set_insts_mark();\n@@ -484,0 +487,1 @@\n+    if (cbuf) cbuf->set_insts_mark();\n@@ -612,1 +616,1 @@\n-address MacroAssembler::trampoline_call(Address entry) {\n+address MacroAssembler::trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size) {\n@@ -617,3 +621,0 @@\n-  \/\/ FIX: We are checking the target is in CodeCache to avoid bug 8286314.\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n-         \"destination of trampoline call not found in code cache\");\n@@ -625,3 +626,1 @@\n-    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n-    \/\/ trampoline stubs generated by Call LIR ops.\n-    if (StubRoutines::aarch64::complete() && Thread::current()->is_Compiler_thread()) {\n+    if (check_emit_size) {\n@@ -631,3 +630,0 @@\n-\n-      \/\/ We need to be at phase output when we check the size of emitted code.\n-      PhaseOutput* phase_output = Compile::current()->output();\n@@ -636,1 +632,1 @@\n-         phase_output != NULL && phase_output->in_scratch_emit_size());\n+         Compile::current()->output()->in_scratch_emit_size());\n@@ -648,1 +644,1 @@\n-  address call = pc();\n+  if (cbuf) cbuf->set_insts_mark();\n@@ -655,0 +651,1 @@\n+  \/\/ just need to return a non-null address\n@@ -656,1 +653,1 @@\n-  return call;\n+  return pc();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1122,1 +1122,1 @@\n-  \/\/     This is longer and slower than a direct call. The offset has\n+  \/\/     This is longer than a direct call. The offset has\n@@ -1124,2 +1124,2 @@\n-  \/\/     far calls can reach anywhere in the code cache. If the sematic of\n-  \/\/     the call is not needed, a far jump 'b reg' can be used instead.\n+  \/\/     far calls can reach anywhere in the code cache. If a jump is\n+  \/\/     needed rather than a call, a far jump 'b reg' can be used instead.\n@@ -1143,2 +1143,3 @@\n-  \/\/     A link-time optimization can be applied to a trampoline call when the generated\n-  \/\/     code is moved to the code cache. A trampoline call is replaced with by a direct call.\n+  \/\/     If the destination is in range when the generated code is moved to the code\n+  \/\/     cache, 'bl trampoline' is replaced with 'bl destination' and the trampoline\n+  \/\/     is not used.\n@@ -1146,0 +1147,3 @@\n+  \/\/     This is necessary because the trampoline may well be redirected later when\n+  \/\/     code is patched, and the new destination may not be reachable by a simple BR\n+  \/\/     instruction.\n@@ -1149,3 +1153,24 @@\n-  \/\/     patch while code is running, so it must be used at a safepoint.\n-\n-  \/\/ Emit a direct call if the entry address is always in range,\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/ The patching we do conforms to the \"Concurrent modification and\n+  \/\/ execution of instructions\" section of the Arm Architectural\n+  \/\/ Reference Manual, which only allows B, BL, BRK, HVC, ISB, NOP, SMC,\n+  \/\/ or SVC instructions to be modified while another thread is\n+  \/\/ executing them.\n+  \/\/\n+  \/\/ To patch a trampoline call when the BL can't reach, we first modify\n+  \/\/ the 64-bit destination address in the trampoline, then modify the\n+  \/\/ BL to point to the trampoline, then flush the instruction cache to\n+  \/\/ broadcast the change to all executing threads. See\n+  \/\/ NativeCall::set_destination_mt_safe for the details.\n+  \/\/\n+  \/\/ There is a benign race in that the other thread might observe the\n+  \/\/ modified BL before it observes the modified 64-bit destination\n+  \/\/ address. That does not matter because the destination method has been\n+  \/\/ invalidated, so there will be a trap at its start.\n+  \/\/ For this to work, the destination address in the trampoline is\n+  \/\/ always updated, even if we're not using the trampoline.\n+\n+  \/\/ Emit a direct call if the entry address will always be in range,\n@@ -1159,2 +1184,3 @@\n-  \/\/ Return: address of the generated call in the code section of CodeBuffer.\n-  address trampoline_call(Address entry);\n+  \/\/ Return: NULL if CodeCache is full.\n+  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL) { return trampoline_call1(entry, cbuf, true); }\n+  address trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size = true);\n@@ -1171,1 +1197,1 @@\n-  \/\/ Emit a direct call\/jump if the entry address is always in range,\n+  \/\/ Emit a direct call\/jump if the entry address will always be in range,\n@@ -1182,2 +1208,2 @@\n-  void far_call(Address entry, Register tmp = rscratch1);\n-  int far_jump(Address entry, Register tmp = rscratch1);\n+  void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+  int far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1042,1 +1042,1 @@\n-  __ trampoline_call(resolve);\n+  __ trampoline_call1(resolve, NULL, false);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}