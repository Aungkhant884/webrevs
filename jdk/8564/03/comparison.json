{"files":[{"patch":"@@ -1116,2 +1116,69 @@\n-  \/\/ Calls\n-\n+  \/\/ AArch64 OpenJDK uses four different types of calls:\n+  \/\/   - direct call: bl pc_relative_offset\n+  \/\/     This is the shortest and the fastest, but the offset has the range:\n+  \/\/     +\/-128MB for the release build, +\/-2MB for the debug build.\n+  \/\/\n+  \/\/   - far call: adrp reg, pc_relative_offset; add; bl reg\n+  \/\/     This is longer than a direct call. The offset has\n+  \/\/     the range +\/-4GB. As the code cache size is limited to 4GB,\n+  \/\/     far calls can reach anywhere in the code cache. If a jump is\n+  \/\/     needed rather than a call, a far jump 'b reg' can be used instead.\n+  \/\/     All instructions are embedded at a call site.\n+  \/\/\n+  \/\/   - trampoline call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod). It is a combination\n+  \/\/     of a direct call, which is used if the destination of a call is in range,\n+  \/\/     and a register-indirect call. It has the advantages of reaching anywhere in\n+  \/\/     the AArch64 address space and being patchable at runtime when the generated\n+  \/\/     code is being executed by other threads.\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       bl trampoline\n+  \/\/     [Stub code section]\n+  \/\/     trampoline:\n+  \/\/       ldr reg, pc + 8\n+  \/\/       br reg\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/     If the destination is in range when the generated code is moved to the code\n+  \/\/     cache, 'bl trampoline' is replaced with 'bl destination' and the trampoline\n+  \/\/     is not used.\n+  \/\/     The optimization does not remove the trampoline from the stub section.\n+  \/\/     This is necessary because the trampoline may well be redirected later when\n+  \/\/     code is patched, and the new destination may not be reachable by a simple BR\n+  \/\/     instruction.\n+  \/\/\n+  \/\/   - indirect call: move reg, address; blr reg\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/ The patching we do conforms to the \"Concurrent modification and\n+  \/\/ execution of instructions\" section of the Arm Architectural\n+  \/\/ Reference Manual, which only allows B, BL, BRK, HVC, ISB, NOP, SMC,\n+  \/\/ or SVC instructions to be modified while another thread is\n+  \/\/ executing them.\n+  \/\/\n+  \/\/ To patch a trampoline call when the BL can't reach, we first modify\n+  \/\/ the 64-bit destination address in the trampoline, then modify the\n+  \/\/ BL to point to the trampoline, then flush the instruction cache to\n+  \/\/ broadcast the change to all executing threads. See\n+  \/\/ NativeCall::set_destination_mt_safe for the details.\n+  \/\/\n+  \/\/ There is a benign race in that the other thread might observe the\n+  \/\/ modified BL before it observes the modified 64-bit destination\n+  \/\/ address. That does not matter because the destination method has been\n+  \/\/ invalidated, so there will be a trap at its start.\n+  \/\/ For this to work, the destination address in the trampoline is\n+  \/\/ always updated, even if we're not using the trampoline.\n+\n+  \/\/ Emit a direct call if the entry address will always be in range,\n+  \/\/ otherwise a trampoline call.\n+  \/\/ Supported entry.rspec():\n+  \/\/ - relocInfo::runtime_call_type\n+  \/\/ - relocInfo::opt_virtual_call_type\n+  \/\/ - relocInfo::static_call_type\n+  \/\/ - relocInfo::virtual_call_type\n+  \/\/\n+  \/\/ Return: NULL if CodeCache is full.\n@@ -1130,1 +1197,2 @@\n-  \/\/ Far_call and far_jump generate a call of\/jump to the provided address.\n+  \/\/ Emit a direct call\/jump if the entry address will always be in range,\n+  \/\/ otherwise a far call\/jump.\n@@ -1136,7 +1204,4 @@\n-  \/\/ If the distance to the address can exceed the branch range\n-  \/\/ (128M for the release build, 2M for the debug build; see branch_range definition)\n-  \/\/ for direct calls(BL)\/jumps(B), a call(BLR)\/jump(BR) with the address put in\n-  \/\/ the tmp register is generated. Instructions putting the address in the tmp register\n-  \/\/ are embedded at a call site. The tmp register is invalidated.\n-  \/\/ This differs from trampoline_call which puts additional code (trampoline) including\n-  \/\/ BR into the stub code section and a BL to the trampoline at a call site.\n+  \/\/ In the case of a far call\/jump, the entry address is put in the tmp register.\n+  \/\/ The tmp register is invalidated.\n+  \/\/\n+  \/\/ Far_jump returns the amount of the emitted code.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":75,"deletions":10,"binary":false,"changes":85,"status":"modified"}]}