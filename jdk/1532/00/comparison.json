{"files":[{"patch":"@@ -1081,1 +1081,1 @@\n-  if (opcode == Op_RotateLeftV) {\n+  if (opcode == Op_RotateLeftImmV) {\n@@ -1089,1 +1089,1 @@\n-    assert(opcode == Op_RotateRightV, \"opcode should be Op_RotateRightV\");\n+    assert(opcode == Op_RotateRightImmV, \"opcode should be Op_RotateRightImmV\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1598,0 +1598,2 @@\n+    case Op_RotateRightImmV:\n+    case Op_RotateLeftImmV:\n@@ -7889,2 +7891,2 @@\n-  match(Set dst (RotateLeftV src shift));\n-  match(Set dst (RotateRightV src shift));\n+  match(Set dst (RotateLeftImmV src shift));\n+  match(Set dst (RotateRightImmV src shift));\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4179,2 +4179,2 @@\n-    \"RoundDoubleModeV\",\"RotateLeftV\" , \"RotateRightV\", \"LoadVector\",\"StoreVector\",\n-    \"LoadVectorGather\", \"StoreVectorScatter\",\n+    \"RoundDoubleModeV\", \"RotateLeftImmV\", \"RotateRightImmV\", \"RotateLeftV\" , \"RotateRightV\",\n+    \"LoadVector\",\"StoreVector\", \"LoadVectorGather\", \"StoreVectorScatter\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+macro(RotateLeftImmV)\n@@ -281,0 +282,1 @@\n+macro(RotateRightImmV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-      if (VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n+      if (VectorNode::implemented(n, cur_max_vector, bt)) {\n@@ -2011,1 +2011,1 @@\n-      retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));\n+      retValue = VectorNode::implemented(p0, size, velt_basic_type(p0));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -301,1 +301,2 @@\n-bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {\n+bool VectorNode::implemented(Node *n, uint vlen, BasicType bt) {\n+  int opc = n->Opcode();\n@@ -310,1 +311,1 @@\n-      return is_vector_rotate_supported(vopc, vlen, bt);\n+      return is_vector_rotate_supported(vopc, vlen, bt, n->in(2)->is_Con());\n@@ -350,1 +351,1 @@\n-bool VectorNode::is_vector_rotate_supported(int vopc, uint vlen, BasicType bt) {\n+bool VectorNode::is_vector_rotate_supported(int vopc, uint vlen, BasicType bt, bool is_imm) {\n@@ -353,0 +354,5 @@\n+  \/\/ Get the opcode for rotate immediate\n+  if (is_imm) {\n+    vopc = vopc == Op_RotateLeftV ? Op_RotateLeftImmV : Op_RotateRightImmV;\n+  }\n+\n@@ -512,2 +518,10 @@\n-  case Op_RotateLeftV: return new RotateLeftVNode(n1, n2, vt);\n-  case Op_RotateRightV: return new RotateRightVNode(n1, n2, vt);\n+\n+  case Op_RotateLeftV:\n+    if (n2->is_Con())\n+      return new RotateLeftImmVNode(n1, n2, vt);\n+    return new RotateLeftVNode(n1, n2, vt);\n+\n+  case Op_RotateRightV:\n+    if (n2->is_Con())\n+      return new RotateRightImmVNode(n1, n2, vt);\n+    return new RotateRightVNode(n1, n2, vt);\n@@ -1200,0 +1214,18 @@\n+Node* RotateLeftImmVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  int vlen = length();\n+  BasicType bt = vect_type()->element_basic_type();\n+  if (!Matcher::match_rule_supported_vector(Op_RotateLeftImmV, vlen, bt)) {\n+    return VectorNode::degenerate_vector_rotate(in(1), in(2), true, vlen, bt, phase);\n+  }\n+  return NULL;\n+}\n+\n+Node* RotateRightImmVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  int vlen = length();\n+  BasicType bt = vect_type()->element_basic_type();\n+  if (!Matcher::match_rule_supported_vector(Op_RotateRightImmV, vlen, bt)) {\n+    return VectorNode::degenerate_vector_rotate(in(1), in(2), false, vlen, bt, phase);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  static bool implemented(int opc, uint vlen, BasicType bt);\n+  static bool implemented(Node* n, uint vlen, BasicType bt);\n@@ -88,1 +88,1 @@\n-  static bool is_vector_rotate_supported(int vopc, uint vlen, BasicType bt);\n+  static bool is_vector_rotate_supported(int vopc, uint vlen, BasicType bt, bool is_imm);\n@@ -1395,0 +1395,18 @@\n+class RotateRightImmVNode : public RotateRightVNode {\n+public:\n+  RotateRightImmVNode(Node* in1, Node* in2, const TypeVect* vt)\n+  : RotateRightVNode(in1, in2, vt) {}\n+\n+  virtual int Opcode() const;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n+class RotateLeftImmVNode : public RotateLeftVNode {\n+public:\n+  RotateLeftImmVNode(Node* in1, Node* in2, const TypeVect* vt)\n+  : RotateLeftVNode(in1, in2, vt) {}\n+\n+  virtual int Opcode() const;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,20 @@\n-\n+  @Benchmark\n+  public void testRotateLeftIImm() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+       ires[i] = Integer.rotateLeft(iarr[i], 12);\n+  }\n+  @Benchmark\n+  public void testRotateRightIImm() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+       ires[i] = Integer.rotateRight(iarr[i], 23);\n+  }\n+  @Benchmark\n+  public void testRotateLeftLImm() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+       lres[i] = Long.rotateLeft(larr[i], 7);\n+  }\n+  @Benchmark\n+  public void testRotateRightLImm() {\n+    for (int i = 0; i < TESTSIZE; i++)\n+       lres[i] = Long.rotateRight(larr[i], 47);\n+  }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RotateBenchmark.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}