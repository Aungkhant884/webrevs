{"files":[{"patch":"@@ -2398,1 +2398,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt, int ext) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -981,1 +981,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt, int ext) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2143,1 +2143,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt, int ext) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1536,1 +1536,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt, int ext) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-  if (opcode == Op_RotateLeftImmV) {\n+  if (opcode == Op_RotateLeftV) {\n@@ -1089,1 +1089,1 @@\n-    assert(opcode == Op_RotateRightImmV, \"opcode should be Op_RotateRightImmV\");\n+    assert(opcode == Op_RotateRightV, \"opcode should be Op_RotateRightV\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1557,1 +1557,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt, int ext) {\n@@ -1598,2 +1598,0 @@\n-    case Op_RotateRightImmV:\n-    case Op_RotateLeftImmV:\n@@ -7891,2 +7889,2 @@\n-  match(Set dst (RotateLeftImmV src shift));\n-  match(Set dst (RotateRightImmV src shift));\n+  match(Set dst (RotateLeftV src shift));\n+  match(Set dst (RotateRightV src shift));\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4179,2 +4179,2 @@\n-    \"RoundDoubleModeV\", \"RotateLeftImmV\", \"RotateRightImmV\", \"RotateLeftV\" , \"RotateRightV\",\n-    \"LoadVector\",\"StoreVector\", \"LoadVectorGather\", \"StoreVectorScatter\",\n+    \"RoundDoubleModeV\",\"RotateLeftV\" , \"RotateRightV\", \"LoadVector\",\"StoreVector\",\n+    \"LoadVectorGather\", \"StoreVectorScatter\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-macro(RotateLeftImmV)\n@@ -282,1 +281,0 @@\n-macro(RotateRightImmV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,11 @@\n+  static const int MATCH_RULE_SUPPORT_VECTOR_HAS_NO_EXTINFO  = 0;\n+  static const int MATCH_RULE_SUPPORT_VECTOR_INITIAL_EXTINFO = 1;\n+\n+  static const bool match_rule_supported_vector_has_extinfo(int extinfo) {\n+    return extinfo != MATCH_RULE_SUPPORT_VECTOR_HAS_NO_EXTINFO;\n+  }\n+\n+  static const int match_rule_supported_vector_init_extinfo(void) {\n+    return MATCH_RULE_SUPPORT_VECTOR_INITIAL_EXTINFO;\n+  }\n+\n@@ -318,1 +329,2 @@\n-  static const bool match_rule_supported_vector(int opcode, int vlen, BasicType bt);\n+  static const bool match_rule_supported_vector(int opcode, int vlen, BasicType bt,\n+                      int ext = MATCH_RULE_SUPPORT_VECTOR_HAS_NO_EXTINFO);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-      if (VectorNode::implemented(n, cur_max_vector, bt)) {\n+      if (VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n@@ -2011,1 +2011,1 @@\n-      retValue = VectorNode::implemented(p0, size, velt_basic_type(p0));\n+      retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -301,2 +301,1 @@\n-bool VectorNode::implemented(Node *n, uint vlen, BasicType bt) {\n-  int opc = n->Opcode();\n+bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {\n@@ -311,1 +310,1 @@\n-      return is_vector_rotate_supported(vopc, vlen, bt, n->in(2)->is_Con());\n+      return is_vector_rotate_supported(vopc, vlen, bt);\n@@ -351,1 +350,1 @@\n-bool VectorNode::is_vector_rotate_supported(int vopc, uint vlen, BasicType bt, bool is_imm) {\n+bool VectorNode::is_vector_rotate_supported(int vopc, uint vlen, BasicType bt) {\n@@ -354,5 +353,0 @@\n-  \/\/ Get the opcode for rotate immediate\n-  if (is_imm) {\n-    vopc = vopc == Op_RotateLeftV ? Op_RotateLeftImmV : Op_RotateRightImmV;\n-  }\n-\n@@ -381,0 +375,10 @@\n+int VectorNode::encode_rotate_vector_shift_type(Node *shift) {\n+    int info = Matcher::match_rule_supported_vector_init_extinfo();\n+    int rotate_shift_type = shift->is_Con() ? 0 : 1 << 1;\n+    return info | rotate_shift_type;\n+}\n+\n+bool VectorNode::is_rotate_vector_var(int info) {\n+  return (info & (1 << 1)) ? true : false; \n+}\n+\n@@ -518,10 +522,2 @@\n-\n-  case Op_RotateLeftV:\n-    if (n2->is_Con())\n-      return new RotateLeftImmVNode(n1, n2, vt);\n-    return new RotateLeftVNode(n1, n2, vt);\n-\n-  case Op_RotateRightV:\n-    if (n2->is_Con())\n-      return new RotateRightImmVNode(n1, n2, vt);\n-    return new RotateRightVNode(n1, n2, vt);\n+  case Op_RotateLeftV: return new RotateLeftVNode(n1, n2, vt);\n+  case Op_RotateRightV: return new RotateRightVNode(n1, n2, vt);\n@@ -1199,1 +1195,2 @@\n-  if (!Matcher::match_rule_supported_vector(Op_RotateLeftV, vlen, bt)) {\n+  int extinfo = encode_rotate_vector_shift_type(in(2));\n+  if (!Matcher::match_rule_supported_vector(Op_RotateLeftV, vlen, bt, extinfo)) {\n@@ -1208,19 +1205,2 @@\n-  if (!Matcher::match_rule_supported_vector(Op_RotateRightV, vlen, bt)) {\n-    return VectorNode::degenerate_vector_rotate(in(1), in(2), false, vlen, bt, phase);\n-  }\n-  return NULL;\n-}\n-\n-Node* RotateLeftImmVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  int vlen = length();\n-  BasicType bt = vect_type()->element_basic_type();\n-  if (!Matcher::match_rule_supported_vector(Op_RotateLeftImmV, vlen, bt)) {\n-    return VectorNode::degenerate_vector_rotate(in(1), in(2), true, vlen, bt, phase);\n-  }\n-  return NULL;\n-}\n-\n-Node* RotateRightImmVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  int vlen = length();\n-  BasicType bt = vect_type()->element_basic_type();\n-  if (!Matcher::match_rule_supported_vector(Op_RotateRightImmV, vlen, bt)) {\n+  int extinfo = encode_rotate_vector_shift_type(in(2));\n+  if (!Matcher::match_rule_supported_vector(Op_RotateRightV, vlen, bt, extinfo)) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  static bool implemented(Node* n, uint vlen, BasicType bt);\n+  static bool implemented(int opc, uint vlen, BasicType bt);\n@@ -88,1 +88,3 @@\n-  static bool is_vector_rotate_supported(int vopc, uint vlen, BasicType bt, bool is_imm);\n+  static bool is_vector_rotate_supported(int vopc, uint vlen, BasicType bt);\n+  static int  encode_rotate_vector_shift_type(Node *shift);\n+  static bool is_rotate_vector_var(int info);\n@@ -1395,18 +1397,0 @@\n-class RotateRightImmVNode : public RotateRightVNode {\n-public:\n-  RotateRightImmVNode(Node* in1, Node* in2, const TypeVect* vt)\n-  : RotateRightVNode(in1, in2, vt) {}\n-\n-  virtual int Opcode() const;\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n-class RotateLeftImmVNode : public RotateLeftVNode {\n-public:\n-  RotateLeftImmVNode(Node* in1, Node* in2, const TypeVect* vt)\n-  : RotateLeftVNode(in1, in2, vt) {}\n-\n-  virtual int Opcode() const;\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -86,20 +86,1 @@\n-  @Benchmark\n-  public void testRotateLeftIImm() {\n-    for (int i = 0; i < TESTSIZE; i++)\n-       ires[i] = Integer.rotateLeft(iarr[i], 12);\n-  }\n-  @Benchmark\n-  public void testRotateRightIImm() {\n-    for (int i = 0; i < TESTSIZE; i++)\n-       ires[i] = Integer.rotateRight(iarr[i], 23);\n-  }\n-  @Benchmark\n-  public void testRotateLeftLImm() {\n-    for (int i = 0; i < TESTSIZE; i++)\n-       lres[i] = Long.rotateLeft(larr[i], 7);\n-  }\n-  @Benchmark\n-  public void testRotateRightLImm() {\n-    for (int i = 0; i < TESTSIZE; i++)\n-       lres[i] = Long.rotateRight(larr[i], 47);\n-  }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RotateBenchmark.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"}]}