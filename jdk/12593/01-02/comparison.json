{"files":[{"patch":"@@ -59,2 +59,1 @@\n-        delayimp.lib $(WIN_JAVA_LIB) advapi32.lib ole32.lib oleaut32.lib \\\n-        wbemuuid.lib, \\\n+        delayimp.lib $(WIN_JAVA_LIB) advapi32.lib, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"NetworkInterface.h\"\n@@ -27,1 +28,0 @@\n-#include \"java_net_NetworkInterface.h\"\n@@ -29,2 +29,1 @@\n-\n-#include <wbemidl.h>\n+#include \"java_net_NetworkInterface.h\"\n@@ -60,9 +59,4 @@\n-typedef struct _netaddr {\n-    SOCKADDR_INET Address;\n-    SCOPE_ID ScopeId;\n-    UINT8 PrefixLength;\n-    struct _netaddr *Next;\n-} netaddr;\n-\n-BOOL getAddressTables(\n-        MIB_UNICASTIPADDRESS_TABLE **uniAddrs, MIB_ANYCASTIPADDRESS_TABLE **anyAddrs) {\n+static BOOL getAddressTables(\n+        JNIEnv *env, MIB_UNICASTIPADDRESS_TABLE **uniAddrs,\n+        MIB_ANYCASTIPADDRESS_TABLE **anyAddrs) {\n+    ULONG apiRetVal;\n@@ -70,1 +64,6 @@\n-    if (GetUnicastIpAddressTable(addrFamily, uniAddrs) != NO_ERROR) {\n+\n+    apiRetVal = GetUnicastIpAddressTable(addrFamily, uniAddrs);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetUnicastIpAddressTable\");\n@@ -73,1 +72,2 @@\n-    if (GetAnycastIpAddressTable(addrFamily, anyAddrs) != NO_ERROR) {\n+    apiRetVal = GetAnycastIpAddressTable(addrFamily, anyAddrs);\n+    if (apiRetVal != NO_ERROR) {\n@@ -75,0 +75,3 @@\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetAnycastIpAddressTable\");\n@@ -80,1 +83,1 @@\n-void freeNetaddrs(netaddr *netaddrP) {\n+static void freeNetaddrs(netaddr *netaddrP) {\n@@ -89,1 +92,1 @@\n-jobject createNetworkInterface(\n+static jobject createNetworkInterface(\n@@ -97,1 +100,1 @@\n-    ULONG i, mask;\n+    ULONG apiRetVal, i, mask;\n@@ -106,3 +109,6 @@\n-    if (ConvertInterfaceLuidToNameW(\n-            &(ifRow->InterfaceLuid), (PWSTR) &ifName, NDIS_IF_MAX_BUFFER_SIZE)\n-            != ERROR_SUCCESS) {\n+    apiRetVal = ConvertInterfaceLuidToNameW(\n+            &(ifRow->InterfaceLuid), (PWSTR) &ifName, NDIS_IF_MAX_BUFFER_SIZE);\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"ConvertInterfaceLuidToNameW\");\n@@ -140,1 +146,0 @@\n-            addrsCurrent->ScopeId = uniAddrs->Table[i].ScopeId;\n@@ -151,1 +156,0 @@\n-            addrsCurrent->ScopeId = anyAddrs->Table[i].ScopeId;\n@@ -197,2 +201,2 @@\n-                if (ConvertLengthToIpv4Mask(\n-                        addrsCurrent->PrefixLength, &mask) != NO_ERROR) {\n+                apiRetVal = ConvertLengthToIpv4Mask(addrsCurrent->PrefixLength, &mask);\n+                if (apiRetVal != NO_ERROR) {\n@@ -200,0 +204,4 @@\n+                    SetLastError(apiRetVal);\n+                    NET_ThrowByNameWithLastError(\n+                            env, JNU_JAVANETPKG \"SocketException\",\n+                            \"ConvertLengthToIpv4Mask\");\n@@ -280,4 +288,12 @@\n-jobject createNetworkInterfaceForSingleRowWithTables(\n-        JNIEnv *env, MIB_IF_ROW2 *ifRow, MIB_UNICASTIPADDRESS_TABLE *uniAddrs,\n-        MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n-    if (GetIfEntry2(ifRow) != NO_ERROR) {\n+static jobject createNetworkInterfaceForSingleRowWithTables(\n+        JNIEnv *env, BOOL throwIfNotFound, MIB_IF_ROW2 *ifRow,\n+        MIB_UNICASTIPADDRESS_TABLE *uniAddrs, MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n+    ULONG apiRetVal;\n+\n+    apiRetVal = GetIfEntry2(ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        if (throwIfNotFound && apiRetVal == ERROR_FILE_NOT_FOUND) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        }\n@@ -289,1 +305,2 @@\n-jobject createNetworkInterfaceForSingleRow(JNIEnv *env, MIB_IF_ROW2 *ifRow) {\n+static jobject createNetworkInterfaceForSingleRow(\n+        JNIEnv *env, BOOL throwIfNotFound, MIB_IF_ROW2 *ifRow) {\n@@ -294,1 +311,1 @@\n-    if (getAddressTables(&uniAddrs, &anyAddrs) == FALSE) {\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n@@ -299,1 +316,1 @@\n-            env, ifRow, uniAddrs, anyAddrs);\n+            env, throwIfNotFound, ifRow, uniAddrs, anyAddrs);\n@@ -317,1 +334,1 @@\n-    return createNetworkInterfaceForSingleRow(env, &ifRow);\n+    return createNetworkInterfaceForSingleRow(env, FALSE, &ifRow);\n@@ -328,1 +345,1 @@\n-    DWORD convertResult;\n+    ULONG apiRetVal;\n@@ -332,1 +349,1 @@\n-    convertResult = ConvertInterfaceNameToLuidW(nameChars, &(ifRow.InterfaceLuid));\n+    apiRetVal = ConvertInterfaceNameToLuidW(nameChars, &(ifRow.InterfaceLuid));\n@@ -334,1 +351,7 @@\n-    if (convertResult != ERROR_SUCCESS) {\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        if (apiRetVal != ERROR_INVALID_NAME) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\",\n+                    \"ConvertInterfaceNameToLuidW\");\n+        }\n@@ -337,1 +360,1 @@\n-    return createNetworkInterfaceForSingleRow(env, &ifRow);\n+    return createNetworkInterfaceForSingleRow(env, TRUE, &ifRow);\n@@ -353,2 +376,2 @@\n-    if (getAddressTables(&uniAddrs, &anyAddrs) == FALSE) {\n-        return JNI_FALSE;\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        return NULL;\n@@ -364,1 +387,1 @@\n-                    env, &ifRow, uniAddrs, anyAddrs);\n+                    env, TRUE, &ifRow, uniAddrs, anyAddrs);\n@@ -373,1 +396,1 @@\n-                    env, &ifRow, uniAddrs, anyAddrs);\n+                    env, TRUE, &ifRow, uniAddrs, anyAddrs);\n@@ -396,1 +419,1 @@\n-    if (getAddressTables(&uniAddrs, &anyAddrs) == FALSE) {\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n@@ -434,1 +457,1 @@\n-    ULONG i;\n+    ULONG apiRetVal, i;\n@@ -437,1 +460,5 @@\n-    if (GetIfTable2(&ifTable) != NO_ERROR) {\n+    apiRetVal = GetIfTable2(&ifTable);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfTable2\");\n@@ -447,1 +474,1 @@\n-    if (getAddressTables(&uniAddrs, &anyAddrs) == FALSE) {\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n@@ -479,0 +506,1 @@\n+    ULONG apiRetVal;\n@@ -481,1 +509,5 @@\n-    if (GetIfEntry2(&ifRow) != NO_ERROR) {\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n@@ -497,0 +529,1 @@\n+    ULONG apiRetVal;\n@@ -499,1 +532,5 @@\n-    if (GetIfEntry2(&ifRow) != NO_ERROR) {\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n@@ -513,0 +550,1 @@\n+    ULONG apiRetVal;\n@@ -515,1 +553,5 @@\n-    if (GetIfEntry2(&ifRow) != NO_ERROR) {\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n@@ -529,0 +571,1 @@\n+    ULONG apiRetVal;\n@@ -532,1 +575,5 @@\n-    if (GetIfEntry2(&ifRow) != NO_ERROR) {\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n@@ -556,0 +603,1 @@\n+    ULONG apiRetVal;\n@@ -558,1 +606,5 @@\n-    if (GetIfEntry2(&ifRow) != NO_ERROR) {\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n@@ -578,1 +630,1 @@\n-    There are not many ways to access these settings.\n+    There are no good ways to access these settings.\n@@ -588,10 +640,6 @@\n-    So using COM to execute a WMI query was the best solution I could come up with.\n-\n-    The PowerShell equivalent of this code is:\n-    Get-WmiObject -Query \"select MldLevel from MSFT_NetIPv6Protocol\" -Namespace \"ROOT\/StandardCimv2\"\n-    Subsitute IPv4 if desired.\n-    The property is still called MldLevel here even though it is IGMPLevel elsewhere.\n-\n-    You can also change the value using PowerShell (admin rights needed):\n-    Set-NetIPv4Protocol -IGMPLevel <None, SendOnly, All>\n-    Set-NetIPv6Protocol -MldLevel <None, SendOnly, All>\n+    It's also possible to use COM to execute a WMI query:\n+    \"SELECT MldLevel FROM MSFT_NetIPv4Protocol\" in namespace \"ROOT\\\\StandardCimv2\"\n+    But during review, we agreed that wasn't great either.\n+    So we're just going to unconditionally return true\n+    since multicast is unlikely to be disabled,\n+    and a boolean can't represent the full range of possibilities anyway.\n@@ -599,95 +647,1 @@\n-    jboolean retVal = JNI_FALSE;\n-    IWbemLocator *locator;\n-    IWbemServices *services;\n-    IEnumWbemClassObject *results;\n-    IWbemClassObject *result;\n-    ULONG returnedCount;\n-    BSTR resource, language, query;\n-    VARIANT value;\n-\n-    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n-        goto done0;\n-    }\n-\n-    if (FAILED(CoInitializeSecurity(\n-            NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT,\n-            RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL))) {\n-        goto done1;\n-    }\n-\n-    if (FAILED(CoCreateInstance(\n-            &CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, &locator))) {\n-        goto done1;\n-    }\n-\n-    resource = SysAllocString(L\"ROOT\\\\StandardCimv2\");\n-    if (resource == NULL) {\n-        goto done2;\n-    }\n-\n-    language = SysAllocString(L\"WQL\");\n-    if (language == NULL) {\n-        goto done3;\n-    }\n-\n-    query = SysAllocString(ipv6_available() ?\n-            L\"SELECT MldLevel FROM MSFT_NetIPv6Protocol\" :\n-            L\"SELECT MldLevel FROM MSFT_NetIPv4Protocol\");\n-    if (query == NULL) {\n-        goto done4;\n-    }\n-\n-    if (FAILED(locator->lpVtbl->ConnectServer(\n-            locator, resource, NULL, NULL, NULL, 0, NULL, NULL, &services))) {\n-        goto done5;\n-    }\n-\n-    if (FAILED(services->lpVtbl->ExecQuery(\n-            services, language, query, WBEM_FLAG_BIDIRECTIONAL, NULL, &results))) {\n-        goto done6;\n-    }\n-\n-    if (FAILED(results->lpVtbl->Next(\n-            results, WBEM_INFINITE, 1, &result, &returnedCount))) {\n-        goto done7;\n-    }\n-\n-    if (returnedCount == 0) {\n-        goto done8;\n-    }\n-\n-    if (FAILED(result->lpVtbl->Get(result, L\"MldLevel\", 0, &value, NULL, NULL))) {\n-        goto done8; \/\/ note that we must NOT call VariantClear in this case\n-    }\n-\n-    \/\/ 0 = None; 1 = SendOnly; 2 = All\n-    retVal = value.uintVal == 0 ? JNI_FALSE : JNI_TRUE;\n-\n-    VariantClear(&value);\n-\n-    done8:\n-    result->lpVtbl->Release(result);\n-\n-    done7:\n-    results->lpVtbl->Release(results);\n-\n-    done6:\n-    services->lpVtbl->Release(services);\n-\n-    done5:\n-    SysFreeString(query);\n-\n-    done4:\n-    SysFreeString(language);\n-\n-    done3:\n-    SysFreeString(resource);\n-\n-    done2:\n-    locator->lpVtbl->Release(locator);\n-\n-    done1:\n-    CoUninitialize();\n-\n-    done0:\n-    return retVal;\n+    return JNI_TRUE;\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.c","additions":110,"deletions":156,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef NETWORK_INTERFACE_H\n+#define NETWORK_INTERFACE_H\n+\n+#include \"net_util.h\"\n+\n+\/*\n+ * Structures used when enumerating interfaces and addresses\n+ *\/\n+typedef struct _netaddr {\n+    SOCKADDR_INET Address;\n+    UINT8 PrefixLength;\n+    struct _netaddr *Next;\n+} netaddr;\n+\n+#endif\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n+static int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n","filename":"src\/java.base\/windows\/native\/libnet\/ResolverConfigurationImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-                if (ni.supportsMulticast()) {\n+                if (ni.supportsMulticast() && !ni.getInterfaceAddresses().isEmpty()) {\n","filename":"test\/jdk\/java\/net\/SocketOption\/OptionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}