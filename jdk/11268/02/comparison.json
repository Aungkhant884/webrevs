{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+ * @run main MultiThreadTest\n+ * @run main\/othervm MultiThreadTest\n+ * @run main\/othervm MultiThreadTest\n+ * @run main\/othervm MultiThreadTest\n+ * @run main\/othervm MultiThreadTest\n@@ -43,0 +48,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -45,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -46,0 +54,2 @@\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.LongStream;\n@@ -54,1 +64,1 @@\n-    static Object threadlock = new Object ();\n+    static final Object threadlock = new Object ();\n@@ -56,0 +66,5 @@\n+    \/\/ KEEP_ALIVE sent by the server\n+    static final int KEEP_ALIVE = 1; \/\/ seconds\n+    \/\/ The sending thread will sleep for this time after sending\n+    \/\/ half the number of its requests\n+    static final int SLEEP = KEEP_ALIVE * 1000 + 500; \/\/ ms\n@@ -66,0 +81,9 @@\n+    \/\/ The number of time an idle timeout was detected by any worker\n+    \/\/ on the server side.\n+    static final AtomicInteger IDLE_TIME_EXCEEDED = new AtomicInteger();\n+    \/\/ Set to true after all requests have been sent\n+    static final AtomicBoolean DONE = new AtomicBoolean();\n+    \/\/ The time at which the clients have received the last\n+    \/\/ response (last response byte has been read).\n+    static final AtomicLong END = new AtomicLong();\n+\n@@ -99,1 +123,0 @@\n-\n@@ -103,0 +126,4 @@\n+                \/\/ sleep after sending half of the requests, that\n+                \/\/ should cause the connections to be closed as idle\n+                \/\/ if sleeping more than KeepAlive.\n+                if (i == requests\/2) Thread.sleep(SLEEP);\n@@ -110,0 +137,1 @@\n+                    END.set(System.nanoTime());\n@@ -114,1 +142,2 @@\n-        debug(\"client: end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"client: end at \" + at() + \"ms, thread duration \"\n+                + Duration.ofNanos(System.nanoTime() - start).toMillis() + \"ms\");\n@@ -118,0 +147,11 @@\n+    \/\/ time at which main() started its work.\n+    static volatile long MAIN_START;\n+\n+    \/\/ number of millis since MAIN_START\n+    public static long at() {\n+        return at(System.nanoTime());\n+    }\n+    \/\/ number of millis between MAIN_START and the given time stamp\n+    public static long at(long nanoTime) {\n+        return Duration.ofNanos(nanoTime - MAIN_START).toMillis();\n+    }\n@@ -121,0 +161,1 @@\n+        END.set(start);\n@@ -142,5 +183,14 @@\n-        Object lock = MultiThreadTest.getLock();\n-        synchronized (lock) {\n-            for (int i=0; i<threads; i++) {\n-                MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests);\n-                t.start ();\n+        MAIN_START = System.nanoTime();\n+        try {\n+            Object lock = MultiThreadTest.getLock();\n+            List<MultiThreadTest> tests = new ArrayList<>();\n+            synchronized (lock) {\n+                for (int i = 0; i < threads; i++) {\n+                    MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests);\n+                    tests.add(t);\n+                    t.start();\n+                }\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) {\n+                }\n@@ -148,4 +198,0 @@\n-            try {\n-                lock.wait();\n-            } catch (InterruptedException e) {}\n-        }\n@@ -153,16 +199,35 @@\n-        \/\/ shutdown server - we're done.\n-        svr.shutdown();\n-\n-        int cnt = svr.connectionCount();\n-        MultiThreadTest.debug(\"Connections = \" + cnt);\n-        int reqs = Worker.getRequests ();\n-        MultiThreadTest.debug(\"Requests = \" + reqs);\n-        System.out.println (\"Connection count = \" + cnt + \" Request count = \" + reqs);\n-\n-        \/\/ We may have received traffic from something else than\n-        \/\/ our client. We should only count those workers for which\n-        \/\/ the expected header has been found.\n-        int validConnections = 0;\n-        for (Worker w : svr.workers()) {\n-            if (w.headerFound) validConnections++;\n-        }\n+            DONE.compareAndSet(false, true);\n+            END.compareAndSet(start, System.nanoTime()); \/\/ sets END if not set.\n+            long end = END.get();\n+            MultiThreadTest.debug(\"DONE at \" + at(end) + \"ms\");\n+\n+            \/\/ shutdown server - we're done.\n+            svr.shutdown();\n+\n+            int cnt = svr.connectionCount();\n+            MultiThreadTest.debug(\"Connections = \" + cnt);\n+            int reqs = Worker.getRequests();\n+            MultiThreadTest.debug(\"Requests = \" + reqs);\n+            System.out.println(\"Connection count = \" + cnt + \" Request count = \" + reqs);\n+\n+            \/\/ We may have received traffic from something else than\n+            \/\/ our client. We should only count those workers for which\n+            \/\/ the expected header has been found.\n+            int validConnections = 0;\n+            int becameIdle = 0;\n+            for (Worker w : svr.workers()) {\n+                if (w.headerFound > 0) {\n+                    validConnections++;\n+                    if (w.mayHaveTimedOut(end)) {\n+                        debug(\"Worker \" + w.id + \" may have timed out\");\n+                        becameIdle++;\n+                    } else {\n+                        long at0 = at(w.lastReading);\n+                        long at1 = at(w.lastReplied);\n+                        debug(\"Worker \" + w.id +\" has not timed out - last used at \" +\n+                            Math.max(at0, at1));\n+                    }\n+                } else {\n+                    debug(\"Worker \" + w.id + \" is not a valid connection\");\n+                }\n+            }\n@@ -170,3 +235,15 @@\n-        if (validConnections > threads + 1 || validConnections == 0) { \/\/ could be less\n-            throw new RuntimeException (\"Expected \" + threads + \" connections: used \" + validConnections);\n-        }\n+            if (validConnections > threads) {\n+                if (SLEEP > KEEP_ALIVE) {\n+                    debug(\"INFO: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" while using \" + threads\n+                            + \" threads to make concurrent connections\");\n+                } else {\n+                    debug(\"WARNING: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" where only \" + threads\n+                            + \" connections and none idle were expected!\");\n+                }\n+            }\n@@ -174,10 +251,3 @@\n-        \/\/ Sometimes the client drops a connection after a while and\n-        \/\/ spawns a new one. Why this is happening is not clear,\n-        \/\/ and JDK-8223783 is logged to follow up on this. For the sake\n-        \/\/ of test stabilization we don't fail on `threads + 1` connections\n-        \/\/ but log a warning instead.\n-        if (validConnections == threads + 1) {\n-            debug(\"WARNING: \" + validConnections\n-                + \" have been used, where only \" + threads\n-                + \" were expected!\");\n-        }\n+            if (validConnections > threads + becameIdle || validConnections == 0) { \/\/ could be less\n+                throw new RuntimeException(\"Expected \" + (threads + becameIdle) + \" connections: used \" + validConnections);\n+            }\n@@ -185,6 +255,7 @@\n-        if (validConnections != cnt) {\n-            debug(\"WARNING: got \" + (cnt - validConnections) + \" unexpected connections!\");\n-        }\n-        if  (validConnections == cnt && reqs != threads*requests) {\n-            throw new RuntimeException (\"Expected \"+ threads*requests+ \" requests: got \" +reqs);\n-        }\n+            if (validConnections != cnt) {\n+                \/\/ these connections are not necessarily unexpected if SLEEP exceeds keep-alive.\n+                debug(\"INFO: got \" + (cnt - validConnections) + \" unexpected connections\");\n+            }\n+            if (reqs != threads * requests) {\n+                throw new RuntimeException(\"Expected \" + threads * requests + \" requests: got \" + reqs);\n+            }\n@@ -192,2 +263,9 @@\n-        for (Thread worker : svr.workers()) {\n-            worker.join(60_000);\n+        } finally {\n+            debug(\"waiting for worker to shutdown at \" + at() +\"ms\");\n+            for (Worker worker : svr.workers()) {\n+                \/\/ we could call worker.done(); to force the worker\n+                \/\/ to terminate at this point, but we want to verify\n+                \/\/ that the client will eventually close the idle\n+                \/\/ connection. So just join the worker and wait...\n+                worker.join(60_000);\n+            }\n@@ -196,1 +274,1 @@\n-        debug(\"main thread end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"main thread end - \" + at() + \"ms\");\n@@ -234,0 +312,4 @@\n+            try {\n+                ss.close();\n+            } catch (IOException x) {\n+            }\n@@ -238,1 +320,2 @@\n-                ss.setSoTimeout(2000);\n+                ss.setSoTimeout(6000);\n+                long startServer = System.nanoTime();\n@@ -242,0 +325,1 @@\n+                    long acceptTime;\n@@ -245,2 +329,4 @@\n-                        MultiThreadTest.debug(\"server: return accept.\");\n-                    } catch (SocketTimeoutException te) {\n+                        acceptTime = System.nanoTime();\n+                        MultiThreadTest.debug(\"server: return accept (at \" +\n+                                MultiThreadTest.at(acceptTime)+ \"ms)\");\n+                    } catch (IOException te) {\n@@ -250,1 +336,2 @@\n-                                MultiThreadTest.debug(\"server: Shuting down.\");\n+                                MultiThreadTest.debug(\"server: Shuting down at: \"\n+                                        + MultiThreadTest.at() + \"ms\");\n@@ -254,1 +341,3 @@\n-                        continue;\n+                        if (te instanceof SocketTimeoutException)\n+                            continue;\n+                        throw te;\n@@ -261,1 +350,1 @@\n-                        w = new Worker(s, id);\n+                        w = new Worker(s, id, acceptTime);\n@@ -283,5 +372,28 @@\n-        Socket s;\n-        int id;\n-        volatile boolean headerFound;\n-\n-        Worker(Socket s, int id) {\n+        final long TIMEOUT = MultiThreadTest.KEEP_ALIVE; \/\/ seconds\n+        final long KEEP_ALIVE_NS = Duration.ofSeconds(TIMEOUT).toNanos(); \/\/ nanos\n+        final Socket s;\n+        final int id;\n+\n+        \/\/ time at which the connection was accepted (nanos)\n+        final long acceptTime;\n+\n+        \/\/ number of requests that had the expected URI\n+        volatile int headerFound;\n+        \/\/ time at which the worker thread exited\n+        volatile long stopTime;\n+        \/\/ Time at which the first call to is.read() for the last request\n+        \/\/ returned. This includes cases where -1 was returned.\n+        volatile long startReading;\n+        \/\/ Lat time at which a byte was read from the stream.\n+        volatile long lastReading;\n+        \/\/ number of times that the time between two consecutive received requests\n+        \/\/ exceeded the KEEP_ALIVE timeout.\n+        volatile int timeoutExceeded;\n+        \/\/ Number of requests handled by this worker\n+        volatile int requestHandled;\n+        \/\/ Time at which the last byte of the last reply was sent\n+        volatile long lastReplied;\n+        \/\/ Whether the worker was asked to stop\n+        volatile boolean done;\n+\n+        Worker(Socket s, int id, long acceptTime) {\n@@ -291,0 +403,2 @@\n+            \/\/ no time can have a value before accepTime\n+            this.acceptTime = lastReading = lastReplied = startReading = acceptTime;\n@@ -308,0 +422,21 @@\n+        \/**\n+         * Tries to figure out whether this worker might have been idle for more\n+         * than the KEEP_ALIVE timeout. This will be true if the worker detected\n+         * that the idle timeout was exceeded between two consecutive request, or\n+         * if the time between the last reply\n+         * @param nanosNow\n+         * @return\n+         *\/\n+        public boolean mayHaveTimedOut(long nanosNow) {\n+            \/\/ the minimum time elapsed between nanosNow and:\n+            \/\/  - the time the socket was accepted\n+            \/\/  - the last time a byte was received\n+            \/\/  - the last time a reply was sent.\n+            \/\/ We must not use `startReading` here because `startReading` may\n+            \/\/ be set if the client asynchronously closes the connection\n+            \/\/ after all requests have been sent. We should really only\n+            \/\/ take into account `lastReading` and `lastReplied`.\n+            long idle = Math.min(nanosNow - lastReading, nanosNow - lastReplied);\n+            return timeoutExceeded > 0 || idle >= KEEP_ALIVE_NS;\n+        }\n+\n@@ -310,1 +445,2 @@\n-            while (true) {\n+            long last;\n+            while (!done) {\n@@ -312,0 +448,5 @@\n+                last = System.nanoTime();\n+                if (count == 0) {\n+                    \/\/ time at which the first byte of the request (or EOF) was received\n+                    startReading = last;\n+                }\n@@ -314,0 +455,2 @@\n+                \/\/ time at which the last byte of the request was received (excludes EOF)\n+                lastReading = last;\n@@ -325,0 +468,1 @@\n+            return count;\n@@ -330,0 +474,3 @@\n+            \/\/ lastUsed starts when the connection was accepted\n+            long lastUsed = acceptTime;\n+            int expectedReqs = 0;\n@@ -339,2 +486,1 @@\n-                for (;;) {\n-\n+                for (;!done;) {\n@@ -342,1 +488,1 @@\n-                    int n=0;\n+                    int n;\n@@ -345,0 +491,9 @@\n+                    long idle = startReading - lastUsed;\n+                    if (idle >= KEEP_ALIVE_NS) {\n+                        if (!MultiThreadTest.DONE.get()) {\n+                            \/\/ avoid increasing timeoutExceeded after the test is no\n+                            \/\/ longer sending requests.\n+                            MultiThreadTest.IDLE_TIME_EXCEEDED.incrementAndGet();\n+                            timeoutExceeded++;\n+                        }\n+                    }\n@@ -346,1 +501,2 @@\n-                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown\");\n+                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown at \"\n+                                + MultiThreadTest.at() + \"ms\");\n@@ -351,1 +507,2 @@\n-                        headerFound = true;\n+                        headerFound = ++expectedReqs;\n+                        incRequests();\n@@ -354,0 +511,2 @@\n+                        s.close();\n+                        return;\n@@ -358,1 +517,1 @@\n-                        \"(\" + n + \" bytes).\");\n+                        \"(\" + n + \" bytes) at \" + MultiThreadTest.at() + \"ms\");\n@@ -360,1 +519,0 @@\n-                    incRequests();\n@@ -365,1 +523,1 @@\n-                    out.print(\"Keep-Alive: timeout=15, max=\"+max+\"\\r\\n\");\n+                    out.print(\"Keep-Alive: timeout=\" + TIMEOUT + \", max=\"+max+\"\\r\\n\");\n@@ -371,1 +529,2 @@\n-\n+                    requestHandled++;\n+                    lastUsed = lastReplied = System.nanoTime();\n@@ -379,1 +538,1 @@\n-                e.printStackTrace();\n+                if (!done) e.printStackTrace();\n@@ -381,0 +540,1 @@\n+                long end = stopTime = System.nanoTime();\n@@ -384,2 +544,16 @@\n-                MultiThreadTest.debug(\"worker: \" + id  + \" end - \" +\n-                            Duration.ofNanos(System.nanoTime() - start));\n+                MultiThreadTest.debug(\"worker: \" + id + \" end at \" +\n+                            MultiThreadTest.at() + \"ms,  elapsed since worker start: \" +\n+                            Duration.ofNanos(end - start).toMillis() + \"ms, elapsed since accept: \" +\n+                            Duration.ofNanos(end - acceptTime).toMillis() +\n+                            \"ms, timeout exceeded: \" + timeoutExceeded +\n+                            \", received \" + expectedReqs + \" genuine requests, \" +\n+                            \", mayHaveTimedOut: \" + mayHaveTimedOut(end));\n+            }\n+        }\n+\n+        public void done() {\n+            done = true;\n+            try {\n+                s.close();\n+            } catch (IOException x) {\n+                \/\/ ignore\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/MultiThreadTest.java","additions":249,"deletions":75,"binary":false,"changes":324,"status":"modified"}]}