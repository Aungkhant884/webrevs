[{"commit":{"message":"Remove redundant cast from previous commit."},"files":[{"filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java"}],"sha":"c9758c5872df0da40832b654f11a93f2e2f6126a"},{"commit":{"message":"Access ZipFileSystem.ch via outer pointer as it is now final"},"files":[{"filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java"}],"sha":"bccf5d3c09f39f1c8113d40d1312ecccc7c572c7"},{"commit":{"message":"Use pattern matching instanceof"},"files":[{"filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java"}],"sha":"0859d2d649aaf5bbd9268f6382805d8169e96e35"},{"commit":{"message":"8265448: Avoid lock contention in reads from zipfs when possible\n\nIf the given Path represents a file, use the overload of read defined\nin FileChannel that accepts an explicit position and avoid serializing\nreads.\n\nNote: The underlying NIO implementation is not required to implement\nFileChannel.read(ByteBuffer, long) concurrently; Windows still appears\nto lock, as it returns true for NativeDispatcher.needsPositionLock."},"files":[{"filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/nio\/zipfs\/ZipFileSystemBenchmark.java"}],"sha":"b7b6f9a80ee05e0f4be7e3dd2cf492eb794e40b5"}]