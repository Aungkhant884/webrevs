{"files":[{"patch":"@@ -12156,0 +12156,2 @@\n+\/\/ 64bit only pieces of the assembler\n+\n@@ -12161,1 +12163,0 @@\n-\/\/ 64bit only pieces of the assembler\n@@ -12165,56 +12166,3 @@\n-static bool is_reachable_from(address pc, address target, relocInfo::relocType relocType) {\n-  int64_t disp;\n-\n-  \/\/ None will force a 64bit literal to the code stream. Likely a placeholder\n-  \/\/ for something that will be patched later and we need to certain it will\n-  \/\/ always be reachable.\n-  if (relocType == relocInfo::none) {\n-    return false;\n-  }\n-  if (relocType == relocInfo::internal_word_type) {\n-    \/\/ This should be rip relative and easily reachable.\n-    return true;\n-  }\n-  if (relocType == relocInfo::virtual_call_type ||\n-      relocType == relocInfo::opt_virtual_call_type ||\n-      relocType == relocInfo::static_call_type ||\n-      relocType == relocInfo::static_stub_type ) {\n-    \/\/ This should be rip relative within the code cache and easily\n-    \/\/ reachable until we get huge code caches. (At which point\n-    \/\/ ic code is going to have issues).\n-    return true;\n-  }\n-  if (relocType != relocInfo::external_word_type &&\n-      relocType != relocInfo::poll_return_type &&  \/\/ these are really external_word but need special\n-      relocType != relocInfo::poll_type &&         \/\/ relocs to identify them\n-      relocType != relocInfo::runtime_call_type ) {\n-    return false;\n-  }\n-\n-  \/\/ Stress the correction code\n-  if (ForceUnreachable) {\n-    \/\/ Must be runtimecall reloc, see if it is in the codecache\n-    \/\/ Flipping stuff in the codecache to be unreachable causes issues\n-    \/\/ with things like inline caches where the additional instructions\n-    \/\/ are not handled.\n-    if (!CodeCache::contains(target)) {\n-      return false;\n-    }\n-  }\n-  \/\/ For external_word_type\/runtime_call_type if it is reachable from where we\n-  \/\/ are now (possibly a temp buffer) and where we might end up\n-  \/\/ anywhere in the codeCache then we are always reachable.\n-  \/\/ This would have to change if we ever save\/restore shared code\n-  \/\/ to be more pessimistic.\n-  disp = (int64_t)target - ((int64_t)CodeCache::low_bound() + sizeof(int));\n-  if (!Assembler::is_simm32(disp)) {\n-    return false;\n-  }\n-  disp = (int64_t)target - ((int64_t)CodeCache::high_bound() + sizeof(int));\n-  if (!Assembler::is_simm32(disp)) {\n-    return false;\n-  }\n-\n-  disp = (int64_t)target - ((int64_t)pc + sizeof(int));\n-\n-  \/\/ Because rip relative is a disp + address_of_next_instruction and we\n+\/\/ Determine whether an address is reachable in rip-relative addressing mode.\n+static bool is_reachable_from(address target, address pc) {\n+  \/\/ Because rip-relative is a disp + address_of_next_instruction and we\n@@ -12225,2 +12173,2 @@\n-  \/\/ 12 == override\/rex byte, opcode byte, rm byte, sib byte, a 4-byte disp , 4-byte literal\n-  \/\/ + 4 because better safe than sorry.\n+  \/\/ 12 == override\/rex byte, opcode byte, rm byte, sib byte, a 4-byte disp, 4-byte literal.\n+  \/\/ Plus 4, because better safe than sorry.\n@@ -12228,0 +12176,2 @@\n+\n+  int64_t disp = (int64_t)target - ((int64_t)pc + sizeof(int));\n@@ -12236,9 +12186,5 @@\n-bool Assembler::reachable(AddressLiteral adr) {\n-  bool is_reachable = is_reachable_from(pc(), adr.target(), adr.reloc());\n-  assert(is_reachable || !always_reachable(adr), \"sanity\");\n-  return is_reachable;\n-}\n-\n-bool Assembler::always_reachable(AddressLiteral adr) {\n-  switch (adr.reloc()) {\n-    \/\/ This should be rip relative and easily reachable.\n+\/\/ Determine whether an address is always reachable in rip-relative addressing mode\n+\/\/ when accessed from the code cache.\n+static bool is_always_reachable(address target, relocInfo::relocType reloc_type) {\n+  switch (reloc_type) {\n+    \/\/ This should be rip-relative and easily reachable.\n@@ -12248,1 +12194,1 @@\n-    \/\/ This should be rip relative within the code cache and easily\n+    \/\/ This should be rip-relative within the code cache and easily\n@@ -12261,1 +12207,1 @@\n-      return CodeCache::contains(adr._target);\n+      return CodeCache::contains(target);\n@@ -12269,0 +12215,45 @@\n+\/\/ Determine whether target address is reachable from pc address in rip-relative addressing mode.\n+static bool is_reachable_from(address target, address pc, relocInfo::relocType reloc_type) {\n+  if (is_always_reachable(target, reloc_type)) {\n+    return true;\n+  }\n+  switch (reloc_type) {\n+    \/\/ None will force a 64bit literal to the code stream. Likely a placeholder\n+    \/\/ for something that will be patched later and we need to certain it will\n+    \/\/ always be reachable.\n+    case relocInfo::none: {\n+      return false;\n+    }\n+    case relocInfo::runtime_call_type:\n+    case relocInfo::external_word_type:\n+    case relocInfo::poll_return_type: \/\/ these are really external_word but need special\n+    case relocInfo::poll_type: {      \/\/ relocs to identify them\n+      assert(!CodeCache::contains(target), \"always reachable\");\n+      \/\/ For external_word_type\/runtime_call_type if it is reachable from where we\n+      \/\/ are now (possibly a temp buffer) and where we might end up\n+      \/\/ anywhere in the codeCache then we are always reachable.\n+      \/\/ This would have to change if we ever save\/restore shared code\n+      \/\/ to be more pessimistic.\n+      if (ForceUnreachable) {\n+        return false; \/\/ stress the correction code\n+      }\n+      if (!is_reachable_from(target, CodeCache::low_bound()) ||\n+          !is_reachable_from(target, CodeCache::high_bound())) {\n+        return false;\n+      }\n+      return is_reachable_from(target, pc);\n+    }\n+    default: {\n+      return false;\n+    }\n+  }\n+}\n+\n+bool Assembler::reachable(AddressLiteral adr) {\n+  return is_reachable_from(adr.target(), pc(), adr.reloc());\n+}\n+\n+bool Assembler::always_reachable(AddressLiteral adr) {\n+  return is_always_reachable(adr.target(), adr.reloc());\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":61,"deletions":70,"binary":false,"changes":131,"status":"modified"}]}