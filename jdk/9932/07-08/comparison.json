{"files":[{"patch":"@@ -12166,19 +12166,0 @@\n-\/\/ Determine whether an address is reachable in rip-relative addressing mode.\n-static bool is_reachable_from(address target, address pc) {\n-  \/\/ Because rip-relative is a disp + address_of_next_instruction and we\n-  \/\/ don't know the value of address_of_next_instruction we apply a fudge factor\n-  \/\/ to make sure we will be ok no matter the size of the instruction we get placed into.\n-\n-  \/\/ 12 == override\/rex byte, opcode byte, rm byte, sib byte, a 4-byte disp, 4-byte literal\n-  \/\/ + 4 because better safe than sorry.\n-  const int fudge = 12 + 4;\n-\n-  int64_t disp = (int64_t)target - ((int64_t)pc + sizeof(int));\n-  if (disp < 0) {\n-    disp -= fudge;\n-  } else {\n-    disp += fudge;\n-  }\n-  return Assembler::is_simm32(disp);\n-}\n-\n@@ -12214,2 +12195,2 @@\n-\/\/ Determine whether target address is reachable from pc address in rip-relative addressing mode.\n-static bool is_reachable_from(address target, address pc, relocInfo::relocType reloc_type) {\n+\/\/ Determine whether an address is reachable in rip-relative addressing mode from the code cache.\n+static bool is_reachable_from(address target, relocInfo::relocType reloc_type) {\n@@ -12236,9 +12217,11 @@\n-      \/\/ anywhere in the codeCache then we are always reachable.\n-      \/\/ This would have to change if we ever save\/restore shared code\n-      \/\/ to be more pessimistic.\n-      if (is_reachable_from(target, CodeCache::low_bound())  &&\n-          is_reachable_from(target, CodeCache::high_bound()) &&\n-          is_reachable_from(target, pc)) {\n-        return true;\n-      }\n-      return false;\n+      \/\/ anywhere in the code cache then we are always reachable.\n+      \/\/ This would have to change if we ever save\/restore shared code to be more pessimistic.\n+      \/\/ Code buffer has to be allocated in the code cache, so check against\n+      \/\/ code cache boundaries cover that case.\n+      \/\/\n+      \/\/ In rip-relative addressing mode, an effective address is formed by adding displacement\n+      \/\/ to the 64-bit RIP of the next instruction which is not known yet. Considering target address\n+      \/\/ is guaranteed to be outside of the code cache, checking against code cache boundaries is enough\n+      \/\/ to account for that.\n+      return Assembler::is_simm32(target - CodeCache::low_bound()) &&\n+             Assembler::is_simm32(target - CodeCache::high_bound());\n@@ -12253,1 +12236,2 @@\n-  return is_reachable_from(adr.target(), pc(), adr.reloc());\n+  assert(CodeCache::contains(pc()), \"required\");\n+  return is_reachable_from(adr.target(), adr.reloc());\n@@ -12257,0 +12241,1 @@\n+  assert(CodeCache::contains(pc()), \"required\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":16,"deletions":31,"binary":false,"changes":47,"status":"modified"}]}