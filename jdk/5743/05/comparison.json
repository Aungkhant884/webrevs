{"files":[{"patch":"@@ -26,1 +26,0 @@\n-import java.io.BufferedWriter;\n@@ -42,1 +41,0 @@\n-import java.nio.file.FileVisitResult;\n@@ -44,0 +42,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -46,2 +45,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -56,0 +53,1 @@\n+import java.util.Locale;\n@@ -58,0 +56,1 @@\n+import java.util.function.BiFunction;\n@@ -61,0 +60,1 @@\n+import java.util.stream.Collectors;\n@@ -186,0 +186,1 @@\n+     *\n@@ -267,0 +268,1 @@\n+     *\n@@ -276,0 +278,1 @@\n+     *\n@@ -305,1 +308,1 @@\n-     * <pre><code>\n+     * {@snippet :\n@@ -310,1 +313,1 @@\n-     * <\/code><\/pre>\n+     * }\n@@ -404,0 +407,1 @@\n+     *\n@@ -467,2 +471,1 @@\n-     * @param expected the exit code that is required for the test\n-     * to pass.\n+     * @param expected the exit code that is required for the test to pass\n@@ -483,3 +486,4 @@\n-     * @param path a path within the most recent output directory\n-     *  or the name of one of the output buffers, identifying\n-     *  where to look for the search strings.\n+     *\n+     * @param path          a path within the most recent output directory\n+     *                      or the name of one of the output buffers, identifying\n+     *                      where to look for the search strings.\n@@ -487,2 +491,2 @@\n-     *  to be found, or false if the file is not expected to be found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if the file is not expected to be found\n+     * @param strings       the strings to be searched for\n@@ -502,2 +506,3 @@\n-     * @param path a path within the most recent output directory, identifying\n-     *  where to look for the search strings.\n+     *\n+     * @param path          a path within the most recent output directory, identifying\n+     *                      where to look for the search strings.\n@@ -505,3 +510,5 @@\n-     *  to be found, or false if all of the strings are expected to be\n-     *  not found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if all of the strings are expected to be\n+     *                      not found\n+     * @param strings       the strings to be searched for\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -510,8 +517,4 @@\n-        \/\/ Read contents of file\n-        try {\n-            String fileString = readFile(outputDir, Path.of(path));\n-            checkOutput(outputDir.resolve(path).toString(), fileString, expectedFound, strings);\n-        } catch (Error e) {\n-            checking(\"Read file\");\n-            failed(\"Error reading file: \" + e);\n-        }\n+        new OutputChecker(path)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (32 failures) and change to true\n+                .check(strings);\n@@ -524,1 +527,2 @@\n-     * @param output the output stream to check\n+     *\n+     * @param output        the output stream to check\n@@ -526,3 +530,5 @@\n-     *  to be found, or false if all of the strings are expected to be\n-     *  not found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if all of the strings are expected to be\n+     *                      not found\n+     * @param strings       the strings to be searched for\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -531,20 +537,4 @@\n-        checkOutput(output.toString(), outputMap.get(output), expectedFound, strings);\n-    }\n-\n-    \/\/ NOTE: path may be the name of an Output stream as well as a file path\n-    private void checkOutput(String path, String fileString, boolean expectedFound, String... strings) {\n-        for (String stringToFind : strings) {\n-\/\/            log.logCheckOutput(path, expectedFound, stringToFind);\n-            checking(\"checkOutput\");\n-            \/\/ Find string in file's contents\n-            boolean isFound = findString(fileString, stringToFind);\n-            if (isFound == expectedFound) {\n-                passed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind);\n-            } else {\n-                failed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind + '\\n' +\n-                        \"found \\n\" +\n-                        fileString);\n-            }\n-        }\n+        new OutputChecker(output)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (6 failures) and change to true\n+                .check(strings);\n@@ -555,0 +545,1 @@\n+     *\n@@ -556,0 +547,2 @@\n+     *\n+     * @see OutputChecker#checkUnique()\n@@ -562,1 +555,1 @@\n-     * Checks that there are no duplicate lines that either match or don't match a given patter,\n+     * Checks that there are no duplicate lines that either match or don't match a given pattern,\n@@ -564,1 +557,2 @@\n-     * @param output the output stream to check\n+     *\n+     * @param output  the output stream to check\n@@ -566,2 +560,4 @@\n-     * @param select if {@code true}, lines that match the pattern will be checked for uniqueness;\n-     *               if {@code false}, lines that do not match the pattern will be checked\n+     * @param select  if {@code true}, lines that match the pattern will be checked for uniqueness;\n+     *                if {@code false}, lines that do not match the pattern will be checked\n+     *\n+     * @see OutputChecker#checkUnique(Pattern, boolean)\n@@ -570,23 +566,15 @@\n-        checking(\"checkUnique\");\n-        Pattern filter = Pattern.compile(pattern);\n-        Matcher m = filter.matcher(\"\");\n-        Map<String, Integer> linesSofar = new HashMap<>();\n-        int lineNumber = 0;\n-        int duplicates = 0;\n-        for (String line : getOutputLines(output)) {\n-            m.reset(line);\n-            if (m.find() == select) {\n-                Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n-                if (prev != null) {\n-                    out.println(\"duplicate line detected on line \" + lineNumber\n-                            + \"; first occurrence on line \" + prev);\n-                    out.println(\"line: \" + line);\n-                    duplicates++;\n-                }\n-            }\n-        }\n-        if (duplicates == 0) {\n-            passed(\"All lines are unique\");\n-        } else {\n-            failed(duplicates + \" duplicate lines found\");\n-        }\n+        new OutputChecker(output).checkUnique(Pattern.compile(pattern), select);\n+    }\n+\n+    \/**\n+     * Ensures that a series of strings appear only once, in the generated output.\n+     * Note: this test does not exhaustively check for all other possible\n+     * duplicates once one is found.\n+     *\n+     * @param path    the file to check\n+     * @param strings the strings\n+     *\n+     * @see OutputChecker#checkUnique(String...)\n+     *\/\n+    public void checkUnique(String path, String... strings) {\n+        new OutputChecker(path).checkUnique(strings);\n@@ -661,1 +649,2 @@\n-     * Gets the content of the one of the output streams written by javadoc.\n+     * Returns the content of one of the output streams written by javadoc.\n+     *\n@@ -670,1 +659,2 @@\n-     * Gets the content of the one of the output streams written by javadoc.\n+     * Returns the content of one of the output streams written by javadoc.\n+     *\n@@ -681,0 +671,1 @@\n+     *\n@@ -682,4 +673,4 @@\n-     *  to be found, or false if all of the files are expected to be\n-     *  not found\n-     * @param paths the files to check, within the most recent output directory.\n-     * *\/\n+     *                      to be found, or false if all of the files are expected to be\n+     *                      not found\n+     * @param paths         the files to check, within the most recent output directory.\n+     *\/\n@@ -692,5 +683,5 @@\n-     * @param expectedFound true if all of the files are expected\n-     *  to be found, or false if all of the files are expected to be\n-     *  not found\n-     * @param paths the files to check, within the most recent output directory.\n-     * *\/\n+     *\n+     * @param expectedFound true if all of the files are expected to be found,\n+     *                      or false if all of the files are expected to be not found\n+     * @param paths         the files to check, within the most recent output directory.\n+     *\/\n@@ -714,2 +705,5 @@\n-     * @param path the file to check\n-     * @param strings  the strings whose order to check\n+     *\n+     * @param path    the file to check\n+     * @param strings the strings whose order to check\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -718,44 +712,3 @@\n-        Path file = outputDir.resolve(path);\n-        String fileString = readOutputFile(path);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = fileString.indexOf(s, prevIndex + 1);\n-            checking(\"file: \" + file + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(file, s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(file, s + \" is in the correct order\");\n-            } else {\n-                failed(file, s + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that a series of strings appear only once, in the generated output,\n-     * noting that, this test does not exhaustively check for all other possible\n-     * duplicates once one is found.\n-     * @param path the file to check\n-     * @param strings ensure each are unique\n-     *\/\n-    public void checkUnique(String path, String... strings) {\n-        Path file = outputDir.resolve(path);\n-        String fileString = readOutputFile(path);\n-        for (String s : strings) {\n-            int currentIndex = fileString.indexOf(s);\n-            checking(s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(file, s + \" not found.\");\n-                continue;\n-            }\n-            int nextindex = fileString.indexOf(s, currentIndex + s.length());\n-            if (nextindex == -1) {\n-                passed(file, s + \" is unique\");\n-            } else {\n-                failed(file, s + \" is not unique, found at \" + nextindex);\n-            }\n-        }\n+        new OutputChecker(path)\n+                .setExpectOrdered(true) \/\/ be explicit\n+                .check(strings);\n@@ -769,1 +722,1 @@\n-     * @param files the set of files to be compared\n+     * @param files    the set of files to be compared\n@@ -833,2 +786,2 @@\n-        } catch (FileNotFoundException e) {\n-            throw new Error(\"File not found: \" + fileName + \": \" + e);\n+        } catch (FileNotFoundException | NoSuchFileException e) {\n+            throw new Error(\"File not found: \" + fileName + \": \" + e, e);\n@@ -836,1 +789,1 @@\n-            throw new Error(\"Error reading file: \" + fileName + \": \" + e);\n+            throw new Error(\"Error reading file: \" + fileName + \": \" + e, e);\n@@ -944,16 +897,0 @@\n-    \/**\n-     * Searches for the string in the given file and return true\n-     * if the string was found.\n-     *\n-     * @param fileString    the contents of the file to search through\n-     * @param stringToFind  the string to search for\n-     * @return              true if the string was found\n-     *\/\n-    private boolean findString(String fileString, String stringToFind) {\n-        \/\/ javadoc (should) always use the platform newline sequence,\n-        \/\/ but in the strings to find it is more convenient to use the Java\n-        \/\/ newline character. So we translate \\n to NL before we search.\n-        stringToFind = stringToFind.replace(\"\\n\", NL);\n-        return fileString.contains(stringToFind);\n-    }\n-\n@@ -978,0 +915,453 @@\n+    \/**\n+     * A flexible checker for checking the content of generated files and output streams.\n+     *\n+     * Configuration can be done with a series of chained method calls.\n+     * Checks can be specified as either literal strings or regular expressions.\n+     *\/\n+    public class OutputChecker {\n+        private final String name;\n+        private final String content;\n+        private boolean allowOverlaps = false;\n+        private boolean expectFound = true;\n+        private boolean expectOrdered = true;\n+        private List<Range> matches = new ArrayList<>();\n+        private Range lastMatch;\n+\n+        private enum SearchKind {\n+            TEXT, PATTERN;\n+            @Override\n+            public String toString() {\n+                return name().toLowerCase(Locale.ROOT);\n+            }\n+        }\n+\n+        \/** A half-open interval {@code [start, end)} to record the position of a match. *\/\n+        record Range(int start, int end) {\n+            static Range of(int start, int end) {\n+                return new Range(start, end);\n+            }\n+            boolean overlaps(Range other) {\n+                \/\/ Intervals do not overlap if one interval is completely before or completely after the other:\n+                \/\/ that is,    other.end <= start || end <= other.start\n+                \/\/ Invert that for when intervals do overlap, and simplify to the following expression:\n+                return other.end > start && end > other.start;\n+            }\n+            String toIntervalString() {\n+                return \"[\" + start + \",\" + end + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for a file written by the most recent run of javadoc.\n+         * If the file cannot be found or there is any other error while reading the file,\n+         * an error will be reported and all subsequent {@code check...} methods will be skipped\n+         *\n+         * @param file the file\n+         *\/\n+        public OutputChecker(String file) {\n+            String c = null;\n+            try {\n+                c = readFile(file);\n+            } catch (Error e) {\n+                JavadocTester.this.checking(\"Read file \" + file);\n+                if (e.getCause() instanceof IOException) {\n+                    \/\/ exception probably thrown (with known message) by readFile\n+                    failed(e.getMessage());\n+                } else {\n+                    failed(\"Error reading file: \" + e);\n+                }\n+            }\n+\n+            if (c == null) {\n+                name = null;\n+                content = null;\n+            } else {\n+                name = file;\n+                content = c;\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for an output stream written by the most recent run of javadoc.\n+         *\n+         * @param output the output\n+         *\/\n+        public OutputChecker(Output output) {\n+            name = output.name();\n+            content = getOutput(output);\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectFound whether matches are expected to be found\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectFound(boolean expectFound) {\n+            this.expectFound = expectFound;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found in order or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectOrdered  whether matches should be ordered\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectOrdered(boolean expectOrdered) {\n+            this.expectOrdered = expectOrdered;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are allowed to overlap.\n+         * The default is {@code false}.\n+         *\n+         * @param allowOverlaps whether matches may overlap\n+         * @return this object\n+         *\/\n+        public OutputChecker setAllowOverlaps(boolean allowOverlaps) {\n+            this.allowOverlaps = allowOverlaps;\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of strings.\n+         * Within the search strings, the newline character {@code \\n}\n+         * will be translated to the platform newline character sequence.\n+         *\n+         * @param strings the strings to be searched for\n+         *\/\n+        public OutputChecker check(String... strings) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\" + NL\n+                        + List.of(strings).stream()\n+                        .map(s -> \"    \" + toShortString(s))\n+                        .collect(Collectors.joining(NL)));\n+                return this;\n+            }\n+\n+            for (String stringToFind : strings) {\n+                check(startPos -> findString(stringToFind, startPos), SearchKind.TEXT, stringToFind);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of regular expressions.\n+         * Unlike {@link #check(String...)}, there is no special handling for\n+         * newline characters. Use {@code \\R} to match the platform newline sequence.\n+         *\n+         * @param patterns the regular expressions to be searched for\n+         *\/\n+        public OutputChecker check(Pattern... patterns) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\" + NL\n+                        + List.of(patterns).stream()\n+                        .map(p -> \"    \" + toShortString(p.pattern()))\n+                        .collect(Collectors.joining(NL)));\n+                return this;\n+            }\n+            for (Pattern pattern : patterns) {\n+                check(startPos -> findPattern(pattern, startPos), SearchKind.PATTERN, pattern.pattern());\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of an item.\n+         *\n+         * @param finder a function to find the next occurrence of an item starting at a given position\n+         * @param kind   the kind of the item ({@code \"text\"} or {@code \"pattern:} to include in messages\n+         * @param s      a string for the item, to be included in messages\n+         *\/\n+        private void check(Function<Integer, Range> finder, SearchKind kind, String s) {\n+            checking(\"checkOutput\", kind);\n+            int start = getStart();\n+            Range r = finder.apply(start);\n+            boolean isFound = r != null;\n+            if (isFound == expectFound) {\n+                matches.add(lastMatch = r);\n+                passed(name + \": following \" + kind + \" \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s);\n+            } else {\n+                \/\/ item not found in order, so check if the item is found out of order, to determine the best message\n+                if (expectFound && expectOrdered && start > 0) {\n+                    Range r2 = finder.apply(0);\n+                    if (r2 != null) {\n+                        failed(name + \": following \" + kind + \" was found on line \"\n+                                + getLineNumber(r2.start)\n+                                + \", but not in order as expected, on or after line \"\n+                                + getLineNumber(start)\n+                                + \":\\n\"\n+                                + s);\n+                        return;\n+                    }\n+                }\n+                failed(name + \": following \" + kind + \" \"\n+                        + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s + '\\n' + \"found \\n\" + content);\n+            }\n+\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines in the content.\n+         *\/\n+        public OutputChecker checkUnique() {\n+            checkUnique(Pattern.compile(\".*\"), true);\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines that either match or don't match a given pattern,\n+         * in one of the streams written by javadoc.\n+         *\n+         * @param pattern a pattern to filter the lines to be checked\n+         * @param select  if {@code true}, lines that match the pattern will be checked for uniqueness;\n+         *                if {@code false}, lines that do not match the pattern will be checked\n+         *\/\n+        public OutputChecker checkUnique(Pattern pattern, boolean select ) {\n+            if (name == null) {\n+                out.println(\"Skipping checkUnique\");\n+                return this;\n+            }\n+\n+            checking(\"checkUnique\", SearchKind.PATTERN);\n+            Matcher m = pattern.matcher(\"\");\n+            Map<String, Integer> linesSofar = new HashMap<>();\n+            int lineNumber = 0;\n+            int duplicates = 0;\n+            for (String line : content.split(NL)) {\n+                m.reset(line);\n+                if (m.find() == select) {\n+                    Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n+                    if (prev != null) {\n+                        out.println(\"duplicate line detected on line \" + lineNumber\n+                                + \"; first occurrence on line \" + prev);\n+                        out.println(\"line: \" + line);\n+                        duplicates++;\n+                    }\n+                }\n+            }\n+            if (duplicates == 0) {\n+                passed(\"All lines are unique\");\n+            } else {\n+                failed(duplicates + \" duplicate lines found\");\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that each of a series of strings appears only once in the generated output.\n+         * Note: this test does not exhaustively check for all other possible duplicates once one is found.\n+         *\n+         * @param strings the strings\n+         *\/\n+        public OutputChecker checkUnique(String... strings) {\n+            return checkUnique(SearchKind.TEXT, List.of(strings), this::findString);\n+        }\n+\n+        \/**\n+         * Checks that each of a series of pattern matches appears only once in the generated output.\n+         * Note: this test does not exhaustively check for all other possible duplicates once one is found.\n+         *\n+         * @param patterns the patterns\n+         *\/\n+        public OutputChecker checkUnique(Pattern... patterns) {\n+            return checkUnique(SearchKind.PATTERN, List.of(patterns), this::findPattern);\n+        }\n+\n+        private <T> OutputChecker checkUnique(SearchKind kind, List<T> items, BiFunction<T, Integer, Range> finder) {\n+            if (name == null) {\n+                out.println(\"Skipping checkUnique\");\n+                return this;\n+            }\n+\n+            Range latest = null;\n+            for (T item : items) {\n+                int start = getStart();\n+                Range r = finder.apply(item, start);\n+                checking(\"checkUnique at index \" + start, SearchKind.TEXT);\n+                if (r == null) {\n+                    failed(name + \": \" + item + \" not found.\");\n+                    continue;\n+                }\n+                \/\/ only update lastMatch for the initial match of each item\n+                if (lastMatch == null) {\n+                    lastMatch = r;\n+                }\n+                Range next = finder.apply(item, r.end);\n+                if (next == null) {\n+                    passed(name + \": \" + item + \" is unique\");\n+                } else {\n+                    failed(name + \": \" + item + \" is not unique, found at \" + next.start);\n+                }\n+            }\n+            if (latest != null) {\n+                lastMatch = latest;\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that all the output has been matched by preceding checks with this object.\n+         * It does not matter whether the checks were ordered or not.\n+         * The results of the matches are sorted and then checked to be adjacent and to\n+         * cover the entire content.\n+         *\n+         * @apiNote This is probably most useful for checking diagnostic output,\n+         *          in which case care must be taken to allow for platform differences\n+         *          in the output, such as file separators and newline sequences.\n+         *\/\n+        public OutputChecker checkComplete() {\n+            if (name == null) {\n+                out.println(\"Skipping checkComplete\");\n+                return this;\n+            }\n+\n+            JavadocTester.this.checking(\"checking for complete coverage of output\");\n+            List<Range> uncovered = new ArrayList<>();\n+            List<Range> list = new ArrayList<>(matches);\n+            list.sort(Comparator.comparing(Range::start));\n+            int prev = 0;\n+            for (Range r : list) {\n+                if (r.start != prev) {\n+                    uncovered.add(new Range(prev, r.start));\n+                }\n+                prev = r.end;\n+            }\n+            if (prev != content.length()) {\n+                uncovered.add(new Range(prev, content.length()));\n+            }\n+            if (uncovered.isEmpty()) {\n+                passed(\"All output matched\");\n+            } else {\n+                failed(\"The following output was not matched: \"\n+                    + uncovered.stream()\n+                        .map(Range::toIntervalString)\n+                        .collect(Collectors.joining(\", \")));\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that no output is present.\n+         *\/\n+        public OutputChecker checkEmpty() {\n+            if (name == null) {\n+                out.println(\"Skipping checkEmpty\");\n+                return this;\n+            }\n+\n+            JavadocTester.this.checking(\"empty\");\n+            if (content == null || content.isEmpty()) {\n+                passed(name + \" is empty, as expected\");\n+            } else {\n+                failed(name + \" is not empty; contains:\\n\"\n+                        + content);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\/\n+        public OutputChecker checkAnyOf(String... strings) {\n+            return checkAnyOf(SearchKind.TEXT, List.of(strings), this::findString);\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\/\n+        public OutputChecker checkAnyOf(Pattern... patterns) {\n+            return checkAnyOf(SearchKind.PATTERN, List.of(patterns), this::findPattern);\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\n+         *\/\n+        private <T> OutputChecker checkAnyOf(SearchKind kind, List<T> items, BiFunction<T, Integer, Range> finder) {\n+            if (name == null) {\n+                out.println(\"Skipping checkAnyOf\");\n+                return this;\n+            }\n+\n+            checking(\"checkAnyOf\", kind);\n+            Range earliest = null;\n+            int start = getStart();\n+            int count = 0;\n+            for (T item : items) {\n+                Range r = finder.apply(item, start);\n+                if (r != null) {\n+                    count++;\n+                    if (earliest == null || rangeComparator.compare(earliest, r) > 0) {\n+                        earliest = r;\n+                    }\n+                }\n+            }\n+            if (earliest != null) {\n+                lastMatch = earliest;\n+            }\n+            if (count == 0) {\n+                failed(\"no match found for any \" + kind);\n+            } else {\n+                passed(count + \" matches found; earliest is \" + earliest.toIntervalString());\n+            }\n+            return this;\n+        }\n+\n+        Comparator<Range> rangeComparator = Comparator.comparing(Range::start).thenComparing(Range::end);\n+\n+        private void checking(String name, SearchKind kind) {\n+            JavadocTester.this.checking(name + \" \" + kind.name()\n+                + \" allowOverlaps:\" + allowOverlaps\n+                + \" expectFound:\"   + expectFound\n+                + \" expectOrdered:\" + expectOrdered);\n+        }\n+\n+        private Range findString(String stringToFind, int start) {\n+            \/\/ javadoc (should) always use the platform newline sequence,\n+            \/\/ but in the strings to find it is more convenient to use the Java\n+            \/\/ newline character. So we translate \\n to NL before we search.\n+            stringToFind = stringToFind.replace(\"\\n\", NL);\n+            int i = content.indexOf(stringToFind, start);\n+            return i >= 0 ? Range.of(i, i + stringToFind.length()) : null;\n+        }\n+\n+        private Range findPattern(Pattern p, int start) {\n+            Matcher m = p.matcher(content);\n+            return m.find(start) ? Range.of(m.start(), m.end()) : null;\n+        }\n+        private int getStart() {\n+            if (lastMatch == null || !expectOrdered) {\n+                return 0;\n+            }\n+            return allowOverlaps ? lastMatch.start + 1 : lastMatch.end;\n+        }\n+\n+        private int getLineNumber(int pos) {\n+            Pattern p = Pattern.compile(\"\\\\R\");\n+            Matcher m = p.matcher(content);\n+            int line = 1;\n+            int start = 0;\n+            while (m.find(start) && m.start() < pos) {\n+                line++;\n+                start = m.start() + 1;\n+            }\n+            return line;\n+        }\n+\n+        private String toShortString(String s) {\n+            final int MAX = 64;\n+            s = s.replaceAll(\"\\\\s+\", \" \");\n+            if (s.length() > MAX) {\n+                s = s.substring(0, MAX \/ 2 - 2) + \" ... \" + s.substring(s.length() - MAX \/ 2 - 2);\n+            }\n+            return s;\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":544,"deletions":154,"binary":false,"changes":698,"status":"modified"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8273154\n+ * @summary Provide a JavadocTester method for non-overlapping, unordered output matching\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestJavadocTester\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests basic mechanisms in the {@code JavadocTester} class.\n+ *\n+ * It is not a direct test of the javadoc tool or the output generated by the\n+ * Standard Doclet, although both are indirectly used as part of this test.\n+ *\n+ * The test works by exercising the {@code JavadocTester} API with a series of\n+ * positive and negative tests.  The {@code passed} and {@code failed} methods\n+ * are overridden to record the messages reported by the underlying instance, so\n+ * that the messages can subsequently be verified. Also, {@code printSummary}\n+ * is overridden to suppress the default action to throw {@code Error} when\n+ * tests have failed.\n+ *\/\n+public class TestJavadocTester extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        TestJavadocTester tester = new TestJavadocTester();\n+        tester.setup().runTests();\n+    }\n+\n+    private final List<String> messages = new ArrayList<>();\n+    private int testErrors = 0;\n+\n+    \/**\n+     * Overrides the default implementation of {@code passed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void passed(String message) {\n+        super.passed(message);\n+        messages.add(\"Passed: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code failed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void failed(String message) {\n+        super.failed(message);\n+        messages.add(\"FAILED: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code printSummary} to suppress\n+     * the error thrown as a result of errors reported by {@code JavadocTester}.\n+     * Instead, an error is thrown if any errors are found by the tests in this class.\n+     *\/\n+    @Override\n+    public void printSummary() {\n+        try {\n+            super.printSummary();\n+        } catch (Error e) {\n+            if (e.getClass() != Error.class) {\n+                throw e;\n+            }\n+            report(\"Suppressed: \" + e);\n+        }\n+\n+        if (testErrors > 0) {\n+            report(testErrors + \" errors found\");\n+            throw new Error(testErrors + \" errors found\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks the content of messages reported by the {@code passed} and {@code failed}\n+     * methods in {@code JavadocTester}.  The messages are saved by the local overloads\n+     * of those methods in this class.\n+     *\n+     * Because some of the messages are <em>very<\/em> long, it is enough to pass in\n+     * initial substrings of the expected messages.\n+     *\n+     * Note that messages reported by {@code JavadocTester} use filenames as given\n+     * to the various {@code check...} calls. By convention, these always use {@code \/}\n+     * as the file separator, and not the platform file separator.\n+     *\n+     * @param expect initial substrings of expected messages\n+     *\/\n+    void checkMessages(String... expect) {\n+        for (String e : expect) {\n+            Optional<String> match = messages.stream()\n+                    .filter(m -> m.startsWith(e))\n+                    .findFirst();\n+            if (match.isPresent()) {\n+                report(\"found '\" + e + \"'\");\n+            } else {\n+                report(\"ERROR: no message found for '\" + e + \"'\");\n+                testErrors++;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reports a message, preceded by {@code >>> }.\n+     *\n+     * It is helpful\/important to distinguish the messages written as a side-effect\n+     * of the underlying tests from the messages used to report the outcome of the\n+     * tests that verify those messages.  Instead of interposing to mark the messages\n+     * written as a side effect of the underlying tests, we leave those messages\n+     * unchanged, and instead, mark the messages reporting whether those messages\n+     * are as expected or not.\n+     *\n+     * @param message the message to be reported.\n+     *\/\n+    private void report(String message) {\n+        message.lines().forEachOrdered(l -> out.println(\">>> \" + l));\n+    }\n+\n+    \/\/-------------------------------------------------\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    TestJavadocTester setup() throws IOException {\n+        Path src = Path.of(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * First sentence abc.\n+                 * Second sentence.\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 *\/\n+                public class C {\n+                    private C() { }\n+                    \/** m3 comment. *\/\n+                    public void m3() { }\n+                    \/** m2 comment. *\/\n+                    public void m2() { }\n+                    \/** m1 comment. *\/\n+                    public void m1() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", \"out\",\n+                \"-sourcepath\", src.toString(),\n+                \"-noindex\", \"-nohelp\",\n+                \"p\");\n+        return this;\n+    }\n+\n+    @Test\n+    public void testSimpleStringCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"abc123\",\n+                        \"def456\");\n+        messages.forEach(this::report);\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    abc123\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    def456\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectFound(false)\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    FAILED: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleRegexCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(Pattern.compile(\"S.cond s.nt.nc.\"),\n+                        Pattern.compile(\"[abc]{3}[123]{3}\"),\n+                        Pattern.compile(\"d.f4.6\"));\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    S.cond s.nt.nc.\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    [abc]{3}[123]{3}\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    d.f4.6\"\"\");\n+    }\n+\n+    @Test\n+    public void testOrdered() {\n+        messages.clear();\n+        \/\/ methods are listed alphabetically in the Summary table,\n+        \/\/ but in source-code order in the Details section.\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"<h2>Method Summary<\/h2>\",\n+                        \"<a href=\\\"#m1()\\\" class=\\\"member-name-link\\\">m1<\/a>\",\n+                        \"<a href=\\\"#m2()\\\" class=\\\"member-name-link\\\">m2<\/a>\",\n+                        \"<a href=\\\"#m3()\\\" class=\\\"member-name-link\\\">m3<\/a>\")\n+                .check(\"<h2>Method Details<\/h2>\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m3()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m2()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m1()\\\">\\n\");\n+\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Summary<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m1()\" class=\"member-name-link\">m1<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m2()\" class=\"member-name-link\">m2<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m3()\" class=\"member-name-link\">m3<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Details<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m3()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m2()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m1()\">\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testUnordered_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(false)\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    First sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testUnordered_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    FAILED: p\/C.html: following text was found on line\"\"\");\n+    }\n+\n+    @Test\n+    public void testComplete_Ordered() {\n+        messages.clear();\n+        \/\/ In the following calls, the strings are specified in the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        fix(\"Creating destination directory: \\\"out\/\\\"\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .check(\"Building tree for all the packages and classes...\\n\",\n+                        fix(\"Generating out\/p\/C.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-summary.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-tree.html...\\n\"),\n+                        fix(\"Generating out\/overview-tree.html...\\n\"),\n+                        fix(\"Generating out\/index.html...\\n\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    @Test\n+    public void testComplete_Unordered() {\n+        messages.clear();\n+        \/\/ In the following calls, the strings are deliberately specified out of the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .setExpectOrdered(false)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        \"Building tree for all the packages and classes...\\n\")\n+                .check(fix(\"Creating destination directory: \\\"out\/\\\"\\n\",\n+                        \"Generating out\/index.html...\\n\",\n+                        \"Generating out\/overview-tree.html...\\n\",\n+                        \"Generating out\/p\/package-tree.html...\\n\",\n+                        \"Generating out\/p\/package-summary.html...\\n\",\n+                        \"Generating out\/p\/C.html...\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    @Test\n+    public void testEmpty() {\n+        messages.clear();\n+        new OutputChecker(Output.STDERR)\n+                .checkEmpty();\n+        checkMessages(\"Passed: STDERR is empty, as expected\");\n+    }\n+\n+    @Test\n+    public void testBadFile() {\n+        messages.clear();\n+        new OutputChecker(\"does-not-exist.html\")\n+                .check(\"abcdef\",\n+                        \"very long string \".repeat(10))\n+                .check(Pattern.quote(\"abcdef\"),\n+                        Pattern.quote(\"very long string\".repeat(10)));\n+        checkMessages(\"FAILED: File not found: does-not-exist.html\");\n+    }\n+\n+    @Test\n+    public void testAnyOf() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .checkAnyOf(\"m1()\", \"m2()\", \"m3()\")    \/\/ expect all found\n+                .checkAnyOf(\"m1()\", \"m2()\", \"M3()\")    \/\/ expect some found\n+                .checkAnyOf(\"M1()\", \"M2()\", \"M3()\");   \/\/ expect none found\n+        checkMessages(\"Passed: 3 matches found\",\n+                \"Passed: 2 matches found\",\n+                \"FAILED: no match found for any text\");\n+    }\n+\n+    @Test\n+    public void testUnique() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(false)\n+                .checkUnique(\"id=\\\"m1()\\\"\", \"id=\\\"m2()\\\"\", \"id=\\\"m3()\\\"\")   \/\/ expect unique\n+                .checkUnique(\"m1()\", \"m2()\", \"m3()\");                       \/\/ expect not unique\n+        checkMessages(\"Passed: p\/C.html: id=\\\"m1()\\\" is unique\",\n+                \"Passed: p\/C.html: id=\\\"m2()\\\" is unique\",\n+                \"Passed: p\/C.html: id=\\\"m3()\\\" is unique\",\n+                \"FAILED: p\/C.html: m1() is not unique\",\n+                \"FAILED: p\/C.html: m2() is not unique\",\n+                \"FAILED: p\/C.html: m3() is not unique\");\n+    }\n+\n+    \/**\n+     * {@return a string with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param item the string\n+     *\/\n+    private String fix(String item) {\n+        return item.replace(\"\/\", FS);\n+    }\n+\n+    \/**\n+     * {@return an array of strings with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param items the strings\n+     *\/\n+    private String[] fix(String... items) {\n+        return Stream.of(items)\n+                .map(this::fix)\n+                .toArray(String[]::new);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/testJavadocTester\/TestJavadocTester.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"}]}