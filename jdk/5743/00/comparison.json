{"files":[{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Comparator;\n@@ -59,0 +60,1 @@\n+import java.util.stream.Collectors;\n@@ -503,8 +505,4 @@\n-        \/\/ Read contents of file\n-        try {\n-            String fileString = readFile(outputDir, path);\n-            checkOutput(new File(outputDir, path).getPath(), fileString, expectedFound, strings);\n-        } catch (Error e) {\n-            checking(\"Read file\");\n-            failed(\"Error reading file: \" + e);\n-        }\n+        new OutputChecker(path)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (32 failures) and change to true\n+                .check(strings);\n@@ -524,20 +522,4 @@\n-        checkOutput(output.toString(), outputMap.get(output), expectedFound, strings);\n-    }\n-\n-    \/\/ NOTE: path may be the name of an Output stream as well as a file path\n-    private void checkOutput(String path, String fileString, boolean expectedFound, String... strings) {\n-        for (String stringToFind : strings) {\n-\/\/            log.logCheckOutput(path, expectedFound, stringToFind);\n-            checking(\"checkOutput\");\n-            \/\/ Find string in file's contents\n-            boolean isFound = findString(fileString, stringToFind);\n-            if (isFound == expectedFound) {\n-                passed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind);\n-            } else {\n-                failed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind + '\\n' +\n-                        \"found \\n\" +\n-                        fileString);\n-            }\n-        }\n+        new OutputChecker(output)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (6 failures) and change to true\n+                .check(strings);\n@@ -555,1 +537,1 @@\n-     * Checks that there are no duplicate lines that either match or don't match a given patter,\n+     * Checks that there are no duplicate lines that either match or don't match a given pattern,\n@@ -563,23 +545,1 @@\n-        checking(\"checkUnique\");\n-        Pattern filter = Pattern.compile(pattern);\n-        Matcher m = filter.matcher(\"\");\n-        Map<String, Integer> linesSofar = new HashMap<>();\n-        int lineNumber = 0;\n-        int duplicates = 0;\n-        for (String line : getOutputLines(output)) {\n-            m.reset(line);\n-            if (m.find() == select) {\n-                Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n-                if (prev != null) {\n-                    out.println(\"duplicate line detected on line \" + lineNumber\n-                            + \"; first occurrence on line \" + prev);\n-                    out.println(\"line: \" + line);\n-                    duplicates++;\n-                }\n-            }\n-        }\n-        if (duplicates == 0) {\n-            passed(\"All lines are unique\");\n-        } else {\n-            failed(duplicates + \" duplicate lines found\");\n-        }\n+        new OutputChecker(output).checkUnique(pattern, select);\n@@ -711,18 +671,3 @@\n-        File file = new File(outputDir, path);\n-        String fileString = readOutputFile(path);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = fileString.indexOf(s, prevIndex + 1);\n-            checking(\"file: \" + file + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(file, s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(file, s + \" is in the correct order\");\n-            } else {\n-                failed(file, s + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n+        new OutputChecker(path)\n+                .setExpectOrdered(true) \/\/ be explicit\n+                .check(strings);\n@@ -1016,0 +961,330 @@\n+    \/**\n+     * A flexible checker for checking the content of generated files and output streams.\n+     *\n+     * Configuration can be done with a series of chained method calls.\n+     * Checks can be specified as either literal strings or regular expressions.\n+     *\/\n+    public class OutputChecker {\n+        private final String name;\n+        private final String content;\n+        private boolean allowOverlaps = false;\n+        private boolean expectFound = true;\n+        private boolean expectOrdered = true;\n+        private List<Range> matches = new ArrayList<>();\n+        private Range lastMatch;\n+\n+        \/** A half-open interval {@code [start, end)} to record the position of a match. *\/\n+        record Range(int start, int end) {\n+            static Range of(int start, int end) {\n+                return new Range(start, end);\n+            }\n+            boolean overlaps(Range other) {\n+                \/\/ Intervals do not overlap if one interval is completely before or completely after the other:\n+                \/\/ that is,    other.end <= start || end <= other.start\n+                \/\/ Invert that for when intervals do overlap, and simplify to the following expression:\n+                return other.end > start && end > other.start;\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for a file written by the most recent run of javadoc.\n+         * If the file cannot be found or there is any other error while reading the file,\n+         * an error will be reported and all subsequent {@code check...} methods will be skipped\n+         *\n+         * @param file the file\n+         *\/\n+        public OutputChecker(String file) {\n+            String c = null;\n+            try {\n+                c = readFile(file);\n+            } catch (Error e) {\n+                checking(\"Read file\");\n+                failed(\"Error reading file: \" + e);\n+            }\n+\n+            if (c == null) {\n+                name = null;\n+                content = null;\n+            } else {\n+                name = file;\n+                content = c;\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for an output stream written by the most recent run of javadoc.\n+         *\n+         * @param output the output\n+         *\/\n+        public OutputChecker(Output output) {\n+            name = output.name();\n+            content = getOutput(output);\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectFound whether matches are expected to be found\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectFound(boolean expectFound) {\n+            this.expectFound = expectFound;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found in order or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectOrdered  whether matches should be ordered\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectOrdered(boolean expectOrdered) {\n+            this.expectOrdered = expectOrdered;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are allowed to overlap.\n+         * The default is {@code false}.\n+         *\n+         * @param allowOverlaps whether matches may overlap\n+         * @return this object\n+         *\/\n+        public OutputChecker setAllowOverlaps(boolean allowOverlaps) {\n+            this.allowOverlaps = allowOverlaps;\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of strings.\n+         * Within the search strings, the newline character {@code \\n}\n+         * will be translated to the platform newline character sequence.\n+         *\n+         * @param strings the strings to be searched for\n+         *\/\n+        public OutputChecker check(String... strings) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\\n\"\n+                        + List.of(strings).stream()\n+                        .map(s -> \"    \" + toShortString(s))\n+                        .collect(Collectors.joining(\"\\n\")));\n+                return this;\n+            }\n+\n+            for (String stringToFind : strings) {\n+                check(startPos -> findString(stringToFind, startPos), \"text\", stringToFind);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of regular expressions.\n+         * Unlike {@link #check(String...)}, there is no special handling for\n+         * newline characters. Use {@code \\R} to match the platform newline sequence.\n+         *\n+         * @param patterns the regular expressions to be searched for\n+         *\/\n+        public OutputChecker check(Pattern... patterns) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\\n\"\n+                        + List.of(patterns).stream()\n+                        .map(p -> \"    \" + toShortString(p.pattern()))\n+                        .collect(Collectors.joining(\"\\n\")));\n+                return this;\n+            }\n+            for (Pattern pattern : patterns) {\n+                check(startPos -> findPattern(pattern, startPos), \"pattern\", pattern.pattern());\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines in the content.\n+         *\/\n+        public OutputChecker checkUnique() {\n+            checkUnique(\".*\", true);\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines that either match or don't match a given pattern,\n+         * in one of the streams written by javadoc.\n+         *\n+         * @param pattern a pattern to filter the lines to be checked\n+         * @param select  if {@code true}, lines that match the pattern will be checked for uniqueness;\n+         *                if {@code false}, lines that do not match the pattern will be checked\n+         *\/\n+        public OutputChecker checkUnique(String pattern, boolean select ) {\n+            checking(\"checkUnique\");\n+            Pattern filter = Pattern.compile(pattern);\n+            Matcher m = filter.matcher(\"\");\n+            Map<String, Integer> linesSofar = new HashMap<>();\n+            int lineNumber = 0;\n+            int duplicates = 0;\n+            for (String line : content.split(NL)) {\n+                m.reset(line);\n+                if (m.find() == select) {\n+                    Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n+                    if (prev != null) {\n+                        out.println(\"duplicate line detected on line \" + lineNumber\n+                                + \"; first occurrence on line \" + prev);\n+                        out.println(\"line: \" + line);\n+                        duplicates++;\n+                    }\n+                }\n+            }\n+            if (duplicates == 0) {\n+                passed(\"All lines are unique\");\n+            } else {\n+                failed(duplicates + \" duplicate lines found\");\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that all the output has been matched by preceding checks with this object.\n+         * It does not matter whether the checks were ordered or not.\n+         * The results of the matches are sorted and then checked to be adjacent and to\n+         * cover the entire content.\n+         *\n+         * @apiNote This is probably most useful for checking diagnostic output,\n+         *          in which case care must be taken to allow for platform differences\n+         *          in the output, such as file separators and newline sequences.\n+         *\/\n+        public OutputChecker checkComplete() {\n+            if (name == null) {\n+                out.println(\"Skipping checkComplete\");\n+                return this;\n+            }\n+\n+            JavadocTester.this.checking(\"checking for complete coverage of output\");\n+            List<Range> uncovered = new ArrayList<>();\n+            List<Range> list = new ArrayList<>(matches);\n+            list.sort(Comparator.comparing(Range::start));\n+            int prev = 0;\n+            for (Range r : list) {\n+                if (r.start != prev) {\n+                    uncovered.add(new Range(prev, r.start));\n+                }\n+                prev = r.end;\n+            }\n+            if (prev != content.length()) {\n+                uncovered.add(new Range(prev, content.length()));\n+            }\n+            if (uncovered.isEmpty()) {\n+                passed(\"All output matched\");\n+            } else {\n+                failed(\"The following output was not matched: \"\n+                    + uncovered.stream()\n+                        .map(r -> \"[\" + r.start + \",\" + r.end + \")\")\n+                        .collect(Collectors.joining(\", \")));\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that no output is present.\n+         *\/\n+        public OutputChecker checkEmpty() {\n+            if (name == null) {\n+                out.println(\"Skipping checkEmpty\");\n+                return this;\n+            }\n+\n+            checking(\"empty\");\n+            if (content == null || content.isEmpty()) {\n+                passed(name + \" is empty, as expected\");\n+            } else {\n+                failed(name + \" is not empty; contains:\\n\"\n+                        + content);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of an item.\n+         *\n+         * @param finder a function to find the next occurrence of an item starting at a given position\n+         * @param kind   the kind of the item ({@code \"text\"} or {@code \"pattern:} to include in messages\n+         * @param s      a string for the item, to be included in messages\n+         *\/\n+        private void check(Function<Integer, Range> finder, String kind, String s) {\n+            checking(kind);\n+            int start = getStart();\n+            Range r = finder.apply(start);\n+            boolean isFound = r != null;\n+            if (isFound == expectFound) {\n+                matches.add(lastMatch = r);\n+                passed(name + \": following \" + kind + \" \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s);\n+            } else {\n+                \/\/ item not found in order, so check if the item is found out of order, to determine the best message\n+                if (expectFound && expectOrdered && start > 0) {\n+                    Range r2 = finder.apply(0);\n+                    if (r2 != null) {\n+                        failed(name + \": following \" + kind + \" was found on line \"\n+                                + getLineNumber(r2.start)\n+                                + \", but not in order as expected, on or after line \"\n+                                + getLineNumber(start)\n+                                + \":\\n\"\n+                                + s);\n+                        return;\n+                    }\n+                }\n+                failed(name + \": following \" + kind + \" \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s + '\\n' + \"found \\n\" + content);\n+            }\n+\n+        }\n+\n+        private void checking(String kind) {\n+            JavadocTester.this.checking(\"checkOutput \" + kind\n+                + \" allowOverlaps:\" + allowOverlaps\n+                + \" expectFound:\"   + expectFound\n+                + \" expectOrdered:\" + expectOrdered);\n+        }\n+\n+        private Range findString(String stringToFind, int start) {\n+            \/\/ javadoc (should) always use the platform newline sequence,\n+            \/\/ but in the strings to find it is more convenient to use the Java\n+            \/\/ newline character. So we translate \\n to NL before we search.\n+            stringToFind = stringToFind.replace(\"\\n\", NL);\n+            int i = content.indexOf(stringToFind, start);\n+            return i >= 0 ? Range.of(i, i + stringToFind.length()) : null;\n+        }\n+\n+        private Range findPattern(Pattern p, int start) {\n+            Matcher m = p.matcher(content);\n+            return m.find(start) ? Range.of(m.start(), m.end()) : null;\n+        }\n+        private int getStart() {\n+            if (lastMatch == null || !expectOrdered) {\n+                return 0;\n+            }\n+            return allowOverlaps ? lastMatch.start + 1 : lastMatch.end;\n+        }\n+\n+        private int getLineNumber(int pos) {\n+            Pattern p = Pattern.compile(\"\\\\R\");\n+            Matcher m = p.matcher(content);\n+            int line = 1;\n+            int start = 0;\n+            while (m.find(start) && m.start() < pos) {\n+                line++;\n+                start = m.start() + 1;\n+            }\n+            return line;\n+        }\n+\n+        private String toShortString(String s) {\n+            final int MAX = 64;\n+            s = s.replaceAll(\"\\\\s+\", \" \");\n+            if (s.length() > MAX) {\n+                s = s.substring(0, MAX \/ 2 - 2) + \" ... \" + s.substring(s.length() - MAX \/ 2 - 2);\n+            }\n+            return s;\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":345,"deletions":70,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -0,0 +1,409 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8273154\n+ * @summary Provide a JavadocTester method for non-overlapping, unordered output matching\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestJavadocTester\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests basic mechanisms in the {@code JavadocTester} class.\n+ *\n+ * It is not a direct test of the javadoc tool or the output generated by the\n+ * Standard Doclet, although both are indirectly used as part of this test.\n+ *\n+ * The test works by exercising the {@code JavadocTester} API with a series of\n+ * positive and negative tests.  The {@code passed} and {@code failed} methods\n+ * are overridden to record the messages reported by the underlying instance, so\n+ * that the messages can subsequently be verified. Also, {@code printSummary}\n+ * is overridden to suppress the default action to throw {@code Error} when\n+ * tests have failed.\n+ *\/\n+public class TestJavadocTester extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        TestJavadocTester tester = new TestJavadocTester();\n+        tester.setup().runTests();\n+    }\n+\n+    private final List<String> messages = new ArrayList<>();\n+    private int testErrors = 0;\n+\n+    \/**\n+     * Overrides the default implementation of {@code passed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void passed(String message) {\n+        super.passed(message);\n+        messages.add(\"Passed: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code failed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void failed(String message) {\n+        super.failed(message);\n+        messages.add(\"FAILED: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code printSummary} to suppress\n+     * the error thrown as a result of errors reported by {@code JavadocTester}.\n+     * Instead, an error is thrown if any errors are found by the tests in this class.\n+     *\/\n+    @Override\n+    public void printSummary() {\n+        try {\n+            super.printSummary();\n+        } catch (Error e) {\n+            if (e.getClass() != Error.class) {\n+                throw e;\n+            }\n+            report(\"Suppressed: \" + e);\n+        }\n+\n+        if (testErrors > 0) {\n+            report(testErrors + \" errors found\");\n+            throw new Error(testErrors + \" errors found\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks the content of messages reported by the {@code passed} and {@code failed}\n+     * methods in {@code JavadocTester}.  The messages are saved by the local overloads\n+     * of those methods in this class.\n+     *\n+     * Because some of the messages are <em>very<\/em> long, it is enough to pass in\n+     * initial substrings of the expected messages.\n+     *\n+     * Note that messages reported by {@code JavadocTester} use filenames as given\n+     * to the various {@code check...} calls. By convention, these always use {@code \/}\n+     * as the file separator, and not the platform file separator.\n+     *\n+     * @param expect initial substrings of expected messages\n+     *\/\n+    void checkMessages(String... expect) {\n+        for (String e : expect) {\n+            Optional<String> match = messages.stream()\n+                    .filter(m -> m.startsWith(e))\n+                    .findFirst();\n+            if (match.isPresent()) {\n+                report(\"found '\" + e + \"'\");\n+            } else {\n+                report(\"ERROR: no message found for '\" + e + \"'\");\n+                testErrors++;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reports a message, preceded by {@code >>> }.\n+     *\n+     * It is helpful\/important to distinguish the messages written as a side-effect\n+     * of the underlying tests from the messages used to report the outcome of the\n+     * tests that verify those messages.  Instead of interposing to mark the messages\n+     * written as a side effect of the underlying tests, we leave those messages\n+     * unchanged, and instead, mark the messages reporting whether those messages\n+     * are as expected or not.\n+     *\n+     * @param message the message to be reported.\n+     *\/\n+    private void report(String message) {\n+        message.lines().forEachOrdered(l -> out.println(\">>> \" + l));\n+    }\n+\n+    \/\/-------------------------------------------------\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    TestJavadocTester setup() throws IOException {\n+        Path src = Path.of(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * First sentence abc.\n+                 * Second sentence.\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 *\/\n+                public class C {\n+                    private C() { }\n+                    \/** m3 comment. *\/\n+                    public void m3() { }\n+                    \/** m2 comment. *\/\n+                    public void m2() { }\n+                    \/** m1 comment. *\/\n+                    public void m1() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", \"out\",\n+                \"-sourcepath\", src.toString(),\n+                \"-noindex\", \"-nohelp\",\n+                \"p\");\n+        return this;\n+    }\n+\n+    @Test\n+    public void testSimpleStringCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"abc123\",\n+                        \"def456\");\n+        messages.forEach(this::report);\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    abc123\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    def456\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectFound(false)\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    FAILED: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleRegexCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(Pattern.compile(\"S.cond s.nt.nc.\"),\n+                        Pattern.compile(\"[abc]{3}[123]{3}\"),\n+                        Pattern.compile(\"d.f4.6\"));\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    S.cond s.nt.nc.\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    [abc]{3}[123]{3}\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    d.f4.6\"\"\");\n+    }\n+\n+    @Test\n+    public void testOrdered() {\n+        messages.clear();\n+        \/\/ methods are listed alphabetiocally in the Summary table,\n+        \/\/ but in source-code order in the Details section.\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"<h2>Method Summary<\/h2>\",\n+                        \"<a href=\\\"#m1()\\\" class=\\\"member-name-link\\\">m1<\/a>\",\n+                        \"<a href=\\\"#m2()\\\" class=\\\"member-name-link\\\">m2<\/a>\",\n+                        \"<a href=\\\"#m3()\\\" class=\\\"member-name-link\\\">m3<\/a>\")\n+                .check(\"<h2>Method Details<\/h2>\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m3()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m2()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m1()\\\">\\n\");\n+\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Summary<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m1()\" class=\"member-name-link\">m1<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m2()\" class=\"member-name-link\">m2<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m3()\" class=\"member-name-link\">m3<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Details<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m3()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m2()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m1()\">\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testUnordered_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(false)\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    First sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testUnordered_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    FAILED: p\/C.html: following text was found on line\"\"\");\n+    }\n+\n+    @Test\n+    public void testComplete_Ordered() {\n+        messages.clear();\n+        \/\/ In this following calls, the strings are specified in the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        fix(\"Creating destination directory: \\\"out\/\\\"\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .check(\"Building tree for all the packages and classes...\\n\",\n+                        fix(\"Generating out\/p\/C.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-summary.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-tree.html...\\n\"),\n+                        fix(\"Generating out\/overview-tree.html...\\n\"),\n+                        fix(\"Generating out\/index.html...\\n\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    @Test\n+    public void testComplete_Unordered() {\n+        messages.clear();\n+        \/\/ In this following calls, the strings are deliberately specified out of the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .setExpectOrdered(false)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        \"Building tree for all the packages and classes...\\n\")\n+                .check(fix(\"Creating destination directory: \\\"out\/\\\"\\n\",\n+                        \"Generating out\/index.html...\\n\",\n+                        \"Generating out\/overview-tree.html...\\n\",\n+                        \"Generating out\/p\/package-tree.html...\\n\",\n+                        \"Generating out\/p\/package-summary.html...\\n\",\n+                        \"Generating out\/p\/C.html...\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    \/**\n+     * {@return a string with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param item the string\n+     *\/\n+    private String fix(String item) {\n+        return item.replace(\"\/\", FS);\n+    }\n+\n+    \/**\n+     * {@return an array of strings with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param items the strings\n+     *\/\n+    private String[] fix(String... items) {\n+        return List.of(items).stream()\n+                .map(this::fix)\n+                .toArray(String[]::new);\n+    }\n+\n+    @Test\n+    public void testEmpty() {\n+        messages.clear();\n+        new OutputChecker(Output.STDERR)\n+                .checkEmpty();\n+        checkMessages(\"Passed: STDERR is empty, as expected\");\n+    }\n+\n+    @Test\n+    public void testBadFile() {\n+        messages.clear();\n+        new OutputChecker(\"does-not-exist.html\")\n+                .check(\"abcdef\",\n+                        \"very long string \".repeat(10))\n+                .check(Pattern.quote(\"abcdef\"),\n+                        Pattern.quote(\"very long string\".repeat(10)));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/testJavadocTester\/TestJavadocTester.java","additions":409,"deletions":0,"binary":false,"changes":409,"status":"added"}]}