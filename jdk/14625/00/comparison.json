{"files":[{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Version.*;\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true CancelledResponse2\n+ *\/\n+\n+public class CancelledResponse2 {\n+\n+\n+    HttpTestServer h2TestServer;\n+    URI h2TestServerURI;\n+    private SSLContext sslContext;\n+    private static final Random random = RandomFactory.getRandom();\n+    private static final int MAX_CLIENT_DELAY = 160;\n+\n+    @DataProvider(name = \"versions\")\n+    public Object[][] positive() {\n+        return new Object[][]{\n+                { HTTP_2, h2TestServerURI },\n+        };\n+    }\n+\n+    private static void delay() {\n+        int delay = random.nextInt(MAX_CLIENT_DELAY);\n+        try {\n+            System.out.println(\"client delay: \" + delay);\n+            Thread.sleep(delay);\n+        } catch (InterruptedException x) {\n+            out.println(\"Unexpected exception: \" + x);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"versions\")\n+    public void test(Version version, URI uri) throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            HttpClient httpClient = HttpClient.newBuilder().sslContext(sslContext).version(version).build();\n+            HttpRequest httpRequest = HttpRequest.newBuilder(uri)\n+                    .version(version)\n+                    .GET()\n+                    .build();\n+            AtomicBoolean cancelled = new AtomicBoolean();\n+            BodyHandler<String> bh = ofString(response, cancelled);\n+            CompletableFuture<HttpResponse<String>> cf = httpClient.sendAsync(httpRequest, bh);\n+            try {\n+                cf.get();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                assertTrue(e.getCause() instanceof IOException, \"HTTP\/2 should cancel with an IOException when the Subscription is cancelled.\");\n+            }\n+            assertTrue(cf.isCompletedExceptionally());\n+            assertTrue(cancelled.get());\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        sslContext = new SimpleSSLContext().get();\n+        h2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        h2TestServer.addHandler(new CancelledResponseHandler(), \"\/h2\");\n+        h2TestServerURI = URI.create(\"https:\/\/\" + h2TestServer.serverAuthority() + \"\/h2\");\n+\n+        h2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        h2TestServer.stop();\n+    }\n+\n+    BodyHandler<String> ofString(String expected, AtomicBoolean cancelled) {\n+        return new CancellingHandler(expected, cancelled);\n+    }\n+\n+    static class CancelledResponseHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+\n+            byte[] resp = response.getBytes(StandardCharsets.UTF_8);\n+\n+            t.sendResponseHeaders(200, resp.length);\n+            System.err.println(resp.length);\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+                for (byte b : resp) {\n+                    \/\/ This can be used to verify that varying amounts of the response data are sent.\n+                    System.err.print((char) b);\n+                    os.write(b);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static final String response = \"Lorem ipsum dolor sit amet consectetur adipiscing elit, sed do eiusmod tempor quis\" +\n+            \" nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\";\n+\n+    record CancellingHandler(String expected, AtomicBoolean cancelled) implements BodyHandler<String> {\n+        @Override\n+        public HttpResponse.BodySubscriber<String> apply(HttpResponse.ResponseInfo rinfo) {\n+            assert !cancelled.get();\n+            return new CancellingBodySubscriber(expected, cancelled);\n+        }\n+    }\n+\n+\n+    static class CancellingBodySubscriber implements HttpResponse.BodySubscriber<String> {\n+        private final String expected;\n+        private final CompletableFuture<String> result;\n+        private Flow.Subscription subscription;\n+        final AtomicInteger index = new AtomicInteger();\n+        final AtomicBoolean cancelled;\n+        CancellingBodySubscriber(String expected, AtomicBoolean cancelled) {\n+            this.cancelled = cancelled;\n+            this.expected = expected;\n+            result = new CompletableFuture<>();\n+        }\n+\n+        @Override\n+        public CompletionStage<String> getBody() {\n+            return result;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Flow.Subscription subscription) {\n+            this.subscription = subscription;\n+            subscription.request(1);\n+        }\n+\n+        @Override\n+        public void onNext(List<ByteBuffer> item) {\n+            \/\/if (result.isDone())\n+            \/\/ Max Delay is 180ms as there is 160 characters in response which gives at least 160ms in some test cases and\n+            \/\/ allows a response to complete fully with a lee-way of 20ms in other cases. Otherwise, response body is\n+            \/\/ usually partial. Each character is written by the server handler with a 1ms delay.\n+            delay();\n+            for (ByteBuffer b : item) {\n+                while (b.hasRemaining() && !result.isDone()) {\n+                    int i = index.getAndIncrement();\n+                    char at = expected.charAt(i);\n+                    byte[] data = new byte[b.remaining()];\n+                    b.get(data); \/\/ we know that the server writes 1 char\n+                    String s = new String(data);\n+                    char c = s.charAt(0);\n+                    System.err.print(c);\n+                    if (c != at) {\n+                        Throwable x = new IllegalStateException(\"char at \"\n+                                + i + \" is '\" + c + \"' expected '\"\n+                                + at + \"' for \\\"\" + expected +\"\\\"\");\n+                        out.println(\"unexpected char received, cancelling\");\n+                        subscription.cancel();\n+                        result.completeExceptionally(x);\n+                        return;\n+                    }\n+                }\n+                System.err.println();\n+            }\n+            if (index.get() > 0 && !result.isDone()) {\n+                \/\/ we should complete the result here, but let's\n+                \/\/ see if we get something back...\n+                out.println(\"Cancelling subscription after reading \" + index.get());\n+                cancelled.set(true);\n+                subscription.cancel();\n+                result.completeExceptionally(new CancelException());\n+                return;\n+            }\n+            if (!result.isDone()) {\n+                out.println(\"requesting 1 more\");\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            result.completeExceptionally(throwable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            int len = index.get();\n+            if (len == expected.length()) {\n+                result.complete(expected);\n+            } else {\n+                Throwable x = new IllegalStateException(\"received only \"\n+                        + len + \" chars, expected \" + expected.length()\n+                        + \" for \\\"\" + expected +\"\\\"\");\n+                result.completeExceptionally(x);\n+            }\n+        }\n+    }\n+\n+    static class CancelException extends IOException {\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelledResponse2.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"}]}