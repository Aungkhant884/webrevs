{"files":[{"patch":"@@ -293,0 +293,21 @@\n+void InterpreterMacroAssembler::load_resolved_indy_entry(Register cache, Register index) {\n+  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  assert_different_registers(cache, index, Rtemp);\n+\n+  get_index_at_bcp(index, 1, Rtemp, sizeof(u4));\n+\n+  \/\/ load constant pool cache pointer\n+  ldr(cache, Address(FP, frame::interpreter_frame_cache_offset * wordSize));\n+\n+  \/\/ Get address of invokedynamic array\n+  ldr(cache, Address(cache, in_bytes(ConstantPoolCache::invokedynamic_entries_offset())));\n+\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  \/\/ On ARM32 sizeof(ResolvedIndyEntry) is 12, use mul instead of lsl\n+  mov(Rtemp, sizeof(ResolvedIndyEntry));\n+  mul(index, index, Rtemp);\n+\n+  add(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  add(cache, cache, index);\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-\n@@ -106,0 +105,2 @@\n+  void load_resolved_indy_entry(Register cache, Register index);\n+\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-  __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n@@ -369,4 +368,14 @@\n-  __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n-  __ ldrb(Rtemp, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n-  __ check_stack_top();\n-  __ add(Rstack_top, Rstack_top, AsmOperand(Rtemp, lsl, Interpreter::logStackElementSize));\n+  if (index_size == sizeof(u4)) {\n+    __ load_resolved_indy_entry(Rcache, Rindex);\n+    __ ldrh(Rcache, Address(Rcache, in_bytes(ResolvedIndyEntry::num_parameters_offset())));\n+    __ check_stack_top();\n+    __ add(Rstack_top, Rstack_top, AsmOperand(Rcache, lsl, Interpreter::logStackElementSize));\n+  } else {\n+    \/\/ Pop N words from the stack\n+    __ get_cache_and_index_at_bcp(Rcache, Rindex, 1, index_size);\n+\n+    __ add(Rtemp, Rcache, AsmOperand(Rindex, lsl, LogBytesPerWord));\n+    __ ldrb(Rtemp, Address(Rtemp, ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::flags_offset()));\n+    __ check_stack_top();\n+    __ add(Rstack_top, Rstack_top, AsmOperand(Rtemp, lsl, Interpreter::logStackElementSize));\n+  }\n@@ -376,2 +385,2 @@\n- __ check_and_handle_popframe();\n- __ check_and_handle_earlyret();\n+  __ check_and_handle_popframe();\n+  __ check_and_handle_earlyret();\n@@ -384,1 +393,0 @@\n-\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2611,0 +2611,62 @@\n+\/\/ The rmethod register is input and overwritten to be the adapter method for the\n+\/\/ indy call. Link Register (lr) is set to the return address for the adapter and\n+\/\/ an appendix may be pushed to the stack. Registers r0-r3 are clobbered\n+void TemplateTable::load_invokedynamic_entry(Register method) {\n+  \/\/ setup registers\n+  const Register appendix = R1;\n+  const Register cache = R2_tmp;\n+  const Register index = R3_tmp;\n+  assert_different_registers(method, appendix, cache, index);\n+\n+  __ save_bcp();\n+\n+  Label resolved;\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ ldr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  TemplateTable::volatile_barrier(MacroAssembler::LoadLoad, noreg, true);\n+  \/\/ Compare the method to zero\n+  __ cbnz(method, resolved);\n+\n+  Bytecodes::Code code = bytecode();\n+\n+  \/\/ Call to the interpreter runtime to resolve invokedynamic\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(R1, code); \/\/ this is essentially Bytecodes::_invokedynamic, call_VM requires R1\n+  __ call_VM(noreg, entry, R1);\n+  \/\/ Update registers with resolved info\n+  __ load_resolved_indy_entry(cache, index);\n+  \/\/ Load-acquire the adapter method to match store-release in ResolvedIndyEntry::fill_in()\n+  __ ldr(method, Address(cache, in_bytes(ResolvedIndyEntry::method_offset())));\n+  TemplateTable::volatile_barrier(MacroAssembler::LoadLoad, noreg, true);\n+\n+#ifdef ASSERT\n+  __ cbnz(method, resolved);\n+  __ stop(\"Should be resolved by now\");\n+#endif \/\/ ASSERT\n+  __ bind(resolved);\n+\n+  Label L_no_push;\n+  \/\/ Check if there is an appendix\n+  __ ldrb(index, Address(cache, in_bytes(ResolvedIndyEntry::flags_offset())));\n+  __ tbz(index, ResolvedIndyEntry::has_appendix_shift, L_no_push);\n+  \/\/ Get appendix\n+  __ ldrh(index, Address(cache, in_bytes(ResolvedIndyEntry::resolved_references_index_offset())));\n+  \/\/ Push the appendix as a trailing parameter\n+  \/\/ since the parameter_size includes it.\n+  __ load_resolved_reference_at_index(appendix, index);\n+  __ verify_oop(appendix);\n+  __ push(appendix);  \/\/ push appendix (MethodType, CallSite, etc.)\n+  __ bind(L_no_push);\n+\n+  \/\/ compute return type\n+  __ ldrb(index, Address(cache, in_bytes(ResolvedIndyEntry::result_type_offset())));\n+  \/\/ load return address\n+  \/\/ Return address is loaded into link register(lr) and not pushed to the stack\n+  \/\/ like x86\n+  {\n+    const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);\n+    __ mov_address(Rtemp, table_addr);\n+    __ ldr(LR, Address(Rtemp, index, lsl, Interpreter::logStackElementSize));\n+  }\n+}\n@@ -2619,1 +2681,1 @@\n-                                               bool is_invokedynamic) {\n+                                               bool is_invokedynamic \/*unused*\/) {\n@@ -2642,1 +2704,1 @@\n-  size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));\n+  size_t index_size = sizeof(u2);\n@@ -3568,1 +3630,1 @@\n-  if (is_invokedynamic || is_invokehandle) {\n+  if (is_invokehandle) {\n@@ -3813,1 +3875,1 @@\n-  prepare_invoke(byte_no, R5_method, Rcallsite);\n+  load_invokedynamic_entry(R5_method);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":66,"deletions":4,"binary":false,"changes":70,"status":"modified"}]}