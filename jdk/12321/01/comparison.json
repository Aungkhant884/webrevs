{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  assert(inst_mark() != NULL, \"must be inside InstructionMark\");\n+  assert(inst_mark() != nullptr, \"must be inside InstructionMark\");\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -68,1 +68,1 @@\n-  assert(info != NULL, \"must have info\");\n+  assert(info != nullptr, \"must have info\");\n@@ -74,1 +74,1 @@\n-  assert(info != NULL, \"must have info\");\n+  assert(info != nullptr, \"must have info\");\n@@ -357,1 +357,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -125,1 +125,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -135,1 +135,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -281,1 +281,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -331,1 +331,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -339,1 +339,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -382,1 +382,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -430,1 +430,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -458,1 +458,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -469,1 +469,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -490,1 +490,1 @@\n-  if (info->exception_handlers() != NULL) {\n+  if (info->exception_handlers() != nullptr) {\n@@ -512,1 +512,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -607,1 +607,1 @@\n-        const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);\n+        const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, nullptr);\n@@ -614,1 +614,1 @@\n-      const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);\n+      const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, nullptr);\n@@ -778,1 +778,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -850,1 +850,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -893,1 +893,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -946,1 +946,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1056,3 +1056,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n@@ -1062,1 +1062,1 @@\n-    if (op->info() != NULL) add_debug_info_for_branch(op->info());\n+    if (op->info() != nullptr) add_debug_info_for_branch(op->info());\n@@ -1291,1 +1291,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -1294,1 +1294,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -1296,1 +1296,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -1378,1 +1378,1 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1431,1 +1431,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -1434,1 +1434,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -1436,1 +1436,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -1469,1 +1469,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1623,1 +1623,1 @@\n-    const2reg(opr1, tmp, lir_patch_none, NULL);\n+    const2reg(opr1, tmp, lir_patch_none, nullptr);\n@@ -1633,1 +1633,1 @@\n-    const2reg(opr2, tmp, lir_patch_none, NULL);\n+    const2reg(opr2, tmp, lir_patch_none, nullptr);\n@@ -1644,1 +1644,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -2034,1 +2034,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -2045,1 +2045,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -2056,1 +2056,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -2227,1 +2227,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -2231,1 +2231,1 @@\n-  if (default_type == NULL \/\/ || basic_type == T_OBJECT\n+  if (default_type == nullptr \/\/ || basic_type == T_OBJECT\n@@ -2243,1 +2243,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -2283,1 +2283,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -2293,1 +2293,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -2378,1 +2378,1 @@\n-      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, nullptr);\n@@ -2390,1 +2390,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2560,1 +2560,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2569,1 +2569,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2587,1 +2587,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2606,1 +2606,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2608,1 +2608,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2621,1 +2621,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2646,1 +2646,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2713,1 +2713,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -2749,1 +2749,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -2760,2 +2760,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -2790,1 +2790,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -2811,1 +2811,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -2840,1 +2840,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -2904,1 +2904,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":59,"deletions":59,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = NULL);\n+  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -112,1 +112,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -114,1 +114,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -123,1 +123,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -125,1 +125,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -127,1 +127,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -318,1 +318,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -469,1 +469,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -515,1 +515,1 @@\n-      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -517,1 +517,1 @@\n-      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -550,1 +550,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -788,1 +788,1 @@\n-  CallingConvention* cc = NULL;\n+  CallingConvention* cc = nullptr;\n@@ -810,1 +810,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -817,1 +817,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -824,1 +824,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -831,1 +831,1 @@\n-      if (StubRoutines::dpow() != NULL) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -838,1 +838,1 @@\n-      if (StubRoutines::dsin() != NULL) {\n+      if (StubRoutines::dsin() != nullptr) {\n@@ -845,1 +845,1 @@\n-      if (StubRoutines::dcos() != NULL) {\n+      if (StubRoutines::dcos() != nullptr) {\n@@ -852,1 +852,1 @@\n-      if (StubRoutines::dtan() != NULL) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -1149,1 +1149,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1182,1 +1182,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1189,1 +1189,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1236,1 +1236,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1251,1 +1251,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1254,1 +1254,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1277,1 +1277,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/NULL);\n+  cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/nullptr);\n@@ -113,1 +113,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n+  \/\/ location (null in the displaced hdr location indicates recursive locking)\n@@ -132,1 +132,1 @@\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n+  \/\/ if the loaded hdr is null we had recursive locking\n@@ -297,1 +297,1 @@\n-  \/\/ explicit NULL check not needed since load from [klass_offset] causes a trap\n+  \/\/ explicit null check not needed since load from [klass_offset] causes a trap\n@@ -314,1 +314,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,1 +372,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n@@ -545,1 +545,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -619,2 +619,2 @@\n-  OopMapSet* oop_maps = NULL;\n-  OopMap* oop_map = NULL;\n+  OopMapSet* oop_maps = nullptr;\n+  OopMap* oop_map = nullptr;\n@@ -837,1 +837,1 @@\n-        __ check_klass_subtype_slow_path(r4, r0, r2, r5, NULL, &miss);\n+        __ check_klass_subtype_slow_path(r4, r0, r2, r5, nullptr, &miss);\n@@ -907,1 +907,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -994,1 +994,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    RuntimeAddress stub = NULL;\n+    RuntimeAddress stub = nullptr;\n@@ -293,1 +293,1 @@\n-      assert(stub.target() != NULL, \"string_indexof_linear_ll stub has not been generated\");\n+      assert(stub.target() != nullptr, \"string_indexof_linear_ll stub has not been generated\");\n@@ -296,1 +296,1 @@\n-       assert(stub.target() != NULL, \"string_indexof_linear_ul stub has not been generated\");\n+       assert(stub.target() != nullptr, \"string_indexof_linear_ul stub has not been generated\");\n@@ -299,1 +299,1 @@\n-      assert(stub.target() != NULL, \"string_indexof_linear_uu stub has not been generated\");\n+      assert(stub.target() != nullptr, \"string_indexof_linear_uu stub has not been generated\");\n@@ -847,1 +847,1 @@\n-    RuntimeAddress stub = NULL;\n+    RuntimeAddress stub = nullptr;\n@@ -864,1 +864,1 @@\n-    assert(stub.target() != NULL, \"compare_long_string stub has not been generated\");\n+    assert(stub.target() != nullptr, \"compare_long_string stub has not been generated\");\n@@ -2043,1 +2043,1 @@\n-  if (ciEnv::current()->task() != NULL) {\n+  if (ciEnv::current()->task() != nullptr) {\n@@ -2045,1 +2045,1 @@\n-    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+    if (phase_output != nullptr && phase_output->in_scratch_emit_size()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == NULL) {\n+      if (cb->stubs()->maybe_expand_to_ensure_remaining(NativeInstruction::instruction_size) && cb->blob() == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -57,2 +57,2 @@\n-  if (base == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -92,1 +92,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -121,1 +121,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -142,1 +142,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  \/\/ at(frame::interpreter_frame_last_sp_offset) can be NULL at safepoint preempts\n+  \/\/ at(frame::interpreter_frame_last_sp_offset) can be null at safepoint preempts\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL) {\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/disassembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-     _oop_maps(NULL) {\n+     _oop_maps(nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -125,4 +125,4 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n+    intptr_t* sender_sp = nullptr;\n+    intptr_t* sender_unextended_sp = nullptr;\n+    address   sender_pc = nullptr;\n+    intptr_t* saved_fp =  nullptr;\n@@ -192,1 +192,1 @@\n-    if (sender_pc == NULL ||  sender_blob == NULL) {\n+    if (sender_pc == nullptr ||  sender_blob == nullptr) {\n@@ -225,1 +225,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -267,1 +267,1 @@\n-  if ( (address) this->fp()[return_addr_offset] == NULL) return false;\n+  if ( (address) this->fp()[return_addr_offset] == nullptr) return false;\n@@ -301,1 +301,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -367,1 +367,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -395,1 +395,1 @@\n-  return jfa->last_Java_sp() == NULL;\n+  return jfa->last_Java_sp() == nullptr;\n@@ -399,1 +399,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -444,1 +444,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -446,1 +446,1 @@\n-    if (sender_cm != NULL) {\n+    if (sender_cm != nullptr) {\n@@ -571,1 +571,1 @@\n-        obj = (obj_p == NULL) ? (oop)NULL : *obj_p;\n+        obj = (obj_p == nullptr) ? (oop)nullptr : *obj_p;\n@@ -639,1 +639,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -719,1 +719,1 @@\n-    if (cb != NULL) {\n+    if (cb != nullptr) {\n@@ -785,1 +785,1 @@\n-  if (last_Java_sp() == NULL) return;\n+  if (last_Java_sp() == nullptr) return;\n@@ -788,2 +788,2 @@\n-  vmassert(last_Java_sp() != NULL, \"not called from Java code?\");\n-  vmassert(last_Java_pc() == NULL, \"already walkable\");\n+  vmassert(last_Java_sp() != nullptr, \"not called from Java code?\");\n+  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -42,5 +42,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -63,1 +63,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -67,1 +67,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -76,1 +76,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -79,1 +79,1 @@\n-    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n@@ -103,1 +103,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -105,2 +105,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n@@ -127,1 +127,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -147,2 +147,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -174,1 +174,1 @@\n-  \/\/ assert(_pc != NULL, \"no pc?\");\n+  \/\/ assert(_pc != nullptr, \"no pc?\");\n@@ -180,1 +180,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -201,1 +201,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -206,1 +206,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -213,1 +213,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -222,1 +222,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -246,1 +246,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n@@ -299,1 +299,1 @@\n-  if (last_sp == NULL) {\n+  if (last_sp == nullptr) {\n@@ -339,1 +339,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -345,1 +345,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -359,2 +359,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -362,1 +362,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -369,1 +369,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -398,1 +398,1 @@\n-  if (_cb != NULL) return sender_for_compiled_frame(map);\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -431,1 +431,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -437,1 +437,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -213,1 +213,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -217,1 +217,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -237,1 +237,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -430,1 +430,1 @@\n-  \/\/ At this point we know new_value is non-NULL and the new_value crosses regions.\n+  \/\/ At this point we know new_value is non-null and the new_value crosses regions.\n@@ -457,1 +457,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -203,1 +203,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -208,2 +208,2 @@\n-  Assembler::Condition condition = slow_path == NULL ? Assembler::EQ : Assembler::NE;\n-  Label& barrier_target = slow_path == NULL ? skip_barrier : *slow_path;\n+  Assembler::Condition condition = slow_path == nullptr ? Assembler::EQ : Assembler::NE;\n+  Label& barrier_target = slow_path == nullptr ? skip_barrier : *slow_path;\n@@ -255,1 +255,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -272,1 +272,1 @@\n-  if (bs == NULL) {\n+  if (bs == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -450,1 +450,1 @@\n-\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals NULL\n+\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals null\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs past to check cast\n+define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap nulls past to check cast\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  \/\/ assert(cached_value == NULL || cached_oop->is_perm(), \"must be perm oop\");\n+  \/\/ assert(cached_value == nullptr || cached_oop->is_perm(), \"must be perm oop\");\n","filename":"src\/hotspot\/cpu\/aarch64\/icBuffer_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  *flush_icache_stub = (ICache::flush_icache_stub_t)NULL;\n+  *flush_icache_stub = (ICache::flush_icache_stub_t)nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-    cbz(rscratch1, L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    cbz(rscratch1, L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -772,1 +772,1 @@\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -871,1 +871,1 @@\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -899,1 +899,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1290,1 +1290,1 @@\n-  \/\/ observed the item[start_row] is NULL.\n+  \/\/ observed the item[start_row] is null.\n@@ -1306,1 +1306,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1309,1 +1309,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1312,1 +1312,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n@@ -1586,1 +1586,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n@@ -1614,1 +1614,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    \/\/ NULL last_sp until next java call\n+    \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-    intptr_t value = *addr == 0 ? NULL : (intptr_t)addr;\n+    intptr_t value = *addr == 0 ? (intptr_t)nullptr : (intptr_t)addr;\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -45,2 +45,2 @@\n-    _last_Java_fp = NULL;\n-    _last_Java_pc = NULL;\n+    _last_Java_fp = nullptr;\n+    _last_Java_pc = nullptr;\n@@ -54,1 +54,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -58,1 +58,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n@@ -67,1 +67,1 @@\n-  bool walkable(void)                            { return _last_Java_sp != NULL && _last_Java_pc != NULL; }\n+  bool walkable(void)                            { return _last_Java_sp != nullptr && _last_Java_pc != nullptr; }\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-      name = NULL;  \/\/ unreachable\n+      name = nullptr;  \/\/ unreachable\n@@ -199,1 +199,1 @@\n-      slow_case_addr = NULL;  \/\/ unreachable\n+      slow_case_addr = nullptr;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -651,1 +651,1 @@\n-  assert(last_java_pc != NULL, \"must provide a valid PC\");\n+  assert(last_java_pc != nullptr, \"must provide a valid PC\");\n@@ -689,1 +689,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -708,1 +708,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -866,1 +866,1 @@\n-    assert(CodeCache::find_blob(target) != NULL &&\n+    assert(CodeCache::find_blob(target) != nullptr &&\n@@ -898,1 +898,1 @@\n-        if (stub == NULL) {\n+        if (stub == nullptr) {\n@@ -900,1 +900,1 @@\n-          return NULL; \/\/ CodeCache is full\n+          return nullptr; \/\/ CodeCache is full\n@@ -931,2 +931,2 @@\n-  if (stub == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -967,1 +967,1 @@\n-  mov_metadata(rmethod, (Metadata*)NULL);\n+  mov_metadata(rmethod, (Metadata*)nullptr);\n@@ -1158,1 +1158,1 @@\n-  \/\/ for (scan = klass->itable(); scan->interface() != NULL; scan += scan_step) {\n+  \/\/ for (scan = klass->itable(); scan->interface() != nullptr; scan += scan_step) {\n@@ -1217,2 +1217,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, nullptr);\n@@ -1241,4 +1241,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -1363,3 +1363,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -1436,1 +1436,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -1440,1 +1440,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -1442,1 +1442,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -1469,1 +1469,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -1501,1 +1501,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -1633,1 +1633,1 @@\n-    \/\/ provoke OS NULL exception if reg = NULL by\n+    \/\/ provoke OS null exception if reg = null by\n@@ -1639,1 +1639,1 @@\n-    \/\/ will provoke OS NULL exception if reg = NULL\n+    \/\/ will provoke OS null exception if reg = null\n@@ -1957,1 +1957,1 @@\n-  if (last != NULL && nativeInstruction_at(last)->is_Membar() && prev == last) {\n+  if (last != nullptr && nativeInstruction_at(last)->is_Membar() && prev == last) {\n@@ -2442,2 +2442,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  if (!UseCompressedOops || Universe::ptr_base() == NULL) {\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  if (!UseCompressedOops || Universe::ptr_base() == nullptr) {\n@@ -2464,1 +2464,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n@@ -2495,1 +2495,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n@@ -2521,1 +2521,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -3090,1 +3090,1 @@\n-  if (last == NULL || !nativeInstruction_at(last)->is_Imm_LdSt()) {\n+  if (last == nullptr || !nativeInstruction_at(last)->is_Imm_LdSt()) {\n@@ -4107,1 +4107,1 @@\n-    if (CompressedKlassPointers::base() == NULL) {\n+    if (CompressedKlassPointers::base() == nullptr) {\n@@ -4147,1 +4147,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -4180,1 +4180,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -4202,1 +4202,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -4219,1 +4219,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -4236,1 +4236,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -4242,1 +4242,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -4248,1 +4248,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -4254,1 +4254,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -4260,1 +4260,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -4266,1 +4266,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -4286,1 +4286,1 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n+  if (CompressedKlassPointers::base() == nullptr) {\n@@ -4394,2 +4394,2 @@\n-    assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-    assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+    assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+    assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4409,1 +4409,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4462,1 +4462,1 @@\n-\/\/ Used for storing NULLs.\n+\/\/ Used for storing nulls.\n@@ -4468,1 +4468,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs a Recorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs a Recorder\");\n@@ -4477,1 +4477,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -4502,1 +4502,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -4515,1 +4515,1 @@\n-    assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+    assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4729,1 +4729,1 @@\n-    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    assert(count_pos.target() != nullptr, \"count_positives stub has not been generated\");\n@@ -4731,1 +4731,1 @@\n-    if (tpc1 == NULL) {\n+    if (tpc1 == nullptr) {\n@@ -4734,1 +4734,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4740,1 +4740,1 @@\n-    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    assert(count_pos_long.target() != nullptr, \"count_positives_long stub has not been generated\");\n@@ -4742,1 +4742,1 @@\n-    if (tpc2 == NULL) {\n+    if (tpc2 == nullptr) {\n@@ -4745,1 +4745,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4792,1 +4792,1 @@\n-    \/\/ if (a1 == null || a2 == null)\n+    \/\/ if (a1 == nullptr || a2 == nullptr)\n@@ -4923,1 +4923,1 @@\n-    assert(stub.target() != NULL, \"array_equals_long stub has not been generated\");\n+    assert(stub.target() != nullptr, \"array_equals_long stub has not been generated\");\n@@ -4925,1 +4925,1 @@\n-    if (tpc == NULL) {\n+    if (tpc == nullptr) {\n@@ -4928,1 +4928,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5075,1 +5075,1 @@\n-  assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+  assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -5082,1 +5082,1 @@\n-    assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+    assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -5093,1 +5093,1 @@\n-      if (tpc == NULL) {\n+      if (tpc == nullptr) {\n@@ -5095,1 +5095,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5444,1 +5444,1 @@\n-      assert(stub.target() != NULL, \"large_byte_array_inflate stub has not been generated\");\n+      assert(stub.target() != nullptr, \"large_byte_array_inflate stub has not been generated\");\n@@ -5446,1 +5446,1 @@\n-      if (tpc == NULL) {\n+      if (tpc == nullptr) {\n@@ -5449,1 +5449,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5836,1 +5836,1 @@\n-  \/\/ See if oop is NULL if it is we need no handle\n+  \/\/ See if oop is null if it is we need no handle\n@@ -5849,1 +5849,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n@@ -5855,1 +5855,1 @@\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-null\n@@ -5882,1 +5882,1 @@\n-    \/\/ Store oop in handle area, may be NULL\n+    \/\/ Store oop in handle area, may be null\n@@ -5890,1 +5890,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":75,"deletions":75,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    Label *retaddr = NULL\n+    Label *retaddr = nullptr\n@@ -598,1 +598,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -600,1 +600,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -623,1 +623,1 @@\n-  static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {\n+  static void pd_patch_instruction(address branch, address target, const char* file = nullptr, int line = 0) {\n@@ -866,1 +866,1 @@\n-  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ Used for storing null. All other oop constants should be\n@@ -873,1 +873,1 @@\n-  \/\/ converting a zero (like NULL) into a Register by giving\n+  \/\/ converting a zero (like null) into a Register by giving\n@@ -945,1 +945,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -978,2 +978,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n@@ -1182,1 +1182,1 @@\n-  \/\/ Return: the call PC or NULL if CodeCache is full.\n+  \/\/ Return: the call PC or null if CodeCache is full.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-    return CompressedOops::base() == NULL;\n+    return CompressedOops::base() == nullptr;\n@@ -102,1 +102,1 @@\n-    return CompressedKlassPointers::base() == NULL;\n+    return CompressedKlassPointers::base() == nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -185,1 +185,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-  if (trampoline_stub_addr != NULL) {\n+  if (trampoline_stub_addr != nullptr) {\n@@ -206,1 +206,1 @@\n-    assert (trampoline_stub_addr != NULL, \"we need a trampoline\");\n+    assert (trampoline_stub_addr != nullptr, \"we need a trampoline\");\n@@ -217,1 +217,1 @@\n-  assert(code != NULL, \"Could not find the containing code blob\");\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n@@ -229,1 +229,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -270,1 +270,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -530,1 +530,1 @@\n-  address stub = NULL;\n+  address stub = nullptr;\n@@ -537,1 +537,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,1 +290,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -585,1 +585,1 @@\n-  address destination(nmethod* nm = NULL) const;\n+  address destination(nmethod* nm = nullptr) const;\n@@ -705,1 +705,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -727,1 +727,1 @@\n-    assert(instr != NULL, \"\");\n+    assert(instr != nullptr, \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    if (base_location != NULL) {\n+    if (base_location != nullptr) {\n@@ -43,1 +43,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg reg) const { return nullptr; }\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n@@ -581,1 +581,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != nullptr)\n@@ -585,1 +585,1 @@\n-    if (StubRoutines::code1() != NULL)\n+    if (StubRoutines::code1() != nullptr)\n@@ -589,1 +589,1 @@\n-    if (StubRoutines::code2() != NULL)\n+    if (StubRoutines::code2() != nullptr)\n@@ -771,1 +771,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -802,1 +802,1 @@\n-  assert(regs2 == NULL, \"not needed on AArch64\");\n+  assert(regs2 == nullptr, \"not needed on AArch64\");\n@@ -1420,1 +1420,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -1423,1 +1423,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1440,1 +1440,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1455,1 +1455,1 @@\n-  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1458,1 +1458,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1580,1 +1580,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n@@ -1786,1 +1786,1 @@\n-      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -2177,1 +2177,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2383,1 +2383,1 @@\n-  \/\/ QQQ this is useless it was NULL above\n+  \/\/ QQQ this is useless it was null above\n@@ -2763,1 +2763,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2879,1 +2879,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2891,1 +2891,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL,\n+    assert(StubRoutines::_call_stub_return_address != nullptr,\n@@ -569,1 +569,1 @@\n-    __ cbz(r0, exit); \/\/ if obj is NULL it is OK\n+    __ cbz(r0, exit); \/\/ if obj is null it is OK\n@@ -593,1 +593,1 @@\n-    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n+    __ cbz(r0, error);      \/\/ if klass is null it is broken\n@@ -1401,1 +1401,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1467,1 +1467,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1745,1 +1745,1 @@\n-    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n+    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, nullptr,\n@@ -1747,1 +1747,1 @@\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n@@ -1815,1 +1815,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -2047,1 +2047,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2053,1 +2053,1 @@\n-    \/\/  if (src == NULL) return -1;\n+    \/\/  if (src == nullptr) return -1;\n@@ -2059,1 +2059,1 @@\n-    \/\/  if (dst == NULL) return -1;\n+    \/\/  if (dst == nullptr) return -1;\n@@ -2076,1 +2076,1 @@\n-    \/\/  assert(src->klass() != NULL);\n+    \/\/  assert(src->klass() != nullptr);\n@@ -2080,1 +2080,1 @@\n-      __ cbnz(scratch_src_klass, L2);   \/\/ it is broken if klass is NULL\n+      __ cbnz(scratch_src_klass, L2);   \/\/ it is broken if klass is null\n@@ -2482,1 +2482,1 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, nullptr,\n@@ -2494,1 +2494,1 @@\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n@@ -2537,1 +2537,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, NULL, \"arrayof_oop_arraycopy_uninit\",\n+        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n@@ -2547,1 +2547,1 @@\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n@@ -8010,1 +8010,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -8125,1 +8125,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-address StubRoutines::aarch64::_get_previous_sp_entry = NULL;\n+address StubRoutines::aarch64::_get_previous_sp_entry = nullptr;\n@@ -38,22 +38,22 @@\n-address StubRoutines::aarch64::_f2i_fixup = NULL;\n-address StubRoutines::aarch64::_f2l_fixup = NULL;\n-address StubRoutines::aarch64::_d2i_fixup = NULL;\n-address StubRoutines::aarch64::_d2l_fixup = NULL;\n-address StubRoutines::aarch64::_vector_iota_indices = NULL;\n-address StubRoutines::aarch64::_float_sign_mask = NULL;\n-address StubRoutines::aarch64::_float_sign_flip = NULL;\n-address StubRoutines::aarch64::_double_sign_mask = NULL;\n-address StubRoutines::aarch64::_double_sign_flip = NULL;\n-address StubRoutines::aarch64::_zero_blocks = NULL;\n-address StubRoutines::aarch64::_count_positives = NULL;\n-address StubRoutines::aarch64::_count_positives_long = NULL;\n-address StubRoutines::aarch64::_large_array_equals = NULL;\n-address StubRoutines::aarch64::_compare_long_string_LL = NULL;\n-address StubRoutines::aarch64::_compare_long_string_UU = NULL;\n-address StubRoutines::aarch64::_compare_long_string_LU = NULL;\n-address StubRoutines::aarch64::_compare_long_string_UL = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_ll = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_uu = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_ul = NULL;\n-address StubRoutines::aarch64::_large_byte_array_inflate = NULL;\n-address StubRoutines::aarch64::_method_entry_barrier = NULL;\n+address StubRoutines::aarch64::_f2i_fixup = nullptr;\n+address StubRoutines::aarch64::_f2l_fixup = nullptr;\n+address StubRoutines::aarch64::_d2i_fixup = nullptr;\n+address StubRoutines::aarch64::_d2l_fixup = nullptr;\n+address StubRoutines::aarch64::_vector_iota_indices = nullptr;\n+address StubRoutines::aarch64::_float_sign_mask = nullptr;\n+address StubRoutines::aarch64::_float_sign_flip = nullptr;\n+address StubRoutines::aarch64::_double_sign_mask = nullptr;\n+address StubRoutines::aarch64::_double_sign_flip = nullptr;\n+address StubRoutines::aarch64::_zero_blocks = nullptr;\n+address StubRoutines::aarch64::_count_positives = nullptr;\n+address StubRoutines::aarch64::_count_positives_long = nullptr;\n+address StubRoutines::aarch64::_large_array_equals = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_LL = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_UU = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_LU = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_UL = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_ll = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_uu = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_ul = nullptr;\n+address StubRoutines::aarch64::_large_byte_array_inflate = nullptr;\n+address StubRoutines::aarch64::_method_entry_barrier = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  \/\/        bcp (NULL)\n+  \/\/        bcp (null)\n@@ -149,1 +149,1 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n+  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n@@ -167,1 +167,1 @@\n-  address entry_point = NULL;\n+  address entry_point = nullptr;\n@@ -247,1 +247,1 @@\n-    if (StubRoutines::dsin() == NULL) {\n+    if (StubRoutines::dsin() == nullptr) {\n@@ -254,1 +254,1 @@\n-    if (StubRoutines::dcos() == NULL) {\n+    if (StubRoutines::dcos() == nullptr) {\n@@ -261,1 +261,1 @@\n-    if (StubRoutines::dtan() == NULL) {\n+    if (StubRoutines::dtan() == nullptr) {\n@@ -268,1 +268,1 @@\n-    if (StubRoutines::dlog() == NULL) {\n+    if (StubRoutines::dlog() == nullptr) {\n@@ -275,1 +275,1 @@\n-    if (StubRoutines::dlog10() == NULL) {\n+    if (StubRoutines::dlog10() == nullptr) {\n@@ -282,1 +282,1 @@\n-    if (StubRoutines::dexp() == NULL) {\n+    if (StubRoutines::dexp() == nullptr) {\n@@ -289,1 +289,1 @@\n-    if (StubRoutines::dpow() == NULL) {\n+    if (StubRoutines::dpow() == nullptr) {\n@@ -297,1 +297,1 @@\n-    fn = NULL;  \/\/ unreachable\n+    fn = nullptr;  \/\/ unreachable\n@@ -313,1 +313,1 @@\n-  \/\/  pop return address, reset last_sp to NULL\n+  \/\/  pop return address, reset last_sp to null\n@@ -398,1 +398,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -415,1 +415,1 @@\n-    \/\/ kind of lame ExternalAddress can't take NULL because\n+    \/\/ kind of lame ExternalAddress can't take null because\n@@ -417,1 +417,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -436,1 +436,1 @@\n-  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/ and null it as marker that esp is now tos until next java call\n@@ -483,1 +483,1 @@\n-  \/\/ NULL last_sp until next java call\n+  \/\/ null last_sp until next java call\n@@ -522,1 +522,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -615,2 +615,2 @@\n-  \/\/ (NULL bcp).  We pass zero for it.  The call returns the address\n-  \/\/ of the verified entry point for the method or NULL if the\n+  \/\/ (null bcp).  We pass zero for it.  The call returns the address\n+  \/\/ of the verified entry point for the method or null if the\n@@ -708,1 +708,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -758,1 +758,1 @@\n-      __ stop(\"synchronization object is NULL\");\n+      __ stop(\"synchronization object is null\");\n@@ -896,1 +896,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 != null\n@@ -963,1 +963,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1018,1 +1018,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1059,1 +1059,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1856,1 +1856,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -2023,1 +2023,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,2 +142,2 @@\n-\/\/ Store an oop (or NULL) at the Address described by obj.\n-\/\/ If val == noreg this means store a NULL\n+\/\/ Store an oop (or null) at the Address described by obj.\n+\/\/ If val == noreg this means store a null\n@@ -417,1 +417,1 @@\n-    __ mov(result, 0);  \/\/ NULL object reference\n+    __ mov(result, 0);  \/\/ null object reference\n@@ -1114,1 +1114,1 @@\n-  \/\/ do array store check - check for NULL value first\n+  \/\/ do array store check - check for null value first\n@@ -1142,1 +1142,1 @@\n-  \/\/ Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]\n+  \/\/ Have a null in r0, r3=array, r2=index.  Store null at ary[idx]\n@@ -1146,1 +1146,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -1875,1 +1875,1 @@\n-    \/\/ r0: osr nmethod (osr ok) or NULL (osr not possible)\n+    \/\/ r0: osr nmethod (osr ok) or null (osr not possible)\n@@ -2291,1 +2291,1 @@\n-    __ clinit_barrier(temp, rscratch1, NULL, &clinit_barrier_slow);\n+    __ clinit_barrier(temp, rscratch1, nullptr, &clinit_barrier_slow);\n@@ -2381,1 +2381,1 @@\n-      __ mov(c_rarg1, zr); \/\/ NULL object reference\n+      __ mov(c_rarg1, zr); \/\/ null object reference\n@@ -2386,1 +2386,1 @@\n-    \/\/ c_rarg1: object pointer or NULL\n+    \/\/ c_rarg1: object pointer or null\n@@ -2634,1 +2634,1 @@\n-    \/\/ c_rarg1: object pointer set up above (NULL if static)\n+    \/\/ c_rarg1: object pointer set up above (null if static)\n@@ -3635,1 +3635,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3688,1 +3688,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3697,2 +3697,2 @@\n-  \/\/ r0 = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ r0 = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ r0 = 0: obj == nullptr or  obj is not an instanceof the specified klass\n+  \/\/ r0 = 1: obj != nullptr and obj is     an instanceof the specified klass\n@@ -3758,1 +3758,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n@@ -3770,1 +3770,1 @@\n-  __ mov(c_rarg1, zr); \/\/ points to free slot or NULL\n+  __ mov(c_rarg1, zr); \/\/ points to free slot or null\n@@ -3861,1 +3861,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,3 +54,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -121,1 +121,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -144,3 +144,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -244,1 +244,1 @@\n-  assert(SharedRuntime::get_handle_wrong_method_stub() != NULL, \"check initialization order\");\n+  assert(SharedRuntime::get_handle_wrong_method_stub() != nullptr, \"check initialization order\");\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}