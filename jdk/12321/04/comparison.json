{"files":[{"patch":"@@ -105,1 +105,1 @@\n-  assert(inst_mark() != NULL, \"must be inside InstructionMark\");\n+  assert(inst_mark() != nullptr, \"must be inside InstructionMark\");\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -337,1 +337,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -125,1 +125,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -135,1 +135,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -281,1 +281,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -331,1 +331,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -339,1 +339,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -382,1 +382,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -430,1 +430,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -458,1 +458,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -469,1 +469,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -490,1 +490,1 @@\n-  if (info->exception_handlers() != NULL) {\n+  if (info->exception_handlers() != nullptr) {\n@@ -512,1 +512,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -607,1 +607,1 @@\n-        const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);\n+        const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, nullptr);\n@@ -614,1 +614,1 @@\n-      const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);\n+      const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, nullptr);\n@@ -778,1 +778,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -850,1 +850,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -893,1 +893,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -946,1 +946,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1056,3 +1056,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n@@ -1062,1 +1062,1 @@\n-    if (op->info() != NULL) add_debug_info_for_branch(op->info());\n+    if (op->info() != nullptr) add_debug_info_for_branch(op->info());\n@@ -1291,1 +1291,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -1294,1 +1294,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -1296,1 +1296,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -1378,1 +1378,1 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1431,1 +1431,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -1434,1 +1434,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -1436,1 +1436,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -1469,1 +1469,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1623,1 +1623,1 @@\n-    const2reg(opr1, tmp, lir_patch_none, NULL);\n+    const2reg(opr1, tmp, lir_patch_none, nullptr);\n@@ -1633,1 +1633,1 @@\n-    const2reg(opr2, tmp, lir_patch_none, NULL);\n+    const2reg(opr2, tmp, lir_patch_none, nullptr);\n@@ -1644,1 +1644,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -2036,1 +2036,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -2047,1 +2047,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -2058,1 +2058,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -2229,1 +2229,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -2233,1 +2233,1 @@\n-  if (default_type == NULL \/\/ || basic_type == T_OBJECT\n+  if (default_type == nullptr \/\/ || basic_type == T_OBJECT\n@@ -2245,1 +2245,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -2285,1 +2285,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -2295,1 +2295,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -2380,1 +2380,1 @@\n-      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, nullptr);\n@@ -2392,1 +2392,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2562,1 +2562,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2571,1 +2571,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2589,1 +2589,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2608,1 +2608,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2610,1 +2610,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2623,1 +2623,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2648,1 +2648,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2715,1 +2715,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -2751,1 +2751,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -2762,2 +2762,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -2792,1 +2792,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -2813,1 +2813,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -2842,1 +2842,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -2906,1 +2906,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = NULL);\n+  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -112,1 +112,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -114,1 +114,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -123,1 +123,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -125,1 +125,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -127,1 +127,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -318,1 +318,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -469,1 +469,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -515,1 +515,1 @@\n-      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -517,1 +517,1 @@\n-      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -550,1 +550,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -803,1 +803,1 @@\n-  CallingConvention* cc = NULL;\n+  CallingConvention* cc = nullptr;\n@@ -825,1 +825,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -832,1 +832,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -839,1 +839,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -846,1 +846,1 @@\n-      if (StubRoutines::dpow() != NULL) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -853,1 +853,1 @@\n-      if (StubRoutines::dsin() != NULL) {\n+      if (StubRoutines::dsin() != nullptr) {\n@@ -860,1 +860,1 @@\n-      if (StubRoutines::dcos() != NULL) {\n+      if (StubRoutines::dcos() != nullptr) {\n@@ -867,1 +867,1 @@\n-      if (StubRoutines::dtan() != NULL) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -1164,1 +1164,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1197,1 +1197,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1204,1 +1204,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1251,1 +1251,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1266,1 +1266,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1269,1 +1269,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1292,1 +1292,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/NULL);\n+  cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/nullptr);\n@@ -113,1 +113,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n+  \/\/ location (null in the displaced hdr location indicates recursive locking)\n@@ -132,1 +132,1 @@\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n+  \/\/ if the loaded hdr is null we had recursive locking\n@@ -297,1 +297,1 @@\n-  \/\/ explicit NULL check not needed since load from [klass_offset] causes a trap\n+  \/\/ explicit null check not needed since load from [klass_offset] causes a trap\n@@ -314,1 +314,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,1 +372,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n@@ -545,1 +545,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -619,2 +619,2 @@\n-  OopMapSet* oop_maps = NULL;\n-  OopMap* oop_map = NULL;\n+  OopMapSet* oop_maps = nullptr;\n+  OopMap* oop_map = nullptr;\n@@ -837,1 +837,1 @@\n-        __ check_klass_subtype_slow_path(r4, r0, r2, r5, NULL, &miss);\n+        __ check_klass_subtype_slow_path(r4, r0, r2, r5, nullptr, &miss);\n@@ -907,1 +907,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -994,1 +994,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    RuntimeAddress stub = NULL;\n+    RuntimeAddress stub = nullptr;\n@@ -293,1 +293,1 @@\n-      assert(stub.target() != NULL, \"string_indexof_linear_ll stub has not been generated\");\n+      assert(stub.target() != nullptr, \"string_indexof_linear_ll stub has not been generated\");\n@@ -296,1 +296,1 @@\n-       assert(stub.target() != NULL, \"string_indexof_linear_ul stub has not been generated\");\n+       assert(stub.target() != nullptr, \"string_indexof_linear_ul stub has not been generated\");\n@@ -299,1 +299,1 @@\n-      assert(stub.target() != NULL, \"string_indexof_linear_uu stub has not been generated\");\n+      assert(stub.target() != nullptr, \"string_indexof_linear_uu stub has not been generated\");\n@@ -847,1 +847,1 @@\n-    RuntimeAddress stub = NULL;\n+    RuntimeAddress stub = nullptr;\n@@ -864,1 +864,1 @@\n-    assert(stub.target() != NULL, \"compare_long_string stub has not been generated\");\n+    assert(stub.target() != nullptr, \"compare_long_string stub has not been generated\");\n@@ -2052,1 +2052,1 @@\n-  if (ciEnv::current()->task() != NULL) {\n+  if (ciEnv::current()->task() != nullptr) {\n@@ -2054,1 +2054,1 @@\n-    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+    if (phase_output != nullptr && phase_output->in_scratch_emit_size()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == NULL) {\n+  if (cb->stubs()->maybe_expand_to_ensure_remaining(total_requested_size) && cb->blob() == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBuffer_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -57,2 +57,2 @@\n-  if (base == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -91,1 +91,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -120,1 +120,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -141,1 +141,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  \/\/ at(frame::interpreter_frame_last_sp_offset) can be NULL at safepoint preempts\n+  \/\/ at(frame::interpreter_frame_last_sp_offset) can be null at safepoint preempts\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL) {\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/disassembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-     _oop_maps(NULL) {\n+     _oop_maps(nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -125,4 +125,4 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n+    intptr_t* sender_sp = nullptr;\n+    intptr_t* sender_unextended_sp = nullptr;\n+    address   sender_pc = nullptr;\n+    intptr_t* saved_fp =  nullptr;\n@@ -192,1 +192,1 @@\n-    if (sender_pc == NULL ||  sender_blob == NULL) {\n+    if (sender_pc == nullptr ||  sender_blob == nullptr) {\n@@ -225,1 +225,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -267,1 +267,1 @@\n-  if ( (address) this->fp()[return_addr_offset] == NULL) return false;\n+  if ( (address) this->fp()[return_addr_offset] == nullptr) return false;\n@@ -301,1 +301,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -367,1 +367,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -395,1 +395,1 @@\n-  return jfa->last_Java_sp() == NULL;\n+  return jfa->last_Java_sp() == nullptr;\n@@ -399,1 +399,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -444,1 +444,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -446,1 +446,1 @@\n-    if (sender_cm != NULL) {\n+    if (sender_cm != nullptr) {\n@@ -571,1 +571,1 @@\n-        obj = (obj_p == NULL) ? (oop)NULL : *obj_p;\n+        obj = (obj_p == nullptr) ? (oop)nullptr : *obj_p;\n@@ -639,1 +639,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -719,1 +719,1 @@\n-    if (cb != NULL) {\n+    if (cb != nullptr) {\n@@ -785,1 +785,1 @@\n-  if (last_Java_sp() == NULL) return;\n+  if (last_Java_sp() == nullptr) return;\n@@ -788,2 +788,2 @@\n-  vmassert(last_Java_sp() != NULL, \"not called from Java code?\");\n-  vmassert(last_Java_pc() == NULL, \"already walkable\");\n+  vmassert(last_Java_sp() != nullptr, \"not called from Java code?\");\n+  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -42,5 +42,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -63,1 +63,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -67,1 +67,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -76,1 +76,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -79,1 +79,1 @@\n-    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n@@ -103,1 +103,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -105,2 +105,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n@@ -127,1 +127,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -147,2 +147,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -174,1 +174,1 @@\n-  \/\/ assert(_pc != NULL, \"no pc?\");\n+  \/\/ assert(_pc != nullptr, \"no pc?\");\n@@ -180,1 +180,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -201,1 +201,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -206,1 +206,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -213,1 +213,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -222,1 +222,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -246,1 +246,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n@@ -299,1 +299,1 @@\n-  if (last_sp == NULL) {\n+  if (last_sp == nullptr) {\n@@ -339,1 +339,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -345,1 +345,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -359,2 +359,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -362,1 +362,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -369,1 +369,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -398,1 +398,1 @@\n-  if (_cb != NULL) return sender_for_compiled_frame(map);\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -431,1 +431,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -437,1 +437,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -213,1 +213,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -217,1 +217,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -237,1 +237,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -430,1 +430,1 @@\n-  \/\/ At this point we know new_value is non-NULL and the new_value crosses regions.\n+  \/\/ At this point we know new_value is non-null and the new_value crosses regions.\n@@ -457,1 +457,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -308,1 +308,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -313,2 +313,2 @@\n-  Assembler::Condition condition = slow_path == NULL ? Assembler::EQ : Assembler::NE;\n-  Label& barrier_target = slow_path == NULL ? skip_barrier : *slow_path;\n+  Assembler::Condition condition = slow_path == nullptr ? Assembler::EQ : Assembler::NE;\n+  Label& barrier_target = slow_path == nullptr ? skip_barrier : *slow_path;\n@@ -360,1 +360,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -377,1 +377,1 @@\n-  if (bs == NULL) {\n+  if (bs == nullptr) {\n@@ -420,1 +420,1 @@\n-  __ cbz(obj, error);      \/\/ if klass is NULL it is broken\n+  __ cbz(obj, error);      \/\/ if klass is null it is broken\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -450,1 +450,1 @@\n-\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals NULL\n+\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals null\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs past to check cast\n+define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap nulls past to check cast\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  \/\/ assert(cached_value == NULL || cached_oop->is_perm(), \"must be perm oop\");\n+  \/\/ assert(cached_value == nullptr || cached_oop->is_perm(), \"must be perm oop\");\n","filename":"src\/hotspot\/cpu\/aarch64\/icBuffer_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  *flush_icache_stub = (ICache::flush_icache_stub_t)NULL;\n+  *flush_icache_stub = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    cbz(rscratch1, L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    cbz(rscratch1, L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -772,1 +772,1 @@\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -871,1 +871,1 @@\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -899,1 +899,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1290,1 +1290,1 @@\n-  \/\/ observed the item[start_row] is NULL.\n+  \/\/ observed the item[start_row] is null.\n@@ -1306,1 +1306,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1309,1 +1309,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1312,1 +1312,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n@@ -1586,1 +1586,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n@@ -1614,1 +1614,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    \/\/ NULL last_sp until next java call\n+    \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-    intptr_t value = *addr == 0 ? NULL : (intptr_t)addr;\n+    intptr_t value = *addr == 0 ? (intptr_t)0 : (intptr_t)addr;\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -45,2 +45,2 @@\n-    _last_Java_fp = NULL;\n-    _last_Java_pc = NULL;\n+    _last_Java_fp = nullptr;\n+    _last_Java_pc = nullptr;\n@@ -54,1 +54,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -58,1 +58,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n@@ -67,1 +67,1 @@\n-  bool walkable(void)                            { return _last_Java_sp != NULL && _last_Java_pc != NULL; }\n+  bool walkable(void)                            { return _last_Java_sp != nullptr && _last_Java_pc != nullptr; }\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-      name = NULL;  \/\/ unreachable\n+      name = nullptr;  \/\/ unreachable\n@@ -199,1 +199,1 @@\n-      slow_case_addr = NULL;  \/\/ unreachable\n+      slow_case_addr = nullptr;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -651,1 +651,1 @@\n-  assert(last_java_pc != NULL, \"must provide a valid PC\");\n+  assert(last_java_pc != nullptr, \"must provide a valid PC\");\n@@ -689,1 +689,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -708,1 +708,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -866,1 +866,1 @@\n-    assert(CodeCache::find_blob(target) != NULL &&\n+    assert(CodeCache::find_blob(target) != nullptr &&\n@@ -898,1 +898,1 @@\n-        if (stub == NULL) {\n+        if (stub == nullptr) {\n@@ -900,1 +900,1 @@\n-          return NULL; \/\/ CodeCache is full\n+          return nullptr; \/\/ CodeCache is full\n@@ -930,2 +930,2 @@\n-  if (stub == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -971,1 +971,1 @@\n-  mov_metadata(rmethod, (Metadata*)NULL);\n+  mov_metadata(rmethod, nullptr);\n@@ -1167,1 +1167,1 @@\n-  \/\/ for (scan = klass->itable(); scan->interface() != NULL; scan += scan_step) {\n+  \/\/ for (scan = klass->itable(); scan->interface() != nullptr; scan += scan_step) {\n@@ -1226,2 +1226,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, nullptr);\n@@ -1250,4 +1250,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -1372,3 +1372,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -1445,1 +1445,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -1449,1 +1449,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -1451,1 +1451,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -1478,1 +1478,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -1510,1 +1510,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -1642,1 +1642,1 @@\n-    \/\/ provoke OS NULL exception if reg = NULL by\n+    \/\/ provoke OS null exception if reg is null by\n@@ -1648,1 +1648,1 @@\n-    \/\/ will provoke OS NULL exception if reg = NULL\n+    \/\/ will provoke OS null exception if reg is null\n@@ -1966,1 +1966,1 @@\n-  if (last != NULL && nativeInstruction_at(last)->is_Membar() && prev == last) {\n+  if (last != nullptr && nativeInstruction_at(last)->is_Membar() && prev == last) {\n@@ -2451,2 +2451,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  if (!UseCompressedOops || Universe::ptr_base() == NULL) {\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  if (!UseCompressedOops || Universe::ptr_base() == nullptr) {\n@@ -2473,1 +2473,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n@@ -2504,1 +2504,1 @@\n-  cbz(value, done);           \/\/ Use NULL as-is.\n+  cbz(value, done);           \/\/ Use null as-is.\n@@ -2530,1 +2530,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -3099,1 +3099,1 @@\n-  if (last == NULL || !nativeInstruction_at(last)->is_Imm_LdSt()) {\n+  if (last == nullptr || !nativeInstruction_at(last)->is_Imm_LdSt()) {\n@@ -4359,1 +4359,1 @@\n-    if (CompressedKlassPointers::base() == NULL) {\n+    if (CompressedKlassPointers::base() == nullptr) {\n@@ -4399,1 +4399,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -4432,1 +4432,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -4454,1 +4454,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -4471,1 +4471,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -4488,1 +4488,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -4494,1 +4494,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -4500,1 +4500,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -4506,1 +4506,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -4512,1 +4512,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -4518,1 +4518,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -4538,1 +4538,1 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n+  if (CompressedKlassPointers::base() == nullptr) {\n@@ -4646,2 +4646,2 @@\n-    assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-    assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+    assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+    assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4661,1 +4661,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4714,1 +4714,1 @@\n-\/\/ Used for storing NULLs.\n+\/\/ Used for storing nulls.\n@@ -4720,1 +4720,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs a Recorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs a Recorder\");\n@@ -4729,1 +4729,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -4754,1 +4754,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -4767,1 +4767,1 @@\n-    assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+    assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -4981,1 +4981,1 @@\n-    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    assert(count_pos.target() != nullptr, \"count_positives stub has not been generated\");\n@@ -4983,1 +4983,1 @@\n-    if (tpc1 == NULL) {\n+    if (tpc1 == nullptr) {\n@@ -4986,1 +4986,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4992,1 +4992,1 @@\n-    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    assert(count_pos_long.target() != nullptr, \"count_positives_long stub has not been generated\");\n@@ -4994,1 +4994,1 @@\n-    if (tpc2 == NULL) {\n+    if (tpc2 == nullptr) {\n@@ -4997,1 +4997,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5044,1 +5044,1 @@\n-    \/\/ if (a1 == null || a2 == null)\n+    \/\/ if (a1 == nullptr || a2 == nullptr)\n@@ -5175,1 +5175,1 @@\n-    assert(stub.target() != NULL, \"array_equals_long stub has not been generated\");\n+    assert(stub.target() != nullptr, \"array_equals_long stub has not been generated\");\n@@ -5177,1 +5177,1 @@\n-    if (tpc == NULL) {\n+    if (tpc == nullptr) {\n@@ -5180,1 +5180,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5327,1 +5327,1 @@\n-  assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+  assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -5334,1 +5334,1 @@\n-    assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+    assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -5345,1 +5345,1 @@\n-      if (tpc == NULL) {\n+      if (tpc == nullptr) {\n@@ -5347,1 +5347,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5696,1 +5696,1 @@\n-      assert(stub.target() != NULL, \"large_byte_array_inflate stub has not been generated\");\n+      assert(stub.target() != nullptr, \"large_byte_array_inflate stub has not been generated\");\n@@ -5698,1 +5698,1 @@\n-      if (tpc == NULL) {\n+      if (tpc == nullptr) {\n@@ -5701,1 +5701,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -6088,1 +6088,1 @@\n-  \/\/ See if oop is NULL if it is we need no handle\n+  \/\/ See if oop is null if it is we need no handle\n@@ -6101,1 +6101,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n@@ -6107,1 +6107,1 @@\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-null\n@@ -6134,1 +6134,1 @@\n-    \/\/ Store oop in handle area, may be NULL\n+    \/\/ Store oop in handle area, may be null\n@@ -6142,1 +6142,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":75,"deletions":75,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    Label *retaddr = NULL\n+    Label *retaddr = nullptr\n@@ -605,1 +605,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -607,1 +607,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -630,1 +630,1 @@\n-  static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {\n+  static void pd_patch_instruction(address branch, address target, const char* file = nullptr, int line = 0) {\n@@ -875,1 +875,1 @@\n-  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ Used for storing null. All other oop constants should be\n@@ -882,1 +882,1 @@\n-  \/\/ converting a zero (like NULL) into a Register by giving\n+  \/\/ converting a zero (like null) into a Register by giving\n@@ -954,1 +954,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -987,2 +987,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n@@ -1191,1 +1191,1 @@\n-  \/\/ Return: the call PC or NULL if CodeCache is full.\n+  \/\/ Return: the call PC or null if CodeCache is full.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    return CompressedOops::base() == NULL;\n+    return CompressedOops::base() == nullptr;\n@@ -102,1 +102,1 @@\n-    return CompressedKlassPointers::base() == NULL;\n+    return CompressedKlassPointers::base() == nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -185,1 +185,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-  if (trampoline_stub_addr != NULL) {\n+  if (trampoline_stub_addr != nullptr) {\n@@ -209,1 +209,1 @@\n-    assert (trampoline_stub_addr != NULL, \"we need a trampoline\");\n+    assert (trampoline_stub_addr != nullptr, \"we need a trampoline\");\n@@ -220,1 +220,1 @@\n-  assert(code != NULL, \"Could not find the containing code blob\");\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n@@ -232,1 +232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -273,1 +273,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,1 +297,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -592,1 +592,1 @@\n-  address destination(nmethod* nm = NULL) const;\n+  address destination(nmethod* nm = nullptr) const;\n@@ -712,1 +712,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -734,1 +734,1 @@\n-    assert(instr != NULL, \"\");\n+    assert(instr != nullptr, \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    if (base_location != NULL) {\n+    if (base_location != nullptr) {\n@@ -43,1 +43,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg reg) const { return nullptr; }\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::final_stubs_code() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n@@ -581,1 +581,1 @@\n-    if (Interpreter::code() != NULL) {\n+    if (Interpreter::code() != nullptr) {\n@@ -586,1 +586,1 @@\n-    if (StubRoutines::initial_stubs_code() != NULL) {\n+    if (StubRoutines::initial_stubs_code() != nullptr) {\n@@ -592,1 +592,1 @@\n-    if (StubRoutines::final_stubs_code() != NULL) {\n+    if (StubRoutines::final_stubs_code() != nullptr) {\n@@ -776,1 +776,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -806,1 +806,1 @@\n-  assert(regs2 == NULL, \"not needed on AArch64\");\n+  assert(regs2 == nullptr, \"not needed on AArch64\");\n@@ -1424,1 +1424,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       nullptr);\n@@ -1427,1 +1427,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1444,1 +1444,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1459,1 +1459,1 @@\n-  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1462,1 +1462,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1584,1 +1584,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n@@ -1790,1 +1790,1 @@\n-      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n+      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n@@ -2181,1 +2181,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2387,1 +2387,1 @@\n-  \/\/ QQQ this is useless it was NULL above\n+  \/\/ QQQ this is useless it was null above\n@@ -2767,1 +2767,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2883,1 +2883,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2895,1 +2895,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL,\n+    assert(StubRoutines::_call_stub_return_address != nullptr,\n@@ -569,1 +569,1 @@\n-    __ cbz(r0, exit); \/\/ if obj is NULL it is OK\n+    __ cbz(r0, exit); \/\/ if obj is null it is OK\n@@ -1483,1 +1483,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1549,1 +1549,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1827,1 +1827,1 @@\n-    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n+    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, nullptr,\n@@ -1829,1 +1829,1 @@\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n@@ -1900,1 +1900,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -2137,1 +2137,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2143,1 +2143,1 @@\n-    \/\/  if (src == NULL) return -1;\n+    \/\/  if (src == nullptr) return -1;\n@@ -2149,1 +2149,1 @@\n-    \/\/  if (dst == NULL) return -1;\n+    \/\/  if (dst == nullptr) return -1;\n@@ -2166,1 +2166,1 @@\n-    \/\/  assert(src->klass() != NULL);\n+    \/\/  assert(src->klass() != nullptr);\n@@ -2170,1 +2170,1 @@\n-      __ cbnz(scratch_src_klass, L2);   \/\/ it is broken if klass is NULL\n+      __ cbnz(scratch_src_klass, L2);   \/\/ it is broken if klass is null\n@@ -2578,1 +2578,1 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_byte_copy(true, entry, nullptr,\n@@ -2590,1 +2590,1 @@\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n@@ -2633,1 +2633,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, NULL, \"arrayof_oop_arraycopy_uninit\",\n+        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n@@ -2643,1 +2643,1 @@\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n@@ -8093,1 +8093,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-address StubRoutines::aarch64::_get_previous_sp_entry = NULL;\n+address StubRoutines::aarch64::_get_previous_sp_entry = nullptr;\n@@ -38,22 +38,22 @@\n-address StubRoutines::aarch64::_f2i_fixup = NULL;\n-address StubRoutines::aarch64::_f2l_fixup = NULL;\n-address StubRoutines::aarch64::_d2i_fixup = NULL;\n-address StubRoutines::aarch64::_d2l_fixup = NULL;\n-address StubRoutines::aarch64::_vector_iota_indices = NULL;\n-address StubRoutines::aarch64::_float_sign_mask = NULL;\n-address StubRoutines::aarch64::_float_sign_flip = NULL;\n-address StubRoutines::aarch64::_double_sign_mask = NULL;\n-address StubRoutines::aarch64::_double_sign_flip = NULL;\n-address StubRoutines::aarch64::_zero_blocks = NULL;\n-address StubRoutines::aarch64::_count_positives = NULL;\n-address StubRoutines::aarch64::_count_positives_long = NULL;\n-address StubRoutines::aarch64::_large_array_equals = NULL;\n-address StubRoutines::aarch64::_compare_long_string_LL = NULL;\n-address StubRoutines::aarch64::_compare_long_string_UU = NULL;\n-address StubRoutines::aarch64::_compare_long_string_LU = NULL;\n-address StubRoutines::aarch64::_compare_long_string_UL = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_ll = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_uu = NULL;\n-address StubRoutines::aarch64::_string_indexof_linear_ul = NULL;\n-address StubRoutines::aarch64::_large_byte_array_inflate = NULL;\n-address StubRoutines::aarch64::_method_entry_barrier = NULL;\n+address StubRoutines::aarch64::_f2i_fixup = nullptr;\n+address StubRoutines::aarch64::_f2l_fixup = nullptr;\n+address StubRoutines::aarch64::_d2i_fixup = nullptr;\n+address StubRoutines::aarch64::_d2l_fixup = nullptr;\n+address StubRoutines::aarch64::_vector_iota_indices = nullptr;\n+address StubRoutines::aarch64::_float_sign_mask = nullptr;\n+address StubRoutines::aarch64::_float_sign_flip = nullptr;\n+address StubRoutines::aarch64::_double_sign_mask = nullptr;\n+address StubRoutines::aarch64::_double_sign_flip = nullptr;\n+address StubRoutines::aarch64::_zero_blocks = nullptr;\n+address StubRoutines::aarch64::_count_positives = nullptr;\n+address StubRoutines::aarch64::_count_positives_long = nullptr;\n+address StubRoutines::aarch64::_large_array_equals = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_LL = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_UU = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_LU = nullptr;\n+address StubRoutines::aarch64::_compare_long_string_UL = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_ll = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_uu = nullptr;\n+address StubRoutines::aarch64::_string_indexof_linear_ul = nullptr;\n+address StubRoutines::aarch64::_large_byte_array_inflate = nullptr;\n+address StubRoutines::aarch64::_method_entry_barrier = nullptr;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  \/\/        bcp (NULL)\n+  \/\/        bcp (null)\n@@ -165,1 +165,1 @@\n-  address entry_point = NULL;\n+  address entry_point = nullptr;\n@@ -245,1 +245,1 @@\n-    if (StubRoutines::dsin() == NULL) {\n+    if (StubRoutines::dsin() == nullptr) {\n@@ -252,1 +252,1 @@\n-    if (StubRoutines::dcos() == NULL) {\n+    if (StubRoutines::dcos() == nullptr) {\n@@ -259,1 +259,1 @@\n-    if (StubRoutines::dtan() == NULL) {\n+    if (StubRoutines::dtan() == nullptr) {\n@@ -266,1 +266,1 @@\n-    if (StubRoutines::dlog() == NULL) {\n+    if (StubRoutines::dlog() == nullptr) {\n@@ -273,1 +273,1 @@\n-    if (StubRoutines::dlog10() == NULL) {\n+    if (StubRoutines::dlog10() == nullptr) {\n@@ -280,1 +280,1 @@\n-    if (StubRoutines::dexp() == NULL) {\n+    if (StubRoutines::dexp() == nullptr) {\n@@ -287,1 +287,1 @@\n-    if (StubRoutines::dpow() == NULL) {\n+    if (StubRoutines::dpow() == nullptr) {\n@@ -295,1 +295,1 @@\n-    fn = NULL;  \/\/ unreachable\n+    fn = nullptr;  \/\/ unreachable\n@@ -345,1 +345,1 @@\n-  \/\/  pop return address, reset last_sp to NULL\n+  \/\/  pop return address, reset last_sp to null\n@@ -430,1 +430,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -447,1 +447,1 @@\n-    \/\/ kind of lame ExternalAddress can't take NULL because\n+    \/\/ kind of lame ExternalAddress can't take null because\n@@ -449,1 +449,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -468,1 +468,1 @@\n-  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/ and null it as marker that esp is now tos until next java call\n@@ -524,1 +524,1 @@\n-  \/\/ NULL last_sp until next java call\n+  \/\/ null last_sp until next java call\n@@ -563,1 +563,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -656,2 +656,2 @@\n-  \/\/ (NULL bcp).  We pass zero for it.  The call returns the address\n-  \/\/ of the verified entry point for the method or NULL if the\n+  \/\/ (null bcp).  We pass zero for it.  The call returns the address\n+  \/\/ of the verified entry point for the method or null if the\n@@ -749,1 +749,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -799,1 +799,1 @@\n-      __ stop(\"synchronization object is NULL\");\n+      __ stop(\"synchronization object is null\");\n@@ -937,1 +937,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 != null\n@@ -1897,1 +1897,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -2064,1 +2064,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -142,2 +142,2 @@\n-\/\/ Store an oop (or NULL) at the Address described by obj.\n-\/\/ If val == noreg this means store a NULL\n+\/\/ Store an oop (or null) at the Address described by obj.\n+\/\/ If val == noreg this means store a null\n@@ -417,1 +417,1 @@\n-    __ mov(result, 0);  \/\/ NULL object reference\n+    __ mov(result, 0);  \/\/ null object reference\n@@ -1112,1 +1112,1 @@\n-  \/\/ do array store check - check for NULL value first\n+  \/\/ do array store check - check for null value first\n@@ -1140,1 +1140,1 @@\n-  \/\/ Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]\n+  \/\/ Have a null in r0, r3=array, r2=index.  Store null at ary[idx]\n@@ -1144,1 +1144,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -1873,1 +1873,1 @@\n-    \/\/ r0: osr nmethod (osr ok) or NULL (osr not possible)\n+    \/\/ r0: osr nmethod (osr ok) or null (osr not possible)\n@@ -2289,1 +2289,1 @@\n-    __ clinit_barrier(temp, rscratch1, NULL, &clinit_barrier_slow);\n+    __ clinit_barrier(temp, rscratch1, nullptr, &clinit_barrier_slow);\n@@ -2448,1 +2448,1 @@\n-      __ mov(c_rarg1, zr); \/\/ NULL object reference\n+      __ mov(c_rarg1, zr); \/\/ null object reference\n@@ -2453,1 +2453,1 @@\n-    \/\/ c_rarg1: object pointer or NULL\n+    \/\/ c_rarg1: object pointer or null\n@@ -2701,1 +2701,1 @@\n-    \/\/ c_rarg1: object pointer set up above (NULL if static)\n+    \/\/ c_rarg1: object pointer set up above (null if static)\n@@ -3698,1 +3698,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3751,1 +3751,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3760,2 +3760,2 @@\n-  \/\/ r0 = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ r0 = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ r0 = 0: obj == nullptr or  obj is not an instanceof the specified klass\n+  \/\/ r0 = 1: obj != nullptr and obj is     an instanceof the specified klass\n@@ -3821,1 +3821,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n@@ -3833,1 +3833,1 @@\n-  __ mov(c_rarg1, zr); \/\/ points to free slot or NULL\n+  __ mov(c_rarg1, zr); \/\/ points to free slot or null\n@@ -3924,1 +3924,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -594,1 +594,1 @@\n-    if (virt2 != NULL && strcasestr(line, virt2) != 0) {\n+    if (virt2 != nullptr && strcasestr(line, virt2) != 0) {\n@@ -612,1 +612,1 @@\n-  check_info_file(tname_file, \"Xen\", XenPVHVM, NULL, NoDetectedVirtualization);\n+  check_info_file(tname_file, \"Xen\", XenPVHVM, nullptr, NoDetectedVirtualization);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,3 +54,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -121,1 +121,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -144,3 +144,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -244,1 +244,1 @@\n-  assert(SharedRuntime::get_handle_wrong_method_stub() != NULL, \"check initialization order\");\n+  assert(SharedRuntime::get_handle_wrong_method_stub() != nullptr, \"check initialization order\");\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}