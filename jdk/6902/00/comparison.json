{"files":[{"patch":"@@ -54,1 +54,1 @@\n-  examine [ address\/count ] | [ address,address] <font color=\"red\">show contents of memory from given address<\/font>\n+  examine { address[\/count] | address,address } <font color=\"red\">show contents of memory from given address<\/font>\n@@ -70,1 +70,1 @@\n-  mem address [ length ] <font color=\"red\">show contents of memory -- also shows closest ELF\/COFF symbol if found<\/font>\n+  mem [ -v ] { address[\/count] | address,address } <font color=\"red\">show contents of memory. optionally include \"findpc\" info for addresses<\/font>\n","filename":"src\/jdk.hotspot.agent\/doc\/clhsdb.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -367,0 +367,48 @@\n+    String fillHexString(Address a, int width) {\n+        String s = \"0x0\";\n+        if (a != null) {\n+            s = a.toString();\n+        }\n+        if (s.length() != width) {\n+            return s.substring(0, 2) + \"000000000000000000000\".substring(0, width - s.length()) + s.substring(2);\n+        }\n+        return s;\n+    }\n+\n+    class AddressRange {\n+        private Address start;\n+        private Address end;\n+        AddressRange(Address start, Address end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+        Address getStart() {return start;}\n+        Address getEnd() {return end;}\n+    }\n+\n+    \/\/ Parses either address[\/count] or address,address into address start\/end values\n+    AddressRange parseAddressRange(String arg, int formatSize) {\n+        Pattern args1 = Pattern.compile(\"^(0x[0-9a-f]+)(\/([0-9]*)([a-z]*))?$\");\n+        Pattern args2 = Pattern.compile(\"^(0x[0-9a-f]+),(0x[0-9a-f]+)(\/[a-z]*)?$\");\n+        Matcher m1 = args1.matcher(arg);\n+        Matcher m2 = args2.matcher(arg);\n+        Address start = null;\n+        Address end   = null;\n+\n+        if (m1.matches()) {\n+            start = VM.getVM().getDebugger().parseAddress(m1.group(1));\n+            int count = 1;\n+            if (m1.group(2) != null) {\n+                count = Integer.parseInt(m1.group(3));\n+            }\n+            end = start.addOffsetTo(count * formatSize);\n+            return new AddressRange(start, end);\n+        } else if (m2.matches()) {\n+            start = VM.getVM().getDebugger().parseAddress(m2.group(1));\n+            end   = VM.getVM().getDebugger().parseAddress(m2.group(2));\n+            return new AddressRange(start, end);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n@@ -412,15 +460,1 @@\n-        new Command(\"examine\", \"examine [ address\/count ] | [ address,address]\", false) {\n-            Pattern args1 = Pattern.compile(\"^(0x[0-9a-f]+)(\/([0-9]*)([a-z]*))?$\");\n-            Pattern args2 = Pattern.compile(\"^(0x[0-9a-f]+),(0x[0-9a-f]+)(\/[a-z]*)?$\");\n-\n-            String fill(Address a, int width) {\n-                String s = \"0x0\";\n-                if (a != null) {\n-                    s = a.toString();\n-                }\n-                if (s.length() != width) {\n-                    return s.substring(0, 2) + \"000000000000000000000\".substring(0, width - s.length()) + s.substring(2);\n-                }\n-                return s;\n-            }\n-\n+        new Command(\"examine\", \"examine { address[\/count] | address,address }\", false) {\n@@ -432,4 +466,0 @@\n-                    Matcher m1 = args1.matcher(arg);\n-                    Matcher m2 = args2.matcher(arg);\n-                    Address start = null;\n-                    Address end   = null;\n@@ -437,12 +467,2 @@\n-\n-                    if (m1.matches()) {\n-                        start = VM.getVM().getDebugger().parseAddress(m1.group(1));\n-                        int count = 1;\n-                        if (m1.group(2) != null) {\n-                            count = Integer.parseInt(m1.group(3));\n-                        }\n-                        end = start.addOffsetTo(count * formatSize);\n-                    } else if (m2.matches()) {\n-                        start = VM.getVM().getDebugger().parseAddress(m2.group(1));\n-                        end   = VM.getVM().getDebugger().parseAddress(m2.group(2));\n-                    } else {\n+                    AddressRange addressRange = parseAddressRange(arg, formatSize);\n+                    if (addressRange == null) {\n@@ -450,1 +470,0 @@\n-                        return;\n@@ -452,0 +471,3 @@\n+                    Address start = addressRange.getStart();\n+                    Address end = addressRange.getEnd();\n+\n@@ -455,1 +477,1 @@\n-                    out.print(fill(start, formatWidth));\n+                    out.print(fillHexString(start, formatWidth));\n@@ -462,1 +484,1 @@\n-                        out.print(fill(val, formatWidth));\n+                        out.print(fillHexString(val, formatWidth));\n@@ -470,1 +492,1 @@\n-                                out.print(fill(start, formatWidth));\n+                                out.print(fillHexString(start, formatWidth));\n@@ -485,0 +507,56 @@\n+        new Command(\"mem\", \"mem [-v] { address[\/count] | address,address }\", false) {\n+            public void doit(Tokens t) {\n+                int formatSize = (int)VM.getVM().getAddressSize();\n+                boolean verbose = false;\n+                String arg;\n+\n+                if (t.countTokens() == 2) {\n+                    arg = t.nextToken();\n+                    if (arg.equals(\"-v\")) {\n+                        verbose = true;\n+                    } else {\n+                        usage();\n+                        return;\n+                    }\n+                }\n+                if (t.countTokens() != 1) {\n+                    usage();\n+                    return;\n+                }\n+\n+                arg = t.nextToken();\n+                AddressRange addressRange = parseAddressRange(arg, formatSize);\n+                if (addressRange == null) {\n+                    usage();\n+                }\n+                Address start = addressRange.getStart();\n+                Address end = addressRange.getEnd();\n+\n+                if (verbose) {\n+                    \/\/ Do the equivalent of a findpc on the start address.\n+                    PointerLocation loc = PointerFinder.find(start);\n+                    loc.printOn(out);\n+                }\n+\n+                int formatWidth = formatSize * 8 \/ 4 + 2;\n+                while (start != null && start.lessThan(end)) {\n+                    out.print(fillHexString(start, formatWidth));\n+                    out.print(\": \");\n+                    Address val = start.getAddressAt(0);\n+                    out.print(fillHexString(val, formatWidth));\n+                    if (verbose) {\n+                        \/\/ If we know what this is a pointer to, then print additional information.\n+                        PointerLocation loc = PointerFinder.find(val);\n+                        if (!loc.isUnknown()) {\n+                            out.print(\" \");\n+                            loc.printOn(out, false, false);\n+                        } else {\n+                            out.println();\n+                        }\n+                    } else {\n+                        out.println();\n+                    }\n+                    start = start.addOffsetTo(formatSize);\n+                }\n+            }\n+        },\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -184,0 +184,14 @@\n+\n+            \/\/ Run \"mem -v <addr>\/30\" on a Method*. The first line will look like:\n+            \/\/   Address 0x0000152e30403530: Method jdk\/test\/lib\/apps\/LingeredApp.steadyState(Ljava\/lang\/Object;)V@0x0000152e30403530\n+            \/\/ Followed by lines displaying the memory contents, including interpretation\n+            \/\/ of any contents that are addresses.\n+            cmdStr = \"mem -v \" + methodAddr + \"\/30\";\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"Method jdk\/test\/lib\/apps\/LingeredApp.steadyState\",\n+                                          methodAddr,\n+                                          \/* The following are from fields in the Method object. *\/\n+                                          \"vtable for Method\",\n+                                          \"ConstantPool for jdk\/test\/lib\/apps\/LingeredApp\"));\n+            runTest(withCore, cmds, expStrMap);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}