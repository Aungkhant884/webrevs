{"files":[{"patch":"@@ -182,33 +182,0 @@\n-oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, oop* load_addr) {\n-  return load_reference_barrier_native_impl(obj, load_addr);\n-}\n-\n-oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, narrowOop* load_addr) {\n-  return load_reference_barrier_native_impl(obj, load_addr);\n-}\n-\n-template <class T>\n-oop ShenandoahBarrierSet::load_reference_barrier_native_impl(oop obj, T* load_addr) {\n-  if (CompressedOops::is_null(obj)) {\n-    return NULL;\n-  }\n-\n-  ShenandoahMarkingContext* const marking_context = _heap->marking_context();\n-  if (_heap->is_concurrent_weak_root_in_progress() && !marking_context->is_marked(obj)) {\n-    Thread* thr = Thread::current();\n-    if (thr->is_Java_thread()) {\n-      return NULL;\n-    } else {\n-      return obj;\n-    }\n-  }\n-\n-  oop fwd = load_reference_barrier_not_null(obj);\n-  if (ShenandoahSelfFixing && load_addr != NULL && fwd != obj) {\n-    \/\/ Since we are here and we know the load address, update the reference.\n-    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n-  }\n-\n-  return fwd;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  oop load_reference_barrier_native(oop obj, oop* load_addr);\n-  oop load_reference_barrier_native(oop obj, narrowOop* load_addr);\n+  template <class T>\n+  inline oop load_reference_barrier_native(oop obj, T* load_addr);\n@@ -116,3 +116,0 @@\n-  template <class T>\n-  oop load_reference_barrier_native_impl(oop obj, T* load_addr);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,25 @@\n+template <class T>\n+inline oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, T* load_addr) {\n+  if (CompressedOops::is_null(obj)) {\n+    return NULL;\n+  }\n+\n+  ShenandoahMarkingContext* const marking_context = _heap->marking_context();\n+  if (_heap->is_concurrent_weak_root_in_progress() && !marking_context->is_marked(obj)) {\n+    Thread* thr = Thread::current();\n+    if (thr->is_Java_thread()) {\n+      return NULL;\n+    } else {\n+      return obj;\n+    }\n+  }\n+\n+  oop fwd = load_reference_barrier_not_null(obj);\n+  if (ShenandoahSelfFixing && load_addr != NULL && fwd != obj) {\n+    \/\/ Since we are here and we know the load address, update the reference.\n+    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+  }\n+\n+  return fwd;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}