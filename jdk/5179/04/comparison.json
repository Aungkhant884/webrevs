{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import sun.nio.ch.ChannelOutputStream;\n@@ -66,34 +67,0 @@\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n@@ -139,41 +106,1 @@\n-\n-        return new OutputStream() {\n-\n-            private ByteBuffer bb;\n-            private byte[] bs;       \/\/ Invoker's previous array\n-            private byte[] b1;\n-\n-            @Override\n-            public synchronized void write(int b) throws IOException {\n-                if (b1 == null)\n-                    b1 = new byte[1];\n-                b1[0] = (byte) b;\n-                this.write(b1);\n-            }\n-\n-            @Override\n-            public synchronized void write(byte[] bs, int off, int len)\n-                    throws IOException\n-            {\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return;\n-                }\n-                ByteBuffer bb = ((this.bs == bs)\n-                                 ? this.bb\n-                                 : ByteBuffer.wrap(bs));\n-                bb.limit(Math.min(off + len, bb.capacity()));\n-                bb.position(off);\n-                this.bb = bb;\n-                this.bs = bs;\n-                Channels.writeFully(ch, bb);\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                ch.close();\n-            }\n-\n-        };\n+        return new ChannelOutputStream(ch);\n@@ -219,4 +146,2 @@\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n+                Objects.checkFromIndexSize(off, len, bs.length);\n+                if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":79,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,38 @@\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out instanceof ChannelOutputStream cos\n+                && ch instanceof FileChannel fc) {\n+            WritableByteChannel wbc = cos.channel();\n+\n+            if (wbc instanceof FileChannel dst) {\n+                return transfer(fc, dst);\n+            }\n+\n+            if (wbc instanceof SelectableChannel sc) {\n+                synchronized (sc.blockingLock()) {\n+                    if (!sc.isBlocking())\n+                        throw new IllegalBlockingModeException();\n+                    return transfer(fc, wbc);\n+                }\n+            }\n+\n+            return transfer(fc, wbc);\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    private static long transfer(FileChannel src, WritableByteChannel dst) throws IOException {\n+        long initialPos = src.position();\n+        long pos = initialPos;\n+        try {\n+            while (pos < src.size()) {\n+                pos += src.transferTo(pos, Long.MAX_VALUE, dst);\n+            }\n+        } finally {\n+            src.position(pos);\n+        }\n+        return pos - initialPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.nio.channels.spi.*;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is defined here rather than in java.nio.channels.Channels\n+ * so that it will be accessible from java.nio.channels.Channels and\n+ * sun.nio.ch.ChannelInputStream.\n+ *\n+ *\n+ * @author Mark Reinhold\n+ * @author Mike McCloskey\n+ * @author JSR-51 Expert Group\n+ * @since 18\n+ *\/\n+public class ChannelOutputStream extends OutputStream {\n+\n+    private final WritableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     *\n+     * @throws  IllegalBlockingModeException\n+     *          If the channel is selectable and configured non-blocking.\n+     *\/\n+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFullyImpl(ch, bb);\n+            }\n+        } else {\n+            writeFullyImpl(ch, bb);\n+        }\n+    }\n+\n+    \/**\n+     * @param ch The channel wrapped by this stream.\n+     *\/\n+    public ChannelOutputStream(WritableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * @return The channel wrapped by this stream.\n+     *\/\n+    WritableByteChannel channel() {\n+        return ch;\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        if (b1 == null)\n+            b1 = new byte[1];\n+        b1[0] = (byte) b;\n+        this.write(b1);\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] bs, int off, int len)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, bs.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        ByteBuffer bb = ((this.bs == bs)\n+                         ? this.bb\n+                         : ByteBuffer.wrap(bs));\n+        bb.limit(Math.min(off + len, bb.capacity()));\n+        bb.position(off);\n+        this.bb = bb;\n+        this.bs = bs;\n+        writeFully(ch, bb);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2014, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.String.format;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main TransferTo\n+ * @bug 8265891\n+ * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo contract defined in the javadoc\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+\tprivate static final int MIN_SIZE = 10_000;\n+\tprivate static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+\tprivate static final int ITERATIONS = 10;\n+\n+\tprivate static final Random RND = RandomFactory.getRandom();\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\ttest(fileChannelInput(), fileChannelOutput());\n+\t\ttest(fileChannelInput(), selectableChannelOutput());\n+\t\ttest(fileChannelInput(), writableByteChannelOutput()); \/\/ Non-Selectable\n+\t\ttest(readableByteChannelInput(), defaultOutput());\n+\t}\n+\n+\tprivate static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+\t\tcontents(inputStreamProvider, outputStreamProvider);\n+\t}\n+\n+\tprivate static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+\t\ttry (InputStream in = inputStreamProvider.input()) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\t}\n+\n+\tprivate static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+\t\t\/\/ to span through several batches\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+\t\t\/\/ randomly chosen starting points within source and target\n+\t\tfor (int i = 0; i < ITERATIONS; i++) {\n+\t\t\tbyte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+\t\t\tint posIn = RND.nextInt(inBytes.length);\n+\t\t\tint posOut = RND.nextInt(MIN_SIZE);\n+\t\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n+\t\t}\n+\t}\n+\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes)\n+\t\t\tthrows Exception {\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, 0, 0);\n+\t}\n+\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn,\n+\t\t\tint posOut) throws Exception {\n+\t\tAtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+\t\ttry (InputStream in = inputStreamProvider.input(inBytes); OutputStream out = outputStreamProvider.output(recorder::set)) {\n+\t\t\t\/\/ skip bytes till starting point\n+\t\t\tin.readNBytes(posIn);\n+\t\t\tout.write(new byte[posOut]);\n+\n+\t\t\tlong reported = in.transferTo(out);\n+\t\t\tint count = inBytes.length - posIn;\n+\n+\t\t\tif (reported != count)\n+\t\t\t\tthrow new AssertionError(format(\"reported %d bytes but should report %d\", reported, count));\n+\n+\t\t\tbyte[] outBytes = recorder.get().get();\n+\t\t\tif (!Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count))\n+\t\t\t\tthrow new AssertionError(format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+\t\t}\n+\t}\n+\n+\tprivate static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+\t\tbyte[] bytes = new byte[min + RND.nextInt(maxRandomAdditive)];\n+\t\tRND.nextBytes(bytes);\n+\t\treturn bytes;\n+\t}\n+\n+\tprivate static interface InputStreamProvider {\n+\t\tInputStream input(byte... bytes) throws Exception;\n+\t}\n+\n+\tprivate static interface OutputStreamProvider {\n+\t\tOutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+\t}\n+\n+\tprivate static OutputStreamProvider defaultOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn outputStream;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider fileChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFiles.write(path, bytes);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path);\n+\t\t\t\treturn Channels.newInputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider readableByteChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\treturn Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider fileChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+\t\t\t\tspy.accept(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn Files.readAllBytes(path);\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\tthrow new AssertionError(\"Failed to verify output file\", e);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\treturn Channels.newOutputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider selectableChannelOutput() throws IOException {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tPipe pipe = Pipe.open();\n+\t\t\t\tCountDownLatch cdl = new CountDownLatch(1);\n+\t\t\t\tAtomicReference<byte[]> bytes = new AtomicReference<>();\n+\t\t\t\tThread reader = new Thread(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tInputStream is = Channels.newInputStream(pipe.source());\n+\t\t\t\t\t\tbytes.set(is.readAllBytes());\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\tthrow new AssertionError(\"Exception while asserting content\", e);\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\tcdl.countDown();\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\treader.start();\n+\t\t\t\tfinal OutputStream os = Channels.newOutputStream(pipe.sink());\n+\t\t\t\tspy.accept(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tSystem.out.println(\"CLOSING\");\n+\t\t\t\t\t    os.close();\n+\t\t\t\t\t\tSystem.out.println(\"WAITING\");\n+                        cdl.await();\n+                        byte[] b = bytes.get();\n+\t\t\t\t\t\tSystem.out.println(\"BYTES \" + b.length);\n+                        return b;\n+\t\t\t\t\t} catch (IOException | InterruptedException e) {\n+\t\t\t\t\t    throw new AssertionError(\"Exception while asserting content\", e);\n+\t\t\t\t    }\n+\t\t\t\t});\n+\t\t\t\treturn os;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider writableByteChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn Channels.newOutputStream(Channels.newChannel(outputStream));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic interface Thrower {\n+\t\tpublic void run() throws Throwable;\n+\t}\n+\n+\tpublic static void assertThrowsNPE(Thrower thrower, String message) {\n+\t\tassertThrows(thrower, NullPointerException.class, message);\n+\t}\n+\n+\tpublic static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+\t\tThrowable thrown;\n+\t\ttry {\n+\t\t\tthrower.run();\n+\t\t\tthrown = null;\n+\t\t} catch (Throwable caught) {\n+\t\t\tthrown = caught;\n+\t\t}\n+\n+\t\tif (!throwable.isInstance(thrown)) {\n+\t\t\tString caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+\t\t\tthrow new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+\t\t}\n+\n+\t\tif (thrown != null && !message.equals(thrown.getMessage())) {\n+\t\t\tthrow new AssertionError(format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+\t\t}\n+\t}\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"}]}