{"files":[{"patch":"@@ -152,2 +152,1 @@\n-            return transferInBlockingMode(fc, cos.channel());\n-        }\n+            WritableByteChannel wbc = cos.channel();\n@@ -155,2 +154,3 @@\n-        return super.transferTo(out);\n-    }\n+            if (wbc instanceof FileChannel dst) {\n+                return transfer(fc, dst);\n+            }\n@@ -158,3 +158,7 @@\n-    private static long transferInBlockingMode(FileChannel fc, WritableByteChannel wbc) throws IOException {\n-        return supplyUsingBlockingChannel(fc, () -> supplyUsingBlockingChannel(wbc, () -> transfer(fc, wbc)));\n-    }\n+            if (wbc instanceof SelectableChannel sc) {\n+                synchronized (sc.blockingLock()) {\n+                    if (!sc.isBlocking())\n+                        throw new IllegalBlockingModeException();\n+                    return transfer(fc, wbc);\n+                }\n+            }\n@@ -162,4 +166,2 @@\n-    @FunctionalInterface\n-    private static interface ThrowingLongSupplier<E extends Exception> {\n-        long supply() throws E;\n-    }\n+            return transfer(fc, wbc);\n+        }\n@@ -167,10 +169,1 @@\n-    private static long supplyUsingBlockingChannel(Channel c, ThrowingLongSupplier<IOException> tls)\n-            throws IOException {\n-        if (c instanceof SelectableChannel sc)\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                return tls.supply();\n-            }\n-        else\n-            return tls.supply();\n+        return super.transferTo(out);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -61,1 +61,3 @@\n-        test(fileChannelInput(), writableByteChannelOutput());\n+        test(fileChannelInput(), fileChannelOutput());\n+        \/\/ TODO Need test for blocking socket\n+        test(fileChannelInput(), writableByteChannelOutput()); \/\/ Non-Selectable\n@@ -155,0 +157,17 @@\n+    private static OutputStreamProvider fileChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                spy.accept(() -> {\n+                    try {\n+                        return Files.readAllBytes(path);\n+                    } catch (IOException e) {\n+                        throw new AssertionError(\"Failed to verify output file\", e);\n+                    }\n+                });\n+                return Channels.newOutputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}