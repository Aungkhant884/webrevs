{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.channels.Pipe;\n@@ -45,0 +46,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -64,179 +66,209 @@\n-    private static final int MIN_SIZE      = 10_000;\n-    private static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n-\n-    private static final int ITERATIONS = 10;\n-\n-    private static final Random RND = RandomFactory.getRandom();\n-\n-    public static void main(String[] args) throws Exception {\n-        test(fileChannelInput(), fileChannelOutput());\n-        \/\/ TODO Need test for blocking socket\n-        test(fileChannelInput(), writableByteChannelOutput()); \/\/ Non-Selectable\n-        test(readableByteChannelInput(), defaultOutput());\n-    }\n-\n-    private static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n-            throws Exception {\n-        ifOutIsNullThenNpeIsThrown(inputStreamProvider);\n-        contents(inputStreamProvider, outputStreamProvider);\n-    }\n-\n-    private static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n-        try (InputStream in = inputStreamProvider.input()) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n-\n-        try (InputStream in = inputStreamProvider.input((byte) 1)) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n-\n-        try (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n-            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n-        }\n-    }\n-\n-    private static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n-            throws Exception {\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n-\n-        \/\/ to span through several batches\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n-\n-        \/\/ randomly chosen starting points within source and target\n-        for (int i = 0; i < ITERATIONS; i++) {\n-            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n-            int posIn = RND.nextInt(inBytes.length);\n-            int posOut = RND.nextInt(MIN_SIZE);\n-            checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n-        }\n-    }\n-\n-    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n-            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n-        checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, 0, 0);\n-    }\n-\n-    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n-            OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn, int posOut) throws Exception {\n-        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n-        try (InputStream in = inputStreamProvider.input(inBytes);\n-                OutputStream out = outputStreamProvider.output(recorder::set)) {\n-            \/\/ skip bytes till starting point\n-            in.readNBytes(posIn);\n-            out.write(new byte[posOut]);\n-\n-            long reported = in.transferTo(out);\n-            int count = inBytes.length - posIn;\n-\n-            if (reported != count)\n-                throw new AssertionError(\n-                        format(\"reported %d bytes but should report %d\", reported, count));\n-\n-            byte[] outBytes = recorder.get().get();\n-            if (!Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count))\n-                throw new AssertionError(\n-                        format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n-        }\n-    }\n-\n-    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n-        byte[] bytes = new byte[min + RND.nextInt(maxRandomAdditive)];\n-        RND.nextBytes(bytes);\n-        return bytes;\n-    }\n-\n-    private static interface InputStreamProvider {\n-        InputStream input(byte... bytes) throws Exception;\n-    }\n-\n-    private static interface OutputStreamProvider {\n-        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n-    }\n-\n-    private static OutputStreamProvider defaultOutput() {\n-        return new OutputStreamProvider() {\n-            @Override\n-            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n-                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-                spy.accept(outputStream::toByteArray);\n-                return outputStream;\n-            }\n-        };\n-    }\n-\n-    private static InputStreamProvider fileChannelInput() {\n-        return new InputStreamProvider() {\n-            @Override\n-            public InputStream input(byte... bytes) throws Exception {\n-                Path path = Files.createTempFile(null, null);\n-                Files.write(path, bytes);\n-                FileChannel fileChannel = FileChannel.open(path);\n-                return Channels.newInputStream(fileChannel);\n-            }\n-        };\n-    }\n-\n-    private static InputStreamProvider readableByteChannelInput() {\n-        return new InputStreamProvider() {\n-            @Override\n-            public InputStream input(byte... bytes) throws Exception {\n-                return Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n-            }\n-        };\n-    }\n-\n-    private static OutputStreamProvider fileChannelOutput() {\n-        return new OutputStreamProvider() {\n-            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n-                Path path = Files.createTempFile(null, null);\n-                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n-                spy.accept(() -> {\n-                    try {\n-                        return Files.readAllBytes(path);\n-                    } catch (IOException e) {\n-                        throw new AssertionError(\"Failed to verify output file\", e);\n-                    }\n-                });\n-                return Channels.newOutputStream(fileChannel);\n-            }\n-        };\n-    }\n-\n-    private static OutputStreamProvider writableByteChannelOutput() {\n-        return new OutputStreamProvider() {\n-            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n-                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-                spy.accept(outputStream::toByteArray);\n-                return Channels.newOutputStream(Channels.newChannel(outputStream));\n-            }\n-        };\n-    }\n-\n-    public interface Thrower {\n-        public void run() throws Throwable;\n-    }\n-\n-    public static void assertThrowsNPE(Thrower thrower, String message) {\n-        assertThrows(thrower, NullPointerException.class, message);\n-    }\n-\n-    public static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n-        Throwable thrown;\n-        try {\n-            thrower.run();\n-            thrown = null;\n-        } catch (Throwable caught) {\n-            thrown = caught;\n-        }\n-\n-        if (!throwable.isInstance(thrown)) {\n-            String caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n-            throw new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n-        }\n-\n-        if (thrown != null && !message.equals(thrown.getMessage())) {\n-            throw new AssertionError(\n-                    format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n-        }\n-    }\n+\tprivate static final int MIN_SIZE = 10_000;\n+\tprivate static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+\tprivate static final int ITERATIONS = 10;\n+\n+\tprivate static final Random RND = RandomFactory.getRandom();\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\ttest(fileChannelInput(), fileChannelOutput());\n+\t\ttest(fileChannelInput(), selectableChannelOutput());\n+\t\ttest(fileChannelInput(), writableByteChannelOutput()); \/\/ Non-Selectable\n+\t\ttest(readableByteChannelInput(), defaultOutput());\n+\t}\n+\n+\tprivate static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+\t\tcontents(inputStreamProvider, outputStreamProvider);\n+\t}\n+\n+\tprivate static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+\t\ttry (InputStream in = inputStreamProvider.input()) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\t}\n+\n+\tprivate static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+\t\t\/\/ to span through several batches\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+\t\t\/\/ randomly chosen starting points within source and target\n+\t\tfor (int i = 0; i < ITERATIONS; i++) {\n+\t\t\tbyte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+\t\t\tint posIn = RND.nextInt(inBytes.length);\n+\t\t\tint posOut = RND.nextInt(MIN_SIZE);\n+\t\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n+\t\t}\n+\t}\n+\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes)\n+\t\t\tthrows Exception {\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, 0, 0);\n+\t}\n+\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn,\n+\t\t\tint posOut) throws Exception {\n+\t\tAtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+\t\ttry (InputStream in = inputStreamProvider.input(inBytes); OutputStream out = outputStreamProvider.output(recorder::set)) {\n+\t\t\t\/\/ skip bytes till starting point\n+\t\t\tin.readNBytes(posIn);\n+\t\t\tout.write(new byte[posOut]);\n+\n+\t\t\tlong reported = in.transferTo(out);\n+\t\t\tint count = inBytes.length - posIn;\n+\n+\t\t\tif (reported != count)\n+\t\t\t\tthrow new AssertionError(format(\"reported %d bytes but should report %d\", reported, count));\n+\n+\t\t\tbyte[] outBytes = recorder.get().get();\n+\t\t\tif (!Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count))\n+\t\t\t\tthrow new AssertionError(format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+\t\t}\n+\t}\n+\n+\tprivate static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+\t\tbyte[] bytes = new byte[min + RND.nextInt(maxRandomAdditive)];\n+\t\tRND.nextBytes(bytes);\n+\t\treturn bytes;\n+\t}\n+\n+\tprivate static interface InputStreamProvider {\n+\t\tInputStream input(byte... bytes) throws Exception;\n+\t}\n+\n+\tprivate static interface OutputStreamProvider {\n+\t\tOutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+\t}\n+\n+\tprivate static OutputStreamProvider defaultOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn outputStream;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider fileChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFiles.write(path, bytes);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path);\n+\t\t\t\treturn Channels.newInputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider readableByteChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\treturn Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider fileChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+\t\t\t\tspy.accept(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn Files.readAllBytes(path);\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\tthrow new AssertionError(\"Failed to verify output file\", e);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\treturn Channels.newOutputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider selectableChannelOutput() throws IOException {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tPipe pipe = Pipe.open();\n+\t\t\t\tCountDownLatch cdl = new CountDownLatch(1);\n+\t\t\t\tAtomicReference<byte[]> bytes = new AtomicReference<>();\n+\t\t\t\tThread reader = new Thread(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tInputStream is = Channels.newInputStream(pipe.source());\n+\t\t\t\t\t\tbytes.set(is.readAllBytes());\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\tthrow new AssertionError(\"Exception while asserting content\", e);\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\tcdl.countDown();\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\treader.start();\n+\t\t\t\tfinal OutputStream os = Channels.newOutputStream(pipe.sink());\n+\t\t\t\tspy.accept(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tSystem.out.println(\"CLOSING\");\n+\t\t\t\t\t    os.close();\n+\t\t\t\t\t\tSystem.out.println(\"WAITING\");\n+                        cdl.await();\n+                        byte[] b = bytes.get();\n+\t\t\t\t\t\tSystem.out.println(\"BYTES \" + b.length);\n+                        return b;\n+\t\t\t\t\t} catch (IOException | InterruptedException e) {\n+\t\t\t\t\t    throw new AssertionError(\"Exception while asserting content\", e);\n+\t\t\t\t    }\n+\t\t\t\t});\n+\t\t\t\treturn os;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider writableByteChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn Channels.newOutputStream(Channels.newChannel(outputStream));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic interface Thrower {\n+\t\tpublic void run() throws Throwable;\n+\t}\n+\n+\tpublic static void assertThrowsNPE(Thrower thrower, String message) {\n+\t\tassertThrows(thrower, NullPointerException.class, message);\n+\t}\n+\n+\tpublic static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+\t\tThrowable thrown;\n+\t\ttry {\n+\t\t\tthrower.run();\n+\t\t\tthrown = null;\n+\t\t} catch (Throwable caught) {\n+\t\t\tthrown = caught;\n+\t\t}\n+\n+\t\tif (!throwable.isInstance(thrown)) {\n+\t\t\tString caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+\t\t\tthrow new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+\t\t}\n+\n+\t\tif (thrown != null && !message.equals(thrown.getMessage())) {\n+\t\t\tthrow new AssertionError(format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+\t\t}\n+\t}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":211,"deletions":179,"binary":false,"changes":390,"status":"modified"}]}