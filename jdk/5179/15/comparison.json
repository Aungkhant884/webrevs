{"files":[{"patch":"@@ -72,3 +72,6 @@\n-     * <p> The {@code read} methods of the resulting stream will throw an\n-     * {@link IllegalBlockingModeException} if invoked while the underlying\n-     * channel is in non-blocking mode.  The stream will not be buffered, and\n+     * <p> The {@code read} and {@code transferTo} methods of the resulting stream\n+     * will throw an {@link IllegalBlockingModeException} if invoked while the\n+     * underlying channel is in non-blocking mode. The {@code transferTo} method\n+     * will also throw an {@code IllegalBlockingModeException} if invoked to\n+     * transfer bytes to an output stream that writes to an underlying channel in\n+     * non-blocking mode.  The stream will not be buffered, and\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.channels.WritableByteChannel;\n@@ -241,3 +242,16 @@\n-                && ch instanceof FileChannel fc\n-                && cos.channel() instanceof FileChannel dst) {\n-            return transfer(fc, dst);\n+                && ch instanceof FileChannel fc) {\n+            WritableByteChannel wbc = cos.channel();\n+\n+            if (wbc instanceof FileChannel dst) {\n+                return transfer(fc, dst);\n+            }\n+\n+            if (wbc instanceof SelectableChannel sc) {\n+                synchronized (sc.blockingLock()) {\n+                    if (!sc.isBlocking())\n+                        throw new IllegalBlockingModeException();\n+                    return transfer(fc, wbc);\n+                }\n+            }\n+\n+            return transfer(fc, wbc);\n@@ -249,1 +263,1 @@\n-    private static long transfer(FileChannel src, FileChannel dst) throws IOException {\n+    private static long transfer(FileChannel src, WritableByteChannel dst) throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.WritableByteChannel;\n@@ -36,0 +41,3 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n@@ -82,0 +90,6 @@\n+            \/\/ tests FileChannel.transferTo(SelectableChannelOutput) optimized case\n+            { fileChannelInput(), selectableChannelOutput() },\n+\n+            \/\/ tests FileChannel.transferTo(WritableChannelOutput) optimized case\n+            { fileChannelInput(), writableByteChannelOutput() },\n+\n@@ -172,0 +186,31 @@\n+    \/*\n+     * Special test whether selectable channel based transfer throws blocking mode exception.\n+     *\/\n+    @Test\n+    public void testIllegalBlockingMode() throws IOException {\n+        Pipe pipe = Pipe.open();\n+        try {\n+            \/\/ testing arbitrary input (here: empty file) to non-blocking selectable output\n+            try (FileChannel fc = FileChannel.open(Files.createTempFile(null, null));\n+                    InputStream is = Channels.newInputStream(fc);\n+                    SelectableChannel sc = pipe.sink().configureBlocking(false);\n+                    OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n+\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                assertThrows(IllegalBlockingModeException.class, () -> is.transferTo(os));\n+            }\n+\n+            \/\/ testing non-blocking selectable input to arbitrary output (here: byte array)\n+            try (SelectableChannel sc = pipe.source().configureBlocking(false);\n+                    InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n+                    OutputStream os = new ByteArrayOutputStream()) {\n+\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                assertThrows(IllegalBlockingModeException.class, () -> is.transferTo(os));\n+            }\n+        } finally {\n+            pipe.source().close();\n+            pipe.sink().close();\n+        }\n+}\n+\n@@ -285,0 +330,35 @@\n+    private static OutputStreamProvider selectableChannelOutput() throws IOException {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Pipe pipe = Pipe.open();\n+                Future<byte[]> bytes = CompletableFuture.supplyAsync(() -> {\n+                    try {\n+                        InputStream is = Channels.newInputStream(pipe.source());\n+                        return is.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new AssertionError(\"Exception while asserting content\", e);\n+                    }\n+                });\n+                final OutputStream os = Channels.newOutputStream(pipe.sink());\n+                spy.accept(() -> {\n+                    try {\n+                        os.close();\n+                        return bytes.get();\n+                    } catch (IOException | InterruptedException | ExecutionException e) {\n+                        throw new AssertionError(\"Exception while asserting content\", e);\n+                    }\n+                });\n+                return os;\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider writableByteChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return Channels.newOutputStream(Channels.newChannel(outputStream));\n+            }\n+        };\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"}]}