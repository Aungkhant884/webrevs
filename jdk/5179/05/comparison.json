{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import sun.nio.ch.ChannelOutputStream;\n@@ -66,34 +67,0 @@\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n@@ -139,41 +106,1 @@\n-\n-        return new OutputStream() {\n-\n-            private ByteBuffer bb;\n-            private byte[] bs;       \/\/ Invoker's previous array\n-            private byte[] b1;\n-\n-            @Override\n-            public synchronized void write(int b) throws IOException {\n-                if (b1 == null)\n-                    b1 = new byte[1];\n-                b1[0] = (byte) b;\n-                this.write(b1);\n-            }\n-\n-            @Override\n-            public synchronized void write(byte[] bs, int off, int len)\n-                    throws IOException\n-            {\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return;\n-                }\n-                ByteBuffer bb = ((this.bs == bs)\n-                                 ? this.bb\n-                                 : ByteBuffer.wrap(bs));\n-                bb.limit(Math.min(off + len, bb.capacity()));\n-                bb.position(off);\n-                this.bb = bb;\n-                this.bs = bs;\n-                Channels.writeFully(ch, bb);\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                ch.close();\n-            }\n-\n-        };\n+        return new ChannelOutputStream(ch);\n@@ -219,4 +146,2 @@\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n+                Objects.checkFromIndexSize(off, len, bs.length);\n+                if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":79,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,38 @@\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out instanceof ChannelOutputStream cos\n+                && ch instanceof FileChannel fc) {\n+            WritableByteChannel wbc = cos.channel();\n+\n+            if (wbc instanceof FileChannel dst) {\n+                return transfer(fc, dst);\n+            }\n+\n+            if (wbc instanceof SelectableChannel sc) {\n+                synchronized (sc.blockingLock()) {\n+                    if (!sc.isBlocking())\n+                        throw new IllegalBlockingModeException();\n+                    return transfer(fc, wbc);\n+                }\n+            }\n+\n+            return transfer(fc, wbc);\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    private static long transfer(FileChannel src, WritableByteChannel dst) throws IOException {\n+        long initialPos = src.position();\n+        long pos = initialPos;\n+        try {\n+            while (pos < src.size()) {\n+                pos += src.transferTo(pos, Long.MAX_VALUE, dst);\n+            }\n+        } finally {\n+            src.position(pos);\n+        }\n+        return pos - initialPos;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.nio.channels.spi.*;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is defined here rather than in java.nio.channels.Channels\n+ * so that it will be accessible from java.nio.channels.Channels and\n+ * sun.nio.ch.ChannelInputStream.\n+ *\n+ *\n+ * @author Mark Reinhold\n+ * @author Mike McCloskey\n+ * @author JSR-51 Expert Group\n+ * @since 18\n+ *\/\n+public class ChannelOutputStream extends OutputStream {\n+\n+    private final WritableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     *\n+     * @throws  IllegalBlockingModeException\n+     *          If the channel is selectable and configured non-blocking.\n+     *\/\n+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFullyImpl(ch, bb);\n+            }\n+        } else {\n+            writeFullyImpl(ch, bb);\n+        }\n+    }\n+\n+    \/**\n+     * @param ch The channel wrapped by this stream.\n+     *\/\n+    public ChannelOutputStream(WritableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * @return The channel wrapped by this stream.\n+     *\/\n+    WritableByteChannel channel() {\n+        return ch;\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        if (b1 == null)\n+            b1 = new byte[1];\n+        b1[0] = (byte) b;\n+        this.write(b1);\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] bs, int off, int len)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, bs.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        ByteBuffer bb = ((this.bs == bs)\n+                         ? this.bb\n+                         : ByteBuffer.wrap(bs));\n+        bb.limit(Math.min(off + len, bb.capacity()));\n+        bb.position(off);\n+        this.bb = bb;\n+        this.bs = bs;\n+        writeFully(ch, bb);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2014, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.String.format;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main TransferTo\n+ * @bug 8265891\n+ * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo contract defined in the javadoc\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+    private static final int MIN_SIZE      = 10_000;\n+    private static final int MAX_SIZE_INCR = 100_000_000 - MIN_SIZE;\n+\n+    private static final int ITERATIONS = 10;\n+\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(fileChannelInput(), fileChannelOutput());\n+        test(fileChannelInput(), selectableChannelOutput());\n+        test(fileChannelInput(), writableByteChannelOutput()); \/\/ Non-Selectable\n+        test(readableByteChannelInput(), defaultOutput());\n+    }\n+\n+    private static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        ifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+        contents(inputStreamProvider, outputStreamProvider);\n+    }\n+\n+    private static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+        try (InputStream in = inputStreamProvider.input()) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+    }\n+\n+    private static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+\n+        \/\/ to span through several batches\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+\n+        \/\/ randomly chosen starting points within source and target\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            byte[] inBytes = createRandomBytes(MIN_SIZE, MAX_SIZE_INCR);\n+            int posIn = RND.nextInt(inBytes.length);\n+            int posOut = RND.nextInt(MIN_SIZE);\n+            checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, posIn, posOut);\n+        }\n+    }\n+\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, inBytes, 0, 0);\n+    }\n+\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes, int posIn, int posOut) throws Exception {\n+        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+        try (InputStream in = inputStreamProvider.input(inBytes);\n+                OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            \/\/ skip bytes till starting point\n+            in.readNBytes(posIn);\n+            out.write(new byte[posOut]);\n+\n+            long reported = in.transferTo(out);\n+            int count = inBytes.length - posIn;\n+\n+            if (reported != count)\n+                throw new AssertionError(\n+                        format(\"reported %d bytes but should report %d\", reported, count));\n+\n+            byte[] outBytes = recorder.get().get();\n+            if (!Arrays.equals(inBytes, posIn, posIn + count, outBytes, posOut, posOut + count))\n+                throw new AssertionError(\n+                        format(\"inBytes.length=%d, outBytes.length=%d\", count, outBytes.length));\n+        }\n+    }\n+\n+    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        byte[] bytes = new byte[min + RND.nextInt(maxRandomAdditive)];\n+        RND.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    private static interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    private static interface OutputStreamProvider {\n+        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+    }\n+\n+    private static OutputStreamProvider defaultOutput() {\n+        return new OutputStreamProvider() {\n+            @Override\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return outputStream;\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider fileChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                Files.write(path, bytes);\n+                FileChannel fileChannel = FileChannel.open(path);\n+                return Channels.newInputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider readableByteChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                return Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider fileChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                spy.accept(() -> {\n+                    try {\n+                        return Files.readAllBytes(path);\n+                    } catch (IOException e) {\n+                        throw new AssertionError(\"Failed to verify output file\", e);\n+                    }\n+                });\n+                return Channels.newOutputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider selectableChannelOutput() throws IOException {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Pipe pipe = Pipe.open();\n+                CountDownLatch cdl = new CountDownLatch(1);\n+                AtomicReference<byte[]> bytes = new AtomicReference<>();\n+                Thread reader = new Thread(() -> {\n+                    try {\n+                        InputStream is = Channels.newInputStream(pipe.source());\n+                        bytes.set(is.readAllBytes());\n+                    } catch (IOException e) {\n+                        throw new AssertionError(\"Exception while asserting content\", e);\n+                    } finally {\n+                        cdl.countDown();\n+                    }\n+                });\n+                reader.start();\n+                final OutputStream os = Channels.newOutputStream(pipe.sink());\n+                spy.accept(() -> {\n+                    try {\n+                        System.out.println(\"CLOSING\");\n+                        os.close();\n+                        System.out.println(\"WAITING\");\n+                        cdl.await();\n+                        byte[] b = bytes.get();\n+                        System.out.println(\"BYTES \" + b.length);\n+                        return b;\n+                    } catch (IOException | InterruptedException e) {\n+                        throw new AssertionError(\"Exception while asserting content\", e);\n+                    }\n+                });\n+                return os;\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider writableByteChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return Channels.newOutputStream(Channels.newChannel(outputStream));\n+            }\n+        };\n+    }\n+\n+    public interface Thrower {\n+        public void run() throws Throwable;\n+    }\n+\n+    public static void assertThrowsNPE(Thrower thrower, String message) {\n+        assertThrows(thrower, NullPointerException.class, message);\n+    }\n+\n+    public static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+        Throwable thrown;\n+        try {\n+            thrower.run();\n+            thrown = null;\n+        } catch (Throwable caught) {\n+            thrown = caught;\n+        }\n+\n+        if (!throwable.isInstance(thrown)) {\n+            String caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+            throw new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+        }\n+\n+        if (thrown != null && !message.equals(thrown.getMessage())) {\n+            throw new AssertionError(\n+                    format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"}]}