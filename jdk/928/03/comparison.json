{"files":[{"patch":"@@ -58,1 +58,1 @@\n-  ZNMethod::nmethod_oops_do(nm, &cl);\n+  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -95,2 +97,2 @@\n-template <bool Concurrent, bool Weak>\n-class ZHeapIteratorRootOopClosure : public ZRootsIteratorClosure {\n+template <bool Weak>\n+class ZHeapIteratorRootOopClosure : public OopClosure {\n@@ -105,5 +107,1 @@\n-    if (Concurrent) {\n-      return NativeAccess<AS_NO_KEEPALIVE>::oop_load(p);\n-    }\n-\n-    return RawAccess<>::oop_load(p);\n+    return NativeAccess<AS_NO_KEEPALIVE>::oop_load(p);\n@@ -124,16 +122,0 @@\n-\n-  virtual void do_thread(Thread* thread) {\n-    CodeBlobToOopClosure code_cl(this, false \/* fix_oop_relocations *\/);\n-    thread->oops_do(this, &code_cl);\n-  }\n-\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    if (ClassUnloading) {\n-      \/\/ All encountered nmethods should have been \"entered\" during stack walking\n-      return ZNMethodEntry::VerifyDisarmed;\n-    } else {\n-      \/\/ All nmethods are considered roots and will be visited.\n-      \/\/ Make sure that the unvisited gets fixed and disarmed before proceeding.\n-      return ZNMethodEntry::PreBarrier;\n-    }\n-  }\n@@ -183,1 +165,1 @@\n-    _concurrent_roots(),\n+    _concurrent_roots(ClassLoaderData::_claim_other),\n@@ -258,4 +240,77 @@\n-template <bool Concurrent, bool Weak, typename RootsIterator>\n-void ZHeapIterator::push_roots(const ZHeapIteratorContext& context, RootsIterator& iter) {\n-  ZHeapIteratorRootOopClosure<Concurrent, Weak> cl(context);\n-  iter.oops_do(&cl);\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_other> ZHeapIteratorCLDCLosure;\n+\n+class ZHeapIteratorNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const        _cl;\n+  BarrierSetNMethod* const _bs_nm;\n+\n+public:\n+  ZHeapIteratorNMethodClosure(OopClosure* cl) :\n+      _cl(cl),\n+      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(!ClassUnloading, \"Only used if class unloading is turned off\");\n+\n+    \/\/ ClassUnloading is turned off, all nmethods are considered strong,\n+    \/\/ not only those on the call stacks. The heap iteration might happen\n+    \/\/ before the concurrent processign of the code cache, make sure that\n+    \/\/ all nmethods have been processed before visiting the oops.\n+    _bs_nm->nmethod_entry_barrier(nm);\n+\n+    ZNMethod::nmethod_oops_do(nm, _cl);\n+  }\n+};\n+\n+class ZHeapIteratorThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _cl;\n+\n+  class NMethodVisitor : public CodeBlobToOopClosure {\n+  public:\n+    NMethodVisitor(OopClosure* cl) :\n+        CodeBlobToOopClosure(cl, false \/* fix_oop_relocations *\/) {}\n+\n+    void do_code_blob(CodeBlob* cb) {\n+      assert(!cb->is_nmethod() || !ZNMethod::is_armed(cb->as_nmethod()),\n+          \"NMethods on stack should have been fixed and disarmed\");\n+\n+      CodeBlobToOopClosure::do_code_blob(cb);\n+    }\n+  };\n+\n+public:\n+  ZHeapIteratorThreadClosure(OopClosure* cl) : _cl(cl) {}\n+\n+  void do_thread(Thread* thread) {\n+    NMethodVisitor code_cl(_cl);\n+    thread->oops_do(_cl, &code_cl);\n+  }\n+};\n+\n+void ZHeapIterator::push_strong_roots(const ZHeapIteratorContext& context) {\n+  ZHeapIteratorRootOopClosure<false \/* Weak *\/> cl(context);\n+  ZHeapIteratorCLDCLosure cld_cl(&cl);\n+  ZHeapIteratorNMethodClosure nm_cl(&cl);\n+  ZHeapIteratorThreadClosure thread_cl(&cl);\n+\n+  _concurrent_roots.apply(&cl,\n+                          &cld_cl,\n+                          &thread_cl,\n+                          &nm_cl);\n+}\n+\n+void ZHeapIterator::push_weak_roots(const ZHeapIteratorContext& context) {\n+  ZHeapIteratorRootOopClosure<true  \/* Weak *\/> cl(context);\n+  _concurrent_weak_roots.apply(&cl);\n+\n+  AlwaysTrueClosure is_alive;\n+  _weak_roots.apply(&is_alive, &cl);\n+}\n+\n+template <bool VisitWeaks>\n+void ZHeapIterator::push_roots(const ZHeapIteratorContext& context) {\n+  push_strong_roots(context);\n+  if (VisitWeaks) {\n+    push_weak_roots(context);\n+  }\n@@ -346,8 +401,3 @@\n-void ZHeapIterator::object_iterate_inner(const ZHeapIteratorContext& context, ObjectClosure* cl) {\n-  push_roots<true  \/* Concurrent *\/, false \/* Weak *\/>(context, _concurrent_roots);\n-  if (VisitWeaks) {\n-    push_roots<false \/* Concurrent *\/, true  \/* Weak *\/>(context, _weak_roots);\n-    push_roots<true  \/* Concurrent *\/, true  \/* Weak *\/>(context, _concurrent_weak_roots);\n-  }\n-\n-  drain_and_steal<VisitWeaks>(context, cl);\n+void ZHeapIterator::object_iterate_inner(const ZHeapIteratorContext& context, ObjectClosure* object_cl) {\n+  push_roots<VisitWeaks>(context);\n+  drain_and_steal<VisitWeaks>(context, object_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":86,"deletions":36,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -49,10 +49,10 @@\n-  const bool                         _visit_weaks;\n-  ZStatTimerDisable                  _timer_disable;\n-  ZHeapIteratorBitMaps               _bitmaps;\n-  ZLock                              _bitmaps_lock;\n-  ZHeapIteratorQueues                _queues;\n-  ZHeapIteratorArrayQueues           _array_queues;\n-  ZConcurrentRootsIteratorClaimOther _concurrent_roots;\n-  ZWeakRootsIterator                 _weak_roots;\n-  ZConcurrentWeakRootsIterator       _concurrent_weak_roots;\n-  TaskTerminator                     _terminator;\n+  const bool                   _visit_weaks;\n+  ZStatTimerDisable            _timer_disable;\n+  ZHeapIteratorBitMaps         _bitmaps;\n+  ZLock                        _bitmaps_lock;\n+  ZHeapIteratorQueues          _queues;\n+  ZHeapIteratorArrayQueues     _array_queues;\n+  ZConcurrentRootsIterator     _concurrent_roots;\n+  ZWeakRootsIterator           _weak_roots;\n+  ZConcurrentWeakRootsIterator _concurrent_weak_roots;\n+  TaskTerminator               _terminator;\n@@ -64,2 +64,5 @@\n-  template <bool Concurrent, bool Weak, typename RootsIterator>\n-  void push_roots(const ZHeapIteratorContext& context, RootsIterator& iter);\n+  void push_strong_roots(const ZHeapIteratorContext& context);\n+  void push_weak_roots(const ZHeapIteratorContext& context);\n+\n+  template <bool VisitWeaks>\n+  void push_roots(const ZHeapIteratorContext& context);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/z\/zLock.inline.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -575,4 +578,3 @@\n-class ZMarkConcurrentRootsIteratorClosure : public ZRootsIteratorClosure {\n-public:\n-  ZMarkConcurrentRootsIteratorClosure() {\n-    ZThreadLocalAllocBuffer::reset_statistics();\n+class ZMarkOopClosure : public OopClosure {\n+  virtual void do_oop(oop* p) {\n+    ZBarrier::mark_barrier_on_oop_field(p, false \/* finalizable *\/);\n@@ -581,2 +583,2 @@\n-  ~ZMarkConcurrentRootsIteratorClosure() {\n-    ZThreadLocalAllocBuffer::publish_statistics();\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n@@ -584,0 +586,1 @@\n+};\n@@ -585,4 +588,3 @@\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    \/\/ Only apply closure to armed nmethods, and then disarm them.\n-    return ZNMethodEntry::Disarm;\n-  }\n+class ZMarkThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _cl;\n@@ -590,0 +592,8 @@\n+public:\n+  ZMarkThreadClosure(OopClosure* cl) :\n+      _cl(cl) {\n+    ZThreadLocalAllocBuffer::reset_statistics();\n+  }\n+  ~ZMarkThreadClosure() {\n+    ZThreadLocalAllocBuffer::publish_statistics();\n+  }\n@@ -592,1 +602,1 @@\n-    StackWatermarkSet::finish_processing(jt, this, StackWatermarkKind::gc);\n+    StackWatermarkSet::finish_processing(jt, _cl, StackWatermarkKind::gc);\n@@ -595,0 +605,1 @@\n+};\n@@ -596,3 +607,3 @@\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::mark_barrier_on_oop_field(p, false \/* finalizable *\/);\n-  }\n+class ZMarkNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const _cl;\n@@ -600,2 +611,14 @@\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n+public:\n+  ZMarkNMethodClosure(OopClosure* cl) :\n+      _cl(cl) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n+    if (!nm->is_alive()) {\n+      return;\n+    }\n+\n+    if (ZNMethod::is_armed(nm)) {\n+      ZNMethod::nmethod_oops_do_inner(nm, _cl);\n+      ZNMethod::disarm(nm);\n+    }\n@@ -605,0 +628,2 @@\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_strong> ZMarkCLDClosure;\n+\n@@ -607,4 +632,8 @@\n-  ZMark* const                        _mark;\n-  SuspendibleThreadSetJoiner          _sts_joiner;\n-  ZConcurrentRootsIteratorClaimStrong _roots;\n-  ZMarkConcurrentRootsIteratorClosure _cl;\n+  ZMark* const               _mark;\n+  SuspendibleThreadSetJoiner _sts_joiner;\n+  ZConcurrentRootsIterator   _roots;\n+\n+  ZMarkOopClosure            _cl;\n+  ZMarkCLDClosure            _cld_cl;\n+  ZMarkThreadClosure         _thread_cl;\n+  ZMarkNMethodClosure        _nm_cl;\n@@ -617,2 +646,5 @@\n-      _roots(),\n-      _cl() {\n+      _roots(ClassLoaderData::_claim_strong),\n+      _cl(),\n+      _cld_cl(&_cl),\n+      _thread_cl(&_cl),\n+      _nm_cl(&_cl) {\n@@ -627,1 +659,4 @@\n-    _roots.oops_do(&_cl);\n+    _roots.apply(&_cl,\n+                 &_cld_cl,\n+                 &_thread_cl,\n+                 &_nm_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -207,0 +207,9 @@\n+  ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n+  if (!nm->is_alive()) {\n+    return;\n+  }\n+\n+  ZNMethod::nmethod_oops_do_inner(nm, cl);\n+}\n+\n+void ZNMethod::nmethod_oops_do_inner(nmethod* nm, OopClosure* cl) {\n@@ -237,42 +246,1 @@\n-class ZNMethodToOopsDoClosure : public NMethodClosure {\n-private:\n-  OopClosure* const        _cl;\n-  const ZNMethodEntry      _entry;\n-  BarrierSetNMethod* const _bs_nm;\n-\n-public:\n-  ZNMethodToOopsDoClosure(OopClosure* cl, ZNMethodEntry entry) :\n-      _cl(cl),\n-      _entry(entry),\n-      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n-\n-  virtual void do_nmethod(nmethod* nm) {\n-    if (_entry == ZNMethodEntry::PreBarrier) {\n-      \/\/ Apply entry barrier before proceeding with closure\n-      _bs_nm->nmethod_entry_barrier(nm);\n-    }\n-\n-    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n-    if (!nm->is_alive()) {\n-      return;\n-    }\n-\n-    if (_entry == ZNMethodEntry::Disarm) {\n-      \/\/ Apply closure and disarm only armed nmethods\n-      if (ZNMethod::is_armed(nm)) {\n-        ZNMethod::nmethod_oops_do(nm, _cl);\n-        ZNMethod::disarm(nm);\n-      }\n-      return;\n-    }\n-\n-    if (_entry == ZNMethodEntry::VerifyDisarmed) {\n-      \/\/ Only verify\n-      assert(!ZNMethod::is_armed(nm), \"Must be disarmed\");\n-    }\n-\n-    ZNMethod::nmethod_oops_do(nm, _cl);\n-  }\n-};\n-\n-void ZNMethod::oops_do_begin() {\n+void ZNMethod::nmethods_do_begin() {\n@@ -282,1 +250,1 @@\n-void ZNMethod::oops_do_end() {\n+void ZNMethod::nmethods_do_end() {\n@@ -286,3 +254,2 @@\n-void ZNMethod::oops_do(OopClosure* cl, ZNMethodEntry entry) {\n-  ZNMethodToOopsDoClosure nmethod_cl(cl, entry);\n-  ZNMethodTable::nmethods_do(&nmethod_cl);\n+void ZNMethod::nmethods_do(NMethodClosure* cl) {\n+  ZNMethodTable::nmethods_do(cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":13,"deletions":46,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-class OopClosure;\n+class NMethodClosure;\n@@ -34,7 +34,0 @@\n-enum class ZNMethodEntry {\n-  PreBarrier,\n-  Disarm,\n-  VerifyDisarmed,\n-  None\n-};\n-\n@@ -59,0 +52,1 @@\n+  static void nmethod_oops_do_inner(nmethod* nm, OopClosure* cl);\n@@ -60,3 +54,3 @@\n-  static void oops_do_begin();\n-  static void oops_do_end();\n-  static void oops_do(OopClosure* cl, ZNMethodEntry entry);\n+  static void nmethods_do_begin();\n+  static void nmethods_do_end();\n+  static void nmethods_do(NMethodClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-class ZPhantomKeepAliveOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomKeepAliveOopClosure : public OopClosure {\n@@ -60,2 +60,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const;\n@@ -63,2 +61,1 @@\n-\n-class ZPhantomCleanOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomCleanOopClosure : public OopClosure {\n@@ -68,2 +65,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,5 +83,0 @@\n-inline ZNMethodEntry ZPhantomKeepAliveOopClosure::nmethod_entry() const {\n-  ShouldNotReachHere();\n-  return ZNMethodEntry::None;\n-}\n-\n@@ -112,5 +107,0 @@\n-inline ZNMethodEntry ZPhantomCleanOopClosure::nmethod_entry() const {\n-  ShouldNotReachHere();\n-  return ZNMethodEntry::None;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -41,0 +42,1 @@\n+static const ZStatSubPhase ZSubPhasePauseRootsJVMTITagMap(\"Pause Roots JVMTITagMap\");\n@@ -70,2 +72,4 @@\n-    \/\/ export weak roots to rehash the JVMTI tag map\n-    ZRelocateRoots::oops_do(&_cl);\n+    \/\/ tag map to rehash the entries with the new oop addresses.\n+    ZStatTimer timer(ZSubPhasePauseRootsJVMTITagMap);\n+    AlwaysTrueClosure always_alive;\n+    JvmtiTagMap::weak_oops_do(&always_alive, &_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -31,1 +32,1 @@\n-#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -37,1 +38,0 @@\n-static const ZStatSubPhase ZSubPhasePauseRootsJVMTIWeakExport(\"Pause Roots JVMTIWeakExport\");\n@@ -42,1 +42,1 @@\n-static const ZStatSubPhase ZSubPhasePauseWeakRootsJVMTIWeakExport(\"Pause Weak Roots JVMTIWeakExport\");\n+static const ZStatSubPhase ZSubPhasePauseWeakRootsJVMTITagMap(\"Pause Weak Roots JVMTITagMap\");\n@@ -45,7 +45,3 @@\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-ZParallelOopsDo<T, F>::ZParallelOopsDo(T* iter) :\n-    _iter(iter),\n-    _completed(false) {}\n-\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-void ZParallelOopsDo<T, F>::oops_do(ZRootsIteratorClosure* cl) {\n+template <typename Iterator>\n+template <typename ClosureType>\n+void ZParallelApply<Iterator>::apply(ClosureType* cl) {\n@@ -53,1 +49,1 @@\n-    (_iter->*F)(cl);\n+    _iter.apply(cl);\n@@ -60,7 +56,2 @@\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-ZSerialWeakOopsDo<T, F>::ZSerialWeakOopsDo(T* iter) :\n-    _iter(iter),\n-    _claimed(false) {}\n-\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-void ZSerialWeakOopsDo<T, F>::weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n+template <typename Iterator>\n+void ZSerialWeakApply<Iterator>::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n@@ -68,1 +59,1 @@\n-    (_iter->*F)(is_alive, cl);\n+    _iter.apply(is_alive, cl);\n@@ -72,0 +63,13 @@\n+ZStrongOopStorageSetIterator::ZStrongOopStorageSetIterator() :\n+    _iter() {}\n+\n+void ZStrongOopStorageSetIterator::apply(OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsOopStorageSet);\n+  _iter.oops_do(cl);\n+}\n+\n+void ZStrongCLDsIterator::apply(CLDClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsClassLoaderDataGraph);\n+  ClassLoaderDataGraph::always_strong_cld_do(cl);\n+}\n+\n@@ -80,1 +84,8 @@\n-void ZJavaThreadsIterator::threads_do(ThreadClosure* cl) {\n+void ZJavaThreadsIterator::apply(ThreadClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsJavaThreads);\n+\n+  \/\/ The resource mark is needed because interpreter oop maps are\n+  \/\/ not reused in concurrent mode. Instead, they are temporary and\n+  \/\/ resource allocated.\n+  ResourceMark                 _rm;\n+\n@@ -86,15 +97,1 @@\n-void ZRelocateRoots::oops_do(OopClosure* cl) {\n-  ZStatTimer timer(ZSubPhasePauseRootsJVMTIWeakExport);\n-  AlwaysTrueClosure always_alive;\n-  JvmtiExport::weak_oops_do(&always_alive, cl);\n-}\n-\n-ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) :\n-    _oop_storage_set_iter(),\n-    _java_threads_iter(),\n-    _cld_claim(cld_claim),\n-    _oop_storage_set(this),\n-    _class_loader_data_graph(this),\n-    _java_threads(this),\n-    _code_cache(this) {\n-  ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n+ZNMethodsIterator::ZNMethodsIterator() {\n@@ -102,1 +99,1 @@\n-    ZNMethodTable::nmethods_do_begin();\n+    ZNMethod::nmethods_do_begin();\n@@ -106,1 +103,1 @@\n-ZConcurrentRootsIterator::~ZConcurrentRootsIterator() {\n+ZNMethodsIterator::~ZNMethodsIterator() {\n@@ -108,1 +105,1 @@\n-    ZNMethodTable::nmethods_do_end();\n+    ZNMethod::nmethods_do_end();\n@@ -112,12 +109,1 @@\n-void ZConcurrentRootsIterator::do_oop_storage_set(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsOopStorageSet);\n-  _oop_storage_set_iter.oops_do(cl);\n-}\n-\n-void ZConcurrentRootsIterator::do_class_loader_data_graph(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsClassLoaderDataGraph);\n-  CLDToOopClosure cld_cl(cl, _cld_claim);\n-  ClassLoaderDataGraph::always_strong_cld_do(&cld_cl);\n-}\n-\n-void ZConcurrentRootsIterator::do_code_cache(ZRootsIteratorClosure* cl) {\n+void ZNMethodsIterator::apply(NMethodClosure* cl) {\n@@ -125,1 +111,1 @@\n-  ZNMethod::oops_do(cl, cl->nmethod_entry());\n+  ZNMethod::nmethods_do(cl);\n@@ -128,14 +114,3 @@\n-class ZConcurrentRootsIteratorThreadClosure : public ThreadClosure {\n-private:\n-  \/\/ The resource mark is needed because interpreter oop maps are\n-  \/\/ not reused in concurrent mode. Instead, they are temporary and\n-  \/\/ resource allocated.\n-  ResourceMark                 _rm;\n-  ZRootsIteratorClosure* const _cl;\n-\n-public:\n-  ZConcurrentRootsIteratorThreadClosure(ZRootsIteratorClosure* cl) :\n-      _cl(cl) {}\n-\n-  virtual void do_thread(Thread* thread) {\n-    _cl->do_thread(thread);\n+ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) {\n+  if (cld_claim != ClassLoaderData::_claim_none) {\n+    ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n@@ -143,6 +118,0 @@\n-};\n-\n-void ZConcurrentRootsIterator::do_java_threads(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsJavaThreads);\n-  ZConcurrentRootsIteratorThreadClosure thread_cl(cl);\n-  _java_threads_iter.threads_do(&thread_cl);\n@@ -151,4 +120,7 @@\n-void ZConcurrentRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  _oop_storage_set.oops_do(cl);\n-  _class_loader_data_graph.oops_do(cl);\n-  _java_threads.oops_do(cl);\n+void ZConcurrentRootsIterator::apply(OopClosure* cl,\n+                                     CLDClosure* cld_cl,\n+                                     ThreadClosure* thread_cl,\n+                                     NMethodClosure* nm_cl) {\n+  _oop_storage_set.apply(cl);\n+  _class_loader_data_graph.apply(cld_cl);\n+  _java_threads.apply(thread_cl);\n@@ -156,1 +128,1 @@\n-    _code_cache.oops_do(cl);\n+    _nmethods.apply(nm_cl);\n@@ -161,1 +133,1 @@\n-    _jvmti_weak_export(this) {\n+    _jvmti_tag_map() {\n@@ -165,3 +137,2 @@\n-void ZWeakRootsIterator::do_jvmti_weak_export(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhasePauseWeakRootsJVMTIWeakExport);\n-  JvmtiExport::weak_oops_do(is_alive, cl);\n+void ZWeakRootsIterator::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n+  _jvmti_tag_map.apply(is_alive, cl);\n@@ -170,2 +141,3 @@\n-void ZWeakRootsIterator::weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n-  _jvmti_weak_export.weak_oops_do(is_alive, cl);\n+void ZJVMTITagMapIterator::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhasePauseWeakRootsJVMTITagMap);\n+  JvmtiTagMap::weak_oops_do(is_alive, cl);\n@@ -174,4 +146,2 @@\n-void ZWeakRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  AlwaysTrueClosure always_alive;\n-  weak_oops_do(&always_alive, cl);\n-}\n+ZWeakOopStorageSetIterator::ZWeakOopStorageSetIterator() :\n+    _iter() {}\n@@ -179,3 +149,3 @@\n-ZConcurrentWeakRootsIterator::ZConcurrentWeakRootsIterator() :\n-    _oop_storage_set_iter(),\n-    _oop_storage_set(this) {\n+void ZWeakOopStorageSetIterator::apply(OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentWeakRootsOopStorageSet);\n+  _iter.oops_do(cl);\n@@ -184,2 +154,2 @@\n-void ZConcurrentWeakRootsIterator::report_num_dead() {\n-  _oop_storage_set_iter.report_num_dead();\n+void ZWeakOopStorageSetIterator::report_num_dead() {\n+  _iter.report_num_dead();\n@@ -188,3 +158,2 @@\n-void ZConcurrentWeakRootsIterator::do_oop_storage_set(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentWeakRootsOopStorageSet);\n-  _oop_storage_set_iter.oops_do(cl);\n+void ZConcurrentWeakRootsIterator::report_num_dead() {\n+  _oop_storage_set.iter().report_num_dead();\n@@ -193,2 +162,2 @@\n-void ZConcurrentWeakRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  _oop_storage_set.oops_do(cl);\n+void ZConcurrentWeakRootsIterator::apply(OopClosure* cl) {\n+  _oop_storage_set.apply(cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":65,"deletions":96,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -29,2 +28,1 @@\n-#include \"gc\/z\/zNMethod.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -34,7 +32,2 @@\n-class ZRootsIteratorClosure;\n-\n-typedef OopStorageSetStrongParState<true \/* concurrent *\/, false \/* is_const *\/> ZOopStorageSetStrongIterator;\n-typedef OopStorageSetWeakParState<true \/* concurrent *\/, false \/* is_const *\/> ZOopStorageSetWeakIterator;\n-\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-class ZParallelOopsDo {\n+template <typename Iterator>\n+class ZParallelApply {\n@@ -42,1 +35,1 @@\n-  T* const      _iter;\n+  Iterator      _iter;\n@@ -46,2 +39,10 @@\n-  ZParallelOopsDo(T* iter);\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  ZParallelApply() :\n+      _iter(),\n+      _completed(false) {}\n+\n+  template <typename ClosureType>\n+  void apply(ClosureType* cl);\n+\n+  Iterator& iter() {\n+    return _iter;\n+  }\n@@ -50,2 +51,2 @@\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-class ZSerialWeakOopsDo {\n+template <typename Iterator>\n+class ZSerialWeakApply {\n@@ -53,1 +54,1 @@\n-  T* const      _iter;\n+  Iterator      _iter;\n@@ -57,2 +58,5 @@\n-  ZSerialWeakOopsDo(T* iter);\n-  void weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n+  ZSerialWeakApply() :\n+      _iter(),\n+      _claimed(false) {}\n+\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -61,1 +65,3 @@\n-class ZRootsIteratorClosure : public OopClosure {\n+class ZStrongOopStorageSetIterator {\n+  OopStorageSetStrongParState<true \/* concurrent *\/, false \/* is_const *\/> _iter;\n+\n@@ -63,1 +69,1 @@\n-  virtual void do_thread(Thread* thread) {}\n+  ZStrongOopStorageSetIterator();\n@@ -65,1 +71,6 @@\n-  virtual ZNMethodEntry nmethod_entry() const = 0;\n+  void apply(OopClosure* cl);\n+};\n+\n+class ZStrongCLDsIterator {\n+public:\n+  void apply(CLDClosure* cl);\n@@ -78,1 +89,1 @@\n-  void threads_do(ThreadClosure* cl);\n+  void apply(ThreadClosure* cl);\n@@ -81,1 +92,1 @@\n-class ZRelocateRoots : public AllStatic {\n+class ZNMethodsIterator {\n@@ -83,1 +94,4 @@\n-  static void oops_do(OopClosure* cl);\n+  ZNMethodsIterator();\n+  ~ZNMethodsIterator();\n+\n+  void apply(NMethodClosure* cl);\n@@ -88,13 +102,4 @@\n-  ZOopStorageSetStrongIterator _oop_storage_set_iter;\n-  ZJavaThreadsIterator         _java_threads_iter;\n-  const int                    _cld_claim;\n-\n-  void do_oop_storage_set(ZRootsIteratorClosure* cl);\n-  void do_java_threads(ZRootsIteratorClosure* cl);\n-  void do_class_loader_data_graph(ZRootsIteratorClosure* cl);\n-  void do_code_cache(ZRootsIteratorClosure* cl);\n-\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_oop_storage_set>         _oop_storage_set;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_class_loader_data_graph> _class_loader_data_graph;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_java_threads>            _java_threads;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_code_cache>              _code_cache;\n+  ZParallelApply<ZStrongOopStorageSetIterator> _oop_storage_set;\n+  ZParallelApply<ZStrongCLDsIterator>          _class_loader_data_graph;\n+  ZParallelApply<ZJavaThreadsIterator>         _java_threads;\n+  ZParallelApply<ZNMethodsIterator>            _nmethods;\n@@ -104,1 +109,0 @@\n-  ~ZConcurrentRootsIterator();\n@@ -106,1 +110,4 @@\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(OopClosure* cl,\n+             CLDClosure* cld_cl,\n+             ThreadClosure* thread_cl,\n+             NMethodClosure* nm_cl);\n@@ -109,5 +116,3 @@\n-class ZConcurrentRootsIteratorClaimStrong : public ZConcurrentRootsIterator {\n-public:\n-  ZConcurrentRootsIteratorClaimStrong() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_strong) {}\n-};\n+class ZWeakOopStorageSetIterator {\n+private:\n+  OopStorageSetWeakParState<true \/* concurrent *\/, false \/* is_const *\/> _iter;\n@@ -115,1 +120,0 @@\n-class ZConcurrentRootsIteratorClaimOther : public ZConcurrentRootsIterator {\n@@ -117,2 +121,5 @@\n-  ZConcurrentRootsIteratorClaimOther() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_other) {}\n+  ZWeakOopStorageSetIterator();\n+\n+  void apply(OopClosure* cl);\n+\n+  void report_num_dead();\n@@ -121,1 +128,1 @@\n-class ZConcurrentRootsIteratorClaimNone : public ZConcurrentRootsIterator {\n+class ZJVMTITagMapIterator {\n@@ -123,2 +130,1 @@\n-  ZConcurrentRootsIteratorClaimNone() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_none) {}\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -129,3 +135,1 @@\n-  void do_jvmti_weak_export(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n-\n-  ZSerialWeakOopsDo<ZWeakRootsIterator, &ZWeakRootsIterator::do_jvmti_weak_export> _jvmti_weak_export;\n+  ZSerialWeakApply<ZJVMTITagMapIterator> _jvmti_tag_map;\n@@ -136,2 +140,1 @@\n-  void weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -142,5 +145,1 @@\n-  ZOopStorageSetWeakIterator _oop_storage_set_iter;\n-\n-  void do_oop_storage_set(ZRootsIteratorClosure* cl);\n-\n-  ZParallelOopsDo<ZConcurrentWeakRootsIterator, &ZConcurrentWeakRootsIterator::do_oop_storage_set> _oop_storage_set;\n+  ZParallelApply<ZWeakOopStorageSetIterator> _oop_storage_set;\n@@ -149,3 +148,1 @@\n-  ZConcurrentWeakRootsIterator();\n-\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(OopClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.hpp","additions":60,"deletions":63,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    ZNMethod::nmethod_oops_do(nm, &cl);\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -69,1 +70,1 @@\n-class ZVerifyRootClosure : public ZRootsIteratorClosure {\n+class ZVerifyRootClosure : public OopClosure {\n@@ -92,2 +93,0 @@\n-  virtual void do_thread(Thread* thread);\n-\n@@ -97,5 +96,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    \/\/ Verification performs its own verification\n-    return ZNMethodEntry::None;\n-  }\n@@ -184,12 +178,0 @@\n-void ZVerifyRootClosure::do_thread(Thread* thread) {\n-  thread->oops_do_no_frames(this, NULL);\n-\n-  JavaThread* const jt = thread->as_Java_thread();\n-  if (!jt->has_last_Java_frame()) {\n-    return;\n-  }\n-\n-  ZVerifyStack verify_stack(this, jt);\n-  verify_stack.verify_frames();\n-}\n-\n@@ -224,4 +206,1 @@\n-template <typename RootsIterator>\n-void ZVerify::roots(bool verify_fixed) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n-  assert(!ZResurrection::is_blocked(), \"Invalid phase\");\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_none> ZVerifyCLDClosure;\n@@ -229,4 +208,18 @@\n-  if (ZVerifyRoots) {\n-    ZVerifyRootClosure cl(verify_fixed);\n-    RootsIterator iter;\n-    iter.oops_do(&cl);\n+class ZVerifyThreadClosure : public ThreadClosure {\n+private:\n+  ZVerifyRootClosure* const _cl;\n+\n+public:\n+  ZVerifyThreadClosure(ZVerifyRootClosure* cl) :\n+      _cl(cl) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    thread->oops_do_no_frames(_cl, NULL);\n+\n+    JavaThread* const jt = thread->as_Java_thread();\n+    if (!jt->has_last_Java_frame()) {\n+      return;\n+    }\n+\n+    ZVerifyStack verify_stack(_cl, jt);\n+    verify_stack.verify_frames();\n@@ -234,1 +227,1 @@\n-}\n+};\n@@ -236,3 +229,24 @@\n-void ZVerify::roots_weak() {\n-  roots<ZWeakRootsIterator>(true \/* verify_fixed *\/);\n-}\n+class ZVerifyNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const        _cl;\n+  BarrierSetNMethod* const _bs_nm;\n+  const bool               _verify_fixed;\n+\n+  bool trust_nmethod_state() const {\n+    \/\/ The root iterator will visit non-processed\n+    \/\/ nmethods class unloading is turned off.\n+    return ClassUnloading || _verify_fixed;\n+  }\n+\n+public:\n+  ZVerifyNMethodClosure(OopClosure* cl, bool verify_fixed) :\n+      _cl(cl),\n+      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()),\n+      _verify_fixed(verify_fixed) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(!trust_nmethod_state() || !_bs_nm->is_armed(nm), \"Should not encounter any armed nmethods\");\n+\n+    ZNMethod::nmethod_oops_do(nm, _cl);\n+  }\n+};\n@@ -241,1 +255,17 @@\n-  roots<ZConcurrentRootsIteratorClaimNone>(verify_fixed);\n+  ZVerifyRootClosure cl(verify_fixed);\n+  ZVerifyCLDClosure cld_cl(&cl);\n+  ZVerifyThreadClosure thread_cl(&cl);\n+  ZVerifyNMethodClosure nm_cl(&cl, verify_fixed);\n+\n+  ZConcurrentRootsIterator iter(ClassLoaderData::_claim_none);\n+  iter.apply(&cl,\n+             &cld_cl,\n+             &thread_cl,\n+             &nm_cl);\n+}\n+\n+void ZVerify::roots_weak() {\n+  AlwaysTrueClosure is_alive;\n+  ZVerifyRootClosure cl(true \/* verify_fixed *\/);\n+  ZWeakRootsIterator iter;\n+  iter.apply(&is_alive, &cl);\n@@ -245,1 +275,3 @@\n-  roots<ZConcurrentWeakRootsIterator>(true \/* verify_fixed *\/);\n+  ZVerifyRootClosure cl(true \/* verify_fixed *\/);\n+  ZConcurrentWeakRootsIterator iter;\n+  iter.apply(&cl);\n@@ -249,4 +281,9 @@\n-  roots_concurrent_strong(verify_concurrent_strong);\n-  if (verify_weaks) {\n-    roots_weak();\n-    roots_concurrent_weak();\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n+  assert(!ZResurrection::is_blocked(), \"Invalid phase\");\n+\n+  if (ZVerifyRoots) {\n+    roots_concurrent_strong(verify_concurrent_strong);\n+    if (verify_weaks) {\n+      roots_weak();\n+      roots_concurrent_weak();\n+    }\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":75,"deletions":38,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-  template <typename RootsIterator> static void roots(bool verify_fixed);\n-\n-  static void roots_weak();\n@@ -38,0 +35,1 @@\n+  static void roots_weak();\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    _weak_roots.weak_oops_do(&is_alive, &keep_alive);\n+    _weak_roots.apply(&is_alive, &keep_alive);\n@@ -50,1 +50,1 @@\n-  _workers->run_parallel(&task);\n+  _workers->run_serial(&task);\n@@ -68,1 +68,1 @@\n-    _concurrent_weak_roots.oops_do(&cl);\n+    _concurrent_weak_roots.apply(&cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,6 @@\n+template <int claim>\n+class ClaimingCLDToOopClosure : public CLDToOopClosure {\n+public:\n+  ClaimingCLDToOopClosure(OopClosure* cl) : CLDToOopClosure(cl, claim) {}\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}