{"files":[{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    \/\/ Adapter blobs never have a complete frame and are never ok.\n+    if (_cb->is_adapter_blob()) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (check && _cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (check && thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  *sender_pc = (address)*((*sender_sp) - frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (check && !fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*)*(fp + frame::interpreter_frame_sender_sp_offset);\n+  if (saved_fp) *saved_fp = (intptr_t**)(fp + frame::link_offset);\n+\n+  return true;\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CompiledMethod::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                                   sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -59,0 +59,2 @@\n+  ResourceMark rm;\n+\n@@ -98,11 +100,0 @@\n-    \/\/ First check if frame is complete and tester is reliable\n-    \/\/ Unfortunately we can only check frame complete for runtime stubs and nmethod\n-    \/\/ other generic buffer blobs are more problematic so we just assume they are\n-    \/\/ ok. adapter blobs never have a frame complete and are never ok.\n-\n-    if (!_cb->is_frame_complete_at(_pc)) {\n-      if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n-        return false;\n-      }\n-    }\n-\n@@ -120,37 +111,8 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    intptr_t*  sender_sp = NULL;\n+    intptr_t*  sender_unextended_sp = NULL;\n+    address    sender_pc = NULL;\n+    intptr_t** saved_fp =  NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, true, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -159,1 +121,0 @@\n-\n@@ -167,1 +128,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -173,1 +134,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -202,1 +163,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -208,1 +169,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -456,0 +417,2 @@\n+  ResourceMark rm;\n+\n@@ -461,5 +424,0 @@\n-  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = l_sender_sp;\n-\n-  \/\/ the return_address is always the word on the stack\n-  address sender_pc = (address) *(l_sender_sp-1);\n@@ -467,1 +425,7 @@\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp - frame::sender_sp_offset);\n+  intptr_t*  l_sender_sp;\n+  intptr_t*  l_unextended_sp;\n+  address    l_sender_pc;\n+  intptr_t** l_saved_fp;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, false, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -485,1 +449,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, l_saved_fp);\n@@ -488,1 +452,1 @@\n-  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":25,"deletions":61,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    \/\/ Adapter blobs never have a complete frame and are never ok.\n+    if (_cb->is_adapter_blob()) {\n+      return false;\n+    }\n+  }\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (check && thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ With our calling conventions, the return_address should\n+  \/\/ end up being the word on the stack\n+  *sender_pc = (address)*((*sender_sp) - frame::sender_sp_offset + frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset + frame::link_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (check && !fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  return true;\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CompiledMethod::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                                   sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n","filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -77,11 +79,0 @@\n-    \/\/ First check if frame is complete and tester is reliable\n-    \/\/ Unfortunately we can only check frame complete for runtime stubs and nmethod\n-    \/\/ other generic buffer blobs are more problematic so we just assume they are\n-    \/\/ ok. adapter blobs never have a frame complete and are never ok.\n-\n-    if (!_cb->is_frame_complete_at(_pc)) {\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n-        return false;\n-      }\n-    }\n-\n@@ -101,22 +92,4 @@\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      \/\/ With our calling conventions, the return_address should\n-      \/\/ end up being the word on the stack\n-      sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, true, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n@@ -391,0 +364,2 @@\n+  ResourceMark rm;\n+\n@@ -394,3 +369,0 @@\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = sender_sp;\n@@ -398,1 +370,1 @@\n-  address sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n@@ -400,3 +372,7 @@\n-  \/\/ This is the saved value of FP which may or may not really be an FP.\n-  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - sender_sp_offset + link_offset);\n+  intptr_t*  l_sender_sp;\n+  intptr_t*  l_unextended_sp;\n+  address    l_sender_pc;\n+  intptr_t** l_saved_fp;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, false, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -416,1 +392,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, l_saved_fp);\n@@ -419,2 +395,2 @@\n-  assert(sender_sp != sp(), \"must have changed\");\n-  return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  assert(l_sender_sp != sp(), \"must have changed\");\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":19,"deletions":43,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    \/\/ Adapter blobs never have a complete frame and are never ok.\n+    if (_cb->is_adapter_blob()) {\n+      return false;\n+    }\n+  }\n+\n+  frame::abi_minframe* sender_abi = (frame::abi_minframe*) fp;\n+  *sender_sp = (intptr_t*) fp;\n+  *sender_pc = (address) sender_abi->lr;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CompiledMethod::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                                   sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -55,0 +55,2 @@\n+  ResourceMark rm;\n+\n@@ -90,11 +92,0 @@\n-    \/\/ Now check if the frame is complete and the test is\n-    \/\/ reliable. Unfortunately we can only check frame completeness for\n-    \/\/ runtime stubs and nmethods. Other generic buffer blobs are more\n-    \/\/ problematic so we just assume they are OK. Adapter blobs never have a\n-    \/\/ complete frame and are never OK\n-    if (!_cb->is_frame_complete_at(_pc)) {\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n-        return false;\n-      }\n-    }\n-\n@@ -110,3 +101,7 @@\n-    abi_minframe* sender_abi = (abi_minframe*) fp;\n-    intptr_t* sender_sp = (intptr_t*) fp;\n-    address   sender_pc = (address) sender_abi->lr;;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, true, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n@@ -206,0 +201,2 @@\n+  ResourceMark rm;\n+\n@@ -209,2 +206,6 @@\n-  address pc = *compiled_sender_pc_addr(_cb);\n-  frame caller(compiled_sender_sp(_cb), pc);\n+\n+  intptr_t*  l_sender_sp;\n+  address    l_sender_pc;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, false, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, NULL, NULL);\n@@ -223,9 +224,1 @@\n-  return caller;\n-}\n-\n-intptr_t* frame::compiled_sender_sp(CodeBlob* cb) const {\n-  return sender_sp();\n-}\n-\n-address* frame::compiled_sender_pc_addr(CodeBlob* cb) const {\n-  return sender_pc_addr();\n+  return frame(l_sender_sp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -387,8 +387,0 @@\n- private:\n-\n-  intptr_t* compiled_sender_sp(CodeBlob* cb) const;\n-  address*  compiled_sender_pc_addr(CodeBlob* cb) const;\n-  address*  sender_pc_addr(void) const;\n-\n- public:\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,3 +106,0 @@\n-inline address* frame::sender_pc_addr() const {\n-  return (address*)&(callers_abi()->lr);\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    \/\/ Adapter blobs never have a complete frame and are never ok.\n+    if (_cb->is_adapter_blob()) {\n+      return false;\n+    }\n+  }\n+\n+  frame::z_abi_160* sender_abi = (frame::z_abi_160*) fp;\n+  *sender_sp = (intptr_t*) sender_abi->callers_sp;\n+  *sender_pc = (address) sender_abi->return_pc;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CompiledMethod::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                                   sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n","filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -58,0 +58,2 @@\n+  ResourceMark rm;\n+\n@@ -113,3 +115,7 @@\n-    z_abi_160* sender_abi = (z_abi_160*) fp;\n-    intptr_t* sender_sp = (intptr_t*) sender_abi->callers_sp;\n-    address   sender_pc = (address) sender_abi->return_pc;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, true, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n@@ -217,0 +223,2 @@\n+  ResourceMark rm;\n+\n@@ -218,0 +226,1 @@\n+\n@@ -220,2 +229,5 @@\n-  address pc = *compiled_sender_pc_addr(_cb);\n-  frame caller(compiled_sender_sp(_cb), pc);\n+  intptr_t*  l_sender_sp;\n+  address    l_sender_pc;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, false, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, NULL, NULL);\n@@ -234,1 +246,1 @@\n-  return caller;\n+  return frame(l_sender_sp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    \/\/ Adapter blobs never have a complete frame and are never ok.\n+    if (_cb->is_adapter_blob()) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (check && _cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (check && thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ On Intel the return_address is always the word on the stack\n+  *sender_pc = (address)*((*sender_sp) - frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (check && !fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*)*(fp + frame::interpreter_frame_sender_sp_offset);\n+  if (saved_fp) *saved_fp = (intptr_t**)(fp + frame::link_offset);\n+\n+  return true;\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  *sender_sp = unextended_sp;\n+  \/\/ Is sender_sp safe?\n+  if (check && thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ On Intel the return_address is always the word on the stack\n+  *sender_pc = (address)*((*sender_sp) - frame::pc_return_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset);\n+\n+  return true;\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (check && !fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_sp = fp + frame::sender_sp_offset;\n+  \/\/ Is sender_sp safe?\n+  if (check && thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  *sender_unextended_sp = *sender_sp;\n+\n+  \/\/ On Intel the return_address is always the word on the stack\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  *saved_fp = (intptr_t**)(fp + frame::link_offset);\n+\n+  return true;\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ First check if frame is complete and tester is reliable\n+  if (check && !_cb->is_frame_complete_at(pc)) {\n+    return false;\n+  }\n+\n+  return CodeBlob::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  if (_cb->is_compiled_by_c1() || _cb->is_compiled_by_c2()) {\n+    \/\/ We landed on the prolog which looks like:\n+    \/\/  mov %eax,-0x16000(%rsp) == stack banging\n+    \/\/  push %rbp\n+    \/\/  sub N, %rsp\n+    \/\/ Let's first figure out which instruction we're on\n+    int offset = pc - _cb->as_nmethod()->verified_entry_point();\n+    \/\/ If it's stack banging or `push %rbp`, %rsp hasn't been modified by this method\n+    if (offset == 0 \/* stack banging *\/ || offset == 7 \/* `push %rbp` *\/) {\n+      if (check && thread != NULL && !thread->is_in_full_stack_checked((address)sp)) {\n+        return false;\n+      }\n+\n+      *sender_sp = sp;\n+      *sender_unextended_sp = *sender_sp;\n+      *sender_pc = (address)*(*sender_sp);\n+\n+      CodeBlob *sender_cb = CodeCache::find_blob_unsafe(*sender_pc);\n+      if (*sender_pc == NULL ||  sender_cb == NULL) {\n+        return false;\n+      }\n+      \/\/ Could be a zombie method\n+      if (sender_cb->is_zombie() || sender_cb->is_unloaded()) {\n+        return false;\n+      }\n+      \/\/ Could just be some random pointer within the codeBlob\n+      if (!sender_cb->code_contains(*sender_pc)) {\n+        return false;\n+      }\n+\n+      *saved_fp = (intptr_t**)((*sender_sp) + sender_cb->frame_size() - frame::sender_sp_offset);\n+      return true;\n+    \/\/ If it's `sub N, %rsp`, %rsp has been incremented by `push %rbp` already\n+    \/\/ but the stack frame hasn't been allocated\n+    } else if (offset == 8 \/* `sub N, %rsp` *\/) {\n+      if (check && thread != NULL && !thread->is_in_full_stack_checked((address)sp)) {\n+        return false;\n+      }\n+\n+      *sender_sp = sp;\n+      *sender_unextended_sp = *sender_sp;\n+      *sender_pc = (address)*((*sender_sp) + frame::return_addr_offset);\n+      *saved_fp = (intptr_t**)((*sender_sp) + frame::link_offset);\n+      return true;\n+    }\n+  }\n+\n+  return CompiledMethod::FrameParser::sender_frame(thread, check, pc, sp, unextended_sp, fp, fp_safe,\n+                                                   sender_pc, sender_sp, sender_unextended_sp, saved_fp);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -72,1 +74,3 @@\n-  \/\/ an fp must be within the stack and above (but not equal) sp\n+  \/\/ an fp must be within the stack and above or equal to sp\n+  \/\/  it may be equal when the stack frame size is 0 which is the case\n+  \/\/  for some stubs for example.\n@@ -74,1 +78,1 @@\n-  bool fp_safe = thread->is_in_stack_range_excl(fp, sp) &&\n+  bool fp_safe = thread->is_in_stack_range_incl(fp, sp) &&\n@@ -85,11 +89,0 @@\n-    \/\/ First check if frame is complete and tester is reliable\n-    \/\/ Unfortunately we can only check frame complete for runtime stubs and nmethod\n-    \/\/ other generic buffer blobs are more problematic so we just assume they are\n-    \/\/ ok. adapter blobs never have a frame complete and are never ok.\n-\n-    if (!_cb->is_frame_complete_at(_pc)) {\n-      if (_cb->is_compiled() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {\n-        return false;\n-      }\n-    }\n-\n@@ -109,38 +102,8 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      \/\/ On Intel the return_address is always the word on the stack\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    intptr_t*  sender_sp = NULL;\n+    intptr_t*  sender_unextended_sp = NULL;\n+    address    sender_pc = NULL;\n+    intptr_t** saved_fp =  NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, true, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -149,1 +112,0 @@\n-\n@@ -157,1 +119,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -163,1 +125,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -192,1 +154,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -198,1 +160,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -470,0 +432,2 @@\n+  ResourceMark rm;\n+\n@@ -473,3 +437,0 @@\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = sender_sp;\n@@ -477,2 +438,1 @@\n-  \/\/ On Intel the return_address is always the word on the stack\n-  address sender_pc = (address) *(sender_sp-1);\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n@@ -480,3 +440,7 @@\n-  \/\/ This is the saved value of EBP which may or may not really be an FP.\n-  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+  intptr_t*  l_sender_sp = NULL;\n+  intptr_t*  l_unextended_sp = NULL;\n+  address    l_sender_pc = NULL;\n+  intptr_t** l_saved_fp = NULL;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, false, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -496,1 +460,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, l_saved_fp);\n@@ -499,2 +463,1 @@\n-  assert(sender_sp != sp(), \"must have changed\");\n-  return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":30,"deletions":67,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool VtableBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool StubRoutinesBlob::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool CompiledMethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool nmethod::FrameParser::sender_frame(JavaThread *thread, bool check, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -56,4 +56,4 @@\n-  int code_size = InterpreterCodeSize;\n-  NOT_PRODUCT(code_size *= 4;)  \/\/ debug uses extra interpreter code space\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n-                         \"Interpreter\");\n+  \/\/ debug uses extra interpreter code space\n+  BufferBlob* blob = InterpreterBlob::create(InterpreterCodeSize NOT_PRODUCT( * 4));\n+  assert(blob != NULL, \"invariant\");\n+  _code = new StubQueue(new InterpreterCodeletInterface, blob, NULL);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -310,0 +310,52 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of InterpreterBlob\n+\n+InterpreterBlob* InterpreterBlob::create(int buffer_size) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  InterpreterBlob* blob = NULL;\n+  unsigned int size = sizeof(InterpreterBlob);\n+  \/\/ align the size to CodeEntryAlignment\n+  size = CodeBlob::align_code_offset(size);\n+  size += align_up(buffer_size, 2 * oopSize);\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) InterpreterBlob(size);\n+    if (blob == NULL) {\n+      vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for Interpreter blob\");\n+    }\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of StubRoutinesBlob\n+\n+StubRoutinesBlob* StubRoutinesBlob::create(const char* name, int buffer_size) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  StubRoutinesBlob* blob = NULL;\n+  unsigned int size = sizeof(StubRoutinesBlob);\n+  \/\/ align the size to CodeEntryAlignment\n+  size = CodeBlob::align_code_offset(size);\n+  size += align_up(buffer_size, oopSize);\n+  assert(name != NULL, \"must provide a name\");\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) StubRoutinesBlob(name, size);\n+    if (blob == NULL) {\n+      vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for %s\", name);\n+    }\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of VtableBlob\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+\/\/    InterpreterBlob    : Used to hold Interpreter\n+\/\/    StubRoutinesBlob   : Used for stubroutines\n@@ -141,0 +143,2 @@\n+  virtual bool is_interpreter_blob() const            { return false; }\n+  virtual bool is_stub_routines_blob() const          { return false; }\n@@ -151,6 +155,6 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n-  nmethod* as_nmethod()                        { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n-  CompiledMethod* as_compiled_method()         { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n-  CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }\n-  OptimizedEntryBlob* as_optimized_entry_blob() const             { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n+  nmethod* as_nmethod_or_null() const                 { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod() const                         { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n+  CompiledMethod* as_compiled_method_or_null() const  { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method() const          { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n+  CodeBlob* as_codeblob_or_null() const               { return (CodeBlob*) this; }\n+  OptimizedEntryBlob* as_optimized_entry_blob() const { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n@@ -196,0 +200,12 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser: public ResourceObj {\n+   protected:\n+    const CodeBlob* _cb;\n+   public:\n+    FrameParser(const CodeBlob* cb) : _cb(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+\n@@ -339,1 +355,0 @@\n-\n@@ -362,0 +377,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public CodeBlob::FrameParser {\n+   public:\n+    FrameParser(const RuntimeBlob* cb) : CodeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -388,0 +409,2 @@\n+  friend class InterpreterBlob;\n+  friend class StubRoutinesBlob;\n@@ -411,0 +434,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public RuntimeBlob::FrameParser {\n+   public:\n+    FrameParser(const BufferBlob* cb) : RuntimeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -449,0 +478,10 @@\n+\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public BufferBlob::FrameParser {\n+   public:\n+    FrameParser(const VtableBlob* cb) : BufferBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n@@ -467,0 +506,52 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ InterpreterBlob: used to hold Interpreter\n+\n+class InterpreterBlob: public BufferBlob {\n+private:\n+  InterpreterBlob(int size)                          : BufferBlob(\"Interpreter\", size) {}\n+\n+public:\n+  \/\/ Creation\n+  static InterpreterBlob* create(int buffer_size);\n+\n+  \/\/ Typing\n+  virtual bool is_interpreter_blob() const { return true; }\n+\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public BufferBlob::FrameParser {\n+   public:\n+    FrameParser(const InterpreterBlob* cb) : BufferBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+};\n+\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ StubRoutinesBlob: used to hold stubroutines\n+\n+class StubRoutinesBlob: public BufferBlob {\n+private:\n+  StubRoutinesBlob(const char* name, int size)        : BufferBlob(name, size) {}\n+\n+public:\n+  \/\/ Creation\n+  static StubRoutinesBlob* create(const char* name, int buffer_size);\n+\n+  \/\/ Typing\n+  virtual bool is_stub_routines_blob() const { return true; }\n+\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public BufferBlob::FrameParser {\n+   public:\n+    FrameParser(const StubRoutinesBlob* cb) : BufferBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":98,"deletions":7,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -402,0 +402,11 @@\n+ public:\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public CodeBlob::FrameParser {\n+   public:\n+    FrameParser(const CompiledMethod* cb) : CodeBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -143,1 +143,6 @@\n-  _buffer = new StubQueue(new ICStubInterface, 10*K, InlineCacheBuffer_lock, \"InlineCacheBuffer\");\n+  int code_size = align_up((int)(10*K), 2*BytesPerWord);\n+  BufferBlob* blob = BufferBlob::create(\"InlineCacheBuffer\", code_size);\n+  if (blob == NULL) {\n+    vm_exit_out_of_memory(code_size, OOM_MALLOC_ERROR, \"CodeCache: no room for InlineCacheBuffer\");\n+  }\n+  _buffer = new StubQueue(new ICStubInterface, blob, InlineCacheBuffer_lock);\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -761,0 +761,11 @@\n+\n+ public:\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public CompiledMethod::FrameParser {\n+   public:\n+    FrameParser(const nmethod* cb) : CompiledMethod::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, bool check_frame_complete, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -67,7 +67,2 @@\n-StubQueue::StubQueue(StubInterface* stub_interface, int buffer_size,\n-                     Mutex* lock, const char* name) : _mutex(lock) {\n-  intptr_t size = align_up(buffer_size, 2*BytesPerWord);\n-  BufferBlob* blob = BufferBlob::create(name, size);\n-  if( blob == NULL) {\n-    vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for %s\", name);\n-  }\n+StubQueue::StubQueue(StubInterface* stub_interface, BufferBlob* blob,\n+                     Mutex* lock) : _mutex(lock) {\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  StubQueue(StubInterface* stub_interface, int buffer_size, Mutex* lock,\n-            const char* name);\n+  StubQueue(StubInterface* stub_interface, BufferBlob* blob, Mutex* lock);\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -48,4 +49,4 @@\n-  int code_size = InterpreterCodeSize;\n-  NOT_PRODUCT(code_size *= 4;)  \/\/ debug uses extra interpreter code space\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n-                        \"Interpreter\");\n+  \/\/ debug uses extra interpreter code space\n+  BufferBlob* blob = InterpreterBlob::create(InterpreterCodeSize NOT_PRODUCT( * 4));\n+  assert(blob != NULL, \"invariant\");\n+  _code = new StubQueue(new InterpreterCodeletInterface, blob, NULL);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -654,0 +654,4 @@\n+    } else if (_cb->is_interpreter_blob()) {\n+      st->print(\"v  ~InterpreterBlob\");\n+    } else if (_cb->is_stub_routines_blob()) {\n+      st->print(\"v  ~StubRoutinesBlob\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,4 +217,2 @@\n-    _code1 = BufferBlob::create(\"StubRoutines (1)\", code_size1);\n-    if (_code1 == NULL) {\n-      vm_exit_out_of_memory(code_size1, OOM_MALLOC_ERROR, \"CodeCache: no room for StubRoutines (1)\");\n-    }\n+    _code1 = StubRoutinesBlob::create(\"StubRoutines (1)\", code_size1);\n+    assert(_code1, \"invariant\");\n@@ -271,4 +269,2 @@\n-    _code2 = BufferBlob::create(\"StubRoutines (2)\", code_size2);\n-    if (_code2 == NULL) {\n-      vm_exit_out_of_memory(code_size2, OOM_MALLOC_ERROR, \"CodeCache: no room for StubRoutines (2)\");\n-    }\n+    _code2 = StubRoutinesBlob::create(\"StubRoutines (2)\", code_size2);\n+    assert(_code2, \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1403,0 +1403,2 @@\n+  declare_type(InterpreterBlob,          BufferBlob)                      \\\n+  declare_type(StubRoutinesBlob,         BufferBlob)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+    virtualConstructor.addMapping(\"InterpreterBlob\", InterpreterBlob.class);\n+    virtualConstructor.addMapping(\"StubRoutinesBlob\", StubRoutinesBlob.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+\n+public class InterpreterBlob extends BufferBlob {\n+\n+    public InterpreterBlob(Address addr) {\n+        super(addr);\n+    }\n+\n+    public boolean isInterpreterBlob() {\n+        return true;\n+    }\n+\n+    public String getName() {\n+        return \"InterpreterBlob: \" + super.getName();\n+    }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/InterpreterBlob.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+\n+public class StubRoutinesBlob extends BufferBlob {\n+\n+    public StubRoutinesBlob(Address addr) {\n+        super(addr);\n+    }\n+\n+    public boolean isStubRoutinesBlob() {\n+        return true;\n+    }\n+\n+    public String getName() {\n+        return \"StubRoutinesBlob: \" + super.getName();\n+    }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubRoutinesBlob.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}