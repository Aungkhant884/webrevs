[{"commit":{"message":"Fix comments"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"}],"sha":"b1d8611c38b11aab00d011cb279a5c52199bd7c1"},{"commit":{"message":"Disable checks in FrameParser when known to be safe"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"},{"filename":"src\/hotspot\/share\/code\/compiledMethod.hpp"},{"filename":"src\/hotspot\/share\/code\/nmethod.hpp"}],"sha":"85f218c82d0c435388c325992713713cfeb72749"},{"commit":{"message":"Allow AsyncGetCallTrace and JFR to unwind stack from vtable stub\n\nThe program is the following:\n\n```\nimport java.util.function.Supplier;\n\npublic class Prof2 {\n\n    public static void main(String[] args) {\n        var rand = new java.util.Random(0);\n        Supplier[] suppliers = {\n                () -> 0,\n                () -> 1,\n                () -> 2,\n                () -> 3,\n        };\n\n        long sum = 0;\n        for (int i = 0; i >= 0; i++) {\n            sum += (int)suppliers[i % suppliers.length].get();\n        }\n    }\n}\n```\n\nThe results are as follows:\n\n- Baseline (from previous commit):\n\nFlat Profile (by method):\n            (t 39.3,s 39.3) AGCT::Unknown Java[ERR=-5]\n            (t 40.3,s 36.1) Prof2::main\n            (t  6.4,s  5.3) Prof2$$Lambda$28.0x0000000800081000::get\n            (t  6.1,s  5.1) Prof2$$Lambda$29.0x0000000800081220::get\n            (t  6.0,s  5.0) Prof2$$Lambda$27.0x0000000800080c28::get\n            (t  6.1,s  5.0) Prof2$$Lambda$26.0x0000000800080a08::get\n            (t  1.1,s  1.1) Prof2::lambda$main$2\n            (t  1.1,s  1.1) Prof2::lambda$main$0\n            (t  1.0,s  1.0) Prof2::lambda$main$1\n            (t  0.9,s  0.9) Prof2::lambda$main$3\n            (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n\n- With unwind from vtable stub\n\nFlat Profile (by method):\n        (t 74.1,s 70.3) Prof2::main\n        (t  6.5,s  5.5) Prof2$$Lambda$29.0x0000000800081220::get\n        (t  6.6,s  5.4) Prof2$$Lambda$28.0x0000000800081000::get\n        (t  5.7,s  5.0) Prof2$$Lambda$26.0x0000000800080a08::get\n        (t  5.9,s  5.0) Prof2$$Lambda$27.0x0000000800080c28::get\n        (t  4.9,s  4.9) AGCT::Unknown Java[ERR=-5]\n        (t  1.2,s  1.2) Prof2::lambda$main$2\n        (t  0.9,s  0.9) Prof2::lambda$main$3\n        (t  0.9,s  0.9) Prof2::lambda$main$1\n        (t  0.7,s  0.7) Prof2::lambda$main$0\n        (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n\nWe attribute the vtable stub to the caller and not the callee, which is\nalready an improvement from the existing case."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"}],"sha":"2f2e49bbd9e944a02899d30b01888144250d40d3"},{"commit":{"message":"Allow AsyncGetCallTrace and JFR to unwind stack from nmethod's prolog\n\nWhen sampling hits the prolog of a method, Hotspot assumes it's unable\nto parse the frame. This change allows to parse such frame on x86 by\nspecializing which instruction it's hitting in the prolog.\n\nThe results are as follows:\n\n- Baseline:\n\nFlat Profile (by method):\n        (t 60.7,s 60.7) AGCT::Unknown Java[ERR=-5]\n        (t 39.2,s 35.2) Prof2::main\n        (t  1.4,s  1.4) Prof2::lambda$main$3\n        (t  1.0,s  1.0) Prof2::lambda$main$2\n        (t  0.9,s  0.9) Prof2::lambda$main$1\n        (t  0.7,s  0.7) Prof2::lambda$main$0\n        (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n        (t  0.0,s  0.0) java.lang.Thread::exit\n        (t  0.9,s  0.0) Prof2$$Lambda$2.0x0000000800c00c28::get\n        (t  1.0,s  0.0) Prof2$$Lambda$3.0x0000000800c01000::get\n        (t  1.4,s  0.0) Prof2$$Lambda$4.0x0000000800c01220::get\n        (t  0.7,s  0.0) Prof2$$Lambda$1.0x0000000800c00a08::get\n\n- With incomplete frame parsing:\n\nFlat Profile (by method):\n        (t 39.3,s 39.3) AGCT::Unknown Java[ERR=-5]\n        (t 40.3,s 36.1) Prof2::main\n        (t  6.4,s  5.3) Prof2$$Lambda$28.0x0000000800081000::get\n        (t  6.1,s  5.1) Prof2$$Lambda$29.0x0000000800081220::get\n        (t  6.0,s  5.0) Prof2$$Lambda$27.0x0000000800080c28::get\n        (t  6.1,s  5.0) Prof2$$Lambda$26.0x0000000800080a08::get\n        (t  1.1,s  1.1) Prof2::lambda$main$2\n        (t  1.1,s  1.1) Prof2::lambda$main$0\n        (t  1.0,s  1.0) Prof2::lambda$main$1\n        (t  0.9,s  0.9) Prof2::lambda$main$3\n        (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n        (t  0.0,s  0.0) java.util.Locale::getInstance\n        (t  0.0,s  0.0) AGCT::Not walkable Java[ERR=-6]\n        (t  0.0,s  0.0) jdk.internal.loader.BuiltinClassLoader::loadClassOrNull\n        (t  0.0,s  0.0) java.lang.ClassLoader::loadClass\n        (t  0.0,s  0.0) sun.net.util.URLUtil::urlNoFragString\n        (t  0.0,s  0.0) java.lang.Class::forName0\n        (t  0.0,s  0.0) java.util.Locale::initDefault\n        (t  0.0,s  0.0) jdk.internal.loader.BuiltinClassLoader::loadClass\n        (t  0.0,s  0.0) jdk.internal.loader.URLClassPath::getLoader\n        (t  0.0,s  0.0) jdk.internal.loader.URLClassPath::getResource\n        (t  0.0,s  0.0) java.lang.String::toLowerCase\n        (t  0.0,s  0.0) sun.launcher.LauncherHelper::loadMainClass\n        (t  0.0,s  0.0) sun.launcher.LauncherHelper::checkAndLoadMain\n        (t  0.0,s  0.0) java.util.Locale::<clinit>\n        (t  0.0,s  0.0) jdk.internal.loader.BuiltinClassLoader::findClassOnClassPathOrNull\n        (t  0.0,s  0.0) jdk.internal.loader.ClassLoaders$AppClassLoader::loadClass\n        (t  0.0,s  0.0) java.lang.Class::forName\n\nThe program is as follows:\n\n```\nimport java.util.function.Supplier;\n\npublic class Prof2 {\n\n    public static void main(String[] args) {\n        var rand = new java.util.Random(0);\n        Supplier[] suppliers = {\n                () -> 0,\n                () -> 1,\n                () -> 2,\n                () -> 3,\n        };\n\n        long sum = 0;\n        for (int i = 0; i >= 0; i++) {\n            sum += (int)suppliers[i % suppliers.length].get();\n        }\n    }\n}\n```\n\nWe see that the results are particularely useful in this case as the\nmethods are very short (it only returns an integer), and the probability\nof hitting the prolog is then very high."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"},{"filename":"src\/hotspot\/share\/code\/compiledMethod.hpp"},{"filename":"src\/hotspot\/share\/code\/nmethod.hpp"}],"sha":"df2d275851dbaa26c0f2f572831928be82f3c285"},{"commit":{"message":"Allow AsyncGetCallTrace and JFR to walk a stub frame\n\nWhen the signal sent for AsyncGetCallTrace or JFR would land on a stub\n(like arraycopy), it wouldn't be able to detect the sender (caller)\nframe because `_cb->frame_size() == 0`.\n\nBecause we fully control how the prolog and epilog of stub code is\ngenerated, we know there are two cases:\n1. A stack frame is allocated via macroAssembler->enter(), and consists\nin `push rbp; mov rsp, rbp;`.\n2. No stack frames are allocated and rbp is left unchanged and rsp is\ndecremented with the `call` instruction that push the return `pc` on the\nstack.\n\nFor case 1., we can easily know the sender frame by simply looking at\nrbp, especially since we know that all stubs preserve the frame pointer\n(on x86 at least).\n\nFor case 2., we end up returning the sender's sender, but that already\ngives us more information than what we have today.\n\nThe results are as follows:\n\n- Baseline:\n\nFlat Profile (by method):\n        (t 99.4,s 99.4) AGCT::Unknown Java[ERR=-5]\n        (t  0.5,s  0.2) Prof1::main\n        (t  0.2,s  0.2) java.lang.AbstractStringBuilder::append\n        (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n        (t  0.0,s  0.0) java.lang.AbstractStringBuilder::ensureCapacityInternal\n        (t  0.0,s  0.0) java.lang.AbstractStringBuilder::shift\n        (t  0.0,s  0.0) java.lang.String::getBytes\n        (t  0.0,s  0.0) java.lang.AbstractStringBuilder::putStringAt\n        (t  0.0,s  0.0) java.lang.StringBuilder::delete\n        (t  0.2,s  0.0) java.lang.StringBuilder::append\n        (t  0.0,s  0.0) java.lang.AbstractStringBuilder::delete\n        (t  0.0,s  0.0) java.lang.AbstractStringBuilder::putStringAt\n\n- With StubRoutinesBlob::FrameParser\n\nFlat Profile (by method):\n        (t 98.7,s 98.7) java.lang.AbstractStringBuilder::ensureCapacityInternal\n        (t  0.9,s  0.9) java.lang.AbstractStringBuilder::delete\n        (t 99.8,s  0.2) Prof1::main\n        (t  0.1,s  0.1) AGCT::Unknown not Java[ERR=-3]\n        (t  0.0,s  0.0) AGCT::Unknown Java[ERR=-5]\n        (t 98.8,s  0.0) java.lang.AbstractStringBuilder::append\n        (t 98.8,s  0.0) java.lang.StringBuilder::append\n        (t  0.9,s  0.0) java.lang.StringBuilder::delete\n\nThe program is as follows:\n\n```\npublic class Prof1 {\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 1000000; i++) {\n            sb.append(\"ab\");\n            sb.delete(0, 1);\n        }\n        System.out.println(sb.length());\n    }\n}\n```\n\nWe now account for the arraycopy stub which is called by\nAbstractStringBuilder::ensureCapacityInternal. It was previously ignored\nbecause it would not know how to parse the frame for the arraycopy stub\nand would fall in the AGCT::Unknown Java[ERR=-5] section.\n\nHowever, it still isn't perfect since it doesn't point to the arraycopy stub\ndirectly."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"},{"filename":"src\/hotspot\/share\/runtime\/frame.cpp"},{"filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java"},{"filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubRoutinesBlob.java"}],"sha":"28a090eaa858503b7beded6f94d4237b47062ec0"},{"commit":{"message":"Extract sender frame parsing to CodeBlock::FrameParser\n\nWhether and how a frame is setup is controlled by the code generator\nfor the specific CodeBlock. The CodeBlock is then in the best place to know how\nto parse the sender's frame from the current frame in the given CodeBlock.\n\nThis refactoring proposes to extract this parsing out of `frame` and into a\n`CodeBlock::FrameParser`. This FrameParser is then specialized in the relevant\ninherited children of CodeBlock.\n\nThis change is to largely facilitate adding new supported cases for JDK-8252417\nlike runtime stubs."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp"},{"filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp"},{"filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp"},{"filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp"},{"filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp"},{"filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp"},{"filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.cpp"},{"filename":"src\/hotspot\/share\/code\/codeBlob.hpp"},{"filename":"src\/hotspot\/share\/code\/icBuffer.cpp"},{"filename":"src\/hotspot\/share\/code\/stubs.cpp"},{"filename":"src\/hotspot\/share\/code\/stubs.hpp"},{"filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp"},{"filename":"src\/hotspot\/share\/runtime\/frame.cpp"},{"filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp"},{"filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java"},{"filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/InterpreterBlob.java"},{"filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubRoutinesBlob.java"}],"sha":"b0ecec2efa2aae3f22fcffeda946c67c96b69ffa"}]