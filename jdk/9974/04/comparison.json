{"files":[{"patch":"@@ -341,12 +341,0 @@\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  BasicTypeList signature(0);\n-  CallingConvention* cc = frame_map()->java_calling_convention(&signature, true);\n-\n-  const LIR_Opr result_reg = result_register_for(x->type());\n-  address entry = StubRoutines::cont_doYield();\n-  LIR_Opr result = rlock_result(x);\n-  CodeEmitInfo* info = state_for(x, x->state());\n-  __ call_runtime(entry, LIR_OprFact::illegalOpr, result_reg, cc->args(), info);\n-  __ move(result_reg, result);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1126,0 +1126,56 @@\n+static void gen_continuation_yield(MacroAssembler* masm,\n+                                   const methodHandle& method,\n+                                   const BasicType* sig_bt,\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& stack_slots,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n+    enum layout {\n+      rfp_off1,\n+      rfp_off2,\n+      lr_off,\n+      lr_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+    \/\/ assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+    stack_slots = framesize \/  VMRegImpl::slots_per_word;\n+    assert(stack_slots == 2, \"recheck layout\");\n+\n+    address start = __ pc();\n+\n+    compiled_entry_offset = __ pc() - start;\n+    __ enter();\n+\n+    __ mov(c_rarg1, sp);\n+\n+    frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+\n+    __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+\n+    __ mov(c_rarg0, rthread);\n+    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+    __ call_VM_leaf(Continuation::freeze_entry(), 2);\n+    __ reset_last_Java_frame(true);\n+\n+    Label pinned;\n+\n+    __ cbnz(r0, pinned);\n+\n+    \/\/ We've succeeded, set sp to the ContinuationEntry\n+    __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+    __ mov(sp, rscratch1);\n+    continuation_enter_cleanup(masm);\n+\n+    __ bind(pinned); \/\/ pinned -- return to caller\n+\n+    __ leave();\n+    __ ret(lr);\n+\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(the_pc - start, map);\n+}\n+\n@@ -1210,3 +1266,1 @@\n-  if (method->is_continuation_enter_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n+  if (method->is_continuation_native_intrinsic()) {\n@@ -1219,10 +1273,25 @@\n-    gen_continuation_enter(masm,\n-                         method,\n-                         in_sig_bt,\n-                         in_regs,\n-                         exception_offset,\n-                         oop_maps,\n-                         frame_complete,\n-                         stack_slots,\n-                         interpreted_entry_offset,\n-                         vep_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      gen_continuation_enter(masm,\n+                             method,\n+                             in_sig_bt,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      gen_continuation_yield(masm,\n+                             method,\n+                             in_sig_bt,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n@@ -1240,1 +1309,7 @@\n-    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      _cont_doYield_stub = nm;\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":89,"deletions":14,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -6615,63 +6615,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    const char *name = \"cont_doYield\";\n-\n-    enum layout {\n-      rfp_off1,\n-      rfp_off2,\n-      lr_off,\n-      lr_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-    \/\/ assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-\n-    __ enter();\n-\n-    __ mov(c_rarg1, sp);\n-\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-\n-    __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n-\n-    __ mov(c_rarg0, rthread);\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ call_VM_leaf(Continuation::freeze_entry(), 2);\n-    __ reset_last_Java_frame(true);\n-\n-    Label pinned;\n-\n-    __ cbnz(r0, pinned);\n-\n-    \/\/ We've succeeded, set sp to the ContinuationEntry\n-    __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-    __ mov(sp, rscratch1);\n-    continuation_enter_cleanup(masm);\n-\n-    __ bind(pinned); \/\/ pinned -- return to caller\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-    return stub;\n-  }\n-\n@@ -7851,3 +7788,0 @@\n-    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n-    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                        : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -846,12 +846,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-\n-  address entry = __ pc();\n-  assert(StubRoutines::cont_doYield() != NULL, \"stub not yet generated\");\n-\n-  __ push_cont_fastpath(rthread);\n-  __ far_jump(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::cont_doYield())));\n-\n-  return entry;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1331,4 +1331,0 @@\n-\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n-}\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2962,6 +2962,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n@@ -3078,3 +3072,0 @@\n-    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n-    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                                                                   : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -731,6 +731,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1384,4 +1384,0 @@\n-\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4504,6 +4504,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n@@ -4619,3 +4613,0 @@\n-    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n-    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                        : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -479,6 +479,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,4 +304,0 @@\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3721,6 +3721,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n@@ -3823,3 +3817,0 @@\n-    StubRoutines::_cont_doYield_stub     = generate_cont_doYield();\n-    StubRoutines::_cont_doYield = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                   : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -790,6 +790,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1186,4 +1186,0 @@\n-\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n-}\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2860,6 +2860,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n@@ -2943,3 +2937,0 @@\n-    StubRoutines::_cont_doYield_stub  = generate_cont_doYield();\n-    StubRoutines::_cont_doYield       = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                      : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -485,6 +485,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-  Unimplemented();\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -339,12 +339,0 @@\n-void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n-  BasicTypeList signature(0);\n-  CallingConvention* cc = frame_map()->java_calling_convention(&signature, true);\n-\n-  const LIR_Opr result_reg = result_register_for(x->type());\n-  address entry = StubRoutines::cont_doYield();\n-  LIR_Opr result = rlock_result(x);\n-  CodeEmitInfo* info = state_for(x, x->state());\n-  __ call_runtime(entry, LIR_OprFact::illegalOpr, result_reg, cc->args(), info);\n-  __ move(result_reg, result);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1271,7 +1271,7 @@\n-                                 const VMRegPair* regs,\n-                                 int& exception_offset,\n-                                 OopMapSet* oop_maps,\n-                                 int& frame_complete,\n-                                 int& stack_slots,\n-                                 int& interpreted_entry_offset,\n-                                 int& compiled_entry_offset) {\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& stack_slots,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n@@ -1444,0 +1444,55 @@\n+static void gen_continuation_yield(MacroAssembler* masm,\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& stack_slots,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+  stack_slots = framesize \/  VMRegImpl::slots_per_word;\n+  assert(stack_slots == 2, \"recheck layout\");\n+\n+  address start = __ pc();\n+  compiled_entry_offset = __ pc() - start;\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  frame_complete = the_pc - start;\n+\n+  \/\/ This nop must be exactly at the PC we push into the frame info.\n+  \/\/ We use this nop for fast CodeBlob lookup, associate the OopMap\n+  \/\/ with it right away.\n+  __ post_call_nop();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ movptr(c_rarg1, rsp);\n+  __ call_VM_leaf(Continuation::freeze_entry(), 2);\n+  __ reset_last_Java_frame(true);\n+\n+  Label L_pinned;\n+\n+  __ testptr(rax, rax);\n+  __ jcc(Assembler::notZero, L_pinned);\n+\n+  __ movptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  continuation_enter_cleanup(masm);\n+  __ pop(rbp);\n+  __ ret(0);\n+\n+  __ bind(L_pinned);\n+\n+  \/\/ Pinned, return to caller\n+  __ leave();\n+  __ ret(0);\n+}\n+\n@@ -1528,3 +1583,1 @@\n-  if (method->is_continuation_enter_intrinsic()) {\n-    vmIntrinsics::ID iid = method->intrinsic_id();\n-    intptr_t start = (intptr_t)__ pc();\n+  if (method->is_continuation_native_intrinsic()) {\n@@ -1535,1 +1588,1 @@\n-    OopMapSet* oop_maps =  new OopMapSet();\n+    OopMapSet* oop_maps = new OopMapSet();\n@@ -1537,8 +1590,21 @@\n-    gen_continuation_enter(masm,\n-                         in_regs,\n-                         exception_offset,\n-                         oop_maps,\n-                         frame_complete,\n-                         stack_slots,\n-                         interpreted_entry_offset,\n-                         vep_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      gen_continuation_enter(masm,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      gen_continuation_yield(masm,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n@@ -1556,1 +1622,5 @@\n-    ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      _cont_doYield_stub = nm;\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":90,"deletions":20,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -3985,6 +3985,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n@@ -4169,3 +4163,0 @@\n-    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n-    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                                                                   : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7504,60 +7504,0 @@\n-  RuntimeStub* generate_cont_doYield() {\n-    if (!Continuations::enabled()) return nullptr;\n-\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"cont_doYield\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ enter();\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    \/\/ This nop must be exactly at the PC we push into the frame info.\n-    \/\/ We use this nop for fast CodeBlob lookup, associate the OopMap\n-    \/\/ with it right away.\n-    __ post_call_nop();\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    __ set_last_Java_frame(rsp, rbp, the_pc);\n-    __ movptr(c_rarg0, r15_thread);\n-    __ movptr(c_rarg1, rsp);\n-    __ call_VM_leaf(Continuation::freeze_entry(), 2);\n-    __ reset_last_Java_frame(true);\n-\n-    Label L_pinned;\n-\n-    __ testptr(rax, rax);\n-    __ jcc(Assembler::notZero, L_pinned);\n-\n-    __ movptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n-    continuation_enter_cleanup(_masm);\n-    __ pop(rbp);\n-    __ ret(0);\n-\n-    __ bind(L_pinned);\n-\n-    \/\/ Pinned, return to caller\n-    __ leave();\n-    __ ret(0);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n@@ -7983,3 +7923,0 @@\n-    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n-    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n-                                        : StubRoutines::_cont_doYield_stub->entry_point();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -658,14 +658,0 @@\n-address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n-  if (!Continuations::enabled()) return nullptr;\n-\n-  address entry = __ pc();\n-  assert(StubRoutines::cont_doYield() != NULL, \"stub not yet generated\");\n-\n-  __ push_cont_fastpath();\n-\n-  __ jump(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::cont_doYield())));\n-  \/\/ return value is in rax\n-\n-  return entry;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  case vmIntrinsics::_Continuation_doYield:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3022,4 +3022,0 @@\n-  case vmIntrinsics::_Continuation_doYield:\n-    do_continuation_doYield(x);\n-    break;\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-  void do_continuation_doYield(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  FUNCTION_CASE(entry, StubRoutines::cont_doYield());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+    case vmIntrinsics::_Continuation_enterSpecial:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-  do_intrinsic(_Continuation_doYield,      jdk_internal_vm_Continuation, doYield_name,      continuationDoYield_signature, F_S) \\\n+  do_intrinsic(_Continuation_doYield,      jdk_internal_vm_Continuation, doYield_name,      continuationDoYield_signature, F_SN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-    if (method()->is_continuation_enter_intrinsic()) {\n+    if (method()->is_continuation_native_intrinsic()) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,9 @@\n+  if (nm->method()->is_continuation_yield_intrinsic()) {\n+    return false;\n+  }\n+\n+  if (nm->method()->is_continuation_native_intrinsic()) {\n+    guarantee(false, \"Unknown Continuation native intrinsic\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -153,5 +153,0 @@\n-      case vmIntrinsics::_Continuation_doYield:\n-        if (VMContinuations) {\n-          return java_lang_continuation_doYield;\n-        }\n-        break;\n@@ -171,2 +166,3 @@\n-    if (m->is_continuation_enter_intrinsic()) {\n-      return zerolocals;\n+    if (m->is_continuation_native_intrinsic()) {\n+      \/\/ This entry will never be called.  The real entry gets generated later, like for MH intrinsics.\n+      return abstract;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-    java_lang_continuation_doYield,                             \/\/ implementation of jdk.internal.vm.Continuation.doYield()\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1088,1 +1088,1 @@\n-  if (resolved_method->is_continuation_enter_intrinsic()\n+  if (resolved_method->is_continuation_native_intrinsic()\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,2 +226,0 @@\n-  method_entry(java_lang_continuation_doYield)\n-\n@@ -428,2 +426,0 @@\n-  case Interpreter::java_lang_continuation_doYield\n-                                           : entry_point = generate_Continuation_doYield_entry(); break;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-  address generate_Continuation_doYield_entry();\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -340,1 +340,0 @@\n-  static_field(StubRoutines,                _cont_doYield,                                    address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1241,1 +1241,1 @@\n-  if (h_method->is_continuation_enter_intrinsic()) {\n+  if (h_method->is_continuation_native_intrinsic()) {\n@@ -1245,0 +1245,1 @@\n+    _i2i_entry = NULL;\n@@ -1328,1 +1329,1 @@\n-  if (mh->is_continuation_enter_intrinsic()) {\n+  if (mh->is_continuation_native_intrinsic()) {\n@@ -1331,2 +1332,8 @@\n-    \/\/ This is the entry used when we're in interpreter-only mode; see InterpreterMacroAssembler::jump_from_interpreted\n-    mh->_i2i_entry = ContinuationEntry::interpreted_entry();\n+    if (mh->is_continuation_enter_intrinsic()) {\n+      \/\/ This is the entry used when we're in interpreter-only mode; see InterpreterMacroAssembler::jump_from_interpreted\n+      mh->_i2i_entry = ContinuationEntry::interpreted_entry();\n+    } else if (mh->is_continuation_yield_intrinsic()) {\n+      mh->_i2i_entry = mh->get_i2c_entry();\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -739,0 +739,2 @@\n+  inline bool is_continuation_yield_intrinsic() const;\n+  inline bool is_continuation_native_intrinsic() const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,10 @@\n+\n+inline bool Method::is_continuation_yield_intrinsic() const {\n+  return intrinsic_id() == vmIntrinsics::_Continuation_doYield;\n+}\n+\n+inline bool Method::is_continuation_native_intrinsic() const {\n+  return intrinsic_id() == vmIntrinsics::_Continuation_enterSpecial ||\n+         intrinsic_id() == vmIntrinsics::_Continuation_doYield;\n+}\n+\n@@ -97,1 +107,1 @@\n-  return is_method_handle_intrinsic() || is_continuation_enter_intrinsic();\n+  return is_method_handle_intrinsic() || is_continuation_native_intrinsic();\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -741,1 +741,0 @@\n-  case vmIntrinsics::_Continuation_doYield:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -647,3 +647,0 @@\n-  case vmIntrinsics::_Continuation_doYield:\n-    return inline_continuation_do_yield();\n-\n@@ -7413,9 +7410,0 @@\n-bool LibraryCallKit::inline_continuation_do_yield() {\n-  address call_addr = StubRoutines::cont_doYield();\n-  const TypeFunc* tf = OptoRuntime::continuation_doYield_Type();\n-  Node* call = make_runtime_call(RC_NO_LEAF, tf, call_addr, \"doYield\", TypeRawPtr::BOTTOM);\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -732,31 +732,0 @@\n- const TypeFunc* OptoRuntime::continuation_doYield_Type() {\n-   \/\/ create input type (domain)\n-   const Type **fields = TypeTuple::fields(0);\n-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-   \/\/ create result type (range)\n-   fields = TypeTuple::fields(1);\n-   fields[TypeFunc::Parms+0] = TypeInt::INT;\n-   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n-\n-   return TypeFunc::make(domain, range);\n- }\n-\n- const TypeFunc* OptoRuntime::continuation_jump_Type() {\n-  \/\/ create input type (domain)\n-  const Type **fields = TypeTuple::fields(6);\n-  fields[TypeFunc::Parms+0] = TypeLong::LONG;\n-  fields[TypeFunc::Parms+1] = Type::HALF;\n-  fields[TypeFunc::Parms+2] = TypeLong::LONG;\n-  fields[TypeFunc::Parms+3] = Type::HALF;\n-  fields[TypeFunc::Parms+4] = TypeLong::LONG;\n-  fields[TypeFunc::Parms+5] = Type::HALF;\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+6, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-  return TypeFunc::make(domain, range);\n- }\n-\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -246,2 +246,0 @@\n-  static const TypeFunc* continuation_doYield_Type();\n-  static const TypeFunc* continuation_jump_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -223,1 +224,1 @@\n-\/\/ Called from generate_cont_doYield() in stubGenerator_<cpu>.cpp through Continuation::freeze_entry();\n+\/\/ Called from gen_continuation_yield() in sharedRuntime_<cpu>.cpp through Continuation::freeze_entry();\n@@ -384,0 +385,4 @@\n+#ifdef ASSERT\n+  bool interpreted_native_or_deoptimized_on_stack();\n+#endif\n+\n@@ -483,1 +488,1 @@\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == doYield_stub_frame_size, \"\");\n+  assert(SharedRuntime::cont_doYield_stub()->frame_size() == doYield_stub_frame_size, \"\");\n@@ -557,1 +562,1 @@\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+  assert(SharedRuntime::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n@@ -748,1 +753,0 @@\n-    assert(StubRoutines::cont_doYield_stub()->contains(f.pc()), \"\");\n@@ -756,2 +760,3 @@\n-  assert(StubRoutines::cont_doYield_stub()->contains(f.pc()), \"must be\");\n-  f = sender<ContinuationHelper::StubFrame>(f);\n+  assert(SharedRuntime::cont_doYield_stub()->contains(f.pc()), \"must be\");\n+  f = sender<ContinuationHelper::NonInterpretedUnknownFrame>(f);\n+  assert(Continuation::is_frame_in_continuation(_thread->last_continuation(), f), \"\");\n@@ -775,0 +780,1 @@\n+  assert(Continuation::is_frame_in_continuation(_thread->last_continuation(), f), \"\");\n@@ -1359,3 +1365,3 @@\n-static bool interpreted_native_or_deoptimized_on_stack(JavaThread* thread) {\n-  ContinuationEntry* ce = thread->last_continuation();\n-  RegisterMap map(thread,\n+bool FreezeBase::interpreted_native_or_deoptimized_on_stack() {\n+  ContinuationEntry* ce = _thread->last_continuation();\n+  RegisterMap map(_thread,\n@@ -1366,1 +1372,1 @@\n-  for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n+  for (frame f = freeze_start_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n@@ -1437,1 +1443,1 @@\n-         || (current->cont_fastpath_thread_state() && !interpreted_native_or_deoptimized_on_stack(current)), \"\");\n+         || (current->cont_fastpath_thread_state() && !freeze.interpreted_native_or_deoptimized_on_stack()), \"\");\n@@ -2314,1 +2320,1 @@\n-      if (!cm->method()->is_continuation_enter_intrinsic()) {\n+      if (!cm->method()->is_continuation_native_intrinsic()) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+nmethod*            SharedRuntime::_cont_doYield_stub;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  static nmethod*            _cont_doYield_stub;\n+\n@@ -252,0 +254,5 @@\n+  static nmethod* cont_doYield_stub() {\n+    assert(_cont_doYield_stub != nullptr, \"oops\");\n+    return _cont_doYield_stub;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -176,2 +176,0 @@\n-RuntimeStub* StubRoutines::_cont_doYield_stub = NULL;\n-address StubRoutines::_cont_doYield       = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -254,2 +254,0 @@\n-  static RuntimeStub* _cont_doYield_stub;\n-  static address _cont_doYield;\n@@ -433,2 +431,0 @@\n-  static RuntimeStub* cont_doYield_stub() { return _cont_doYield_stub; }\n-  static address cont_doYield()        { return _cont_doYield; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    private static int doYield() { throw new Error(\"Intrinsic not installed\"); }\n+    private native static int doYield();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}