{"files":[{"patch":"@@ -661,0 +661,2 @@\n+            cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -668,1 +670,7 @@\n-            int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            int caLen;\n+            try {\n+                caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            } catch (CharacterCodingException x) {\n+                \/\/ Substitution is enabled, so this shouldn't happen\n+                throw new Error(x);\n+            }\n@@ -794,1 +802,7 @@\n-        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        int caLen;\n+        try {\n+            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        } catch (CharacterCodingException x) {\n+            \/\/ throw via IAE\n+            throw new IllegalArgumentException(x);\n+        }\n@@ -1202,1 +1216,2 @@\n-    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n+                                            throws CharacterCodingException {\n@@ -1205,14 +1220,6 @@\n-        cd.onMalformedInput(CodingErrorAction.REPLACE)\n-            .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n+        CoderResult cr = cd.decode(bb, cb, true);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n+        cr = cd.flush(cb);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @bug 8286287\n- * @summary Verifies newStringNoRepl() does not throw an Error.\n+ * @bug 8286287 8288589\n+ * @summary Verifies newStringNoRepl() throws a CharacterCodingException.\n@@ -31,0 +31,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -42,0 +43,10 @@\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n@@ -43,6 +54,0 @@\n-        System.out.println(\"Returned bytes: \" +\n-            HexFormat.of()\n-                .withPrefix(\"x\")\n-                .withUpperCase()\n-                .formatHex(Files.readString(f, UTF_16).getBytes(UTF_16)));\n-        Files.delete(f);\n","filename":"test\/jdk\/java\/lang\/String\/NewStringNoRepl.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"}]}