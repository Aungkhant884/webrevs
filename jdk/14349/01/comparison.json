{"files":[{"patch":"@@ -387,0 +387,12 @@\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof Figure)) {\n+            return false;\n+        }\n+        return getInputNode().equals(((Figure)o).getInputNode());\n+    }\n+    @Override\n+    public int hashCode() {\n+        return getInputNode().hashCode();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -159,0 +159,12 @@\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof FigureConnection)) {\n+            return false;\n+        }\n+\n+        return getInputSlot().getFigure().equals(((FigureConnection)o).getInputSlot().getFigure())\n+                && getOutputSlot().getFigure().equals(((FigureConnection)o).getOutputSlot().getFigure())\n+                && getInputSlot().getPosition() == ((FigureConnection)o).getInputSlot().getPosition()\n+                && getOutputSlot().getPosition() == ((FigureConnection) o).getOutputSlot().getPosition();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,43 +82,0 @@\n-    private class LayoutNode {\n-\n-        public int x;\n-        public int y;\n-        public int width;\n-        public int height;\n-        public int layer = -1;\n-        public int xOffset;\n-        public int yOffset;\n-        public int bottomYOffset;\n-        public Vertex vertex; \/\/ Only used for non-dummy nodes, otherwise null\n-\n-        public List<LayoutEdge> preds = new ArrayList<>();\n-        public List<LayoutEdge> succs = new ArrayList<>();\n-        public HashMap<Integer, Integer> outOffsets = new HashMap<>();\n-        public HashMap<Integer, Integer> inOffsets = new HashMap<>();\n-        public int pos = -1; \/\/ Position within layer\n-\n-        public int crossingNumber;\n-\n-        @Override\n-        public String toString() {\n-            return \"Node \" + vertex;\n-        }\n-    }\n-\n-    private class LayoutEdge {\n-\n-        public LayoutNode from;\n-        public LayoutNode to;\n-        \/\/ Horizontal distance relative to start of 'from'.\n-        public int relativeFrom;\n-        \/\/ Horizontal distance relative to start of 'to'.\n-        public int relativeTo;\n-        public Link link;\n-        public boolean vip;\n-\n-        @Override\n-        public String toString() {\n-            return \"Edge \" + from + \", \" + to;\n-        }\n-    }\n-\n@@ -193,0 +150,4 @@\n+    public List<LayoutNode> getNodes() {\n+        return nodes;\n+    }\n+\n@@ -308,1 +269,1 @@\n-                    if (e.link != null) {\n+                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n@@ -389,3 +350,0 @@\n-\n-                        \/\/ No longer needed!\n-                        e.link = null;\n@@ -395,0 +353,1 @@\n+                \/\/ THIS PART MIGHT NOT BE NECESSARY SINCE ALL EDGES CAN BE DRAWN FROM BOTTOM UP\n@@ -396,1 +355,1 @@\n-                    if (e.link != null) {\n+                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n@@ -473,1 +432,0 @@\n-                        e.link = null;\n@@ -834,0 +792,3 @@\n+                            if (!nodes.contains(e.to)) {\n+                                nodes.add(e.to);\n+                            }\n@@ -1224,1 +1185,1 @@\n-                    for (LayoutEdge e : n.succs) {\n+                    for (LayoutEdge e : List.copyOf(n.succs)) {\n@@ -1232,2 +1193,2 @@\n-            LayoutNode n = e.from;\n-            if (e.to.layer > n.layer + 1) {\n+            LayoutNode n = e.to;\n+            if (e.to.layer - 1 > e.from.layer) {\n@@ -1235,1 +1196,1 @@\n-                for (int i = n.layer + 1; i < last.to.layer; i++) {\n+                for (int i = n.layer - 1; i > last.from.layer; i--) {\n@@ -1243,2 +1204,2 @@\n-            n.width = dummyWidth;\n-            n.height = dummyHeight;\n+            n.width = DUMMY_WIDTH;\n+            n.height = DUMMY_HEIGHT;\n@@ -1246,1 +1207,1 @@\n-            n.preds.add(e);\n+            n.succs.add(e);\n@@ -1250,9 +1211,10 @@\n-            n.succs.add(result);\n-            result.from = n;\n-            result.relativeFrom = n.width \/ 2;\n-            result.to = e.to;\n-            result.relativeTo = e.relativeTo;\n-            e.relativeTo = n.width \/ 2;\n-            e.to.preds.remove(e);\n-            e.to.preds.add(result);\n-            e.to = n;\n+            n.preds.add(result);\n+            result.to = n;\n+            result.relativeTo = n.width \/ 2;\n+            result.from = e.from;\n+            result.relativeFrom = e.relativeFrom;\n+            result.link = e.link;\n+            e.relativeFrom = n.width \/ 2;\n+            e.from.succs.remove(e);\n+            e.from.succs.add(result);\n+            e.from = n;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":28,"deletions":66,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,1913 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.LayoutGraph;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.util.*;\n+\n+public class HierarchicalStableLayoutManager {\n+\n+    public static final int DUMMY_HEIGHT = 1;\n+    public static final int DUMMY_WIDTH = 1;\n+    public static final int X_OFFSET = 8;\n+    public static final int LAYER_OFFSET = 8;\n+    \/\/ Algorithm global datastructures\n+    private HashSet<? extends Vertex> currentVertices;\n+    private HashSet<? extends Link> currentLinks;\n+    private Set<Link> reversedLinks;\n+    private List<LayoutNode> nodes;\n+    private final List<LayoutNode> oldNodes;\n+    private final HashMap<Vertex, LayoutNode> vertexToLayoutNode;\n+    private final HashMap<Vertex, LayoutNode> oldVertexToLayoutNode;\n+    private HashMap<Link, List<Point>> reversedLinkStartPoints;\n+    private HashMap<Link, List<Point>> reversedLinkEndPoints;\n+    private HashMap<Integer, List<LayoutNode>> layers;\n+\n+    private final HierarchicalLayoutManager manager;\n+    private HashMap<Vertex, VertexAction> vertexToAction;\n+    private List<VertexAction> vertexActions;\n+    private List<LinkAction> linkActions;\n+    private HashSet<? extends Vertex> oldVertices;\n+    private HashSet<? extends Link> oldLinks;\n+    private boolean shouldRedrawLayout = true;\n+    private boolean shouldRemoveEmptyLayers = true;\n+    private final boolean shouldComputeLayoutScore = false;\n+\n+    enum Action {\n+        ADD,\n+        REMOVE\n+    }\n+\n+    private class VertexAction {\n+        public Vertex vertex;\n+        public List<LinkAction> linkActions = new LinkedList<>();\n+        public Action action;\n+\n+        public VertexAction(Vertex vertex, Action action) {\n+            this.vertex = vertex;\n+            this.action = action;\n+        }\n+    }\n+\n+    private class LinkAction {\n+        public Link link;\n+        public Action action;\n+\n+        public LinkAction(Link link, Action action) {\n+            this.link = link;\n+            this.action = action;\n+        }\n+    }\n+\n+    public HierarchicalStableLayoutManager() {\n+        oldVertices = new HashSet<>();\n+        oldLinks = new HashSet<>();\n+        manager = new HierarchicalLayoutManager(HierarchicalLayoutManager.Combine.SAME_OUTPUTS);\n+        vertexToLayoutNode = new HashMap<>();\n+        nodes = new ArrayList<>();\n+        oldVertexToLayoutNode = new HashMap<>();\n+        oldNodes = new ArrayList<>();\n+    }\n+\n+    private int calculateOptimalBoth(LayoutNode n) {\n+        if (n.preds.size() == 0 && n.succs.size() == 0) {\n+            return n.x;\n+        }\n+\n+        int[] values = new int[n.preds.size() + n.succs.size()];\n+        int i = 0;\n+\n+        for (LayoutEdge e : n.preds) {\n+            values[i] = e.from.x + e.relativeFrom - e.relativeTo;\n+            i++;\n+        }\n+\n+        for (LayoutEdge e : n.succs) {\n+            values[i] = e.to.x + e.relativeTo - e.relativeFrom;\n+            i++;\n+        }\n+\n+        return median(values);\n+    }\n+\n+    private int median(int[] values) {\n+        Arrays.sort(values);\n+        if (values.length % 2 == 0) {\n+            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n+        } else {\n+            return values[values.length \/ 2];\n+        }\n+    }\n+\n+    \/**\n+     * Adjust the X-coordinates of the nodes in the given layer, as a new node has\n+     * been inserted at that layer\n+     *\n+     * @param newNode\n+     * @param layer\n+     *\/\n+    private void adjustXCoordinates(int layer) {\n+        List<LayoutNode> nodes = layers.get(layer);\n+        ArrayList<Integer> space = new ArrayList<>();\n+        List<LayoutNode> nodeProcessingOrder = new ArrayList<>();\n+\n+        nodes.sort(nodePositionComparator);\n+\n+        int curX = 0;\n+        for (LayoutNode n : nodes) {\n+            space.add(curX);\n+            curX += n.width + X_OFFSET;\n+            nodeProcessingOrder.add(n);\n+        }\n+\n+        nodeProcessingOrder.sort(nodeProcessingUpComparator);\n+        NodeRow r = new NodeRow(space);\n+        for (LayoutNode n : nodeProcessingOrder) {\n+            int optimal = calculateOptimalBoth(n);\n+            r.insert(n, optimal);\n+        }\n+    }\n+\n+    \/**\n+     * Ensure that the datastructures nodes and layerNodes are consistent\n+     *\/\n+    private void sanityCheckNodesAndLayerNodes() {\n+        int nodeCount = 0;\n+        for (int i = 0; i < layers.keySet().size(); i++) {\n+            assert layers.containsKey(i);\n+            layers.get(i).sort(nodePositionComparator);\n+            int nodePos = 0;\n+            for (LayoutNode n : layers.get(i)) {\n+                assert n.layer == i;\n+                assert nodes.contains(n);\n+                assert n.pos == nodePos;\n+                nodePos += 1;\n+                nodeCount += 1;\n+            }\n+        }\n+        for (LayoutNode n : nodes) {\n+            assert n.vertex == null || vertexToLayoutNode.get(n.vertex).equals(n);\n+            assert n.layer < layers.keySet().size();\n+            assert layers.get(n.layer).contains(n);\n+        }\n+        assert nodeCount == nodes.size();\n+    }\n+\n+    private void sanityCheckEdges() {\n+        for (LayoutNode n : nodes) {\n+            for (LayoutEdge e : List.copyOf(n.succs)) {\n+                assert e.from.equals(n);\n+                if (nodes.contains(e.to)) {\n+                    assert e.to.preds.contains(e);\n+                    assert layers.get(n.layer + 1).contains(e.to);\n+                    assert e.to.layer == n.layer + 1;\n+                } else {\n+                    n.succs.remove(e);\n+                }\n+            }\n+            for (LayoutEdge e : List.copyOf(n.preds)) {\n+                assert e.to.equals(n);\n+                if (nodes.contains(e.from)) {\n+                    assert e.from.succs.contains(e);\n+                    assert layers.get(n.layer - 1).contains(e.from);\n+                    assert e.from.layer == n.layer - 1;\n+                } else {\n+                    n.preds.remove(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final Comparator<VertexAction> vertexActionComparator = (a1, a2) -> {\n+        if (a1.action == Action.REMOVE) {\n+            if (a2.action == Action.REMOVE) {\n+                return a2.linkActions.size() - a1.linkActions.size();\n+            }\n+            return -1;\n+        }\n+        if (a2.action == Action.REMOVE) {\n+            return 1;\n+        }\n+\n+        return a1.linkActions.size() - a2.linkActions.size();\n+    };\n+\n+    private void generateActions() {\n+        HashSet<Link> oldLinks = new HashSet<>(this.oldLinks);\n+\n+        HashSet<Vertex> addedVertices = new HashSet<>(currentVertices);\n+        addedVertices.removeAll(oldVertices);\n+\n+        HashSet<Vertex> removedVertices = new HashSet<>(oldVertices);\n+        removedVertices.removeAll(currentVertices);\n+\n+        HashSet<Link> addedLinks = new HashSet<>(currentLinks);\n+        HashSet<Link> removedLinks = new HashSet<>(oldLinks);\n+        for (Link link1 : currentLinks) {\n+            for (Link link2 : oldLinks) {\n+                if (link1.equals(link2)) {\n+                    addedLinks.remove(link1);\n+                    removedLinks.remove(link2);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (Vertex v : addedVertices) {\n+            VertexAction a = new VertexAction(v, Action.ADD);\n+            vertexActions.add(a);\n+            vertexToAction.put(v, a);\n+        }\n+\n+        for (Vertex v : removedVertices) {\n+            VertexAction a = new VertexAction(v, Action.REMOVE);\n+            vertexActions.add(a);\n+            vertexToAction.put(v, a);\n+        }\n+\n+        for (Link l : addedLinks) {\n+            Vertex to = l.getTo().getVertex();\n+            Vertex from = l.getFrom().getVertex();\n+            LinkAction a = new LinkAction(l, Action.ADD);\n+\n+            if (addedVertices.contains(to)) {\n+                vertexToAction.get(to).linkActions.add(a);\n+            }\n+            if (addedVertices.contains(from)) {\n+                vertexToAction.get(from).linkActions.add(a);\n+            }\n+            if (!addedVertices.contains(to) && !addedVertices.contains(from)) {\n+                linkActions.add(a);\n+            }\n+        }\n+\n+        for (Link l : removedLinks) {\n+            Vertex to = l.getTo().getVertex();\n+            Vertex from = l.getFrom().getVertex();\n+            LinkAction a = new LinkAction(l, Action.REMOVE);\n+\n+            if (removedVertices.contains(to)) {\n+                vertexToAction.get(to).linkActions.add(a);\n+            }\n+            if (removedVertices.contains(from)) {\n+                vertexToAction.get(from).linkActions.add(a);\n+            }\n+            if (!removedVertices.contains(to) && !removedVertices.contains(from)) {\n+                linkActions.add(a);\n+            }\n+        }\n+\n+        vertexActions.sort(vertexActionComparator);\n+    }\n+\n+    private void findInitialReversedLinks() {\n+        for (Link link : oldLinks) {\n+            for (Link l : currentLinks) {\n+                if (l.equals(link)) {\n+                    if (vertexToLayoutNode.get(l.getFrom().getVertex()).layer > vertexToLayoutNode\n+                            .get(l.getTo().getVertex()).layer) {\n+                        \/\/ Link is reversed\n+                        reversedLinks.add(l);\n+                        updateReversedLinkPositions(l);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void updateReversedLinkPositions(Link link) {\n+        LayoutNode fromNode = vertexToLayoutNode.get(link.getFrom().getVertex());\n+        LayoutNode toNode = vertexToLayoutNode.get(link.getTo().getVertex());\n+        \/\/ Correct direction, is reversed link\n+        assert fromNode != null && toNode != null;\n+        assert nodes.contains(fromNode) && nodes.contains(toNode);\n+        assert fromNode.layer > toNode.layer;\n+        assert reversedLinks.contains(link);\n+\n+        updateNodeWithReversedEdges(fromNode);\n+        updateNodeWithReversedEdges(toNode);\n+    }\n+\n+    private void updateNodeWithReversedEdges(LayoutNode node) {\n+        \/\/ Reset node data in case there were previous reversed edges\n+        node.width = (int) node.vertex.getSize().getWidth();\n+        node.height = (int) node.vertex.getSize().getHeight();\n+        node.yOffset = 0;\n+        node.bottomYOffset = 0;\n+        node.xOffset = 0;\n+        node.inOffsets.clear();\n+        node.outOffsets.clear();\n+\n+        SortedSet<Integer> reversedDown = new TreeSet<>();\n+\n+        \/\/ Reset relativeFrom for all succ edges\n+        for (LayoutEdge e : node.succs) {\n+            if (e.link == null) {\n+                continue;\n+            }\n+            e.relativeFrom = e.link.getFrom().getRelativePosition().x;\n+            if (reversedLinks.contains(e.link)) {\n+                e.relativeFrom = e.link.getTo().getRelativePosition().x;\n+                reversedDown.add(e.relativeFrom);\n+            }\n+        }\n+\n+        \/\/ Whether the node has non-self reversed edges going downwards.\n+        \/\/ If so, reversed edges going upwards are drawn to the left.\n+        boolean hasReversedDown = reversedDown.size() > 0;\n+\n+        SortedSet<Integer> reversedUp = null;\n+        if (hasReversedDown) {\n+            reversedUp = new TreeSet<>();\n+        } else {\n+            reversedUp = new TreeSet<>(Collections.reverseOrder());\n+        }\n+\n+        \/\/ Reset relativeTo for all pred edges\n+        for (LayoutEdge e : node.preds) {\n+            if (e.link == null) {\n+                continue;\n+            }\n+            e.relativeTo = e.link.getTo().getRelativePosition().x;\n+            if (reversedLinks.contains(e.link)) {\n+                e.relativeTo = e.link.getFrom().getRelativePosition().x;\n+                reversedUp.add(e.relativeTo);\n+            }\n+        }\n+\n+        final int offset = X_OFFSET + DUMMY_WIDTH;\n+\n+        int curY = 0;\n+        int curWidth = node.width + reversedDown.size() * offset;\n+        for (int pos : reversedDown) {\n+            ArrayList<LayoutEdge> reversedSuccs = new ArrayList<>();\n+            for (LayoutEdge e : node.succs) {\n+                if (e.relativeFrom == pos && reversedLinks.contains(e.link)) {\n+                    reversedSuccs.add(e);\n+                    e.relativeFrom = curWidth;\n+                }\n+            }\n+\n+            ArrayList<Point> startPoints = new ArrayList<>();\n+            startPoints.add(new Point(curWidth, curY));\n+            startPoints.add(new Point(pos, curY));\n+            startPoints.add(new Point(pos, reversedDown.size() * offset));\n+            for (LayoutEdge e : reversedSuccs) {\n+                reversedLinkStartPoints.put(e.link, startPoints);\n+            }\n+\n+            node.inOffsets.put(pos, -curY);\n+            curY += offset;\n+            node.height += offset;\n+            node.yOffset += offset;\n+            curWidth -= offset;\n+        }\n+\n+        int widthFactor = reversedDown.size();\n+        node.width += widthFactor * offset;\n+\n+        int curX = 0;\n+        int minX = 0;\n+        if (hasReversedDown) {\n+            minX = -offset * reversedUp.size();\n+        }\n+\n+        int oldNodeHeight = node.height;\n+        for (int pos : reversedUp) {\n+            ArrayList<LayoutEdge> reversedPreds = new ArrayList<>();\n+            for (LayoutEdge e : node.preds) {\n+                if (e.relativeTo == pos && reversedLinks.contains(e.link)) {\n+                    if (hasReversedDown) {\n+                        e.relativeTo = curX - offset;\n+                    } else {\n+                        e.relativeTo = node.width + offset;\n+                    }\n+\n+                    reversedPreds.add(e);\n+                }\n+            }\n+            node.height += offset;\n+            ArrayList<Point> endPoints = new ArrayList<>();\n+\n+            node.width += offset;\n+            if (hasReversedDown) {\n+                curX -= offset;\n+                endPoints.add(new Point(curX, node.height));\n+            } else {\n+                curX += offset;\n+                endPoints.add(new Point(node.width, node.height));\n+            }\n+\n+            node.outOffsets.put(pos - minX, curX);\n+            curX += offset;\n+            node.bottomYOffset += offset;\n+\n+            endPoints.add(new Point(pos, node.height));\n+            endPoints.add(new Point(pos, oldNodeHeight));\n+            for (LayoutEdge e : reversedPreds) {\n+                reversedLinkEndPoints.put(e.link, endPoints);\n+            }\n+        }\n+\n+        if (minX < 0) {\n+            for (LayoutEdge e : node.preds) {\n+                e.relativeTo -= minX;\n+            }\n+\n+            for (LayoutEdge e : node.succs) {\n+                e.relativeFrom -= minX;\n+            }\n+\n+            node.xOffset = -minX;\n+            node.width += -minX;\n+        }\n+    }\n+\n+    \/**\n+     * Used to compare nodes across consecutive graphs\n+     *\/\n+    private void copyOldNodes() {\n+        oldNodes.clear();\n+        oldVertexToLayoutNode.clear();\n+        for (LayoutNode node : nodes) {\n+            if (node.vertex != null) {\n+                LayoutNode nodeCopy = new LayoutNode();\n+                nodeCopy.x = node.x;\n+                nodeCopy.y = node.y;\n+                nodeCopy.xOffset = node.xOffset;\n+                nodeCopy.yOffset = node.yOffset;\n+                oldVertexToLayoutNode.put(node.vertex, nodeCopy);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Indicate that the layout should be redrawn with a static algorithm\n+     *\/\n+    public void setShouldRedrawLayout(boolean shouldRedrawLayout) {\n+        this.shouldRedrawLayout = shouldRedrawLayout;\n+    }\n+\n+    public void updateLayout(HashSet<? extends Vertex> vertices, HashSet<? extends Link> links) {\n+        currentVertices = vertices;\n+        currentLinks = links;\n+        reversedLinks = new HashSet<>();\n+        reversedLinkStartPoints = new HashMap<>();\n+        reversedLinkEndPoints = new HashMap<>();\n+        vertexActions = new LinkedList<>();\n+        linkActions = new LinkedList<>();\n+        vertexToAction = new HashMap<>();\n+\n+        new ProcessInput().run();\n+\n+        if (shouldRedrawLayout) {\n+            \/\/ If the layout is too messy it should be redrawn using the static algorithm,\n+            \/\/ currently HierarchicalLayoutManager\n+            manager.doLayout(new LayoutGraph(links, vertices));\n+            nodes = manager.getNodes();\n+            shouldRedrawLayout = false;\n+        } else {\n+            generateActions();\n+\n+            new BuildDatastructure().run();\n+\n+            findInitialReversedLinks();\n+\n+            \/\/ Only apply updates if there are any\n+            if (linkActions.size() > 0 || vertexActions.size() > 0) {\n+                new ApplyActionUpdates().run();\n+            }\n+\n+            new AssignYCoordinates().run();\n+\n+            new WriteResult().run();\n+\n+            if (shouldComputeLayoutScore) {\n+                new ComputeLayoutScore().run();\n+            }\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        copyOldNodes();\n+        oldVertices = new HashSet<>(currentVertices);\n+        oldLinks = new HashSet<>(currentLinks);\n+    }\n+\n+    private class ProcessInput {\n+        public void removeDuplicateLinks() {\n+            HashSet<Link> links = new HashSet<>();\n+            for (Link link : currentLinks) {\n+                if (link.getTo().getVertex().equals(link.getFrom().getVertex())) {\n+                    \/\/ self-edge\n+                    continue;\n+                }\n+                links.add(link);\n+            }\n+            currentLinks = links;\n+        }\n+\n+        private void run() {\n+            removeDuplicateLinks();\n+        }\n+    }\n+\n+    private class BuildDatastructure {\n+\n+        \/\/ In case there are changes in the node size, it's layer must be updated\n+        Set<Integer> layersToUpdate = new HashSet<>();\n+\n+        \/**\n+         * Update the vertex and link object references to the current vertices and\n+         * links, resetting any temporary changes caused by previous layout\n+         *\/\n+        private void updateNodeObjects() {\n+            for (LayoutNode node : nodes) {\n+                if (node.vertex != null) {\n+                    for (Vertex vertex : currentVertices) {\n+                        if (vertex.equals(node.vertex)) {\n+                            Dimension size = vertex.getSize();\n+                            if (node.width < (int) size.getWidth()) {\n+                                layersToUpdate.add(node.layer);\n+                            }\n+                            node.width = (int) size.getWidth();\n+                            node.height = (int) size.getHeight();\n+                            node.vertex = vertex;\n+                        }\n+                    }\n+                    vertexToLayoutNode.put(node.vertex, node);\n+                } else {\n+                    node.height = DUMMY_HEIGHT;\n+                    node.width = DUMMY_WIDTH;\n+                }\n+                for (LayoutEdge edge : node.preds) {\n+                    if (edge.link != null) {\n+                        for (Link link : currentLinks) {\n+                            if (link.equals(edge.link)) {\n+                                edge.link = link;\n+                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                                    \/\/ reversed link\n+                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n+                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                } else {\n+                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n+                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                }\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                for (LayoutEdge edge : node.succs) {\n+                    if (edge.link != null) {\n+                        for (Link link : currentLinks) {\n+                            if (link.equals(edge.link)) {\n+                                edge.link = link;\n+                                if (link.getTo().getVertex().equals(edge.from.vertex)) {\n+                                    \/\/ reversed link\n+                                    edge.relativeFrom = link.getTo().getRelativePosition().x;\n+                                    edge.relativeTo = link.getFrom().getRelativePosition().x;\n+                                } else {\n+                                    edge.relativeFrom = link.getFrom().getRelativePosition().x;\n+                                    edge.relativeTo = link.getTo().getRelativePosition().x;\n+                                }\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Store the nodes that each layer contains\n+         *\/\n+        private void storeNodeLayers() {\n+            layers = new HashMap<>();\n+            for (LayoutNode node : nodes) {\n+                if (!layers.containsKey(node.layer)) {\n+                    layers.put(node.layer, new ArrayList<>());\n+                }\n+                layers.get(node.layer).add(node);\n+            }\n+            for (int i = 0; i < layers.keySet().size(); i++) {\n+                if (!layers.containsKey(i)) {\n+                    layers.put(i, new ArrayList<>());\n+                }\n+            }\n+        }\n+\n+        private void updateLayersXCoords() {\n+            for (Integer i : layersToUpdate) {\n+                adjustXCoordinates(i);\n+            }\n+        }\n+\n+        private void run() {\n+            updateNodeObjects();\n+            storeNodeLayers();\n+            updateLayersXCoords();\n+            sanityCheckNodesAndLayerNodes();\n+        }\n+    }\n+\n+    private class ApplyActionUpdates {\n+        \/**\n+         * Find the optimal position within the given layer to insert the given node.\n+         * The optimum is given by the least amount of edge crossings.\n+         *\n+         * @param node\n+         * @param layer\n+         * @return The optimal position within given layer\n+         *\/\n+        private int optimalPosition(LayoutNode node, int layer) {\n+            assert layers.keySet().contains(layer);\n+\n+            List<LayoutNode> layerNodes = layers.get(layer);\n+            layerNodes.sort(nodePositionComparator);\n+            int edgeCrossings = Integer.MAX_VALUE;\n+            int optimalPos = -1;\n+\n+            \/\/ Try each possible position in the layer\n+            for (int i = 0; i < layerNodes.size() + 1; i++) {\n+                int xCoord;\n+                if (i == 0) {\n+                    xCoord = layerNodes.get(i).x - node.width - 1;\n+                } else {\n+                    xCoord = layerNodes.get(i - 1).x + layerNodes.get(i - 1).width + 1;\n+                }\n+\n+                int currentCrossings = 0;\n+\n+                if (layers.keySet().contains(layer - 1)) {\n+                    List<LayoutNode> predNodes = layers.get(layer - 1);\n+                    \/\/ For each link with an end point in vertex, check how many edges crosses it\n+                    for (LayoutEdge edge : node.preds) {\n+                        if (edge.from.layer == layer - 1) {\n+                            int fromNodeXCoord = edge.from.x;\n+                            if (edge.from.vertex != null) {\n+                                fromNodeXCoord += edge.relativeFrom;\n+                            }\n+                            int toNodeXCoord = xCoord;\n+                            if (node.vertex != null) {\n+                                toNodeXCoord += edge.relativeTo;\n+                            }\n+                            for (LayoutNode n : predNodes) {\n+                                for (LayoutEdge e : n.succs) {\n+                                    if (e.to == null) {\n+                                        continue;\n+                                    }\n+                                    int compFromXCoord = e.from.x;\n+                                    if (e.from.vertex != null) {\n+                                        compFromXCoord += e.relativeFrom;\n+                                    }\n+                                    int compToXCoord = e.to.x;\n+                                    if (e.to.vertex != null) {\n+                                        compToXCoord += e.relativeTo;\n+                                    }\n+                                    if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                            || (fromNodeXCoord < compFromXCoord\n+                                            && toNodeXCoord > compToXCoord)) {\n+                                        currentCrossings += 1;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                \/\/ Edge crossings across current layer and layer below\n+                if (layers.keySet().contains(layer + 1)) {\n+                    List<LayoutNode> succsNodes = layers.get(layer + 1);\n+                    \/\/ For each link with an end point in vertex, check how many edges crosses it\n+                    for (LayoutEdge edge : node.succs) {\n+                        if (edge.to.layer == layer + 1) {\n+                            int toNodeXCoord = edge.to.x;\n+                            if (edge.to.vertex != null) {\n+                                toNodeXCoord += edge.relativeTo;\n+                            }\n+                            int fromNodeXCoord = xCoord;\n+                            if (node.vertex != null) {\n+                                fromNodeXCoord += edge.relativeFrom;\n+                            }\n+                            for (LayoutNode n : succsNodes) {\n+                                for (LayoutEdge e : n.preds) {\n+                                    if (e.from == null) {\n+                                        continue;\n+                                    }\n+                                    int compFromXCoord = e.from.x;\n+                                    if (e.from.vertex != null) {\n+                                        compFromXCoord += e.relativeFrom;\n+                                    }\n+                                    int compToXCoord = e.to.x;\n+                                    if (e.to.vertex != null) {\n+                                        compToXCoord += e.relativeTo;\n+                                    }\n+                                    if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                            || (fromNodeXCoord < compFromXCoord\n+                                            && toNodeXCoord > compToXCoord)) {\n+                                        currentCrossings += 1;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if (currentCrossings <= edgeCrossings) {\n+                    edgeCrossings = currentCrossings;\n+                    optimalPos = i;\n+                }\n+            }\n+            assert optimalPos != -1;\n+            return optimalPos;\n+        }\n+\n+        \/**\n+         * Insert node at the assigned layer, updating the positions of the nodes within\n+         * the layer\n+         *\n+         * @param node\n+         * @param layer\n+         *\/\n+        private void insertNode(LayoutNode node, int layer) {\n+            assert layers.keySet().contains(layer) || layer == 0;\n+\n+            node.layer = layer;\n+            List<LayoutNode> layerNodes = layers.getOrDefault(layer, new ArrayList<LayoutNode>());\n+\n+            if (layerNodes.size() == 0) {\n+                node.pos = 0;\n+            } else {\n+                node.pos = optimalPosition(node, layer);\n+            }\n+\n+            for (LayoutNode n : layerNodes) {\n+                if (n.pos >= node.pos) {\n+                    n.pos += 1;\n+                }\n+            }\n+            layerNodes.add(node);\n+            layers.put(layer, layerNodes);\n+\n+            if (!nodes.contains(node)) {\n+                nodes.add(node);\n+            }\n+            if (node.vertex != null) {\n+                vertexToLayoutNode.put(node.vertex, node);\n+            }\n+\n+            adjustXCoordinates(layer);\n+\n+            sanityCheckNodesAndLayerNodes();\n+        }\n+\n+        private void processSingleEdge(LayoutEdge e) {\n+            LayoutNode n = e.to;\n+            if (e.to.layer - 1 > e.from.layer) {\n+                LayoutEdge last = e;\n+                for (int i = n.layer - 1; i > last.from.layer; i--) {\n+                    last = addBetween(last, i);\n+                }\n+            }\n+        }\n+\n+        private LayoutEdge addBetween(LayoutEdge e, int layer) {\n+            LayoutNode n = new LayoutNode();\n+            n.width = DUMMY_WIDTH;\n+            n.height = DUMMY_HEIGHT;\n+            n.succs.add(e);\n+            LayoutEdge result = new LayoutEdge();\n+            result.vip = e.vip;\n+            n.preds.add(result);\n+            result.to = n;\n+            result.relativeTo = n.width \/ 2;\n+            result.from = e.from;\n+            result.relativeFrom = e.relativeFrom;\n+            result.link = e.link;\n+            e.relativeFrom = n.width \/ 2;\n+            e.from.succs.remove(e);\n+            e.from.succs.add(result);\n+            e.from = n;\n+            insertNode(n, layer);\n+            return result;\n+        }\n+\n+        private void insertDummyNodes(LayoutEdge edge) {\n+            LayoutNode from = edge.from;\n+            LayoutNode to = edge.to;\n+\n+            boolean hasEdgeFromSamePort = false;\n+            LayoutEdge edgeFromSamePort = new LayoutEdge();\n+\n+            for (LayoutEdge e : edge.from.succs) {\n+                if (e.relativeFrom == edge.relativeFrom && e.to.vertex == null) {\n+                    edgeFromSamePort = e;\n+                    hasEdgeFromSamePort = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!hasEdgeFromSamePort) {\n+                processSingleEdge(edge);\n+            } else {\n+                LayoutEdge curEdge = edgeFromSamePort;\n+                boolean newEdge = true;\n+                while (curEdge.to.layer < to.layer - 1 && curEdge.to.vertex == null && newEdge) {\n+                    \/\/ Traverse down the chain of dummy nodes linking together the edges originating\n+                    \/\/ from the same port\n+                    newEdge = false;\n+                    if (curEdge.to.succs.size() == 1) {\n+                        curEdge = curEdge.to.succs.get(0);\n+                        newEdge = true;\n+                    } else {\n+                        for (LayoutEdge e : curEdge.to.succs) {\n+                            if (e.to.vertex == null) {\n+                                curEdge = e;\n+                                newEdge = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                LayoutNode prevDummy;\n+                if (curEdge.to.vertex != null) {\n+                    prevDummy = curEdge.from;\n+                } else {\n+                    prevDummy = curEdge.to;\n+                }\n+\n+                edge.from = prevDummy;\n+                edge.relativeFrom = prevDummy.width \/ 2;\n+                from.succs.remove(edge);\n+                prevDummy.succs.add(edge);\n+                processSingleEdge(edge);\n+            }\n+        }\n+\n+        private boolean canMoveNodeUp(LayoutNode node) {\n+            if (node.layer == 0) {\n+                return false;\n+            }\n+            int newLayer = node.layer - 1;\n+            for (LayoutEdge e : node.preds) {\n+                if (e.from.vertex != null && e.from.layer == newLayer) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private boolean canMoveNodeDown(LayoutNode node) {\n+            if (node.layer == layers.keySet().size() - 1) {\n+                return false;\n+            }\n+            int newLayer = node.layer + 1;\n+            for (LayoutEdge e : node.succs) {\n+                if (e.to.vertex != null && e.to.layer == newLayer) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private void moveNodeUp(LayoutNode node) {\n+            assert canMoveNodeUp(node);\n+\n+            List<LayoutEdge> previousPredEdges = List.copyOf(node.preds);\n+            for (LayoutEdge edge : previousPredEdges) {\n+                LayoutNode predNode = edge.from;\n+                assert predNode.vertex == null;\n+                for (LayoutEdge e : predNode.preds) {\n+                    e.to = edge.to;\n+                    e.relativeTo = edge.relativeTo;\n+                    node.preds.add(e);\n+                    node.preds.remove(edge);\n+                }\n+                removeNodeWithoutRemovingLayer(predNode);\n+            }\n+\n+            removeNodeWithoutRemovingLayer(node);\n+            insertNode(node, node.layer - 1);\n+\n+            for (LayoutEdge edge : List.copyOf(node.succs)) {\n+                processSingleEdge(edge);\n+            }\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        private void moveNodeDown(LayoutNode node) {\n+            assert canMoveNodeDown(node);\n+\n+            List<LayoutEdge> previousSuccEdges = List.copyOf(node.succs);\n+            for (LayoutEdge edge : previousSuccEdges) {\n+                LayoutNode succNode = edge.to;\n+                assert succNode.vertex == null;\n+                for (LayoutEdge e : succNode.succs) {\n+                    e.from = edge.from;\n+                    e.relativeFrom = edge.relativeFrom;\n+                    node.succs.add(e);\n+                    node.succs.remove(edge);\n+                }\n+                removeNodeWithoutRemovingLayer(succNode);\n+            }\n+\n+            removeNodeWithoutRemovingLayer(node);\n+            insertNode(node, node.layer + 1);\n+\n+            for (LayoutEdge edge : List.copyOf(node.preds)) {\n+                processSingleEdge(edge);\n+            }\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        private void handleNeighborNodesOnSameLayer(LayoutNode from, LayoutNode to) {\n+            if (canMoveNodeDown(to)) {\n+                moveNodeDown(to);\n+            } else if (canMoveNodeUp(from)) {\n+                moveNodeUp(from);\n+            } else {\n+                expandNewLayerBeneath(to);\n+            }\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        \/**\n+         * Create a new layer at node.layer + 1 and move the given node there. Adjust\n+         * remaining layers numbers\n+         *\n+         * @param node\n+         *\/\n+        private void expandNewLayerBeneath(LayoutNode node) {\n+            sanityCheckEdges();\n+            sanityCheckNodesAndLayerNodes();\n+            int layer = node.layer + 1;\n+\n+            \/\/ Move all necessary layers down one step\n+            for (int i = layers.size() - 1; i >= layer; i--) {\n+                List<LayoutNode> list = layers.get(i);\n+                for (LayoutNode n : list) {\n+                    n.layer = i + 1;\n+                }\n+                layers.remove(i);\n+                layers.put(i + 1, list);\n+            }\n+\n+            \/\/ Create new empty layer\n+            List<LayoutNode> l = new ArrayList<>();\n+            layers.put(layer, l);\n+\n+            sanityCheckNodesAndLayerNodes();\n+            assert layers.get(layer).size() == 0;\n+            for (LayoutNode n : nodes) {\n+                assert n.layer != layer;\n+            }\n+\n+            \/\/ Add dummy nodes for edges going across new layer. One for each port on the\n+            \/\/ nodes that has outgoing edges\n+            List<LayoutNode> predLayer = List.copyOf(layers.get(layer - 1));\n+            for (LayoutNode n : predLayer) {\n+                HashMap<Integer, List<LayoutEdge>> portHashes = new HashMap<>();\n+\n+                for (LayoutEdge e : n.succs) {\n+                    if (!portHashes.keySet().contains(e.relativeFrom)) {\n+                        portHashes.put(e.relativeFrom, new ArrayList<>());\n+                    }\n+                    portHashes.get(e.relativeFrom).add(e);\n+                }\n+\n+                for (Integer i : portHashes.keySet()) {\n+                    List<LayoutEdge> edges = portHashes.get(i);\n+\n+                    LayoutNode dummy = new LayoutNode();\n+                    dummy.width = DUMMY_WIDTH;\n+                    dummy.height = DUMMY_HEIGHT;\n+\n+                    LayoutEdge newEdge = new LayoutEdge();\n+                    newEdge.from = n;\n+                    newEdge.relativeFrom = i;\n+                    newEdge.to = dummy;\n+                    newEdge.relativeTo = dummy.width \/ 2;\n+                    newEdge.link = edges.get(0).link; \/\/ issue?\n+                    n.succs.add(newEdge);\n+                    dummy.preds.add(newEdge);\n+\n+                    for (LayoutEdge e : edges) {\n+                        e.from = dummy;\n+                        e.relativeFrom = dummy.width \/ 2;\n+                        n.succs.remove(e);\n+                        dummy.succs.add(e);\n+                        assert e.to.layer == layer + 1;\n+                    }\n+\n+                    insertNode(dummy, layer);\n+                }\n+            }\n+\n+            \/\/ Move node to new layer\n+            moveNodeDown(node);\n+            assert layers.get(layer).contains(node);\n+            assert node.layer == layer;\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        private void applyAddLinkAction(Link l) {\n+            Vertex from = l.getFrom().getVertex();\n+            Vertex to = l.getTo().getVertex();\n+            LayoutNode fromNode = vertexToLayoutNode.get(from);\n+            LayoutNode toNode = vertexToLayoutNode.get(to);\n+\n+            if (!nodes.contains(fromNode) || !nodes.contains(toNode) || to.equals(from)) {\n+                return;\n+            }\n+\n+            if (toNode.layer == fromNode.layer) {\n+                handleNeighborNodesOnSameLayer(fromNode, toNode);\n+            }\n+\n+            LayoutEdge edge = new LayoutEdge();\n+            edge.link = l;\n+            edge.from = fromNode;\n+            edge.relativeFrom = l.getFrom().getRelativePosition().x;\n+            edge.to = toNode;\n+            edge.relativeTo = l.getTo().getRelativePosition().x;\n+\n+            boolean reversedLink = fromNode.layer > toNode.layer;\n+            if (reversedLink) {\n+                \/\/ Reversed link\n+                reversedLinks.add(l);\n+\n+                LayoutNode temp = fromNode;\n+                fromNode = toNode;\n+                toNode = temp;\n+\n+                int oldRelativeFrom = edge.relativeFrom;\n+                int oldRelativeTo = edge.relativeTo;\n+\n+                edge.from = fromNode;\n+                edge.to = toNode;\n+                edge.relativeFrom = oldRelativeTo;\n+                edge.relativeTo = oldRelativeFrom;\n+            }\n+\n+            fromNode.succs.add(edge);\n+            toNode.preds.add(edge);\n+\n+            if (reversedLink) {\n+                updateReversedLinkPositions(l);\n+            }\n+\n+            if (fromNode.layer != toNode.layer - 1) {\n+                \/\/ Edge span multiple layers - must insert dummy nodes\n+                insertDummyNodes(edge);\n+            }\n+\n+            sanityCheckEdges();\n+            sanityCheckNodesAndLayerNodes();\n+        }\n+\n+        \/**\n+         * Calculate which layer the given vertex should be inserted at to minimize\n+         * reversed edges and edge lengths\n+         * If there are multiple options, choose the bottom most layer\n+         *\n+         * @param vertex\n+         * @param links\n+         * @return the optimal layer to insert the given vertex\n+         *\/\n+        private int optimalLayer(Vertex vertex, List<Link> links) {\n+            if (vertex.isRoot()) {\n+                return 0;\n+            } else if (layers.keySet().size() == 0) {\n+                return 0;\n+            }\n+\n+            int reversedEdges = Integer.MAX_VALUE;\n+            int totalEdgeLength = Integer.MAX_VALUE;\n+            int neighborsOnSameLayer = Integer.MAX_VALUE;\n+            int layer = -1;\n+            for (int i = 0; i < layers.keySet().size(); i++) {\n+                \/\/ System.out.println(\"Testing layer \" + i);\n+                int curReversedEdges = 0;\n+                int curTotalEdgeLength = 0;\n+                int curNeighborsOnSameLayer = 0;\n+                for (Link link : links) {\n+                    LayoutNode fromNode = vertexToLayoutNode.get(link.getFrom().getVertex());\n+                    LayoutNode toNode = vertexToLayoutNode.get(link.getTo().getVertex());\n+                    if (link.getTo().getVertex().equals(vertex) && fromNode != null) {\n+                        if (fromNode.layer > i) {\n+                            curReversedEdges += 1;\n+                        } else if (fromNode.layer == i) {\n+                            curNeighborsOnSameLayer += 1;\n+                        }\n+                        curTotalEdgeLength += Math.abs(fromNode.layer - i);\n+                    }\n+                    if (link.getFrom().getVertex().equals(vertex) && toNode != null) {\n+                        if (toNode.layer < i) {\n+                            curReversedEdges += 1;\n+                        } else if (toNode.layer == i) {\n+                            curNeighborsOnSameLayer += 1;\n+                        }\n+                        curTotalEdgeLength += Math.abs(i - toNode.layer);\n+                    }\n+                }\n+\n+                curReversedEdges *= 10000;\n+                curNeighborsOnSameLayer *= 2;\n+\n+                if (curReversedEdges + curTotalEdgeLength + curNeighborsOnSameLayer <= reversedEdges + totalEdgeLength\n+                        + neighborsOnSameLayer) {\n+                    totalEdgeLength = curTotalEdgeLength;\n+                    reversedEdges = curReversedEdges;\n+                    neighborsOnSameLayer = curNeighborsOnSameLayer;\n+                    layer = i;\n+                }\n+            }\n+\n+            assert layer != -1;\n+            return layer;\n+        }\n+\n+        private void applyAddVertexAction(VertexAction action) {\n+            LayoutNode node = new LayoutNode();\n+            Dimension size = action.vertex.getSize();\n+            node.width = (int) size.getWidth();\n+            node.height = (int) size.getHeight();\n+            node.vertex = action.vertex;\n+\n+            List<Link> links = new ArrayList<>();\n+            for (LinkAction a : action.linkActions) {\n+                links.add(a.link);\n+            }\n+            int layer = optimalLayer(action.vertex, links);\n+\n+            \/\/ Temporarily add the links so that the node insertion accounts for edge\n+            \/\/ crossings\n+            for (Link l : links) {\n+                LayoutEdge e = new LayoutEdge();\n+                if (l.getTo().getVertex().equals(action.vertex)\n+                        && nodes.contains(vertexToLayoutNode.get(l.getFrom().getVertex()))) {\n+                    e.to = node;\n+                    e.from = vertexToLayoutNode.get(l.getFrom().getVertex());\n+                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n+                    e.relativeTo = l.getTo().getRelativePosition().x;\n+                    node.preds.add(e);\n+                } else if (l.getFrom().getVertex().equals(action.vertex)\n+                        && nodes.contains(vertexToLayoutNode.get(l.getTo().getVertex()))) {\n+                    e.from = node;\n+                    e.to = vertexToLayoutNode.get(l.getTo().getVertex());\n+                    e.relativeFrom = l.getFrom().getRelativePosition().x;\n+                    e.relativeTo = l.getTo().getRelativePosition().x;\n+                    node.succs.add(e);\n+                }\n+            }\n+            insertNode(node, layer);\n+            node.succs.clear();\n+            node.preds.clear();\n+\n+            \/\/ Add associated edges\n+            for (LinkAction a : action.linkActions) {\n+                if (a.action == Action.ADD) {\n+                    applyAddLinkAction(a.link);\n+                }\n+            }\n+\n+            sanityCheckEdges();\n+            sanityCheckNodesAndLayerNodes();\n+        }\n+\n+        private void applyRemoveLinkAction(Link l) {\n+            Vertex from = l.getFrom().getVertex();\n+            Vertex to = l.getTo().getVertex();\n+            LayoutNode toNode = vertexToLayoutNode.get(to);\n+            LayoutNode fromNode = vertexToLayoutNode.get(from);\n+\n+            if (toNode.layer < fromNode.layer) {\n+                \/\/ Reversed edge\n+                LayoutNode temp = toNode;\n+                toNode = fromNode;\n+                fromNode = temp;\n+\n+                reversedLinks.remove(l);\n+                reversedLinkEndPoints.remove(l);\n+                reversedLinkStartPoints.remove(l);\n+            }\n+\n+            \/\/ Remove preds-edges bottom up, starting at \"to\" node\n+            \/\/ Cannot start from \"from\" node since there might be joint edges\n+            List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.preds);\n+            for (LayoutEdge edge : toNodePredsEdges) {\n+                LayoutNode n = edge.from;\n+                LayoutEdge edgeToRemove;\n+\n+                if (edge.link != null && edge.link.equals(l)) {\n+                    toNode.preds.remove(edge);\n+                    edgeToRemove = edge;\n+                } else {\n+                    \/\/ Wrong edge, look at next\n+                    continue;\n+                }\n+\n+                if (n.vertex != null && n.vertex.equals(from)) {\n+                    \/\/ No dummy nodes inbetween 'from' and 'to' vertex\n+                    n.succs.remove(edgeToRemove);\n+                    break;\n+                } else {\n+                    \/\/ Must remove edges between dummy nodes\n+                    boolean found = true;\n+                    LayoutNode prev = toNode;\n+                    while (n.vertex == null && found) {\n+                        found = false;\n+\n+                        if (n.vertex == null && n.succs.size() <= 1 && n.preds.size() <= 1) {\n+                            \/\/ Dummy node used only for this link, remove if not already removed\n+                            if (nodes.contains(n)) {\n+                                removeNode(n);\n+                            }\n+                        } else {\n+                            \/\/ anchor node, should not be removed\n+                            break;\n+                        }\n+\n+                        if (n.preds.size() == 1) {\n+                            n.succs.remove(edgeToRemove);\n+                            prev = n;\n+                            edgeToRemove = n.preds.get(0);\n+                            n = edgeToRemove.from;\n+                            found = true;\n+                        }\n+                    }\n+\n+                    n.succs.remove(edgeToRemove);\n+                    prev.preds.remove(edgeToRemove);\n+                }\n+                break;\n+            }\n+\n+            sanityCheckEdges();\n+            sanityCheckNodesAndLayerNodes();\n+        }\n+\n+        private void removeNodeWithoutRemovingLayer(LayoutNode node) {\n+            boolean prevShouldRemoveEmptyLayers = shouldRemoveEmptyLayers;\n+            shouldRemoveEmptyLayers = false;\n+            removeNode(node);\n+            shouldRemoveEmptyLayers = prevShouldRemoveEmptyLayers;\n+        }\n+\n+        private void removeNode(LayoutNode node) {\n+            if (!nodes.contains(node)) {\n+                return;\n+            }\n+            int layer = node.layer;\n+            int pos = node.pos;\n+            List<LayoutNode> remainingLayerNodes = layers.get(layer);\n+            assert remainingLayerNodes.contains(node);\n+            remainingLayerNodes.remove(node);\n+\n+            \/\/ Update position of remaining nodes on the same layer\n+            boolean onlyDummiesLeft = true;\n+            for (LayoutNode n : remainingLayerNodes) {\n+                if (n.pos > pos) {\n+                    n.pos -= 1;\n+                }\n+                if (n.vertex != null || n.preds.size() > 1) {\n+                    onlyDummiesLeft = false;\n+                }\n+            }\n+\n+            if (onlyDummiesLeft && shouldRemoveEmptyLayers) {\n+                layers.remove(layer);\n+                for (int i = layer + 1; i <= layers.size(); i++) {\n+                    List<LayoutNode> list = layers.get(i);\n+                    layers.remove(i);\n+                    layers.put(i - 1, list);\n+                    for (LayoutNode n : list) {\n+                        n.layer -= 1;\n+                    }\n+                }\n+                for (LayoutNode n : remainingLayerNodes) {\n+                    if (n.preds.size() == 1) {\n+                        LayoutEdge predEdge = n.preds.get(0);\n+                        LayoutNode fromNode = predEdge.from;\n+                        fromNode.succs.remove(predEdge);\n+                        for (LayoutEdge e : n.succs) {\n+                            e.from = fromNode;\n+                            e.relativeFrom = predEdge.relativeFrom;\n+                            fromNode.succs.add(e);\n+                        }\n+                    }\n+                    nodes.remove(n);\n+                }\n+            } else {\n+                layers.put(layer, remainingLayerNodes);\n+                adjustXCoordinates(layer);\n+            }\n+\n+            \/\/ Remove node from graph layout\n+            nodes.remove(node);\n+        }\n+\n+        private void applyRemoveVertexAction(VertexAction action) {\n+            LayoutNode node = vertexToLayoutNode.get(action.vertex);\n+\n+            assert nodes.contains(node);\n+\n+            \/\/ Remove associated edges\n+            for (LinkAction a : action.linkActions) {\n+                if (a.action == Action.REMOVE) {\n+                    applyRemoveLinkAction(a.link);\n+                }\n+            }\n+\n+            removeNode(node);\n+\n+            sanityCheckNodesAndLayerNodes();\n+            sanityCheckEdges();\n+        }\n+\n+        void run() {\n+            for (LinkAction action : linkActions) {\n+                if (action.action == Action.REMOVE) {\n+                    applyRemoveLinkAction(action.link);\n+                }\n+            }\n+\n+            for (VertexAction action : vertexActions) {\n+                switch (action.action) {\n+                    case REMOVE:\n+                        applyRemoveVertexAction(action);\n+                        break;\n+                    case ADD:\n+                        applyAddVertexAction(action);\n+                        break;\n+                    default:\n+                        assert false : \"Invalid update action\";\n+                }\n+            }\n+\n+            for (LinkAction action : linkActions) {\n+                if (action.action == Action.ADD) {\n+                    applyAddLinkAction(action.link);\n+                }\n+            }\n+\n+            sanityCheckEdges();\n+            sanityCheckNodesAndLayerNodes();\n+\n+            \/\/ Add or remove wrongful links\n+            Set<Link> layoutedLinks = new HashSet<>();\n+            Set<LayoutNode> layoutedNodes = new HashSet<>();\n+            for (LayoutNode n : nodes) {\n+                for (LayoutEdge e : n.preds) {\n+                    if (e.link != null) {\n+                        layoutedLinks.add(e.link);\n+                    }\n+                }\n+                if (n.vertex != null) {\n+                    layoutedNodes.add(n);\n+                }\n+            }\n+            Set<Link> superfluousLinks = new HashSet<>(layoutedLinks);\n+            superfluousLinks.removeAll(currentLinks);\n+            for (Link l : superfluousLinks) {\n+                applyRemoveLinkAction(l);\n+                layoutedLinks.remove(l);\n+            }\n+            Set<Link> missingLinks = new HashSet<>(currentLinks);\n+            missingLinks.removeAll(layoutedLinks);\n+            for (Link l : missingLinks) {\n+                applyAddLinkAction(l);\n+                layoutedLinks.add(l);\n+            }\n+            assert currentVertices.size() == layoutedNodes.size();\n+            assert currentLinks.size() == layoutedLinks.size();\n+        }\n+    }\n+\n+    private static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n+    private static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+        if (n1.vertex == null) {\n+            if (n2.vertex == null) {\n+                return 0;\n+            }\n+            return -1;\n+        }\n+        if (n2.vertex == null) {\n+            return 1;\n+        }\n+        return n1.succs.size() - n2.succs.size();\n+    };\n+\n+    private static class NodeRow {\n+\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n+\n+        public NodeRow(ArrayList<Integer> space) {\n+            treeSet = new TreeSet<>(nodePositionComparator);\n+            this.space = space;\n+        }\n+\n+        public int offset(LayoutNode n1, LayoutNode n2) {\n+            int v1 = space.get(n1.pos) + n1.width;\n+            int v2 = space.get(n2.pos);\n+            return v2 - v1;\n+        }\n+\n+        public void insert(LayoutNode n, int pos) {\n+\n+            SortedSet<LayoutNode> headSet = treeSet.headSet(n);\n+\n+            LayoutNode leftNeighbor;\n+            int minX = Integer.MIN_VALUE;\n+            if (!headSet.isEmpty()) {\n+                leftNeighbor = headSet.last();\n+                minX = leftNeighbor.x + leftNeighbor.width + offset(leftNeighbor, n);\n+            }\n+\n+            if (pos < minX) {\n+                n.x = minX;\n+            } else {\n+\n+                LayoutNode rightNeighbor;\n+                SortedSet<LayoutNode> tailSet = treeSet.tailSet(n);\n+                int maxX = Integer.MAX_VALUE;\n+                if (!tailSet.isEmpty()) {\n+                    rightNeighbor = tailSet.first();\n+                    maxX = rightNeighbor.x - offset(n, rightNeighbor) - n.width;\n+                }\n+\n+                n.x = Math.min(pos, maxX);\n+\n+                assert minX <= maxX : minX + \" vs \" + maxX;\n+            }\n+\n+            treeSet.add(n);\n+        }\n+    }\n+\n+    private class AssignYCoordinates {\n+        void run() {\n+\n+            \/\/ Reset all values before assigning y-coordinates\n+            for (LayoutNode n : nodes) {\n+                if (n.vertex != null) {\n+                    updateNodeWithReversedEdges(n);\n+                } else {\n+                    n.height = DUMMY_HEIGHT;\n+                }\n+                n.y = 0;\n+            }\n+\n+            int curY = 0;\n+\n+            for (int i = 0; i < layers.size(); i++) {\n+                List<LayoutNode> layer = layers.get(i);\n+                int maxHeight = 0;\n+                int baseLine = 0;\n+                int bottomBaseLine = 0;\n+                for (LayoutNode n : layer) {\n+                    maxHeight = Math.max(maxHeight, n.height - n.yOffset - n.bottomYOffset);\n+                    baseLine = Math.max(baseLine, n.yOffset);\n+                    bottomBaseLine = Math.max(bottomBaseLine, n.bottomYOffset);\n+                }\n+\n+                int maxXOffset = 0;\n+                for (LayoutNode n : layer) {\n+                    if (n.vertex == null) {\n+                        \/\/ Dummy node\n+                        n.y = curY;\n+                        n.height = maxHeight + baseLine + bottomBaseLine;\n+\n+                    } else {\n+                        n.y = curY + baseLine + (maxHeight - (n.height - n.yOffset - n.bottomYOffset)) \/ 2 - n.yOffset;\n+                    }\n+\n+                    for (LayoutEdge e : n.succs) {\n+                        int curXOffset = Math.abs(n.x - e.to.x);\n+                        maxXOffset = Math.max(curXOffset, maxXOffset);\n+                    }\n+                }\n+\n+                curY += maxHeight + baseLine + bottomBaseLine;\n+                curY += LAYER_OFFSET + ((int) (Math.sqrt(maxXOffset) * 1.5));\n+            }\n+        }\n+    }\n+\n+    private class ComputeLayoutScore {\n+        \/**\n+         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n+         *\n+         * @param p\n+         * @param q\n+         * @param r\n+         * @return true if point q lies on line segment 'pr'\n+         *\/\n+        private boolean onSegment(Point p, Point q, Point r) {\n+            if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\n+                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))\n+                return true;\n+\n+            return false;\n+        }\n+\n+        \/**\n+         * To find orientation of ordered triplet (p, q, r).\n+         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n+         *\n+         * @return 0 --> p, q and r are collinear, 1 --> Clockwise, 2 -->\n+         *         Counterclockwise\n+         *\/\n+        private int orientation(Point p, Point q, Point r) {\n+            int val = (q.y - p.y) * (r.x - q.x) -\n+                    (q.x - p.x) * (r.y - q.y);\n+\n+            if (val == 0)\n+                return 0; \/\/ collinear\n+\n+            return (val > 0) ? 1 : 2; \/\/ clock or counterclock wise\n+        }\n+\n+        \/**\n+         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n+         *\n+         * @return true if line segment 'p1q1' and 'p2q2' intersect.\n+         *\/\n+        private boolean doIntersect(Point p1, Point q1, Point p2, Point q2) {\n+            \/\/ Share the same port\n+            if (p1.equals(p2) || q1.equals(q2) || p1.equals(q2) || q1.equals(p2)) {\n+                return false;\n+            }\n+\n+            \/\/ Find the four orientations needed for general and\n+            \/\/ special cases\n+            int o1 = orientation(p1, q1, p2);\n+            int o2 = orientation(p1, q1, q2);\n+            int o3 = orientation(p2, q2, p1);\n+            int o4 = orientation(p2, q2, q1);\n+\n+            \/\/ General case\n+            if (o1 != o2 && o3 != o4)\n+                return true;\n+\n+            \/\/ Special Cases\n+            \/\/ p1, q1 and p2 are collinear and p2 lies on segment p1q1\n+            if (o1 == 0 && onSegment(p1, p2, q1)) {\n+                return true;\n+            }\n+\n+            \/\/ p1, q1 and q2 are collinear and q2 lies on segment p1q1\n+            if (o2 == 0 && onSegment(p1, q2, q1)) {\n+                return true;\n+            }\n+\n+            \/\/ p2, q2 and p1 are collinear and p1 lies on segment p2q2\n+            if (o3 == 0 && onSegment(p2, p1, q2)) {\n+                return true;\n+            }\n+\n+            \/\/ p2, q2 and q1 are collinear and q1 lies on segment p2q2\n+            if (o4 == 0 && onSegment(p2, q1, q2)) {\n+                return true;\n+            }\n+\n+            return false; \/\/ Doesn't fall in any of the above cases\n+        }\n+\n+        private int totalEdgeCrossings() {\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+            for (LayoutNode node : nodes) {\n+                if (node.vertex == null) {\n+                    continue;\n+                }\n+                for (LayoutEdge e : node.preds) {\n+                    if (e.link != null && !linkPositions.keySet().contains(e.link)) {\n+                        List<Point> points = new WriteResult().edgePoints(e);\n+\n+                        \/\/ Merged edges creates duplicate edge segments\n+                        for (Link l : linkPositions.keySet()) {\n+                            \/\/ Exists edge from same vertex, same port\n+                            if (l.getFrom().getVertex().equals(e.link.getFrom().getVertex())\n+                                    && l.getFrom().getRelativePosition().x == e.link.getFrom()\n+                                    .getRelativePosition().x) {\n+                                List<Point> duplicatePoints = new ArrayList<>();\n+                                for (Point p : points) {\n+                                    if (linkPositions.get(l).contains(p)) {\n+                                        duplicatePoints.add(p);\n+                                    }\n+                                }\n+                                if (duplicatePoints.size() > 1) {\n+                                    \/\/ Should not remove anchor point\n+                                    duplicatePoints.remove(duplicatePoints.size() - 1);\n+                                    points.removeAll(duplicatePoints);\n+                                }\n+                            }\n+                        }\n+\n+                        linkPositions.put(e.link, points);\n+                    }\n+                }\n+            }\n+\n+            int crossings = 0;\n+\n+            for (Link l1 : linkPositions.keySet()) {\n+                for (Link l2 : linkPositions.keySet()) {\n+                    if (l1.equals(l2) || (l1.getFrom().getVertex().equals(l2.getFrom().getVertex())\n+                            && l1.getFrom().getRelativePosition().x == l2.getFrom().getRelativePosition().x)) {\n+                        continue;\n+                    }\n+\n+                    List<Point> pointsLink1 = linkPositions.get(l1);\n+                    List<Point> pointsLink2 = linkPositions.get(l2);\n+\n+                    for (int i = 1; i < pointsLink1.size(); i++) {\n+                        Point p1 = pointsLink1.get(i - 1);\n+                        Point q1 = pointsLink1.get(i);\n+                        for (int j = 1; j < pointsLink2.size(); j++) {\n+                            Point p2 = pointsLink2.get(j - 1);\n+                            Point q2 = pointsLink2.get(j);\n+\n+                            if (doIntersect(p1, q1, p2, q2)) {\n+                                crossings += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            \/\/ Double counting every crossing\n+            return crossings \/ 2;\n+        }\n+\n+        private float averageEdgeLength() {\n+            float totLength = 0;\n+            int edgeCount = 0;\n+\n+            for (LayoutNode node : nodes) {\n+                if (node.vertex == null)\n+                    continue;\n+                for (LayoutEdge e : node.preds) {\n+                    if (e.link == null)\n+                        continue;\n+                    List<Point> points = new WriteResult().edgePoints(e);\n+                    float edgeLength = 0;\n+                    Point prevPoint = points.get(0);\n+                    for (int i = 1; i < points.size(); i++) {\n+                        Point point = points.get(i);\n+                        edgeLength += prevPoint.distance(point);\n+                        prevPoint = point;\n+                    }\n+                    totLength += edgeLength;\n+                    edgeCount += 1;\n+                }\n+            }\n+\n+            if (edgeCount > 0) {\n+                return totLength \/ edgeCount;\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        \/**\n+         * Computes how much the bends in an edge deviates from being straight, on\n+         * average\n+         *\n+         * @return\n+         *\/\n+        private float averageEdgeBendDegrees() {\n+            float totDegree = 0;\n+            int edgeCount = 0;\n+\n+            for (LayoutNode node : nodes) {\n+                if (node.vertex == null)\n+                    continue;\n+                for (LayoutEdge e : node.preds) {\n+                    if (e.link == null)\n+                        continue;\n+                    List<Point> points = new WriteResult().edgePoints(e);\n+                    Point prevPoint = points.get(0);\n+                    Point curPoint = points.get(1);\n+                    for (int i = 2; i < points.size(); i++) {\n+                        Point nextPoint = points.get(i);\n+\n+                        double x1 = prevPoint.getX() - curPoint.getX();\n+                        double y1 = prevPoint.getY() - curPoint.getY();\n+                        double x2 = nextPoint.getX() - curPoint.getX();\n+                        double y2 = nextPoint.getY() - curPoint.getY();\n+\n+                        double dotProduct = x1 * x2 + y1 * y2;\n+                        double prevMagnitude = Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2));\n+                        double nextMagnitude = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));\n+                        double cos = dotProduct \/ (prevMagnitude * nextMagnitude);\n+                        double angle = Math.acos(cos);\n+\n+                        if (angle < Math.PI) {\n+                            totDegree += Math.abs(Math.PI - angle);\n+                        }\n+\n+                        prevPoint = curPoint;\n+                        curPoint = nextPoint;\n+                    }\n+                    edgeCount += 1;\n+                }\n+            }\n+\n+            if (edgeCount > 0) {\n+                return totDegree \/ edgeCount;\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        private int reversedEdges() {\n+            return reversedLinks.size();\n+        }\n+\n+        private float averageNodeDisplacement() {\n+            HashSet<Vertex> commonVertices = new HashSet<>(oldVertices);\n+            commonVertices.retainAll(currentVertices);\n+\n+            float totalDisplacement = 0;\n+            for (Vertex vertex : commonVertices) {\n+                LayoutNode node = vertexToLayoutNode.get(vertex);\n+                int x1 = node.x + node.xOffset;\n+                int y1 = node.y + node.yOffset;\n+                LayoutNode oldNode = oldVertexToLayoutNode.get(vertex);\n+                int x2 = oldNode.x + oldNode.xOffset;\n+                int y2 = oldNode.y + oldNode.yOffset;\n+                totalDisplacement += Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n+            }\n+            return totalDisplacement \/ commonVertices.size();\n+        }\n+\n+        public void run() {\n+            int edgeCrossings = totalEdgeCrossings();\n+            float edgeBendsDeg = averageEdgeBendDegrees();\n+            float edgeLength = averageEdgeLength();\n+            float nodeDisplacement = averageNodeDisplacement();\n+            int reversedEdges = reversedEdges();\n+        }\n+    }\n+\n+    private class WriteResult {\n+\n+        private List<Point> edgePoints(LayoutEdge e) {\n+            ArrayList<Point> points = new ArrayList<>();\n+\n+            Point p = new Point(e.to.x + e.relativeTo,\n+                    e.to.y + e.to.yOffset + e.link.getTo().getRelativePosition().y);\n+            points.add(p);\n+            if (e.to.inOffsets.containsKey(e.relativeTo)) {\n+                points.add(new Point(p.x,\n+                        p.y + e.to.inOffsets.get(e.relativeTo) + e.link.getTo().getRelativePosition().y));\n+            }\n+\n+            LayoutNode cur = e.from;\n+            LayoutEdge curEdge = e;\n+            while (cur.vertex == null && cur.preds.size() != 0) {\n+                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n+                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n+                    \/\/ On the same vertical line, can remove previous point\n+                    points.remove(points.size() - 1);\n+                }\n+                \/\/ Top of the dummy node\n+                points.add(new Point(cur.x + cur.width \/ 2, cur.y + cur.height));\n+                if (points.size() > 1 && points.get(points.size() - 1).x == cur.x + cur.width \/ 2\n+                        && points.get(points.size() - 2).x == cur.x + cur.width \/ 2) {\n+                    points.remove(points.size() - 1);\n+                }\n+                \/\/ Bottom of the dummy node\n+                points.add(new Point(cur.x + cur.width \/ 2, cur.y));\n+                assert cur.preds.size() == 1;\n+                curEdge = cur.preds.get(0);\n+                cur = curEdge.from;\n+            }\n+\n+            p = new Point(cur.x + curEdge.relativeFrom, cur.y + cur.height - cur.bottomYOffset\n+                    + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y));\n+            if (curEdge.from.outOffsets.containsKey(curEdge.relativeFrom)) {\n+                points.add(new Point(p.x, p.y + curEdge.from.outOffsets.get(curEdge.relativeFrom)\n+                        + (curEdge.link == null ? 0 : curEdge.link.getFrom().getRelativePosition().y)));\n+            }\n+            points.add(p);\n+\n+            Collections.reverse(points);\n+\n+            if (reversedLinks.contains(e.link)) {\n+                Collections.reverse(points);\n+\n+                assert reversedLinkStartPoints.containsKey(e.link);\n+                for (Point p1 : reversedLinkStartPoints.get(e.link)) {\n+                    points.add(new Point(p1.x + cur.x, p1.y + cur.y));\n+                }\n+\n+                assert reversedLinkEndPoints.containsKey(e.link);\n+                for (Point p1 : reversedLinkEndPoints.get(e.link)) {\n+                    points.add(0, new Point(p1.x + e.to.x, p1.y + e.to.y));\n+                }\n+            }\n+\n+            return points;\n+        }\n+\n+        void run() {\n+            HashMap<Vertex, Point> vertexPositions = new HashMap<>();\n+            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n+\n+            for (LayoutNode n : nodes) {\n+\n+                if (n.vertex != null) {\n+                    assert !vertexPositions.containsKey(n.vertex);\n+                    vertexPositions.put(n.vertex, new Point(n.x + n.xOffset, n.y + n.yOffset));\n+                } else {\n+                    continue;\n+                }\n+\n+                \/\/ All edges can be drawn from bottom up, the links are stored in the preds list\n+                \/\/ of each node\n+                for (LayoutEdge e : n.preds) {\n+                    if (e.link != null && !linkPositions.containsKey(e.link)) {\n+                        List<Point> points = edgePoints(e);\n+                        assert !linkPositions.containsKey(e.link);\n+                        linkPositions.put(e.link, points);\n+                    }\n+                }\n+            }\n+\n+            \/\/ Ensure all edges are drawn\n+            assert currentLinks.size() <= linkPositions.keySet().size();\n+\n+            int minX = Integer.MAX_VALUE;\n+            int minY = Integer.MAX_VALUE;\n+            for (Vertex v : vertexPositions.keySet()) {\n+                Point p = vertexPositions.get(v);\n+                minX = Math.min(minX, p.x);\n+                minY = Math.min(minY, p.y);\n+            }\n+\n+            for (Link l : linkPositions.keySet()) {\n+                List<Point> points = linkPositions.get(l);\n+                for (Point p : points) {\n+                    if (p != null) {\n+                        minX = Math.min(minX, p.x);\n+                        minY = Math.min(minY, p.y);\n+                    }\n+                }\n+            }\n+\n+            for (Vertex v : vertexPositions.keySet()) {\n+                Point p = vertexPositions.get(v);\n+                p.x -= minX;\n+                p.y -= minY;\n+                v.setPosition(p);\n+            }\n+\n+            for (Link l : linkPositions.keySet()) {\n+                List<Point> points = linkPositions.get(l);\n+                for (Point p : points) {\n+                    if (p != null) {\n+                        p.x -= minX;\n+                        p.y -= minY;\n+                    }\n+                }\n+                l.setControlPoints(points);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalStableLayoutManager.java","additions":1913,"deletions":0,"binary":false,"changes":1913,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.Link;\n+\n+public class LayoutEdge {\n+\n+        public LayoutNode from;\n+        public LayoutNode to;\n+        \/\/ Horizontal distance relative to start of 'from'.\n+        public int relativeFrom;\n+        \/\/ Horizontal distance relative to start of 'to'.\n+        public int relativeTo;\n+        public Link link;\n+        public boolean vip;\n+\n+        @Override\n+        public String toString() {\n+            return \"Edge \" + from + \", \" + to;\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutEdge.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n+\n+public class LayoutNode {\n+\n+        public int x;\n+        public int y;\n+        public int width;\n+        public int height;\n+        public int layer = -1;\n+        public int xOffset;\n+        public int yOffset;\n+        public int bottomYOffset;\n+        public Vertex vertex; \/\/ Only used for non-dummy nodes, otherwise null\n+\n+        public List<LayoutEdge> preds = new ArrayList<>();\n+        public List<LayoutEdge> succs = new ArrayList<>();\n+        public HashMap<Integer, Integer> outOffsets = new HashMap<>();\n+        public HashMap<Integer, Integer> inOffsets = new HashMap<>();\n+        public int pos = -1; \/\/ Position within layer\n+\n+        public int crossingNumber;\n+\n+        @Override\n+        public String toString() {\n+            return \"Node \" + vertex;\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+        public static final int STABLE_SEA_OF_NODES = 3;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalCFGLayoutManager;\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalClusterLayoutManager;\n-import com.sun.hotspot.igv.hierarchicallayout.HierarchicalLayoutManager;\n-import com.sun.hotspot.igv.hierarchicallayout.LinearLayoutManager;\n+import com.sun.hotspot.igv.hierarchicallayout.*;\n@@ -90,0 +87,1 @@\n+    private final HierarchicalStableLayoutManager hierarchicalStableLayoutManager;\n@@ -490,0 +488,2 @@\n+\n+        hierarchicalStableLayoutManager = new HierarchicalStableLayoutManager();\n@@ -691,0 +691,4 @@\n+    private void doStableSeaLayout(HashSet<Figure> visibleFigures, HashSet<Connection> visibleConnections) {\n+        hierarchicalStableLayoutManager.updateLayout(visibleFigures, visibleConnections);\n+    }\n+\n@@ -695,0 +699,1 @@\n+        hierarchicalStableLayoutManager.setShouldRedrawLayout(true);\n@@ -1190,1 +1195,3 @@\n-        if (getModel().getShowSea()) {\n+        if (getModel().getShowStableSea()) {\n+            doStableSeaLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowSea()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private boolean showStableSea;\n@@ -93,0 +94,11 @@\n+    public boolean getShowStableSea() {\n+        return showStableSea;\n+    }\n+\n+    public void setShowStableSea(boolean enable) {\n+        showStableSea = enable;\n+        if (enable) {\n+            diagramChangedEvent.fire();\n+        }\n+    }\n+\n@@ -219,0 +231,1 @@\n+        showStableSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.STABLE_SEA_OF_NODES;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+        JToggleButton stableSeaLayoutButton = new JToggleButton(new EnableStableSeaLayoutAction(this));\n+        stableSeaLayoutButton.setSelected(diagramViewModel.getShowStableSea());\n+        layoutButtons.add(stableSeaLayoutButton);\n+        toolBar.add(stableSeaLayoutButton);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n+import java.beans.PropertyChangeEvent;\n+\n+public class EnableStableSeaLayoutAction extends EnableLayoutAction {\n+\n+    public EnableStableSeaLayoutAction(EditorTopComponent etc) {\n+        super(etc);\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/stable_sea.png\";\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"Show stable sea of nodes\";\n+    }\n+\n+    @Override\n+    public void propertyChange(PropertyChangeEvent evt) {\n+        editor.getModel().setShowStableSea(this.isSelected());\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableStableSeaLayoutAction.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/stable_sea.png","binary":true,"status":"added"}]}