{"files":[{"patch":"@@ -392,1 +392,1 @@\n-        return getInputNode().equals(((Figure)o).getInputNode());\n+        return getInputNode().equals(((Figure) o).getInputNode());\n@@ -394,0 +394,1 @@\n+    \n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,5 @@\n+        <dependency>\n+            <groupId>com.sun.hotspot.igv<\/groupId>\n+            <artifactId>Util<\/artifactId>\n+            <version>${project.version}<\/version>\n+        <\/dependency>\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/pom.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.hotspot.igv.util.Statistics;\n@@ -621,1 +622,1 @@\n-                return median(values);\n+                return Statistics.median(values);\n@@ -631,1 +632,1 @@\n-                return median(values);\n+                return Statistics.median(values);\n@@ -653,1 +654,1 @@\n-            return median(values);\n+            return Statistics.median(values);\n@@ -669,10 +670,1 @@\n-            return median(values);\n-        }\n-\n-        private int median(int[] values) {\n-            Arrays.sort(values);\n-            if (values.length % 2 == 0) {\n-                return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n-            } else {\n-                return values[values.length \/ 2];\n-            }\n+            return Statistics.median(values);\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.util.Statistics;\n@@ -39,1 +40,1 @@\n-    \/\/ Algorithm global datastructures\n+    \/\/ Algorithm global data structures\n@@ -44,1 +45,0 @@\n-    private final List<LayoutNode> oldNodes;\n@@ -59,1 +59,0 @@\n-    private final boolean shouldComputeLayoutScore = false;\n@@ -66,1 +65,1 @@\n-    private class VertexAction {\n+    private static class VertexAction {\n@@ -77,1 +76,1 @@\n-    private class LinkAction {\n+    private static class LinkAction {\n@@ -94,1 +93,0 @@\n-        oldNodes = new ArrayList<>();\n@@ -98,1 +96,1 @@\n-        if (n.preds.size() == 0 && n.succs.size() == 0) {\n+        if (n.preds.isEmpty() && n.succs.isEmpty()) {\n@@ -115,10 +113,1 @@\n-        return median(values);\n-    }\n-\n-    private int median(int[] values) {\n-        Arrays.sort(values);\n-        if (values.length % 2 == 0) {\n-            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n-        } else {\n-            return values[values.length \/ 2];\n-        }\n+        return Statistics.median(values);\n@@ -131,1 +120,0 @@\n-     * @param layer\n@@ -156,1 +144,1 @@\n-     * Ensure that the datastructures nodes and layerNodes are consistent\n+     * Ensure that the data structures nodes and layerNodes are consistent\n@@ -450,18 +438,0 @@\n-    \/**\n-     * Used to compare nodes across consecutive graphs\n-     *\/\n-    private void copyOldNodes() {\n-        oldNodes.clear();\n-        oldVertexToLayoutNode.clear();\n-        for (LayoutNode node : nodes) {\n-            if (node.vertex != null) {\n-                LayoutNode nodeCopy = new LayoutNode();\n-                nodeCopy.x = node.x;\n-                nodeCopy.y = node.y;\n-                nodeCopy.xOffset = node.xOffset;\n-                nodeCopy.yOffset = node.yOffset;\n-                oldVertexToLayoutNode.put(node.vertex, nodeCopy);\n-            }\n-        }\n-    }\n-\n@@ -509,4 +479,0 @@\n-            if (shouldComputeLayoutScore) {\n-                new ComputeLayoutScore().run();\n-            }\n-\n@@ -517,1 +483,0 @@\n-        copyOldNodes();\n@@ -542,1 +507,1 @@\n-        \/\/ In case there are changes in the node size, it's layer must be updated\n+        \/\/ In case there are changes in the node size, its layer must be updated\n@@ -644,3 +609,0 @@\n-         * @param node\n-         * @param layer\n-         * @return The optimal position within given layer\n@@ -649,1 +611,1 @@\n-            assert layers.keySet().contains(layer);\n+            assert layers.containsKey(layer);\n@@ -667,1 +629,1 @@\n-                if (layers.keySet().contains(layer - 1)) {\n+                if (layers.containsKey(layer - 1)) {\n@@ -669,1 +631,1 @@\n-                    \/\/ For each link with an end point in vertex, check how many edges crosses it\n+                    \/\/ For each link with an end point in vertex, check how many edges cross it\n@@ -704,1 +666,1 @@\n-                if (layers.keySet().contains(layer + 1)) {\n+                if (layers.containsKey(layer + 1)) {\n@@ -706,1 +668,1 @@\n-                    \/\/ For each link with an end point in vertex, check how many edges crosses it\n+                    \/\/ For each link with an end point in vertex, check how many edges cross it\n@@ -753,2 +715,0 @@\n-         * @param node\n-         * @param layer\n@@ -757,1 +717,1 @@\n-            assert layers.keySet().contains(layer) || layer == 0;\n+            assert layers.containsKey(layer) || layer == 0;\n@@ -762,1 +722,1 @@\n-            if (layerNodes.size() == 0) {\n+            if (layerNodes.isEmpty()) {\n@@ -969,1 +929,0 @@\n-         * @param node\n@@ -991,1 +950,1 @@\n-            assert layers.get(layer).size() == 0;\n+            assert layers.get(layer).isEmpty();\n@@ -1003,1 +962,1 @@\n-                    if (!portHashes.keySet().contains(e.relativeFrom)) {\n+                    if (!portHashes.containsKey(e.relativeFrom)) {\n@@ -1104,1 +1063,1 @@\n-         * If there are multiple options, choose the bottom most layer\n+         * If there are multiple options, choose the bottom-most layer\n@@ -1106,2 +1065,0 @@\n-         * @param vertex\n-         * @param links\n@@ -1113,1 +1070,1 @@\n-            } else if (layers.keySet().size() == 0) {\n+            } else if (layers.keySet().isEmpty()) {\n@@ -1122,1 +1079,0 @@\n-                \/\/ System.out.println(\"Testing layer \" + i);\n@@ -1531,253 +1487,0 @@\n-    private class ComputeLayoutScore {\n-        \/**\n-         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n-         *\n-         * @param p\n-         * @param q\n-         * @param r\n-         * @return true if point q lies on line segment 'pr'\n-         *\/\n-        private boolean onSegment(Point p, Point q, Point r) {\n-            return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\n-                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n-        }\n-\n-        \/**\n-         * To find orientation of ordered triplet (p, q, r).\n-         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n-         *\n-         * @return 0 --> p, q and r are collinear, 1 --> Clockwise, 2 -->\n-         *         Counterclockwise\n-         *\/\n-        private int orientation(Point p, Point q, Point r) {\n-            int val = (q.y - p.y) * (r.x - q.x) -\n-                    (q.x - p.x) * (r.y - q.y);\n-\n-            if (val == 0) {\n-                return 0; \/\/ collinear\n-            }\n-\n-            return (val > 0) ? 1 : 2; \/\/ clock or counterclock wise\n-        }\n-\n-        \/**\n-         * https:\/\/www.geeksforgeeks.org\/check-if-two-given-line-segments-intersect\/\n-         *\n-         * @return true if line segment 'p1q1' and 'p2q2' intersect.\n-         *\/\n-        private boolean doIntersect(Point p1, Point q1, Point p2, Point q2) {\n-            \/\/ Share the same port\n-            if (p1.equals(p2) || q1.equals(q2) || p1.equals(q2) || q1.equals(p2)) {\n-                return false;\n-            }\n-\n-            \/\/ Find the four orientations needed for general and\n-            \/\/ special cases\n-            int o1 = orientation(p1, q1, p2);\n-            int o2 = orientation(p1, q1, q2);\n-            int o3 = orientation(p2, q2, p1);\n-            int o4 = orientation(p2, q2, q1);\n-\n-            \/\/ General case\n-            if (o1 != o2 && o3 != o4) {\n-                return true;\n-            }\n-\n-            \/\/ Special Cases\n-            \/\/ p1, q1 and p2 are collinear and p2 lies on segment p1q1\n-            if (o1 == 0 && onSegment(p1, p2, q1)) {\n-                return true;\n-            }\n-\n-            \/\/ p1, q1 and q2 are collinear and q2 lies on segment p1q1\n-            if (o2 == 0 && onSegment(p1, q2, q1)) {\n-                return true;\n-            }\n-\n-            \/\/ p2, q2 and p1 are collinear and p1 lies on segment p2q2\n-            if (o3 == 0 && onSegment(p2, p1, q2)) {\n-                return true;\n-            }\n-\n-            \/\/ p2, q2 and q1 are collinear and q1 lies on segment p2q2\n-            if (o4 == 0 && onSegment(p2, q1, q2)) {\n-                return true;\n-            }\n-\n-            return false; \/\/ Doesn't fall in any of the above cases\n-        }\n-\n-        private int totalEdgeCrossings() {\n-            HashMap<Link, List<Point>> linkPositions = new HashMap<>();\n-            for (LayoutNode node : nodes) {\n-                if (node.vertex == null) {\n-                    continue;\n-                }\n-                for (LayoutEdge e : node.preds) {\n-                    if (e.link != null && !linkPositions.keySet().contains(e.link)) {\n-                        List<Point> points = new WriteResult().edgePoints(e);\n-\n-                        \/\/ Merged edges creates duplicate edge segments\n-                        for (Link l : linkPositions.keySet()) {\n-                            \/\/ Exists edge from same vertex, same port\n-                            if (l.getFrom().getVertex().equals(e.link.getFrom().getVertex())\n-                                    && l.getFrom().getRelativePosition().x == e.link.getFrom()\n-                                    .getRelativePosition().x) {\n-                                List<Point> duplicatePoints = new ArrayList<>();\n-                                for (Point p : points) {\n-                                    if (linkPositions.get(l).contains(p)) {\n-                                        duplicatePoints.add(p);\n-                                    }\n-                                }\n-                                if (duplicatePoints.size() > 1) {\n-                                    \/\/ Should not remove anchor point\n-                                    duplicatePoints.remove(duplicatePoints.size() - 1);\n-                                    points.removeAll(duplicatePoints);\n-                                }\n-                            }\n-                        }\n-\n-                        linkPositions.put(e.link, points);\n-                    }\n-                }\n-            }\n-\n-            int crossings = 0;\n-\n-            for (Link l1 : linkPositions.keySet()) {\n-                for (Link l2 : linkPositions.keySet()) {\n-                    if (l1.equals(l2) || (l1.getFrom().getVertex().equals(l2.getFrom().getVertex())\n-                            && l1.getFrom().getRelativePosition().x == l2.getFrom().getRelativePosition().x)) {\n-                        continue;\n-                    }\n-\n-                    List<Point> pointsLink1 = linkPositions.get(l1);\n-                    List<Point> pointsLink2 = linkPositions.get(l2);\n-\n-                    for (int i = 1; i < pointsLink1.size(); i++) {\n-                        Point p1 = pointsLink1.get(i - 1);\n-                        Point q1 = pointsLink1.get(i);\n-                        for (int j = 1; j < pointsLink2.size(); j++) {\n-                            Point p2 = pointsLink2.get(j - 1);\n-                            Point q2 = pointsLink2.get(j);\n-\n-                            if (doIntersect(p1, q1, p2, q2)) {\n-                                crossings += 1;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            \/\/ Double counting every crossing\n-            return crossings \/ 2;\n-        }\n-\n-        private float averageEdgeLength() {\n-            float totLength = 0;\n-            int edgeCount = 0;\n-\n-            for (LayoutNode node : nodes) {\n-                if (node.vertex == null)\n-                    continue;\n-                for (LayoutEdge e : node.preds) {\n-                    if (e.link == null)\n-                        continue;\n-                    List<Point> points = new WriteResult().edgePoints(e);\n-                    float edgeLength = 0;\n-                    Point prevPoint = points.get(0);\n-                    for (int i = 1; i < points.size(); i++) {\n-                        Point point = points.get(i);\n-                        edgeLength += prevPoint.distance(point);\n-                        prevPoint = point;\n-                    }\n-                    totLength += edgeLength;\n-                    edgeCount += 1;\n-                }\n-            }\n-\n-            if (edgeCount > 0) {\n-                return totLength \/ edgeCount;\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        \/**\n-         * Computes how much the bends in an edge deviates from being straight, on\n-         * average\n-         *\/\n-        private float averageEdgeBendDegrees() {\n-            float totDegree = 0;\n-            int edgeCount = 0;\n-\n-            for (LayoutNode node : nodes) {\n-                if (node.vertex == null)\n-                    continue;\n-                for (LayoutEdge e : node.preds) {\n-                    if (e.link == null)\n-                        continue;\n-                    List<Point> points = new WriteResult().edgePoints(e);\n-                    Point prevPoint = points.get(0);\n-                    Point curPoint = points.get(1);\n-                    for (int i = 2; i < points.size(); i++) {\n-                        Point nextPoint = points.get(i);\n-\n-                        double x1 = prevPoint.getX() - curPoint.getX();\n-                        double y1 = prevPoint.getY() - curPoint.getY();\n-                        double x2 = nextPoint.getX() - curPoint.getX();\n-                        double y2 = nextPoint.getY() - curPoint.getY();\n-\n-                        double dotProduct = x1 * x2 + y1 * y2;\n-                        double prevMagnitude = Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2));\n-                        double nextMagnitude = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));\n-                        double cos = dotProduct \/ (prevMagnitude * nextMagnitude);\n-                        double angle = Math.acos(cos);\n-\n-                        if (angle < Math.PI) {\n-                            totDegree += Math.abs(Math.PI - angle);\n-                        }\n-\n-                        prevPoint = curPoint;\n-                        curPoint = nextPoint;\n-                    }\n-                    edgeCount += 1;\n-                }\n-            }\n-\n-            if (edgeCount > 0) {\n-                return totDegree \/ edgeCount;\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        private int reversedEdges() {\n-            return reversedLinks.size();\n-        }\n-\n-        private float averageNodeDisplacement() {\n-            HashSet<Vertex> commonVertices = new HashSet<>(oldVertices);\n-            commonVertices.retainAll(currentVertices);\n-\n-            float totalDisplacement = 0;\n-            for (Vertex vertex : commonVertices) {\n-                LayoutNode node = vertexToLayoutNode.get(vertex);\n-                int x1 = node.x + node.xOffset;\n-                int y1 = node.y + node.yOffset;\n-                LayoutNode oldNode = oldVertexToLayoutNode.get(vertex);\n-                int x2 = oldNode.x + oldNode.xOffset;\n-                int y2 = oldNode.y + oldNode.yOffset;\n-                totalDisplacement += Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n-            }\n-            return totalDisplacement \/ commonVertices.size();\n-        }\n-\n-        public void run() {\n-            int edgeCrossings = totalEdgeCrossings();\n-            float edgeBendsDeg = averageEdgeBendDegrees();\n-            float edgeLength = averageEdgeLength();\n-            float nodeDisplacement = averageNodeDisplacement();\n-            int reversedEdges = reversedEdges();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalStableLayoutManager.java","additions":19,"deletions":316,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.hotspot.igv.util;\n+\n+import java.util.Arrays;\n+\n+public class Statistics {\n+\n+    public static int median(int[] values) {\n+        Arrays.sort(values);\n+        if (values.length % 2 == 0) {\n+            return (values[values.length \/ 2 - 1] + values[values.length \/ 2]) \/ 2;\n+        } else {\n+            return values[values.length \/ 2];\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/Statistics.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -200,1 +200,1 @@\n-            \/\/ HierarchicalStableLayoutManager is not stable for difference graphs\n+            \/\/ HierarchicalStableLayoutManager is not reliable for difference graphs\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}