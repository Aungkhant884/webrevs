{"files":[{"patch":"@@ -652,3 +652,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n@@ -656,3 +654,1 @@\n-  const size_t outer_size = size + nmt_overhead;\n-\n-  void* const outer_ptr = (u_char*)::malloc(outer_size);\n+  void* const outer_ptr = ::malloc(outer_size);\n@@ -663,1 +659,1 @@\n-  void* inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack, level);\n+  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n@@ -699,5 +695,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n-\n-  const size_t new_outer_size = size + nmt_overhead;\n+  const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n@@ -706,1 +698,1 @@\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n@@ -709,0 +701,3 @@\n+  if (new_outer_ptr == NULL) {\n+    return NULL;\n+  }\n@@ -710,2 +705,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n-  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack, level);\n+  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n@@ -731,2 +725,0 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-\n@@ -734,1 +726,2 @@\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -109,2 +109,1 @@\n-MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, size_t* bucket_idx,\n-  size_t* pos_idx, MEMFLAGS flags) {\n+MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags) {\n@@ -114,2 +113,1 @@\n-  *bucket_idx = (size_t)index;\n-  *pos_idx = 0;\n+  *marker = 0;\n@@ -125,0 +123,1 @@\n+      *marker = build_marker(index, 0);\n@@ -131,0 +130,1 @@\n+  unsigned pos_idx = 0;\n@@ -132,1 +132,1 @@\n-  while (head != NULL && (*pos_idx) <= MAX_BUCKET_LENGTH) {\n+  while (head != NULL && pos_idx < MAX_BUCKET_LENGTH) {\n@@ -136,0 +136,1 @@\n+        *marker = build_marker(index, pos_idx);\n@@ -140,1 +141,1 @@\n-    if (head->next() == NULL && (*pos_idx) < MAX_BUCKET_LENGTH) {\n+    if (head->next() == NULL && pos_idx < (MAX_BUCKET_LENGTH - 1)) {\n@@ -145,1 +146,2 @@\n-        (*pos_idx) ++;\n+        pos_idx ++;\n+        *marker = build_marker(index, pos_idx);\n@@ -152,1 +154,1 @@\n-    (*pos_idx) ++;\n+    pos_idx ++;\n@@ -158,2 +160,3 @@\n-MallocSite* MallocSiteTable::malloc_site(size_t bucket_idx, size_t pos_idx) {\n-  assert(bucket_idx < table_size, \"Invalid bucket index\");\n+MallocSite* MallocSiteTable::malloc_site(uint32_t marker) {\n+  uint16_t bucket_idx = bucket_idx_from_marker(marker);\n+  const uint16_t pos_idx = pos_idx_from_marker(marker);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -114,2 +114,5 @@\n-  \/\/ The table must not be wider than the maximum value the bucket_idx field\n-  \/\/ in the malloc header can hold.\n+  \/\/ Table cannot be wider than a 16bit bucket idx can hold\n+#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n+  \/\/ Each bucket chain cannot be longer than what a 16 bit pos idx can hold (hopefully way shorter)\n+#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n+\n@@ -118,0 +121,7 @@\n+  static uint32_t build_marker(unsigned bucket_idx, unsigned pos_idx) {\n+    assert(bucket_idx <= MAX_MALLOCSITE_TABLE_SIZE && pos_idx < MAX_BUCKET_LENGTH, \"overflow\");\n+    return (uint32_t)bucket_idx << 16 | pos_idx;\n+  }\n+  static uint16_t bucket_idx_from_marker(uint32_t marker) { return marker >> 16; }\n+  static uint16_t pos_idx_from_marker(uint32_t marker) { return marker & 0xFFFF; }\n+\n@@ -119,0 +129,1 @@\n+\n@@ -126,3 +137,2 @@\n-  static inline bool access_stack(NativeCallStack& stack, size_t bucket_idx,\n-    size_t pos_idx) {\n-    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+  static inline bool access_stack(NativeCallStack& stack, uint32_t marker) {\n+    MallocSite* site = malloc_site(marker);\n@@ -137,3 +147,2 @@\n-  \/\/ Return true if the allocation is recorded successfully, bucket_idx\n-  \/\/ and pos_idx are also updated to indicate the entry where the allocation\n-  \/\/ information was recorded.\n+  \/\/ Return true if the allocation is recorded successfully and updates marker\n+  \/\/ to indicate the entry where the allocation information was recorded.\n@@ -144,2 +153,2 @@\n-    size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) {\n-    MallocSite* site = lookup_or_add(stack, bucket_idx, pos_idx, flags);\n+      uint32_t* marker, MEMFLAGS flags) {\n+    MallocSite* site = lookup_or_add(stack, marker, flags);\n@@ -150,1 +159,1 @@\n-  \/\/ Record memory deallocation. bucket_idx and pos_idx indicate where the allocation\n+  \/\/ Record memory deallocation. marker indicates where the allocation\n@@ -152,2 +161,2 @@\n-  static inline bool deallocation_at(size_t size, size_t bucket_idx, size_t pos_idx) {\n-    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+  static inline bool deallocation_at(size_t size, uint32_t marker) {\n+    MallocSite* site = malloc_site(marker);\n@@ -173,2 +182,2 @@\n-  static MallocSite* lookup_or_add(const NativeCallStack& key, size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags);\n-  static MallocSite* malloc_site(size_t bucket_idx, size_t pos_idx);\n+  static MallocSite* lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags);\n+  static MallocSite* malloc_site(uint32_t marker);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"services\/mallocTracker.inline.hpp\"\n@@ -117,14 +116,0 @@\n-void MallocHeader::release() {\n-  assert(MemTracker::enabled(), \"Sanity\");\n-\n-  assert_block_integrity();\n-\n-  MallocMemorySummary::record_free(size(), flags());\n-  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(size(), _bucket_idx, _pos_idx);\n-  }\n-\n-  mark_block_as_dead();\n-}\n-\n@@ -235,5 +220,0 @@\n-bool MallocHeader::record_malloc_site(const NativeCallStack& stack, size_t size,\n-  size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const {\n-  return MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);\n-}\n-\n@@ -241,1 +221,1 @@\n-  return MallocSiteTable::access_stack(stack, _bucket_idx, _pos_idx);\n+  return MallocSiteTable::access_stack(stack, _mst_marker);\n@@ -257,7 +237,10 @@\n-  const NativeCallStack& stack, NMT_TrackingLevel level) {\n-  assert(level != NMT_off, \"precondition\");\n-  void*         memblock;      \/\/ the address for user data\n-  MallocHeader* header = NULL;\n-\n-  if (malloc_base == NULL) {\n-    return NULL;\n+  const NativeCallStack& stack)\n+{\n+  assert(MemTracker::enabled(), \"precondition\");\n+  assert(malloc_base != NULL, \"precondition\");\n+\n+  MallocMemorySummary::record_malloc(size, flags);\n+  MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n+  uint32_t mst_marker = 0;\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::allocation_at(stack, size, &mst_marker, flags);\n@@ -267,3 +250,2 @@\n-\n-  header = ::new (malloc_base)MallocHeader(size, flags, stack, level);\n-  memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));\n+  MallocHeader* const header = ::new (malloc_base)MallocHeader(size, flags, stack, mst_marker);\n+  void* const memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));\n@@ -276,4 +258,6 @@\n-  if (level > NMT_off) {\n-    \/\/ Read back\n-    assert(get_size(memblock) == size,   \"Wrong size\");\n-    assert(get_flags(memblock) == flags, \"Wrong flags\");\n+  \/\/ Read back\n+  {\n+    MallocHeader* const header2 = malloc_header(memblock);\n+    assert(header2->size() == size, \"Wrong size\");\n+    assert(header2->flags() == flags, \"Wrong flags\");\n+    header2->assert_block_integrity();\n@@ -287,3 +271,14 @@\n-  assert(MemTracker::tracking_level() != NMT_off && memblock != NULL, \"precondition\");\n-  MallocHeader* header = malloc_header(memblock);\n-  header->release();\n+  assert(MemTracker::enabled(), \"Sanity\");\n+  assert(memblock != NULL, \"precondition\");\n+\n+  MallocHeader* const header = malloc_header(memblock);\n+  header->assert_block_integrity();\n+\n+  MallocMemorySummary::record_free(header->size(), header->flags());\n+  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n+  }\n+\n+  header->mark_block_as_dead();\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n- *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n@@ -280,1 +280,1 @@\n- *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n@@ -295,5 +295,4 @@\n-  size_t _size;\n-  uint16_t _bucket_idx;\n-  uint16_t _pos_idx;\n-  uint8_t _flags;\n-  uint8_t _unused;\n+  const size_t _size;\n+  const uint32_t _mst_marker;\n+  const uint8_t _flags;\n+  const uint8_t _unused;\n@@ -302,3 +301,0 @@\n-#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n-#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n-\n@@ -315,3 +311,0 @@\n-  \/\/ If block is broken, print out a report to tty (optionally with\n-  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n-  void assert_block_integrity() const;\n@@ -319,1 +312,0 @@\n-  void mark_block_as_dead();\n@@ -329,1 +321,4 @@\n-  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, NMT_TrackingLevel level) {\n+  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n+    : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n+      _unused(0), _canary(_header_canary_life_mark)\n+  {\n@@ -331,16 +326,0 @@\n-\n-    _flags = NMTUtil::flag_to_index(flags);\n-    set_size(size);\n-    if (level == NMT_detail) {\n-      size_t bucket_idx;\n-      size_t pos_idx;\n-      if (record_malloc_site(stack, size, &bucket_idx, &pos_idx, flags)) {\n-        assert(bucket_idx <= MAX_MALLOCSITE_TABLE_SIZE, \"Overflow bucket index\");\n-        assert(pos_idx <= MAX_BUCKET_LENGTH, \"Overflow bucket position index\");\n-        _bucket_idx = (uint16_t)bucket_idx;\n-        _pos_idx = (uint16_t)pos_idx;\n-      }\n-    }\n-\n-    _unused = 0;\n-    _canary = _header_canary_life_mark;\n@@ -351,3 +330,0 @@\n-\n-    MallocMemorySummary::record_malloc(size, flags);\n-    MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n@@ -358,0 +334,1 @@\n+  inline uint32_t mst_marker() const { return _mst_marker; }\n@@ -360,2 +337,1 @@\n-  \/\/ Cleanup tracking information and mark block as dead before the memory is released.\n-  void release();\n+  void mark_block_as_dead();\n@@ -368,6 +344,3 @@\n- private:\n-  inline void set_size(size_t size) {\n-    _size = size;\n-  }\n-  bool record_malloc_site(const NativeCallStack& stack, size_t size,\n-    size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const;\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  void assert_block_integrity() const;\n@@ -386,9 +359,3 @@\n-  \/\/ malloc tracking header size for specific tracking level\n-  static inline size_t malloc_header_size(NMT_TrackingLevel level) {\n-    return (level == NMT_off) ? 0 : sizeof(MallocHeader);\n-  }\n-\n-  \/\/ malloc tracking footer size for specific tracking level\n-  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n-    return (level == NMT_off) ? 0 : sizeof(uint16_t);\n-  }\n+  \/\/ The overhead that is incurred by switching on NMT (we need, per malloc allocation,\n+  \/\/ space for header and 16-bit footer)\n+  static const size_t overhead_per_malloc = sizeof(MallocHeader) + sizeof(uint16_t);\n@@ -406,1 +373,1 @@\n-    const NativeCallStack& stack, NMT_TrackingLevel level);\n+    const NativeCallStack& stack);\n@@ -411,19 +378,0 @@\n-  \/\/ Offset memory address to header address\n-  static inline void* get_base(void* memblock);\n-  static inline void* get_base(void* memblock, NMT_TrackingLevel level) {\n-    if (memblock == NULL || level == NMT_off) return memblock;\n-    return (char*)memblock - malloc_header_size(level);\n-  }\n-\n-  \/\/ Get memory size\n-  static inline size_t get_size(void* memblock) {\n-    MallocHeader* header = malloc_header(memblock);\n-    return header->size();\n-  }\n-\n-  \/\/ Get memory type\n-  static inline MEMFLAGS get_flags(void* memblock) {\n-    MallocHeader* header = malloc_header(memblock);\n-    return header->flags();\n-  }\n-\n@@ -441,1 +389,1 @@\n- private:\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":20,"deletions":72,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n-#define SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n-\n-#include \"services\/mallocTracker.hpp\"\n-\n-#include \"services\/memTracker.hpp\"\n-\n-inline void* MallocTracker::get_base(void* memblock){\n-  return get_base(memblock, MemTracker::tracking_level());\n-}\n-\n-#endif \/\/ SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/mallocTracker.inline.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"services\/mallocTracker.inline.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n@@ -93,4 +93,0 @@\n-void* MemTracker::malloc_base(void* memblock) {\n-  return MallocTracker::get_base(memblock);\n-}\n-\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,5 @@\n+  \/\/ Per-malloc overhead incurred by NMT, depending on the current NMT level\n+  static size_t overhead_per_malloc() {\n+    return enabled() ? MallocTracker::overhead_per_malloc : 0;\n+  }\n+\n@@ -91,3 +96,3 @@\n-    const NativeCallStack& stack, NMT_TrackingLevel level) {\n-    if (level != NMT_off) {\n-      return MallocTracker::record_malloc(mem_base, size, flag, stack, level);\n+    const NativeCallStack& stack) {\n+    if (enabled()) {\n+      return MallocTracker::record_malloc(mem_base, size, flag, stack);\n@@ -98,14 +103,0 @@\n-  static inline size_t malloc_header_size(NMT_TrackingLevel level) {\n-    return MallocTracker::malloc_header_size(level);\n-  }\n-\n-  \/\/ malloc tracking footer size for specific tracking level\n-  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n-    return MallocTracker::malloc_footer_size(level);\n-  }\n-\n-  \/\/ To malloc base address, which is the starting address\n-  \/\/ of malloc tracking header if tracking is enabled.\n-  \/\/ Otherwise, it returns the same address.\n-  static void* malloc_base(void* memblock);\n-\n@@ -113,1 +104,1 @@\n-  static inline void* record_free(void* memblock, NMT_TrackingLevel level) {\n+  static inline void* record_free(void* memblock) {\n@@ -115,1 +106,1 @@\n-    if (level == NMT_off || memblock == NULL) {\n+    if (!enabled()) {\n@@ -121,1 +112,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    assert(flag_is_valid(flag), \"Invalid flag\");\n+    assert(flag_is_valid(flag), \"Invalid flag (%u)\", (unsigned)flag);\n@@ -101,1 +101,1 @@\n-    assert(flag_index_is_valid(index), \"Invalid flag\");\n+    assert(flag_index_is_valid(index), \"Invalid flag index (%d)\", index);\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,0 +482,4 @@\n+  if (p == NULL) {\n+    tty->print_cr(\"NULL\");\n+    return;\n+  }\n@@ -501,1 +505,1 @@\n-        const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(p, tracking_level);\n+        const MallocHeader* mhdr = MallocTracker::malloc_header(p);\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}