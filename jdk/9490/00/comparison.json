{"files":[{"patch":"@@ -147,6 +147,3 @@\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the HeapRegion.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr,\n-                                                    HeapWord* pb) const;\n+  inline HeapWord* advance_to_block_containing_addr(const void* addr,\n+                                                    HeapWord* const pb,\n+                                                    HeapWord* first_block) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,19 +85,0 @@\n-inline HeapWord* HeapRegion::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                              const void* addr,\n-                                                              HeapWord* pb) const {\n-  while (n <= addr) {\n-    \/\/ When addr is not covered by the block starting at q we need to\n-    \/\/ step forward until we find the correct block. With the BOT\n-    \/\/ being precise, we should never have to step through more than\n-    \/\/ a single card.\n-    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(n, (HeapWord*)addr), \"must be\");\n-    q = n;\n-    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n-        \"start of block must be an initialized object\");\n-    n += block_size(q, pb);\n-  }\n-  assert(q <= addr, \"wrong order for q and addr\");\n-  assert(addr < n, \"wrong order for addr and n\");\n-  return q;\n-}\n-\n@@ -108,0 +89,17 @@\n+inline HeapWord* HeapRegion::advance_to_block_containing_addr(const void* addr,\n+                                                              HeapWord* const pb,\n+                                                              HeapWord* first_block) const {\n+  HeapWord* cur_block = first_block;\n+  while (true) {\n+    HeapWord* next_block = cur_block + block_size(cur_block, pb);\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    cur_block = next_block;\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+  }\n+}\n+\n@@ -109,5 +107,2 @@\n-  HeapWord* q = _bot_part.block_start_reaching_into_card(addr);\n-  \/\/ The returned address is the block that reaches into the card of addr. Walk\n-  \/\/ the heap to get to the block reaching into addr.\n-  HeapWord* n = q + block_size(q, pb);\n-  return forward_to_block_containing_addr(q, n, addr, pb);\n+  HeapWord* first_block = _bot_part.block_start_reaching_into_card(addr);\n+  return advance_to_block_containing_addr(addr, pb, first_block);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"}]}