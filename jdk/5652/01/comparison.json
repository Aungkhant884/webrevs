{"files":[{"patch":"@@ -68,1 +68,2 @@\n-    StringNullCheckMode\n+    StringNullCheckMode,\n+    NegativeIntCheckMode\n@@ -125,0 +126,1 @@\n+\n@@ -128,0 +130,5 @@\n+\n+  void push_negative_int_check(Node* value) {\n+    push(value, NegativeIntCheckMode);\n+  }\n+\n@@ -131,0 +138,1 @@\n+\n@@ -505,1 +513,2 @@\n-                  alloc->jvms()->dump_spec(tty); tty->cr();\n+                  alloc->jvms()->dump_spec(tty);\n+                  tty->cr();\n@@ -512,0 +521,21 @@\n+            } else if (sig == ciSymbols::int_void_signature()) {\n+              \/\/ StringBuilder(int) case.\n+              Node* parm = use->in(TypeFunc::Parms + 1);\n+              assert(parm != NULL, \"must exist\");\n+              const TypeInt* type = _gvn->type(parm)->is_int();\n+              if (type->_hi < 0) {\n+                \/\/ Initial capacity argument is always negative in which case StringBuilder(int) throws\n+                \/\/ a NegativeArraySizeException. Bail out from string opts.\n+#ifndef PRODUCT\n+                if (PrintOptimizeStringConcat) {\n+                  tty->print(\"giving up because a negative argument is passed to StringBuilder(int) which \"\n+                             \"throws a NegativeArraySizeException\");\n+                  alloc->jvms()->dump_spec(tty);\n+                  tty->cr();\n+                }\n+#endif\n+                return NULL;\n+              } else if (type->_lo < 0) {\n+                \/\/ Argument could be negative: We need a runtime check to throw NegativeArraySizeException in that case.\n+                sc->push_negative_int_check(parm);\n+              }\n@@ -1797,0 +1827,17 @@\n+      case StringConcat::NegativeIntCheckMode: {\n+        \/\/ Initial capacity argument might be negative in which case StringBuilder(int) throws\n+        \/\/ a NegativeArraySizeException. Insert a runtime check with an uncommon trap.\n+        const TypeInt* type = kit.gvn().type(arg)->is_int();\n+        assert(type->_hi >= 0 && type->_lo < 0, \"no runtime int check needed\");\n+        Node* p = __ Bool(__ CmpI(arg, kit.intcon(0)), BoolTest::ge);\n+        IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);\n+        {\n+          \/\/ Negative int -> uncommon trap.\n+          PreserveJVMState pjvms(&kit);\n+          kit.set_control(__ IfFalse(iff));\n+          kit.uncommon_trap(Deoptimization::Reason_intrinsic,\n+                            Deoptimization::Action_maybe_recompile);\n+        }\n+        kit.set_control(__ IfTrue(iff));\n+        break;\n+      }\n@@ -1966,0 +2013,2 @@\n+          case StringConcat::NegativeIntCheckMode:\n+            break; \/\/ Nothing to do, was only needed to add a runtime check earlier.\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271459\n+ * @requires vm.compiler2.enabled\n+ * @summary C2 applies string opts to StringBuilder object created with a negative size and misses the NegativeArraySizeException.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stringopts.TestNegativeArraySize\n+ *\/\n+\n+package compiler.c2.irTests.stringopts;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class TestNegativeArraySize {\n+\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        \/\/ Dont inline any StringBuilder methods for this IR test to check if string opts are applied or not.\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=dontinline,java.lang.StringBuilder::*\");\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\", IRNode.INTRINSIC_TRAP})\n+    static String positiveConst() {\n+        \/\/ C2 knows that argument is 5 and applies string opts without runtime check.\n+        StringBuilder sb = new StringBuilder(5); \/\/ StringBuilder object optimized away by string opts.\n+        return sb.toString(); \/\/ Call optimized away by string opts.\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_OF, \"StringBuilder\", \"1\", IRNode.CALL_OF_METHOD, \"toString\", \"1\"})\n+    @IR(failOn = IRNode.INTRINSIC_TRAP) \/\/ No runtime check, we bail out of string opts\n+    static String negativeConst() {\n+        StringBuilder sb = new StringBuilder(-5); \/\/ C2 knows that we always have a negative int -> bail out of string opts\n+        return sb.toString(); \/\/ Call stays due to bailout.\n+    }\n+\n+    @Run(test = \"negativeConst\")\n+    static void runNegativeConst() {\n+        try {\n+            negativeConst();\n+            Asserts.fail(\"should have thrown exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n+    @IR(counts = {IRNode.INTRINSIC_TRAP, \"1\"}) \/\/ Uncommon trap of runtime check\n+    static String positiveFld() {\n+        \/\/ C2 does not know if iFld is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path, however, is never taken because iFld is always positive.\n+        StringBuilder sb = new StringBuilder(iFld);\n+        return sb.toString();\n+    }\n+\n+    @Run(test = \"positiveFld\")\n+    static void runPositiveFld() {\n+        iFld = 4;\n+        positiveFld();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n+    @IR(counts = {IRNode.INTRINSIC_TRAP, \"1\"}) \/\/ Uncommon trap of runtime check\n+    static String negativeFld() {\n+        \/\/ C2 does not know if iFld is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is always taken because iFld is always negative.\n+        StringBuilder sb = new StringBuilder(iFld);\n+        return sb.toString();\n+    }\n+\n+    @Run(test = \"negativeFld\")\n+    static void runNegativeFld() {\n+        iFld = -4;\n+        try {\n+            negativeFld();\n+            Asserts.fail(\"should have thrown exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n+    @IR(counts = {IRNode.INTRINSIC_TRAP, \"1\"}) \/\/ Uncommon trap of runtime check\n+    static String maybeNegativeConst(boolean flag) {\n+        \/\/ C2 knows that cap is between -5 and 5. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is sometimes taken and sometimes not.\n+        int cap = flag ? 5 : -5;\n+        StringBuilder sb = new StringBuilder(cap);\n+        return sb.toString();\n+    }\n+\n+    @Run(test = \"maybeNegativeConst\")\n+    static void runMaybeNegativeConst() {\n+        boolean flag = TestFramework.toggleBoolean();\n+        try {\n+            maybeNegativeConst(flag);\n+            Asserts.assertTrue(flag);\n+        } catch (NegativeArraySizeException e) {\n+            Asserts.assertFalse(flag);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\", IRNode.INTRINSIC_TRAP})\n+    static String alwaysPositiveConst(boolean flag) {\n+        \/\/ C2 knows that cap is between 1 and 100 and applies string opts without runtime check.\n+        int cap = flag ? 1 : 100;\n+        StringBuilder sb = new StringBuilder(cap); \/\/ Object optimized away.\n+        return sb.toString(); \/\/ Optimized away.\n+    }\n+\n+    @Run(test = \"alwaysPositiveConst\")\n+    static void runAlwaysPositiveConst() {\n+        alwaysPositiveConst(TestFramework.toggleBoolean());\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n+    @IR(counts = {IRNode.INTRINSIC_TRAP, \"1\"}) \/\/ Uncommon trap of runtime check\n+    static String negativeArg(int cap) {\n+        \/\/ C2 does not know if cap is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is always taken because cap is always negative.\n+        StringBuilder sb = new StringBuilder(cap);\n+        return sb.toString();\n+    }\n+\n+    @Run(test = \"negativeArg\")\n+    static void runNegativeArg() {\n+        try {\n+            negativeArg(-5);\n+            Asserts.fail(\"should have thrown exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n+    @IR(counts = {IRNode.INTRINSIC_TRAP, \"1\"}) \/\/ Uncommon trap of runtime check\n+    static String positiveArg(int cap) {\n+        \/\/ C2 does not know if cap is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path, however, is never taken because cap is always positive.\n+        StringBuilder sb = new StringBuilder(cap);\n+        return sb.toString();\n+    }\n+\n+    @Run(test = \"positiveArg\")\n+    static void runPositiveArg() {\n+        positiveArg(5);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stringopts\/TestNegativeArraySize.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -117,3 +117,4 @@\n-    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n-    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallDynamicJava\" + MID + IS_REPLACED + END;\n-    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallStaticJava\" + MID + IS_REPLACED + END;\n+    public static final String CALL = START + \"Call.*Java\" + MID + END;\n+    public static final String CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"Call.*Java\" + MID + IS_REPLACED + \" \" +  END;\n+    public static final String DYNAMIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallDynamicJava\" + MID + IS_REPLACED + \" \" + END;\n+    public static final String STATIC_CALL_OF_METHOD = COMPOSITE_PREFIX + START + \"CallStaticJava\" + MID + IS_REPLACED + \" \" +  END;\n@@ -128,0 +129,1 @@\n+    public static final String INTRINSIC_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,0 +103,6 @@\n+        runCheck(GoodRuleConstraint.create(Calls.class, \"calls()\", 1),\n+                 BadFailOnConstraint.create(Calls.class, \"calls()\", 2, 1, \"CallStaticJava\", \"dontInline\"),\n+                 BadFailOnConstraint.create(Calls.class, \"calls()\", 2, 2, \"CallStaticJava\", \"dontInline\"),\n+                 GoodRuleConstraint.create(Calls.class, \"calls()\", 3)\n+        );\n+\n@@ -188,2 +194,3 @@\n-                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n-                 GoodRuleConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 4)\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"intrinsic\"),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 4, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 5)\n@@ -870,0 +877,23 @@\n+class Calls {\n+\n+    @Test\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    @IR(failOn = {IRNode.CALL_OF_METHOD, \"dontInline\",  \/\/ Fails\n+                  IRNode.STATIC_CALL_OF_METHOD, \"dontInline\"}) \/\/ Fails\n+    @IR(failOn = {IRNode.CALL_OF_METHOD, \"forceInline\",\n+                  IRNode.STATIC_CALL_OF_METHOD, \"forceInline\",\n+                  IRNode.CALL_OF_METHOD, \"dontInlines\",\n+                  IRNode.STATIC_CALL_OF_METHOD, \"dontInlines\",\n+                  IRNode.CALL_OF_METHOD, \"dont\",\n+                  IRNode.STATIC_CALL_OF_METHOD, \"dont\"})\n+    public void calls() {\n+        dontInline();\n+        forceInline();\n+    }\n+\n+    @DontInline\n+    public void dontInline() {}\n+\n+    @ForceInline\n+    public void forceInline() {}\n+}\n@@ -997,0 +1027,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1017,0 +1048,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1036,0 +1068,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1052,0 +1085,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1067,0 +1101,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1085,0 +1120,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1103,0 +1139,1 @@\n+                  IRNode.INTRINSIC_TRAP,\n@@ -1113,0 +1150,1 @@\n+    @IR(failOn = IRNode.INTRINSIC_TRAP) \/\/ fails\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"}]}