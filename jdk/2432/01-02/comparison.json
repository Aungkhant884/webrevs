{"files":[{"patch":"@@ -192,1 +192,1 @@\n-  __ load_const_optimized(tmp1, SharedRuntime::get_handle_wrong_method_stub(), tmp2);\n+  __ calculate_address_from_global_toc(tmp1, SharedRuntime::get_handle_wrong_method_stub(), true, true, false);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,3 +111,2 @@\n-  \/\/ Nothing to do.\n-  \/\/ Unlike other platforms, the frame resolution is done in the nmethod entry barrier stub.\n-  \/\/ This way, writing frame information on the stack can be avoided.\n+  \/\/ As PPC64 always has a valid back chain (unlike other platforms), the stub can simply pop the frame.\n+  \/\/ Thus, there's nothing to do here.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3591,2 +3591,3 @@\n-    \/\/ Restore link register. Points to an instruction in the previous Java frame; effectively resuming\n-    \/\/ its execution after this method's deoptimization.  This method's prologue is aborted.\n+    \/\/ Restore link register.  Required as the 'wrong method stub' needs the caller's frame\n+    \/\/ to properly deoptimize this method (e.g. by re-resolving the call site for compiled methods).\n+    \/\/ This method's prologue is aborted.\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}