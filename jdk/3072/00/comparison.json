{"files":[{"patch":"@@ -58,0 +58,9 @@\n+    \/*\n+     * File header flags.\n+     *\/\n+    private static final int FTEXT      = 1;    \/\/ Extra text\n+    private static final int FHCRC      = 2;    \/\/ Header CRC\n+    private static final int FEXTRA     = 4;    \/\/ Extra field\n+    private static final int FNAME      = 8;    \/\/ File name\n+    private static final int FCOMMENT   = 16;   \/\/ File comment\n+\n@@ -137,0 +146,67 @@\n+    \/**\n+     * Creates a new output stream with the specified buffer size,\n+     * flush mode and flags.\n+     *\n+     * @param out the output stream\n+     * @param size the output buffer size\n+     * @param syncFlush\n+     *        if {@code true} invocation of the inherited\n+     *        {@link DeflaterOutputStream#flush() flush()} method of\n+     *        this instance flushes the compressor with flush mode\n+     *        {@link Deflater#SYNC_FLUSH} before flushing the output\n+     *        stream, otherwise only flushes the output stream\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPOutputStream(OutputStream out,\n+                            int size,\n+                            boolean syncFlush,\n+                            boolean generateHeaderCRC,\n+                            byte[] extraFieldBytes,\n+                            byte[] filename,\n+                            byte[] fileComment)\n+        throws IOException\n+    {\n+        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n+              size,\n+              syncFlush);\n+        usesDefaultDeflater = true;\n+        writeHeader(generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+        crc.reset();\n+    }\n+\n+    \/**\n+     * Creates a new output stream with the specified flags.\n+     *\n+     * @param out the output stream\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPOutputStream(OutputStream out,\n+                            boolean generateHeaderCRC,\n+                            byte[] extraFieldBytes,\n+                            byte[] filename,\n+                            byte[] fileComment)\n+        throws IOException\n+    {\n+        this(out, 512, false, generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+    }\n+\n@@ -199,0 +275,108 @@\n+    \/**\n+     * Writes GZIP member header with optional header flags, per RFC-1952.\n+     *\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     *\/\n+    private void writeHeader(boolean generateHeaderCRC,\n+                             byte[] extraFieldBytes,\n+                             byte[] filename,\n+                             byte[] fileComment) throws IOException {\n+        byte flags = 0;\n+        \/\/ set flags.\n+        if (generateHeaderCRC == true) {\n+            flags |= FHCRC;\n+        }\n+        if (extraFieldBytes != null && extraFieldBytes.length != 0) {\n+            flags |= FEXTRA;\n+        }\n+        if (filename != null && filename.length != 0) {\n+            flags |= FNAME;\n+        }\n+        if (fileComment != null && fileComment.length != 0) {\n+            flags |= FCOMMENT;\n+        }\n+\n+        \/\/ the head of header.\n+        byte [] head = new byte[] {\n+                           (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n+                           (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n+                           Deflater.DEFLATED,        \/\/ Compression method (CM)\n+                           flags,                    \/\/ Flags (FLG)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Extra flags (XFLG)\n+                           OS_UNKNOWN                \/\/ Operating system (OS)\n+        };\n+        \/\/ write head.\n+        out.write(head);\n+        if (generateHeaderCRC) {\n+            crc.update(head, 0, head.length);\n+        }\n+\n+        \/\/ write extra field.\n+        if ((flags & FEXTRA) == FEXTRA) {\n+            \/* extra field, per RFC-1952\n+             *     +---+---+=================================+\n+             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n+             *     +---+---+=================================+\n+             *\/\n+            int xlen = extraFieldBytes.length;\n+            if (xlen > 0xffff) {\n+                throw new ZipException(\"extra field size out of range\");\n+            }\n+            \/\/ write XLEN.\n+            out.write((byte)(xlen & 0xff));\n+            out.write((byte)((xlen >> 8) & 0xff));\n+            \/\/ write extra field bytes.\n+            out.write(extraFieldBytes);\n+            if (generateHeaderCRC) {\n+                crc.update((byte)(xlen & 0xff));\n+                crc.update(((byte)(xlen >> 8) & 0xff));\n+                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n+            }\n+        }\n+        \/\/ write file name.\n+        if ((flags & FNAME) == FNAME) {\n+            \/*\n+             *    +=========================================+\n+             *    |...original file name, zero-terminated...|\n+             *    +=========================================+\n+             *\/\n+            out.write(filename);\n+            out.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(filename, 0, filename.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write file comment.\n+        if ((flags & FCOMMENT) == FCOMMENT) {\n+            \/*\n+             *    +===================================+\n+             *    |...file comment, zero-terminated...|\n+             *    +===================================+\n+             *\/\n+            out.write(fileComment);\n+            out.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(fileComment, 0, fileComment.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write header crc16.\n+        if ((flags & FHCRC) == FHCRC) {\n+            int crc16 = (int)crc.getValue() & 0xffff;\n+            out.write((byte)(crc16 & 0xff));\n+            out.write((byte)(crc16 >> 8) & 0xff);\n+            crc.reset();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"modified"}]}