{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,9 @@\n+    \/*\n+     * File header flags.\n+     *\/\n+    private static final int FTEXT      = 1;    \/\/ Extra text\n+    private static final int FHCRC      = 2;    \/\/ Header CRC\n+    private static final int FEXTRA     = 4;    \/\/ Extra field\n+    private static final int FNAME      = 8;    \/\/ File name\n+    private static final int FCOMMENT   = 16;   \/\/ File comment\n+\n@@ -137,0 +146,67 @@\n+    \/**\n+     * Creates a new output stream with the specified buffer size,\n+     * flush mode and flags.\n+     *\n+     * @param out the output stream\n+     * @param size the output buffer size\n+     * @param syncFlush\n+     *        if {@code true} invocation of the inherited\n+     *        {@link DeflaterOutputStream#flush() flush()} method of\n+     *        this instance flushes the compressor with flush mode\n+     *        {@link Deflater#SYNC_FLUSH} before flushing the output\n+     *        stream, otherwise only flushes the output stream\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPOutputStream(OutputStream out,\n+                            int size,\n+                            boolean syncFlush,\n+                            boolean generateHeaderCRC,\n+                            byte[] extraFieldBytes,\n+                            byte[] filename,\n+                            byte[] fileComment)\n+        throws IOException\n+    {\n+        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n+              size,\n+              syncFlush);\n+        usesDefaultDeflater = true;\n+        writeHeader(generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+        crc.reset();\n+    }\n+\n+    \/**\n+     * Creates a new output stream with the specified flags.\n+     *\n+     * @param out the output stream\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPOutputStream(OutputStream out,\n+                            boolean generateHeaderCRC,\n+                            byte[] extraFieldBytes,\n+                            byte[] filename,\n+                            byte[] fileComment)\n+        throws IOException\n+    {\n+        this(out, 512, false, generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+    }\n+\n@@ -182,1 +258,1 @@\n-     * Writes GZIP member header.\n+     * Writes GZIP member header without any header flags.\n@@ -185,12 +261,109 @@\n-        out.write(new byte[] {\n-                      (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n-                      (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n-                      Deflater.DEFLATED,        \/\/ Compression method (CM)\n-                      0,                        \/\/ Flags (FLG)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Extra flags (XFLG)\n-                      OS_UNKNOWN                \/\/ Operating system (OS)\n-                  });\n+        writeHeader(false, null, null, null);\n+    }\n+\n+    \/**\n+     * Writes GZIP member header with optional header flags, per RFC-1952.\n+     *\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes the byte array of extra filed,\n+     *                        the generated header would calculate the byte[] size\n+     *                        and fill it before the byte[] in header.\n+     * @param filename        the original file name.\n+     * @param fileComment     the file comment.\n+     *\/\n+    private void writeHeader(boolean generateHeaderCRC,\n+                             byte[] extraFieldBytes,\n+                             byte[] filename,\n+                             byte[] fileComment) throws IOException {\n+        byte flags = 0;\n+        \/\/ set flags.\n+        if (generateHeaderCRC == true) {\n+            flags |= FHCRC;\n+        }\n+        if (extraFieldBytes != null && extraFieldBytes.length != 0) {\n+            flags |= FEXTRA;\n+        }\n+        if (filename != null && filename.length != 0) {\n+            flags |= FNAME;\n+        }\n+        if (fileComment != null && fileComment.length != 0) {\n+            flags |= FCOMMENT;\n+        }\n+\n+        \/\/ the head of header.\n+        byte [] head = new byte[] {\n+                           (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n+                           (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n+                           Deflater.DEFLATED,        \/\/ Compression method (CM)\n+                           flags,                    \/\/ Flags (FLG)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Modification time MTIME (int)\n+                           0,                        \/\/ Extra flags (XFLG)\n+                           OS_UNKNOWN                \/\/ Operating system (OS)\n+        };\n+        \/\/ write head.\n+        out.write(head);\n+        if (generateHeaderCRC) {\n+            crc.update(head, 0, head.length);\n+        }\n+\n+        \/\/ write extra field.\n+        if ((flags & FEXTRA) == FEXTRA) {\n+            \/* extra field, per RFC-1952\n+             *     +---+---+=================================+\n+             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n+             *     +---+---+=================================+\n+             *\/\n+            int xlen = extraFieldBytes.length;\n+            if (xlen > 0xffff) {\n+                throw new ZipException(\"extra field size out of range\");\n+            }\n+            \/\/ write XLEN.\n+            out.write((byte)(xlen & 0xff));\n+            out.write((byte)((xlen >> 8) & 0xff));\n+            \/\/ write extra field bytes.\n+            out.write(extraFieldBytes);\n+            if (generateHeaderCRC) {\n+                crc.update((byte)(xlen & 0xff));\n+                crc.update(((byte)(xlen >> 8) & 0xff));\n+                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n+            }\n+        }\n+        \/\/ write file name.\n+        if ((flags & FNAME) == FNAME) {\n+            \/*\n+             *    +=========================================+\n+             *    |...original file name, zero-terminated...|\n+             *    +=========================================+\n+             *\/\n+            out.write(filename);\n+            out.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(filename, 0, filename.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write file comment.\n+        if ((flags & FCOMMENT) == FCOMMENT) {\n+            \/*\n+             *    +===================================+\n+             *    |...file comment, zero-terminated...|\n+             *    +===================================+\n+             *\/\n+            out.write(fileComment);\n+            out.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(fileComment, 0, fileComment.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write header crc16.\n+        if ((flags & FHCRC) == FHCRC) {\n+            int crc16 = (int)crc.getValue() & 0xffff;\n+            out.write((byte)(crc16 & 0xff));\n+            out.write((byte)(crc16 >> 8) & 0xff);\n+            crc.reset();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":187,"deletions":14,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.zip.CRC32;\n@@ -42,0 +43,1 @@\n+    private static final int FLAGS_HEADER_INDEX = 3;\n@@ -44,1 +46,5 @@\n-\n+    \/\/ flags for test\n+    private static final int FHCRC      = 2;    \/\/ Header CRC\n+    private static final int FEXTRA     = 4;    \/\/ Extra field\n+    private static final int FNAME      = 8;    \/\/ File name\n+    private static final int FCOMMENT   = 16;   \/\/ File comment\n@@ -47,1 +53,2 @@\n-     * has a value of {@code 255} which represents \"unknown\"\n+     * has a value of {@code 255} which represents \"unknown\", and test\n+     * that the flags and header crc16 field could be successfully set.\n@@ -52,0 +59,10 @@\n+        \/\/ header fields\n+        boolean generateHeaderCrc = true;\n+        \/\/ extra field\n+        byte[] xfield = \"extraFieldBytesTest\".getBytes();\n+        \/\/ file name\n+        byte[] fname = \"FileNameTest.tmp\".getBytes();\n+        \/\/ file comment\n+        byte[] fcomment = \"FileCommentTest\".getBytes();\n+        CRC32 crc = new CRC32();\n+        crc.reset();\n@@ -53,1 +70,5 @@\n-        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos);) {\n+        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos,\n+                                                                            generateHeaderCrc,\n+                                                                            xfield,\n+                                                                            fname,\n+                                                                            fcomment);) {\n@@ -60,0 +81,37 @@\n+        \/\/ test header flags\n+        byte expectedFlags = (byte) ((FHCRC | FEXTRA | FNAME | FCOMMENT) & 0xff);\n+        Assert.assertEquals(toUnsignedByte(compressed[FLAGS_HEADER_INDEX]), expectedFlags,\n+                \"Unexpected value for header flags\");\n+        \/\/ test extra field\n+        int index = OS_HEADER_INDEX + 1;\n+        int lo = toUnsignedByte(compressed[index++]);\n+        int hi = toUnsignedByte(compressed[index++]) << 8;\n+        int fieldLen = hi | lo;\n+        int expectedFieldLen = xfield.length;\n+        String fieldStr = new String(compressed, index, expectedFieldLen);\n+        Assert.assertEquals(fieldLen, expectedFieldLen, \"Unexpected length of extra field\");\n+        Assert.assertEquals(fieldStr, new String(xfield), \"Unexpected extra field contents\");\n+        index += expectedFieldLen;\n+\n+        \/\/ test file name\n+        int fnameLen = fname.length;\n+        String fn = new String(compressed, index, fnameLen);\n+        Assert.assertEquals(fn, new String(fname), \"Unexpected file name in header\");\n+        index += fnameLen;\n+        Assert.assertEquals(compressed[index++], 0, \"File name in header must be end with 0\");\n+\n+        \/\/ test file comment\n+        int fcommLen = fcomment.length;\n+        String fc = new String(compressed, index, fcommLen);\n+        Assert.assertEquals(fc, new String(fcomment), \"Unexpected file name in header\");\n+        index += fcommLen;\n+        Assert.assertEquals(compressed[index++], 0, \"File comment in header must be end with 0\");\n+\n+        \/\/ test crc of header (lower 16bits)\n+        crc.update(compressed, 0, index);\n+        int expected = (int)(crc.getValue()) & 0xffff;\n+        int low = toUnsignedByte(compressed[index++]);\n+        int high = toUnsignedByte(compressed[index++]) << 8;\n+        int headerCrc = high | low;\n+        Assert.assertEquals(headerCrc, expected, \"Unexpected CRC value of header\");\n+\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPOutputStreamHeaderTest.java","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"}]}