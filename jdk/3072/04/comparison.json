{"files":[{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\/**\n+ * This class implements the GZIP file header builder\n+ *\n+ * @author      Lin Zang\n+ * @since 17\n+ *\n+ *\/\n+public class GZIPHeaderBuilder {\n+    \/* compress method, only {@code Deflater.DEFLATED} supportted. *\/\n+    private byte cm;\n+    private byte[] extraFieldBytes;\n+    private String filename;\n+    private String fileComment;\n+    \/* Header flags, refer to definition in {@code GZIPHeaderData} *\/\n+    private byte flags;\n+    private int headerCrc16;\n+\n+    \/**\n+     * Creates a GZIP file header builder.\n+     * Current only {@code Deflater.DEFLATED} compress method supportted.\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder() {\n+        this.cm = (byte)Deflater.DEFLATED;\n+        this.extraFieldBytes = null;\n+        this.filename = null;\n+        this.fileComment = null;\n+        this.flags = 0;\n+        this.headerCrc16 = 0;\n+    }\n+\n+    \/**\n+     * Add extra field in GZIP file header.\n+     * This method verifies the extra fileds layout per RFC-1952.\n+     * See comments of {@code verifyExtraFieldLayout}\n+     *\n+     * @param extraFieldBytes The byte array of extra field.\n+     * @return {@code this}\n+     *\n+     * @throws ZipException if extra field layout is incorrect.\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withExtraFieldBytes(byte[] extraFieldBytes) throws ZipException {\n+        \/*\n+         * Here do verification before write data.\n+         *\/\n+        if (!verifyExtraFieldLayout(extraFieldBytes)) {\n+            throw new ZipException(\"incorrect extra field format\");\n+        }\n+        flags |= GZIPHeaderData.FEXTRA;\n+        this.extraFieldBytes = extraFieldBytes;\n+        return this;\n+    }\n+\n+    \/**\n+     * Add file name in GZIP file header.\n+     *\n+     * Per RFC-1952, the file name string should in ISO_8859-1 character set.\n+     *\n+     * @param filename The file name\n+     * @return {@code this}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withFileName(String filename) {\n+        if (filename == null || filename.length() == 0) {\n+            this.filename = null;\n+        }\n+        this.filename = filename;\n+        flags |= GZIPHeaderData.FNAME;\n+        return this;\n+    }\n+\n+    \/**\n+     * Add file comment in GZIP file header.\n+     *\n+     * Per RFC-1952, the file comment string should in ISO_8859-1 character set.\n+     *\n+     * @param fileComment The file comment\n+     * @return {@code this}'\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withFileComment(String fileComment) {\n+        if (fileComment == null || fileComment.length() == 0) {\n+            this.fileComment = null;\n+        }\n+        this.fileComment = fileComment;\n+        flags |= GZIPHeaderData.FCOMMENT;\n+        return this;\n+    }\n+\n+    \/**\n+     * Enable\/Disable the CRC calculation of GZIP file header.\n+     *\n+     * @param calculateHeaderCRC if {@code true} the header data contains the lower 16 bytes of header CRC\n+     * @return {@code this}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder calculateHeaderCRC(boolean calculateHeaderCRC) {\n+        if (calculateHeaderCRC) {\n+            flags |= GZIPHeaderData.FHCRC;\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     *  Generate the GZIP header data\n+     * @return the {@code record} of GZIP header data.\n+     *\n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not {@code Deflater.DEFLATED}\n+     * @since 17\n+     *\/\n+    public GZIPHeaderData build() throws IOException {\n+        byte[] headerBytes = generateBytes(cm, extraFieldBytes, filename, fileComment);\n+        return new GZIPHeaderData(cm, flags, extraFieldBytes, filename, fileComment, headerCrc16, headerBytes);\n+    }\n+\n+    \/**\n+     * Creates GZIP header bytes with optional header members and compress method.\n+     * Per RFC-1952:\n+     *    The filename and fileComment member should be String in\n+     *          LATIN-1 (ISO-8859-1) character set.\n+     *\n+     *    A compliant compressor must produce files with correct ID1,\n+     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n+     *          the fixed-length part of the header to default values (255 for\n+     *          OS, 0 for all others).  The compressor must set all reserved\n+     *          bits to zero.\n+     *\n+     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n+     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n+     *\n+     * @param cm                    compress method,\n+     *                              per RFC-1952, 0-7 are reserved, 8 denotes \"deflate\".\n+     *                              at present only support {@code Deflater.DEFLATED}\n+     *\n+     * @param extraFieldBytes\n+     *        The byte array of extra filed, the generated header would calculate the\n+     *        byte[] size and fill it before the byte[] in header.\n+     * @param filename              the original file name in ISO-8859-1 character set\n+     * @param fileComment           the file comment in ISO_8859-1 character set.\n+     *                              \n+     * @return Bytes of header data generated.\n+     * \n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not {@code Deflater.DEFLATED}.\n+     *\n+     * @since 17\n+     *\/\n+    public byte[] generateBytes(byte cm,\n+                                byte[] extraFieldBytes,\n+                                String filename,\n+                                String fileComment) throws IOException {\n+        CRC32 crc = new CRC32();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        \/\/ the head of header.\n+        byte [] head = new byte[] {\n+                (byte) GZIPHeaderData.GZIP_MAGIC,        \/\/ Magic number (short)\n+                (byte)(GZIPHeaderData.GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n+                cm,                       \/\/ Compression method (CM)\n+                flags,                    \/\/ Flags (FLG)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Extra flags (XFLG)\n+                GZIPHeaderData.OS_UNKNOWN                \/\/ Operating system (OS)\n+        };\n+        \/\/ write head.\n+        baos.write(head);\n+        \n+        if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+            crc.update(head, 0, head.length);\n+        }\n+\n+        \/\/ write extra field.\n+        if ((flags & GZIPHeaderData.FEXTRA) == GZIPHeaderData.FEXTRA) {\n+            \/* extra field, per RFC-1952:\n+             *     +---+---+=================================+\n+             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n+             *     +---+---+=================================+\n+             *\/\n+            int xlen = extraFieldBytes.length;\n+            if (xlen > 0xffff) {\n+                throw new ZipException(\"extra field size out of range\");\n+            }\n+            \/\/ write XLEN.\n+            baos.write((byte)(xlen & 0xff));\n+            baos.write((byte)((xlen >> 8) & 0xff));\n+            \/*\n+             * Here do verification before write data.\n+             *\/\n+            if (!verifyExtraFieldLayout(extraFieldBytes)) {\n+                throw new ZipException(\"incorrect extra field format\");\n+            };\n+            baos.write(extraFieldBytes);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update((byte)(xlen & 0xff));\n+                crc.update(((byte)(xlen >> 8) & 0xff));\n+                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n+            }\n+        }\n+        \/\/ write file name.\n+        if ((flags & GZIPHeaderData.FNAME) == GZIPHeaderData.FNAME) {\n+            \/*\n+             *    +=========================================+\n+             *    |...original file name, zero-terminated...|\n+             *    +=========================================+\n+             *\/\n+            byte[] filenameBytes = filename.getBytes(\"ISO-8859-1\");\n+            baos.write(filenameBytes);\n+            baos.write(0);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update(filenameBytes, 0, filenameBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write file comment.\n+        if ((flags & GZIPHeaderData.FCOMMENT) == GZIPHeaderData.FCOMMENT) {\n+            \/*\n+             *    +===================================+\n+             *    |...file comment, zero-terminated...|\n+             *    +===================================+\n+             *\/\n+            byte[] fcommBytes = fileComment.getBytes(\"ISO-8859-1\");\n+            baos.write(fcommBytes);\n+            baos.write(0);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update(fcommBytes, 0, fcommBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write header crc16.\n+        if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+            int crc16 = (int) crc.getValue() & 0xffff;\n+            this.headerCrc16 = crc16;\n+            baos.write((byte) (crc16 & 0xff));\n+            baos.write((byte) (crc16 >> 8) & 0xff);\n+            crc.reset();\n+        }\n+        return baos.toByteArray();\n+    }\n+    \n+    \/** verify extra field data layout.\n+     * Per RFC 1952:\n+     * If the FEXTRA bit is set, an \"extra field\" is present in\n+     * the header, with total length XLEN bytes.  It consists of a\n+     * series of subfields, each of the form:\n+     *\n+     * +---+---+---+---+==================================+\n+     * |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n+     * +---+---+---+---+==================================+\n+     *\n+     * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n+     * with some mnemonic value\n+     *\n+     * @param fieldBytes    the data of extra fileds.\n+     * @return {@code true} if field data layout is correct.\n+     *\n+     * @since 17\n+     *\/\n+    private boolean verifyExtraFieldLayout(byte[] fieldBytes) {\n+        int index = 0;\n+        int total = fieldBytes.length;\n+        while(index < total) {\n+            byte si1 = fieldBytes[index++];\n+            byte si2 = fieldBytes[index++];\n+            \/\/ si1 and si2 should be ASCII\n+            if (si1 > 127 || si2 > 127) return false;\n+            byte loLen = fieldBytes[index++];\n+            byte hiLen = fieldBytes[index++];\n+            int len = ((int)hiLen) << 8 | (int)loLen;\n+            index += len;\n+        }\n+        return index == total;\n+    }\n+\n+    \/**\n+     * This class implements the header of GZIP file which contains members defined\n+     * in the RFC 1952 specification\n+     *\n+     * @since 17\n+     *\n+     *\/\n+    public record GZIPHeaderData (byte compressMethod, byte flags,\n+                                  byte[] extraFieldBytes,\n+                                  String filename,\n+                                  String fileComment,\n+                                  int headerCRC16,\n+                                  byte[] headerBytes) {\n+        \/**\n+         * GZIP header magic number.\n+         *\/\n+        private static final int GZIP_MAGIC = 0x8b1f;\n+\n+        \/**\n+         * Represents the default \"unknown\" value for OS header, per RFC-1952\n+         *\/\n+        private static final byte OS_UNKNOWN = (byte) 255;\n+\n+        \/**\n+         * File header flags.\n+         *\n+         * Per RFC 1952, the header fields contains several members based on flag byte\n+         * This flag byte is divided into individual bits as follows:\n+         *\n+         *                bit 0   FTEXT        file probably ascii text\n+         *                bit 1   FHCRC        CRC16 for the gzip header\n+         *                bit 2   FEXTRA       extra field present\n+         *                bit 3   FNAME        original file name present\n+         *                bit 4   FCOMMENT     file comment present\n+         *                bit 5   reserved\n+         *                bit 6   reserved\n+         *                bit 7   reserved\n+         *\n+         *\/\n+        private static final int FTEXT      = 1;    \/\/ Extra text\n+        private static final int FHCRC      = 2;    \/\/ Header CRC\n+        private static final int FEXTRA     = 4;    \/\/ Extra field\n+        private static final int FNAME      = 8;    \/\/ File name\n+        private static final int FCOMMENT   = 16;   \/\/ File comment\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPHeaderBuilder.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+\n@@ -42,6 +43,1 @@\n-    protected CRC32 crc = new CRC32();\n-\n-    \/*\n-     * GZIP header magic number.\n-     *\/\n-    private static final int GZIP_MAGIC = 0x8b1f;\n+    private CRC32 crc = new CRC32();\n@@ -49,1 +45,1 @@\n-    \/*\n+    \/**\n@@ -55,3 +51,0 @@\n-    \/\/ Represents the default \"unknown\" value for OS header, per RFC-1952\n-    private static final byte OS_UNKNOWN = (byte) 255;\n-\n@@ -59,4 +52,2 @@\n-     * Creates a new output stream with the specified buffer size.\n-     *\n-     * <p>The new output stream instance is created as if by invoking\n-     * the 3-argument constructor GZIPOutputStream(out, size, false).\n+     * Creates a new output stream with the specified buffer size,\n+     * flush mode flags and header fields.\n@@ -66,0 +57,10 @@\n+     * @param syncFlush\n+     *        if {@code true} invocation of the inherited\n+     *        {@link DeflaterOutputStream#flush() flush()} method of\n+     *        this instance flushes the compressor with flush mode\n+     *        {@link Deflater#SYNC_FLUSH} before flushing the output\n+     *        stream, otherwise only flushes the output stream\n+     * @param gzipHeaderData\n+     *        The header of Gzip file, contains header members defined\n+     *        in RFC 1952. if {@code null}, use default header data.\n+     *\n@@ -67,1 +68,2 @@\n-     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n@@ -69,2 +71,15 @@\n-    public GZIPOutputStream(OutputStream out, int size) throws IOException {\n-        this(out, size, false);\n+    public GZIPOutputStream(OutputStream out,\n+                            int size,\n+                            boolean syncFlush,\n+                            GZIPHeaderBuilder.GZIPHeaderData gzipHeaderData)\n+            throws IOException\n+    {\n+        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n+                size,\n+                syncFlush);\n+        usesDefaultDeflater = true;\n+        if (gzipHeaderData == null) {\n+            gzipHeaderData = new GZIPHeaderBuilder().build();\n+        }\n+        writeHeader(gzipHeaderData.headerBytes());\n+        crc.reset();\n@@ -75,1 +90,1 @@\n-     * flush mode.\n+     * flush mode. And leave all other header fields set to default value.\n@@ -91,1 +106,1 @@\n-        throws IOException\n+            throws IOException\n@@ -93,6 +108,1 @@\n-        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n-              size,\n-              syncFlush);\n-        usesDefaultDeflater = true;\n-        writeHeader();\n-        crc.reset();\n+        this(out, size, syncFlush, null);\n@@ -101,0 +111,16 @@\n+    \/**\n+     * Creates a new output stream with the specified buffer size.\n+     * And leave all other header fields set to default value.\n+     *\n+     * <p>The new output stream instance is created as if by invoking\n+     * the 3-argument constructor GZIPOutputStream(out, size, false).\n+     *\n+     * @param out the output stream\n+     * @param size the output buffer size\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     *\/\n+    public GZIPOutputStream(OutputStream out, int size) throws IOException {\n+        this(out, size, false);\n+    }\n@@ -104,0 +130,1 @@\n+     * And leave all other header fields set to default value.\n@@ -117,1 +144,2 @@\n-     * the specified flush mode.\n+     * the specified flush mode. And leave all other header fields\n+     * set to default value.\n@@ -137,0 +165,19 @@\n+    \/**\n+     * Creates a new output stream with the specified flags.\n+     *\n+     * @param out the output stream\n+     * @param gzipHeaderData\n+     *        The header of Gzip file, contains header members defined\n+     *        in RFC 1952. if {@code null}, use default header data.\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPOutputStream(OutputStream out,\n+                            GZIPHeaderBuilder.GZIPHeaderData gzipHeaderData)\n+        throws IOException\n+    {\n+        this(out, 512, false, gzipHeaderData);\n+    }\n+\n@@ -181,2 +228,2 @@\n-    \/*\n-     * Writes GZIP member header.\n+    \/**\n+     * Writes GZIP header data.\n@@ -184,13 +231,2 @@\n-    private void writeHeader() throws IOException {\n-        out.write(new byte[] {\n-                      (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n-                      (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n-                      Deflater.DEFLATED,        \/\/ Compression method (CM)\n-                      0,                        \/\/ Flags (FLG)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Modification time MTIME (int)\n-                      0,                        \/\/ Extra flags (XFLG)\n-                      OS_UNKNOWN                \/\/ Operating system (OS)\n-                  });\n+    private void writeHeader(byte[] headerBytes) throws IOException {\n+        out.write(headerBytes);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":78,"deletions":42,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.zip.CRC32;\n@@ -32,0 +33,1 @@\n+import java.util.zip.GZIPHeaderBuilder;\n@@ -42,0 +44,1 @@\n+    private static final int FLAGS_HEADER_INDEX = 3;\n@@ -44,0 +47,5 @@\n+    \/\/ flags for test\n+    private static final int FHCRC      = 2;    \/\/ Header CRC\n+    private static final int FEXTRA     = 4;    \/\/ Extra field\n+    private static final int FNAME      = 8;    \/\/ File name\n+    private static final int FCOMMENT   = 16;   \/\/ File comment\n@@ -50,1 +58,1 @@\n-    public void testOSHeader() throws Exception {\n+    public void testOSHeaderWithDefaultMembers() throws Exception {\n@@ -71,0 +79,107 @@\n+    \/**\n+     * Test that the {@code OS} header field in the GZIP output stream\n+     * has a value of {@code 255} which represents \"unknown\", and test\n+     * that the flags and header crc16 field could be successfully set.\n+     *\/\n+    @Test\n+    public void testOSHeaderWithField() throws Exception {\n+        final String data = \"Hello world!!!\";\n+        \/\/ header fields\n+        boolean generateHeaderCrc = true;\n+        \/* extra field\n+         * per RFC 1952:\n+         * If the FLG.FEXTRA bit is set, an \"extra field\" is present in\n+         * the header, with total length XLEN bytes.  It consists of a\n+         * series of subfields, each of the form:\n+         *\n+         *   +---+---+---+---+==================================+\n+         *   |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n+         *   +---+---+---+---+==================================+\n+         *\n+         * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n+         * with some mnemonic value.\n+         *\n+         * Subfield\n+         * IDs with SI2 = 0 are reserved for future use.  The following\n+         * IDs are currently defined:\n+         *\n+         *   SI1         SI2         Data\n+         *   ----------  ----------  ----\n+         *   0x41 ('A')  0x70 ('P')  Apollo file type information\n+         *\/\n+        ByteArrayOutputStream fieldStream = new ByteArrayOutputStream();\n+        fieldStream.write(\"AP\".getBytes());\n+        String xFieldData = \"Apollo file type information\";\n+        int len = xFieldData.length();\n+        fieldStream.write((byte)(len & 0xff));\n+        fieldStream.write((byte) (len >> 8) & 0xff);\n+        fieldStream.write(xFieldData.getBytes());\n+        byte[] xfield = fieldStream.toByteArray();\n+        \/\/ file name\n+        String fname = \"FileNameTest.tmp\";\n+        \/\/ file comment\n+        String fcomment = \"FileCommentTest\";\n+        CRC32 crc = new CRC32();\n+        crc.reset();\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        GZIPHeaderBuilder.GZIPHeaderData headerData = new GZIPHeaderBuilder()\n+                                                            .withExtraFieldBytes(xfield)\n+                                                            .withFileName(fname)\n+                                                            .withFileComment(fcomment)\n+                                                            .calculateHeaderCRC(generateHeaderCrc)\n+                                                            .build();\n+        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos, headerData);) {\n+            gzipOutputStream.write(data.getBytes(StandardCharsets.UTF_8));\n+        }\n+        final byte[] compressed = baos.toByteArray();\n+        Assert.assertNotNull(compressed, \"Compressed data is null\");\n+        Assert.assertEquals(toUnsignedByte(compressed[OS_HEADER_INDEX]), HEADER_VALUE_OS_UNKNOWN,\n+                \"Unexpected value for OS header\");\n+        \/\/ test header flags\n+        byte expectedFlags = (byte) ((FHCRC | FEXTRA | FNAME | FCOMMENT) & 0xff);\n+        Assert.assertEquals(toUnsignedByte(compressed[FLAGS_HEADER_INDEX]), expectedFlags,\n+                \"Unexpected value for header flags\");\n+        \/\/ test extra field\n+        int index = OS_HEADER_INDEX + 1;\n+        int lo = toUnsignedByte(compressed[index++]);\n+        int hi = toUnsignedByte(compressed[index++]) << 8;\n+        int fieldLen = hi | lo;\n+        int expectedFieldLen = xfield.length;\n+        String fieldStr = new String(compressed, index, expectedFieldLen);\n+        Assert.assertEquals(fieldLen, expectedFieldLen, \"Unexpected length of extra field\");\n+        Assert.assertEquals(fieldStr, new String(xfield), \"Unexpected extra field contents\");\n+        index += expectedFieldLen;\n+\n+        \/\/ test file name\n+        int fnameLen = fname.length();\n+        String fn = new String(compressed, index, fnameLen);\n+        Assert.assertEquals(fn, new String(fname), \"Unexpected file name in header\");\n+        index += fnameLen;\n+        Assert.assertEquals(compressed[index++], 0, \"File name in header must be end with 0\");\n+\n+        \/\/ test file comment\n+        int fcommLen = fcomment.length();\n+        String fc = new String(compressed, index, fcommLen);\n+        Assert.assertEquals(fc, new String(fcomment), \"Unexpected file name in header\");\n+        index += fcommLen;\n+        Assert.assertEquals(compressed[index++], 0, \"File comment in header must be end with 0\");\n+\n+        \/\/ test crc of header (lower 16bits)\n+        crc.update(compressed, 0, index);\n+        int expected = (int)(crc.getValue()) & 0xffff;\n+        int low = toUnsignedByte(compressed[index++]);\n+        int high = toUnsignedByte(compressed[index++]) << 8;\n+        int headerCrc = high | low;\n+        Assert.assertEquals(headerCrc, expected, \"Unexpected CRC value of header\");\n+\n+        \/\/ finally verify that the compressed data is readable back to the original\n+        final String uncompressed;\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream();\n+             final ByteArrayInputStream bis = new ByteArrayInputStream(compressed);\n+             final GZIPInputStream gzipInputStream = new GZIPInputStream(bis)) {\n+            gzipInputStream.transferTo(os);\n+            uncompressed = new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+        Assert.assertEquals(uncompressed, data, \"Unexpected data read from GZIPInputStream\");\n+    }\n+\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPOutputStreamHeaderTest.java","additions":117,"deletions":2,"binary":false,"changes":119,"status":"modified"}]}