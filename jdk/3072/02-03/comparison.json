{"files":[{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * This class implements the header of GZIP file which contains members defined\n+ * in the RFC 1952 specification\n+ * @author      Lin Zang\n+ * @since 17\n+ *\n+ *\/\n+public class GZIPHeaderData {\n+\n+    \/**\n+     * CRC-32 of header data.\n+     *\/\n+    private CRC32 crc = new CRC32();\n+\n+    \/**\n+     * GZIP header magic number.\n+     *\/\n+    private static final int GZIP_MAGIC = 0x8b1f;\n+\n+\n+    \/\/ Represents the default \"unknown\" value for OS header, per RFC-1952\n+    private static final byte OS_UNKNOWN = (byte) 255;\n+\n+    \/**\n+     * File header flags.\n+     *\n+     * Per RFC 1952, the header fields contains serveral members based on flag byte:\n+     * This flag byte is divided into individual bits as follows:\n+     *\n+     *                bit 0   FTEXT        file probably ascii text\n+     *                bit 1   FHCRC        CRC16 for the gzip header\n+     *                bit 2   FEXTRA       extra field present\n+     *                bit 3   FNAME        original file name present\n+     *                bit 4   FCOMMENT     file comment present\n+     *                bit 5   reserved\n+     *                bit 6   reserved\n+     *                bit 7   reserved\n+     *\/\n+    private byte flags;\n+\n+    private static final int FTEXT      = 1;    \/\/ Extra text\n+    private static final int FHCRC      = 2;    \/\/ Header CRC\n+    private static final int FEXTRA     = 4;    \/\/ Extra field\n+    private static final int FNAME      = 8;    \/\/ File name\n+    private static final int FCOMMENT   = 16;   \/\/ File comment\n+\n+    \/*\n+     * GZIP Header bytes.\n+     *\/\n+    private ByteArrayOutputStream baos;\n+\n+    \/**\n+     * Creates GZIP member header with optional header members and compress method.\n+     * Per RFC-1952:\n+     *    The filename and fileComment member should be String in\n+     *          LATIN-1 (ISO-8859-1) character set.\n+     *\n+     *    A compliant compressor must produce files with correct ID1,\n+     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n+     *          the fixed-length part of the header to default values (255 for\n+     *          OS, 0 for all others).  The compressor must set all reserved\n+     *          bits to zero.\n+     *\n+     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n+     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n+     *\n+     * @param cm                    compress method,\n+     *                              per RFC-1952, 0-7 are reserved, 8 denotes \"deflate\".\n+     *                              usually passed by {@code Deflater.DEFLATED}\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes\n+     *        The byte array of extra filed, the generated header would calculate the\n+     *        byte[] size and fill it before the byte[] in header.\n+     * @param filename              the original file name in ISO-8859-1 character set\n+     * @param fileComment           the file comment in ISO_8859-1 character set.\n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not 0-8.\n+     *\/\n+     public GZIPHeaderData(byte cm,\n+                           boolean generateHeaderCRC,\n+                           byte[] extraFieldBytes,\n+                           String filename,\n+                           String fileComment) throws IOException {\n+        baos = new ByteArrayOutputStream();\n+        byte flags = 0;\n+        if (cm > 8 || cm < 0) {\n+            throw new IllegalArgumentException(\"Illegal compress method\");\n+        }\n+\n+        \/\/ set flags.\n+        if (generateHeaderCRC == true) {\n+            flags |= FHCRC;\n+        }\n+        if (extraFieldBytes != null && extraFieldBytes.length != 0) {\n+            flags |= FEXTRA;\n+        }\n+        if (filename != null && filename.length() != 0) {\n+            flags |= FNAME;\n+        }\n+        if (fileComment != null && fileComment.length() != 0) {\n+            flags |= FCOMMENT;\n+        }\n+\n+        \/\/ the head of header.\n+        byte [] head = new byte[] {\n+                (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n+                (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n+                cm,                       \/\/ Compression method (CM)\n+                flags,                    \/\/ Flags (FLG)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Extra flags (XFLG)\n+                OS_UNKNOWN                \/\/ Operating system (OS)\n+        };\n+        \/\/ write head.\n+        baos.write(head);\n+        if (generateHeaderCRC) {\n+            crc.update(head, 0, head.length);\n+        }\n+\n+        \/\/ write extra field.\n+        if ((flags & FEXTRA) == FEXTRA) {\n+            \/* extra field, per RFC-1952:\n+             *     +---+---+=================================+\n+             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n+             *     +---+---+=================================+\n+             *\/\n+            int xlen = extraFieldBytes.length;\n+            if (xlen > 0xffff) {\n+                throw new ZipException(\"extra field size out of range\");\n+            }\n+            \/\/ write XLEN.\n+            baos.write((byte)(xlen & 0xff));\n+            baos.write((byte)((xlen >> 8) & 0xff));\n+            \/*\n+             * Here do verification before write data.\n+             *\/\n+            if (!verifyExtraFieldLayout(extraFieldBytes)) {\n+                throw new ZipException(\"incorrect extra field format\");\n+            };\n+            baos.write(extraFieldBytes);\n+            if (generateHeaderCRC) {\n+                crc.update((byte)(xlen & 0xff));\n+                crc.update(((byte)(xlen >> 8) & 0xff));\n+                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n+            }\n+        }\n+        \/\/ write file name.\n+        if ((flags & FNAME) == FNAME) {\n+            \/*\n+             *    +=========================================+\n+             *    |...original file name, zero-terminated...|\n+             *    +=========================================+\n+             *\/\n+            byte[] filenameBytes = filename.getBytes(\"ISO-8859-1\");\n+            baos.write(filenameBytes);\n+            baos.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(filenameBytes, 0, filenameBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write file comment.\n+        if ((flags & FCOMMENT) == FCOMMENT) {\n+            \/*\n+             *    +===================================+\n+             *    |...file comment, zero-terminated...|\n+             *    +===================================+\n+             *\/\n+            byte[] fcommBytes = fileComment.getBytes(\"ISO-8859-1\");\n+            baos.write(fcommBytes);\n+            baos.write(0);\n+            if (generateHeaderCRC) {\n+                crc.update(fcommBytes, 0, fcommBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write header crc16.\n+        if ((flags & FHCRC) == FHCRC) {\n+            int crc16 = (int)crc.getValue() & 0xffff;\n+            baos.write((byte)(crc16 & 0xff));\n+            baos.write((byte)(crc16 >> 8) & 0xff);\n+            crc.reset();\n+        }\n+    }\n+\n+    \/**\n+     * Creates GZIP member header with optional header members.\n+     * Per RFC-1952:\n+     *    The filename and fileComment member should be String in\n+     *          LATIN-1 (ISO-8859-1) character set.\n+     *\n+     *    A compliant compressor must produce files with correct ID1,\n+     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n+     *          the fixed-length part of the header to default values (255 for\n+     *          OS, 0 for all others).  The compressor must set all reserved\n+     *          bits to zero.\n+     *\n+     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n+     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n+     *\n+     *   The compress method is set to {@code Defalter.DEFLATED}\n+     *\n+     * @param generateHeaderCRC\n+     *        if {@code true} the header will include the CRC16 of the header.\n+     * @param extraFieldBytes\n+     *        The byte array of extra filed, the generated header would calculate the\n+     *        byte[] size and fill it before the byte[] in header.\n+     * @param filename              the original file name in ISO-8859-1 character set\n+     * @param fileComment           the file comment in ISO_8859-1 character set.\n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     *\/\n+    public GZIPHeaderData(boolean generateHeaderCRC,\n+                          byte[] extraFieldBytes,\n+                          String filename,\n+                          String fileComment) throws IOException {\n+        this((byte)Deflater.DEFLATED, generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+    }\n+\n+    \/**\n+     * Creates GZIP File header with default members.\n+     *\n+     * <p>All optional member of head are set to zero and header crc is not requried by default.\n+     *\n+     * @param cm    compress method\n+     *\n+     * @throws ZipException                 If extra field size is out of range.\n+     *                                      Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not 0-8.\n+     *\/\n+    public GZIPHeaderData(byte cm) throws IOException {\n+        this(cm, false, null, null, null);\n+    }\n+\n+    \/**\n+     * Creates GZIP File header with default members and compress method.\n+     *\n+     * <p>All optional member of head are set to zero and header crc is not requried by default.\n+     *\n+     * @param cm    compress method\n+     *\n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     *\/\n+    public GZIPHeaderData() throws IOException {\n+        this((byte)Deflater.DEFLATED);\n+    }\n+\n+    \/** verify extra field data layout.\n+     * Per RFC 1952:\n+     * If the FLG.FEXTRA bit is set, an \"extra field\" is present in\n+     * the header, with total length XLEN bytes.  It consists of a\n+     * series of subfields, each of the form:\n+     *\n+     * +---+---+---+---+==================================+\n+     * |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n+     * +---+---+---+---+==================================+\n+            *\n+     * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n+     * with some mnemonic value\n+     *\n+     * @param fieldBytes    the data of extra fileds.\n+     *\/\n+    private boolean verifyExtraFieldLayout(byte[] fieldBytes) {\n+        int index = 0;\n+        int total = fieldBytes.length;\n+        while(index < total) {\n+            byte si1 = fieldBytes[index++];\n+            byte si2 = fieldBytes[index++];\n+            \/\/ si1 and si2 should be ASCII\n+            if (si1 > 127 || si2 > 127) return false;\n+            byte loLen = fieldBytes[index++];\n+            byte hiLen = fieldBytes[index++];\n+            int len = ((int)hiLen) << 8 | (int)loLen;\n+            index += len;\n+        }\n+        return index == total;\n+    }\n+\n+    \/**\n+     * Get bytes of header data\n+     * @return the bytes of header\n+     *\/\n+    public byte[] getBytes() {\n+        if (baos == null) {\n+            return null;\n+        }\n+        return baos.toByteArray();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPHeaderData.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -42,6 +43,1 @@\n-    protected CRC32 crc = new CRC32();\n-\n-    \/*\n-     * GZIP header magic number.\n-     *\/\n-    private static final int GZIP_MAGIC = 0x8b1f;\n+    private CRC32 crc = new CRC32();\n@@ -49,1 +45,1 @@\n-    \/*\n+    \/**\n@@ -55,12 +51,0 @@\n-    \/\/ Represents the default \"unknown\" value for OS header, per RFC-1952\n-    private static final byte OS_UNKNOWN = (byte) 255;\n-\n-    \/*\n-     * File header flags.\n-     *\/\n-    private static final int FTEXT      = 1;    \/\/ Extra text\n-    private static final int FHCRC      = 2;    \/\/ Header CRC\n-    private static final int FEXTRA     = 4;    \/\/ Extra field\n-    private static final int FNAME      = 8;    \/\/ File name\n-    private static final int FCOMMENT   = 16;   \/\/ File comment\n-\n@@ -68,4 +52,2 @@\n-     * Creates a new output stream with the specified buffer size.\n-     *\n-     * <p>The new output stream instance is created as if by invoking\n-     * the 3-argument constructor GZIPOutputStream(out, size, false).\n+     * Creates a new output stream with the specified buffer size,\n+     * flush mode flags and header fields.\n@@ -75,0 +57,10 @@\n+     * @param syncFlush\n+     *        if {@code true} invocation of the inherited\n+     *        {@link DeflaterOutputStream#flush() flush()} method of\n+     *        this instance flushes the compressor with flush mode\n+     *        {@link Deflater#SYNC_FLUSH} before flushing the output\n+     *        stream, otherwise only flushes the output stream\n+     * @param gzipHeaderData\n+     *        The header of Gzip file, contains header members defined\n+     *        in RFC 1952. if {@code null}, use default header data.\n+     *\n@@ -76,1 +68,2 @@\n-     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     * @since 17\n@@ -78,2 +71,15 @@\n-    public GZIPOutputStream(OutputStream out, int size) throws IOException {\n-        this(out, size, false);\n+    public GZIPOutputStream(OutputStream out,\n+                            int size,\n+                            boolean syncFlush,\n+                            GZIPHeaderData gzipHeaderData)\n+            throws IOException\n+    {\n+        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n+                size,\n+                syncFlush);\n+        usesDefaultDeflater = true;\n+        if (gzipHeaderData == null) {\n+            gzipHeaderData = new GZIPHeaderData((byte)Deflater.DEFLATED);\n+        }\n+        writeHeader(gzipHeaderData.getBytes());\n+        crc.reset();\n@@ -84,1 +90,1 @@\n-     * flush mode.\n+     * flush mode. And leave all other header fields set to default value.\n@@ -100,1 +106,1 @@\n-        throws IOException\n+            throws IOException\n@@ -102,6 +108,1 @@\n-        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n-              size,\n-              syncFlush);\n-        usesDefaultDeflater = true;\n-        writeHeader();\n-        crc.reset();\n+        this(out, size, syncFlush, null);\n@@ -110,0 +111,16 @@\n+    \/**\n+     * Creates a new output stream with the specified buffer size.\n+     * And leave all other header fields set to default value.\n+     *\n+     * <p>The new output stream instance is created as if by invoking\n+     * the 3-argument constructor GZIPOutputStream(out, size, false).\n+     *\n+     * @param out the output stream\n+     * @param size the output buffer size\n+     * @throws    IOException If an I\/O error has occurred.\n+     * @throws    IllegalArgumentException if {@code size <= 0}\n+     *\n+     *\/\n+    public GZIPOutputStream(OutputStream out, int size) throws IOException {\n+        this(out, size, false);\n+    }\n@@ -113,0 +130,1 @@\n+     * And leave all other header fields set to default value.\n@@ -126,1 +144,2 @@\n-     * the specified flush mode.\n+     * the specified flush mode. And leave all other header fields\n+     * set to default value.\n@@ -146,41 +165,0 @@\n-    \/**\n-     * Creates a new output stream with the specified buffer size,\n-     * flush mode and flags.\n-     *\n-     * @param out the output stream\n-     * @param size the output buffer size\n-     * @param syncFlush\n-     *        if {@code true} invocation of the inherited\n-     *        {@link DeflaterOutputStream#flush() flush()} method of\n-     *        this instance flushes the compressor with flush mode\n-     *        {@link Deflater#SYNC_FLUSH} before flushing the output\n-     *        stream, otherwise only flushes the output stream\n-     * @param generateHeaderCRC\n-     *        if {@code true} the header will include the CRC16 of the header.\n-     * @param extraFieldBytes the byte array of extra filed,\n-     *                        the generated header would calculate the byte[] size\n-     *                        and fill it before the byte[] in header.\n-     * @param filename        the original file name.\n-     * @param fileComment     the file comment.\n-     * @throws    IOException If an I\/O error has occurred.\n-     * @throws    IllegalArgumentException if {@code size <= 0}\n-     *\n-     * @since 17\n-     *\/\n-    public GZIPOutputStream(OutputStream out,\n-                            int size,\n-                            boolean syncFlush,\n-                            boolean generateHeaderCRC,\n-                            byte[] extraFieldBytes,\n-                            byte[] filename,\n-                            byte[] fileComment)\n-        throws IOException\n-    {\n-        super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true),\n-              size,\n-              syncFlush);\n-        usesDefaultDeflater = true;\n-        writeHeader(generateHeaderCRC, extraFieldBytes, filename, fileComment);\n-        crc.reset();\n-    }\n-\n@@ -191,7 +169,3 @@\n-     * @param generateHeaderCRC\n-     *        if {@code true} the header will include the CRC16 of the header.\n-     * @param extraFieldBytes the byte array of extra filed,\n-     *                        the generated header would calculate the byte[] size\n-     *                        and fill it before the byte[] in header.\n-     * @param filename        the original file name.\n-     * @param fileComment     the file comment.\n+     * @param gzipHeaderData\n+     *        The header of Gzip file, contains header members defined\n+     *        in RFC 1952. if {@code null}, use default header data.\n@@ -204,4 +178,1 @@\n-                            boolean generateHeaderCRC,\n-                            byte[] extraFieldBytes,\n-                            byte[] filename,\n-                            byte[] fileComment)\n+                            GZIPHeaderData gzipHeaderData)\n@@ -210,1 +181,1 @@\n-        this(out, 512, false, generateHeaderCRC, extraFieldBytes, filename, fileComment);\n+        this(out, 512, false, gzipHeaderData);\n@@ -257,7 +228,0 @@\n-    \/*\n-     * Writes GZIP member header without any header flags.\n-     *\/\n-    private void writeHeader() throws IOException {\n-        writeHeader(false, null, null, null);\n-    }\n-\n@@ -265,9 +229,1 @@\n-     * Writes GZIP member header with optional header flags, per RFC-1952.\n-     *\n-     * @param generateHeaderCRC\n-     *        if {@code true} the header will include the CRC16 of the header.\n-     * @param extraFieldBytes the byte array of extra filed,\n-     *                        the generated header would calculate the byte[] size\n-     *                        and fill it before the byte[] in header.\n-     * @param filename        the original file name.\n-     * @param fileComment     the file comment.\n+     * Writes GZIP header data.\n@@ -275,95 +231,2 @@\n-    private void writeHeader(boolean generateHeaderCRC,\n-                             byte[] extraFieldBytes,\n-                             byte[] filename,\n-                             byte[] fileComment) throws IOException {\n-        byte flags = 0;\n-        \/\/ set flags.\n-        if (generateHeaderCRC == true) {\n-            flags |= FHCRC;\n-        }\n-        if (extraFieldBytes != null && extraFieldBytes.length != 0) {\n-            flags |= FEXTRA;\n-        }\n-        if (filename != null && filename.length != 0) {\n-            flags |= FNAME;\n-        }\n-        if (fileComment != null && fileComment.length != 0) {\n-            flags |= FCOMMENT;\n-        }\n-\n-        \/\/ the head of header.\n-        byte [] head = new byte[] {\n-                           (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n-                           (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n-                           Deflater.DEFLATED,        \/\/ Compression method (CM)\n-                           flags,                    \/\/ Flags (FLG)\n-                           0,                        \/\/ Modification time MTIME (int)\n-                           0,                        \/\/ Modification time MTIME (int)\n-                           0,                        \/\/ Modification time MTIME (int)\n-                           0,                        \/\/ Modification time MTIME (int)\n-                           0,                        \/\/ Extra flags (XFLG)\n-                           OS_UNKNOWN                \/\/ Operating system (OS)\n-        };\n-        \/\/ write head.\n-        out.write(head);\n-        if (generateHeaderCRC) {\n-            crc.update(head, 0, head.length);\n-        }\n-\n-        \/\/ write extra field.\n-        if ((flags & FEXTRA) == FEXTRA) {\n-            \/* extra field, per RFC-1952\n-             *     +---+---+=================================+\n-             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n-             *     +---+---+=================================+\n-             *\/\n-            int xlen = extraFieldBytes.length;\n-            if (xlen > 0xffff) {\n-                throw new ZipException(\"extra field size out of range\");\n-            }\n-            \/\/ write XLEN.\n-            out.write((byte)(xlen & 0xff));\n-            out.write((byte)((xlen >> 8) & 0xff));\n-            \/\/ write extra field bytes.\n-            out.write(extraFieldBytes);\n-            if (generateHeaderCRC) {\n-                crc.update((byte)(xlen & 0xff));\n-                crc.update(((byte)(xlen >> 8) & 0xff));\n-                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n-            }\n-        }\n-        \/\/ write file name.\n-        if ((flags & FNAME) == FNAME) {\n-            \/*\n-             *    +=========================================+\n-             *    |...original file name, zero-terminated...|\n-             *    +=========================================+\n-             *\/\n-            out.write(filename);\n-            out.write(0);\n-            if (generateHeaderCRC) {\n-                crc.update(filename, 0, filename.length);\n-                crc.update(0);\n-            }\n-        }\n-        \/\/ write file comment.\n-        if ((flags & FCOMMENT) == FCOMMENT) {\n-            \/*\n-             *    +===================================+\n-             *    |...file comment, zero-terminated...|\n-             *    +===================================+\n-             *\/\n-            out.write(fileComment);\n-            out.write(0);\n-            if (generateHeaderCRC) {\n-                crc.update(fileComment, 0, fileComment.length);\n-                crc.update(0);\n-            }\n-        }\n-        \/\/ write header crc16.\n-        if ((flags & FHCRC) == FHCRC) {\n-            int crc16 = (int)crc.getValue() & 0xffff;\n-            out.write((byte)(crc16 & 0xff));\n-            out.write((byte)(crc16 >> 8) & 0xff);\n-            crc.reset();\n-        }\n+    private void writeHeader(byte[] headerBytes) throws IOException {\n+        out.write(headerBytes);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":62,"deletions":199,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.zip.GZIPHeaderData;\n@@ -51,0 +52,27 @@\n+\n+    \/**\n+     * Test that the {@code OS} header field in the GZIP output stream\n+     * has a value of {@code 255} which represents \"unknown\"\n+     *\/\n+    @Test\n+    public void testOSHeaderWithDefaultMembers() throws Exception {\n+        final String data = \"Hello world!!!\";\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos);) {\n+            gzipOutputStream.write(data.getBytes(StandardCharsets.UTF_8));\n+        }\n+        final byte[] compressed = baos.toByteArray();\n+        Assert.assertNotNull(compressed, \"Compressed data is null\");\n+        Assert.assertEquals(toUnsignedByte(compressed[OS_HEADER_INDEX]), HEADER_VALUE_OS_UNKNOWN,\n+                \"Unexpected value for OS header\");\n+        \/\/ finally verify that the compressed data is readable back to the original\n+        final String uncompressed;\n+        try (final ByteArrayOutputStream os = new ByteArrayOutputStream();\n+             final ByteArrayInputStream bis = new ByteArrayInputStream(compressed);\n+             final GZIPInputStream gzipInputStream = new GZIPInputStream(bis)) {\n+            gzipInputStream.transferTo(os);\n+            uncompressed = new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+        Assert.assertEquals(uncompressed, data, \"Unexpected data read from GZIPInputStream\");\n+    }\n+\n@@ -57,1 +85,1 @@\n-    public void testOSHeader() throws Exception {\n+    public void testOSHeaderWithField() throws Exception {\n@@ -61,2 +89,29 @@\n-        \/\/ extra field\n-        byte[] xfield = \"extraFieldBytesTest\".getBytes();\n+        \/* extra field\n+         * per RFC 1952:\n+         * If the FLG.FEXTRA bit is set, an \"extra field\" is present in\n+         * the header, with total length XLEN bytes.  It consists of a\n+         * series of subfields, each of the form:\n+         *\n+         *   +---+---+---+---+==================================+\n+         *   |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n+         *   +---+---+---+---+==================================+\n+         *\n+         * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n+         * with some mnemonic value.\n+         *\n+         * Subfield\n+         * IDs with SI2 = 0 are reserved for future use.  The following\n+         * IDs are currently defined:\n+         *\n+         *   SI1         SI2         Data\n+         *   ----------  ----------  ----\n+         *   0x41 ('A')  0x70 ('P')  Apollo file type information\n+         *\/\n+        ByteArrayOutputStream fieldStream = new ByteArrayOutputStream();\n+        fieldStream.write(\"AP\".getBytes());\n+        String xFieldData = \"Apollo file type information\";\n+        int len = xFieldData.length();\n+        fieldStream.write((byte)(len & 0xff));\n+        fieldStream.write((byte) (len >> 8) & 0xff);\n+        fieldStream.write(xFieldData.getBytes());\n+        byte[] xfield = fieldStream.toByteArray();\n@@ -64,1 +119,1 @@\n-        byte[] fname = \"FileNameTest.tmp\".getBytes();\n+        String fname = \"FileNameTest.tmp\";\n@@ -66,1 +121,1 @@\n-        byte[] fcomment = \"FileCommentTest\".getBytes();\n+        String fcomment = \"FileCommentTest\";\n@@ -70,5 +125,2 @@\n-        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos,\n-                                                                            generateHeaderCrc,\n-                                                                            xfield,\n-                                                                            fname,\n-                                                                            fcomment);) {\n+        GZIPHeaderData headerData = new GZIPHeaderData(generateHeaderCrc, xfield, fname, fcomment);\n+        try (final GZIPOutputStream gzipOutputStream = new GZIPOutputStream(baos, headerData);) {\n@@ -97,1 +149,1 @@\n-        int fnameLen = fname.length;\n+        int fnameLen = fname.length();\n@@ -104,1 +156,1 @@\n-        int fcommLen = fcomment.length;\n+        int fcommLen = fcomment.length();\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPOutputStreamHeaderTest.java","additions":65,"deletions":13,"binary":false,"changes":78,"status":"modified"}]}