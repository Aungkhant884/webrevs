{"files":[{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.zip;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\/**\n+ * This class implements the GZIP file header builder\n+ *\n+ * @author      Lin Zang\n+ * @since 17\n+ *\n+ *\/\n+public class GZIPHeaderBuilder {\n+    \/* compress method, only {@code Deflater.DEFLATED} supportted. *\/\n+    private byte cm;\n+    private byte[] extraFieldBytes;\n+    private String filename;\n+    private String fileComment;\n+    \/* Header flags, refer to definition in {@code GZIPHeaderData} *\/\n+    private byte flags;\n+    private int headerCrc16;\n+\n+    \/**\n+     * Creates a GZIP file header builder.\n+     * Current only {@code Deflater.DEFLATED} compress method supportted.\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder() {\n+        this.cm = (byte)Deflater.DEFLATED;\n+        this.extraFieldBytes = null;\n+        this.filename = null;\n+        this.fileComment = null;\n+        this.flags = 0;\n+        this.headerCrc16 = 0;\n+    }\n+\n+    \/**\n+     * Add extra field in GZIP file header.\n+     * This method verifies the extra fileds layout per RFC-1952.\n+     * See comments of {@code verifyExtraFieldLayout}\n+     *\n+     * @param extraFieldBytes The byte array of extra field.\n+     * @return {@code this}\n+     *\n+     * @throws ZipException if extra field layout is incorrect.\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withExtraFieldBytes(byte[] extraFieldBytes) throws ZipException {\n+        \/*\n+         * Here do verification before write data.\n+         *\/\n+        if (!verifyExtraFieldLayout(extraFieldBytes)) {\n+            throw new ZipException(\"incorrect extra field format\");\n+        }\n+        flags |= GZIPHeaderData.FEXTRA;\n+        this.extraFieldBytes = extraFieldBytes;\n+        return this;\n+    }\n+\n+    \/**\n+     * Add file name in GZIP file header.\n+     *\n+     * Per RFC-1952, the file name string should in ISO_8859-1 character set.\n+     *\n+     * @param filename The file name\n+     * @return {@code this}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withFileName(String filename) {\n+        if (filename == null || filename.length() == 0) {\n+            this.filename = null;\n+        }\n+        this.filename = filename;\n+        flags |= GZIPHeaderData.FNAME;\n+        return this;\n+    }\n+\n+    \/**\n+     * Add file comment in GZIP file header.\n+     *\n+     * Per RFC-1952, the file comment string should in ISO_8859-1 character set.\n+     *\n+     * @param fileComment The file comment\n+     * @return {@code this}'\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder withFileComment(String fileComment) {\n+        if (fileComment == null || fileComment.length() == 0) {\n+            this.fileComment = null;\n+        }\n+        this.fileComment = fileComment;\n+        flags |= GZIPHeaderData.FCOMMENT;\n+        return this;\n+    }\n+\n+    \/**\n+     * Enable\/Disable the CRC calculation of GZIP file header.\n+     *\n+     * @param calculateHeaderCRC if {@code true} the header data contains the lower 16 bytes of header CRC\n+     * @return {@code this}\n+     *\n+     * @since 17\n+     *\/\n+    public GZIPHeaderBuilder calculateHeaderCRC(boolean calculateHeaderCRC) {\n+        if (calculateHeaderCRC) {\n+            flags |= GZIPHeaderData.FHCRC;\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     *  Generate the GZIP header data\n+     * @return the {@code record} of GZIP header data.\n+     *\n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not {@code Deflater.DEFLATED}\n+     * @since 17\n+     *\/\n+    public GZIPHeaderData build() throws IOException {\n+        byte[] headerBytes = generateBytes(cm, extraFieldBytes, filename, fileComment);\n+        return new GZIPHeaderData(cm, flags, extraFieldBytes, filename, fileComment, headerCrc16, headerBytes);\n+    }\n+\n+    \/**\n+     * Creates GZIP header bytes with optional header members and compress method.\n+     * Per RFC-1952:\n+     *    The filename and fileComment member should be String in\n+     *          LATIN-1 (ISO-8859-1) character set.\n+     *\n+     *    A compliant compressor must produce files with correct ID1,\n+     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n+     *          the fixed-length part of the header to default values (255 for\n+     *          OS, 0 for all others).  The compressor must set all reserved\n+     *          bits to zero.\n+     *\n+     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n+     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n+     *\n+     * @param cm                    compress method,\n+     *                              per RFC-1952, 0-7 are reserved, 8 denotes \"deflate\".\n+     *                              at present only support {@code Deflater.DEFLATED}\n+     *\n+     * @param extraFieldBytes\n+     *        The byte array of extra filed, the generated header would calculate the\n+     *        byte[] size and fill it before the byte[] in header.\n+     * @param filename              the original file name in ISO-8859-1 character set\n+     * @param fileComment           the file comment in ISO_8859-1 character set.\n+     *                              \n+     * @return Bytes of header data generated.\n+     * \n+     * @throws ZipException         If extra field size is out of range.\n+     *                              Or if extra filed data layout is incorrect.\n+     * @throws IllegalArgumentException     If compress method is not {@code Deflater.DEFLATED}.\n+     *\n+     * @since 17\n+     *\/\n+    public byte[] generateBytes(byte cm,\n+                                byte[] extraFieldBytes,\n+                                String filename,\n+                                String fileComment) throws IOException {\n+        CRC32 crc = new CRC32();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        \/\/ the head of header.\n+        byte [] head = new byte[] {\n+                (byte) GZIPHeaderData.GZIP_MAGIC,        \/\/ Magic number (short)\n+                (byte)(GZIPHeaderData.GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n+                cm,                       \/\/ Compression method (CM)\n+                flags,                    \/\/ Flags (FLG)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Modification time MTIME (int)\n+                0,                        \/\/ Extra flags (XFLG)\n+                GZIPHeaderData.OS_UNKNOWN                \/\/ Operating system (OS)\n+        };\n+        \/\/ write head.\n+        baos.write(head);\n+        \n+        if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+            crc.update(head, 0, head.length);\n+        }\n+\n+        \/\/ write extra field.\n+        if ((flags & GZIPHeaderData.FEXTRA) == GZIPHeaderData.FEXTRA) {\n+            \/* extra field, per RFC-1952:\n+             *     +---+---+=================================+\n+             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n+             *     +---+---+=================================+\n+             *\/\n+            int xlen = extraFieldBytes.length;\n+            if (xlen > 0xffff) {\n+                throw new ZipException(\"extra field size out of range\");\n+            }\n+            \/\/ write XLEN.\n+            baos.write((byte)(xlen & 0xff));\n+            baos.write((byte)((xlen >> 8) & 0xff));\n+            \/*\n+             * Here do verification before write data.\n+             *\/\n+            if (!verifyExtraFieldLayout(extraFieldBytes)) {\n+                throw new ZipException(\"incorrect extra field format\");\n+            };\n+            baos.write(extraFieldBytes);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update((byte)(xlen & 0xff));\n+                crc.update(((byte)(xlen >> 8) & 0xff));\n+                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n+            }\n+        }\n+        \/\/ write file name.\n+        if ((flags & GZIPHeaderData.FNAME) == GZIPHeaderData.FNAME) {\n+            \/*\n+             *    +=========================================+\n+             *    |...original file name, zero-terminated...|\n+             *    +=========================================+\n+             *\/\n+            byte[] filenameBytes = filename.getBytes(\"ISO-8859-1\");\n+            baos.write(filenameBytes);\n+            baos.write(0);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update(filenameBytes, 0, filenameBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write file comment.\n+        if ((flags & GZIPHeaderData.FCOMMENT) == GZIPHeaderData.FCOMMENT) {\n+            \/*\n+             *    +===================================+\n+             *    |...file comment, zero-terminated...|\n+             *    +===================================+\n+             *\/\n+            byte[] fcommBytes = fileComment.getBytes(\"ISO-8859-1\");\n+            baos.write(fcommBytes);\n+            baos.write(0);\n+            if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+                crc.update(fcommBytes, 0, fcommBytes.length);\n+                crc.update(0);\n+            }\n+        }\n+        \/\/ write header crc16.\n+        if ((flags & GZIPHeaderData.FHCRC) == GZIPHeaderData.FHCRC) {\n+            int crc16 = (int) crc.getValue() & 0xffff;\n+            this.headerCrc16 = crc16;\n+            baos.write((byte) (crc16 & 0xff));\n+            baos.write((byte) (crc16 >> 8) & 0xff);\n+            crc.reset();\n+        }\n+        return baos.toByteArray();\n+    }\n+    \n+    \/** verify extra field data layout.\n+     * Per RFC 1952:\n+     * If the FEXTRA bit is set, an \"extra field\" is present in\n+     * the header, with total length XLEN bytes.  It consists of a\n+     * series of subfields, each of the form:\n+     *\n+     * +---+---+---+---+==================================+\n+     * |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n+     * +---+---+---+---+==================================+\n+     *\n+     * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n+     * with some mnemonic value\n+     *\n+     * @param fieldBytes    the data of extra fileds.\n+     * @return {@code true} if field data layout is correct.\n+     *\n+     * @since 17\n+     *\/\n+    private boolean verifyExtraFieldLayout(byte[] fieldBytes) {\n+        int index = 0;\n+        int total = fieldBytes.length;\n+        while(index < total) {\n+            byte si1 = fieldBytes[index++];\n+            byte si2 = fieldBytes[index++];\n+            \/\/ si1 and si2 should be ASCII\n+            if (si1 > 127 || si2 > 127) return false;\n+            byte loLen = fieldBytes[index++];\n+            byte hiLen = fieldBytes[index++];\n+            int len = ((int)hiLen) << 8 | (int)loLen;\n+            index += len;\n+        }\n+        return index == total;\n+    }\n+\n+    \/**\n+     * This class implements the header of GZIP file which contains members defined\n+     * in the RFC 1952 specification\n+     *\n+     * @since 17\n+     *\n+     *\/\n+    public record GZIPHeaderData (byte compressMethod, byte flags,\n+                                  byte[] extraFieldBytes,\n+                                  String filename,\n+                                  String fileComment,\n+                                  int headerCRC16,\n+                                  byte[] headerBytes) {\n+        \/**\n+         * GZIP header magic number.\n+         *\/\n+        private static final int GZIP_MAGIC = 0x8b1f;\n+\n+        \/**\n+         * Represents the default \"unknown\" value for OS header, per RFC-1952\n+         *\/\n+        private static final byte OS_UNKNOWN = (byte) 255;\n+\n+        \/**\n+         * File header flags.\n+         *\n+         * Per RFC 1952, the header fields contains several members based on flag byte\n+         * This flag byte is divided into individual bits as follows:\n+         *\n+         *                bit 0   FTEXT        file probably ascii text\n+         *                bit 1   FHCRC        CRC16 for the gzip header\n+         *                bit 2   FEXTRA       extra field present\n+         *                bit 3   FNAME        original file name present\n+         *                bit 4   FCOMMENT     file comment present\n+         *                bit 5   reserved\n+         *                bit 6   reserved\n+         *                bit 7   reserved\n+         *\n+         *\/\n+        private static final int FTEXT      = 1;    \/\/ Extra text\n+        private static final int FHCRC      = 2;    \/\/ Header CRC\n+        private static final int FEXTRA     = 4;    \/\/ Extra field\n+        private static final int FNAME      = 8;    \/\/ File name\n+        private static final int FCOMMENT   = 16;   \/\/ File comment\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPHeaderBuilder.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -1,323 +0,0 @@\n-\/*\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util.zip;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-\n-\/**\n- * This class implements the header of GZIP file which contains members defined\n- * in the RFC 1952 specification\n- * @author      Lin Zang\n- * @since 17\n- *\n- *\/\n-public class GZIPHeaderData {\n-\n-    \/**\n-     * CRC-32 of header data.\n-     *\/\n-    private CRC32 crc = new CRC32();\n-\n-    \/**\n-     * GZIP header magic number.\n-     *\/\n-    private static final int GZIP_MAGIC = 0x8b1f;\n-\n-\n-    \/\/ Represents the default \"unknown\" value for OS header, per RFC-1952\n-    private static final byte OS_UNKNOWN = (byte) 255;\n-\n-    \/**\n-     * File header flags.\n-     *\n-     * Per RFC 1952, the header fields contains serveral members based on flag byte:\n-     * This flag byte is divided into individual bits as follows:\n-     *\n-     *                bit 0   FTEXT        file probably ascii text\n-     *                bit 1   FHCRC        CRC16 for the gzip header\n-     *                bit 2   FEXTRA       extra field present\n-     *                bit 3   FNAME        original file name present\n-     *                bit 4   FCOMMENT     file comment present\n-     *                bit 5   reserved\n-     *                bit 6   reserved\n-     *                bit 7   reserved\n-     *\/\n-    private byte flags;\n-\n-    private static final int FTEXT      = 1;    \/\/ Extra text\n-    private static final int FHCRC      = 2;    \/\/ Header CRC\n-    private static final int FEXTRA     = 4;    \/\/ Extra field\n-    private static final int FNAME      = 8;    \/\/ File name\n-    private static final int FCOMMENT   = 16;   \/\/ File comment\n-\n-    \/*\n-     * GZIP Header bytes.\n-     *\/\n-    private ByteArrayOutputStream baos;\n-\n-    \/**\n-     * Creates GZIP member header with optional header members and compress method.\n-     * Per RFC-1952:\n-     *    The filename and fileComment member should be String in\n-     *          LATIN-1 (ISO-8859-1) character set.\n-     *\n-     *    A compliant compressor must produce files with correct ID1,\n-     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n-     *          the fixed-length part of the header to default values (255 for\n-     *          OS, 0 for all others).  The compressor must set all reserved\n-     *          bits to zero.\n-     *\n-     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n-     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n-     *\n-     * @param cm                    compress method,\n-     *                              per RFC-1952, 0-7 are reserved, 8 denotes \"deflate\".\n-     *                              usually passed by {@code Deflater.DEFLATED}\n-     * @param generateHeaderCRC\n-     *        if {@code true} the header will include the CRC16 of the header.\n-     * @param extraFieldBytes\n-     *        The byte array of extra filed, the generated header would calculate the\n-     *        byte[] size and fill it before the byte[] in header.\n-     * @param filename              the original file name in ISO-8859-1 character set\n-     * @param fileComment           the file comment in ISO_8859-1 character set.\n-     * @throws ZipException         If extra field size is out of range.\n-     *                              Or if extra filed data layout is incorrect.\n-     * @throws IllegalArgumentException     If compress method is not 0-8.\n-     *\/\n-     public GZIPHeaderData(byte cm,\n-                           boolean generateHeaderCRC,\n-                           byte[] extraFieldBytes,\n-                           String filename,\n-                           String fileComment) throws IOException {\n-        baos = new ByteArrayOutputStream();\n-        byte flags = 0;\n-        if (cm > 8 || cm < 0) {\n-            throw new IllegalArgumentException(\"Illegal compress method\");\n-        }\n-\n-        \/\/ set flags.\n-        if (generateHeaderCRC == true) {\n-            flags |= FHCRC;\n-        }\n-        if (extraFieldBytes != null && extraFieldBytes.length != 0) {\n-            flags |= FEXTRA;\n-        }\n-        if (filename != null && filename.length() != 0) {\n-            flags |= FNAME;\n-        }\n-        if (fileComment != null && fileComment.length() != 0) {\n-            flags |= FCOMMENT;\n-        }\n-\n-        \/\/ the head of header.\n-        byte [] head = new byte[] {\n-                (byte) GZIP_MAGIC,        \/\/ Magic number (short)\n-                (byte)(GZIP_MAGIC >> 8),  \/\/ Magic number (short)\n-                cm,                       \/\/ Compression method (CM)\n-                flags,                    \/\/ Flags (FLG)\n-                0,                        \/\/ Modification time MTIME (int)\n-                0,                        \/\/ Modification time MTIME (int)\n-                0,                        \/\/ Modification time MTIME (int)\n-                0,                        \/\/ Modification time MTIME (int)\n-                0,                        \/\/ Extra flags (XFLG)\n-                OS_UNKNOWN                \/\/ Operating system (OS)\n-        };\n-        \/\/ write head.\n-        baos.write(head);\n-        if (generateHeaderCRC) {\n-            crc.update(head, 0, head.length);\n-        }\n-\n-        \/\/ write extra field.\n-        if ((flags & FEXTRA) == FEXTRA) {\n-            \/* extra field, per RFC-1952:\n-             *     +---+---+=================================+\n-             *     | XLEN  |...XLEN bytes of \"extra field\"...|\n-             *     +---+---+=================================+\n-             *\/\n-            int xlen = extraFieldBytes.length;\n-            if (xlen > 0xffff) {\n-                throw new ZipException(\"extra field size out of range\");\n-            }\n-            \/\/ write XLEN.\n-            baos.write((byte)(xlen & 0xff));\n-            baos.write((byte)((xlen >> 8) & 0xff));\n-            \/*\n-             * Here do verification before write data.\n-             *\/\n-            if (!verifyExtraFieldLayout(extraFieldBytes)) {\n-                throw new ZipException(\"incorrect extra field format\");\n-            };\n-            baos.write(extraFieldBytes);\n-            if (generateHeaderCRC) {\n-                crc.update((byte)(xlen & 0xff));\n-                crc.update(((byte)(xlen >> 8) & 0xff));\n-                crc.update(extraFieldBytes, 0, extraFieldBytes.length);\n-            }\n-        }\n-        \/\/ write file name.\n-        if ((flags & FNAME) == FNAME) {\n-            \/*\n-             *    +=========================================+\n-             *    |...original file name, zero-terminated...|\n-             *    +=========================================+\n-             *\/\n-            byte[] filenameBytes = filename.getBytes(\"ISO-8859-1\");\n-            baos.write(filenameBytes);\n-            baos.write(0);\n-            if (generateHeaderCRC) {\n-                crc.update(filenameBytes, 0, filenameBytes.length);\n-                crc.update(0);\n-            }\n-        }\n-        \/\/ write file comment.\n-        if ((flags & FCOMMENT) == FCOMMENT) {\n-            \/*\n-             *    +===================================+\n-             *    |...file comment, zero-terminated...|\n-             *    +===================================+\n-             *\/\n-            byte[] fcommBytes = fileComment.getBytes(\"ISO-8859-1\");\n-            baos.write(fcommBytes);\n-            baos.write(0);\n-            if (generateHeaderCRC) {\n-                crc.update(fcommBytes, 0, fcommBytes.length);\n-                crc.update(0);\n-            }\n-        }\n-        \/\/ write header crc16.\n-        if ((flags & FHCRC) == FHCRC) {\n-            int crc16 = (int)crc.getValue() & 0xffff;\n-            baos.write((byte)(crc16 & 0xff));\n-            baos.write((byte)(crc16 >> 8) & 0xff);\n-            crc.reset();\n-        }\n-    }\n-\n-    \/**\n-     * Creates GZIP member header with optional header members.\n-     * Per RFC-1952:\n-     *    The filename and fileComment member should be String in\n-     *          LATIN-1 (ISO-8859-1) character set.\n-     *\n-     *    A compliant compressor must produce files with correct ID1,\n-     *          ID2, CM, CRC32, and ISIZE, but may set all the other fields in\n-     *          the fixed-length part of the header to default values (255 for\n-     *          OS, 0 for all others).  The compressor must set all reserved\n-     *          bits to zero.\n-     *\n-     *   The XFL (extra Flags) is set to zero and OS is set to {@code OS_UNKNOWN (=255)}.\n-     *   The FTEXT flag is set to zero and MTIME is filled with 0.\n-     *\n-     *   The compress method is set to {@code Defalter.DEFLATED}\n-     *\n-     * @param generateHeaderCRC\n-     *        if {@code true} the header will include the CRC16 of the header.\n-     * @param extraFieldBytes\n-     *        The byte array of extra filed, the generated header would calculate the\n-     *        byte[] size and fill it before the byte[] in header.\n-     * @param filename              the original file name in ISO-8859-1 character set\n-     * @param fileComment           the file comment in ISO_8859-1 character set.\n-     * @throws ZipException         If extra field size is out of range.\n-     *                              Or if extra filed data layout is incorrect.\n-     *\/\n-    public GZIPHeaderData(boolean generateHeaderCRC,\n-                          byte[] extraFieldBytes,\n-                          String filename,\n-                          String fileComment) throws IOException {\n-        this((byte)Deflater.DEFLATED, generateHeaderCRC, extraFieldBytes, filename, fileComment);\n-    }\n-\n-    \/**\n-     * Creates GZIP File header with default members.\n-     *\n-     * <p>All optional member of head are set to zero and header crc is not requried by default.\n-     *\n-     * @param cm    compress method\n-     *\n-     * @throws ZipException                 If extra field size is out of range.\n-     *                                      Or if extra filed data layout is incorrect.\n-     * @throws IllegalArgumentException     If compress method is not 0-8.\n-     *\/\n-    public GZIPHeaderData(byte cm) throws IOException {\n-        this(cm, false, null, null, null);\n-    }\n-\n-    \/**\n-     * Creates GZIP File header with default members and compress method.\n-     *\n-     * <p>All optional member of head are set to zero and header crc is not requried by default.\n-     *\n-     * @param cm    compress method\n-     *\n-     * @throws ZipException         If extra field size is out of range.\n-     *                              Or if extra filed data layout is incorrect.\n-     *\/\n-    public GZIPHeaderData() throws IOException {\n-        this((byte)Deflater.DEFLATED);\n-    }\n-\n-    \/** verify extra field data layout.\n-     * Per RFC 1952:\n-     * If the FLG.FEXTRA bit is set, an \"extra field\" is present in\n-     * the header, with total length XLEN bytes.  It consists of a\n-     * series of subfields, each of the form:\n-     *\n-     * +---+---+---+---+==================================+\n-     * |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|\n-     * +---+---+---+---+==================================+\n-            *\n-     * SI1 and SI2 provide a subfield ID, typically two ASCII letters\n-     * with some mnemonic value\n-     *\n-     * @param fieldBytes    the data of extra fileds.\n-     *\/\n-    private boolean verifyExtraFieldLayout(byte[] fieldBytes) {\n-        int index = 0;\n-        int total = fieldBytes.length;\n-        while(index < total) {\n-            byte si1 = fieldBytes[index++];\n-            byte si2 = fieldBytes[index++];\n-            \/\/ si1 and si2 should be ASCII\n-            if (si1 > 127 || si2 > 127) return false;\n-            byte loLen = fieldBytes[index++];\n-            byte hiLen = fieldBytes[index++];\n-            int len = ((int)hiLen) << 8 | (int)loLen;\n-            index += len;\n-        }\n-        return index == total;\n-    }\n-\n-    \/**\n-     * Get bytes of header data\n-     * @return the bytes of header\n-     *\/\n-    public byte[] getBytes() {\n-        if (baos == null) {\n-            return null;\n-        }\n-        return baos.toByteArray();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPHeaderData.java","additions":0,"deletions":323,"binary":false,"changes":323,"status":"deleted"},{"patch":"@@ -74,1 +74,1 @@\n-                            GZIPHeaderData gzipHeaderData)\n+                            GZIPHeaderBuilder.GZIPHeaderData gzipHeaderData)\n@@ -82,1 +82,1 @@\n-            gzipHeaderData = new GZIPHeaderData((byte)Deflater.DEFLATED);\n+            gzipHeaderData = new GZIPHeaderBuilder().build();\n@@ -84,1 +84,1 @@\n-        writeHeader(gzipHeaderData.getBytes());\n+        writeHeader(gzipHeaderData.headerBytes());\n@@ -178,1 +178,1 @@\n-                            GZIPHeaderData gzipHeaderData)\n+                            GZIPHeaderBuilder.GZIPHeaderData gzipHeaderData)\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.zip.GZIPHeaderData;\n+import java.util.zip.GZIPHeaderBuilder;\n@@ -125,1 +125,6 @@\n-        GZIPHeaderData headerData = new GZIPHeaderData(generateHeaderCrc, xfield, fname, fcomment);\n+        GZIPHeaderBuilder.GZIPHeaderData headerData = new GZIPHeaderBuilder()\n+                                                            .withExtraFieldBytes(xfield)\n+                                                            .withFileName(fname)\n+                                                            .withFileComment(fcomment)\n+                                                            .calculateHeaderCRC(generateHeaderCrc)\n+                                                            .build();\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPOutputStreamHeaderTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}