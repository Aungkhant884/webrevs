{"files":[{"patch":"@@ -532,1 +532,1 @@\n-address NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS) {\n+void NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS) {\n@@ -534,1 +534,0 @@\n-  address stub = NULL;\n@@ -538,1 +537,1 @@\n-      stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+      address stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n@@ -540,1 +539,1 @@\n-        JVMCI_ERROR_0(\"could not emit trampoline stub - code cache is full\");\n+        JVMCI_ERROR(\"could not emit trampoline stub - code cache is full\");\n@@ -542,2 +541,2 @@\n-      \/\/ A relocation is created while emitting the stub and will ensure this\n-      \/\/ call instruction is subsequently patched to call the stub\n+      \/\/ The relocation is created while emitting the stub will ensure this\n+      \/\/ call instruction is subsequently patched to call the stub.\n@@ -545,2 +544,2 @@\n-      \/\/ Not sure how this can be happen but let's be defensive\n-      JVMCI_ERROR_0(\"single-use stub should not exist\");\n+      \/\/ Not sure how this can be happen but be defensive\n+      JVMCI_ERROR(\"single-use stub should not exist\");\n@@ -552,2 +551,0 @@\n-\n-  return stub;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  address trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS);\n+  void trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}