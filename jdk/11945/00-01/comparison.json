{"files":[{"patch":"@@ -536,5 +536,11 @@\n-  if (a.far_branches()\n-      && ! is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n-    stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n-    if (stub == nullptr) {\n-      JVMCI_ERROR_0(\"could not emit trampoline stub - code cache is full\");\n+  if (a.far_branches()) {\n+    if (!is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n+      stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+      if (stub == nullptr) {\n+        JVMCI_ERROR_0(\"could not emit trampoline stub - code cache is full\");\n+      }\n+      \/\/ A relocation is created while emitting the stub and will ensure this\n+      \/\/ call instruction is subsequently patched to call the stub\n+    } else {\n+      \/\/ Not sure how this can be happen but let's be defensive\n+      JVMCI_ERROR_0(\"single-use stub should not exist\");\n@@ -542,6 +548,2 @@\n-  }\n-\n-  if (stub == NULL) {\n-    \/\/ If we generated no stub, patch this call directly to dest.\n-    \/\/ This will happen if we don't need far branches or if there\n-    \/\/ already was a trampoline.\n+  } else {\n+    \/\/ If not using far branches, patch this call directly to dest.\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"}]}