{"files":[{"patch":"@@ -133,1 +133,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_virtual_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_virtual_call_stub(), JVMCI_CHECK);\n@@ -140,1 +140,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_static_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_static_call_stub(), JVMCI_CHECK);\n@@ -147,1 +147,1 @@\n-      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_opt_virtual_call_stub());\n+      call->trampoline_jump(cbuf, SharedRuntime::get_resolve_opt_virtual_call_stub(), JVMCI_CHECK);\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciEnv.hpp\"\n+#endif\n@@ -526,0 +529,1 @@\n+#if INCLUDE_JVMCI\n@@ -528,1 +532,1 @@\n-address NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest) {\n+address NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS) {\n@@ -532,9 +536,14 @@\n-  if (a.far_branches()\n-      && ! is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n-    stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n-  }\n-\n-  if (stub == NULL) {\n-    \/\/ If we generated no stub, patch this call directly to dest.\n-    \/\/ This will happen if we don't need far branches or if there\n-    \/\/ already was a trampoline.\n+  if (a.far_branches()) {\n+    if (!is_NativeCallTrampolineStub_at(instruction_address() + displacement())) {\n+      stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+      if (stub == nullptr) {\n+        JVMCI_ERROR_0(\"could not emit trampoline stub - code cache is full\");\n+      }\n+      \/\/ A relocation is created while emitting the stub and will ensure this\n+      \/\/ call instruction is subsequently patched to call the stub\n+    } else {\n+      \/\/ Not sure how this can be happen but let's be defensive\n+      JVMCI_ERROR_0(\"single-use stub should not exist\");\n+    }\n+  } else {\n+    \/\/ If not using far branches, patch this call directly to dest.\n@@ -546,0 +555,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+#include \"runtime\/os.hpp\"\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciExceptions.hpp\"\n+#endif\n+\n@@ -254,1 +259,3 @@\n-  address trampoline_jump(CodeBuffer &cbuf, address dest);\n+#if INCLUDE_JVMCI\n+  address trampoline_jump(CodeBuffer &cbuf, address dest, JVMCI_TRAPS);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -341,0 +341,2 @@\n+\n+  \/\/ Returns NULL if CodeBuffer::expand fails\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1181,1 +1181,3 @@\n-      CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset);\n+      if (CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset) == nullptr) {\n+        JVMCI_ERROR(\"could not emit to_interp stub - code cache is full\");\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}