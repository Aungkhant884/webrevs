{"files":[{"patch":"@@ -3646,1 +3646,1 @@\n-\/\/ For P10+ only\n+\/\/ For P10 (or later) only\n@@ -3784,27 +3784,2 @@\n-    \/\/ loop_unrolls needs to be a power of two so that the rounding can be\n-    \/\/ done using a mask.\n-    \/\/\n-    \/\/ The amount of loop unrolling was determined by running a benchmark\n-    \/\/ that decodes a 20k block of Base64 data on a Power9 machine:\n-    \/\/ loop_unrolls = 1 :\n-    \/\/ (min, avg, max) = (108639.215, 110530.479, 110779.920), stdev = 568.437\n-    \/\/ loop_unrolls = 2 :\n-    \/\/ (min, avg, max) = (108259.029, 110174.202, 110399.642), stdev = 561.729\n-    \/\/ loop_unrolls = 4 :\n-    \/\/ (min, avg, max) = (106514.175, 108373.110, 108514.786), stdev = 392.237\n-    \/\/ loop_unrolls = 8 :\n-    \/\/ (min, avg, max) = (106281.283, 108316.668, 108539.953), stdev = 553.938\n-    \/\/ loop_unrolls = 16 :\n-    \/\/ (min, avg, max) = (108580.768, 110631.161, 110766.237), stdev = 430.510\n-    \/\/\n-    \/\/ Comparing only the max values, there's no reason to go past\n-    \/\/ loop_unrolls = 1.  Performance at loop_unrolls = 16 is similar but\n-    \/\/ has the disadvantage of requiring a larger minimum block of data to\n-    \/\/ work with.  A value of 1 gives a minimum of (16 + 12) = 28 bytes\n-    \/\/ before the intrinsic will decode any data.  See the reason for the\n-    \/\/ +12 in the following logic.\n-    const unsigned loop_unrolls = 1;\n-\n-    const unsigned vec_size = 16; \/\/ size of vector registers in bytes\n-    const unsigned block_size = vec_size * loop_unrolls;  \/\/ number of bytes to process in each pass through the loop\n-    const unsigned block_size_shift = exact_log2(block_size);\n+    const unsigned block_size = 16;  \/\/ number of bytes to process in each pass through the loop\n+    const unsigned block_size_shift = 4;\n@@ -3846,1 +3821,1 @@\n-    \/\/ P10+ VSR lookup constants\n+    \/\/ P10 (or later) VSR lookup constants\n@@ -3869,1 +3844,1 @@\n-    \/\/ P10+ VSR lookup variables\n+    \/\/ P10 (or later) VSR lookup variables\n@@ -3879,1 +3854,1 @@\n-    Label not_URL, calculate_size, unrolled_loop_start, unrolled_loop_exit, return_zero;\n+    Label not_URL, calculate_size, loop_start, loop_exit, return_zero;\n@@ -3898,1 +3873,1 @@\n-    \/\/ Load CTR with the number of passes through the unrolled loop\n+    \/\/ Load CTR with the number of passes through the loop\n@@ -3977,6 +3952,2 @@\n-    __ bind(unrolled_loop_start);\n-    for (unsigned unroll_cnt=0; unroll_cnt < loop_unrolls; unroll_cnt++) {\n-      \/\/ We can use a static displacement in the load since it's always a\n-      \/\/ multiple of 16, which is a requirement of lxv\/stxv.  This saves\n-      \/\/ an addi instruction.\n-      __ lxv(input->to_vsr(), unroll_cnt * 16, in);\n+    __ bind(loop_start);\n+    __ lxv(input->to_vsr(), 0, in); \/\/ offset=0\n@@ -3984,0 +3955,8 @@\n+    \/\/\n+    \/\/ Lookup\n+    \/\/\n+    if (PowerArchitecturePPC64 >= 10) {\n+      \/\/ Use xxpermx to do a lookup of each Base64 character in the\n+      \/\/ input vector and translate it to a 6-bit value + 0x80.\n+      \/\/ Characters which are not valid Base64 characters will result\n+      \/\/ in a zero in the corresponding byte.\n@@ -3985,26 +3964,15 @@\n-      \/\/ Lookup\n-      \/\/\n-      if (PowerArchitecturePPC64 >= 10) {\n-        \/\/ Use xxpermx to do a lookup of each Base64 character in the\n-        \/\/ input vector and translate it to a 6-bit value + 0x80.\n-        \/\/ Characters which are not valid Base64 characters will result\n-        \/\/ in a zero in the corresponding byte.\n-        __ align_prefix(); __ xxpermx(xlate_a, table_32_47, table_48_63, input->to_vsr(), 1);\n-        __ align_prefix(); __ xxpermx(xlate_b, table_64_79, table_80_95, input->to_vsr(), 2);\n-        __ xxlor(xlate_b, xlate_a, xlate_b);\n-        __ align_prefix(); __ xxpermx(xlate_a, table_96_111, table_112_127, input->to_vsr(), 3);\n-        __ xxlor(input->to_vsr(), xlate_a, xlate_b);\n-        \/\/ Check for non-Base64 characters by comparing each byte to zero.\n-        __ vcmpequb_(non_match, input, vec_0s);\n-      } else {\n-        \/\/ Isolate the upper 4 bits of each character by shifting it right 4 bits\n-        __ vsrb(higher_nibble, input, vec_4s);\n-        \/\/ Isolate the lower 4 bits by masking\n-        __ xxland(lower_nibble, input->to_vsr(), vec_0xfs);\n-\n-        \/\/ Get the offset (the value to subtract from the byte) by using\n-        \/\/ a lookup table indexed by the upper 4 bits of the character\n-        __ xxperm(offsets->to_vsr(), offsetLUT, higher_nibble->to_vsr());\n-\n-        \/\/ Find out which elements are the special case character (isURL ? '\/' : '-')\n-        __ vcmpequb(eq_special_case_char, input, vec_special_case_char);\n+      \/\/ Note that due to align(32) call above, the xxpermx instructions do\n+      \/\/ not require align_prefix() calls, since the final xxpermx\n+      \/\/ prefix+opcode is at byte 24.\n+      __ xxpermx(xlate_a, table_32_47, table_48_63, input->to_vsr(), 1);    \/\/ offset=4\n+      __ xxpermx(xlate_b, table_64_79, table_80_95, input->to_vsr(), 2);    \/\/ offset=12\n+      __ xxlor(xlate_b, xlate_a, xlate_b);                                  \/\/ offset=20\n+      __ xxpermx(xlate_a, table_96_111, table_112_127, input->to_vsr(), 3); \/\/ offset=24\n+      __ xxlor(input->to_vsr(), xlate_a, xlate_b);\n+      \/\/ Check for non-Base64 characters by comparing each byte to zero.\n+      __ vcmpequb_(non_match, input, vec_0s);\n+    } else {\n+      \/\/ Isolate the upper 4 bits of each character by shifting it right 4 bits\n+      __ vsrb(higher_nibble, input, vec_4s);\n+      \/\/ Isolate the lower 4 bits by masking\n+      __ xxland(lower_nibble, input->to_vsr(), vec_0xfs);\n@@ -4012,4 +3980,3 @@\n-        \/\/ For each character in the input which is a special case\n-        \/\/ character, replace its offset with one that is special for that\n-        \/\/ character.\n-        __ xxsel(offsets->to_vsr(), offsets->to_vsr(), vec_special_case_offset, eq_special_case_char->to_vsr());\n+      \/\/ Get the offset (the value to subtract from the byte) by using\n+      \/\/ a lookup table indexed by the upper 4 bits of the character\n+      __ xxperm(offsets->to_vsr(), offsetLUT, higher_nibble->to_vsr());\n@@ -4017,2 +3984,2 @@\n-        \/\/ Use the lower_nibble to select a mask \"M\" from the lookup table.\n-        __ xxperm(M, maskLUT, lower_nibble);\n+      \/\/ Find out which elements are the special case character (isURL ? '\/' : '-')\n+      __ vcmpequb(eq_special_case_char, input, vec_special_case_char);\n@@ -4020,2 +3987,4 @@\n-        \/\/ \"bit\" is used to isolate which of the bits in M is relevant.\n-        __ xxperm(bit, bitposLUT, higher_nibble->to_vsr());\n+      \/\/ For each character in the input which is a special case\n+      \/\/ character, replace its offset with one that is special for that\n+      \/\/ character.\n+      __ xxsel(offsets->to_vsr(), offsets->to_vsr(), vec_special_case_offset, eq_special_case_char->to_vsr());\n@@ -4023,4 +3992,2 @@\n-        \/\/ Each element of non_match correspond to one each of the 16 input\n-        \/\/ characters.  Those elements that become 0x00 after the xxland\n-        \/\/ instuction are invalid Base64 characters.\n-        __ xxland(non_match->to_vsr(), M, bit);\n+      \/\/ Use the lower_nibble to select a mask \"M\" from the lookup table.\n+      __ xxperm(M, maskLUT, lower_nibble);\n@@ -4028,9 +3995,2 @@\n-        \/\/ Compare each element to zero\n-        \/\/\n-        __ vcmpequb_(non_match, non_match, vec_0s);\n-      }\n-      \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n-      \/\/ Any element comparing equal to zero means there is an error in\n-      \/\/ that element.  Note that the comparison result register\n-      \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n-      __ bne_predict_not_taken(CCR6, unrolled_loop_exit);\n+      \/\/ \"bit\" is used to isolate which of the bits in M is relevant.\n+      __ xxperm(bit, bitposLUT, higher_nibble->to_vsr());\n@@ -4038,2 +3998,4 @@\n-      \/\/ The Base64 characters had no errors, so add the offsets\n-      __ vaddubm(input, input, offsets);\n+      \/\/ Each element of non_match correspond to one each of the 16 input\n+      \/\/ characters.  Those elements that become 0x00 after the xxland\n+      \/\/ instuction are invalid Base64 characters.\n+      __ xxland(non_match->to_vsr(), M, bit);\n@@ -4041,1 +4003,1 @@\n-      \/\/ Pack\n+      \/\/ Compare each element to zero\n@@ -4043,78 +4005,1 @@\n-      \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n-      \/\/ binary data, the first line of each of the cells (except for\n-      \/\/ the constants) uses the bit-field nomenclature from the\n-      \/\/ above-linked paper, whereas the second line is more specific\n-      \/\/ about which exact bits are present, and is constructed using the\n-      \/\/ Power ISA 3.x document style, where:\n-      \/\/\n-      \/\/ * The specifier after the colon depicts which bits are there.\n-      \/\/ * The bit numbering is big endian style (bit 0 is the most\n-      \/\/   significant).\n-      \/\/ * || is a concatenate operator.\n-      \/\/ * Strings of 0's are a field of zeros with the shown length, and\n-      \/\/   likewise for strings of 1's.\n-\n-      \/\/ Note that only e12..e15 are shown here because the shifting\n-      \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n-      \/\/ e0..e3.\n-      \/\/\n-      \/\/ +======================+=================+======================+======================+=============+\n-      \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n-      \/\/ |       Element        |                 |                      |                      |             |\n-      \/\/ +======================+=================+======================+======================+=============+\n-      \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n-      \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n-      \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n-      \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n-      \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n-      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-      \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n-      \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n-      \/\/ +======================+=================+======================+======================+=============+\n-      \/\/\n-      \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n-      \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n-      \/\/ but should be:\n-      \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n-      \/\/\n-      __ vslb(l, input, pack_lshift);\n-      \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n-      \/\/ element numbers, discarding element 0.  This means it actually\n-      \/\/ shifts to the right (not left) according to the order of the\n-      \/\/ table above.\n-      __ vslo(l, l, vec_8s);\n-      __ vsrb(r, input, pack_rshift);\n-      __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n-\n-      \/\/ Final rearrangement of bytes into their correct positions.\n-      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-      \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n-      \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n-      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-      \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n-      \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-      \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n-      \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-      \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n-      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-      \/\/ xx bytes are not used to form the final data\n-      \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n-      \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n-      \/\/ overwritten on the next iteration.\n-      __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n-\n-      \/\/ We cannot use a static displacement on the store, since it's a\n-      \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n-      \/\/ writes 16 bytes, even though only the first 12 are valid data.\n-      __ stxv(gathered->to_vsr(), 0, out);\n-      __ addi(out, out, 12);\n+      __ vcmpequb_(non_match, non_match, vec_0s);\n@@ -4122,4 +4007,95 @@\n-    __ addi(in, in, 16 * loop_unrolls);\n-    __ bdnz(unrolled_loop_start);\n-\n-    __ bind(unrolled_loop_exit);\n+    \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n+    \/\/ Any element comparing equal to zero means there is an error in\n+    \/\/ that element.  Note that the comparison result register\n+    \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n+    __ bne_predict_not_taken(CCR6, loop_exit);\n+\n+    \/\/ The Base64 characters had no errors, so add the offsets, which in\n+    \/\/ the case of Power10 is a constant vector of all 0x80's (see earlier\n+    \/\/ comment where the offsets register is loaded).\n+    __ vaddubm(input, input, offsets);\n+\n+    \/\/ Pack\n+    \/\/\n+    \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n+    \/\/ binary data, the first line of each of the cells (except for\n+    \/\/ the constants) uses the bit-field nomenclature from the\n+    \/\/ above-linked paper, whereas the second line is more specific\n+    \/\/ about which exact bits are present, and is constructed using the\n+    \/\/ Power ISA 3.x document style, where:\n+    \/\/\n+    \/\/ * The specifier after the colon depicts which bits are there.\n+    \/\/ * The bit numbering is big endian style (bit 0 is the most\n+    \/\/   significant).\n+    \/\/ * || is a concatenate operator.\n+    \/\/ * Strings of 0's are a field of zeros with the shown length, and\n+    \/\/   likewise for strings of 1's.\n+\n+    \/\/ Note that only e12..e15 are shown here because the shifting\n+    \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n+    \/\/ e0..e3.\n+    \/\/\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n+    \/\/ |       Element        |                 |                      |                      |             |\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n+    \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n+    \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n+    \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n+    \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n+    \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+    \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n+    \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n+    \/\/ +======================+=================+======================+======================+=============+\n+    \/\/\n+    \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n+    \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n+    \/\/ but should be:\n+    \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n+    \/\/\n+    __ vslb(l, input, pack_lshift);\n+    \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n+    \/\/ element numbers, discarding element 0.  This means it actually\n+    \/\/ shifts to the right (not left) according to the order of the\n+    \/\/ table above.\n+    __ vslo(l, l, vec_8s);\n+    __ vsrb(r, input, pack_rshift);\n+    __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n+\n+    \/\/ Final rearrangement of bytes into their correct positions.\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n+    \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n+    \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+    \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n+    \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+    \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n+    \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+    \/\/ xx bytes are not used to form the final data\n+    \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n+    \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n+    \/\/ overwritten on the next iteration.\n+    __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n+\n+    \/\/ We cannot use a static displacement on the store, since it's a\n+    \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n+    \/\/ writes 16 bytes, even though only the first 12 are valid data.\n+    __ stxv(gathered->to_vsr(), 0, out);\n+    __ addi(out, out, 12);\n+    __ addi(in, in, 16);\n+    __ bdnz(loop_start);\n+\n+    __ bind(loop_exit);\n@@ -4256,1 +4232,1 @@\n-\/\/ Power10+, but experiments doing so on Power10 yielded a slight\n+\/\/ Power10 (or later), but experiments doing so on Power10 yielded a slight\n@@ -4372,1 +4348,1 @@\n-    Register num_blocks     = R11; \/\/ number of blocks to be processed by the unrolled loop\n+    Register num_blocks     = R11; \/\/ number of blocks to be processed by the loop\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":148,"deletions":172,"binary":false,"changes":320,"status":"modified"}]}