{"files":[{"patch":"@@ -827,0 +827,4 @@\n+\n+    \/\/ xxpermx\n+    XXPERMX_PREFIX_OPCODE = PREFIX_PRIMARY_OPCODE | (1u << PRE_TYPE_SHIFT),\n+    XXPERMX_SUFFIX_OPCODE = (34u << OPCODE_SHIFT),\n@@ -2351,0 +2355,1 @@\n+  inline void xxpermx(  VectorSRegister d, VectorSRegister a, VectorSRegister b, VectorSRegister c, int ui3);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -145,0 +145,5 @@\n+inline void Assembler::xxpermx( VectorSRegister d, VectorSRegister a, VectorSRegister b, VectorSRegister c, int ui3) {\n+  emit_int32(XXPERMX_PREFIX_OPCODE | uimm(ui3, 3));\n+  emit_int32(XXPERMX_SUFFIX_OPCODE | vsrt(d) | vsra(a) | vsrb(b) | vsrc(c));\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+void MacroAssembler::align_prefix() {\n+  if (is_aligned(offset() + BytesPerInstWord, 64)) { nop(); }\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+  \/\/ Align prefix opcode to make sure it's not on the last word of a 64-byte block\n+  void align_prefix();\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3646,0 +3646,4 @@\n+\/\/ For P10+ only\n+#define VALID_B64 0x80\n+#define VB64(x) (VALID_B64 | x)\n+\n@@ -3648,0 +3652,2 @@\n+#define BLK_OFFSETOF(x) (offsetof(constant_block, x))\n+\n@@ -3663,61 +3669,114 @@\n-    static const signed char VEC_ALIGN offsetLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0,   0, PLS, DIG,  UC,  UC,  LC,  LC,\n-      0,   0,   0,   0,   0,   0,   0,   0 ) };\n-\n-    static const signed char VEC_ALIGN offsetLUT_URL_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0,   0, HYP, DIG,  UC,  UC,  LC,  LC,\n-      0,   0,   0,   0,   0,   0,   0,   0 ) };\n-\n-    static const unsigned char VEC_ALIGN maskLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      \/* 0        *\/ (unsigned char)0b10101000,\n-      \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000,\n-      \/* 10       *\/ (unsigned char)0b11110000,\n-      \/* 11       *\/ (unsigned char)0b01010100,\n-      \/* 12 .. 14 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000, (unsigned char)0b01010000,\n-      \/* 15       *\/ (unsigned char)0b01010100 ) };\n-\n-    static const unsigned char VEC_ALIGN maskLUT_URL_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      \/* 0        *\/ (unsigned char)0b10101000,\n-      \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n-                     (unsigned char)0b11111000,\n-      \/* 10       *\/ (unsigned char)0b11110000,\n-      \/* 11 .. 12 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000,\n-      \/* 13       *\/ (unsigned char)0b01010100,\n-      \/* 14       *\/ (unsigned char)0b01010000,\n-      \/* 15       *\/ (unsigned char)0b01110000 ) };\n-\n-    static const unsigned char VEC_ALIGN bitposLUT_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, (unsigned char)0x80,\n-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ) };\n-\n-    static const unsigned char VEC_ALIGN pack_lshift_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2 ) };\n-\n-    static const unsigned char VEC_ALIGN pack_rshift_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-      0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0 ) };\n-\n-    \/\/ The first 4 index values are \"don't care\" because\n-    \/\/ we only use the first 12 bytes of the vector,\n-    \/\/ which are decoded from 16 bytes of Base64 characters.\n-    static const unsigned char VEC_ALIGN pack_permute_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-       0, 0, 0, 0,\n-       0,  1,  2,\n-       4,  5,  6,\n-       8,  9, 10,\n-      12, 13, 14 ) };\n-\n-    static const unsigned char VEC_ALIGN p10_pack_permute_val[16] = {\n-      ARRAY_TO_LXV_ORDER(\n-       0,  0,  0,  0,  7,  6,  5,  4,\n-       3,  2, 15, 14, 13, 12, 11, 10 ) };\n+    typedef struct {\n+      signed char offsetLUT_val[16];\n+      signed char offsetLUT_URL_val[16];\n+      unsigned char maskLUT_val[16];\n+      unsigned char maskLUT_URL_val[16];\n+      unsigned char bitposLUT_val[16];\n+      unsigned char table_32_47_val[16];\n+      unsigned char table_32_47_URL_val[16];\n+      unsigned char table_48_63_val[16];\n+      unsigned char table_64_79_val[16];\n+      unsigned char table_80_95_val[16];\n+      unsigned char table_80_95_URL_val[16];\n+      unsigned char table_96_111_val[16];\n+      unsigned char table_112_127_val[16];\n+      unsigned char pack_lshift_val[16];\n+      unsigned char pack_rshift_val[16];\n+      unsigned char pack_permute_val[16];\n+    } constant_block;\n+\n+    static const constant_block VEC_ALIGN const_block = {\n+\n+      .offsetLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0,   0, PLS, DIG,  UC,  UC,  LC,  LC,\n+        0,   0,   0,   0,   0,   0,   0,   0 ) },\n+\n+      .offsetLUT_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0,   0, HYP, DIG,  UC,  UC,  LC,  LC,\n+        0,   0,   0,   0,   0,   0,   0,   0 ) },\n+\n+      .maskLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        \/* 0        *\/ (unsigned char)0b10101000,\n+        \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000,\n+        \/* 10       *\/ (unsigned char)0b11110000,\n+        \/* 11       *\/ (unsigned char)0b01010100,\n+        \/* 12 .. 14 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000, (unsigned char)0b01010000,\n+        \/* 15       *\/ (unsigned char)0b01010100 ) },\n+\n+      .maskLUT_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        \/* 0        *\/ (unsigned char)0b10101000,\n+        \/* 1 .. 9   *\/ (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000, (unsigned char)0b11111000,\n+                       (unsigned char)0b11111000,\n+        \/* 10       *\/ (unsigned char)0b11110000,\n+        \/* 11 .. 12 *\/ (unsigned char)0b01010000, (unsigned char)0b01010000,\n+        \/* 13       *\/ (unsigned char)0b01010100,\n+        \/* 14       *\/ (unsigned char)0b01010000,\n+        \/* 15       *\/ (unsigned char)0b01110000 ) },\n+\n+      .bitposLUT_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, (unsigned char)0x80,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ) },\n+\n+      \/\/ In the following table_*_val constants, a 0 value means the\n+      \/\/ character is not in the Base64 character set\n+      .table_32_47_val = {\n+        ARRAY_TO_LXV_ORDER (\n+         \/* space .. '*' = 0 *\/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \/* '+' = 62 *\/ VB64(62), \/* ',' .. '.' = 0 *\/ 0, 0, 0, \/* '\/' = 63 *\/ VB64(63) ) },\n+\n+      .table_32_47_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* space .. ',' = 0 *\/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \/* '-' = 62 *\/ VB64(62), \/* '.' .. '\/' *\/ 0, 0 ) },\n+\n+      .table_48_63_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* '0' .. '9' = 52 .. 61 *\/ VB64(52), VB64(53), VB64(54), VB64(55), VB64(56), VB64(57), VB64(58), VB64(59), VB64(60), VB64(61),\n+         \/* ':' .. '?' = 0 *\/ 0, 0, 0, 0, 0, 0 ) },\n+\n+      .table_64_79_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         \/* '@' = 0 *\/ 0, \/* 'A' .. 'O' = 0 .. 14 *\/ VB64(0), VB64(1), VB64(2), VB64(3), VB64(4), VB64(5), VB64(6), VB64(7), VB64(8),\n+         VB64(9), VB64(10), VB64(11), VB64(12), VB64(13), VB64(14) ) },\n+\n+      .table_80_95_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'P' .. 'Z' = 15 .. 25 *\/ VB64(15), VB64(16), VB64(17), VB64(18), VB64(19), VB64(20), VB64(21), VB64(22),\n+        VB64(23), VB64(24), VB64(25), \/* '[' .. '_' = 0 *\/ 0, 0, 0, 0, 0 ) },\n+\n+      .table_80_95_URL_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'P' .. 'Z' = 15 .. 25 *\/ VB64(15), VB64(16), VB64(17), VB64(18), VB64(19), VB64(20), VB64(21), VB64(22),\n+        VB64(23), VB64(24), VB64(25), \/* '[' .. '^' = 0 *\/ 0, 0, 0, 0, \/* '_' = 63 *\/ VB64(63) ) },\n+\n+      .table_96_111_val = {\n+        ARRAY_TO_LXV_ORDER(\/* '`' = 0 *\/ 0, \/* 'a' .. 'o' = 26 .. 40 *\/ VB64(26), VB64(27), VB64(28), VB64(29), VB64(30), VB64(31),\n+        VB64(32), VB64(33), VB64(34), VB64(35), VB64(36), VB64(37), VB64(38), VB64(39), VB64(40) ) },\n+\n+      .table_112_127_val = {\n+        ARRAY_TO_LXV_ORDER(\/* 'p' .. 'z' = 41 .. 51 *\/ VB64(41), VB64(42), VB64(43), VB64(44), VB64(45), VB64(46), VB64(47), VB64(48),\n+        VB64(49), VB64(50), VB64(51), \/* '{' .. DEL = 0 *\/ 0, 0, 0, 0, 0 ) },\n+\n+      .pack_lshift_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2, 0, 6, 4, 2 ) },\n+\n+      .pack_rshift_val = {\n+        ARRAY_TO_LXV_ORDER(\n+        0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0, 0, 2, 4, 0 ) },\n+\n+      \/\/ The first 4 index values are \"don't care\" because\n+      \/\/ we only use the first 12 bytes of the vector,\n+      \/\/ which are decoded from 16 bytes of Base64 characters.\n+      .pack_permute_val = {\n+        ARRAY_TO_LXV_ORDER(\n+         0, 0, 0, 0,\n+         0,  1,  2,\n+         4,  5,  6,\n+         8,  9, 10,\n+        12, 13, 14 ) }\n+    };\n@@ -3778,2 +3837,0 @@\n-    \/\/ P10+\n-    VectorRegister  vec_0x3fs               = VR4; \/\/ safe to reuse pack_rshift's register\n@@ -3789,2 +3846,9 @@\n-    \/\/ Variables for lookup\n-    \/\/ VR\n+    \/\/ P10+ VSR lookup constants\n+    VectorSRegister table_32_47             = VSR0;\n+    VectorSRegister table_48_63             = VSR1;\n+    VectorSRegister table_64_79             = VSR2;\n+    VectorSRegister table_80_95             = VSR3;\n+    VectorSRegister table_96_111            = VSR4;\n+    VectorSRegister table_112_127           = VSR6;\n+\n+    \/\/ Data read in and later converted\n@@ -3792,0 +3856,4 @@\n+    \/\/ Variable for testing Base64 validity\n+    VectorRegister  non_match               = VR10;\n+\n+    \/\/ P9 VR Variables for lookup\n@@ -3795,1 +3863,0 @@\n-    VectorRegister  non_match               = VR10;\n@@ -3797,1 +3864,1 @@\n-    \/\/ VSR\n+    \/\/ P9 VSR lookup variables\n@@ -3802,0 +3869,4 @@\n+    \/\/ P10+ VSR lookup variables\n+    VectorSRegister  xlate_a                = VSR7;\n+    VectorSRegister  xlate_b                = VSR8;\n+\n@@ -3806,1 +3877,1 @@\n-    VectorRegister  gathered                = VR9;  \/\/ reuse offsets's register\n+    VectorRegister  gathered                = VR10; \/\/ reuse non_match's register\n@@ -3839,12 +3910,5 @@\n-    __ load_const_optimized(const_ptr, (address)&bitposLUT_val, tmp_reg);\n-    __ lxv(bitposLUT, 0, const_ptr);\n-    if (PowerArchitecturePPC64 >= 10) {\n-        __ load_const_optimized(const_ptr, (address)&p10_pack_permute_val, tmp_reg);\n-    } else {\n-        __ load_const_optimized(const_ptr, (address)&pack_rshift_val, tmp_reg);\n-        __ lxv(pack_rshift->to_vsr(), 0, const_ptr);\n-        __ load_const_optimized(const_ptr, (address)&pack_lshift_val, tmp_reg);\n-        __ lxv(pack_lshift->to_vsr(), 0, const_ptr);\n-        __ load_const_optimized(const_ptr, (address)&pack_permute_val, tmp_reg);\n-    }\n-    __ lxv(pack_permute, 0, const_ptr);\n+    __ load_const_optimized(const_ptr, (address)&const_block, tmp_reg);\n+    __ lxv(bitposLUT, BLK_OFFSETOF(bitposLUT_val), const_ptr);\n+    __ lxv(pack_rshift->to_vsr(), BLK_OFFSETOF(pack_rshift_val), const_ptr);\n+    __ lxv(pack_lshift->to_vsr(), BLK_OFFSETOF(pack_lshift_val), const_ptr);\n+    __ lxv(pack_permute, BLK_OFFSETOF(pack_permute_val), const_ptr);\n@@ -3854,1 +3918,0 @@\n-    __ xxspltib(vec_4s->to_vsr(), 4);\n@@ -3856,1 +3919,0 @@\n-    __ xxspltib(vec_0xfs, 0xf);\n@@ -3858,1 +3920,17 @@\n-        __ xxspltib(vec_0x3fs->to_vsr(), 0x3f);\n+      \/\/ Using VALID_B64 for the offsets effectively strips the upper bit\n+      \/\/ of each byte that was selected from the table.  Setting the upper\n+      \/\/ bit gives us a way to distinguish between the 6-bit value of 0\n+      \/\/ from an error code of 0, which will happen if the character is\n+      \/\/ outside the range of the lookup, or is an illegal Base64\n+      \/\/ character, such as %.\n+      __ xxspltib(offsets->to_vsr(), VALID_B64);\n+\n+      __ lxv(table_48_63, BLK_OFFSETOF(table_48_63_val), const_ptr);\n+      __ lxv(table_64_79, BLK_OFFSETOF(table_64_79_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_val), const_ptr);\n+      __ lxv(table_96_111, BLK_OFFSETOF(table_96_111_val), const_ptr);\n+      __ lxv(table_112_127, BLK_OFFSETOF(table_112_127_val), const_ptr);\n+    } else {\n+      __ xxspltib(vec_4s->to_vsr(), 4);\n+      __ xxspltib(vec_0xfs, 0xf);\n+      __ lxv(bitposLUT, BLK_OFFSETOF(bitposLUT_val), const_ptr);\n@@ -3867,6 +3945,9 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_URL_val, tmp_reg);\n-    __ lxv(offsetLUT, 0, const_ptr);\n-    __ load_const_optimized(const_ptr, (address)&maskLUT_URL_val, tmp_reg);\n-    __ lxv(maskLUT, 0, const_ptr);\n-    __ xxspltib(vec_special_case_char->to_vsr(), '_');\n-    __ xxspltib(vec_special_case_offset, (unsigned char)US);\n+    if (PowerArchitecturePPC64 >= 10) {\n+      __ lxv(table_32_47, BLK_OFFSETOF(table_32_47_URL_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_URL_val), const_ptr);\n+    } else {\n+      __ lxv(offsetLUT, BLK_OFFSETOF(offsetLUT_URL_val), const_ptr);\n+      __ lxv(maskLUT, BLK_OFFSETOF(maskLUT_URL_val), const_ptr);\n+      __ xxspltib(vec_special_case_char->to_vsr(), '_');\n+      __ xxspltib(vec_special_case_offset, (unsigned char)US);\n+    }\n@@ -3877,6 +3958,9 @@\n-    __ load_const_optimized(const_ptr, (address)&offsetLUT_val, tmp_reg);\n-    __ lxv(offsetLUT, 0, const_ptr);\n-    __ load_const_optimized(const_ptr, (address)&maskLUT_val, tmp_reg);\n-    __ lxv(maskLUT, 0, const_ptr);\n-    __ xxspltib(vec_special_case_char->to_vsr(), '\/');\n-    __ xxspltib(vec_special_case_offset, (unsigned char)SLS);\n+    if (PowerArchitecturePPC64 >= 10) {\n+      __ lxv(table_32_47, BLK_OFFSETOF(table_32_47_val), const_ptr);\n+      __ lxv(table_80_95, BLK_OFFSETOF(table_80_95_val), const_ptr);\n+    } else {\n+      __ lxv(offsetLUT, BLK_OFFSETOF(offsetLUT_val), const_ptr);\n+      __ lxv(maskLUT, BLK_OFFSETOF(maskLUT_val), const_ptr);\n+      __ xxspltib(vec_special_case_char->to_vsr(), '\/');\n+      __ xxspltib(vec_special_case_offset, (unsigned char)SLS);\n+    }\n@@ -3895,7 +3979,21 @@\n-        \/\/ We can use a static displacement in the load since it's always a\n-        \/\/ multiple of 16, which is a requirement of lxv\/stxv.  This saves\n-        \/\/ an addi instruction.\n-        __ lxv(input->to_vsr(), unroll_cnt * 16, in);\n-        \/\/\n-        \/\/ Lookup\n-        \/\/\n+      \/\/ We can use a static displacement in the load since it's always a\n+      \/\/ multiple of 16, which is a requirement of lxv\/stxv.  This saves\n+      \/\/ an addi instruction.\n+      __ lxv(input->to_vsr(), unroll_cnt * 16, in);\n+\n+      \/\/\n+      \/\/ Lookup\n+      \/\/\n+      if (PowerArchitecturePPC64 >= 10) {\n+        \/\/ Use xxpermx to do a lookup of each Base64 character in the\n+        \/\/ input vector and translate it to a 6-bit value + 0x80.\n+        \/\/ Characters which are not valid Base64 characters will result\n+        \/\/ in a zero in the corresponding byte.\n+        __ align_prefix(); __ xxpermx(xlate_a, table_32_47, table_48_63, input->to_vsr(), 1);\n+        __ align_prefix(); __ xxpermx(xlate_b, table_64_79, table_80_95, input->to_vsr(), 2);\n+        __ xxlor(xlate_b, xlate_a, xlate_b);\n+        __ align_prefix(); __ xxpermx(xlate_a, table_96_111, table_112_127, input->to_vsr(), 3);\n+        __ xxlor(input->to_vsr(), xlate_a, xlate_b);\n+        \/\/ Check for non-Base64 characters by comparing each byte to zero.\n+        __ vcmpequb_(non_match, input, vec_0s);\n+      } else {\n@@ -3932,4 +4030,0 @@\n-        \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n-        \/\/ Any element comparing equal to zero means there is an error in\n-        \/\/ that element.  Note that the comparison result register\n-        \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n@@ -3937,4 +4031,6 @@\n-        __ bne_predict_not_taken(CCR6, unrolled_loop_exit);\n-\n-        \/\/ The Base64 characters had no errors, so add the offsets\n-        __ vaddubm(input, input, offsets);\n+      }\n+      \/\/ vmcmpequb_ sets the EQ bit of CCR6 if no elements compare equal.\n+      \/\/ Any element comparing equal to zero means there is an error in\n+      \/\/ that element.  Note that the comparison result register\n+      \/\/ non_match is not referenced again.  Only CCR6-EQ matters.\n+      __ bne_predict_not_taken(CCR6, unrolled_loop_exit);\n@@ -3942,111 +4038,2 @@\n-        \/\/ Pack\n-        \/\/\n-        \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n-        \/\/ binary data, the first line of each of the cells (except for\n-        \/\/ the constants) uses the bit-field nomenclature from the\n-        \/\/ above-linked paper, whereas the second line is more specific\n-        \/\/ about which exact bits are present, and is constructed using the\n-        \/\/ Power ISA 3.x document style, where:\n-        \/\/\n-        \/\/ * The specifier after the colon depicts which bits are there.\n-        \/\/ * The bit numbering is big endian style (bit 0 is the most\n-        \/\/   significant).\n-        \/\/ * || is a concatenate operator.\n-        \/\/ * Strings of 0's are a field of zeros with the shown length, and\n-        \/\/   likewise for strings of 1's.\n-\n-        if (PowerArchitecturePPC64 >= 10) {\n-            \/\/ Note that only e8..e15 are shown here because the extract bit\n-            \/\/ pattern is the same in e0..e7.\n-            \/\/\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-            \/\/ |    Vector     |     e8      |          e9          |         e10          |     e11     |     e12     |         e13          |         e14          |     e15     |\n-            \/\/ |    Element    |             |                      |                      |             |             |                      |                      |             |\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-            \/\/ | after vaddudb |  00hhhhhh   |       00gggggg       |       00ffffff       |  00eeeeee   |  00dddddd   |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n-            \/\/ |               | 00||b5:2..7 | 00||b4:4..7||b5:0..1 | 00||b3:6..7||b4:0..3 | 00||b3:0..5 | 00||b2:2..7 | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ |  after xxbrd  |  00aaaaaa   |       00bbbbbb       |       00cccccc       |  00dddddd   |  00eeeeee   |       00ffffff       |       00gggggg       |  00hhhhhh   |\n-            \/\/ |               | 00||b0:0..5 | 00||b0:6..7||b1:0..3 | 00||b1:4..7||b2:0..1 | 00||b2:2..7 | 00||b3:0..5 | 00||b3:6..7||b4:0..3 | 00||b4:4..7||b5:0..1 | 00||b5:2..7 |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ |   vec_0x3fs   |  00111111   |       00111111       |       00111111       |  00111111   |  00111111   |       00111111       |       00111111       |  00111111   |\n-            \/\/ +---------------+-------------+----------------------+----------------------+-------------+-------------+----------------------+----------------------+-------------+\n-            \/\/ | after vpextd  |  00000000   |       00000000       |       aaaaaabb       |  bbbbcccc   |  ccdddddd   |       eeeeeeff       |       ffffgggg       |  gghhhhhh   |\n-            \/\/ |               |  00000000   |       00000000       |       b0:0..7        |   b1:0..7   |   b2:0..7   |       b3:0..7        |       b4:0..7        |   b5:0..7   |\n-            \/\/ +===============+=============+======================+======================+=============+=============+======================+======================+=============+\n-\n-            __ xxbrd(input->to_vsr(), input->to_vsr());\n-            __ vpextd(gathered, input, vec_0x3fs);\n-\n-            \/\/ Final rearrangement of bytes into their correct positions.\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |      Vector      | e0 | e1 | e2 | e3 | e4  | e5  | e6  | e7  | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n-            \/\/ |     Elements     |    |    |    |    |     |     |     |     |    |    |     |     |     |     |     |     |\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |   after vpextd   | 0  | 0  | b6 | b7 | b8  | b9  | b10 | b11 | 0  | 0  | b0  | b1  | b2  | b3  | b4  | b5  |\n-            \/\/ +------------------+----+----+----+----+-----+-----+-----+-----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | p10_pack_permute | 0  | 0  | 0  | 0  |  7  |  6  |  5  |  4  | 3  | 2  | 15  | 14  | 13  | 12  | 11  | 10  |\n-            \/\/ +------------------+----+----+----+----+-----+-----+-----+-----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ |   after xxperm   | 0  | 0  | 0  | 0  | b11 | b10 | b9  | b8  | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n-            \/\/ +==================+====+====+====+====+=====+=====+=====+=====+====+====+=====+=====+=====+=====+=====+=====+\n-\n-        } else {\n-            \/\/ Note that only e12..e15 are shown here because the shifting\n-            \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n-            \/\/ e0..e3.\n-            \/\/\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n-            \/\/ |       Element        |                 |                      |                      |             |\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n-            \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n-            \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n-            \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n-            \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n-            \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n-            \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n-            \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n-            \/\/ +======================+=================+======================+======================+=============+\n-            \/\/\n-            \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n-            \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n-            \/\/ but should be:\n-            \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n-            \/\/\n-            __ vslb(l, input, pack_lshift);\n-            \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n-            \/\/ element numbers, discarding element 0.  This means it actually\n-            \/\/ shifts to the right (not left) according to the order of the\n-            \/\/ table above.\n-            __ vslo(l, l, vec_8s);\n-            __ vsrb(r, input, pack_rshift);\n-            __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n-\n-            \/\/ Final rearrangement of bytes into their correct positions.\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n-            \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n-            \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n-            \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n-            \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n-            \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n-            \/\/ xx bytes are not used to form the final data\n-            \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n-            \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n-            \/\/ overwritten on the next iteration.\n-        }\n-        __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n+      \/\/ The Base64 characters had no errors, so add the offsets\n+      __ vaddubm(input, input, offsets);\n@@ -4054,5 +4041,80 @@\n-        \/\/ We cannot use a static displacement on the store, since it's a\n-        \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n-        \/\/ writes 16 bytes, even though only the first 12 are valid data.\n-        __ stxv(gathered->to_vsr(), 0, out);\n-        __ addi(out, out, 12);\n+      \/\/ Pack\n+      \/\/\n+      \/\/ In the tables below, b0, b1, .. b15 are the bytes of decoded\n+      \/\/ binary data, the first line of each of the cells (except for\n+      \/\/ the constants) uses the bit-field nomenclature from the\n+      \/\/ above-linked paper, whereas the second line is more specific\n+      \/\/ about which exact bits are present, and is constructed using the\n+      \/\/ Power ISA 3.x document style, where:\n+      \/\/\n+      \/\/ * The specifier after the colon depicts which bits are there.\n+      \/\/ * The bit numbering is big endian style (bit 0 is the most\n+      \/\/   significant).\n+      \/\/ * || is a concatenate operator.\n+      \/\/ * Strings of 0's are a field of zeros with the shown length, and\n+      \/\/   likewise for strings of 1's.\n+\n+      \/\/ Note that only e12..e15 are shown here because the shifting\n+      \/\/ and OR'ing pattern replicates for e8..e11, e4..7, and\n+      \/\/ e0..e3.\n+      \/\/\n+      \/\/ +======================+=================+======================+======================+=============+\n+      \/\/ |        Vector        |       e12       |         e13          |         e14          |     e15     |\n+      \/\/ |       Element        |                 |                      |                      |             |\n+      \/\/ +======================+=================+======================+======================+=============+\n+      \/\/ |    after vaddubm     |    00dddddd     |       00cccccc       |       00bbbbbb       |  00aaaaaa   |\n+      \/\/ |                      |   00||b2:2..7   | 00||b1:4..7||b2:0..1 | 00||b0:6..7||b1:0..3 | 00||b0:0..5 |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ |     pack_lshift      |                 |         << 6         |         << 4         |    << 2     |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ |     l after vslb     |    00dddddd     |       cc000000       |       bbbb0000       |  aaaaaa00   |\n+      \/\/ |                      |   00||b2:2..7   |   b2:0..1||000000    |    b1:0..3||0000     | b0:0..5||00 |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ |     l after vslo     |    cc000000     |       bbbb0000       |       aaaaaa00       |  00000000   |\n+      \/\/ |                      | b2:0..1||000000 |    b1:0..3||0000     |     b0:0..5||00      |  00000000   |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ |     pack_rshift      |                 |         >> 2         |         >> 4         |             |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ |     r after vsrb     |    00dddddd     |       0000cccc       |       000000bb       |  00aaaaaa   |\n+      \/\/ |                      |   00||b2:2..7   |    0000||b1:4..7     |   000000||b0:6..7    | 00||b0:0..5 |\n+      \/\/ +----------------------+-----------------+----------------------+----------------------+-------------+\n+      \/\/ | gathered after xxlor |    ccdddddd     |       bbbbcccc       |       aaaaaabb       |  00aaaaaa   |\n+      \/\/ |                      |     b2:0..7     |       b1:0..7        |       b0:0..7        | 00||b0:0..5 |\n+      \/\/ +======================+=================+======================+======================+=============+\n+      \/\/\n+      \/\/ Note: there is a typo in the above-linked paper that shows the result of the gathering process is:\n+      \/\/ [ddddddcc|bbbbcccc|aaaaaabb]\n+      \/\/ but should be:\n+      \/\/ [ccdddddd|bbbbcccc|aaaaaabb]\n+      \/\/\n+      __ vslb(l, input, pack_lshift);\n+      \/\/ vslo of vec_8s shifts the vector by one octet toward lower\n+      \/\/ element numbers, discarding element 0.  This means it actually\n+      \/\/ shifts to the right (not left) according to the order of the\n+      \/\/ table above.\n+      __ vslo(l, l, vec_8s);\n+      __ vsrb(r, input, pack_rshift);\n+      __ xxlor(gathered->to_vsr(), l->to_vsr(), r->to_vsr());\n+\n+      \/\/ Final rearrangement of bytes into their correct positions.\n+      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+      \/\/ |    Vector    |  e0  |  e1  |  e2  |  e3  | e4  | e5  | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 | e14 | e15 |\n+      \/\/ |   Elements   |      |      |      |      |     |     |    |    |    |    |     |     |     |     |     |     |\n+      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+      \/\/ | after xxlor  | b11  | b10  |  b9  |  xx  | b8  | b7  | b6 | xx | b5 | b4 | b3  | xx  | b2  | b1  | b0  | xx  |\n+      \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+      \/\/ | pack_permute |  0   |  0   |  0   |  0   |  0  |  1  | 2  | 4  | 5  | 6  |  8  |  9  | 10  | 12  | 13  | 14  |\n+      \/\/ +--------------+------+------+------+------+-----+-----+----+----+----+----+-----+-----+-----+-----+-----+-----+\n+      \/\/ | after xxperm | b11* | b11* | b11* | b11* | b11 | b10 | b9 | b8 | b7 | b6 | b5  | b4  | b3  | b2  | b1  | b0  |\n+      \/\/ +==============+======+======+======+======+=====+=====+====+====+====+====+=====+=====+=====+=====+=====+=====+\n+      \/\/ xx bytes are not used to form the final data\n+      \/\/ b0..b15 are the decoded and reassembled 8-bit bytes of data\n+      \/\/ b11 with asterisk is a \"don't care\", because these bytes will be\n+      \/\/ overwritten on the next iteration.\n+      __ xxperm(gathered->to_vsr(), gathered->to_vsr(), pack_permute);\n+\n+      \/\/ We cannot use a static displacement on the store, since it's a\n+      \/\/ multiple of 12, not 16.  Note that this stxv instruction actually\n+      \/\/ writes 16 bytes, even though only the first 12 are valid data.\n+      __ stxv(gathered->to_vsr(), 0, out);\n+      __ addi(out, out, 12);\n@@ -4191,4 +4253,6 @@\n-\/\/ lower 32 bytes of the lookup operation.  Power10 and beyond can save the\n-\/\/ compare instruction, because the comparison is done within xxpermx\n-\/\/ itself. TODO: use xxpermx,xxpermx,vor on P10 when instruction prefixes are\n-\/\/ available in assembler_ppc.*\n+\/\/ lower 32 bytes of the lookup operation.\n+\/\/\n+\/\/ Note: it's tempting to use a xxpermx,xxpermx,vor sequence here on\n+\/\/ Power10+, but experiments doing so on Power10 yielded a slight\n+\/\/ performance drop, perhaps due to the need for xxpermx instruction\n+\/\/ prefixes.\n@@ -4286,1 +4350,0 @@\n-    #define BLK_OFFSETOF(x) (offsetof(constant_block, x))\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":294,"deletions":231,"binary":false,"changes":525,"status":"modified"}]}