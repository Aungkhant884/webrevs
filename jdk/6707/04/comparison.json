{"files":[{"patch":"@@ -26,1 +26,0 @@\n-import java.io.IOException;\n@@ -28,0 +27,1 @@\n+import java.io.IOException;\n@@ -29,0 +29,1 @@\n+import java.nio.ByteBuffer;\n@@ -54,0 +55,1 @@\n+import static java.nio.file.StandardOpenOption.*;\n@@ -65,2 +67,2 @@\n- * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n- *          InputStream.transferTo contract defined in the javadoc\n+ * @summary Tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo specification\n@@ -75,3 +77,3 @@\n-    private static final int NUM_WRITES = 3 * 1024;\n-    private static final int BYTES_PER_WRITE = 1024 * 1024;\n-    private static final long BYTES_WRITTEN = (long) NUM_WRITES * BYTES_PER_WRITE;\n+    private static final int NUM_WRITES = 3*1024;\n+    private static final int BYTES_PER_WRITE = 1024*1024;\n+    private static final long BYTES_WRITTEN = (long) NUM_WRITES*BYTES_PER_WRITE;\n@@ -84,1 +86,2 @@\n-     * Provides test scenarios, i. e. combinations of input and output streams to be tested.\n+     * Provides test scenarios, i.e., combinations of input and output streams\n+     * to be tested.\n@@ -92,1 +95,2 @@\n-            \/\/ tests FileChannel.transferTo(SelectableChannelOutput) optimized case\n+            \/\/ tests FileChannel.transferTo(SelectableChannelOutput)\n+            \/\/ optimized case\n@@ -95,1 +99,2 @@\n-            \/\/ tests FileChannel.transferTo(WritableChannelOutput) optimized case\n+            \/\/ tests FileChannel.transferTo(WritableChannelOutput)\n+            \/\/ optimized case\n@@ -104,1 +109,2 @@\n-     * Testing API compliance: Input stream must throw NullPointerException when parameter \"out\" is null.\n+     * Testing API compliance: input stream must throw NullPointerException\n+     * when parameter \"out\" is null.\n@@ -120,1 +126,2 @@\n-     * Testing API compliance: Complete content of input stream must be transferred to output stream.\n+     * Testing API compliance: complete content of input stream must be\n+     * transferred to output stream.\n@@ -131,1 +138,2 @@\n-        \/\/ tests input stream with several data chunks, as 16k is more than a single chunk can hold\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n@@ -134,1 +142,2 @@\n-        \/\/ tests randomly chosen starting positions within source and target stream\n+        \/\/ tests randomly chosen starting positions within source and\n+        \/\/ target stream\n@@ -150,4 +159,5 @@\n-     * Special test for file-to-file transfer of more than two GB.\n-     * This test covers multiple iterations of FileChannel.transerTo(FileChannel),\n-     * which ChannelInputStream.transferTo() only applies in this particular case,\n-     * and cannot get tested using a single byte[] due to size limitation of arrays.\n+     * Special test for file-to-file transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transerTo(FileChannel),\n+     * which ChannelInputStream.transferTo() only applies in this particular\n+     * case, and cannot get tested using a single byte[] due to size limitation\n+     * of arrays.\n@@ -157,1 +167,6 @@\n-        Path sourceFile = Files.createTempFile(CWD, \"test2GBSource\", null);\n+        \/\/ prepare two temporary files to be compared at the end of the test\n+        \/\/ set the source file name\n+        String sourceName = String.format(\"test3GBSource%s.tmp\",\n+            String.valueOf(RND.nextInt(Integer.MAX_VALUE)));\n+        Path sourceFile = CWD.resolve(sourceName);\n+\n@@ -159,2 +174,5 @@\n-            \/\/ preparing two temporary files which will be compared at the end of the test\n-            Path targetFile = Files.createTempFile(CWD, \"test2GBtarget\", null);\n+            \/\/ set the target file name\n+            String targetName = String.format(\"test3GBTarget%s.tmp\",\n+                String.valueOf(RND.nextInt(Integer.MAX_VALUE)));\n+            Path targetFile = CWD.resolve(targetName);\n+\n@@ -162,3 +180,16 @@\n-                \/\/ writing 3 GB of random bytes into source file\n-                for (int i = 0; i < NUM_WRITES; i++)\n-                    Files.write(sourceFile, createRandomBytes(BYTES_PER_WRITE, 0), StandardOpenOption.APPEND);\n+                \/\/ calculate initial position to be just short of 2GB\n+                final long initPos = 2047*BYTES_PER_WRITE;\n+\n+                \/\/ create the source file with a hint to be sparse\n+                try (FileChannel fc = FileChannel.open(sourceFile, CREATE_NEW, SPARSE, WRITE, APPEND);) {\n+                    \/\/ set initial position to avoid writing nearly 2GB\n+                    fc.position(initPos);\n+\n+                    \/\/ fill the remainder of the file with random bytes\n+                    int nw = (int)(NUM_WRITES - initPos\/BYTES_PER_WRITE);\n+                    for (int i = 0; i < nw; i++) {\n+                        byte[] rndBytes = createRandomBytes(BYTES_PER_WRITE, 0);\n+                        ByteBuffer src = ByteBuffer.wrap(rndBytes);\n+                        fc.write(src);\n+                    }\n+                }\n@@ -166,6 +197,2 @@\n-                \/\/ performing actual transfer, effectively by multiple invocations of Filechannel.transferTo(FileChannel)\n-                long count;\n-                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n-                     OutputStream outputStream = Channels\n-                             .newOutputStream(FileChannel.open(targetFile, StandardOpenOption.WRITE))) {\n-                    count = inputStream.transferTo(outputStream);\n+                \/\/ create the target file with a hint to be sparse\n+                try (FileChannel fc = FileChannel.open(targetFile, CREATE_NEW, WRITE, SPARSE);) {\n@@ -174,2 +201,10 @@\n-                \/\/ comparing reported transferred bytes, must be 3 GB\n-                assertEquals(count, BYTES_WRITTEN);\n+                \/\/ perform actual transfer, effectively by multiple invocations\n+                \/\/ of Filechannel.transferTo(FileChannel)\n+                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n+                     OutputStream outputStream = Channels.newOutputStream(FileChannel.open(targetFile, WRITE))) {\n+                    long count = inputStream.transferTo(outputStream);\n+\n+                    \/\/ compare reported transferred bytes, must be 3 GB\n+                    \/\/ less the value of the initial position\n+                    assertEquals(count, BYTES_WRITTEN - initPos);\n+                }\n@@ -177,1 +212,1 @@\n-                \/\/ comparing content of both files, failing in case of any difference\n+                \/\/ compare content of both files, failing if different\n@@ -189,1 +224,2 @@\n-     * Special test whether selectable channel based transfer throws blocking mode exception.\n+     * Special test of whether selectable channel based transfer throws blocking\n+     * mode exception.\n@@ -195,1 +231,2 @@\n-            \/\/ testing arbitrary input (here: empty file) to non-blocking selectable output\n+            \/\/ testing arbitrary input (here: empty file) to non-blocking\n+            \/\/ selectable output\n@@ -197,3 +234,3 @@\n-                    InputStream is = Channels.newInputStream(fc);\n-                    SelectableChannel sc = pipe.sink().configureBlocking(false);\n-                    OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n+                InputStream is = Channels.newInputStream(fc);\n+                SelectableChannel sc = pipe.sink().configureBlocking(false);\n+                OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n@@ -201,1 +238,2 @@\n-                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform\n+                \/\/ a transfer\n@@ -205,1 +243,2 @@\n-            \/\/ testing non-blocking selectable input to arbitrary output (here: byte array)\n+            \/\/ testing non-blocking selectable input to arbitrary output\n+            \/\/ (here: byte array)\n@@ -207,2 +246,2 @@\n-                    InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n-                    OutputStream os = new ByteArrayOutputStream()) {\n+                InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n+                OutputStream os = new ByteArrayOutputStream()) {\n@@ -210,1 +249,2 @@\n-                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform\n+                \/\/ a transfer\n@@ -220,3 +260,3 @@\n-     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n-     * to the expected assumption. The position of the input and output stream before the transfer is\n-     * the start of stream (BOF).\n+     * Asserts that the transferred content is correct, i.e., compares the bytes\n+     * actually transferred to those expected. The position of the input and\n+     * output streams before the transfer are zero (BOF).\n@@ -230,3 +270,3 @@\n-     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n-     * to the expected assumption. The position of the input and output stream before the transfer is\n-     * provided by the caller.\n+     * Asserts that the transferred content is correct, i. e. compares the bytes\n+     * actually transferred to those expected. The positions of the input and\n+     * output streams before the transfer are provided by the caller.\n@@ -238,2 +278,2 @@\n-                OutputStream out = outputStreamProvider.output(recorder::set)) {\n-            \/\/ skip bytes till starting position\n+            OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            \/\/ skip bytes until starting position\n@@ -255,1 +295,2 @@\n-     * Creates an array of random size (between min and min + maxRandomAdditive) filled with random bytes\n+     * Creates an array of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes\n@@ -301,1 +342,2 @@\n-     * Creates a provider for an input stream which wraps a readable byte channel but is not a file channel\n+     * Creates a provider for an input stream which wraps a readable byte\n+     * channel but is not a file channel\n@@ -319,1 +361,1 @@\n-                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                FileChannel fileChannel = FileChannel.open(path, WRITE);\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":95,"deletions":53,"binary":false,"changes":148,"status":"modified"}]}