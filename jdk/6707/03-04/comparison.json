{"files":[{"patch":"@@ -67,2 +67,2 @@\n- * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n- *          InputStream.transferTo contract defined in the javadoc\n+ * @summary Tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo specification\n@@ -77,3 +77,3 @@\n-    private static final int NUM_WRITES = 3 * 1024;\n-    private static final int BYTES_PER_WRITE = 1024 * 1024;\n-    private static final long BYTES_WRITTEN = (long) NUM_WRITES * BYTES_PER_WRITE;\n+    private static final int NUM_WRITES = 3*1024;\n+    private static final int BYTES_PER_WRITE = 1024*1024;\n+    private static final long BYTES_WRITTEN = (long) NUM_WRITES*BYTES_PER_WRITE;\n@@ -86,1 +86,2 @@\n-     * Provides test scenarios, i. e. combinations of input and output streams to be tested.\n+     * Provides test scenarios, i.e., combinations of input and output streams\n+     * to be tested.\n@@ -94,1 +95,2 @@\n-            \/\/ tests FileChannel.transferTo(SelectableChannelOutput) optimized case\n+            \/\/ tests FileChannel.transferTo(SelectableChannelOutput)\n+            \/\/ optimized case\n@@ -97,1 +99,2 @@\n-            \/\/ tests FileChannel.transferTo(WritableChannelOutput) optimized case\n+            \/\/ tests FileChannel.transferTo(WritableChannelOutput)\n+            \/\/ optimized case\n@@ -106,1 +109,2 @@\n-     * Testing API compliance: Input stream must throw NullPointerException when parameter \"out\" is null.\n+     * Testing API compliance: input stream must throw NullPointerException\n+     * when parameter \"out\" is null.\n@@ -122,1 +126,2 @@\n-     * Testing API compliance: Complete content of input stream must be transferred to output stream.\n+     * Testing API compliance: complete content of input stream must be\n+     * transferred to output stream.\n@@ -133,1 +138,2 @@\n-        \/\/ tests input stream with several data chunks, as 16k is more than a single chunk can hold\n+        \/\/ tests input stream with several data chunks, as 16k is more than a\n+        \/\/ single chunk can hold\n@@ -136,1 +142,2 @@\n-        \/\/ tests randomly chosen starting positions within source and target stream\n+        \/\/ tests randomly chosen starting positions within source and\n+        \/\/ target stream\n@@ -152,4 +159,5 @@\n-     * Special test for file-to-file transfer of more than two GB.\n-     * This test covers multiple iterations of FileChannel.transerTo(FileChannel),\n-     * which ChannelInputStream.transferTo() only applies in this particular case,\n-     * and cannot get tested using a single byte[] due to size limitation of arrays.\n+     * Special test for file-to-file transfer of more than 2 GB. This test\n+     * covers multiple iterations of FileChannel.transerTo(FileChannel),\n+     * which ChannelInputStream.transferTo() only applies in this particular\n+     * case, and cannot get tested using a single byte[] due to size limitation\n+     * of arrays.\n@@ -159,1 +167,3 @@\n-        String fileName = String.format(\"test3GBSource%s.tmp\",\n+        \/\/ prepare two temporary files to be compared at the end of the test\n+        \/\/ set the source file name\n+        String sourceName = String.format(\"test3GBSource%s.tmp\",\n@@ -161,1 +171,2 @@\n-        Path sourceFile = CWD.resolve(fileName);\n+        Path sourceFile = CWD.resolve(sourceName);\n+\n@@ -163,2 +174,5 @@\n-            \/\/ preparing two temporary files which will be compared at the end of the test\n-            Path targetFile = Files.createTempFile(CWD, \"test2GBtarget\", null);\n+            \/\/ set the target file name\n+            String targetName = String.format(\"test3GBTarget%s.tmp\",\n+                String.valueOf(RND.nextInt(Integer.MAX_VALUE)));\n+            Path targetFile = CWD.resolve(targetName);\n+\n@@ -169,1 +183,1 @@\n-                \/\/ create the file with a hint to be sparse\n+                \/\/ create the source file with a hint to be sparse\n@@ -183,6 +197,2 @@\n-                \/\/ performing actual transfer, effectively by multiple invocations of Filechannel.transferTo(FileChannel)\n-                long count;\n-                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n-                     OutputStream outputStream = Channels\n-                             .newOutputStream(FileChannel.open(targetFile, StandardOpenOption.WRITE))) {\n-                    count = inputStream.transferTo(outputStream);\n+                \/\/ create the target file with a hint to be sparse\n+                try (FileChannel fc = FileChannel.open(targetFile, CREATE_NEW, WRITE, SPARSE);) {\n@@ -191,3 +201,10 @@\n-                \/\/ comparing reported transferred bytes, must be 3 GB\n-                \/\/ less the value of the initial position\n-                assertEquals(count, BYTES_WRITTEN - initPos);\n+                \/\/ perform actual transfer, effectively by multiple invocations\n+                \/\/ of Filechannel.transferTo(FileChannel)\n+                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n+                     OutputStream outputStream = Channels.newOutputStream(FileChannel.open(targetFile, WRITE))) {\n+                    long count = inputStream.transferTo(outputStream);\n+\n+                    \/\/ compare reported transferred bytes, must be 3 GB\n+                    \/\/ less the value of the initial position\n+                    assertEquals(count, BYTES_WRITTEN - initPos);\n+                }\n@@ -195,1 +212,1 @@\n-                \/\/ comparing content of both files, failing in case of any difference\n+                \/\/ compare content of both files, failing if different\n@@ -207,1 +224,2 @@\n-     * Special test whether selectable channel based transfer throws blocking mode exception.\n+     * Special test of whether selectable channel based transfer throws blocking\n+     * mode exception.\n@@ -213,1 +231,2 @@\n-            \/\/ testing arbitrary input (here: empty file) to non-blocking selectable output\n+            \/\/ testing arbitrary input (here: empty file) to non-blocking\n+            \/\/ selectable output\n@@ -215,3 +234,3 @@\n-                    InputStream is = Channels.newInputStream(fc);\n-                    SelectableChannel sc = pipe.sink().configureBlocking(false);\n-                    OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n+                InputStream is = Channels.newInputStream(fc);\n+                SelectableChannel sc = pipe.sink().configureBlocking(false);\n+                OutputStream os = Channels.newOutputStream((WritableByteChannel) sc)) {\n@@ -219,1 +238,2 @@\n-                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform\n+                \/\/ a transfer\n@@ -223,1 +243,2 @@\n-            \/\/ testing non-blocking selectable input to arbitrary output (here: byte array)\n+            \/\/ testing non-blocking selectable input to arbitrary output\n+            \/\/ (here: byte array)\n@@ -225,2 +246,2 @@\n-                    InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n-                    OutputStream os = new ByteArrayOutputStream()) {\n+                InputStream is = Channels.newInputStream((ReadableByteChannel) sc);\n+                OutputStream os = new ByteArrayOutputStream()) {\n@@ -228,1 +249,2 @@\n-                \/\/ IllegalBlockingMode must be thrown when trying to perform a transfer\n+                \/\/ IllegalBlockingMode must be thrown when trying to perform\n+                \/\/ a transfer\n@@ -238,3 +260,3 @@\n-     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n-     * to the expected assumption. The position of the input and output stream before the transfer is\n-     * the start of stream (BOF).\n+     * Asserts that the transferred content is correct, i.e., compares the bytes\n+     * actually transferred to those expected. The position of the input and\n+     * output streams before the transfer are zero (BOF).\n@@ -248,3 +270,3 @@\n-     * Asserts that the transferred content is correct, i. e. compares the actually transferred bytes\n-     * to the expected assumption. The position of the input and output stream before the transfer is\n-     * provided by the caller.\n+     * Asserts that the transferred content is correct, i. e. compares the bytes\n+     * actually transferred to those expected. The positions of the input and\n+     * output streams before the transfer are provided by the caller.\n@@ -256,2 +278,2 @@\n-                OutputStream out = outputStreamProvider.output(recorder::set)) {\n-            \/\/ skip bytes till starting position\n+            OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            \/\/ skip bytes until starting position\n@@ -273,1 +295,2 @@\n-     * Creates an array of random size (between min and min + maxRandomAdditive) filled with random bytes\n+     * Creates an array of random size (between min and min + maxRandomAdditive)\n+     * filled with random bytes\n@@ -319,1 +342,2 @@\n-     * Creates a provider for an input stream which wraps a readable byte channel but is not a file channel\n+     * Creates a provider for an input stream which wraps a readable byte\n+     * channel but is not a file channel\n@@ -337,1 +361,1 @@\n-                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                FileChannel fileChannel = FileChannel.open(path, WRITE);\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":76,"deletions":52,"binary":false,"changes":128,"status":"modified"}]}