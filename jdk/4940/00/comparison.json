{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -658,0 +658,18 @@\n+    private long transferTo(long position, int icount,\n+                            WritableByteChannel target)\n+        throws IOException\n+    {\n+        long n;\n+\n+        \/\/ Attempt a direct transfer, if the kernel supports it\n+        if ((n = transferToDirectly(position, icount, target)) >= 0)\n+            return n;\n+\n+        \/\/ Attempt a mapped transfer, but only to trusted channel types\n+        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)\n+            return n;\n+\n+        \/\/ Slow path for untrusted targets\n+        return transferToArbitraryChannel(position, icount, target);\n+    }\n+\n@@ -675,9 +693,0 @@\n-        int icount = (int)Math.min(count, Integer.MAX_VALUE);\n-        if ((sz - position) < icount)\n-            icount = (int)(sz - position);\n-\n-        long n;\n-\n-        \/\/ Attempt a direct transfer, if the kernel supports it\n-        if ((n = transferToDirectly(position, icount, target)) >= 0)\n-            return n;\n@@ -685,3 +694,13 @@\n-        \/\/ Attempt a mapped transfer, but only to trusted channel types\n-        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)\n-            return n;\n+        long bytesTransferred = 0L;\n+        final long maxTransferSize = maxTransferSize0();\n+        while (bytesTransferred < count) {\n+            int icount =\n+                (int)Math.min(count - bytesTransferred, maxTransferSize);\n+            if ((sz - position) < icount)\n+                icount = (int)(sz - position);\n+            long n = transferTo(position, icount, target);\n+            if (n <= 0)\n+                break;\n+            position += n;\n+            bytesTransferred += n;\n+        }\n@@ -689,2 +708,1 @@\n-        \/\/ Slow path for untrusted targets\n-        return transferToArbitraryChannel(position, icount, target);\n+        return bytesTransferred;\n@@ -1351,0 +1369,3 @@\n+    \/\/ Retrieves the maximum size of a transfer\n+    private native long maxTransferSize0();\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,0 +255,9 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_maxTransferSize0(JNIEnv* env, jobject this)\n+{\n+#if defined(LINUX)\n+    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+#else\n+    return java_lang_Integer_MAX_VALUE;\n+#endif\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,3 @@\n+\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n+#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n+\n@@ -159,2 +162,2 @@\n-    DWORD chunkSize = (count > java_lang_Integer_MAX_VALUE) ?\n-        java_lang_Integer_MAX_VALUE : (DWORD)count;\n+    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n+        MAX_TRANSMIT_SIZE : (DWORD)count;\n@@ -192,0 +195,7 @@\n+\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_maxTransferSize0(JNIEnv* env, jobject this)\n+{\n+    return MAX_TRANSMIT_SIZE;\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271308\n+ * @summary Verify that transferTo() copies more than Integer.MAX_VALUE bytes\n+ *\/\n+\n+import java.io.File;\n+import java.io.DataOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class Transfer2GPlus {\n+    private static final long BASE   = (long)Integer.MAX_VALUE;\n+    private static final int  EXTRA  = 1024;\n+    private static final long LENGTH = BASE + EXTRA;\n+\n+    public static void main(String[] args) throws IOException {\n+        Path src = Files.createTempFile(\"src\", \".dat\");\n+        src.toFile().deleteOnExit();\n+        byte[] b = createSrcFile(src);\n+        testToFileChannel(src, b);\n+        testToWritableByteChannel(src, b);\n+    }\n+\n+    \/\/ Create a file of size LENGTH with EXTRA random bytes at offset BASE.\n+    private static byte[] createSrcFile(Path src)\n+        throws IOException {\n+        RandomAccessFile raf = new RandomAccessFile(src.toString(), \"rw\");\n+        raf.setLength(LENGTH);\n+        raf.seek(BASE);\n+        Random r = new Random(System.nanoTime());\n+        byte[] b = new byte[EXTRA];\n+        r.nextBytes(b);\n+        raf.write(b);\n+        return b;\n+    }\n+\n+    \/\/ Exercises transferToDirectly() on Linux and transferToTrustedChannel()\n+    \/\/ on macOS and Windows.\n+    private static void testToFileChannel(Path src, byte[] expected)\n+        throws IOException {\n+        Path dst = Files.createTempFile(\"dst\", \".dat\");\n+        dst.toFile().deleteOnExit();\n+        try (FileChannel srcCh = FileChannel.open(src)) {\n+            try (FileChannel dstCh = FileChannel.open(dst,\n+                 StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                long n;\n+                if ((n = srcCh.transferTo(0, LENGTH, dstCh)) < LENGTH)\n+                    throw new RuntimeException(\"Too few bytes transferred: \" +\n+                        n + \" < \" + LENGTH);\n+\n+                if (dstCh.size() < LENGTH)\n+                    throw new RuntimeException(\"Target file too small: \" +\n+                        dstCh.size() + \" < \" + LENGTH);\n+\n+                System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+                dstCh.position(BASE);\n+                ByteBuffer bb = ByteBuffer.allocate(EXTRA);\n+                dstCh.read(bb);\n+                if (!Arrays.equals(bb.array(), expected))\n+                    throw new RuntimeException(\"Unexpected values\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Exercises transferToArbitraryChannel() on all platforms.\n+    private static void testToWritableByteChannel(Path src, byte[] expected)\n+        throws IOException {\n+        File file = File.createTempFile(\"dst\", \".dat\");\n+        file.deleteOnExit();\n+        try (FileChannel srcCh = FileChannel.open(src)) {\n+            \/\/ The FileOutputStream is wrapped so that newChannel() does not\n+            \/\/ return a FileChannelImpl and so make a faster path be taken.\n+            try (DataOutputStream stream =\n+                new DataOutputStream(new FileOutputStream(file))) {\n+                try (WritableByteChannel wbc = Channels.newChannel(stream)) {\n+                    long n;\n+                    if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n+                        throw new RuntimeException(\"Too few bytes transferred: \" +\n+                            n + \" < \" + LENGTH);\n+\n+                    System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+                    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n+                    raf.seek(BASE);\n+                    byte[] b = new byte[EXTRA];\n+                    raf.read(b);\n+                    if (!Arrays.equals(b, expected))\n+                        throw new RuntimeException(\"Unexpected values\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer2GPlus.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}