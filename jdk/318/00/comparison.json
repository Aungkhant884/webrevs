{"files":[{"patch":"@@ -769,1 +769,7 @@\n-          \"Do not use subtype check macro node\")\n+          \"Do not use subtype check macro node\")                            \\\n+                                                                            \\\n+  develop(uintx, StressLongCountedLoop, 0,                                  \\\n+          \"if > 0, convert int counted loops to long counted loops\"         \\\n+          \"to stress handling of long counted loops: run inner loop\"        \\\n+          \"for at most jint_max \/ StressLongCountedLoop\")                   \\\n+          range(0, max_juint)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -970,0 +970,40 @@\n+\n+void CallJavaNode::copy_call_debug_info(PhaseIterGVN* phase, SafePointNode *sfpt) {\n+  \/\/ Copy debug information and adjust JVMState information\n+  uint old_dbg_start = sfpt->is_Call() ? sfpt->as_Call()->tf()->domain()->cnt() : (uint)TypeFunc::Parms+1;\n+  uint new_dbg_start = tf()->domain()->cnt();\n+  int jvms_adj  = new_dbg_start - old_dbg_start;\n+  assert (new_dbg_start == req(), \"argument count mismatch\");\n+  Compile* C = phase->C;\n+\n+  \/\/ SafePointScalarObject node could be referenced several times in debug info.\n+  \/\/ Use Dict to record cloned nodes.\n+  Dict* sosn_map = new Dict(cmpkey,hashkey);\n+  for (uint i = old_dbg_start; i < sfpt->req(); i++) {\n+    Node* old_in = sfpt->in(i);\n+    \/\/ Clone old SafePointScalarObjectNodes, adjusting their field contents.\n+    if (old_in != NULL && old_in->is_SafePointScalarObject()) {\n+      SafePointScalarObjectNode* old_sosn = old_in->as_SafePointScalarObject();\n+      bool new_node;\n+      Node* new_in = old_sosn->clone(sosn_map, new_node);\n+      if (new_node) { \/\/ New node?\n+        new_in->set_req(0, C->root()); \/\/ reset control edge\n+        new_in = phase->transform(new_in); \/\/ Register new node.\n+      }\n+      old_in = new_in;\n+    }\n+    add_req(old_in);\n+  }\n+\n+  \/\/ JVMS may be shared so clone it before we modify it\n+  set_jvms(sfpt->jvms() != NULL ? sfpt->jvms()->clone_deep(C) : NULL);\n+  for (JVMState *jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+    jvms->set_map(this);\n+    jvms->set_locoff(jvms->locoff()+jvms_adj);\n+    jvms->set_stkoff(jvms->stkoff()+jvms_adj);\n+    jvms->set_monoff(jvms->monoff()+jvms_adj);\n+    jvms->set_scloff(jvms->scloff()+jvms_adj);\n+    jvms->set_endoff(jvms->endoff()+jvms_adj);\n+  }\n+}\n+\n@@ -1162,1 +1202,3 @@\n-  if( in(0)->is_Proj() ) {\n+  \/\/ Transforming long counted loops requires a safepoint node. Do not\n+  \/\/ eliminate a safepoint until loop opts are over.\n+  if (in(0)->is_Proj() && !phase->C->major_progress()) {\n@@ -1335,1 +1377,1 @@\n-SafePointScalarObjectNode::clone(Dict* sosn_map) const {\n+SafePointScalarObjectNode::clone(Dict* sosn_map, bool& new_node) const {\n@@ -1338,0 +1380,1 @@\n+    new_node = false;\n@@ -1340,0 +1383,1 @@\n+  new_node = true;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-  SafePointScalarObjectNode* clone(Dict* sosn_map) const;\n+  SafePointScalarObjectNode* clone(Dict* sosn_map, bool& new_node) const;\n@@ -638,0 +638,2 @@\n+  virtual void copy_call_debug_info(PhaseIterGVN* phase, SafePointNode *sfpt) {}\n+\n@@ -680,0 +682,1 @@\n+  void copy_call_debug_info(PhaseIterGVN* phase, SafePointNode *sfpt);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3366,0 +3366,1 @@\n+    assert(!n->as_Loop()->is_transformed_long_loop(), \"should have been turned into a counted loop\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-  if (tl->is_con())\n+  if (tl->is_con()) {\n@@ -455,0 +455,4 @@\n+  }\n+  if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n+    return TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n+  }\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -504,0 +507,723 @@\n+static int check_stride_overflow(jlong stride_con, const TypeLong* limit_t) {\n+  if (stride_con > 0) {\n+    if (limit_t->_lo > (max_jlong - stride_con)) {\n+      return -1;\n+    }\n+    if (limit_t->_hi > (max_jlong - stride_con)) {\n+      return 1;\n+    }\n+  } else {\n+    if (limit_t->_hi < (min_jlong - stride_con)) {\n+      return -1;\n+    }\n+    if (limit_t->_lo < (min_jlong - stride_con)) {\n+      return 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n+static bool condition_stride_ok(BoolTest::mask bt, jlong stride_con) {\n+  \/\/ If the condition is inverted and we will be rolling\n+  \/\/ through MININT to MAXINT, then bail out.\n+  if (bt == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n+      \/\/ Odd stride\n+      (bt == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n+      \/\/ Count down loop rolls through MAXINT\n+      ((bt == BoolTest::le || bt == BoolTest::lt) && stride_con < 0) ||\n+      \/\/ Count up loop rolls through MININT\n+      ((bt == BoolTest::ge || bt == BoolTest::gt) && stride_con > 0)) {\n+    return false; \/\/ Bail out\n+  }\n+  return true;\n+}\n+\n+void PhaseIdealLoop::long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head) {\n+  Node* iv_as_long = new ConvI2LNode(inner_iv, TypeLong::INT);\n+  register_new_node(iv_as_long, inner_head);\n+  Node* iv_replacement = new AddLNode(outer_phi, iv_as_long);\n+  register_new_node(iv_replacement, inner_head);\n+  for (DUIterator_Last imin, i = iv_to_replace->last_outs(imin); i >= imin;) {\n+    Node* u = iv_to_replace->last_out(i);\n+#ifdef ASSERT\n+    if (!is_dominator(inner_head, ctrl_or_self(u))) {\n+      assert(u->is_Phi(), \"should be a Phi\");\n+      for (uint j = 1; j < u->req(); j++) {\n+        if (u->in(j) == iv_to_replace) {\n+          assert(is_dominator(inner_head, u->in(0)->in(j)), \"iv use above loop?\");\n+        }\n+      }\n+    }\n+#endif\n+    _igvn.rehash_node_delayed(u);\n+    int nb = u->replace_edge(iv_to_replace, iv_replacement);\n+    i -= nb;\n+  }\n+}\n+\n+void PhaseIdealLoop::add_empty_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop, SafePointNode* sfpt) {\n+  if (!C->too_many_traps(reason)) {\n+    Node *cont = _igvn.intcon(1);\n+    Node* opq = new Opaque1Node(C, cont);\n+    _igvn.register_new_node_with_optimizer(opq);\n+    Node *bol = new Conv2BNode(opq);\n+    _igvn.register_new_node_with_optimizer(bol);\n+    set_subtree_ctrl(bol);\n+    IfNode* iff = new IfNode(inner_head->in(LoopNode::EntryControl), bol, PROB_MAX, COUNT_UNKNOWN);\n+    register_control(iff, loop, inner_head->in(LoopNode::EntryControl));\n+    Node* iffalse = new IfFalseNode(iff);\n+    register_control(iffalse, _ltree_root, iff);\n+    Node* iftrue = new IfTrueNode(iff);\n+    register_control(iftrue, loop, iff);\n+    C->add_predicate_opaq(opq);\n+\n+    int trap_request = Deoptimization::make_trap_request(reason, Deoptimization::Action_maybe_recompile);\n+    address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+    const TypePtr* no_memory_effects = NULL;\n+    JVMState* jvms = sfpt->jvms();\n+    CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n+                                           jvms->bci(), no_memory_effects);\n+\n+    Node* mem = NULL;\n+    Node* i_o = NULL;\n+    if (sfpt->is_Call()) {\n+      mem = sfpt->proj_out(TypeFunc::Memory);\n+      i_o = sfpt->proj_out(TypeFunc::I_O);\n+    } else {\n+      mem = sfpt->memory();\n+      i_o = sfpt->i_o();\n+    }\n+\n+    Node *frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+    register_new_node(frame, C->start());\n+    Node *ret = new ParmNode(C->start(), TypeFunc::ReturnAdr);\n+    register_new_node(ret, C->start());\n+\n+    unc->init_req(TypeFunc::Control, iffalse);\n+    unc->init_req(TypeFunc::I_O, i_o);\n+    unc->init_req(TypeFunc::Memory, mem); \/\/ may gc ptrs\n+    unc->init_req(TypeFunc::FramePtr, frame);\n+    unc->init_req(TypeFunc::ReturnAdr, ret);\n+    unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n+    unc->set_cnt(PROB_UNLIKELY_MAG(4));\n+    unc->copy_call_debug_info(&_igvn, sfpt);\n+\n+    for (uint i = TypeFunc::Parms; i < unc->req(); i++) {\n+      set_subtree_ctrl(unc->in(i));\n+    }\n+    register_control(unc, _ltree_root, iffalse);\n+\n+    Node* ctrl = new ProjNode(unc, TypeFunc::Control);\n+    register_control(ctrl, _ltree_root, unc);\n+    Node* halt = new HaltNode(ctrl, frame, \"uncommon trap returned which should never happen\" PRODUCT_ONLY(COMMA \/*reachable*\/false));\n+    register_control(halt, _ltree_root, ctrl);\n+    C->root()->add_req(halt);\n+\n+    _igvn.replace_input_of(inner_head, LoopNode::EntryControl, iftrue);\n+    set_idom(inner_head, iftrue, dom_depth(inner_head));\n+  }\n+}\n+\n+\/\/ Find a safepoint node that dominates the back edge. We need a\n+\/\/ SafePointNode so we can use its jvm state to create empty\n+\/\/ predicates.\n+SafePointNode* PhaseIdealLoop::find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop) {\n+  IfNode* exit_test = back_control->in(0)->as_If();\n+  SafePointNode* safepoint = NULL;\n+  if (exit_test->in(0)->is_SafePoint() && exit_test->in(0)->outcnt() == 1) {\n+    safepoint = exit_test->in(0)->as_SafePoint();\n+  } else {\n+    Node* c = back_control;\n+    while (c != x && c->Opcode() != Op_SafePoint) {\n+      c = idom(c);\n+    }\n+\n+    if (c->Opcode() == Op_SafePoint) {\n+      safepoint = c->as_SafePoint();\n+    }\n+\n+    if (safepoint == NULL) {\n+      return NULL;\n+    }\n+\n+    Node* mem = safepoint->in(TypeFunc::Memory);\n+\n+    \/\/ We can only use that safepoint if there's not side effect\n+    \/\/ between the backedge and the safepoint.\n+\n+#ifdef ASSERT\n+    \/\/ mm is used for book keeping\n+    MergeMemNode* mm = NULL;\n+    if (mem->is_MergeMem()) {\n+      mm = mem->clone()->as_MergeMem();\n+      for (MergeMemStream mms(mem->as_MergeMem()); mms.next_non_empty(); ) {\n+        if (mms.alias_idx() != Compile::AliasIdxBot && loop != get_loop(ctrl_or_self(mms.memory()))) {\n+          mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n+        }\n+      }\n+    }\n+#endif\n+    for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n+      Node* u = x->fast_out(i);\n+      if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+        Node* m = u->in(LoopNode::LoopBackControl);\n+        if (u->adr_type() == TypePtr::BOTTOM) {\n+          if (m->is_MergeMem() && mem->is_MergeMem()) {\n+            if (m != mem DEBUG_ONLY(|| true)) {\n+              for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n+                if (!mms.is_empty()) {\n+                  if (mms.memory() != mms.memory2()) {\n+                    return NULL;\n+                  }\n+#ifdef ASSERT\n+                  if (mms.alias_idx() != Compile::AliasIdxBot) {\n+                    mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n+                  }\n+#endif\n+                }\n+              }\n+            }\n+          } else if (mem->is_MergeMem()) {\n+            if (m != mem->as_MergeMem()->base_memory()) {\n+              return NULL;\n+            }\n+          } else {\n+            return NULL;\n+          }\n+        } else {\n+          if (mem->is_MergeMem()) {\n+            if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n+              return NULL;\n+            }\n+#ifdef ASSERT\n+            mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n+#endif\n+          } else {\n+            if (m != mem) {\n+              return NULL;\n+            }\n+          }\n+        }\n+      }\n+    }\n+#ifdef ASSERT\n+    if (mm != NULL) {\n+      assert (_igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n+      _igvn.remove_dead_node(mm);\n+    }\n+#endif\n+  }\n+  return safepoint;\n+}\n+\n+\/\/ If the loop has the shape of a counted loop but with a long\n+\/\/ induction variable, transform the loop in a loop nest: an inner\n+\/\/ loop that iterates for at most max int iterations with an integer\n+\/\/ induction variable and an outer loop that iterates over the full\n+\/\/ range of long values from the initial loop in (at most) max int\n+\/\/ steps. That is:\n+\/\/\n+\/\/ x: for (long phi = init; phi < limit; phi += stride) {\n+\/\/   \/\/ phi := Phi(L, init, incr)\n+\/\/   \/\/ incr := AddL(phi, longcon(stride))\n+\/\/   \/\/ phi_incr := phi (test happens before increment)\n+\/\/   long incr = phi + stride;\n+\/\/   ... use phi and incr ...\n+\/\/ }\n+\/\/\n+\/\/ OR:\n+\/\/\n+\/\/ x: for (long phi = init; (phi += stride) < limit; ) {\n+\/\/   \/\/ phi := Phi(L, AddL(init, stride), incr)\n+\/\/   \/\/ incr := AddL(phi, longcon(stride))\n+\/\/   \/\/ phi_incr := NULL (test happens after increment)\n+\/\/   long incr = phi + stride;\n+\/\/   ... use phi and (phi + stride) ...\n+\/\/ }\n+\/\/\n+\/\/ ==transform=>\n+\/\/\n+\/\/ const ulong inner_iters_limit = INT_MAX - stride - 1;  \/\/near 0x7FFFFFF0\n+\/\/ assert(stride <= inner_iters_limit);  \/\/ else abort transform\n+\/\/ assert((extralong)limit + stride <= LONG_MAX);  \/\/ else deopt\n+\/\/ outer_head: for (long outer_phi = init;;) {\n+\/\/   \/\/ outer_phi := Phi(outer_head, init, AddL(outer_phi, I2L(inner_phi)))\n+\/\/   ulong inner_iters_max = (ulong) MAX(0, ((extralong)limit + stride - outer_phi));\n+\/\/   long inner_iters_actual = MIN(inner_iters_limit, inner_iters_max);\n+\/\/   assert(inner_iters_actual == (int)inner_iters_actual);\n+\/\/   int inner_phi, inner_incr;\n+\/\/   x: for (inner_phi = 0;; inner_phi = inner_incr) {\n+\/\/     \/\/ inner_phi := Phi(x, intcon(0), inner_incr)\n+\/\/     \/\/ inner_incr := AddI(inner_phi, intcon(stride))\n+\/\/     inner_incr = inner_phi + stride;\n+\/\/     if (inner_incr < inner_iters_actual) {\n+\/\/       ... use phi=>(outer_phi+inner_phi) and incr=>(outer_phi+inner_incr) ...\n+\/\/       continue;\n+\/\/     }\n+\/\/     else break;\n+\/\/   }\n+\/\/   if ((outer_phi+inner_phi) < limit)  \/\/OR (outer_phi+inner_incr) < limit\n+\/\/     continue;\n+\/\/   else break;\n+\/\/ }\n+bool PhaseIdealLoop::is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new) {\n+  \/\/ Only for inner loops\n+  if (loop->_child != NULL) {\n+    return false;\n+  }\n+\n+  \/\/ Checks whether the loop has the shape of a counted loop\n+  Node* back_control = loop_exit_control(x, loop);\n+  if (back_control == NULL) {\n+    return false;\n+  }\n+\n+  BoolTest::mask bt = BoolTest::illegal;\n+  float cl_prob = 0;\n+  Node* incr = NULL;\n+  Node* limit = NULL;\n+\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+  if (cmp == NULL || cmp->Opcode() != Op_CmpL) {\n+    return false; \/\/ Avoid pointer & float & 32-bit compares\n+  }\n+\n+  Node* phi_incr = NULL;\n+  incr = loop_iv_incr(incr, x, loop, phi_incr);\n+  if (incr == NULL || incr->Opcode() != Op_AddL) {\n+    return false;\n+  }\n+\n+  Node* xphi = NULL;\n+  Node* stride = loop_iv_stride(incr, loop, xphi);\n+\n+  if (stride == NULL) {\n+    return false;\n+  }\n+\n+#ifndef PRODUCT\n+  Atomic::inc(&_long_loop_candidates);\n+#endif\n+\n+  jlong stride_con = stride->get_long();\n+  assert(stride_con != 0, \"missed some peephole opt\");\n+  \/\/ We can't iterate for more than max int at a time.\n+  if (stride_con != (jint)stride_con) {\n+    return false;\n+  }\n+  \/\/ The number of iterations for the integer count loop: guarantee no\n+  \/\/ overflow: max_jint - stride_con max. -1 so there's no need for a\n+  \/\/ loop limit check if the exit test is <= or >=.\n+  int iters_limit = max_jint - ABS(stride_con) - 1;\n+#ifdef ASSERT\n+  if (StressLongCountedLoop > 0) {\n+    iters_limit = iters_limit \/ StressLongCountedLoop;\n+  }\n+#endif\n+  \/\/ At least 2 iterations so counted loop construction doesn't fail\n+  if (iters_limit\/ABS(stride_con) < 2) {\n+    return false;\n+  }\n+\n+  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+\n+  if (phi == NULL || phi->in(LoopNode::LoopBackControl) != incr) {\n+    return false;\n+  }\n+\n+  \/\/ Safepoint on backedge not supported\n+  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    return false;\n+  }\n+\n+  \/\/ data nodes on back branch not supported\n+  if (back_control->outcnt() > 1) {\n+    return false;\n+  }\n+\n+  if (!condition_stride_ok(bt, stride_con)) {\n+    return false;\n+  }\n+\n+  \/\/ We'll need to use the loop limit before the inner loop is entered\n+  if (!is_dominator(get_ctrl(limit), x)) {\n+    return false;\n+  }\n+\n+  IfNode* exit_test = back_control->in(0)->as_If();\n+\n+  \/\/ We need a safepoint to insert empty predicates for the inner loop.\n+  SafePointNode* safepoint = find_safepoint(back_control, x, loop);\n+  if (safepoint == NULL) {\n+    \/\/ If exit condition is ne, then a loop limit check is likely needed\n+    if (bt == BoolTest::ne) {\n+      return false;\n+    }\n+  } else if (C->too_many_traps(safepoint->jvms()->method(),\n+                        safepoint->jvms()->bci(),\n+                        Deoptimization::Reason_loop_limit_check)) {\n+    \/\/ We must have transformed the loop already and a loop limit\n+    \/\/ check must have failed.\n+    return false;\n+  }\n+\n+  Node* exit_branch = exit_test->proj_out(back_control->Opcode() == Op_IfFalse);\n+  Node* entry_control = x->in(LoopNode::EntryControl);\n+\n+  \/\/ if the loop exit test is on the IV before it is incremented: i <\n+  \/\/ limit, we transform the exit test so it is performed on the exit\n+  \/\/ test after it is incremented: i + stride < limit + stride.  We\n+  \/\/ need limit + stride to not overflow. See adjusted_limit below.\n+  bool limit_check_required = false;\n+  if (phi_incr != NULL) {\n+    const TypeLong* limit_t = _igvn.type(limit)->is_long();\n+    int sov = check_stride_overflow(stride_con, limit_t);\n+    if (sov != 0) {\n+      if (sov < 0) {\n+        return false;  \/\/ Bailout: integer overflow is certain.\n+      }\n+      \/\/ Check that inserting a predicate is indeed possible\n+      if (find_predicate_insertion_point(x->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check) == NULL) {\n+        return false;\n+      }\n+      limit_check_required = true;\n+    }\n+  }\n+\n+  \/\/ Clone the control flow of the loop to build an outer loop\n+  Node* outer_back_branch = back_control->clone();\n+  Node* outer_exit_test = exit_test->clone();\n+  Node* inner_exit_branch = exit_branch->clone();\n+\n+  Node* outer_head = new LoopNode(entry_control, outer_back_branch);\n+  IdealLoopTree* outer_ilt = insert_outer_loop(loop, outer_head->as_Loop(), outer_back_branch);\n+\n+  const bool body_populated = true;\n+  register_control(outer_head, outer_ilt, entry_control, body_populated);\n+\n+  _igvn.register_new_node_with_optimizer(inner_exit_branch);\n+  set_loop(inner_exit_branch, outer_ilt);\n+  set_idom(inner_exit_branch, exit_test, dom_depth(exit_branch));\n+\n+  outer_exit_test->set_req(0, inner_exit_branch);\n+  register_control(outer_exit_test, outer_ilt, inner_exit_branch, body_populated);\n+\n+  _igvn.replace_input_of(exit_branch, 0, outer_exit_test);\n+  set_idom(exit_branch, outer_exit_test, dom_depth(exit_branch));\n+\n+  outer_back_branch->set_req(0, outer_exit_test);\n+  register_control(outer_back_branch, outer_ilt, outer_exit_test, body_populated);\n+\n+  _igvn.replace_input_of(x, LoopNode::EntryControl, outer_head);\n+  set_idom(x, outer_head, dom_depth(x));\n+\n+  \/\/ add an iv phi to the outer loop and use it to compute the inner\n+  \/\/ loop iteration limit\n+  Node* outer_phi = phi->clone();\n+  outer_phi->set_req(0, outer_head);\n+  register_new_node(outer_phi, outer_head);\n+\n+  Node* adjusted_limit = limit;\n+  if (phi_incr != NULL) {\n+    \/\/ If compare points directly to the phi we need to adjust the\n+    \/\/ compare so that it points to the incr.\n+    Node* long_stride = _igvn.longcon(stride_con);\n+    set_ctrl(long_stride, C->root());\n+    adjusted_limit = new AddLNode(limit, long_stride);\n+    _igvn.register_new_node_with_optimizer(adjusted_limit);\n+  }\n+  Node* inner_iters_max = NULL;\n+  if (stride_con > 0) {\n+    inner_iters_max = MaxNode::max_diff_with_zero(adjusted_limit, outer_phi, TypeLong::LONG, _igvn);\n+  } else {\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, adjusted_limit, TypeLong::LONG, _igvn);\n+  }\n+\n+  Node* inner_iters_limit = _igvn.longcon(iters_limit);\n+  \/\/ inner_iters_max may not fit in a signed integer (iterating from\n+  \/\/ Long.MIN_VALUE to Long.MAX_VALUE for instance). Use an unsigned\n+  \/\/ min.\n+  Node* inner_iters_actual = MaxNode::unsigned_min(inner_iters_max, inner_iters_limit, TypeLong::make(0, iters_limit, Type::WidenMin), _igvn);\n+\n+  Node* inner_iters_actual_int = new ConvL2INode(inner_iters_actual);\n+  _igvn.register_new_node_with_optimizer(inner_iters_actual_int);\n+\n+  Node* zero = _igvn.intcon(0);\n+  set_ctrl(zero, C->root());\n+  if (stride_con < 0) {\n+    inner_iters_actual_int = new SubINode(zero, inner_iters_actual_int);\n+    _igvn.register_new_node_with_optimizer(inner_iters_actual_int);\n+  }\n+\n+  \/\/ Clone the iv data nodes as an integer iv\n+  Node* int_stride = _igvn.intcon((int)stride_con);\n+  set_ctrl(int_stride, C->root());\n+  Node* inner_phi = new PhiNode(x->in(0), TypeInt::INT);\n+  Node* inner_incr = new AddINode(inner_phi, int_stride);\n+  Node* inner_cmp = NULL;\n+  if (cmp->in(1) == incr || cmp->in(1) == phi) {\n+    inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n+  }  else {\n+    assert(cmp->in(2) == incr || cmp->in(2) == phi, \"bad iv shape\");\n+    inner_cmp = new CmpINode(inner_iters_actual_int, inner_incr);\n+  }\n+  Node* inner_bol = new BoolNode(inner_cmp, exit_test->in(1)->as_Bool()->_test._test);\n+  inner_phi->set_req(LoopNode::EntryControl, zero);\n+  inner_phi->set_req(LoopNode::LoopBackControl, inner_incr);\n+  register_new_node(inner_phi, x);\n+  register_new_node(inner_incr, x);\n+  register_new_node(inner_cmp, x);\n+  register_new_node(inner_bol, x);\n+\n+  _igvn.replace_input_of(exit_test, 1, inner_bol);\n+\n+  \/\/ Add a predicate to guarantee limit adjustment doesn't overflow\n+  if (limit_check_required) {\n+    assert(phi_incr != NULL, \"only when exit test must be transformed\");\n+    ProjNode *limit_check_proj = find_predicate_insertion_point(outer_head->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check);\n+    assert(limit_check_proj != NULL, \"was tested before\");\n+    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n+    Node* cmp_limit;\n+    Node* bol;\n+\n+    if (stride_con > 0) {\n+      cmp_limit = new CmpLNode(limit, _igvn.longcon(max_jlong - stride_con));\n+      bol = new BoolNode(cmp_limit, BoolTest::le);\n+    } else {\n+      cmp_limit = new CmpLNode(limit, _igvn.longcon(min_jlong - stride_con));\n+      bol = new BoolNode(cmp_limit, BoolTest::ge);\n+    }\n+\n+    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+    Node* new_predicate = limit_check_proj->in(0)->in(0);\n+    Node* above_predicate = new_predicate->in(0)->in(0);\n+    Node* entry = outer_head->in(LoopNode::EntryControl);\n+    _igvn.replace_input_of(limit_check_proj->in(0), 0, above_predicate);\n+    _igvn.replace_input_of(new_predicate->in(0), 0, entry);\n+    _igvn.replace_input_of(outer_head, LoopNode::EntryControl, new_predicate);\n+    set_idom(new_predicate->in(0), entry, dom_depth(entry));\n+    set_idom(new_predicate, new_predicate->in(0), dom_depth(entry));\n+    Node* region = new_predicate->in(0)->as_If()->proj_out(new_predicate->Opcode() == Op_IfFalse)->unique_ctrl_out();\n+    assert(region->is_Region(), \"should be region merging predicates\");\n+    set_idom(region, entry, dom_depth(entry));\n+    set_idom(limit_check_proj->in(0), above_predicate, dom_depth(above_predicate));\n+  }\n+\n+  LoopNode* inner_head = x->as_Loop();\n+\n+  \/\/ Clone inner loop phis to outer loop\n+  for (uint i = 0; i < inner_head->outcnt(); i++) {\n+    Node* u = inner_head->raw_out(i);\n+    if (u->is_Phi() && u != inner_phi && u != phi) {\n+      assert(u->in(0) == inner_head, \"inconsistent\");\n+      Node* clone = u->clone();\n+      clone->set_req(0, outer_head);\n+      register_new_node(clone, outer_head);\n+      _igvn.replace_input_of(u, LoopNode::EntryControl, clone);\n+    }\n+  }\n+\n+  \/\/ Replace inner loop long iv phi as inner loop int iv phi + outer\n+  \/\/ loop iv phi\n+  long_loop_replace_long_iv(phi, inner_phi, outer_phi, inner_head);\n+\n+  \/\/ Replace inner loop long iv incr with inner loop int incr + outer\n+  \/\/ loop iv phi\n+  long_loop_replace_long_iv(incr, inner_incr, outer_phi, inner_head);\n+\n+  set_subtree_ctrl(inner_iters_actual_int);\n+\n+  \/\/ Summary of steps from inital loop to loop nest:\n+  \/\/\n+  \/\/ == old IR nodes =>\n+  \/\/\n+  \/\/ entry_control: {...}\n+  \/\/ x:\n+  \/\/ for (long phi = init;;) {\n+  \/\/   \/\/ phi := Phi(x, init, incr)\n+  \/\/   \/\/ incr := AddL(phi, longcon(stride))\n+  \/\/   exit_test:\n+  \/\/   if (phi < limit)\n+  \/\/     back_control: fallthrough;\n+  \/\/   else\n+  \/\/     exit_branch: break;\n+  \/\/   \/\/ test happens before increment => phi == phi_incr != NULL\n+  \/\/   long incr = phi + stride;\n+  \/\/   ... use phi and incr ...\n+  \/\/   phi = incr;\n+  \/\/ }\n+  \/\/\n+  \/\/ == new IR nodes (just before final peel) =>\n+  \/\/\n+  \/\/ entry_control: {...}\n+  \/\/ long adjusted_limit = limit + stride;  \/\/because phi_incr != NULL\n+  \/\/ assert(!limit_check_required || (extralong)limit + stride == adjusted_limit);  \/\/ else deopt\n+  \/\/ ulong inner_iters_limit = max_jint - ABS(stride) - 1;  \/\/near 0x7FFFFFF0\n+  \/\/ outer_head:\n+  \/\/ for (long outer_phi = init;;) {\n+  \/\/   \/\/ outer_phi := phi->clone(), in(0):=outer_head, => Phi(outer_head, init, incr)\n+  \/\/   \/\/ REPLACE phi  => AddL(outer_phi, I2L(inner_phi))\n+  \/\/   \/\/ REPLACE incr => AddL(outer_phi, I2L(inner_incr))\n+  \/\/   \/\/ SO THAT outer_phi := Phi(outer_head, init, AddL(outer_phi, I2L(inner_incr)))\n+  \/\/   ulong inner_iters_max = (ulong) MAX(0, ((extralong)adjusted_limit - outer_phi) * SGN(stride));\n+  \/\/   int inner_iters_actual_int = (int) MIN(inner_iters_limit, inner_iters_max) * SGN(stride);\n+  \/\/   inner_head: x: \/\/in(1) := outer_head\n+  \/\/   int inner_phi;\n+  \/\/   for (inner_phi = 0;;) {\n+  \/\/     \/\/ inner_phi := Phi(x, intcon(0), inner_phi + stride)\n+  \/\/     int inner_incr = inner_phi + stride;\n+  \/\/     bool inner_bol = (inner_incr < inner_iters_actual_int);\n+  \/\/     exit_test: \/\/exit_test->in(1) := inner_bol;\n+  \/\/     if (inner_bol) \/\/ WAS (phi < limit)\n+  \/\/       back_control: fallthrough;\n+  \/\/     else\n+  \/\/       inner_exit_branch: break;  \/\/exit_branch->clone()\n+  \/\/     ... use phi=>(outer_phi+inner_phi) and incr=>(outer_phi+inner_incr) ...\n+  \/\/     inner_phi = inner_phi + stride;  \/\/ inner_incr\n+  \/\/   }\n+  \/\/   outer_exit_test:  \/\/exit_test->clone(), in(0):=inner_exit_branch\n+  \/\/   if ((outer_phi+inner_phi) < limit)  \/\/ WAS (phi < limit)\n+  \/\/     outer_back_branch: fallthrough;  \/\/back_control->clone(), in(0):=outer_exit_test\n+  \/\/   else\n+  \/\/     exit_branch: break;  \/\/in(0) := outer_exit_test\n+  \/\/ }\n+\n+  \/\/ Peel one iteration of the loop and use the safepoint at the end\n+  \/\/ of the peeled iteration to insert empty predicates. If no well\n+  \/\/ positioned safepoint peel to guarantee a safepoint in the outer\n+  \/\/ loop.\n+  if (safepoint != NULL || !loop->_has_call) {\n+    old_new.clear();\n+    do_peeling(loop, old_new);\n+  }\n+\n+  if (safepoint != NULL) {\n+    SafePointNode* cloned_sfpt = old_new[safepoint->_idx]->as_SafePoint();\n+\n+    if (UseLoopPredicate) {\n+      add_empty_predicate(Deoptimization::Reason_predicate, inner_head, outer_ilt, cloned_sfpt);\n+    }\n+    if (UseProfiledLoopPredicate) {\n+      add_empty_predicate(Deoptimization::Reason_profile_predicate, inner_head, outer_ilt, cloned_sfpt);\n+    }\n+    add_empty_predicate(Deoptimization::Reason_loop_limit_check, inner_head, outer_ilt, cloned_sfpt);\n+  }\n+\n+#ifndef PRODUCT\n+  Atomic::inc(&_long_loop_nests);\n+#endif\n+\n+  inner_head->mark_transformed_long_loop();\n+\n+  return true;\n+}\n+\n+#ifdef ASSERT\n+\/\/ convert an int counted loop to a long counted to stress handling of\n+\/\/ long counted loops\n+bool PhaseIdealLoop::convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop) {\n+  Unique_Node_List iv_nodes;\n+  Node_List old_new;\n+  iv_nodes.push(cmp);\n+  bool failed = false;\n+\n+  for (uint i = 0; i < iv_nodes.size() && !failed; i++) {\n+    Node* n = iv_nodes.at(i);\n+    switch(n->Opcode()) {\n+      case Op_Phi: {\n+        Node* clone = new PhiNode(n->in(0), TypeLong::LONG);\n+        old_new.map(n->_idx, clone);\n+        break;\n+      }\n+      case Op_CmpI: {\n+        Node* clone = new CmpLNode(NULL, NULL);\n+        old_new.map(n->_idx, clone);\n+        break;\n+      }\n+      case Op_AddI: {\n+        Node* clone = new AddLNode(NULL, NULL);\n+        old_new.map(n->_idx, clone);\n+        break;\n+      }\n+      case Op_CastII: {\n+        failed = true;\n+        break;\n+      }\n+      default:\n+        DEBUG_ONLY(n->dump());\n+        fatal(\"unexpected\");\n+    }\n+\n+    for (uint i = 1; i < n->req(); i++) {\n+      Node* in = n->in(i);\n+      if (in == NULL) {\n+        continue;\n+      }\n+      if (loop->is_member(get_loop(get_ctrl(in)))) {\n+        iv_nodes.push(in);\n+      }\n+    }\n+  }\n+\n+  if (failed) {\n+    for (uint i = 0; i < iv_nodes.size(); i++) {\n+      Node* n = iv_nodes.at(i);\n+      Node* clone = old_new[n->_idx];\n+      if (clone != NULL) {\n+        _igvn.remove_dead_node(clone);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  for (uint i = 0; i < iv_nodes.size(); i++) {\n+    Node* n = iv_nodes.at(i);\n+    Node* clone = old_new[n->_idx];\n+    for (uint i = 1; i < n->req(); i++) {\n+      Node* in = n->in(i);\n+      if (in == NULL) {\n+        continue;\n+      }\n+      Node* in_clone = old_new[in->_idx];\n+      if (in_clone == NULL) {\n+        assert(_igvn.type(in)->isa_int(), \"\");\n+        in_clone = new ConvI2LNode(in);\n+        _igvn.register_new_node_with_optimizer(in_clone);\n+        set_subtree_ctrl(in_clone);\n+      }\n+      if (in_clone->in(0) == NULL) {\n+        in_clone->set_req(0, C->top());\n+        clone->set_req(i, in_clone);\n+        in_clone->set_req(0, NULL);\n+      } else {\n+        clone->set_req(i, in_clone);\n+      }\n+    }\n+    _igvn.register_new_node_with_optimizer(clone);\n+  }\n+  set_ctrl(old_new[phi->_idx], phi->in(0));\n+\n+  for (uint i = 0; i < iv_nodes.size(); i++) {\n+    Node* n = iv_nodes.at(i);\n+    Node* clone = old_new[n->_idx];\n+    set_subtree_ctrl(clone);\n+    Node* m = n->Opcode() == Op_CmpI ? clone : NULL;\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* u = n->fast_out(i);\n+      if (iv_nodes.member(u)) {\n+        continue;\n+      }\n+      if (m == NULL) {\n+        m = new ConvL2INode(clone);\n+        _igvn.register_new_node_with_optimizer(m);\n+        set_subtree_ctrl(m);\n+      }\n+      _igvn.rehash_node_delayed(u);\n+      int nb = u->replace_edge(n, m);\n+      --i, imax -= nb;\n+    }\n+  }\n+  return true;\n+}\n+#endif\n+\n@@ -517,1 +1243,0 @@\n-\n@@ -643,10 +1368,2 @@\n-  \/\/ If the condition is inverted and we will be rolling\n-  \/\/ through MININT to MAXINT, then bail out.\n-  if (bt == BoolTest::eq || \/\/ Bail out, but this loop trips at most twice!\n-      \/\/ Odd stride\n-      (bt == BoolTest::ne && stride_con != 1 && stride_con != -1) ||\n-      \/\/ Count down loop rolls through MAXINT\n-      ((bt == BoolTest::le || bt == BoolTest::lt) && stride_con < 0) ||\n-      \/\/ Count up loop rolls through MININT\n-      ((bt == BoolTest::ge || bt == BoolTest::gt) && stride_con > 0)) {\n-    return false; \/\/ Bail out\n+  if (!condition_stride_ok(bt, stride_con)) {\n+    return false;\n@@ -725,0 +1442,1 @@\n+    assert(!x->as_Loop()->is_transformed_long_loop(), \"long loop was transformed\");\n@@ -812,0 +1530,6 @@\n+#ifdef ASSERT\n+  if (!x->as_Loop()->is_transformed_long_loop() && StressLongCountedLoop > 0 && trunc1 == NULL && convert_to_long_loop(cmp, phi, loop)) {\n+    return false;\n+  }\n+#endif\n+\n@@ -998,0 +1722,6 @@\n+#ifndef PRODUCT\n+  if (x->as_Loop()->is_transformed_long_loop()) {\n+    Atomic::inc(&_long_loop_counted_loops);\n+  }\n+#endif\n+\n@@ -2556,1 +3286,3 @@\n-  } else if (_parent != NULL && !_irreducible) {\n+  } else {\n+    assert(!_head->is_Loop() || !_head->as_Loop()->is_transformed_long_loop(), \"transformation to counted loop should not fail\");\n+    if (_parent != NULL && !_irreducible) {\n@@ -2561,0 +3293,1 @@\n+  }\n@@ -3173,1 +3906,6 @@\n-  if (ReassociateInvariants) {\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    is_long_counted_loop(lpt->_head, lpt, worklist);\n+  }\n+\n+  if (ReassociateInvariants && !C->major_progress()) {\n@@ -3201,1 +3939,1 @@\n-  if( SplitIfBlocks && do_split_ifs ) {\n+  if (!C->major_progress() && SplitIfBlocks && do_split_ifs) {\n@@ -3319,0 +4057,3 @@\n+volatile int PhaseIdealLoop::_long_loop_candidates=0; \/\/ Number of long loops seen\n+volatile int PhaseIdealLoop::_long_loop_nests=0; \/\/ Number of long loops successfully transformed to a nest\n+volatile int PhaseIdealLoop::_long_loop_counted_loops=0; \/\/ Number of long loops successfully transformed to a counted loop\n@@ -3320,1 +4061,1 @@\n-  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d\", _loop_invokes, _loop_work);\n+  tty->print_cr(\"PhaseIdealLoop=%d, sum _unique=%d, long loops=%d\/%d\/%d\", _loop_invokes, _loop_work, _long_loop_counted_loops, _long_loop_nests, _long_loop_candidates);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":756,"deletions":15,"binary":false,"changes":771,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-         ProfileTripFailed=131072};\n+         ProfileTripFailed=131072,\n+         TransformedLongLoop=262144};\n@@ -104,0 +105,1 @@\n+  bool is_transformed_long_loop() const { return _loop_flags & TransformedLongLoop; }\n@@ -118,0 +120,1 @@\n+  void mark_transformed_long_loop() { _loop_flags |= TransformedLongLoop; }\n@@ -1047,0 +1050,7 @@\n+  void long_loop_replace_long_iv(Node* iv_to_replace, Node* inner_iv, Node* outer_phi, Node* inner_head);\n+  bool is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new);\n+#ifdef ASSERT\n+  bool convert_to_long_loop(Node* cmp, Node* phi, IdealLoopTree* loop);\n+#endif\n+  void add_empty_predicate(Deoptimization::DeoptReason reason, Node* inner_head, IdealLoopTree* loop, SafePointNode* sfpt);\n+  SafePointNode* find_safepoint(Node* back_control, Node* x, IdealLoopTree* loop);\n@@ -1471,0 +1481,3 @@\n+  static volatile int _long_loop_candidates;\n+  static volatile int _long_loop_nests;\n+  static volatile int _long_loop_counted_loops;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1041,1 +1041,3 @@\n-  if( n_blk->is_CountedLoop() && n->Opcode() == Op_AddI ) return n;\n+  if ((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) {\n+    return n;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,38 +97,0 @@\n-void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {\n-  \/\/ Copy debug information and adjust JVMState information\n-  uint old_dbg_start = oldcall->tf()->domain()->cnt();\n-  uint new_dbg_start = newcall->tf()->domain()->cnt();\n-  int jvms_adj  = new_dbg_start - old_dbg_start;\n-  assert (new_dbg_start == newcall->req(), \"argument count mismatch\");\n-\n-  \/\/ SafePointScalarObject node could be referenced several times in debug info.\n-  \/\/ Use Dict to record cloned nodes.\n-  Dict* sosn_map = new Dict(cmpkey,hashkey);\n-  for (uint i = old_dbg_start; i < oldcall->req(); i++) {\n-    Node* old_in = oldcall->in(i);\n-    \/\/ Clone old SafePointScalarObjectNodes, adjusting their field contents.\n-    if (old_in != NULL && old_in->is_SafePointScalarObject()) {\n-      SafePointScalarObjectNode* old_sosn = old_in->as_SafePointScalarObject();\n-      uint old_unique = C->unique();\n-      Node* new_in = old_sosn->clone(sosn_map);\n-      if (old_unique != C->unique()) { \/\/ New node?\n-        new_in->set_req(0, C->root()); \/\/ reset control edge\n-        new_in = transform_later(new_in); \/\/ Register new node.\n-      }\n-      old_in = new_in;\n-    }\n-    newcall->add_req(old_in);\n-  }\n-\n-  \/\/ JVMS may be shared so clone it before we modify it\n-  newcall->set_jvms(oldcall->jvms() != NULL ? oldcall->jvms()->clone_deep(C) : NULL);\n-  for (JVMState *jvms = newcall->jvms(); jvms != NULL; jvms = jvms->caller()) {\n-    jvms->set_map(newcall);\n-    jvms->set_locoff(jvms->locoff()+jvms_adj);\n-    jvms->set_stkoff(jvms->stkoff()+jvms_adj);\n-    jvms->set_monoff(jvms->monoff()+jvms_adj);\n-    jvms->set_scloff(jvms->scloff()+jvms_adj);\n-    jvms->set_endoff(jvms->endoff()+jvms_adj);\n-  }\n-}\n-\n@@ -187,1 +149,1 @@\n-  copy_call_debug_info(oldcall, call);\n+  call->copy_call_debug_info(&_igvn, oldcall);\n@@ -1476,1 +1438,1 @@\n-  copy_call_debug_info((CallNode *) alloc,  call);\n+  call->copy_call_debug_info(&_igvn, alloc);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-  copy_call_debug_info(ac, call);\n+  call->copy_call_debug_info(&_igvn, ac);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2251,3 +2251,0 @@\n-  \/\/ See if we can avoid this safepoint.  No need for a SafePoint immediately\n-  \/\/ after a Call (except Leaf Call) or another SafePoint.\n-  Node *proj = control();\n@@ -2255,13 +2252,0 @@\n-  if( proj->is_Proj() ) {\n-    Node *n0 = proj->in(0);\n-    if( n0->is_Catch() ) {\n-      n0 = n0->in(0)->in(0);\n-      assert( n0->is_Call(), \"expect a call here\" );\n-    }\n-    if( n0->is_Call() ) {\n-      if( n0->as_Call()->guaranteed_safepoint() )\n-        return;\n-    } else if( n0->is_SafePoint() && n0->req() >= parms ) {\n-      return;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}