{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+\n@@ -30,1 +34,1 @@\n- * using big-endian byte ordering.\n+ * using big-endian byte ordering (i.e. \"Network Order\").\n@@ -32,1 +36,8 @@\n-class Bits {\n+final class Bits {\n+    private Bits() {}\n+\n+    private static final VarHandle SHORT = create(short[].class);\n+    private static final VarHandle INT = create(int[].class);\n+    private static final VarHandle LONG = create(long[].class);\n+    private static final VarHandle FLOAT = create(float[].class);\n+    private static final VarHandle DOUBLE = create(double[].class);\n@@ -44,2 +55,1 @@\n-        return (char) ((b[off + 1] & 0xFF) +\n-                       (b[off] << 8));\n+        return (char) (short) SHORT.get(b, off);\n@@ -49,2 +59,1 @@\n-        return (short) ((b[off + 1] & 0xFF) +\n-                        (b[off] << 8));\n+        return (short) SHORT.get(b, off);\n@@ -54,4 +63,1 @@\n-        return ((b[off + 3] & 0xFF)      ) +\n-               ((b[off + 2] & 0xFF) <<  8) +\n-               ((b[off + 1] & 0xFF) << 16) +\n-               ((b[off    ]       ) << 24);\n+        return (int) INT.get(b, off);\n@@ -61,1 +67,1 @@\n-        return Float.intBitsToFloat(getInt(b, off));\n+        return (float) FLOAT.get(b, off);\n@@ -65,8 +71,1 @@\n-        return ((b[off + 7] & 0xFFL)      ) +\n-               ((b[off + 6] & 0xFFL) <<  8) +\n-               ((b[off + 5] & 0xFFL) << 16) +\n-               ((b[off + 4] & 0xFFL) << 24) +\n-               ((b[off + 3] & 0xFFL) << 32) +\n-               ((b[off + 2] & 0xFFL) << 40) +\n-               ((b[off + 1] & 0xFFL) << 48) +\n-               (((long) b[off])      << 56);\n+        return (long) LONG.get(b, off);\n@@ -76,1 +75,1 @@\n-        return Double.longBitsToDouble(getLong(b, off));\n+        return (double) DOUBLE.get(b, off);\n@@ -89,2 +88,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, (short) val);\n@@ -94,2 +92,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, val);\n@@ -99,4 +96,1 @@\n-        b[off + 3] = (byte) (val       );\n-        b[off + 2] = (byte) (val >>>  8);\n-        b[off + 1] = (byte) (val >>> 16);\n-        b[off    ] = (byte) (val >>> 24);\n+        INT.set(b, off, val);\n@@ -106,1 +100,1 @@\n-        putInt(b, off,  Float.floatToIntBits(val));\n+        FLOAT.set(b, off, val);\n@@ -110,8 +104,1 @@\n-        b[off + 7] = (byte) (val       );\n-        b[off + 6] = (byte) (val >>>  8);\n-        b[off + 5] = (byte) (val >>> 16);\n-        b[off + 4] = (byte) (val >>> 24);\n-        b[off + 3] = (byte) (val >>> 32);\n-        b[off + 2] = (byte) (val >>> 40);\n-        b[off + 1] = (byte) (val >>> 48);\n-        b[off    ] = (byte) (val >>> 56);\n+        LONG.set(b, off, val);\n@@ -121,1 +108,5 @@\n-        putLong(b, off, Double.doubleToLongBits(val));\n+        DOUBLE.set(b, off, val);\n+    }\n+\n+    private static VarHandle create(Class<?> viewArrayClass) {\n+        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Bits.java","additions":30,"deletions":39,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,409 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @run junit\/othervm --add-opens java.base\/java.io=ALL-UNNAMED ReadWriteValues\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+\n+import org.junit.jupiter.api.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ReadWriteValues {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            putShort(BUFF, OFFSET, expected);\n+            short actual = BitsProxy.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            BitsProxy.putShort(BUFF, OFFSET, expected);\n+            short actual = getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            putChar(BUFF, OFFSET, expected);\n+            char actual = BitsProxy.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            BitsProxy.putChar(BUFF, OFFSET, expected);\n+            char actual = getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            putInt(BUFF, OFFSET, expected);\n+            int actual = BitsProxy.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            BitsProxy.putInt(BUFF, OFFSET, expected);\n+            int actual = getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            putLong(BUFF, OFFSET, expected);\n+            long actual = BitsProxy.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            BitsProxy.putLong(BUFF, OFFSET, expected);\n+            long actual = getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        doubles().forEach(d -> {\n+            float expected = (float) d;\n+            putFloat(BUFF, OFFSET, expected);\n+            float actual = BitsProxy.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        doubles().forEach(d -> {\n+            float expected = (float) d;\n+            BitsProxy.putFloat(BUFF, OFFSET, expected);\n+            float actual = getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            putDouble(BUFF, OFFSET, expected);\n+            double actual = BitsProxy.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            BitsProxy.putDouble(BUFF, OFFSET, expected);\n+            double actual = getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> method(\"getInt\").invoke(null, null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> method(\"putInt\", int.class).invoke(null, BUFF, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> method(\"getInt\").invoke(null, BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> method(\"putInt\", int.class).invoke(null, BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> method(\"getInt\").invoke(null, BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> method(\"putInt\", int.class).invoke(null, BUFF, BUFF.length, 1));\n+    }\n+\n+    static Method method(String name) {\n+        try {\n+            Class<?> bits = Class.forName(\"java.io.Bits\");\n+            Method method = bits.getDeclaredMethod(name, byte[].class, int.class);\n+            method.setAccessible(true);\n+            return method;\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    static Method method(String name,\n+                         Class<?> primitiveType) {\n+        try {\n+            Class<?> bits = Class.forName(\"java.io.Bits\");\n+            Method method = bits.getDeclaredMethod(name, byte[].class, int.class, primitiveType);\n+            method.setAccessible(true);\n+            return method;\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return ThreadLocalRandom.current().doubles(ITERATIONS);\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/\/ Wrapper methods to test package private methods\n+\n+    private static final class BitsProxy {\n+\n+        private BitsProxy() {\n+        }\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) invoke(\"getChar\", b, off);\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) invoke(\"getShort\", b, off);\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return (int) invoke(\"getInt\", b, off);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return (float) invoke(\"getFloat\", b, off);\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return (long) invoke(\"getLong\", b, off);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return (double) invoke(\"getDouble\", b, off);\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            try {\n+                method(\"putChar\", char.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            try {\n+                method(\"putShort\", short.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            try {\n+                method(\"putInt\", int.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            try {\n+                method(\"putFloat\", float.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            try {\n+                method(\"putLong\", long.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            try {\n+                method(\"putDouble\", double.class).invoke(null, b, off, val);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static Object invoke(String name, byte[] b, int off) {\n+            try {\n+                return method(name).invoke(null, b, off);\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ Equivalent methods from the old java.io.Bits implementation\n+\n+    static char getChar(byte[] b, int off) {\n+        return (char) ((b[off + 1] & 0xFF) +\n+                (b[off] << 8));\n+    }\n+\n+    static short getShort(byte[] b, int off) {\n+        return (short) ((b[off + 1] & 0xFF) +\n+                (b[off] << 8));\n+    }\n+\n+    static int getInt(byte[] b, int off) {\n+        return ((b[off + 3] & 0xFF)) +\n+                ((b[off + 2] & 0xFF) << 8) +\n+                ((b[off + 1] & 0xFF) << 16) +\n+                ((b[off]) << 24);\n+    }\n+\n+    static float getFloat(byte[] b, int off) {\n+        return Float.intBitsToFloat(getInt(b, off));\n+    }\n+\n+    static long getLong(byte[] b, int off) {\n+        return ((b[off + 7] & 0xFFL)) +\n+                ((b[off + 6] & 0xFFL) << 8) +\n+                ((b[off + 5] & 0xFFL) << 16) +\n+                ((b[off + 4] & 0xFFL) << 24) +\n+                ((b[off + 3] & 0xFFL) << 32) +\n+                ((b[off + 2] & 0xFFL) << 40) +\n+                ((b[off + 1] & 0xFFL) << 48) +\n+                (((long) b[off]) << 56);\n+    }\n+\n+    static double getDouble(byte[] b, int off) {\n+        return Double.longBitsToDouble(getLong(b, off));\n+    }\n+\n+    \/*\n+     * Methods for packing primitive values into byte arrays starting at given\n+     * offsets.\n+     *\/\n+\n+    static void putChar(byte[] b, int off, char val) {\n+        b[off + 1] = (byte) (val);\n+        b[off] = (byte) (val >>> 8);\n+    }\n+\n+    static void putShort(byte[] b, int off, short val) {\n+        b[off + 1] = (byte) (val);\n+        b[off] = (byte) (val >>> 8);\n+    }\n+\n+    static void putInt(byte[] b, int off, int val) {\n+        b[off + 3] = (byte) (val);\n+        b[off + 2] = (byte) (val >>> 8);\n+        b[off + 1] = (byte) (val >>> 16);\n+        b[off] = (byte) (val >>> 24);\n+    }\n+\n+    static void putFloat(byte[] b, int off, float val) {\n+        putInt(b, off, Float.floatToIntBits(val));\n+    }\n+\n+    static void putLong(byte[] b, int off, long val) {\n+        b[off + 7] = (byte) (val);\n+        b[off + 6] = (byte) (val >>> 8);\n+        b[off + 5] = (byte) (val >>> 16);\n+        b[off + 4] = (byte) (val >>> 24);\n+        b[off + 3] = (byte) (val >>> 32);\n+        b[off + 2] = (byte) (val >>> 40);\n+        b[off + 1] = (byte) (val >>> 48);\n+        b[off] = (byte) (val >>> 56);\n+    }\n+\n+    static void putDouble(byte[] b, int off, double val) {\n+        putLong(b, off, Double.doubleToLongBits(val));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Bits\/ReadWriteValues.java","additions":409,"deletions":0,"binary":false,"changes":409,"status":"added"}]}