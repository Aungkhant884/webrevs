{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+\n@@ -30,1 +34,1 @@\n- * using big-endian byte ordering.\n+ * using big-endian byte ordering (i.e. \"Network Order\").\n@@ -32,1 +36,6 @@\n-class Bits {\n+final class Bits {\n+    private Bits() {}\n+\n+    private static final VarHandle SHORT = create(short[].class);\n+    private static final VarHandle INT = create(int[].class);\n+    private static final VarHandle LONG = create(long[].class);\n@@ -44,2 +53,1 @@\n-        return (char) ((b[off + 1] & 0xFF) +\n-                       (b[off] << 8));\n+        return (char) (short) SHORT.get(b, off);\n@@ -49,2 +57,1 @@\n-        return (short) ((b[off + 1] & 0xFF) +\n-                        (b[off] << 8));\n+        return (short) SHORT.get(b, off);\n@@ -54,4 +61,1 @@\n-        return ((b[off + 3] & 0xFF)      ) +\n-               ((b[off + 2] & 0xFF) <<  8) +\n-               ((b[off + 1] & 0xFF) << 16) +\n-               ((b[off    ]       ) << 24);\n+        return (int) INT.get(b, off);\n@@ -61,1 +65,3 @@\n-        return Float.intBitsToFloat(getInt(b, off));\n+        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat((int) INT.get(b, off));\n@@ -65,8 +71,1 @@\n-        return ((b[off + 7] & 0xFFL)      ) +\n-               ((b[off + 6] & 0xFFL) <<  8) +\n-               ((b[off + 5] & 0xFFL) << 16) +\n-               ((b[off + 4] & 0xFFL) << 24) +\n-               ((b[off + 3] & 0xFFL) << 32) +\n-               ((b[off + 2] & 0xFFL) << 40) +\n-               ((b[off + 1] & 0xFFL) << 48) +\n-               (((long) b[off])      << 56);\n+        return (long) LONG.get(b, off);\n@@ -76,1 +75,3 @@\n-        return Double.longBitsToDouble(getLong(b, off));\n+        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Double.longBitsToDouble((long) LONG.get(b, off));\n@@ -89,2 +90,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, (short) val);\n@@ -94,2 +94,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, val);\n@@ -99,4 +98,1 @@\n-        b[off + 3] = (byte) (val       );\n-        b[off + 2] = (byte) (val >>>  8);\n-        b[off + 1] = (byte) (val >>> 16);\n-        b[off    ] = (byte) (val >>> 24);\n+        INT.set(b, off, val);\n@@ -106,1 +102,3 @@\n-        putInt(b, off,  Float.floatToIntBits(val));\n+        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        INT.set(b, off, Float.floatToIntBits(val));\n@@ -110,8 +108,1 @@\n-        b[off + 7] = (byte) (val       );\n-        b[off + 6] = (byte) (val >>>  8);\n-        b[off + 5] = (byte) (val >>> 16);\n-        b[off + 4] = (byte) (val >>> 24);\n-        b[off + 3] = (byte) (val >>> 32);\n-        b[off + 2] = (byte) (val >>> 40);\n-        b[off + 1] = (byte) (val >>> 48);\n-        b[off    ] = (byte) (val >>> 56);\n+        LONG.set(b, off, val);\n@@ -121,1 +112,7 @@\n-        putLong(b, off, Double.doubleToLongBits(val));\n+        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        LONG.set(b, off, Double.doubleToLongBits(val));\n+    }\n+\n+    private static VarHandle create(Class<?> viewArrayClass) {\n+        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Bits.java","additions":36,"deletions":39,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @compile\/module=java.base java\/io\/BitsProxy.java\n+ * @run junit\/othervm --add-opens java.base\/java.io=ALL-UNNAMED ReadWriteValues\n+ *\/\n+\n+import java.io.BitsProxy;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ReadWriteValues {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, OFFSET, expected);\n+            short actual = BitsProxy.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            BitsProxy.putShort(BUFF, OFFSET, expected);\n+            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, OFFSET, expected);\n+            char actual = BitsProxy.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            BitsProxy.putChar(BUFF, OFFSET, expected);\n+            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, OFFSET, expected);\n+            int actual = BitsProxy.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            BitsProxy.putInt(BUFF, OFFSET, expected);\n+            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, OFFSET, expected);\n+            long actual = BitsProxy.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            BitsProxy.putLong(BUFF, OFFSET, expected);\n+            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, OFFSET, expected);\n+            float actual = BitsProxy.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        floats().forEach(expected -> {\n+            BitsProxy.putFloat(BUFF, OFFSET, expected);\n+            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, OFFSET, expected);\n+            double actual = BitsProxy.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            BitsProxy.putDouble(BUFF, OFFSET, expected);\n+            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.putInt(null, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, BUFF.length, 1));\n+    }\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return DoubleStream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS),\n+                DoubleStream.of(Double.NaN,\n+                        Double.NEGATIVE_INFINITY,\n+                        Double.POSITIVE_INFINITY,\n+                        Double.MAX_VALUE,\n+                        Double.MIN_VALUE,\n+                        -0.0d\n+                        +0.0d)\n+        );\n+    }\n+    static Stream<Float> floats() {\n+        return Stream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n+                Stream.of(Float.NaN,\n+                        Float.NEGATIVE_INFINITY,\n+                        Float.POSITIVE_INFINITY,\n+                        Float.MAX_VALUE,\n+                        Float.MIN_VALUE,\n+                        -0.0f\n+                        +0.0f)\n+        );\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/**\n+    * Reference implementation from the old java.io.Bits implementation\n+    *\/\n+    private static final class RefImpl {\n+        private RefImpl() {}\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return ((b[off + 3] & 0xFF)) +\n+                    ((b[off + 2] & 0xFF) << 8) +\n+                    ((b[off + 1] & 0xFF) << 16) +\n+                    ((b[off]) << 24);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return ((b[off + 7] & 0xFFL)) +\n+                    ((b[off + 6] & 0xFFL) << 8) +\n+                    ((b[off + 5] & 0xFFL) << 16) +\n+                    ((b[off + 4] & 0xFFL) << 24) +\n+                    ((b[off + 3] & 0xFFL) << 32) +\n+                    ((b[off + 2] & 0xFFL) << 40) +\n+                    ((b[off + 1] & 0xFFL) << 48) +\n+                    (((long) b[off]) << 56);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            b[off + 3] = (byte) (val);\n+            b[off + 2] = (byte) (val >>> 8);\n+            b[off + 1] = (byte) (val >>> 16);\n+            b[off] = (byte) (val >>> 24);\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            putInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            b[off + 7] = (byte) (val);\n+            b[off + 6] = (byte) (val >>> 8);\n+            b[off + 5] = (byte) (val >>> 16);\n+            b[off + 4] = (byte) (val >>> 24);\n+            b[off + 3] = (byte) (val >>> 32);\n+            b[off + 2] = (byte) (val >>> 40);\n+            b[off + 1] = (byte) (val >>> 48);\n+            b[off] = (byte) (val >>> 56);\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            putLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Bits\/ReadWriteValues.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @compile\/module=java.base java\/io\/ReadWriteValues.java\n+ * @run junit\/othervm --add-opens java.base\/java.io=ALL-UNNAMED ReadWriteValues\n+ *\/\n+\n+package java.io;\n+\n+import java.io.Bits;\n+\n+\/**\n+ * Class to allow public access to package-private methods.\n+ *\/\n+public final class BitsProxy {\n+\n+    public static boolean getBoolean(byte[] b, int off) {\n+        return Bits.getBoolean(b, off);\n+    }\n+\n+    public static char getChar(byte[] b, int off) {\n+        return Bits.getChar(b, off);\n+    }\n+\n+    public static short getShort(byte[] b, int off) {\n+        return Bits.getShort(b, off);\n+    }\n+\n+    public static int getInt(byte[] b, int off) {\n+        return Bits.getInt(b, off);\n+    }\n+\n+    public static float getFloat(byte[] b, int off) {\n+        return Bits.getFloat(b, off);\n+    }\n+\n+    public static long getLong(byte[] b, int off) {\n+        return Bits.getLong(b, off);\n+    }\n+\n+    public static double getDouble(byte[] b, int off) {\n+        return Bits.getDouble(b, off);\n+    }\n+\n+\n+    public static void putBoolean(byte[] b, int off, boolean val) {\n+        Bits.putBoolean(b, off, val);\n+    }\n+\n+    public static void putChar(byte[] b, int off, char val) {\n+        Bits.putChar(b, off, val);\n+    }\n+\n+    public static void putShort(byte[] b, int off, short val) {\n+        Bits.putShort(b, off, val);\n+    }\n+\n+    public static void putInt(byte[] b, int off, int val) {\n+        Bits.putInt(b, off, val);\n+    }\n+\n+    public static void putFloat(byte[] b, int off, float val) {\n+        Bits.putFloat(b, off, val);\n+    }\n+\n+    public static void putLong(byte[] b, int off, long val) {\n+        Bits.putLong(b, off, val);\n+    }\n+\n+    public static void putDouble(byte[] b, int off, double val) {\n+        Bits.putDouble(b, off, val);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Bits\/java.base\/java\/io\/BitsProxy.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}