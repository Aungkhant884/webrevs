{"files":[{"patch":"@@ -52,1 +52,0 @@\n-com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java 8285422 generic-all\n","filename":"test\/jdk\/ProblemList-svc-vthread.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6224859\n- * @summary JDWP: Mixing application suspends and debugger suspends can cause hangs\n- * @comment converted from test\/jdk\/com\/sun\/jdi\/MixedSuspendTest.sh\n- *\n- * @library \/test\/lib\n- * @run main\/othervm MixedSuspendTest\n- *\/\n-\n-import lib.jdb.JdbCommand;\n-import lib.jdb.JdbTest;\n-\n-class MixedSuspendTarg extends Thread {\n-\n-    static volatile boolean started = true;\n-    static String lock = \"startLock\";\n-\n-    public static void main(String[] args){\n-        System.out.println(\"Howdy from MixedSuspendTarg\");\n-\n-        MixedSuspendTarg mytarg = new MixedSuspendTarg();\n-\n-        synchronized(lock) {\n-            mytarg.start();\n-            try {\n-                lock.wait();\n-            } catch(InterruptedException ee) {\n-            }\n-        }\n-        mytarg.suspend();\n-        bkpt();\n-        System.out.println(\"Debuggee: resuming thread\");\n-\n-        \/\/ If the bug occurs, this resume hangs in the back-end\n-        mytarg.resume();\n-        System.out.println(\"Debuggee: resumed thread\");\n-        synchronized(lock) {\n-            started = false;\n-        }\n-        System.out.println(\"Debuggee: exitting, started = \" + started);\n-    }\n-\n-    public void run() {\n-        synchronized(lock) {\n-            lock.notifyAll();\n-        }\n-        while (true) {\n-            synchronized(lock) {\n-                if (!started) {\n-                    break;\n-                }\n-                int i = 0;\n-            }\n-        }\n-\n-        System.out.println(\"Debuggee: end of thread\");\n-    }\n-\n-    static void bkpt() {\n-        \/\/System.out.println(\"bkpt reached, thread = \" + this.getName());\n-        int i = 0;   \/\/ @1 breakpoint\n-    }\n-}\n-\n-public class MixedSuspendTest extends JdbTest {\n-    public static void main(String argv[]) {\n-        new MixedSuspendTest().run();\n-    }\n-\n-    private MixedSuspendTest() {\n-        super(DEBUGGEE_CLASS);\n-    }\n-\n-    private static final String DEBUGGEE_CLASS = MixedSuspendTarg.class.getName();\n-\n-    @Override\n-    protected void runCases() {\n-        setBreakpointsFromTestSource(\"MixedSuspendTest.java\", 1);\n-        jdb.command(JdbCommand.run());\n-        jdb.command(JdbCommand.cont().allowExit());\n-\n-        \/\/ This test fails by timing out.\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/jdi\/MixedSuspendTest.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,245 +0,0 @@\n-\/*\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8274687\n- * @summary Test the special handling in the JDWP agent of threads that call\n- *          j.l.Thread.resume().\n- *\n- *          This is the sequence of actions by the debugger and the threads\n- *          \"main\" and \"resumee\" in the target vm.\n- *\n- *          \"resumee\": Reaches breakpoint in methodWithBreakpoint() and is\n- *                     suspended then.\n- *\n- *          \"main\": Calls j.l.Thread.resume() for \"resumee\". There is an internal\n- *                  breakpoint in Thread.resume() so the JDWP agent receives a\n- *                  breakpoint event. It finds that \"resumee\" is suspended because\n- *                  of JDWP actions. The resume() call would interfere with the\n- *                  debugger therefore \"main\" is blocked.\n- *\n- *          Debugger: Tests if the suspended \"resumee\" can be suspended a second\n- *                    time and resumes it again.\n- *\n- *          Debugger: Resumes \"resumee\" by calling ThreadReference.resume().\n- *                    The JDWP agent notifies \"main\" about it.\n- *\n- *          \"resumee\": Continues execution.\n- *\n- *          \"main\": Receives the notification, finds that \"resumee\" is not\n- *                  suspended anymore and continues execution.\n- *\n- *          Debugger: Verifies that \"main\" is no longer blocked.\n- *\n- * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n- *\n- * @library \/test\/lib\n- *\n- * @run build TestScaffold VMConnection TargetListener TargetAdapter\n- * @run compile -g ResumeAfterThreadResumeCallTest.java\n- * @run driver ResumeAfterThreadResumeCallTest\n- *\/\n-import com.sun.jdi.*;\n-import com.sun.jdi.event.*;\n-import jdk.test.lib.Asserts;\n-\n-import java.util.*;\n-\n-\/\/ Target program for the debugger\n-class ResumeAfterThreadResumeCallTarg extends Thread {\n-\n-    public boolean reachedBreakpoint;\n-    public boolean mainThreadReturnedFromResumeCall;\n-    public boolean testFinished;\n-\n-    public ResumeAfterThreadResumeCallTarg(String name) {\n-        super(name);\n-    }\n-\n-    public static void log(String m) {\n-        String threadName = Thread.currentThread().getName();\n-        System.out.println(\"###(Target,\"+ threadName +\") \" + m);\n-    }\n-\n-    public static void main(String[] args) {\n-        log(\"Entered main()\");\n-\n-        \/\/ Start \"resumee\" thread.\n-        ResumeAfterThreadResumeCallTarg resumee = new ResumeAfterThreadResumeCallTarg(\"resumee\");\n-        resumee.start();\n-\n-        \/\/ Wait for \"resumee\" to reach the breakpoint in methodWithBreakpoint().\n-        while (!resumee.reachedBreakpoint) {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) { \/* ignored *\/ }\n-        }\n-\n-        \/\/ \"resumee\" is suspended now because of the breakpoint\n-        \/\/ Calling Thread.resume() will block this thread.\n-        log(\"Calling Thread.resume()\");\n-        resumee.resume();\n-        resumee.mainThreadReturnedFromResumeCall = true;\n-        log(\"Thread.resume() returned\");\n-\n-        \/\/ Wait for debugger\n-        while (!resumee.testFinished) {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) { \/* ignored *\/ }\n-        }\n-    }\n-\n-    public void run() {\n-        log(\"up and running.\");\n-        methodWithBreakpoint();\n-    }\n-\n-    public void methodWithBreakpoint() {\n-        log(\"Entered methodWithBreakpoint()\");\n-    }\n-}\n-\n-\n-\/\/ Debugger program\n-\n-public class ResumeAfterThreadResumeCallTest extends TestScaffold {\n-    public static final String TARGET_CLS_NAME = ResumeAfterThreadResumeCallTarg.class.getName();\n-    public static final long UNBLOCK_TIMEOUT = 10000;\n-\n-    ResumeAfterThreadResumeCallTest (String args[]) {\n-        super(args);\n-    }\n-\n-    public static void main(String[] args)      throws Exception {\n-        new ResumeAfterThreadResumeCallTest(args).startTests();\n-    }\n-\n-    \/**\n-     * Set a breakpoint in the given method and resume all threads. The\n-     * breakpoint is configured to suspend just the thread that reaches it\n-     * instead of all threads.\n-     *\/\n-    public BreakpointEvent resumeTo(String clsName, String methodName, String signature) {\n-        boolean suspendThreadOnly = true;\n-        return resumeTo(clsName, methodName, signature, suspendThreadOnly);\n-    }\n-\n-    protected void runTests() throws Exception {\n-        BreakpointEvent bpe = startToMain(TARGET_CLS_NAME);\n-        mainThread = bpe.thread();\n-\n-        log(\"Resuming to methodWithBreakpoint()\");\n-        bpe = resumeTo(TARGET_CLS_NAME, \"methodWithBreakpoint\", \"()V\");\n-\n-        log(\"Thread \\\"resumee\\\" has reached the breakpoint and is suspended now.\");\n-        ThreadReference resumee = bpe.thread();\n-        ObjectReference resumeeThreadObj = resumee.frame(1).thisObject();\n-        printStack(resumee);\n-        mainThread.suspend();\n-        printStack(mainThread);\n-        mainThread.resume();\n-        log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n-        log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n-        log(\"Notify target main thread to continue by setting reachedBreakpoint = true.\");\n-        setField(resumeeThreadObj, \"reachedBreakpoint\", vm().mirrorOf(true));\n-\n-        log(\"Sleeping 500ms so that the main thread is blocked calling Thread.resume() on \\\"resumee\\\" Thread.\");\n-        Thread.sleep(500);\n-        log(\"After sleep.\");\n-        mainThread.suspend();\n-        printStack(mainThread);\n-        mainThread.resume();\n-\n-        boolean mainThreadReturnedFromResumeCall = false;\n-        boolean resumedResumee = false;\n-        for (long sleepTime = 50; sleepTime < UNBLOCK_TIMEOUT && !mainThreadReturnedFromResumeCall; sleepTime <<= 1) {\n-            log(\"mainThread.isSuspended() -> \" + mainThread.isSuspended());\n-            Value v = getField(resumeeThreadObj, \"mainThreadReturnedFromResumeCall\");\n-            mainThreadReturnedFromResumeCall = ((PrimitiveValue) v).booleanValue();\n-            if (!resumedResumee) {\n-                \/\/ main thread should still be blocked.\n-                Asserts.assertFalse(mainThreadReturnedFromResumeCall, \"main Thread was not blocked\");\n-\n-                \/\/ Test suspending the already suspended resumee thread.\n-                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n-                log(\"Check if suspended \\\"resumee\\\" can be suspended a 2nd time.\");\n-                resumee.suspend();\n-                log(\"resumee.isSuspended() -> \" + resumee.isSuspended());\n-                log(\"Resuming \\\"resumee\\\"\");\n-                resumee.resume();\n-                Asserts.assertTrue(resumee.isSuspended(), \"\\\"resumee\\\" is not suspended.\");\n-\n-                \/\/ Really resume the resumee thread.\n-                log(\"Resuming \\\"resumee\\\" a 2nd time will unblock the main thread.\");\n-                resumee.resume();\n-                Asserts.assertFalse(resumee.isSuspended(), \"\\\"resumee\\\" is still suspended.\");\n-                resumedResumee = true;\n-            }\n-            log(\"Sleeping \" + sleepTime + \"ms\");\n-            Thread.sleep(sleepTime);\n-        }\n-        Asserts.assertTrue(mainThreadReturnedFromResumeCall, \"main Thread was not unblocked\");\n-\n-        setField(resumeeThreadObj, \"testFinished\", vm().mirrorOf(true));\n-\n-        \/\/ Resume the target listening for events\n-        listenUntilVMDisconnect();\n-    }\n-\n-    public void printStack(ThreadReference thread) throws Exception {\n-        log(\"Stack of thread '\" + thread.name() + \"':\");\n-        List<StackFrame> stack_frames = thread.frames();\n-        int i = 0;\n-        for (StackFrame ff : stack_frames) {\n-            Location loc = ff.location();\n-            String locString = \"bci:\" + loc.codeIndex();\n-            try {\n-                locString = loc.sourceName() + \":\" + loc.lineNumber() + \",\" + locString;\n-            } catch (AbsentInformationException e) {\/* empty *\/};\n-            log(\"  frame[\" + i++ +\"]: \" + ff.location().method() + \" (\" + locString + \")\");\n-        }\n-    }\n-\n-    public void setField(ObjectReference obj, String fName, Value val) throws Exception {\n-        log(\"set field \" + fName + \" = \" + val);\n-        ReferenceType rt = obj.referenceType();\n-        Field fld = rt.fieldByName(fName);\n-        obj.setValue(fld, val);\n-        log(\"ok\");\n-    }\n-\n-    public Value getField(ObjectReference obj, String fName) throws Exception {\n-        log(\"get field \" + fName);\n-        ReferenceType rt = obj.referenceType();\n-        Field fld = rt.fieldByName(fName);\n-        Value val = obj.getValue(fld);\n-        log(\"result : \" + val);\n-        return val;\n-    }\n-\n-    public void log(String m) {\n-        System.out.println(\"###(Debugger) \" + m);\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/jdi\/ResumeAfterThreadResumeCallTest.java","additions":0,"deletions":245,"binary":false,"changes":245,"status":"deleted"}]}