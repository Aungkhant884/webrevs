{"files":[{"patch":"@@ -305,0 +305,8 @@\n+  \/\/ It is important that when soft references are cleared, we also pre-clean the young\n+  \/\/ generation, as we might otherwise throw premature OOM. Therefore, all causes that\n+  \/\/ trigger soft ref cleaning must also trigger pre-cleaning of young gen. If allocations\n+  \/\/ stalled when checking for soft ref cleaning, then since we hold the driver locker all\n+  \/\/ the way until we check for young gen pre-cleaning, we can be certain that we should\n+  \/\/ catch that above and perform young gen pre-cleaning.\n+  assert(!should_clear_soft_references(cause), \"Clearing soft references without pre-cleaning young gen\");\n+\n@@ -388,4 +396,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear = should_clear_soft_references(request.cause());\n-    ZGeneration::old()->set_soft_reference_policy(clear);\n-\n@@ -444,2 +448,2 @@\n-static void handle_alloc_stalling_for_old() {\n-  ZHeap::heap()->handle_alloc_stalling_for_old();\n+static void handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_soft_refs);\n@@ -448,2 +452,2 @@\n-void ZDriverMajor::handle_alloc_stalls() const {\n-  handle_alloc_stalling_for_old();\n+void ZDriverMajor::handle_alloc_stalls(bool cleared_soft_refs) const {\n+  handle_alloc_stalling_for_old(cleared_soft_refs);\n@@ -464,0 +468,4 @@\n+    \/\/ Set up soft reference policy\n+    const bool clear_soft_refs = should_clear_soft_references(request.cause());\n+    ZGeneration::old()->set_soft_reference_policy(clear_soft_refs);\n+\n@@ -473,1 +481,1 @@\n-    handle_alloc_stalls();\n+    handle_alloc_stalls(clear_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void handle_alloc_stalls() const;\n+  void handle_alloc_stalls(bool cleared_soft_refs) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  void handle_alloc_stalling_for_old();\n+  void handle_alloc_stalling_for_old(bool cleared_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-inline void ZHeap::handle_alloc_stalling_for_old() {\n-  _page_allocator.handle_alloc_stalling_for_old();\n+inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+  _page_allocator.handle_alloc_stalling_for_old(cleared_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-void ZPageAllocator::handle_alloc_stalling_for_old() {\n+void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n@@ -990,1 +990,3 @@\n-  notify_out_of_memory();\n+  if (cleared_soft_refs) {\n+    notify_out_of_memory();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  void handle_alloc_stalling_for_old();\n+  void handle_alloc_stalling_for_old(bool cleared_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}