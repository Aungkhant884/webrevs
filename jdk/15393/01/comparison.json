{"files":[{"patch":"@@ -620,4 +620,1 @@\n-    resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_NULL);\n-    if (resolved_klass == nullptr) {\n-      JVMCI_THROW_MSG_NULL(NoClassDefFoundError, str);\n-    }\n+    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, protection_domain, true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-     * @return the type for {@code name} or 0 if resolution failed and {@code resolve == false}\n+     * @return the type for {@code name} or {@code null} if resolution failed and {@code resolve == false}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            Class<?> accessClass, boolean resolve) throws ClassNotFoundException {\n+            Class<?> accessClass, boolean resolve) throws NoClassDefFoundError {\n@@ -97,5 +97,1 @@\n-        try {\n-            return lookupType(name, accessingClass, resolve);\n-        } catch (ClassNotFoundException e) {\n-            throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);\n-        }\n+        return lookupType(name, accessingClass, resolve);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n@@ -46,0 +48,1 @@\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n@@ -47,0 +50,2 @@\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n@@ -48,2 +53,5 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.io.ByteArrayOutputStream;\n+import java.io.CharArrayWriter;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -52,0 +60,8 @@\n+\n+    \/**\n+     * Abstracts which lookup method is being tested.\n+     *\/\n+    public interface Lookup {\n+        ResolvedJavaType lookupType(String name, Class<?> accessingClass, boolean resolve);\n+    }\n+\n@@ -54,2 +70,12 @@\n-        for (TestCase tcase : createTestCases()) {\n-            test.runTest(tcase);\n+\n+        \/\/ Test CompilerToVM.lookupType\n+        for (TestCase tcase : createTestCases(false, true)) {\n+            test.runTest(tcase, CompilerToVMHelper::lookupType);\n+        }\n+\n+        \/\/ Test HotSpotJVMCIRuntime.lookupType\n+        HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();\n+        MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();\n+        for (TestCase tcase : createTestCases(true, false)) {\n+            test.runTest(tcase, (name, accessingClass, resolve) -> (ResolvedJavaType) runtime.lookupType(name,\n+                (HotSpotResolvedObjectType) metaAccess.lookupJavaType(accessingClass), resolve));\n@@ -59,2 +85,2 @@\n-    private static Set<TestCase> createTestCases() {\n-        Set<TestCase> result = new HashSet<>();\n+    private static List<TestCase> createTestCases(boolean allowPrimitive, boolean allowNullAccessingClass) {\n+        List<TestCase> result = new ArrayList<>();\n@@ -62,1 +88,5 @@\n-        result.add(new TestCase(Utils.toJVMTypeSignature(int.class),\n+        if (allowPrimitive) {\n+            result.add(new TestCase(Utils.toJVMTypeSignature(int.class),\n+                LookupTypeTest.class, true, true));\n+        } else {\n+            result.add(new TestCase(Utils.toJVMTypeSignature(int.class),\n@@ -64,0 +94,1 @@\n+        }\n@@ -66,1 +97,1 @@\n-                true, false, ClassNotFoundException.class));\n+                true, false, NoClassDefFoundError.class));\n@@ -69,1 +100,1 @@\n-                true, false, ClassNotFoundException.class));\n+                true, false, NoClassDefFoundError.class));\n@@ -74,1 +105,1 @@\n-                ClassNotFoundException.class));\n+                NoClassDefFoundError.class));\n@@ -83,1 +114,2 @@\n-        result.add(new TestCase(\n+        if (allowNullAccessingClass) {\n+            result.add(new TestCase(\n@@ -86,0 +118,1 @@\n+        }\n@@ -89,1 +122,1 @@\n-    private void runTest(TestCase tcase) {\n+    private void runTest(TestCase tcase, Lookup lookup) {\n@@ -91,1 +124,1 @@\n-        HotSpotResolvedObjectType metaspaceKlass;\n+        ResolvedJavaType metaspaceKlass;\n@@ -93,1 +126,1 @@\n-            metaspaceKlass = CompilerToVMHelper.lookupType(tcase.className,\n+            metaspaceKlass = lookup.lookupType(tcase.className,\n@@ -96,0 +129,3 @@\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            t.printStackTrace(new PrintStream(bos));\n+            String tString = bos.toString();\n@@ -97,1 +133,1 @@\n-                    \"Assumed no exception, but got \" + t);\n+                    \"Assumed no exception, but got \" + tString);\n@@ -99,1 +135,1 @@\n-                    \"Got unexpected exception \" + t);\n+                    \"Got unexpected exception \" + tString);\n@@ -101,1 +137,1 @@\n-                    \"Unexpected exception\");\n+                    \"Unexpected exception: \" + tString);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/LookupTypeTest.java","additions":53,"deletions":17,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -186,0 +186,5 @@\n+\n+    @Test\n+    public void lookupTypeTest() throws Exception {\n+        \/\/ This is tested by compiler\/jvmci\/compilerToVM\/LookupTypeTest.java\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}