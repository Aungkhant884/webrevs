{"files":[{"patch":"@@ -1682,1 +1682,1 @@\n-                                    bool is_double, bool is_min, int vector_length) {\n+                                    BasicType bt, bool is_min, int vector_length) {\n@@ -1685,1 +1685,1 @@\n-  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+  vsetvli_helper(bt, vector_length);\n@@ -1701,1 +1701,1 @@\n-                                           bool is_double, bool is_min, int vector_length) {\n+                                           BasicType bt, bool is_min, int vector_length) {\n@@ -1703,1 +1703,1 @@\n-  vsetvli_helper(is_double ? T_DOUBLE : T_FLOAT, vector_length);\n+  vsetvli_helper(bt, vector_length);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                  bool is_double, bool is_min, int vector_length);\n+                  BasicType bt, bool is_min, int vector_length);\n@@ -194,1 +194,1 @@\n-                         bool is_double, bool is_min, int vector_length);\n+                         BasicType bt, bool is_min, int vector_length);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,16 +629,3 @@\n-instruct vmaxF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst (MaxV src1 src2));\n-  effect(TEMP_DEF dst, TEMP v0);\n-  ins_cost(VEC_COST);\n-  format %{ \"vmaxF $dst, $src1, $src2\" %}\n-  ins_encode %{\n-    __ minmax_fp_v(as_VectorRegister($dst$$reg),\n-                   as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                   false \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaxD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+instruct vmax_fp(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -648,15 +635,1 @@\n-  format %{ \"vmaxD $dst, $src1, $src2\" %}\n-  ins_encode %{\n-    __ minmax_fp_v(as_VectorRegister($dst$$reg),\n-                   as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg),\n-                   true \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vminF(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst (MinV src1 src2));\n-  effect(TEMP_DEF dst, TEMP v0);\n-  ins_cost(VEC_COST);\n-  format %{ \"vminF $dst, $src1, $src2\" %}\n+  format %{ \"vmax_fp $dst, $src1, $src2\" %}\n@@ -664,0 +637,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -666,1 +640,1 @@\n-                   false \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+                   bt, false \/* is_min *\/, Matcher::vector_length(this));\n@@ -671,2 +645,3 @@\n-instruct vminD(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+instruct vmin_fp(vReg dst, vReg src1, vReg src2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -676,1 +651,1 @@\n-  format %{ \"vminD $dst, $src1, $src2\" %}\n+  format %{ \"vmin_fp $dst, $src1, $src2\" %}\n@@ -678,0 +653,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -680,1 +656,1 @@\n-                   true \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+                   bt, true \/* is_min *\/, Matcher::vector_length(this));\n@@ -687,17 +663,3 @@\n-instruct vmaxF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst_src1 (MaxV (Binary dst_src1 src2) vmask));\n-  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  ins_cost(VEC_COST);\n-  format %{ \"vmaxF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n-  ins_encode %{\n-    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n-                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n-                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                          false \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaxD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+instruct vmax_fp_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -707,16 +669,1 @@\n-  format %{ \"vmaxD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n-  ins_encode %{\n-    __ minmax_fp_masked_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n-                          as_VectorRegister($src2$$reg), as_VectorRegister($vmask$$reg),\n-                          as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                          true \/* is_double *\/, false \/* is_min *\/, Matcher::vector_length(this));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vminF_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n-  match(Set dst_src1 (MinV (Binary dst_src1 src2) vmask));\n-  effect(TEMP_DEF dst_src1, TEMP tmp1, TEMP tmp2, TEMP v0);\n-  ins_cost(VEC_COST);\n-  format %{ \"vminF_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  format %{ \"vmax_fp_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n@@ -724,0 +671,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -727,1 +675,1 @@\n-                          false \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+                          bt, false \/* is_min *\/, Matcher::vector_length(this));\n@@ -732,2 +680,3 @@\n-instruct vminD_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+instruct vmin_fp_masked(vReg dst_src1, vReg src2, vRegMask vmask, vReg tmp1, vReg tmp2, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -737,1 +686,1 @@\n-  format %{ \"vminD_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n+  format %{ \"vmin_fp_masked $dst_src1, $dst_src1, $src2, $vmask\\t# KILL $tmp1, $tmp2, $v0\" %}\n@@ -739,0 +688,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -742,1 +692,1 @@\n-                          true \/* is_double *\/, true \/* is_min *\/, Matcher::vector_length(this));\n+                          bt, true \/* is_min *\/, Matcher::vector_length(this));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":24,"deletions":74,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -854,41 +854,0 @@\n-  \/\/ All-singing all-dancing memory copy.\n-  \/\/\n-  \/\/ Copy count units of memory from s to d.  The size of a unit is\n-  \/\/ step, which can be positive or negative depending on the direction\n-  \/\/ of copy.  If is_aligned is false, we align the source address.\n-  \/\/\n-  \/*\n-   * if (is_aligned) {\n-   *   if (count >= 32)\n-   *     goto copy32_loop;\n-   *   if (count >= 8)\n-   *     goto copy8_loop;\n-   *   goto copy_small;\n-   * }\n-   * bool is_backwards = step < 0;\n-   * int granularity = uabs(step);\n-   * count = count  *  granularity;   * count bytes\n-   *\n-   * if (is_backwards) {\n-   *   s += count;\n-   *   d += count;\n-   * }\n-   *\n-   * count limit maybe greater than 16, for better performance\n-   * if (count < 16) {\n-   *   goto copy_small;\n-   * }\n-   *\n-   * if ((dst % 8) == (src % 8)) {\n-   *   aligned;\n-   *   goto copy_big;\n-   * }\n-   *\n-   * copy_big:\n-   * if the amount to copy is more than (or equal to) 32 bytes goto copy32_loop\n-   *  else goto copy8_loop\n-   * copy_small:\n-   *   load element one by one;\n-   * done;\n-   *\/\n-\n@@ -947,0 +906,6 @@\n+  \/\/ All-singing all-dancing memory copy.\n+  \/\/\n+  \/\/ Copy count units of memory from s to d.  The size of a unit is\n+  \/\/ step, which can be positive or negative depending on the direction\n+  \/\/ of copy.\n+  \/\/\n@@ -1040,1 +1005,1 @@\n-    __ bltz(t0, copy_small); \/\/ cnt < 8, go to copy_small, else fall throught to copy8_loop\n+    __ bltz(t0, copy_small); \/\/ cnt < 8, go to copy_small, else fall through to copy8_loop\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":7,"deletions":42,"binary":false,"changes":49,"status":"modified"}]}