{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    jobject    weakRef;\n+    jobject    strongOrWeakRef;\n@@ -92,0 +92,1 @@\n+    jboolean   pin = gdata->pinAllCount != 0;\n@@ -99,7 +100,13 @@\n-    \/* Create weak reference to make sure we have a reference *\/\n-    weakRef = JNI_FUNC_PTR(env,NewWeakGlobalRef)(env, ref);\n-    \/\/ NewWeakGlobalRef can throw OOM, clear exception here.\n-    if ((*env)->ExceptionCheck(env)) {\n-        (*env)->ExceptionClear(env);\n-        jvmtiDeallocate(node);\n-        return NULL;\n+    if (pin) {\n+        \/* Create strong reference to make sure we have a reference *\/\n+        strongOrWeakRef = JNI_FUNC_PTR(env,NewGlobalRef)(env, ref);\n+    } else {\n+        \/* Create weak reference to make sure we have a reference *\/\n+        strongOrWeakRef = JNI_FUNC_PTR(env,NewWeakGlobalRef)(env, ref);\n+\n+        \/\/ NewWeakGlobalRef can throw OOM, clear exception here.\n+        if ((*env)->ExceptionCheck(env)) {\n+            (*env)->ExceptionClear(env);\n+            jvmtiDeallocate(node);\n+            return NULL;\n+        }\n@@ -108,1 +115,1 @@\n-    \/* Set tag on weakRef *\/\n+    \/* Set tag on strongOrWeakRef *\/\n@@ -110,1 +117,1 @@\n-                          (gdata->jvmti, weakRef, ptr_to_jlong(node));\n+                          (gdata->jvmti, strongOrWeakRef, ptr_to_jlong(node));\n@@ -112,1 +119,5 @@\n-        JNI_FUNC_PTR(env,DeleteWeakGlobalRef)(env, weakRef);\n+        if (pin) {\n+            JNI_FUNC_PTR(env,DeleteGlobalRef)(env, strongOrWeakRef);\n+        } else {\n+            JNI_FUNC_PTR(env,DeleteWeakGlobalRef)(env, strongOrWeakRef);\n+        }\n@@ -118,4 +129,4 @@\n-    node->ref      = weakRef;\n-    node->isStrong = JNI_FALSE;\n-    node->count    = 1;\n-    node->seqNum   = newSeqNum();\n+    node->ref         = strongOrWeakRef;\n+    node->count       = 1;\n+    node->strongCount = pin ? 1 : 0;\n+    node->seqNum      = newSeqNum();\n@@ -138,1 +149,1 @@\n-        if (node->isStrong) {\n+        if (node->strongCount != 0) {\n@@ -152,1 +163,1 @@\n-    if (!node->isStrong) {\n+    if (node->strongCount == 0) {\n@@ -167,2 +178,2 @@\n-            node->ref      = strongRef;\n-            node->isStrong = JNI_TRUE;\n+            node->ref         = strongRef;\n+            node->strongCount = 1;\n@@ -172,0 +183,1 @@\n+        node->strongCount++;\n@@ -180,1 +192,1 @@\n-    if (node->isStrong) {\n+    if (node->strongCount == 1) {\n@@ -191,2 +203,2 @@\n-            node->ref      = weakRef;\n-            node->isStrong = JNI_FALSE;\n+            node->ref         = weakRef;\n+            node->strongCount = 0;\n@@ -196,0 +208,1 @@\n+        node->strongCount--;\n@@ -375,1 +388,2 @@\n-    gdata->nextSeqNum       = 1; \/* 0 used for error indication *\/\n+    gdata->nextSeqNum = 1; \/* 0 used for error indication *\/\n+    gdata->pinAllCount = 0;\n@@ -457,1 +471,1 @@\n-            if (node->isStrong) {\n+            if (node->strongCount != 0) {\n@@ -547,0 +561,78 @@\n+\/* Prevent garbage collection of object *\/\n+void\n+commonRef_pinAll()\n+{\n+    debugMonitorEnter(gdata->refLock); {\n+        gdata->pinAllCount++;\n+\n+        if (gdata->pinAllCount == 1) {\n+            JNIEnv  *env;\n+            RefNode *node;\n+            RefNode *prev;\n+            int     i;\n+\n+            env = getEnv();\n+\n+            \/*\n+             * Walk through the id-based hash table. Detach any nodes\n+             * for which the ref has been collected.\n+             *\/\n+            for (i = 0; i < gdata->objectsByIDsize; i++) {\n+                node = gdata->objectsByID[i];\n+                prev = NULL;\n+                while (node != NULL) {\n+                    jobject strongRef;\n+\n+                    strongRef = strengthenNode(env, node);\n+\n+                    \/* Has the object been collected? *\/\n+                    if (strongRef == NULL) {\n+                        RefNode *freed;\n+\n+                        \/* Detach from the ID list *\/\n+                        if (prev == NULL) {\n+                            gdata->objectsByID[i] = node->next;\n+                        } else {\n+                            prev->next = node->next;\n+                        }\n+                        freed = node;\n+                        node = node->next;\n+                        deleteNode(env, freed);\n+                    } else {\n+                        prev = node;\n+                        node = node->next;\n+                    }\n+                }\n+            }\n+        }\n+    } debugMonitorExit(gdata->refLock);\n+}\n+\n+\/* Permit garbage collection of objects *\/\n+void\n+commonRef_unpinAll()\n+{\n+    debugMonitorEnter(gdata->refLock); {\n+        gdata->pinAllCount--;\n+\n+        if (gdata->pinAllCount == 0) {\n+            JNIEnv  *env;\n+            RefNode *node;\n+            int     i;\n+\n+            env = getEnv();\n+\n+            for (i = 0; i < gdata->objectsByIDsize; i++) {\n+                for (node = gdata->objectsByID[i]; node != NULL; node = node->next) {\n+                    jweak weakRef;\n+\n+                    weakRef = weakenNode(env, node);\n+                    if (weakRef == NULL) {\n+                        EXIT_ERROR(AGENT_ERROR_NULL_POINTER,\"NewWeakGlobalRef\");\n+                    }\n+                }\n+            }\n+        }\n+    } debugMonitorExit(gdata->refLock);\n+}\n+\n@@ -585,1 +677,1 @@\n-                    if ( (!node->isStrong) &&\n+                    if ( (node->strongCount == 0) &&\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/commonRef.c","additions":118,"deletions":26,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+void commonRef_pinAll();\n+void commonRef_unpinAll();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/commonRef.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1556,0 +1556,6 @@\n+            \/*\n+             * Pin all objects to prevent objects from being\n+             * garbage collected while the VM is suspended.\n+             *\/\n+            commonRef_pinAll();\n+\n@@ -1607,0 +1613,5 @@\n+        \/*\n+         * Unpin all objects.\n+         *\/\n+        commonRef_unpinAll();\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    unsigned     isStrong : 1;  \/* 1 means this is a string reference *\/\n+    unsigned     strongCount;   \/* count of strong reference *\/\n@@ -131,0 +131,1 @@\n+    unsigned      pinAllCount;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,12 @@\n-        pipe.println(\"newcheck\");\n+            pipe.println(\"newcheck\");\n+\n+            \/\/ There are potentially other non-test Java threads allocating objects and triggering\n+            \/\/ GC's so we need to suspend the target VM to avoid the objects created in the test\n+            \/\/ from being accidentally GC'ed. However, we need the target VM temporary resumed\n+            \/\/ while reading its response. Below we resume the target VM (if required) and suspend\n+            \/\/ it only after pipe.readln() returns.\n+\n+            \/\/ On the first iteration the target VM is not suspended yet.\n+            if (i > 0) {\n+                debuggee.resume();\n+            }\n@@ -150,0 +161,3 @@\n+            \/\/ Suspending target VM to prevent other non-test Java threads from triggering GCs.\n+            debuggee.suspend();\n+\n@@ -233,0 +247,1 @@\n+        debuggee.resume();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ArrayType\/newInstance\/newinstance004.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+                    debuggee.resume();\n@@ -193,0 +194,1 @@\n+                    debuggee.suspend();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/instances\/instances002\/instances002.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,8 @@\n-                array.disableCollection();\n+                try {\n+                    \/\/ Since the VM is not suspended, the object may have been collected\n+                    \/\/ before disableCollection() could be called on it. Just ignore and\n+                    \/\/ continue doing allocations until we run out of memory.\n+                    array.disableCollection();\n+                } catch (ObjectCollectedException e) {\n+                    continue;\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VMOutOfMemoryException\/VMOutOfMemoryException001\/VMOutOfMemoryException001.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,5 @@\n+    \/\/ Keep class loader alive to avoid ObjectCollectedException\n+    \/\/ on the debugger side, in case the GC unloads the class and\n+    \/\/ invalidates code locations.\n+    private TestClassLoader classLoader;\n+\n@@ -73,1 +78,1 @@\n-        TestClassLoader classLoader = new TestClassLoader();\n+        classLoader = new TestClassLoader();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/sde\/SDEDebuggee.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}