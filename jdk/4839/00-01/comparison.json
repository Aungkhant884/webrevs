{"files":[{"patch":"@@ -184,1 +184,2 @@\n-instruct reinterpretS2X(vecX dst, vecD src)\n+\n+instruct reinterpretStoX(vecX dst, vecD src)\n@@ -190,1 +191,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# S2X\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# S to X\" %}\n@@ -193,1 +194,1 @@\n-    \/\/ upper 96 bits of 'src' are expected to have been initialized\n+    \/\/ upper bits of \"src\" are expected to have been initialized\n@@ -202,1 +203,1 @@\n-instruct reinterpretX2S(vecD dst, vecX src)\n+instruct reinterpretStoD(vecD dst, vecD src)\n@@ -204,2 +205,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n@@ -208,1 +209,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# X2S\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# S to D\" %}\n@@ -210,3 +211,6 @@\n-    \/\/ Resize the vector from 128-bits to 32-bits. The higher 96-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n-    __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n+    \/\/ If registers are the same, no register move is required - the\n+    \/\/ upper bits of \"src\" are expected to have been initialized\n+    \/\/ to zero.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n+    }\n@@ -217,1 +221,1 @@\n-instruct reinterpretS2D(vecD dst, vecD src)\n+instruct reinterpretXtoS(vecD dst, vecX src)\n@@ -219,2 +223,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n@@ -223,1 +227,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# S2D\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# X to S\" %}\n@@ -225,6 +229,3 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 32 bits of 'src' are expected to have been initialized\n-    \/\/ to zero.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-    }\n+    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n+    \/\/ of the \"dst\" register must be cleared to zero.\n+    __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n@@ -235,1 +236,1 @@\n-instruct reinterpretD2S(vecD dst, vecD src)\n+instruct reinterpretDtoS(vecD dst, vecD src)\n@@ -241,1 +242,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# D2S\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# D to S\" %}\n@@ -243,2 +244,2 @@\n-    \/\/ Resize the vector from 64-bits to 32-bits. The higher 32-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n+    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n+    \/\/ of the \"dst\" register must be cleared to zero.\n@@ -494,1 +495,1 @@\n-  format %{ \"fcvtzv  T4S, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T4S, $src\\n\\t\"\n@@ -499,1 +500,1 @@\n-    __ fcvtzv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n@@ -510,1 +511,1 @@\n-  format %{ \"fcvtzv  T2D, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T2D, $src\\n\\t\"\n@@ -515,1 +516,1 @@\n-    __ fcvtzv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n@@ -568,1 +569,1 @@\n-  format %{ \"fcvtzv  T4S, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T4S, $src\\n\\t\"\n@@ -572,1 +573,1 @@\n-    __ fcvtzv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n@@ -582,1 +583,1 @@\n-  format %{ \"fcvtzv  T2D, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T2D, $src\\n\\t\"\n@@ -586,1 +587,1 @@\n-    __ fcvtzv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n@@ -629,1 +630,1 @@\n-  format %{ \"fcvtzv  T2S, $dst, $src\\t# convert 2F to 2I vector\" %}\n+  format %{ \"fcvtzv  $dst, T2S, $src\\t# convert 2F to 2I vector\" %}\n@@ -631,1 +632,1 @@\n-    __ fcvtzv(__ T2S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n@@ -640,1 +641,1 @@\n-  format %{ \"fcvtzv  T4S, $dst, $src\\t# convert 4F to 4I vector\" %}\n+  format %{ \"fcvtzv  $dst, T4S, $src\\t# convert 4F to 4I vector\" %}\n@@ -642,1 +643,1 @@\n-    __ fcvtzv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n@@ -651,1 +652,1 @@\n-  format %{ \"fcvtzv  T2D, $dst, $src\\t# convert 2D to 2L vector\" %}\n+  format %{ \"fcvtzv  $dst, T2D, $src\\t# convert 2D to 2L vector\" %}\n@@ -653,1 +654,1 @@\n-    __ fcvtzv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n@@ -699,1 +700,1 @@\n-            \"fcvtzv  T2D, $dst, $dst\\t# convert 2F to 2L vector\"\n+            \"fcvtzv  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n@@ -703,1 +704,1 @@\n-    __ fcvtzv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -136,34 +136,3 @@\n-instruct reinterpretS2X(vecX dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S2X\" %}\n-  ins_encode %{\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 96 bits of 'src' are expected to have been initialized\n-    \/\/ to zero.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretX2S(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X2S\" %}\n-  ins_encode %{\n-    \/\/ Resize the vector from 128-bits to 32-bits. The higher 96-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n-    __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretS2D(vecD dst, vecD src)\n+dnl\n+define(`REINTERPRET_S2XD', `\n+instruct reinterpret$1to$2`'(vec$3 dst, vec$4 src)\n@@ -171,2 +140,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n@@ -175,1 +144,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# S2D\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n@@ -178,1 +147,1 @@\n-    \/\/ upper 32 bits of 'src' are expected to have been initialized\n+    \/\/ upper bits of \"src\" are expected to have been initialized\n@@ -185,3 +154,7 @@\n-%}\n-\n-instruct reinterpretD2S(vecD dst, vecD src)\n+%}')dnl\n+dnl              $1 $2 $3 $4 $5  $6\n+REINTERPRET_S2XD(S, X, X, D, 16, 4)\n+REINTERPRET_S2XD(S, D, D, D, 8,  4)\n+dnl\n+define(`REINTERPRET_XD2S', `\n+instruct reinterpret$1to$2`'(vec$3 dst, vec$4 src)\n@@ -189,2 +162,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n@@ -193,1 +166,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# D2S\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n@@ -195,2 +168,2 @@\n-    \/\/ Resize the vector from 64-bits to 32-bits. The higher 32-bits of\n-    \/\/ the \"dst\" register must be cleared to zero.\n+    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n+    \/\/ of the \"dst\" register must be cleared to zero.\n@@ -200,1 +173,5 @@\n-%}\n+%}')dnl\n+dnl              $1 $2 $3 $4 $5 $6\n+REINTERPRET_XD2S(X, S, D, X, 4, 16)\n+REINTERPRET_XD2S(D, S, D, D, 4, 8)\n+dnl\n@@ -307,1 +284,1 @@\n-  format %{ \"fcvtzv  T$4, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T$4, $src\\n\\t\"\n@@ -312,1 +289,1 @@\n-    __ fcvtzv(__ T$4, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T$4, as_FloatRegister($src$$reg));\n@@ -346,1 +323,1 @@\n-  format %{ \"fcvtzv  T$4, $dst, $src\\n\\t\"\n+  format %{ \"fcvtzv  $dst, T$4, $src\\n\\t\"\n@@ -350,1 +327,1 @@\n-    __ fcvtzv(__ T$4, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T$4, as_FloatRegister($src$$reg));\n@@ -380,1 +357,1 @@\n-  format %{ \"fcvtzv  T$5, $dst, $src\\t# convert $1$2 to $1$3 vector\" %}\n+  format %{ \"fcvtzv  $dst, T$5, $src\\t# convert $1$2 to $1$3 vector\" %}\n@@ -382,1 +359,1 @@\n-    __ fcvtzv(__ T$5, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T$5, as_FloatRegister($src$$reg));\n@@ -426,1 +403,1 @@\n-            \"fcvtzv  T2D, $dst, $dst\\t# convert 2F to 2L vector\"\n+            \"fcvtzv  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n@@ -430,1 +407,1 @@\n-    __ fcvtzv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n+    __ fcvtzv(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":32,"deletions":55,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2039,9 +2039,0 @@\n-  public:\n-  void fcvtzv(SIMD_Arrangement T, FloatRegister Rd, FloatRegister Rn) {\n-    assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");\n-    starti;\n-    f(0, 31), f(T & 1, 30), f(0b0011101, 29, 23);\n-    f((T >> 1) & 1, 22), f(0b100001101110, 21, 10);\n-    rf(Rn, 5), rf(Rd, 0);\n-  }\n-\n@@ -2832,0 +2823,1 @@\n+  \/\/ Advanced SIMD scalar copy\n@@ -2918,0 +2910,1 @@\n+  INSN(fcvtzv, 0, 0b10, 0b01, 0b11011); \/\/ converts each element in a vector from a floating-point value to a signed integer value, and Arm's name is fcvtzs\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1539,1 +1539,1 @@\n-                        [\"fcvtzv\", \"__ fcvtzv(__ T4S, v0, v1);\",                         \"fcvtzs\\tv0.4s, v1.4s\"],\n+                        [\"fcvtzv\", \"__ fcvtzv(v0, __ T4S, v1);\",                         \"fcvtzs\\tv0.4s, v1.4s\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -729,1 +729,1 @@\n-    __ fcvtzv(__ T4S, v0, v1);                         \/\/       fcvtzs  v0.4s, v1.4s\n+    __ fcvtzv(v0, __ T4S, v1);                         \/\/       fcvtzs  v0.4s, v1.4s\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}