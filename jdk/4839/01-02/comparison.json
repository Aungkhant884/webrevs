{"files":[{"patch":"@@ -2428,0 +2428,3 @@\n+    \/\/ We don't have VectorReinterpret with bit_size less than 64 support for\n+    \/\/ now, even for byte type. To be refined with fully VectorCast support.\n+    case Op_VectorReinterpret:\n@@ -2445,0 +2448,5 @@\n+    case Op_VectorCastS2X:\n+      if (vlen < 4 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,2 +155,1 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 64 bits of 'src' are expected to have been initialized\n+    \/\/ The upper 64 bits of 'src' are expected to have been initialized\n@@ -158,5 +157,3 @@\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    }\n+    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n@@ -184,2 +181,1 @@\n-\n-instruct reinterpretStoX(vecX dst, vecD src)\n+instruct reinterpretS2X(vecX dst, vecD src)\n@@ -191,19 +187,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# S to X\" %}\n-  ins_encode %{\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper bits of \"src\" are expected to have been initialized\n-    \/\/ to zero.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretStoD(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S to D\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# S2X\" %}\n@@ -211,35 +189,1 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper bits of \"src\" are expected to have been initialized\n-    \/\/ to zero.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretXtoS(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X to S\" %}\n-  ins_encode %{\n-    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n-    \/\/ of the \"dst\" register must be cleared to zero.\n-    __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretDtoS(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# D to S\" %}\n-  ins_encode %{\n-    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n-    \/\/ of the \"dst\" register must be cleared to zero.\n+    \/\/ The upper bits of \"src\" are expected to have been initialized to zero.\n@@ -253,11 +197,0 @@\n-instruct vcvt4Bto4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\t# convert 4B to 4S vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -275,11 +208,0 @@\n-instruct vcvt4Sto4B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\t# convert 4S to 4B vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -308,11 +230,0 @@\n-instruct vcvt2Sto2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl  $dst, T4S, $src, T4H\\t# convert 2S to 2I vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -352,28 +263,0 @@\n-instruct vcvt4Bto4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\t# convert 4B to 4I vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Bto2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\t# convert 2B to 2I vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -394,96 +277,0 @@\n-instruct vcvt2Sto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl  $dst, T4S, $src, T4H\\n\\t\"\n-            \"sxtl  $dst, T2D, $dst, T2S\\t# convert 2S to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Bto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\n\\t\"\n-            \"sxtl  $dst, T2D, $dst, T2S\\t # convert 2B to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Bto2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"sxtl    $dst, T2D, $dst, T2S\\n\\t\"\n-            \"scvtfv  T2D, $dst, $dst\\t # convert 2B to 2D vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-instruct vcvt4Bto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4B to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Bto2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 2B to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Sto2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl    $dst, T4S, $src, T4H\\n\\t\"\n-            \"sxtl    $dst, T2D, $dst, T2S\\n\\t\"\n-            \"scvtfv  T2D, $dst, $dst\\t# convert 2S to 2D vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n@@ -537,14 +324,0 @@\n-instruct vcvt2Sto2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl    $dst, T4S, $src, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 2S to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":7,"deletions":234,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -107,2 +107,1 @@\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper 64 bits of 'src' are expected to have been initialized\n+    \/\/ The upper 64 bits of 'src' are expected to have been initialized\n@@ -110,5 +109,3 @@\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    }\n+    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n@@ -136,3 +133,1 @@\n-dnl\n-define(`REINTERPRET_S2XD', `\n-instruct reinterpret$1to$2`'(vec$3 dst, vec$4 src)\n+instruct reinterpretS2X(vecX dst, vecD src)\n@@ -140,24 +135,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n-  ins_encode %{\n-    \/\/ If registers are the same, no register move is required - the\n-    \/\/ upper bits of \"src\" are expected to have been initialized\n-    \/\/ to zero.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ dups(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl              $1 $2 $3 $4 $5  $6\n-REINTERPRET_S2XD(S, X, X, D, 16, 4)\n-REINTERPRET_S2XD(S, D, D, D, 8,  4)\n-dnl\n-define(`REINTERPRET_XD2S', `\n-instruct reinterpret$1to$2`'(vec$3 dst, vec$4 src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n@@ -166,1 +139,1 @@\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# S2X\" %}\n@@ -168,2 +141,1 @@\n-    \/\/ Resize the vector from 128-bits or 64-bits to 32-bits. The higher bits\n-    \/\/ of the \"dst\" register must be cleared to zero.\n+    \/\/ The upper bits of \"src\" are expected to have been initialized to zero.\n@@ -173,5 +145,1 @@\n-%}')dnl\n-dnl              $1 $2 $3 $4 $5 $6\n-REINTERPRET_XD2S(X, S, D, X, 4, 16)\n-REINTERPRET_XD2S(D, S, D, D, 4, 8)\n-dnl\n+%}\n@@ -193,1 +161,0 @@\n-VECTOR_CAST_I2I(4, B, S, D, D, sxtl, 8B, 8H)\n@@ -195,1 +162,0 @@\n-VECTOR_CAST_I2I(4, S, B, D, D, xtn,  8H, 8B)\n@@ -198,1 +164,0 @@\n-VECTOR_CAST_I2I(2, S, I, D, D, sxtl, 4H, 4S)\n@@ -203,35 +168,0 @@\n-define(`VECTOR_CAST_I2I_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"$6  $dst, T$8, $src, T$7\\n\\t\"\n-            \"$6  $dst, T$10, $dst, T$9\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$8, as_FloatRegister($src$$reg), __ T$7);\n-    __ $6(as_FloatRegister($dst$$reg), __ T$10, as_FloatRegister($dst$$reg), __ T$9);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6    $7  $8  $9  $10\n-VECTOR_CAST_I2I_L(4, B, I, X, D, sxtl, 8B, 8H, 4H, 4S)\n-VECTOR_CAST_I2I_L(2, B, I, D, D, sxtl, 8B, 8H, 4H, 4S)\n-VECTOR_CAST_I2I_L(4, I, B, D, X, xtn,  4S, 4H, 8H, 8B)\n-VECTOR_CAST_I2I_L(2, S, L, X, D, sxtl, 4H, 4S, 2S, 2D)\n-\n-instruct vcvt2Bto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\n\\t\"\n-            \"sxtl  $dst, T2D, $dst, T2S\\t # convert 2B to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n@@ -239,1 +169,1 @@\n-instruct vcvt2Bto2D(vecX dst, vecD src)\n+instruct vcvt4Ito4B(vecD dst, vecX src)\n@@ -241,6 +171,4 @@\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"sxtl    $dst, T2D, $dst, T2S\\n\\t\"\n-            \"scvtfv  T2D, $dst, $dst\\t # convert 2B to 2D vector\"\n+  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastI2X src));\n+  format %{ \"xtn  $dst, T4H, $src, T4S\\n\\t\"\n+            \"xtn  $dst, T8B, $dst, T8H\\t# convert 4I to 4B vector\"\n@@ -249,4 +177,2 @@\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n+    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n+    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n@@ -257,21 +183,0 @@\n-dnl\n-define(`VECTOR_CAST_I2F_LL', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"sxtl    $dst, T$7, $src, T$6\\n\\t\"\n-            \"sxtl    $dst, T$9, $dst, T$8\\n\\t\"\n-            \"scvtfv  T$9, $dst, $dst\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($src$$reg), __ T$6);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T$9, as_FloatRegister($dst$$reg), __ T$8);\n-    __ scvtfv(__ T$9, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1 $2 $3 $4 $5 $6  $7  $8  $9\n-VECTOR_CAST_I2F_LL(4, B, F, X, D, 8B, 8H, 4H, 4S)\n-VECTOR_CAST_I2F_LL(2, B, F, D, D, 8B, 8H, 4H, 4S)\n-VECTOR_CAST_I2F_LL(2, S, D, X, D, 4H, 4S, 2S, 2D)\n@@ -315,1 +220,0 @@\n-VECTOR_CAST_I2F_L(2, S, F, D, D, 4H, 4S)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":17,"deletions":113,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1525,1 +1525,1 @@\n-                        [\"dups\",   \"__ dups(v0, __ T2S, v1);\",                           \"mov\\ts0, v1.s[0]\"],\n+                        [\"dups\",   \"__ dups(v0, __ T2S, v1);\",                           \"dup\\ts0, v1.s[0]\"],\n@@ -1541,1 +1541,1 @@\n-                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"cpy\\tz0.s, p0\/m, s1\"],\n@@ -1692,1 +1692,2 @@\n-print \"\\n  };\"\n+print\n+print \"  };\"\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -715,1 +715,1 @@\n-    __ dups(v0, __ T2S, v1);                           \/\/       mov     s0, v1.s[0]\n+    __ dups(v0, __ T2S, v1);                           \/\/       dup     s0, v1.s[0]\n@@ -730,1 +730,1 @@\n-    __ sve_cpy(z0, __ S, p0, v1);                      \/\/       mov     z0.s, p0\/m, s1\n+    __ sve_cpy(z0, __ S, p0, v1);                      \/\/       cpy     z0.s, p0\/m, s1\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}