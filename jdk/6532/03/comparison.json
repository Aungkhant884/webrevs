{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.function.Function;\n@@ -311,0 +312,37 @@\n+    \/**\n+     * Finds an interesting index for a key such that the key is present\n+     * at that index in the table, or an open index where the key could\n+     * be stored. Guaranteed that {@code tab[ret] == null} or {@code\n+     * tab[ret] == key}.\n+     *\n+     * @param tab the hash table\n+     * @param key the key, null-masked\n+     * @return the index found\n+     *\/\n+    private static int findInterestingIndex(Object[] tab, Object key) {\n+        final int len = tab.length;\n+        Object item;\n+        int i = hash(key, len);\n+        while ((item = tab[i]) != key && item != null) {\n+            i = nextKeyIndex(i, len);\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Finds an open index where the key could be stored. Guaranteed that\n+     * {@code tab[ret] == null}.\n+     *\n+     * @param tab the hash table\n+     * @param key the key, null-masked\n+     * @return the index found\n+     *\/\n+    private static int findOpenIndex(Object[] tab, Object key) {\n+        final int len = tab.length;\n+        int i = hash(key, len);\n+        while (tab[i] != null) {\n+            i = nextKeyIndex(i, len);\n+        }\n+        return i;\n+    }\n+\n@@ -328,1 +366,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -330,12 +367,1 @@\n-        Object k = maskNull(key);\n-        Object[] tab = table;\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return (V) tab[i + 1];\n-            if (item == null)\n-                return null;\n-            i = nextKeyIndex(i, len);\n-        }\n+        return getOrDefault(key, null);\n@@ -356,10 +382,1 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return true;\n-            if (item == null)\n-                return false;\n-            i = nextKeyIndex(i, len);\n-        }\n+        return tab[findInterestingIndex(tab, k)] == k;\n@@ -397,10 +414,2 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return tab[i + 1] == value;\n-            if (item == null)\n-                return false;\n-            i = nextKeyIndex(i, len);\n-        }\n+        int i = findInterestingIndex(tab, k);\n+        return tab[i] == k && tab[i + 1] == value;\n@@ -425,29 +434,1 @@\n-        final Object k = maskNull(key);\n-\n-        retryAfterResize: for (;;) {\n-            final Object[] tab = table;\n-            final int len = tab.length;\n-            int i = hash(k, len);\n-\n-            for (Object item; (item = tab[i]) != null;\n-                 i = nextKeyIndex(i, len)) {\n-                if (item == k) {\n-                    @SuppressWarnings(\"unchecked\")\n-                        V oldValue = (V) tab[i + 1];\n-                    tab[i + 1] = value;\n-                    return oldValue;\n-                }\n-            }\n-\n-            final int s = size + 1;\n-            \/\/ Use optimized form of 3 * s.\n-            \/\/ Next capacity is len, 2 * current capacity.\n-            if (s + (s << 1) > len && resize(len))\n-                continue retryAfterResize;\n-\n-            modCount++;\n-            tab[i] = k;\n-            tab[i + 1] = value;\n-            size = s;\n-            return null;\n-        }\n+        return put(key, value, true);\n@@ -484,3 +465,1 @@\n-                int i = hash(key, newLength);\n-                while (newTable[i] != null)\n-                    i = nextKeyIndex(i, newLength);\n+                int i = findOpenIndex(newTable, key);\n@@ -526,19 +505,8 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k) {\n-                modCount++;\n-                size--;\n-                @SuppressWarnings(\"unchecked\")\n-                    V oldValue = (V) tab[i + 1];\n-                tab[i + 1] = null;\n-                tab[i] = null;\n-                closeDeletion(i);\n-                return oldValue;\n-            }\n-            if (item == null)\n-                return null;\n-            i = nextKeyIndex(i, len);\n-        }\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            V oldValue = (V) tab[i + 1];\n+            delete(tab, i);\n+            return oldValue;\n+        } else\n+            return null;\n@@ -558,16 +526,3 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k) {\n-                if (tab[i + 1] != value)\n-                    return false;\n-                modCount++;\n-                size--;\n-                tab[i] = null;\n-                tab[i + 1] = null;\n-                closeDeletion(i);\n-                return true;\n-            }\n-            if (item == null)\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            if (tab[i + 1] != value)\n@@ -575,2 +530,4 @@\n-            i = nextKeyIndex(i, len);\n-        }\n+            delete(tab, i);\n+            return true;\n+        } else\n+            return false;\n@@ -1382,0 +1339,271 @@\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public V getOrDefault(Object key, V fallback) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        return tab[i] == k ? (V) tab[i + 1] : fallback;\n+    }\n+\n+    @Override\n+    public V putIfAbsent(K key, V value) {\n+        return put(key, value, false);\n+    }\n+\n+    @Override\n+    public V replace(K key, V value) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V prev = (V) tab[i + 1];\n+            tab[i + 1] = value;\n+            return prev;\n+        } else\n+            return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * mapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * mapping function modified this map\n+     *\/\n+    @Override\n+    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n+        Objects.requireNonNull(mappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            if (oldValue != null)\n+                return oldValue;\n+\n+            \/\/ replace null old value, per specification\n+            final V newValue = callFunction(key, mappingFunction);\n+            if (newValue != null) {\n+                tab[i + 1] = newValue;\n+            }\n+            return newValue;\n+        } else\n+            return maybeAddNewEntry(tab, i, k, callFunction(key, mappingFunction));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            if (oldValue == null) {\n+                return null;\n+            }\n+\n+            return updateByNewValue(tab, i, callFunction(key, oldValue, remappingFunction));\n+        } else\n+            return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            return updateByNewValue(tab, i, callFunction(key, oldValue, remappingFunction));\n+        } else\n+            return maybeAddNewEntry(tab, i, k, callFunction(key, null, remappingFunction));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            return updateByNewValue(tab, i, mergeValue(oldValue, value, remappingFunction));\n+        } else\n+            return maybeAddNewEntry(tab, i, k, value);\n+    }\n+\n+    private V callFunction(K key, Function<? super K, ? extends V> function) {\n+        final int expectedModCount = modCount;\n+        V result = function.apply(key);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V callFunction(K key, V value, BiFunction<? super K, ? super V, ? extends V> function) {\n+        final int expectedModCount = modCount;\n+        V result = function.apply(key, value);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V mergeValue(V oldValue, V value, BiFunction<? super V, ? super V, ? extends V> function) {\n+        if (oldValue == null) {\n+            return value;\n+        }\n+\n+        final int expectedModCount = modCount;\n+        V result = function.apply(oldValue, value);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V updateByNewValue(Object[] tab, int i, V newValue) {\n+        if (newValue != null) {\n+            tab[i + 1] = newValue;\n+        } else {\n+            delete(tab, i);\n+        }\n+        return newValue;\n+    }\n+\n+    \/**\n+     * Deletes a mapping from this map's table. Increases modCount as it\n+     * changes map size.\n+     *\n+     * @param tab the table, should be equivalent to {@code this.table}\n+     * @param i the index of the object to delete\n+     *\/\n+    private void delete(Object[] tab, int i) {\n+        modCount++;\n+        size--;\n+        tab[i] = null;\n+        tab[i + 1] = null;\n+        closeDeletion(i);\n+    }\n+\n+    \/**\n+     * Shared implementation of put and putIfAbsent.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param value value to be associated with the specified key\n+     * @param replace whether a non-null existing value is to be replaced if the key is present\n+     * @return the value associated to the key before the call, or {@code null} if\n+     * there was no previously associated value\n+     *\/\n+    private V put(K key, V value, boolean replace) {\n+        final Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            V oldValue = (V) tab[i + 1];\n+            if (replace || oldValue == null) {\n+                tab[i + 1] = value;\n+            }\n+            return oldValue;\n+        }\n+\n+        addNewEntry(tab, i, k, value);\n+        return null;\n+    }\n+\n+    \/**\n+     * Adds an entry to this map if and only if {@code newValue} is not null.\n+     *\n+     * @param tab the hash table of this map, may be reused\n+     * @param i the current index of k in the table\n+     * @param k the key\n+     * @param newValue the value\n+     * @return the value\n+     *\/\n+    private V maybeAddNewEntry(Object[] tab, int i, Object k, V newValue) {\n+        if (newValue == null) {\n+            return null;\n+        }\n+\n+        return addNewEntry(tab, i, k, newValue);\n+    }\n+\n+    \/**\n+     * Adds a new entry to this map, associating {@code k} with the {@code newValue}.\n+     * Accepts null values. Increases modCount as it changes map size.\n+     *\n+     * @param tab the hash table of this map, may be reused\n+     * @param i the current index of k in the table\n+     * @param k the key\n+     * @param newValue the value\n+     * @return the value\n+     *\/\n+    private V addNewEntry(Object[] tab, int i, Object k, V newValue) {\n+        int len = tab.length;\n+        do {\n+            final int s = size + 1;\n+            \/\/ Use optimized form of 3 * s.\n+            \/\/ Next capacity is len, 2 * current capacity.\n+            if (!(s + (s << 1) > len && resize(len)))\n+                break;\n+\n+            tab = table;\n+            len = tab.length;\n+            \/\/ findInterestingIndex should return the same value here\n+            i = findOpenIndex(tab, k);\n+        } while (true);\n+\n+        modCount++;\n+        tab[i] = k;\n+        tab[i + 1] = newValue;\n+        size++;\n+        return newValue;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":330,"deletions":102,"binary":false,"changes":432,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.IdentityHashMap;\n@@ -58,0 +59,1 @@\n+                new Object[]{new IdentityHashMap<>(), true},\n","filename":"test\/jdk\/java\/util\/Map\/FunctionalCMEs.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class IdentityHashMapBench {\n+    private Supplier<Map<Object, Object>> mapSupplier;\n+    private Object[] objects;\n+    \/\/ orders, 2 * i th is key, 2* i+1 th is value\n+    private Object[] orders;\n+\n+    @Param(\"1000000\")\n+    private int orderSize;\n+\n+    @Param(\"100000\")\n+    private int size;\n+\n+    @Setup @TearDown\n+    public void setup() {\n+        mapSupplier = IdentityHashMap::new;\n+\n+        {\n+            final int size = this.size;\n+            final Object[] objects = new Object[size];\n+            for (int i = 0; i < size; i++) {\n+                objects[i] = new Object();\n+            }\n+            this.objects = objects;\n+        }\n+\n+        {\n+            ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+            final int poolSize = this.size;\n+            final Object[] objects = this.objects;\n+            final int size = this.orderSize;\n+            final Object[] orders = new Object[size];\n+            for (int i = 0; i < size; i++) {\n+                orders[i] = objects[rnd.nextInt(poolSize)];\n+            }\n+            this.orders = orders;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int putBench(Blackhole blackhole) {\n+        var map = mapSupplier.get();\n+        final Object[] data = this.objects;\n+        final int len = data.length;\n+        for (int i = 0; i < len; i += 2) {\n+            blackhole.consume(map.put(data[i], data[i + 1]));\n+        }\n+        return map.size();\n+    }\n+\n+    @Benchmark\n+    public int putIfAbsentBench(Blackhole blackhole) {\n+        var map = mapSupplier.get();\n+        final Object[] data = this.objects;\n+        final int len = data.length;\n+        for (int i = 0; i < len; i += 2) {\n+            blackhole.consume(map.putIfAbsent(data[i], data[i + 1]));\n+        }\n+        return map.size();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/IdentityHashMapBench.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}