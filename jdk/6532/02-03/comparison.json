{"files":[{"patch":"@@ -1,105 +1,105 @@\n-\/*\r\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package org.openjdk.bench.java.util;\r\n-\r\n-import org.openjdk.jmh.annotations.Benchmark;\r\n-import org.openjdk.jmh.annotations.BenchmarkMode;\r\n-import org.openjdk.jmh.annotations.Mode;\r\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\r\n-import org.openjdk.jmh.annotations.Param;\r\n-import org.openjdk.jmh.annotations.Scope;\r\n-import org.openjdk.jmh.annotations.Setup;\r\n-import org.openjdk.jmh.annotations.State;\r\n-import org.openjdk.jmh.annotations.TearDown;\r\n-import org.openjdk.jmh.infra.Blackhole;\r\n-\r\n-import java.util.IdentityHashMap;\r\n-import java.util.Map;\r\n-import java.util.concurrent.ThreadLocalRandom;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.function.Supplier;\r\n-\r\n-@BenchmarkMode(Mode.AverageTime)\r\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\r\n-@State(Scope.Thread)\r\n-public class IdentityHashMapBench {\r\n-    private Supplier<Map<Object, Object>> mapSupplier;\r\n-    private Object[] objects;\r\n-    \/\/ orders, 2 * i th is key, 2* i+1 th is value\r\n-    private Object[] orders;\r\n-\r\n-    @Param(\"1000000\")\r\n-    private int orderSize;\r\n-\r\n-    @Param(\"100000\")\r\n-    private int size;\r\n-\r\n-    @Setup @TearDown\r\n-    public void setup() {\r\n-        mapSupplier = IdentityHashMap::new;\r\n-\r\n-        {\r\n-            final int size = this.size;\r\n-            final Object[] objects = new Object[size];\r\n-            for (int i = 0; i < size; i++) {\r\n-                objects[i] = new Object();\r\n-            }\r\n-            this.objects = objects;\r\n-        }\r\n-\r\n-        {\r\n-            ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n-            final int poolSize = this.size;\r\n-            final Object[] objects = this.objects;\r\n-            final int size = this.orderSize;\r\n-            final Object[] orders = new Object[size];\r\n-            for (int i = 0; i < size; i++) {\r\n-                orders[i] = objects[rnd.nextInt(poolSize)];\r\n-            }\r\n-            this.orders = orders;\r\n-        }\r\n-    }\r\n-\r\n-    @Benchmark\r\n-    public int putBench(Blackhole blackhole) {\r\n-        var map = mapSupplier.get();\r\n-        final Object[] data = this.objects;\r\n-        final int len = data.length;\r\n-        for (int i = 0; i < len; i += 2) {\r\n-            blackhole.consume(map.put(data[i], data[i + 1]));\r\n-        }\r\n-        return map.size();\r\n-    }\r\n-\r\n-    @Benchmark\r\n-    public int putIfAbsentBench(Blackhole blackhole) {\r\n-        var map = mapSupplier.get();\r\n-        final Object[] data = this.objects;\r\n-        final int len = data.length;\r\n-        for (int i = 0; i < len; i += 2) {\r\n-            blackhole.consume(map.putIfAbsent(data[i], data[i + 1]));\r\n-        }\r\n-        return map.size();\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class IdentityHashMapBench {\n+    private Supplier<Map<Object, Object>> mapSupplier;\n+    private Object[] objects;\n+    \/\/ orders, 2 * i th is key, 2* i+1 th is value\n+    private Object[] orders;\n+\n+    @Param(\"1000000\")\n+    private int orderSize;\n+\n+    @Param(\"100000\")\n+    private int size;\n+\n+    @Setup @TearDown\n+    public void setup() {\n+        mapSupplier = IdentityHashMap::new;\n+\n+        {\n+            final int size = this.size;\n+            final Object[] objects = new Object[size];\n+            for (int i = 0; i < size; i++) {\n+                objects[i] = new Object();\n+            }\n+            this.objects = objects;\n+        }\n+\n+        {\n+            ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+            final int poolSize = this.size;\n+            final Object[] objects = this.objects;\n+            final int size = this.orderSize;\n+            final Object[] orders = new Object[size];\n+            for (int i = 0; i < size; i++) {\n+                orders[i] = objects[rnd.nextInt(poolSize)];\n+            }\n+            this.orders = orders;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int putBench(Blackhole blackhole) {\n+        var map = mapSupplier.get();\n+        final Object[] data = this.objects;\n+        final int len = data.length;\n+        for (int i = 0; i < len; i += 2) {\n+            blackhole.consume(map.put(data[i], data[i + 1]));\n+        }\n+        return map.size();\n+    }\n+\n+    @Benchmark\n+    public int putIfAbsentBench(Blackhole blackhole) {\n+        var map = mapSupplier.get();\n+        final Object[] data = this.objects;\n+        final int len = data.length;\n+        for (int i = 0; i < len; i += 2) {\n+            blackhole.consume(map.putIfAbsent(data[i], data[i + 1]));\n+        }\n+        return map.size();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/IdentityHashMapBench.java","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"}]}