{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.util.function.Function;\n@@ -309,0 +310,37 @@\n+    \/**\n+     * Finds an interesting index for a key such that the key is present\n+     * at that index in the table, or an open index where the key could\n+     * be stored. Guaranteed that {@code tab[ret] == null} or {@code\n+     * tab[ret] == key}.\n+     *\n+     * @param tab the hash table\n+     * @param key the key, null-masked\n+     * @return the index found\n+     *\/\n+    private static int findInterestingIndex(Object[] tab, Object key) {\n+        final int len = tab.length;\n+        Object item;\n+        int i = hash(key, len);\n+        while ((item = tab[i]) != key && item != null) {\n+            i = nextKeyIndex(i, len);\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Finds an open index where the key could be stored. Guaranteed that\n+     * {@code tab[ret] == null}.\n+     *\n+     * @param tab the hash table\n+     * @param key the key, null-masked\n+     * @return the index found\n+     *\/\n+    private static int findOpenIndex(Object[] tab, Object key) {\n+        final int len = tab.length;\n+        int i = hash(key, len);\n+        while (tab[i] != null) {\n+            i = nextKeyIndex(i, len);\n+        }\n+        return i;\n+    }\n+\n@@ -326,1 +364,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -328,12 +365,1 @@\n-        Object k = maskNull(key);\n-        Object[] tab = table;\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return (V) tab[i + 1];\n-            if (item == null)\n-                return null;\n-            i = nextKeyIndex(i, len);\n-        }\n+        return getOrDefault(key, null);\n@@ -354,10 +380,1 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return true;\n-            if (item == null)\n-                return false;\n-            i = nextKeyIndex(i, len);\n-        }\n+        return tab[findInterestingIndex(tab, k)] == k;\n@@ -395,10 +412,2 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k)\n-                return tab[i + 1] == value;\n-            if (item == null)\n-                return false;\n-            i = nextKeyIndex(i, len);\n-        }\n+        int i = findInterestingIndex(tab, k);\n+        return tab[i] == k && tab[i + 1] == value;\n@@ -423,29 +432,1 @@\n-        final Object k = maskNull(key);\n-\n-        retryAfterResize: for (;;) {\n-            final Object[] tab = table;\n-            final int len = tab.length;\n-            int i = hash(k, len);\n-\n-            for (Object item; (item = tab[i]) != null;\n-                 i = nextKeyIndex(i, len)) {\n-                if (item == k) {\n-                    @SuppressWarnings(\"unchecked\")\n-                        V oldValue = (V) tab[i + 1];\n-                    tab[i + 1] = value;\n-                    return oldValue;\n-                }\n-            }\n-\n-            final int s = size + 1;\n-            \/\/ Use optimized form of 3 * s.\n-            \/\/ Next capacity is len, 2 * current capacity.\n-            if (s + (s << 1) > len && resize(len))\n-                continue retryAfterResize;\n-\n-            modCount++;\n-            tab[i] = k;\n-            tab[i + 1] = value;\n-            size = s;\n-            return null;\n-        }\n+        return put(key, value, true);\n@@ -482,3 +463,1 @@\n-                int i = hash(key, newLength);\n-                while (newTable[i] != null)\n-                    i = nextKeyIndex(i, newLength);\n+                int i = findOpenIndex(newTable, key);\n@@ -524,19 +503,8 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k) {\n-                modCount++;\n-                size--;\n-                @SuppressWarnings(\"unchecked\")\n-                    V oldValue = (V) tab[i + 1];\n-                tab[i + 1] = null;\n-                tab[i] = null;\n-                closeDeletion(i);\n-                return oldValue;\n-            }\n-            if (item == null)\n-                return null;\n-            i = nextKeyIndex(i, len);\n-        }\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            V oldValue = (V) tab[i + 1];\n+            delete(tab, i);\n+            return oldValue;\n+        } else\n+            return null;\n@@ -556,16 +524,3 @@\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == k) {\n-                if (tab[i + 1] != value)\n-                    return false;\n-                modCount++;\n-                size--;\n-                tab[i] = null;\n-                tab[i + 1] = null;\n-                closeDeletion(i);\n-                return true;\n-            }\n-            if (item == null)\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            if (tab[i + 1] != value)\n@@ -573,2 +528,4 @@\n-            i = nextKeyIndex(i, len);\n-        }\n+            delete(tab, i);\n+            return true;\n+        } else\n+            return false;\n@@ -1378,0 +1335,271 @@\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public V getOrDefault(Object key, V fallback) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        return tab[i] == k ? (V) tab[i + 1] : fallback;\n+    }\n+\n+    @Override\n+    public V putIfAbsent(K key, V value) {\n+        return put(key, value, false);\n+    }\n+\n+    @Override\n+    public V replace(K key, V value) {\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V prev = (V) tab[i + 1];\n+            tab[i + 1] = value;\n+            return prev;\n+        } else\n+            return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * mapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * mapping function modified this map\n+     *\/\n+    @Override\n+    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n+        Objects.requireNonNull(mappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            if (oldValue != null)\n+                return oldValue;\n+\n+            \/\/ replace null old value, per specification\n+            final V newValue = callFunction(key, mappingFunction);\n+            if (newValue != null) {\n+                tab[i + 1] = newValue;\n+            }\n+            return newValue;\n+        } else\n+            return maybeAddNewEntry(tab, i, k, callFunction(key, mappingFunction));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            if (oldValue == null) {\n+                return null;\n+            }\n+\n+            return updateByNewValue(tab, i, callFunction(key, oldValue, remappingFunction));\n+        } else\n+            return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            return updateByNewValue(tab, i, callFunction(key, oldValue, remappingFunction));\n+        } else\n+            return maybeAddNewEntry(tab, i, k, callFunction(key, null, remappingFunction));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * <p>This method will, on a best-effort basis, throw a\n+     * {@link ConcurrentModificationException} if it is detected that the\n+     * remapping function modifies this map during computation.\n+     *\n+     * @throws ConcurrentModificationException if it is detected that the\n+     * remapping function modified this map\n+     *\/\n+    @Override\n+    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(remappingFunction);\n+\n+        Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            final V oldValue = (V) tab[i + 1];\n+            return updateByNewValue(tab, i, mergeValue(oldValue, value, remappingFunction));\n+        } else\n+            return maybeAddNewEntry(tab, i, k, value);\n+    }\n+\n+    private V callFunction(K key, Function<? super K, ? extends V> function) {\n+        final int expectedModCount = modCount;\n+        V result = function.apply(key);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V callFunction(K key, V value, BiFunction<? super K, ? super V, ? extends V> function) {\n+        final int expectedModCount = modCount;\n+        V result = function.apply(key, value);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V mergeValue(V oldValue, V value, BiFunction<? super V, ? super V, ? extends V> function) {\n+        if (oldValue == null) {\n+            return value;\n+        }\n+\n+        final int expectedModCount = modCount;\n+        V result = function.apply(oldValue, value);\n+        if (expectedModCount != modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return result;\n+    }\n+\n+    private V updateByNewValue(Object[] tab, int i, V newValue) {\n+        if (newValue != null) {\n+            tab[i + 1] = newValue;\n+        } else {\n+            delete(tab, i);\n+        }\n+        return newValue;\n+    }\n+\n+    \/**\n+     * Deletes a mapping from this map's table. Increases modCount as it\n+     * changes map size.\n+     *\n+     * @param tab the table, should be equivalent to {@code this.table}\n+     * @param i the index of the object to delete\n+     *\/\n+    private void delete(Object[] tab, int i) {\n+        modCount++;\n+        size--;\n+        tab[i] = null;\n+        tab[i + 1] = null;\n+        closeDeletion(i);\n+    }\n+\n+    \/**\n+     * Shared implementation of put and putIfAbsent.\n+     *\n+     * @param key key with which the specified value is to be associated\n+     * @param value value to be associated with the specified key\n+     * @param replace whether a non-null existing value is to be replaced if the key is present\n+     * @return the value associated to the key before the call, or {@code null} if\n+     * there was no previously associated value\n+     *\/\n+    private V put(K key, V value, boolean replace) {\n+        final Object k = maskNull(key);\n+        Object[] tab = table;\n+        int i = findInterestingIndex(tab, k);\n+        if (tab[i] == k) {\n+            @SuppressWarnings(\"unchecked\")\n+            V oldValue = (V) tab[i + 1];\n+            if (replace || oldValue == null) {\n+                tab[i + 1] = value;\n+            }\n+            return oldValue;\n+        }\n+\n+        addNewEntry(tab, i, k, value);\n+        return null;\n+    }\n+\n+    \/**\n+     * Adds an entry to this map if and only if {@code newValue} is not null.\n+     *\n+     * @param tab the hash table of this map, may be reused\n+     * @param i the current index of k in the table\n+     * @param k the key\n+     * @param newValue the value\n+     * @return the value\n+     *\/\n+    private V maybeAddNewEntry(Object[] tab, int i, Object k, V newValue) {\n+        if (newValue == null) {\n+            return null;\n+        }\n+\n+        return addNewEntry(tab, i, k, newValue);\n+    }\n+\n+    \/**\n+     * Adds a new entry to this map, associating {@code k} with the {@code newValue}.\n+     * Accepts null values. Increases modCount as it changes map size.\n+     *\n+     * @param tab the hash table of this map, may be reused\n+     * @param i the current index of k in the table\n+     * @param k the key\n+     * @param newValue the value\n+     * @return the value\n+     *\/\n+    private V addNewEntry(Object[] tab, int i, Object k, V newValue) {\n+        int len = tab.length;\n+        do {\n+            final int s = size + 1;\n+            \/\/ Use optimized form of 3 * s.\n+            \/\/ Next capacity is len, 2 * current capacity.\n+            if (!(s + (s << 1) > len && resize(len)))\n+                break;\n+\n+            tab = table;\n+            len = tab.length;\n+            \/\/ findInterestingIndex should return the same value here\n+            i = findOpenIndex(tab, k);\n+        } while (true);\n+\n+        modCount++;\n+        tab[i] = k;\n+        tab[i + 1] = newValue;\n+        size++;\n+        return newValue;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":330,"deletions":102,"binary":false,"changes":432,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.IdentityHashMap;\n@@ -58,0 +59,1 @@\n+                new Object[]{new IdentityHashMap<>(), true},\n","filename":"test\/jdk\/java\/util\/Map\/FunctionalCMEs.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}