{"files":[{"patch":"@@ -82,13 +82,0 @@\n-void G1BlockOffsetTablePart::update() {\n-  HeapWord* next_addr = _hr->bottom();\n-  HeapWord* const limit = _hr->top();\n-\n-  HeapWord* prev_addr;\n-  while (next_addr < limit) {\n-    prev_addr = next_addr;\n-    next_addr  = prev_addr + block_size(prev_addr);\n-    update_for_block(prev_addr, next_addr);\n-  }\n-  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n-}\n-\n@@ -278,1 +265,1 @@\n-        size_t obj_size = block_size(obj);\n+        size_t obj_size = _hr->block_size(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  friend class HeapRegion;\n@@ -117,1 +116,1 @@\n-  \/\/ The region that owns this subregion.\n+  \/\/ The region that owns this part of the BOT.\n@@ -124,11 +123,0 @@\n-  inline size_t block_size(const HeapWord* p) const;\n-\n-  \/\/ Returns the address of a block whose start is at most \"addr\".\n-  inline HeapWord* block_at_or_preceding(const void* addr) const;\n-\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the space.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr) const;\n-\n@@ -144,3 +132,0 @@\n-  \/\/ Verify that the block starting with q contains addr.\n-  void assert_addr_in_block(const void* addr, const HeapWord* q) const NOT_DEBUG_RETURN;\n-\n@@ -158,2 +143,0 @@\n-  void update();\n-\n@@ -162,5 +145,5 @@\n-  \/\/ Returns the address of the start of the block containing \"addr\".\n-  inline HeapWord* block_start(const void* addr) const;\n-  \/\/ Returns the address of the start of the block containing \"addr\", assuming that\n-  \/\/ the given address is card-aligned.\n-  inline HeapWord* block_start_aligned(const void* addr) const;\n+  void assert_same_bot_entry(const void* n, const void* addr) const NOT_DEBUG_RETURN;\n+\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  inline HeapWord* block_start_reaching_into_card(const void* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,4 +36,4 @@\n-inline void G1BlockOffsetTablePart::assert_addr_in_block(const void* addr, const HeapWord* q) const {\n-  assert(q <= addr, \"must be\");\n-  const HeapWord* n = q + block_size(q);\n-  assert(n > addr, \"must be\");\n+inline void G1BlockOffsetTablePart::assert_same_bot_entry(const void* n, const void* addr) const {\n+  assert(_bot->index_for(n) == _bot->index_for(addr),\n+         \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n+         _bot->index_for(n), _bot->index_for(addr));\n@@ -43,1 +43,1 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) const {\n+inline HeapWord* G1BlockOffsetTablePart::block_start_reaching_into_card(const void* addr) const {\n@@ -45,4 +45,0 @@\n-  HeapWord* q = block_at_or_preceding(addr);\n-  HeapWord* n = q + block_size(q);\n-  return forward_to_block_containing_addr(q, n, addr);\n-}\n@@ -50,3 +46,20 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start_aligned(const void* addr) const {\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n-  assert(is_aligned(addr, BOTConstants::card_size()), \"must be\");\n+#ifdef ASSERT\n+  if (!_hr->is_continues_humongous()) {\n+    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n+    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n+    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n+           offset, _hr->hrm_index(), _hr->get_short_type_str());\n+  }\n+#endif\n+\n+  size_t index = _bot->index_for(addr);\n+\n+  uint offset = _bot->offset_array(index);\n+  while (offset >= BOTConstants::card_size_in_words()) {\n+    \/\/ The excess of the offset from N_words indicates a power of Base\n+    \/\/ to go back by.\n+    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n+    index -= n_cards_back;\n+    offset = _bot->offset_array(index);\n+  }\n+  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n@@ -54,3 +67,2 @@\n-  HeapWord* q = block_at_or_preceding(addr);\n-  assert_addr_in_block(addr, q);\n-  return q;\n+  HeapWord* q = _bot->address_for_index(index);\n+  return q - offset;\n@@ -115,50 +127,0 @@\n-inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {\n-  return _hr->block_size(p);\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr) const {\n-#ifdef ASSERT\n-  if (!_hr->is_continues_humongous()) {\n-    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n-    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n-    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n-           offset, _hr->hrm_index(), _hr->get_short_type_str());\n-  }\n-#endif\n-\n-  size_t index = _bot->index_for(addr);\n-\n-  uint offset = _bot->offset_array(index);  \/\/ Extend u_char to uint.\n-  while (offset >= BOTConstants::card_size_in_words()) {\n-    \/\/ The excess of the offset from N_words indicates a power of Base\n-    \/\/ to go back by.\n-    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n-    index -= n_cards_back;\n-    offset = _bot->offset_array(index);\n-  }\n-  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n-\n-  HeapWord* q = _bot->address_for_index(index);\n-  return q - offset;\n-}\n-\n-inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                                          const void* addr) const {\n-  while (n <= addr) {\n-    \/\/ When addr is not covered by the block starting at q we need to\n-    \/\/ step forward until we find the correct block. With the BOT\n-    \/\/ being precise, we should never have to step through more than\n-    \/\/ a single card.\n-    assert(_bot->index_for(n) == _bot->index_for(addr),\n-           \"BOT not precise. Index for n: \" SIZE_FORMAT \" must be equal to the index for addr: \" SIZE_FORMAT,\n-           _bot->index_for(n), _bot->index_for(addr));\n-    q = n;\n-    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n-        \"start of block must be an initialized object\");\n-    n += block_size(q);\n-  }\n-  assert(q <= addr, \"wrong order for q and addr\");\n-  assert(addr < n, \"wrong order for addr and n\");\n-  return q;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":27,"deletions":65,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -267,0 +267,12 @@\n+void HeapRegion::update_bot() {\n+  HeapWord* next_addr = bottom();\n+  HeapWord* const limit = top();\n+\n+  HeapWord* prev_addr;\n+  while (next_addr < limit) {\n+    prev_addr = next_addr;\n+    next_addr  = prev_addr + block_size(prev_addr);\n+    _bot_part.update_for_block(prev_addr, next_addr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,1 +147,5 @@\n-  HeapWord* block_start_aligned(const void* p) const;\n+  \/\/ Return the address of the beginning of the block that contains \"addr\".\n+  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n+  \/\/ next block (or the end of the HeapRegion.)\n+  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                    const void* addr) const;\n@@ -150,1 +154,3 @@\n-  HeapWord* block_start(const void* p) const;\n+  \/\/ Returns the address of the block reaching into or starting at addr.\n+  HeapWord* block_start(const void* addr);\n+  HeapWord* block_start_aligned(const void* p) const;\n@@ -194,3 +200,1 @@\n-  void update_bot() {\n-    _bot_part.update();\n-  }\n+  void update_bot();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n@@ -82,2 +83,16 @@\n-inline HeapWord* HeapRegion::block_start_aligned(const void* p) const {\n-  return _bot_part.block_start_aligned(p);\n+inline HeapWord* HeapRegion::forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n+                                                              const void* addr) const {\n+  while (n <= addr) {\n+    \/\/ When addr is not covered by the block starting at q we need to\n+    \/\/ step forward until we find the correct block. With the BOT\n+    \/\/ being precise, we should never have to step through more than\n+    \/\/ a single card.\n+    _bot_part.assert_same_bot_entry(n, addr);\n+    q = n;\n+    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n+        \"start of block must be an initialized object\");\n+    n += block_size(q);\n+  }\n+  assert(q <= addr, \"wrong order for q and addr\");\n+  assert(addr < n, \"wrong order for addr and n\");\n+  return q;\n@@ -86,2 +101,11 @@\n-inline HeapWord* HeapRegion::block_start(const void* p) const {\n-  return _bot_part.block_start(p);\n+inline HeapWord* HeapRegion::block_start(const void* addr) {\n+  HeapWord* q = _bot_part.block_start_reaching_into_card(addr);\n+  \/\/ The returned address is the block that reaches into the card of addr. Walk\n+  \/\/ the heap to get to the block reaching into addr.\n+  HeapWord* n = q + block_size(q);\n+  return forward_to_block_containing_addr(q, n, addr);\n+}\n+\n+inline HeapWord* HeapRegion::block_start_aligned(const void* p) const {\n+  assert(is_aligned(p, BOTConstants::card_size_in_words()), \"must be\");\n+  return _bot_part.block_start_reaching_into_card(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"}]}