{"files":[{"patch":"@@ -140,1 +140,0 @@\n-public:\n@@ -145,0 +144,4 @@\n+  \/\/ Verify that the block starting with q contains addr.\n+  void assert_addr_in_block(const void* addr, const HeapWord* q) const NOT_DEBUG_RETURN;\n+\n+public:\n@@ -159,6 +162,5 @@\n-  \/\/ Returns the address of the start of the block containing \"addr\", or\n-  \/\/ else \"null\" if it is covered by no block.  (May have side effects,\n-  \/\/ namely updating of shared array entries that \"point\" too far\n-  \/\/ backwards.  This can occur, for example, when lab allocation is used\n-  \/\/ in a space covered by the table.)\n-  inline HeapWord* block_start(const void* addr);\n+  \/\/ Returns the address of the start of the block containing \"addr\".\n+  inline HeapWord* block_start(const void* addr) const;\n+  \/\/ Returns the address of the start of the block containing \"addr\", assuming that\n+  \/\/ the given address is card-aligned.\n+  inline HeapWord* block_start_aligned(const void* addr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,9 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) {\n+#ifdef ASSERT\n+inline void G1BlockOffsetTablePart::assert_addr_in_block(const void* addr, const HeapWord* q) const {\n+  assert(q <= addr, \"must be\");\n+  const HeapWord* n = q + block_size(q);\n+  assert(n > addr, \"must be\");\n+}\n+#endif\n+\n+inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) const {\n@@ -42,0 +50,9 @@\n+inline HeapWord* G1BlockOffsetTablePart::block_start_aligned(const void* addr) const {\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  assert(is_aligned(addr, BOTConstants::card_size()), \"must be\");\n+\n+  HeapWord* q = block_at_or_preceding(addr);\n+  assert_addr_in_block(addr, q);\n+  return q;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                  g1h->block_start(slice);\n+                                  r->block_start(slice);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+  HeapWord* block_start_aligned(const void* p) const;\n+\n@@ -148,1 +150,1 @@\n-  HeapWord* block_start(const void* p);\n+  HeapWord* block_start(const void* p) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,5 @@\n-inline HeapWord* HeapRegion::block_start(const void* p) {\n+inline HeapWord* HeapRegion::block_start_aligned(const void* p) const {\n+  return _bot_part.block_start_aligned(p);\n+}\n+\n+inline HeapWord* HeapRegion::block_start(const void* p) const {\n@@ -332,2 +336,3 @@\n-  \/\/ Find the obj that extends onto mr.start().\n-  HeapWord* cur = block_start(start);\n+  \/\/ Find the obj that extends onto mr.start(); in the concurrent phase the start\n+  \/\/ address is always aligned.\n+  HeapWord* cur = is_gc_active ? block_start(start) : block_start_aligned(start);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}