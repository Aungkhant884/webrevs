{"files":[{"patch":"@@ -123,12 +123,0 @@\n-  inline size_t block_size(const HeapWord* p) const;\n-\n-  \/\/ Returns the address of a block whose start is at most \"addr\".\n-  inline HeapWord* block_at_or_preceding(const void* addr) const;\n-\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the space.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr,\n-                                                    HeapWord* pb) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                  g1h->block_start(slice);\n+                                  r->block_start(slice);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  HeapWord* block_start_aligned(const void* p) const;\n@@ -283,1 +284,1 @@\n-  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* pb, Closure* cl);\n+  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n@@ -116,0 +117,5 @@\n+inline HeapWord* HeapRegion::block_start_aligned(const void* p) const {\n+  assert(is_aligned(p, BOTConstants::card_size()), \"must be\");\n+  return _bot_part.block_start_reaching_into_card(p);\n+}\n+\n@@ -405,2 +411,1 @@\n-inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* const pb, Closure* cl) {\n-  \/\/ Cache the boundaries of the area to scan in some locals.\n+inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl) {\n@@ -409,1 +414,1 @@\n-  HeapWord* const end = MIN2(mr.end(), pb);\n+  HeapWord* const end = mr.end();\n@@ -412,17 +417,0 @@\n-  \/\/ Find the obj that extends onto mr.start().\n-  \/\/\n-  \/\/ The BOT itself is stable enough to be read at any time as\n-  \/\/\n-  \/\/ * during refinement the individual elements of the BOT are read and written\n-  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n-  \/\/   to some (possibly outdated) object start.\n-  \/\/   The result of block_start() during concurrent refinement may be outdated - the\n-  \/\/   scrubbing may have written a (partial) filler object header exactly crossing\n-  \/\/   that perceived object start. So we have to advance to the next live object\n-  \/\/   (using the bitmap) to be able to start the following iteration.\n-  \/\/\n-  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n-  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n-  \/\/   safepoints.\n-  \/\/\n-  HeapWord* cur = block_start(start, pb);\n@@ -430,0 +418,6 @@\n+  HeapWord* cur = block_start;\n+  \/\/ The passed block_start may point at a dead block - during the concurrent phase the scrubbing\n+  \/\/ may have written a (partial) filler object header exactly crossing that perceived object\n+  \/\/ start; during GC pause this might just be a dead object that we should not read from.\n+  \/\/ So we have to advance to the next live object (using the bitmap) to be able to start\n+  \/\/ the following iteration over the objects.\n@@ -476,6 +470,19 @@\n-  \/\/ Find the obj that extends onto mr.start()\n-  HeapWord* cur;\n-  if (obj_in_parsable_area(start, pb)) {\n-    cur = block_start(start, pb);\n-  } else {\n-    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr, pb, cl);\n+  \/\/ Find the obj that extends onto mr.start(); first, in the concurrent phase the start\n+  \/\/ address is always aligned.\n+  \/\/\n+  \/\/ Second, the BOT itself is stable enough to be read at any time as\n+  \/\/\n+  \/\/ * during refinement the individual elements of the BOT are read and written\n+  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n+  \/\/   to some (possibly outdated) object start.\n+  \/\/\n+  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n+  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n+  \/\/   safepoints.\n+  \/\/\n+  HeapWord* cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n+  if (!obj_in_parsable_area(start, pb)) {\n+    \/\/ Limit the MemRegion to the part of the area to scan to the unparsable one as using the bitmap\n+    \/\/ is slower than blindly iterating the objects.\n+    MemRegion mr_in_unparsable(mr.start(), MIN2(mr.end(), pb));\n+    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr_in_unparsable, cur, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"}]}