{"files":[{"patch":"@@ -123,12 +123,0 @@\n-  inline size_t block_size(const HeapWord* p) const;\n-\n-  \/\/ Returns the address of a block whose start is at most \"addr\".\n-  inline HeapWord* block_at_or_preceding(const void* addr) const;\n-\n-  \/\/ Return the address of the beginning of the block that contains \"addr\".\n-  \/\/ \"q\" is a block boundary that is <= \"addr\"; \"n\" is the address of the\n-  \/\/ next block (or the end of the space.)\n-  inline HeapWord* forward_to_block_containing_addr(HeapWord* q, HeapWord* n,\n-                                                    const void* addr,\n-                                                    HeapWord* pb) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                  g1h->block_start(slice);\n+                                  r->block_start(slice);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  HeapWord* block_start_aligned(const void* p) const;\n@@ -282,1 +283,1 @@\n-  template <class Closure>\n+  template <class Closure, bool in_gc_pause>\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n@@ -116,0 +117,5 @@\n+inline HeapWord* HeapRegion::block_start_aligned(const void* p) const {\n+  assert(is_aligned(p, BOTConstants::card_size()), \"must be\");\n+  return _bot_part.block_start_reaching_into_card(p);\n+}\n+\n@@ -404,1 +410,1 @@\n-template <class Closure>\n+template <class Closure, bool in_gc_pause>\n@@ -428,1 +434,1 @@\n-  HeapWord* cur = block_start(start, pb);\n+  HeapWord* cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n@@ -479,1 +485,3 @@\n-    cur = block_start(start, pb);\n+    \/\/ Find the obj that extends onto mr.start(); in the concurrent phase the start\n+    \/\/ address is always aligned.\n+    cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n@@ -481,1 +489,1 @@\n-    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr, pb, cl);\n+    cur = oops_on_memregion_iterate_in_unparsable<Closure, in_gc_pause>(mr, pb, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}