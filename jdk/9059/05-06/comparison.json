{"files":[{"patch":"@@ -283,2 +283,2 @@\n-  template <class Closure, bool in_gc_pause>\n-  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* pb, Closure* cl);\n+  template <class Closure>\n+  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,3 +410,2 @@\n-template <class Closure, bool in_gc_pause>\n-inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* const pb, Closure* cl) {\n-  \/\/ Cache the boundaries of the area to scan in some locals.\n+template <class Closure>\n+inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl) {\n@@ -415,1 +414,1 @@\n-  HeapWord* const end = MIN2(mr.end(), pb);\n+  HeapWord* const end = mr.end();\n@@ -418,17 +417,0 @@\n-  \/\/ Find the obj that extends onto mr.start().\n-  \/\/\n-  \/\/ The BOT itself is stable enough to be read at any time as\n-  \/\/\n-  \/\/ * during refinement the individual elements of the BOT are read and written\n-  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n-  \/\/   to some (possibly outdated) object start.\n-  \/\/   The result of block_start() during concurrent refinement may be outdated - the\n-  \/\/   scrubbing may have written a (partial) filler object header exactly crossing\n-  \/\/   that perceived object start. So we have to advance to the next live object\n-  \/\/   (using the bitmap) to be able to start the following iteration.\n-  \/\/\n-  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n-  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n-  \/\/   safepoints.\n-  \/\/\n-  HeapWord* cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n@@ -436,0 +418,6 @@\n+  HeapWord* cur = block_start;\n+  \/\/ The passed block_start may point at a dead block - during the concurrent phase the scrubbing\n+  \/\/ may have written a (partial) filler object header exactly crossing that perceived object\n+  \/\/ start; during GC pause this might just be a dead object that we should not read from.\n+  \/\/ So we have to advance to the next live object (using the bitmap) to be able to start\n+  \/\/ the following iteration over the objects.\n@@ -482,8 +470,19 @@\n-  \/\/ Find the obj that extends onto mr.start()\n-  HeapWord* cur;\n-  if (obj_in_parsable_area(start, pb)) {\n-    \/\/ Find the obj that extends onto mr.start(); in the concurrent phase the start\n-    \/\/ address is always aligned.\n-    cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n-  } else {\n-    cur = oops_on_memregion_iterate_in_unparsable<Closure, in_gc_pause>(mr, pb, cl);\n+  \/\/ Find the obj that extends onto mr.start(); first, in the concurrent phase the start\n+  \/\/ address is always aligned.\n+  \/\/\n+  \/\/ Second, the BOT itself is stable enough to be read at any time as\n+  \/\/\n+  \/\/ * during refinement the individual elements of the BOT are read and written\n+  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n+  \/\/   to some (possibly outdated) object start.\n+  \/\/\n+  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n+  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n+  \/\/   safepoints.\n+  \/\/\n+  HeapWord* cur = in_gc_pause ? block_start(start, pb) : block_start_aligned(start);\n+  if (!obj_in_parsable_area(start, pb)) {\n+    \/\/ Limit the MemRegion to the part of the area to scan to the unparsable one as using the bitmap\n+    \/\/ is slower than blindly iterating the objects.\n+    MemRegion mr_in_unparsable(mr.start(), MIN2(mr.end(), pb));\n+    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr_in_unparsable, cur, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"}]}