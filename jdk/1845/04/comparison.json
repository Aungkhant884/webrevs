{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,0 @@\n-            -framework JavaNativeFoundation \\\n@@ -116,0 +115,1 @@\n+            -framework Foundation \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,2 @@\n-        LIBS := -framework JavaNativeFoundation -framework Cocoa \\\n-            -framework SystemConfiguration -framework Kerberos, \\\n+        LIBS := -framework Cocoa -framework SystemConfiguration \\\n+            -framework Kerberos, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libTestDynamicStore := -ObjC\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestDynamicStore := -framework Cocoa -framework SystemConfiguration\n@@ -87,0 +89,1 @@\n+  BUILD_JDK_JTREG_EXCLUDE += libTestDynamicStore.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,2 +818,2 @@\n-    private void createKeyEntry(String alias, long creationDate, long secKeyRef, long[] secCertificateRefs, byte[][] rawCertData)\n-        throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException {\n+    private void createKeyEntry(String alias, long creationDate, long secKeyRef,\n+                                long[] secCertificateRefs, byte[][] rawCertData) {\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/KeychainStore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\n@@ -32,6 +31,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n-\n-static JNF_CLASS_CACHE(jc_KeychainStore, \"apple\/security\/KeychainStore\");\n-static JNF_MEMBER_CACHE(jm_createTrustedCertEntry, jc_KeychainStore, \"createTrustedCertEntry\", \"(Ljava\/lang\/String;JJ[B)V\");\n-static JNF_MEMBER_CACHE(jm_createKeyEntry, jc_KeychainStore, \"createKeyEntry\", \"(Ljava\/lang\/String;JJ[J[[B)V\");\n+#import <Cocoa\/Cocoa.h>\n@@ -293,0 +287,4 @@\n+    jclass jc_KeychainStore = (*env)->FindClass(env, \"apple\/security\/KeychainStore\");\n+    CHECK_NULL(jc_KeychainStore);\n+    jmethodID jm_createKeyEntry = (*env)->GetMethodID(env, jc_KeychainStore, \"createKeyEntry\", \"(Ljava\/lang\/String;JJ[J[[B)V\");\n+    CHECK_NULL(jm_createKeyEntry);\n@@ -362,1 +360,2 @@\n-            JNFCallVoidMethod(env, keyStore, jm_createKeyEntry, alias, creationDate, nativeKeyRef, certRefArray, javaCertArray);\n+            (*env)->CallVoidMethod(env, keyStore, jm_createKeyEntry, alias, creationDate, nativeKeyRef, certRefArray, javaCertArray);\n+            JNU_CHECK_EXCEPTION(env);\n@@ -380,0 +379,5 @@\n+    jclass jc_KeychainStore = (*env)->FindClass(env, \"apple\/security\/KeychainStore\");\n+    CHECK_NULL(jc_KeychainStore);\n+    jmethodID jm_createTrustedCertEntry = (*env)->GetMethodID(\n+            env, jc_KeychainStore, \"createTrustedCertEntry\", \"(Ljava\/lang\/String;JJ[B)V\");\n+    CHECK_NULL(jm_createTrustedCertEntry);\n@@ -405,1 +409,2 @@\n-            JNFCallVoidMethod(env, keyStore, jm_createTrustedCertEntry, alias, nativeRef, creationDate, certData);\n+            (*env)->CallVoidMethod(env, keyStore, jm_createTrustedCertEntry, alias, nativeRef, creationDate, certData);\n+            JNU_CHECK_EXCEPTION(env);\n@@ -503,0 +508,14 @@\n+NSString* JavaStringToNSString(JNIEnv *env, jstring jstr) {\n+     if (jstr == NULL) {\n+         return NULL;\n+     }\n+     jsize len = (*env)->GetStringLength(env, jstr);\n+     const jchar *chars = (*env)->GetStringChars(env, jstr, NULL);\n+     if (chars == NULL) {\n+         return NULL;\n+     }\n+     NSString *result = [NSString stringWithCharacters:(UniChar *)chars length:len];\n+     (*env)->ReleaseStringChars(env, jstr, chars);\n+     return result;\n+}\n+\n@@ -514,1 +533,7 @@\n-JNF_COCOA_ENTER(env);\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        jsize dataSize = (*env)->GetArrayLength(env, rawDataObj);\n+        jbyte *rawData = (*env)->GetByteArrayElements(env, rawDataObj, NULL);\n+        if (rawData == NULL) {\n+            goto errOut;\n+        }\n@@ -516,5 +541,2 @@\n-    jsize dataSize = (*env)->GetArrayLength(env, rawDataObj);\n-    jbyte *rawData = (*env)->GetByteArrayElements(env, rawDataObj, NULL);\n-    if (rawData == NULL) {\n-        goto errOut;\n-    }\n+        CFDataRef cfDataToImport = CFDataCreate(kCFAllocatorDefault, (UInt8 *)rawData, dataSize);\n+        CFArrayRef createdItems = NULL;\n@@ -522,2 +544,2 @@\n-    CFDataRef cfDataToImport = CFDataCreate(kCFAllocatorDefault, (UInt8 *)rawData, dataSize);\n-    CFArrayRef createdItems = NULL;\n+        SecKeychainRef defaultKeychain = NULL;\n+        SecKeychainCopyDefault(&defaultKeychain);\n@@ -525,2 +547,1 @@\n-    SecKeychainRef defaultKeychain = NULL;\n-    SecKeychainCopyDefault(&defaultKeychain);\n+        SecExternalFormat dataFormat = (isCertificate == JNI_TRUE ? kSecFormatX509Cert : kSecFormatWrappedPKCS8);\n@@ -528,1 +549,3 @@\n-    SecExternalFormat dataFormat = (isCertificate == JNI_TRUE ? kSecFormatX509Cert : kSecFormatWrappedPKCS8);\n+        \/\/ Convert the password obj into a CFStringRef that the keychain importer can use for encryption.\n+        SecKeyImportExportParameters paramBlock;\n+        CFStringRef passwordStrRef = NULL;\n@@ -530,3 +553,2 @@\n-    \/\/ Convert the password obj into a CFStringRef that the keychain importer can use for encryption.\n-    SecKeyImportExportParameters paramBlock;\n-    CFStringRef passwordStrRef = NULL;\n+        jsize passwordLen = 0;\n+        jchar *passwordChars = NULL;\n@@ -534,2 +556,2 @@\n-    jsize passwordLen = 0;\n-    jchar *passwordChars = NULL;\n+        if (passwordObj) {\n+            passwordLen = (*env)->GetArrayLength(env, passwordObj);\n@@ -537,8 +559,5 @@\n-    if (passwordObj) {\n-        passwordLen = (*env)->GetArrayLength(env, passwordObj);\n-\n-        if (passwordLen > 0) {\n-            passwordChars = (*env)->GetCharArrayElements(env, passwordObj, NULL);\n-            if (passwordChars == NULL) {\n-                goto errOut;\n-            }\n+            if (passwordLen > 0) {\n+                passwordChars = (*env)->GetCharArrayElements(env, passwordObj, NULL);\n+                if (passwordChars == NULL) {\n+                    goto errOut;\n+                }\n@@ -546,3 +565,4 @@\n-            passwordStrRef = CFStringCreateWithCharactersNoCopy(NULL, passwordChars, passwordLen, kCFAllocatorNull);\n-            if (passwordStrRef == NULL) {\n-                goto errOut;\n+                passwordStrRef = CFStringCreateWithCharactersNoCopy(NULL, passwordChars, passwordLen, kCFAllocatorNull);\n+                if (passwordStrRef == NULL) {\n+                    goto errOut;\n+                }\n@@ -551,1 +571,0 @@\n-    }\n@@ -553,9 +572,15 @@\n-    paramBlock.version = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n-    \/\/ Note that setting the flags field **requires** you to pass in a password of some kind.  The keychain will not prompt you.\n-    paramBlock.flags = 0;\n-    paramBlock.passphrase = passwordStrRef;\n-    paramBlock.alertTitle = NULL;\n-    paramBlock.alertPrompt = NULL;\n-    paramBlock.accessRef = NULL;\n-    paramBlock.keyUsage = CSSM_KEYUSE_ANY;\n-    paramBlock.keyAttributes = CSSM_KEYATTR_RETURN_DEFAULT;\n+        paramBlock.version = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n+        \/\/ Note that setting the flags field **requires** you to pass in a password of some kind.  The keychain will not prompt you.\n+        paramBlock.flags = 0;\n+        paramBlock.passphrase = passwordStrRef;\n+        paramBlock.alertTitle = NULL;\n+        paramBlock.alertPrompt = NULL;\n+        paramBlock.accessRef = NULL;\n+        paramBlock.keyUsage = CSSM_KEYUSE_ANY;\n+        paramBlock.keyAttributes = CSSM_KEYATTR_RETURN_DEFAULT;\n+\n+        err = SecKeychainItemImport(cfDataToImport, NULL, &dataFormat, NULL,\n+                                    0, &paramBlock, defaultKeychain, &createdItems);\n+        if (cfDataToImport != NULL) {\n+            CFRelease(cfDataToImport);\n+        }\n@@ -563,5 +588,2 @@\n-    err = SecKeychainItemImport(cfDataToImport, NULL, &dataFormat, NULL,\n-                                0, &paramBlock, defaultKeychain, &createdItems);\n-    if (cfDataToImport != NULL) {\n-        CFRelease(cfDataToImport);\n-    }\n+        if (err == noErr) {\n+            SecKeychainItemRef anItem = (SecKeychainItemRef)CFArrayGetValueAtIndex(createdItems, 0);\n@@ -569,2 +591,4 @@\n-    if (err == noErr) {\n-        SecKeychainItemRef anItem = (SecKeychainItemRef)CFArrayGetValueAtIndex(createdItems, 0);\n+            \/\/ Don't bother labeling keys. They become part of an identity, and are not an accessible part of the keychain.\n+            if (CFGetTypeID(anItem) == SecCertificateGetTypeID()) {\n+                setLabelForItem(JavaStringToNSString(env, alias), anItem);\n+            }\n@@ -572,3 +596,5 @@\n-        \/\/ Don't bother labeling keys. They become part of an identity, and are not an accessible part of the keychain.\n-        if (CFGetTypeID(anItem) == SecCertificateGetTypeID()) {\n-            setLabelForItem(JNFJavaToNSString(env, alias), anItem);\n+            \/\/ Retain the item, since it will be released once when the array holding it gets released.\n+            CFRetain(anItem);\n+            returnValue = ptr_to_jlong(anItem);\n+        } else {\n+            cssmPerror(\"_addItemToKeychain: SecKeychainItemImport\", err);\n@@ -577,10 +603,3 @@\n-        \/\/ Retain the item, since it will be released once when the array holding it gets released.\n-        CFRetain(anItem);\n-        returnValue = ptr_to_jlong(anItem);\n-    } else {\n-        cssmPerror(\"_addItemToKeychain: SecKeychainItemImport\", err);\n-    }\n-\n-    if (createdItems != NULL) {\n-        CFRelease(createdItems);\n-    }\n+        if (createdItems != NULL) {\n+            CFRelease(createdItems);\n+        }\n@@ -588,4 +607,4 @@\n-errOut:\n-    if (rawData) {\n-        (*env)->ReleaseByteArrayElements(env, rawDataObj, rawData, JNI_ABORT);\n-    }\n+    errOut:\n+        if (rawData) {\n+            (*env)->ReleaseByteArrayElements(env, rawDataObj, rawData, JNI_ABORT);\n+        }\n@@ -593,6 +612,11 @@\n-    if (passwordStrRef) CFRelease(passwordStrRef);\n-    if (passwordChars) {\n-        \/\/ clear the password and release\n-        memset(passwordChars, 0, passwordLen);\n-        (*env)->ReleaseCharArrayElements(env, passwordObj, passwordChars,\n-            JNI_ABORT);\n+        if (passwordStrRef) CFRelease(passwordStrRef);\n+        if (passwordChars) {\n+            \/\/ clear the password and release\n+            memset(passwordChars, 0, passwordLen);\n+            (*env)->ReleaseCharArrayElements(env, passwordObj, passwordChars,\n+                JNI_ABORT);\n+        }\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n@@ -600,3 +624,0 @@\n-\n-JNF_COCOA_EXIT(env);\n-\n","filename":"src\/java.base\/macosx\/native\/libosxsecurity\/KeystoreImpl.m","additions":101,"deletions":80,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -29,88 +28,1 @@\n-\n-\n-@interface JNFVectorCoercion : NSObject <JNFTypeCoercion> { }\n-@end\n-\n-@implementation JNFVectorCoercion\n-\n-- (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    static JNF_CLASS_CACHE(jc_Vector, \"java\/util\/Vector\");\n-    static JNF_CTOR_CACHE(jm_Vector_ctor, jc_Vector, \"(I)V\");\n-    static JNF_MEMBER_CACHE(jm_Vector_add, jc_Vector, \"add\", \"(Ljava\/lang\/Object;)Z\");\n-\n-    NSArray *nsArray = (NSArray *)obj;\n-    jobject javaArray = JNFNewObject(env, jm_Vector_ctor, (jint)[nsArray count]);\n-\n-    for (id obj in nsArray) {\n-        jobject jobj = [coercer coerceNSObject:obj withEnv:env usingCoercer:coercer];\n-        JNFCallBooleanMethod(env, javaArray, jm_Vector_add, jobj);\n-        if (jobj != NULL) (*env)->DeleteLocalRef(env, jobj);\n-    }\n-\n-    return javaArray;\n-}\n-\n-- (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    return nil;\n-}\n-\n-@end\n-\n-\n-@interface JNFHashtableCoercion : NSObject <JNFTypeCoercion> { }\n-@end\n-\n-@implementation JNFHashtableCoercion\n-\n-- (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    static JNF_CLASS_CACHE(jc_Hashtable, \"java\/util\/Hashtable\");\n-    static JNF_CTOR_CACHE(jm_Hashtable_ctor, jc_Hashtable, \"()V\");\n-    static JNF_MEMBER_CACHE(jm_Hashtable_put, jc_Hashtable, \"put\", \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-\n-    NSDictionary *nsDict = (NSDictionary *)obj;\n-    NSEnumerator *keyEnum = [nsDict keyEnumerator];\n-\n-    jobject jHashTable = JNFNewObject(env, jm_Hashtable_ctor);\n-\n-    id key = nil;\n-    while ((key = [keyEnum nextObject]) != nil) {\n-        jobject jkey = [coercer coerceNSObject:key withEnv:env usingCoercer:coercer];\n-\n-        id value = [nsDict objectForKey:key];\n-        jobject jvalue = [coercer coerceNSObject:value withEnv:env usingCoercer:coercer];\n-\n-        JNFCallObjectMethod(env, jHashTable, jm_Hashtable_put, jkey, jvalue);\n-\n-        if (jkey != NULL) (*env)->DeleteLocalRef(env, jkey);\n-        if (jvalue != NULL) (*env)->DeleteLocalRef(env, jvalue);\n-    }\n-\n-    return jHashTable;\n-}\n-\n-- (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    return nil;\n-}\n-\n-@end\n-\n-\n-\n-NSDictionary *realmConfigsForRealms(SCDynamicStoreRef store, NSArray *realms) {\n-    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n-\n-    for (NSString *realm in realms) {\n-        CFTypeRef realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:@\"Kerberos:%@\", realm]);\n-\n-        if (realmInfo == NULL || CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {\n-            if (realmInfo) CFRelease(realmInfo);\n-            return nil;\n-        }\n-\n-        [dict setObject:(NSArray *)realmInfo forKey:realm];\n-        CFRelease(realmInfo);\n-    }\n-\n-    return dict;\n-}\n-\n+#import \"jni_util.h\"\n@@ -120,0 +32,3 @@\n+#define KERBEROS_REALM_INFO @\"Kerberos:%@\"\n+\n+JavaVM *localVM;\n@@ -122,1 +37,1 @@\n-   NSArray *keys = (NSArray *)changedKeys;\n+    NSArray *keys = (NSArray *)changedKeys;\n@@ -126,5 +41,20 @@\n-    JNFPerformEnvBlock(JNFThreadDetachOnThreadDeath | JNFThreadSetSystemClassLoaderOnAttach | JNFThreadAttachAsDaemon, ^(JNIEnv *env) {\n-        static JNF_CLASS_CACHE(jc_Config, \"sun\/security\/krb5\/Config\");\n-        static JNF_STATIC_MEMBER_CACHE(jm_Config_refresh, jc_Config, \"refresh\", \"()V\");\n-        JNFCallStaticVoidMethod(env, jm_Config_refresh);\n-    });\n+    JNIEnv *env;\n+    bool createdFromAttach = FALSE;\n+    jint status = (*localVM)->GetEnv(localVM, (void**)&env, JNI_VERSION_1_2);\n+    if (status == JNI_EDETACHED) {\n+        status = (*localVM)->AttachCurrentThreadAsDaemon(localVM, (void**)&env, NULL);\n+        createdFromAttach = TRUE;\n+    }\n+    if (status == 0) {\n+        jclass jc_Config = (*env)->FindClass(env, \"sun\/security\/krb5\/Config\");\n+        CHECK_NULL(jc_Config);\n+        jmethodID jm_Config_refresh = (*env)->GetStaticMethodID(env, jc_Config, \"refresh\", \"()V\");\n+        CHECK_NULL(jm_Config_refresh);\n+        (*env)->CallStaticVoidMethod(env, jc_Config, jm_Config_refresh);\n+        if ((*env)->ExceptionOccurred(env) != NULL) {\n+            (*env)->ExceptionClear(env);\n+        }\n+        if (createdFromAttach) {\n+            (*localVM)->DetachCurrentThread(localVM);\n+        }\n+    }\n@@ -138,0 +68,7 @@\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        (*env)->GetJavaVM(env, &localVM);\n+        SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java\"), _SCDynamicStoreCallBack, NULL);\n+        if (store == NULL) {\n+            return;\n+        }\n@@ -139,6 +76,2 @@\n-JNF_COCOA_ENTER(env);\n-\n-    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java\"), _SCDynamicStoreCallBack, NULL);\n-    if (store == NULL) {\n-        return;\n-    }\n+        NSArray *keys = [NSArray arrayWithObjects:KERBEROS_DEFAULT_REALMS, KERBEROS_DEFAULT_REALM_MAPPINGS, nil];\n+        SCDynamicStoreSetNotificationKeys(store, (CFArrayRef) keys, NULL);\n@@ -146,2 +79,5 @@\n-    NSArray *keys = [NSArray arrayWithObjects:KERBEROS_DEFAULT_REALMS, KERBEROS_DEFAULT_REALM_MAPPINGS, nil];\n-    SCDynamicStoreSetNotificationKeys(store, (CFArrayRef) keys, NULL);\n+        CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);\n+        if (rls != NULL) {\n+            CFRunLoopAddSource(CFRunLoopGetMain(), rls, kCFRunLoopDefaultMode);\n+            CFRelease(rls);\n+        }\n@@ -149,4 +85,5 @@\n-    CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);\n-    if (rls != NULL) {\n-        CFRunLoopAddSource(CFRunLoopGetMain(), rls, kCFRunLoopDefaultMode);\n-        CFRelease(rls);\n+        CFRelease(store);\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n@@ -154,0 +91,1 @@\n+}\n@@ -155,4 +93,4 @@\n-    CFRelease(store);\n-\n-JNF_COCOA_EXIT(env);\n-\n+#define ADD(list, str) { \\\n+    jobject localeObj = (*env)->NewStringUTF(env, [str UTF8String]); \\\n+    (*env)->CallBooleanMethod(env, list, jm_listAdd, localeObj); \\\n+    (*env)->DeleteLocalRef(env, localeObj); \\\n@@ -161,0 +99,2 @@\n+#define ADDNULL(list) (*env)->CallBooleanMethod(env, list, jm_listAdd, NULL)\n+\n@@ -164,1 +104,1 @@\n- * Signature: ()Ljava\/util\/Hashtable;\n+ * Signature: ()Ljava\/util\/List;\n@@ -167,1 +107,0 @@\n-    jobject jHashTable = NULL;\n@@ -169,1 +108,1 @@\n-JNF_COCOA_ENTER(env);\n+    jobject newList = 0;\n@@ -171,4 +110,4 @@\n-    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n-    if (store == NULL) {\n-        return NULL;\n-    }\n+    SCDynamicStoreRef store = NULL;\n+    CFTypeRef realms = NULL;\n+    CFTypeRef realmMappings = NULL;\n+    CFTypeRef realmInfo = NULL;\n@@ -176,6 +115,6 @@\n-    CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);\n-    if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {\n-        if (realms) CFRelease(realms);\n-        CFRelease(store);\n-        return NULL;\n-    }\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n+        if (store == NULL) {\n+            return NULL;\n+        }\n@@ -183,1 +122,4 @@\n-    CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);\n+        CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);\n+        if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {\n+            return NULL;\n+        }\n@@ -185,1 +127,41 @@\n-    if (realmMappings == NULL || CFGetTypeID(realmMappings) != CFArrayGetTypeID()) {\n+        \/\/ This methods returns a ArrayList<String>:\n+        \/\/ (realm kdc* null) null (mapping-domain mapping-realm)*\n+        jclass jc_arrayListClass = (*env)->FindClass(env, \"java\/util\/ArrayList\");\n+        CHECK_NULL_RETURN(jc_arrayListClass, NULL);\n+        jmethodID jm_arrayListCons = (*env)->GetMethodID(env, jc_arrayListClass, \"<init>\", \"()V\");\n+        CHECK_NULL_RETURN(jm_arrayListCons, NULL);\n+        jmethodID jm_listAdd = (*env)->GetMethodID(env, jc_arrayListClass, \"add\", \"(Ljava\/lang\/Object;)Z\");\n+        CHECK_NULL_RETURN(jm_listAdd, NULL);\n+        newList = (*env)->NewObject(env, jc_arrayListClass, jm_arrayListCons);\n+        CHECK_NULL_RETURN(newList, NULL);\n+\n+        for (NSString *realm in (NSArray*)realms) {\n+            if (realmInfo) CFRelease(realmInfo); \/\/ for the previous realm\n+            realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, realm]);\n+            if (realmInfo == NULL || CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {\n+                continue;\n+            }\n+\n+            ADD(newList, realm);\n+            NSDictionary* ri = (NSDictionary*)realmInfo;\n+            for (NSDictionary* k in (NSArray*)ri[@\"kdc\"]) {\n+                ADD(newList, k[@\"host\"]);\n+            }\n+            ADDNULL(newList);\n+        }\n+        ADDNULL(newList);\n+\n+        CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);\n+        if (realmMappings != NULL && CFGetTypeID(realmMappings) == CFArrayGetTypeID()) {\n+            for (NSDictionary* d in (NSArray *)realmMappings) {\n+                for (NSString* s in d) {\n+                    ADD(newList, s);\n+                    ADD(newList, d[s]);\n+                }\n+            }\n+        }\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n+        if (realmInfo) CFRelease(realmInfo);\n@@ -187,19 +169,2 @@\n-        CFRelease(realms);\n-        CFRelease(store);\n-        return NULL;\n-    }\n-\n-    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n-\n-    if (CFArrayGetCount(realms) > 0) {\n-        NSDictionary *defaultRealmsDict = [NSDictionary dictionaryWithObject:[(NSArray *)realms objectAtIndex:0] forKey:@\"default_realm\"];\n-        [dict setObject:defaultRealmsDict forKey:@\"libdefaults\"];\n-\n-        NSDictionary *realmConfigs = realmConfigsForRealms(store, (NSArray *)realms);\n-        [dict setObject:realmConfigs forKey:@\"realms\"];\n-    }\n-    CFRelease(realms);\n-    CFRelease(store);\n-\n-    if (CFArrayGetCount(realmMappings) > 0) {\n-        [dict setObject:[(NSArray *)realmMappings objectAtIndex:0] forKey:@\"domain_realm\"];\n+        if (realms) CFRelease(realms);\n+        if (store) CFRelease(store);\n@@ -207,16 +172,1 @@\n-    CFRelease(realmMappings);\n-\n-\n-    \/\/ create and load a coercer with all of the different coercions to convert each type of object\n-    JNFTypeCoercer *coercer = [[[JNFTypeCoercer alloc] init] autorelease];\n-    [JNFDefaultCoercions addStringCoercionTo:coercer];\n-    [JNFDefaultCoercions addNumberCoercionTo:coercer];\n-    [coercer addCoercion:[[[JNFHashtableCoercion alloc] init] autorelease] forNSClass:[NSDictionary class] javaClass:@\"java\/util\/Map\"];\n-    [coercer addCoercion:[[[JNFVectorCoercion alloc] init] autorelease] forNSClass:[NSArray class] javaClass:@\"java\/util\/List\"];\n-\n-    \/\/ convert Cocoa graph to Java graph\n-    jHashTable = [coercer coerceNSObject:dict withEnv:env];\n-\n-JNF_COCOA_EXIT(env);\n-\n-    return jHashTable;\n+    return newList;\n","filename":"src\/java.security.jgss\/macosx\/native\/libosxkrb5\/SCDynamicStoreConfig.m","additions":112,"deletions":162,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Collection;\n@@ -31,0 +30,2 @@\n+import java.util.Iterator;\n+import java.util.List;\n@@ -36,1 +37,6 @@\n-    private static native Hashtable<String, Object> getKerberosConfig();\n+\n+    \/**\n+     * Returns the dynamic store setting for kerberos in a string array.\n+     * (realm kdc* null) null (mapping-domain mapping-realm)*\n+     *\/\n+    private static native List<String> getKerberosConfig();\n@@ -54,43 +60,0 @@\n-    private static Vector<String> unwrapHost(\n-            Collection<Hashtable<String, String>> c) {\n-        Vector<String> vector = new Vector<String>();\n-        for (Hashtable<String, String> m : c) {\n-            vector.add(m.get(\"host\"));\n-        }\n-        return vector;\n-    }\n-\n-    \/**\n-     * convertRealmConfigs: Maps the Object graph that we get from JNI to the\n-     * object graph that Config expects. Also the items inside the kdc array\n-     * are wrapped inside Hashtables\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private static Hashtable<String, Object>\n-            convertRealmConfigs(Hashtable<String, ?> configs) {\n-        Hashtable<String, Object> realmsTable = new Hashtable<String, Object>();\n-\n-        for (String realm : configs.keySet()) {\n-            \/\/ get the kdc\n-            Hashtable<String, Collection<?>> map =\n-                    (Hashtable<String, Collection<?>>) configs.get(realm);\n-            Hashtable<String, Vector<String>> realmMap =\n-                    new Hashtable<String, Vector<String>>();\n-\n-            \/\/ put the kdc into the realmMap\n-            Collection<Hashtable<String, String>> kdc =\n-                    (Collection<Hashtable<String, String>>) map.get(\"kdc\");\n-            if (kdc != null) realmMap.put(\"kdc\", unwrapHost(kdc));\n-\n-            \/\/ put the admin server into the realmMap\n-            Collection<Hashtable<String, String>> kadmin =\n-                    (Collection<Hashtable<String, String>>) map.get(\"kadmin\");\n-            if (kadmin != null) realmMap.put(\"admin_server\", unwrapHost(kadmin));\n-\n-            \/\/ add the full entry to the realmTable\n-            realmsTable.put(realm, realmMap);\n-        }\n-\n-        return realmsTable;\n-    }\n-\n@@ -105,2 +68,2 @@\n-        Hashtable<String, Object> stanzaTable = getKerberosConfig();\n-        if (stanzaTable == null) {\n+        List<String> list = getKerberosConfig();\n+        if (list == null) {\n@@ -110,3 +73,1 @@\n-        if (DEBUG) System.out.println(\"Raw map from JNI: \" + stanzaTable);\n-        return convertNativeConfig(stanzaTable);\n-    }\n+        if (DEBUG) System.out.println(\"Raw map from JNI: \" + list);\n@@ -114,17 +75,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static Hashtable<String, Object> convertNativeConfig(\n-            Hashtable<String, Object> stanzaTable) throws IOException {\n-        \/\/ convert SCDynamicStore realm structure to Java realm structure\n-        Hashtable<String, ?> realms =\n-                (Hashtable<String, ?>) stanzaTable.get(\"realms\");\n-        if (realms == null || realms.isEmpty()) {\n-            throw new IOException(\n-                    \"SCDynamicStore contains an empty Kerberos setting\");\n-        }\n-        stanzaTable.remove(\"realms\");\n-        Hashtable<String, Object> realmsTable = convertRealmConfigs(realms);\n-        stanzaTable.put(\"realms\", realmsTable);\n-        WrapAllStringInVector(stanzaTable);\n-        if (DEBUG) System.out.println(\"stanzaTable : \" + stanzaTable);\n-        return stanzaTable;\n-    }\n+        Hashtable<String,Object> v = new Hashtable<>();\n+        Hashtable<String,Object> realms = new Hashtable<>();\n+        Iterator<String> iterator = list.iterator();\n+        String defaultRealm = null;\n@@ -132,11 +80,19 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static void WrapAllStringInVector(\n-            Hashtable<String, Object> stanzaTable) {\n-        for (String s: stanzaTable.keySet()) {\n-            Object v = stanzaTable.get(s);\n-            if (v instanceof Hashtable) {\n-                WrapAllStringInVector((Hashtable<String,Object>)v);\n-            } else if (v instanceof String) {\n-                Vector<String> vec = new Vector<>();\n-                vec.add((String)v);\n-                stanzaTable.put(s, vec);\n+        while (true) {\n+            String nextRealm = iterator.next();\n+            if (nextRealm == null) {\n+                break;\n+            }\n+            if (defaultRealm == null) {\n+                defaultRealm = nextRealm;\n+                Hashtable<String,Object> dr = new Hashtable<>();\n+                dr.put(\"default_realm\", v1(defaultRealm));\n+                v.put(\"libdefaults\", dr);\n+            }\n+            Hashtable<String,Object> ri = new Hashtable<>();\n+            Vector<String> kdcs = new Vector<>();\n+            while (true) {\n+                String nextKdc = iterator.next();\n+                if (nextKdc == null) {\n+                    break;\n+                }\n+                kdcs.add(nextKdc);\n@@ -144,0 +100,14 @@\n+            if (!kdcs.isEmpty()) {\n+                ri.put(\"kdc\", kdcs);\n+            }\n+            realms.put(nextRealm, ri);\n+        }\n+        if (!realms.isEmpty()) {\n+            v.put(\"realms\", realms);\n+        }\n+        Hashtable<String,Object> mapping = new Hashtable<>();\n+        while (true) {\n+            if (!iterator.hasNext()) {\n+                break;\n+            }\n+            mapping.put(iterator.next(), v1(iterator.next()));\n@@ -145,0 +115,12 @@\n+        if (!mapping.isEmpty()) {\n+            v.put(\"domain_realm\", mapping);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Make a single value Vector. Config's stanzaTable always\n+    \/\/ use Vector as end values.\n+    private static Vector<String> v1(String s) {\n+        Vector<String> out = new Vector<>();\n+        out.add(s);\n+        return out;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":61,"deletions":79,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8257860\n+ * @summary SCDynamicStoreConfig works\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/manual\/native TestDynamicStore\n+ * @requires (os.family == \"mac\")\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+\n+public class TestDynamicStore {\n+\n+    native static int actionInternal(char what, char whom);\n+\n+    \/\/ what: 'a' for add, 'r' for remove\n+    \/\/ whom: 'a' for all, 'r' for realm, 'm' for mapping\n+    static int action(char what, char whom) throws Exception {\n+        int out = actionInternal(what, whom);\n+        System.out.println(\"Run \" + what + whom + \" \" + out);\n+        Thread.sleep(1000);   \/\/ wait for callback called\n+        return out;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        System.loadLibrary(\"TestDynamicStore\");\n+\n+        Config cfg = Config.getInstance();\n+        if (cfg.exists(\"libdefaults\") || cfg.exists(\"realms\")) {\n+            System.out.println(\"Already have krb5 config. Will not touch\");\n+            return;\n+        }\n+\n+        try {\n+            System.out.println(\"Fill in dynamic store\");\n+            action('a', 'a');\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"A.COM\"));\n+            Asserts.assertTrue(Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Remove mapping\");\n+            action('r', 'm');\n+            Asserts.assertTrue(!Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Re-add mapping\");\n+            action('a', 'm');\n+            Asserts.assertTrue(Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Remove realm info\");\n+            action('r', 'r');\n+            \/\/ Realm info is not watched, so no change detected\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"A.COM\"));\n+\n+            System.out.println(\"Remove mapping\");\n+            action('r', 'm');\n+            \/\/ But mapping is watched, so realm info is not re-read\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"B.COM\"));\n+        } finally {\n+            System.out.println(\"Remove everything\");\n+            action('r', 'a');\n+            Asserts.assertTrue(!Config.getInstance().exists(\"libdefault\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/native\/TestDynamicStore.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Cocoa\/Cocoa.h>\n+#import <SystemConfiguration\/SystemConfiguration.h>\n+#import <jni.h>\n+\n+#define KERBEROS_DEFAULT_REALMS @\"Kerberos-Default-Realms\"\n+#define KERBEROS_DEFAULT_REALM_MAPPINGS @\"Kerberos-Domain-Realm-Mappings\"\n+#define KERBEROS_REALM_INFO @\"Kerberos:%@\"\n+\n+int removeAll(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"]));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"B.COM\"]));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS));\n+    return 1;\n+}\n+\n+int removeRealm(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"]));\n+    return 1;\n+}\n+\n+int removeMapping(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS));\n+    return 1;\n+}\n+\n+int addMapping(SCDynamicStoreRef store) {\n+    NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        @\"a\", @\"A\",\n+        @\"b\", @\"B\",\n+        @\"c\", @\"C\",\n+        @\"d\", @\"D\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS, [NSArray arrayWithObjects: dict, nil]));\n+    return 1;\n+}\n+\n+int addAll(SCDynamicStoreRef store) {\n+    NSArray *keys = [NSArray arrayWithObjects:@\"A.COM\", @\"B.COM\", nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS, keys));\n+\n+    NSDictionary *k1 = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        @\"kdc1.a.com\", @\"host\", nil];\n+    NSDictionary *k2 = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        @\"kdc2.a.com\", @\"host\", nil];\n+    NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        [NSArray arrayWithObjects: k1, k2, nil], @\"kdc\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"], dict));\n+\n+    k1 = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        @\"kdc1.b.com\", @\"host\", nil];\n+    k2 = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        @\"kdc2.b.com\", @\"host\", nil];\n+    dict = [[NSDictionary alloc] initWithObjectsAndKeys:\n+        [NSArray arrayWithObjects: k1, k2, nil], @\"kdc\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"B.COM\"], dict));\n+    addMapping(store);\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL Java_TestDynamicStore_actionInternal(JNIEnv *env, jclass clazz, jchar what, jchar whom) {\n+    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n+    fprintf(stderr, \">>> action: %c %c\\n\", what, whom);\n+    switch (what) {\n+        case 'a':\n+            switch (whom) {\n+                case 'a': return addAll(store);\n+                case 'm': return addMapping(store);\n+            }\n+            break;\n+        case 'r':\n+            switch (whom) {\n+                case 'a': return removeAll(store);\n+                case 'r': return removeRealm(store);\n+                case 'm': return removeMapping(store);\n+            }\n+            break;\n+    }\n+    return 0;\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/native\/libTestDynamicStore.c","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}