{"files":[{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"adlc.hpp\"\n+\n+void* AdlAllocateHeap(size_t size) {\n+  unsigned char* ptr = (unsigned char*) malloc(size);\n+  if (ptr == NULL && size != 0) {\n+    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n+    fflush(stderr);\n+    exit(1);\n+  }\n+  return ptr;\n+}\n+\n+void* AdlReAllocateHeap(void* old_ptr, size_t size) {\n+  unsigned char* ptr = (unsigned char*) realloc(old_ptr, size);\n+  if (ptr == NULL && size != 0) {\n+    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n+    fflush(stderr);\n+    exit(1);\n+  }\n+  return ptr;\n+}\n+\n+void* AdlChunk::operator new(size_t requested_size, size_t length) throw() {\n+  return AdlCHeapObj::operator new(requested_size + length);\n+}\n+\n+void  AdlChunk::operator delete(void* p, size_t length) {\n+  AdlCHeapObj::operator delete(p);\n+}\n+\n+AdlChunk::AdlChunk(size_t length) {\n+  _next = NULL;         \/\/ Chain on the linked list\n+  _len  = length;       \/\/ Save actual size\n+}\n+\n+\/\/------------------------------chop-------------------------------------------\n+void AdlChunk::chop() {\n+  AdlChunk *k = this;\n+  while( k ) {\n+    AdlChunk *tmp = k->_next;\n+    \/\/ clear out this chunk (to detect allocation bugs)\n+    memset(k, 0xBE, k->_len);\n+    free(k);                    \/\/ Free chunk (was malloc'd)\n+    k = tmp;\n+  }\n+}\n+\n+void AdlChunk::next_chop() {\n+  _next->chop();\n+  _next = NULL;\n+}\n+\n+\/\/------------------------------AdlArena------------------------------------------\n+AdlArena::AdlArena( size_t init_size ) {\n+  init_size = (init_size+3) & ~3;\n+  _first = _chunk = new (init_size) AdlChunk(init_size);\n+  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n+  _max = _chunk->top();\n+  set_size_in_bytes(init_size);\n+}\n+\n+AdlArena::AdlArena() {\n+  _first = _chunk = new (AdlChunk::init_size) AdlChunk(AdlChunk::init_size);\n+  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n+  _max = _chunk->top();\n+  set_size_in_bytes(AdlChunk::init_size);\n+}\n+\n+AdlArena::AdlArena( AdlArena *a )\n+: _chunk(a->_chunk), _hwm(a->_hwm), _max(a->_max), _first(a->_first) {\n+  set_size_in_bytes(a->size_in_bytes());\n+}\n+\n+\/\/------------------------------used-------------------------------------------\n+\/\/ Total of all AdlChunks in arena\n+size_t AdlArena::used() const {\n+  size_t sum = _chunk->_len - (_max-_hwm); \/\/ Size leftover in this AdlChunk\n+  AdlChunk *k = _first;\n+  while( k != _chunk) {         \/\/ Whilst have AdlChunks in a row\n+    sum += k->_len;             \/\/ Total size of this AdlChunk\n+    k = k->_next;               \/\/ Bump along to next AdlChunk\n+  }\n+  return sum;                   \/\/ Return total consumed space.\n+}\n+\n+\/\/------------------------------grow-------------------------------------------\n+\/\/ Grow a new AdlChunk\n+void* AdlArena::grow( size_t x ) {\n+  \/\/ Get minimal required size.  Either real big, or even bigger for giant objs\n+  size_t len = max(x, AdlChunk::size);\n+\n+  AdlChunk *k = _chunk;         \/\/ Get filled-up chunk address\n+  _chunk = new (len) AdlChunk(len);\n+\n+  if( k ) k->_next = _chunk;    \/\/ Append new chunk to end of linked list\n+  else _first = _chunk;\n+  _hwm  = _chunk->bottom();     \/\/ Save the cached hwm, max\n+  _max =  _chunk->top();\n+  set_size_in_bytes(size_in_bytes() + len);\n+  void* result = _hwm;\n+  _hwm += x;\n+  return result;\n+}\n+\n+\/\/------------------------------calloc-----------------------------------------\n+\/\/ Allocate zeroed storage in AdlArena\n+void *AdlArena::Acalloc( size_t items, size_t x ) {\n+  size_t z = items*x;   \/\/ Total size needed\n+  void *ptr = Amalloc(z);       \/\/ Get space\n+  memset( ptr, 0, z );          \/\/ Zap space\n+  return ptr;                   \/\/ Return space\n+}\n+\n+\/\/------------------------------realloc----------------------------------------\n+\/\/ Reallocate storage in AdlArena.\n+void *AdlArena::Arealloc( void *old_ptr, size_t old_size, size_t new_size ) {\n+  char *c_old = (char*)old_ptr; \/\/ Handy name\n+  \/\/ Stupid fast special case\n+  if( new_size <= old_size ) {  \/\/ Shrink in-place\n+    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n+      _hwm = c_old+new_size;    \/\/ Adjust hwm\n+    return c_old;\n+  }\n+\n+  \/\/ See if we can resize in-place\n+  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n+      (c_old+new_size <= _max) ) {      \/\/ Still fits where it sits\n+    _hwm = c_old+new_size;      \/\/ Adjust hwm\n+    return c_old;               \/\/ Return old pointer\n+  }\n+\n+  \/\/ Oops, got to relocate guts\n+  void *new_ptr = Amalloc(new_size);\n+  memcpy( new_ptr, c_old, old_size );\n+  Afree(c_old,old_size);        \/\/ Mostly done to keep stats accurate\n+  return new_ptr;\n+}\n+\n+\/\/------------------------------reset------------------------------------------\n+\/\/ Reset this AdlArena to empty, and return this AdlArenas guts in a new AdlArena.\n+AdlArena *AdlArena::reset(void) {\n+  AdlArena *a = new AdlArena(this);   \/\/ New empty arena\n+  _first = _chunk = NULL;       \/\/ Normal, new-arena initialization\n+  _hwm = _max = NULL;\n+  return a;                     \/\/ Return AdlArena with guts\n+}\n+\n+\/\/------------------------------contains---------------------------------------\n+\/\/ Determine if pointer belongs to this AdlArena or not.\n+bool AdlArena::contains( const void *ptr ) const {\n+  if( (void*)_chunk->bottom() <= ptr && ptr < (void*)_hwm )\n+    return true;                \/\/ Check for in this chunk\n+  for( AdlChunk *c = _first; c; c = c->_next )\n+    if( (void*)c->bottom() <= ptr && ptr < (void*)c->top())\n+      return true;              \/\/ Check for every chunk in AdlArena\n+  return false;                 \/\/ Not in any AdlChunk, so not in AdlArena\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ CHeapObj\n+\n+void* AdlCHeapObj::operator new(size_t size) throw() {\n+  return (void *) AdlAllocateHeap(size);\n+}\n+\n+void AdlCHeapObj::operator delete(void* p){\n+ free(p);\n+}\n","filename":"src\/hotspot\/share\/adlc\/adlArena.cpp","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_ADLC_ADLARENA_HPP\n+#define SHARE_ADLC_ADLARENA_HPP\n+\n+void* AdlAllocateHeap(size_t size);\n+void* AdlReAllocateHeap(void* old_ptr, size_t size);\n+\n+\/\/ All classes in adlc may be derived\n+\/\/ from one of the following allocation classes:\n+\/\/\n+\/\/ For objects allocated in the C-heap (managed by: malloc & free).\n+\/\/ - CHeapObj\n+\/\/\n+\/\/ For classes used as name spaces.\n+\/\/ - AdlAllStatic\n+\/\/\n+\n+class AdlCHeapObj {\n+ public:\n+  void* operator new(size_t size) throw();\n+  void  operator delete(void* p);\n+  void* new_array(size_t size);\n+};\n+\n+\/\/ Base class for classes that constitute name spaces.\n+\n+class AdlAllStatic {\n+ public:\n+  void* operator new(size_t size) throw();\n+  void operator delete(void* p);\n+};\n+\n+\n+\/\/------------------------------AdlChunk------------------------------------------\n+\/\/ Linked list of raw memory chunks\n+class AdlChunk: public AdlCHeapObj {\n+ private:\n+  \/\/ This ordinary operator delete is needed even though not used, so the\n+  \/\/ below two-argument operator delete will be treated as a placement\n+  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n+  void operator delete(void* p);\n+ public:\n+  void* operator new(size_t size, size_t length) throw();\n+  void  operator delete(void* p, size_t length);\n+  AdlChunk(size_t length);\n+\n+  enum {\n+      init_size =  1*1024,      \/\/ Size of first chunk\n+      size      = 32*1024       \/\/ Default size of an AdlArena chunk (following the first)\n+  };\n+  AdlChunk*       _next;        \/\/ Next AdlChunk in list\n+  size_t       _len;            \/\/ Size of this AdlChunk\n+\n+  void chop();                  \/\/ Chop this chunk\n+  void next_chop();             \/\/ Chop next chunk\n+\n+  \/\/ Boundaries of data area (possibly unused)\n+  char* bottom() const { return ((char*) this) + sizeof(AdlChunk);  }\n+  char* top()    const { return bottom() + _len; }\n+};\n+\n+\n+\/\/------------------------------AdlArena------------------------------------------\n+\/\/ Fast allocation of memory\n+class AdlArena: public AdlCHeapObj {\n+protected:\n+  friend class ResourceMark;\n+  friend class HandleMark;\n+  friend class NoHandleMark;\n+  AdlChunk *_first;             \/\/ First chunk\n+  AdlChunk *_chunk;             \/\/ current chunk\n+  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n+  void* grow(size_t x);         \/\/ Get a new AdlChunk of at least size x\n+  size_t _size_in_bytes;          \/\/ Size of arena (used for memory usage tracing)\n+public:\n+  AdlArena();\n+  AdlArena(size_t init_size);\n+  AdlArena(AdlArena *old);\n+  ~AdlArena()                   { _first->chop(); }\n+  char* hwm() const             { return _hwm; }\n+\n+  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n+  void* Amalloc(size_t x) {\n+#ifdef _LP64\n+    x = (x + (8-1)) & ((unsigned)(-8));\n+#else\n+    x = (x + (4-1)) & ((unsigned)(-4));\n+#endif\n+    if (_hwm + x > _max) {\n+      return grow(x);\n+    } else {\n+      char *old = _hwm;\n+      _hwm += x;\n+      return old;\n+    }\n+  }\n+  \/\/ Further assume size is padded out to words\n+  void *AmallocWords(size_t x) {\n+    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n+    if (_hwm + x > _max) {\n+      return grow(x);\n+    } else {\n+      char *old = _hwm;\n+      _hwm += x;\n+      return old;\n+    }\n+  }\n+\n+  \/\/ Fast delete in area.  Common case is: NOP (except for storage reclaimed)\n+  void Afree(void *ptr, size_t size) {\n+    if (((char*)ptr) + size == _hwm) _hwm = (char*)ptr;\n+  }\n+\n+  void *Acalloc( size_t items, size_t x );\n+  void *Arealloc( void *old_ptr, size_t old_size, size_t new_size );\n+\n+  \/\/ Reset this AdlArena to empty, and return this AdlArenas guts in a new AdlArena.\n+  AdlArena *reset(void);\n+\n+  \/\/ Determine if pointer belongs to this AdlArena or not.\n+  bool contains( const void *ptr ) const;\n+\n+  \/\/ Total of all chunks in use (not thread-safe)\n+  size_t used() const;\n+\n+  \/\/ Total # of bytes used\n+  size_t size_in_bytes() const         {  return _size_in_bytes; }\n+  void   set_size_in_bytes(size_t size)  { _size_in_bytes = size;   }\n+};\n+\n+#endif \/\/ SHARE_ADLC_ADLARENA_HPP\n","filename":"src\/hotspot\/share\/adlc\/adlArena.hpp","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -96,1 +96,1 @@\n-#include \"arena.hpp\"\n+#include \"adlArena.hpp\"\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-          char* buf = (char*) AllocateHeap(strlen(instr->_ident) + 4);\n+          char* buf = (char*) AdlAllocateHeap(strlen(instr->_ident) + 4);\n@@ -2808,1 +2808,1 @@\n-  char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n+  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n@@ -3279,1 +3279,1 @@\n-  char* ec_name = (char*) AllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n+  char* ec_name = (char*) AdlAllocateHeap(strlen(inst._ident) + strlen(prefix) + 1);\n@@ -4412,1 +4412,1 @@\n-      char* result = (char *)AllocateHeap(strlen(location) + strlen(cppBlock) + strlen(end_loc) + 1);\n+      char* result = (char *)AdlAllocateHeap(strlen(location) + strlen(cppBlock) + strlen(end_loc) + 1);\n@@ -4501,1 +4501,1 @@\n-    char* result = (char *)AllocateHeap(strlen(location) + strlen(token2) + strlen(end_loc) + 1);\n+    char* result = (char *)AdlAllocateHeap(strlen(location) + strlen(token2) + strlen(end_loc) + 1);\n@@ -4599,1 +4599,1 @@\n-      char* buf = (char*) AllocateHeap(strlen(param) + 3);\n+      char* buf = (char*) AdlAllocateHeap(strlen(param) + 3);\n@@ -5207,1 +5207,1 @@\n-  char* location = (char *)AllocateHeap(strlen(file) + 100);\n+  char* location = (char *)AdlAllocateHeap(strlen(file) + 100);\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,192 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"adlc.hpp\"\n-\n-void* AllocateHeap(size_t size) {\n-  unsigned char* ptr = (unsigned char*) malloc(size);\n-  if (ptr == NULL && size != 0) {\n-    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n-    fflush(stderr);\n-    exit(1);\n-  }\n-  return ptr;\n-}\n-\n-void* ReAllocateHeap(void* old_ptr, size_t size) {\n-  unsigned char* ptr = (unsigned char*) realloc(old_ptr, size);\n-  if (ptr == NULL && size != 0) {\n-    fprintf(stderr, \"Error: Out of memory in ADLC\\n\"); \/\/ logging can cause crash!\n-    fflush(stderr);\n-    exit(1);\n-  }\n-  return ptr;\n-}\n-\n-void* Chunk::operator new(size_t requested_size, size_t length) throw() {\n-  return CHeapObj::operator new(requested_size + length);\n-}\n-\n-void  Chunk::operator delete(void* p, size_t length) {\n-  CHeapObj::operator delete(p);\n-}\n-\n-Chunk::Chunk(size_t length) {\n-  _next = NULL;         \/\/ Chain on the linked list\n-  _len  = length;       \/\/ Save actual size\n-}\n-\n-\/\/------------------------------chop-------------------------------------------\n-void Chunk::chop() {\n-  Chunk *k = this;\n-  while( k ) {\n-    Chunk *tmp = k->_next;\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    memset(k, 0xBE, k->_len);\n-    free(k);                    \/\/ Free chunk (was malloc'd)\n-    k = tmp;\n-  }\n-}\n-\n-void Chunk::next_chop() {\n-  _next->chop();\n-  _next = NULL;\n-}\n-\n-\/\/------------------------------Arena------------------------------------------\n-Arena::Arena( size_t init_size ) {\n-  init_size = (init_size+3) & ~3;\n-  _first = _chunk = new (init_size) Chunk(init_size);\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  set_size_in_bytes(init_size);\n-}\n-\n-Arena::Arena() {\n-  _first = _chunk = new (Chunk::init_size) Chunk(Chunk::init_size);\n-  _hwm = _chunk->bottom();      \/\/ Save the cached hwm, max\n-  _max = _chunk->top();\n-  set_size_in_bytes(Chunk::init_size);\n-}\n-\n-Arena::Arena( Arena *a )\n-: _chunk(a->_chunk), _hwm(a->_hwm), _max(a->_max), _first(a->_first) {\n-  set_size_in_bytes(a->size_in_bytes());\n-}\n-\n-\/\/------------------------------used-------------------------------------------\n-\/\/ Total of all Chunks in arena\n-size_t Arena::used() const {\n-  size_t sum = _chunk->_len - (_max-_hwm); \/\/ Size leftover in this Chunk\n-  Chunk *k = _first;\n-  while( k != _chunk) {         \/\/ Whilst have Chunks in a row\n-    sum += k->_len;             \/\/ Total size of this Chunk\n-    k = k->_next;               \/\/ Bump along to next Chunk\n-  }\n-  return sum;                   \/\/ Return total consumed space.\n-}\n-\n-\/\/------------------------------grow-------------------------------------------\n-\/\/ Grow a new Chunk\n-void* Arena::grow( size_t x ) {\n-  \/\/ Get minimal required size.  Either real big, or even bigger for giant objs\n-  size_t len = max(x, Chunk::size);\n-\n-  Chunk *k = _chunk;            \/\/ Get filled-up chunk address\n-  _chunk = new (len) Chunk(len);\n-\n-  if( k ) k->_next = _chunk;    \/\/ Append new chunk to end of linked list\n-  else _first = _chunk;\n-  _hwm  = _chunk->bottom();     \/\/ Save the cached hwm, max\n-  _max =  _chunk->top();\n-  set_size_in_bytes(size_in_bytes() + len);\n-  void* result = _hwm;\n-  _hwm += x;\n-  return result;\n-}\n-\n-\/\/------------------------------calloc-----------------------------------------\n-\/\/ Allocate zeroed storage in Arena\n-void *Arena::Acalloc( size_t items, size_t x ) {\n-  size_t z = items*x;   \/\/ Total size needed\n-  void *ptr = Amalloc(z);       \/\/ Get space\n-  memset( ptr, 0, z );          \/\/ Zap space\n-  return ptr;                   \/\/ Return space\n-}\n-\n-\/\/------------------------------realloc----------------------------------------\n-\/\/ Reallocate storage in Arena.\n-void *Arena::Arealloc( void *old_ptr, size_t old_size, size_t new_size ) {\n-  char *c_old = (char*)old_ptr; \/\/ Handy name\n-  \/\/ Stupid fast special case\n-  if( new_size <= old_size ) {  \/\/ Shrink in-place\n-    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n-      _hwm = c_old+new_size;    \/\/ Adjust hwm\n-    return c_old;\n-  }\n-\n-  \/\/ See if we can resize in-place\n-  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n-      (c_old+new_size <= _max) ) {      \/\/ Still fits where it sits\n-    _hwm = c_old+new_size;      \/\/ Adjust hwm\n-    return c_old;               \/\/ Return old pointer\n-  }\n-\n-  \/\/ Oops, got to relocate guts\n-  void *new_ptr = Amalloc(new_size);\n-  memcpy( new_ptr, c_old, old_size );\n-  Afree(c_old,old_size);        \/\/ Mostly done to keep stats accurate\n-  return new_ptr;\n-}\n-\n-\/\/------------------------------reset------------------------------------------\n-\/\/ Reset this Arena to empty, and return this Arenas guts in a new Arena.\n-Arena *Arena::reset(void) {\n-  Arena *a = new Arena(this);   \/\/ New empty arena\n-  _first = _chunk = NULL;       \/\/ Normal, new-arena initialization\n-  _hwm = _max = NULL;\n-  return a;                     \/\/ Return Arena with guts\n-}\n-\n-\/\/------------------------------contains---------------------------------------\n-\/\/ Determine if pointer belongs to this Arena or not.\n-bool Arena::contains( const void *ptr ) const {\n-  if( (void*)_chunk->bottom() <= ptr && ptr < (void*)_hwm )\n-    return true;                \/\/ Check for in this chunk\n-  for( Chunk *c = _first; c; c = c->_next )\n-    if( (void*)c->bottom() <= ptr && ptr < (void*)c->top())\n-      return true;              \/\/ Check for every chunk in Arena\n-  return false;                 \/\/ Not in any Chunk, so not in Arena\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n-\/\/ CHeapObj\n-\n-void* CHeapObj::operator new(size_t size) throw() {\n-  return (void *) AllocateHeap(size);\n-}\n-\n-void CHeapObj::operator delete(void* p){\n- free(p);\n-}\n","filename":"src\/hotspot\/share\/adlc\/arena.cpp","additions":0,"deletions":192,"binary":false,"changes":192,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_ADLC_ARENA_HPP\n-#define SHARE_ADLC_ARENA_HPP\n-\n-void* AllocateHeap(size_t size);\n-void* ReAllocateHeap(void* old_ptr, size_t size);\n-\n-\/\/ All classes in adlc may be derived\n-\/\/ from one of the following allocation classes:\n-\/\/\n-\/\/ For objects allocated in the C-heap (managed by: malloc & free).\n-\/\/ - CHeapObj\n-\/\/\n-\/\/ For classes used as name spaces.\n-\/\/ - AllStatic\n-\/\/\n-\n-class CHeapObj {\n- public:\n-  void* operator new(size_t size) throw();\n-  void  operator delete(void* p);\n-  void* new_array(size_t size);\n-};\n-\n-\/\/ Base class for classes that constitute name spaces.\n-\n-class AllStatic {\n- public:\n-  void* operator new(size_t size) throw();\n-  void operator delete(void* p);\n-};\n-\n-\n-\/\/------------------------------Chunk------------------------------------------\n-\/\/ Linked list of raw memory chunks\n-class Chunk: public CHeapObj {\n- private:\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n- public:\n-  void* operator new(size_t size, size_t length) throw();\n-  void  operator delete(void* p, size_t length);\n-  Chunk(size_t length);\n-\n-  enum {\n-      init_size =  1*1024,      \/\/ Size of first chunk\n-      size      = 32*1024       \/\/ Default size of an Arena chunk (following the first)\n-  };\n-  Chunk*       _next;           \/\/ Next Chunk in list\n-  size_t       _len;            \/\/ Size of this Chunk\n-\n-  void chop();                  \/\/ Chop this chunk\n-  void next_chop();             \/\/ Chop next chunk\n-\n-  \/\/ Boundaries of data area (possibly unused)\n-  char* bottom() const { return ((char*) this) + sizeof(Chunk);  }\n-  char* top()    const { return bottom() + _len; }\n-};\n-\n-\n-\/\/------------------------------Arena------------------------------------------\n-\/\/ Fast allocation of memory\n-class Arena: public CHeapObj {\n-protected:\n-  friend class ResourceMark;\n-  friend class HandleMark;\n-  friend class NoHandleMark;\n-  Chunk *_first;                \/\/ First chunk\n-  Chunk *_chunk;                \/\/ current chunk\n-  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n-  void* grow(size_t x);         \/\/ Get a new Chunk of at least size x\n-  size_t _size_in_bytes;          \/\/ Size of arena (used for memory usage tracing)\n-public:\n-  Arena();\n-  Arena(size_t init_size);\n-  Arena(Arena *old);\n-  ~Arena()                      { _first->chop(); }\n-  char* hwm() const             { return _hwm; }\n-\n-  \/\/ Fast allocate in the arena.  Common case is: pointer test + increment.\n-  void* Amalloc(size_t x) {\n-#ifdef _LP64\n-    x = (x + (8-1)) & ((unsigned)(-8));\n-#else\n-    x = (x + (4-1)) & ((unsigned)(-4));\n-#endif\n-    if (_hwm + x > _max) {\n-      return grow(x);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-  \/\/ Further assume size is padded out to words\n-  void *AmallocWords(size_t x) {\n-    assert( (x&(sizeof(char*)-1)) == 0, \"misaligned size\" );\n-    if (_hwm + x > _max) {\n-      return grow(x);\n-    } else {\n-      char *old = _hwm;\n-      _hwm += x;\n-      return old;\n-    }\n-  }\n-\n-  \/\/ Fast delete in area.  Common case is: NOP (except for storage reclaimed)\n-  void Afree(void *ptr, size_t size) {\n-    if (((char*)ptr) + size == _hwm) _hwm = (char*)ptr;\n-  }\n-\n-  void *Acalloc( size_t items, size_t x );\n-  void *Arealloc( void *old_ptr, size_t old_size, size_t new_size );\n-\n-  \/\/ Reset this Arena to empty, and return this Arenas guts in a new Arena.\n-  Arena *reset(void);\n-\n-  \/\/ Determine if pointer belongs to this Arena or not.\n-  bool contains( const void *ptr ) const;\n-\n-  \/\/ Total of all chunks in use (not thread-safe)\n-  size_t used() const;\n-\n-  \/\/ Total # of bytes used\n-  size_t size_in_bytes() const         {  return _size_in_bytes; }\n-  void   set_size_in_bytes(size_t size)  { _size_in_bytes = size;   }\n-};\n-\n-#endif \/\/ SHARE_ADLC_ARENA_HPP\n","filename":"src\/hotspot\/share\/adlc\/arena.hpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  ProductionState(Arena *arena) : _production(cmpstr, hashstr, arena) { initialize(); };\n+  ProductionState(AdlArena *arena) : _production(cmpstr, hashstr, arena) { initialize(); };\n@@ -820,1 +820,1 @@\n-ExprDict::ExprDict( CmpKey cmp, Hash hash, Arena *arena )\n+ExprDict::ExprDict( CmpKey cmp, Hash hash, AdlArena *arena )\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-Dict::Dict(CmpKey initcmp, Hash inithash, Arena *arena) : _hash(inithash), _cmp(initcmp), _arena(arena) {\n+Dict::Dict(CmpKey initcmp, Hash inithash, AdlArena *arena) : _hash(inithash), _cmp(initcmp), _arena(arena) {\n","filename":"src\/hotspot\/share\/adlc\/dict2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  class Arena *_arena;          \/\/ Where to draw storage from\n+  class AdlArena *_arena;       \/\/ Where to draw storage from\n@@ -59,1 +59,1 @@\n-  Dict( CmpKey cmp, Hash hash, Arena *arena );\n+  Dict( CmpKey cmp, Hash hash, AdlArena *arena );\n","filename":"src\/hotspot\/share\/adlc\/dict2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,3 @@\n-Arena  *Form::arena = Form::generate_arena(); \/\/  = Form::generate_arena();\n-Arena *Form::generate_arena() {\n-  return (new Arena);\n+AdlArena  *Form::arena = Form::generate_arena(); \/\/  = Form::generate_arena();\n+AdlArena *Form::generate_arena() {\n+  return (new AdlArena);\n@@ -43,1 +43,1 @@\n-  _names = (const char**) AllocateHeap(_max*sizeof(char*));\n+  _names = (const char**) AdlAllocateHeap(_max*sizeof(char*));\n@@ -52,1 +52,1 @@\n-    _names = (const char**) ReAllocateHeap(_names, (_max *=2)*sizeof(char*));\n+    _names = (const char**) AdlReAllocateHeap(_names, (_max *=2)*sizeof(char*));\n@@ -315,1 +315,1 @@\n-FormDict::FormDict( CmpKey cmp, Hash hash, Arena *arena )\n+FormDict::FormDict( CmpKey cmp, Hash hash, AdlArena *arena )\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  FormDict( CmpKey cmp, Hash hash, Arena *arena );\n+  FormDict( CmpKey cmp, Hash hash, AdlArena *arena );\n@@ -122,1 +122,1 @@\n-  static Arena  *arena;            \/\/ arena used by forms\n+  static AdlArena  *arena;         \/\/ arena used by forms\n@@ -124,1 +124,1 @@\n-  static Arena  *generate_arena(); \/\/ allocate arena used by forms\n+  static AdlArena  *generate_arena(); \/\/ allocate arena used by forms\n@@ -576,1 +576,1 @@\n-  ExprDict( CmpKey cmp, Hash hash, Arena *arena );\n+  ExprDict( CmpKey cmp, Hash hash, AdlArena *arena );\n","filename":"src\/hotspot\/share\/adlc\/forms.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-  \/\/ Chunk and register mask are determined by the register number\n+  \/\/ AdlChunk and register mask are determined by the register number\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-    uniq_idx = (uint*) AllocateHeap(sizeof(uint) * _uniq_idx_length);\n+    uniq_idx = (uint*) AdlAllocateHeap(sizeof(uint) * _uniq_idx_length);\n@@ -3479,1 +3479,1 @@\n-  subtree = (char *)AllocateHeap(len);\n+  subtree = (char *)AdlAllocateHeap(len);\n@@ -3929,1 +3929,1 @@\n-  char* buf = (char*) AllocateHeap(strlen(instr_ident) + 4);\n+  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}