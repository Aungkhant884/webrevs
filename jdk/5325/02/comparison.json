{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1EvacInfo.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/g1\/g1EvacuationInfo.hpp\"\n@@ -94,1 +94,1 @@\n-void G1Allocator::reuse_retained_old_region(G1EvacuationInfo* evacuation_info,\n+void G1Allocator::reuse_retained_old_region(G1EvacInfo* evacuation_info,\n@@ -127,1 +127,1 @@\n-void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo* evacuation_info) {\n+void G1Allocator::init_gc_alloc_regions(G1EvacInfo* evacuation_info) {\n@@ -143,1 +143,1 @@\n-void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo* evacuation_info) {\n+void G1Allocator::release_gc_alloc_regions(G1EvacInfo* evacuation_info) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class G1EvacuationInfo;\n+class G1EvacInfo;\n@@ -71,1 +71,1 @@\n-  void reuse_retained_old_region(G1EvacuationInfo* evacuation_info,\n+  void reuse_retained_old_region(G1EvacInfo* evacuation_info,\n@@ -108,2 +108,2 @@\n-  void init_gc_alloc_regions(G1EvacuationInfo* evacuation_info);\n-  void release_gc_alloc_regions(G1EvacuationInfo* evacuation_info);\n+  void init_gc_alloc_regions(G1EvacInfo* evacuation_info);\n+  void release_gc_alloc_regions(G1EvacInfo* evacuation_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2853,106 +2853,0 @@\n-void G1CollectedHeap::prepare_tlabs_for_mutator() {\n-  Ticks start = Ticks::now();\n-\n-  _survivor_evac_stats.adjust_desired_plab_sz();\n-  _old_evac_stats.adjust_desired_plab_sz();\n-\n-  allocate_dummy_regions();\n-\n-  _allocator->init_mutator_alloc_regions();\n-\n-  resize_all_tlabs();\n-\n-  phase_times()->record_resize_tlab_time_ms((Ticks::now() - start).seconds() * 1000.0);\n-}\n-\n-void G1CollectedHeap::retire_tlabs() {\n-  ensure_parsability(true);\n-}\n-\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper(double target_pause_time_ms) {\n-  ResourceMark rm;\n-\n-  IsGCActiveMark active_gc_mark;\n-  GCIdMark gc_id_mark;\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-\n-  GCTraceCPUTime tcpu;\n-\n-  _bytes_used_during_gc = 0;\n-\n-  policy()->decide_on_concurrent_start_pause();\n-  \/\/ Record whether this pause may need to trigger a concurrent operation. Later,\n-  \/\/ when we signal the G1ConcurrentMarkThread, the collector state has already\n-  \/\/ been reset for the next pause.\n-  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n-\n-  \/\/ Perform the collection.\n-  G1YoungCollector collector(gc_cause(), target_pause_time_ms, &_evac_failure_regions);\n-  collector.collect();\n-\n-  \/\/ It should now be safe to tell the concurrent mark thread to start\n-  \/\/ without its logging output interfering with the logging output\n-  \/\/ that came from the pause.\n-  if (should_start_concurrent_mark_operation) {\n-    \/\/ CAUTION: after the start_concurrent_cycle() call below, the concurrent marking\n-    \/\/ thread(s) could be running concurrently with us. Make sure that anything\n-    \/\/ after this point does not assume that we are the only GC thread running.\n-    \/\/ Note: of course, the actual marking work will not start until the safepoint\n-    \/\/ itself is released in SuspendibleThreadSet::desynchronize().\n-    start_concurrent_cycle(collector.concurrent_operation_is_full_mark());\n-    ConcurrentGCBreakpoints::notify_idle_to_active();\n-  }\n-}\n-\n-void G1CollectedHeap::complete_cleaning(BoolObjectClosure* is_alive,\n-                                        bool class_unloading_occurred) {\n-  uint num_workers = workers()->active_workers();\n-  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred);\n-  workers()->run_task(&unlink_task);\n-}\n-\n-bool G1STWSubjectToDiscoveryClosure::do_object_b(oop obj) {\n-  assert(obj != NULL, \"must not be NULL\");\n-  assert(_g1h->is_in_reserved(obj), \"Trying to discover obj \" PTR_FORMAT \" not in heap\", p2i(obj));\n-  \/\/ The areas the CM and STW ref processor manage must be disjoint. The is_in_cset() below\n-  \/\/ may falsely indicate that this is not the case here: however the collection set only\n-  \/\/ contains old regions when concurrent mark is not running.\n-  return _g1h->is_in_cset(obj) || _g1h->heap_region_containing(obj)->is_survivor();\n-}\n-\n-void G1CollectedHeap::make_pending_list_reachable() {\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    oop pll_head = Universe::reference_pending_list();\n-    if (pll_head != NULL) {\n-      \/\/ Any valid worker id is fine here as we are in the VM thread and single-threaded.\n-      _cm->mark_in_next_bitmap(0 \/* worker_id *\/, pll_head);\n-    }\n-  }\n-}\n-\n-static bool do_humongous_object_logging() {\n-  return log_is_enabled(Debug, gc, humongous);\n-}\n-\n-bool G1CollectedHeap::should_do_eager_reclaim() const {\n-  \/\/ As eager reclaim logging also gives information about humongous objects in\n-  \/\/ the heap in general, always do the eager reclaim pass even without known\n-  \/\/ candidates.\n-  return (G1EagerReclaimHumongousObjects &&\n-          (has_humongous_reclaim_candidates() || do_humongous_object_logging()));\n-}\n-\n-void G1CollectedHeap::set_humongous_stats(uint num_humongous_total, uint num_humongous_candidates) {\n-  _num_humongous_objects = num_humongous_total;\n-  _num_humongous_reclaim_candidates = num_humongous_candidates;\n-}\n-\n-bool G1CollectedHeap::should_sample_collection_set_candidates() const {\n-  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n-  return candidates != NULL && candidates->num_remaining() > 0;\n-}\n-\n-void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n-  _collection_set_candidates_card_set_stats = stats;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":106,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_G1_G1EVACUATIONINFO_HPP\n-#define SHARE_GC_G1_G1EVACUATIONINFO_HPP\n+#ifndef SHARE_GC_G1_G1EVACINFO_HPP\n+#define SHARE_GC_G1_G1EVACINFO_HPP\n@@ -30,1 +30,1 @@\n-class G1EvacuationInfo : public StackObj {\n+class G1EvacInfo : public StackObj {\n@@ -40,1 +40,1 @@\n-  G1EvacuationInfo() :\n+  G1EvacInfo() :\n@@ -82,1 +82,1 @@\n-#endif \/\/ SHARE_GC_G1_G1EVACUATIONINFO_HPP\n+#endif \/\/ SHARE_GC_G1_G1EVACINFO_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacInfo.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationInfo.hpp","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1EvacuationInfo.hpp\"\n+#include \"gc\/g1\/g1EvacInfo.hpp\"\n@@ -86,1 +86,1 @@\n-void G1NewTracer::report_evacuation_info(G1EvacuationInfo* info) {\n+void G1NewTracer::report_evacuation_info(G1EvacInfo* info) {\n@@ -144,1 +144,1 @@\n-void G1NewTracer::send_evacuation_info_event(G1EvacuationInfo* info) {\n+void G1NewTracer::send_evacuation_info_event(G1EvacInfo* info) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Trace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class G1EvacuationInfo;\n+class G1EvacInfo;\n@@ -48,1 +48,1 @@\n-  void report_evacuation_info(G1EvacuationInfo* info);\n+  void report_evacuation_info(G1EvacInfo* info);\n@@ -68,1 +68,1 @@\n-  void send_evacuation_info_event(G1EvacuationInfo* info);\n+  void send_evacuation_info_event(G1EvacInfo* info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Trace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"gc\/g1\/g1EvacuationInfo.hpp\"\n+#include \"gc\/g1\/g1EvacInfo.hpp\"\n@@ -149,1 +149,1 @@\n-  G1EvacuationInfo _evacuation_info;\n+  G1EvacInfo _evacuation_info;\n@@ -155,1 +155,1 @@\n-  G1EvacuationInfo* evacuation_info() { return &_evacuation_info; }\n+  G1EvacInfo* evacuation_info() { return &_evacuation_info; }\n@@ -291,1 +291,1 @@\n-void G1YoungCollector::calculate_collection_set(G1EvacuationInfo* evacuation_info, double target_pause_time_ms) {\n+void G1YoungCollector::calculate_collection_set(G1EvacInfo* evacuation_info, double target_pause_time_ms) {\n@@ -495,1 +495,1 @@\n-void G1YoungCollector::pre_evacuate_collection_set(G1EvacuationInfo* evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n+void G1YoungCollector::pre_evacuate_collection_set(G1EvacInfo* evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n@@ -965,1 +965,1 @@\n-                                               G1EvacuationInfo* evacuation_info) {\n+                                               G1EvacInfo* evacuation_info) {\n@@ -974,1 +974,1 @@\n-void G1YoungCollector::post_evacuate_collection_set(G1EvacuationInfo* evacuation_info,\n+void G1YoungCollector::post_evacuate_collection_set(G1EvacInfo* evacuation_info,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class G1EvacuationInfo;\n+class G1EvacInfo;\n@@ -91,1 +91,1 @@\n-  void calculate_collection_set(G1EvacuationInfo* evacuation_info, double target_pause_time_ms);\n+  void calculate_collection_set(G1EvacInfo* evacuation_info, double target_pause_time_ms);\n@@ -95,1 +95,1 @@\n-  void pre_evacuate_collection_set(G1EvacuationInfo* evacuation_info, G1ParScanThreadStateSet* pss);\n+  void pre_evacuate_collection_set(G1EvacInfo* evacuation_info, G1ParScanThreadStateSet* pss);\n@@ -122,1 +122,1 @@\n-                               G1EvacuationInfo* evacuation_info);\n+                               G1EvacInfo* evacuation_info);\n@@ -124,1 +124,1 @@\n-  void post_evacuate_collection_set(G1EvacuationInfo* evacuation_info,\n+  void post_evacuate_collection_set(G1EvacInfo* evacuation_info,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  void report(G1CollectedHeap* g1h, G1EvacuationInfo* evacuation_info) {\n+  void report(G1CollectedHeap* g1h, G1EvacInfo* evacuation_info) {\n@@ -579,1 +579,1 @@\n-      FreeCollectionSetTask::FreeCollectionSetTask(G1EvacuationInfo* evacuation_info,\n+      FreeCollectionSetTask::FreeCollectionSetTask(G1EvacInfo* evacuation_info,\n@@ -625,1 +625,1 @@\n-                                                                                 G1EvacuationInfo* evacuation_info,\n+                                                                                 G1EvacInfo* evacuation_info,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class G1EvacuationInfo;\n+class G1EvacInfo;\n@@ -120,1 +120,1 @@\n-                                          G1EvacuationInfo* evacuation_info,\n+                                          G1EvacInfo* evacuation_info,\n@@ -193,1 +193,1 @@\n-  G1EvacuationInfo* _evacuation_info;\n+  G1EvacInfo* _evacuation_info;\n@@ -204,1 +204,1 @@\n-  FreeCollectionSetTask(G1EvacuationInfo* evacuation_info,\n+  FreeCollectionSetTask(G1EvacInfo* evacuation_info,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}