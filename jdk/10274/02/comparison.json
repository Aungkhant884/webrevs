{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,25 @@\n-import javax.swing.*;\n-import javax.swing.border.*;\n-import javax.swing.plaf.*;\n+import sun.swing.StringUIClientPropertyKey;\n+import sun.swing.SwingUtilities2;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonModel;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JOptionPane;\n+import javax.swing.JScrollPane;\n+import javax.swing.JToolBar;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.border.AbstractBorder;\n+import javax.swing.border.Border;\n+import javax.swing.border.CompoundBorder;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.LineBorder;\n+import javax.swing.border.MatteBorder;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.UIResource;\n@@ -33,3 +55,1 @@\n-\n-import java.awt.Component;\n-import java.awt.Insets;\n+import java.awt.BasicStroke;\n@@ -37,0 +57,1 @@\n+import java.awt.Component;\n@@ -40,0 +61,3 @@\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Stroke;\n@@ -41,3 +65,1 @@\n-\n-import sun.swing.StringUIClientPropertyKey;\n-import sun.swing.SwingUtilities2;\n+import java.awt.geom.AffineTransform;\n@@ -226,0 +248,12 @@\n+        \/**\n+         * Round the double to nearest integer, make sure we round\n+         * to lower integer value for 0.5\n+         *\n+         * @param d number to be rounded\n+         * @return a {@code int} which is the rounded value of provided number\n+         *\/\n+        private static int roundDown(double d)\n+        {\n+            double decP = (Math.ceil(d) - d);\n+            return (int)((decP == 0.5) ?  Math.floor(d) :  Math.round(d));\n+        }\n@@ -228,2 +262,1 @@\n-                          int w, int h) {\n-\n+                                int w, int h) {\n@@ -244,35 +277,91 @@\n-              g.setColor(background);\n-              \/\/ Draw outermost lines\n-              g.drawLine( 1, 0, w-2, 0);\n-              g.drawLine( 0, 1, 0, h-2);\n-              g.drawLine( w-1, 1, w-1, h-2);\n-              g.drawLine( 1, h-1, w-2, h-1);\n-\n-              \/\/ Draw the bulk of the border\n-              for (int i = 1; i < 5; i++) {\n-                  g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-              }\n-\n-              if (c instanceof JInternalFrame &&\n-                               ((JInternalFrame)c).isResizable()) {\n-                  g.setColor(highlight);\n-                  \/\/ Draw the Long highlight lines\n-                  g.drawLine( corner+1, 3, w-corner, 3);\n-                  g.drawLine( 3, corner+1, 3, h-corner);\n-                  g.drawLine( w-2, corner+1, w-2, h-corner);\n-                  g.drawLine( corner+1, h-2, w-corner, h-2);\n-\n-                  g.setColor(shadow);\n-                  \/\/ Draw the Long shadow lines\n-                  g.drawLine( corner, 2, w-corner-1, 2);\n-                  g.drawLine( 2, corner, 2, h-corner-1);\n-                  g.drawLine( w-3, corner, w-3, h-corner-1);\n-                  g.drawLine( corner, h-3, w-corner-1, h-3);\n-              }\n-\n-          }\n-\n-          public Insets getBorderInsets(Component c, Insets newInsets) {\n-              newInsets.set(5, 5, 5, 5);\n-              return newInsets;\n-          }\n+            Graphics2D g2d = (Graphics2D) g;\n+            AffineTransform at = g2d.getTransform();\n+            Stroke oldStk = g2d.getStroke();\n+            Color oldColor = g2d.getColor();\n+            boolean resetTransform;\n+            int stkWidth = 1;\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n+            \/\/ skip resetting the transform\n+            resetTransform = (at.getShearX() == 0) && (at.getShearY() == 0);\n+\n+            if (resetTransform) {\n+                g2d.setTransform(new AffineTransform());\n+                stkWidth = roundDown(Math.min(at.getScaleX(), at.getScaleY()));\n+                g2d.setStroke(new BasicStroke((float) stkWidth));\n+            }\n+\n+            int xtranslation = 0;\n+            int ytranslation = 0;\n+            int width = 0;\n+            int height = 0;\n+\n+            if (resetTransform) {\n+                width = roundDown(at.getScaleX() * w);\n+                height = roundDown(at.getScaleY() * h);\n+                xtranslation = roundDown(at.getScaleX() * x + at.getTranslateX());\n+                ytranslation = roundDown(at.getScaleY() * y + at.getTranslateY());\n+            } else {\n+                width = w;\n+                height = h;\n+                xtranslation = x;\n+                ytranslation = y;\n+            }\n+            g2d.translate(xtranslation, ytranslation);\n+\n+            \/\/ border and corner scaling\n+            int scaledCorner = (int) Math.round(corner * at.getScaleX());\n+            \/\/ loop constraint for bulk of the border\n+            int loopCount = (int) Math.round(5 * at.getScaleX());\n+\n+            \/\/ midpoint at which highlight & shadow lines\n+            \/\/ are positioned on the border\n+            int midPoint = loopCount\/2;\n+\n+            g.setColor(background);\n+            \/\/ Draw outermost lines\n+            g.drawLine( 0, 0, width-1, 0);\n+            g.drawLine( 0, 1, 0, height-1);\n+            g.drawLine( width-1, 1, width-1, height-1);\n+            g.drawLine( 1, height-1, width-1, height-1);\n+\n+            \/\/ Draw the bulk of the border\n+            for (int i = 1; i <= loopCount; i++) {\n+                g.drawRect(x+i,y+i,width-(i*2)-1, height-(i*2)-1);\n+            }\n+\n+            if (c instanceof JInternalFrame && ((JInternalFrame)c).isResizable()) {\n+                \/\/ Draw the Long highlight lines\n+                g.setColor(highlight);\n+                g.drawLine(scaledCorner + 1, midPoint+stkWidth,\n+                        width- scaledCorner, midPoint+stkWidth); \/\/top\n+                g.drawLine(midPoint+stkWidth, scaledCorner + 1,\n+                        midPoint+stkWidth, height- scaledCorner); \/\/left\n+                g.drawLine(width-midPoint, scaledCorner + 1,\n+                        width-midPoint, height- scaledCorner); \/\/right\n+                g.drawLine(scaledCorner + 1, height-midPoint,\n+                        width- scaledCorner, height-midPoint); \/\/bottom\n+\n+                \/\/ Draw the Long shadow lines\n+                g.setColor(shadow);\n+                g.drawLine(scaledCorner, midPoint, width- scaledCorner -1, midPoint);\n+                g.drawLine(midPoint, scaledCorner, midPoint, height- scaledCorner -1);\n+                g.drawLine(width-(midPoint+stkWidth), scaledCorner,\n+                        width-(midPoint+stkWidth), height- scaledCorner -1);\n+                g.drawLine(scaledCorner, height-(midPoint+stkWidth),\n+                        width- scaledCorner -1, height-(midPoint+stkWidth));\n+            }\n+\n+            \/\/ Undo the resetTransform setting from before\n+            g2d.translate(-xtranslation, -ytranslation);\n+            if (resetTransform) {\n+                g2d.setColor(oldColor);\n+                g2d.setTransform(at);\n+                g2d.setStroke(oldStk);\n+            }\n+        }\n+\n+        public Insets getBorderInsets(Component c, Insets newInsets) {\n+            newInsets.set(5, 5, 5, 5);\n+            return newInsets;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":136,"deletions":47,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.GridBagLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8015739\n+ * @key headful\n+ * @summary Tests whether background color of JInternalFrame is visible\n+ * in the border region at different scales by checking the midpoints\n+ * and corners of the border.\n+ *\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.25 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.5 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.75 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2.5 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=3 InternalFrameBorderTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015739\n+ * @key headful\n+ * @summary Tests whether background color of JInternalFrame is visible\n+ * in the border region at different scales by checking the midpoints\n+ * and corners of the border.\n+ *\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015739\n+ * @key headful\n+ * @summary Tests whether background color of JInternalFrame is visible\n+ * in the border region at different scales by checking the midpoints\n+ * and corners of the border.\n+ * @requires (os.family == \"linux\")\n+ *\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n+ *\/\n+public class InternalFrameBorderTest {\n+    private static final int FRAME_SIZE = 300;\n+    private static final int INTFRAME_SIZE = 200;\n+    private static final int MIDPOINT = INTFRAME_SIZE\/2;\n+    private static final int BORDER_THICKNESS = 5;\n+    private static StringBuffer errorLog = new StringBuffer();\n+\n+    private static JFrame jFrame;\n+    private static JInternalFrame iFrame;\n+    private static Robot robot;\n+\n+    private static Point iFrameLoc;\n+    private static int iFrameMaxX;\n+    private static int iFrameMaxY;\n+    private static String uiScale;\n+\n+    public static void main(String[] args) throws AWTException,\n+            InterruptedException, InvocationTargetException {\n+        try {\n+            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+        } catch (Exception e) {\n+            System.out.println(\"Metal LAF class not supported\");\n+            return;\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(200);\n+            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n+\n+            SwingUtilities.invokeAndWait(InternalFrameBorderTest::createAndShowGUI);\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                iFrameLoc = iFrame.getLocationOnScreen();\n+                iFrameMaxX = iFrameLoc.x + INTFRAME_SIZE;\n+                iFrameMaxY = iFrameLoc.y + INTFRAME_SIZE;\n+            });\n+\n+            \/\/ Check Borders\n+            SwingUtilities.invokeAndWait(() -> {\n+                checkBorderMidPoints(\"TOP\");\n+                checkBorderMidPoints(\"RIGHT\");\n+                checkBorderMidPoints(\"BOTTOM\");\n+                checkBorderMidPoints(\"LEFT\");\n+            });\n+\n+            \/\/ Check Corners\n+            SwingUtilities.invokeAndWait(() -> {\n+                checkCorners(\"TOP_LEFT\");\n+                checkCorners(\"TOP_RIGHT\");\n+                checkCorners(\"BOTTOM_RIGHT\");\n+                checkCorners(\"BOTTOM_LEFT\");\n+            });\n+            if (!errorLog.isEmpty()) {\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+        } finally {\n+            if (jFrame != null) {\n+                jFrame.dispose();\n+            }\n+            robot.delay(500);\n+        }\n+    }\n+\n+    private static void checkBorderMidPoints(String borderDirection) {\n+        int x = 0, y = 0, start = 0, stop = 0;\n+        switch (borderDirection) {\n+            case \"TOP\" -> {\n+                x = iFrameLoc.x + MIDPOINT;\n+                y = iFrameLoc.y + BORDER_THICKNESS;\n+                start = iFrameLoc.y;\n+                stop = iFrameLoc.y + BORDER_THICKNESS;\n+            }\n+            case \"RIGHT\" -> {\n+                x = iFrameMaxX - BORDER_THICKNESS;\n+                y = iFrameLoc.y + MIDPOINT;\n+                start = iFrameMaxX - BORDER_THICKNESS;\n+                stop = iFrameMaxX;\n+            }\n+            case \"BOTTOM\" -> {\n+                x = iFrameLoc.x + MIDPOINT;\n+                y = iFrameMaxY - BORDER_THICKNESS;\n+                start = iFrameMaxY;\n+                stop = iFrameMaxY - BORDER_THICKNESS;\n+            }\n+            case \"LEFT\" -> {\n+                x = iFrameLoc.x;\n+                y = iFrameLoc.y + MIDPOINT;\n+                start = iFrameLoc.x;\n+                stop = iFrameLoc.x + BORDER_THICKNESS;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + borderDirection);\n+        }\n+\n+        boolean isVertical =  borderDirection.equals(\"RIGHT\")\n+                || borderDirection.equals(\"LEFT\");\n+        boolean isHorizontal =  borderDirection.equals(\"TOP\")\n+                || borderDirection.equals(\"BOTTOM\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = start; i < stop; i++) {\n+            if (Color.RED.equals(robot.getPixelColor(\n+                    isVertical ? i : (iFrameLoc.x + MIDPOINT),\n+                    isHorizontal ? i : (iFrameLoc.y + MIDPOINT)))) {\n+                        saveScreenCapture(borderDirection + \"_\" + uiScale + \".png\");\n+                        errorLog.append(\"uiScale: \"+ uiScale +\n+                                \" Red background color\" + \" detected at \"\n+                                + borderDirection + \" border\\n\");\n+            }\n+        }\n+        robot.delay(300);\n+    }\n+\n+    private static void checkCorners(String cornerLocation) {\n+        int x, y = 0;\n+\n+        switch (cornerLocation) {\n+            case \"TOP_LEFT\" -> {\n+                x = iFrameLoc.x;\n+                y = iFrameLoc.y;\n+            }\n+            case \"TOP_RIGHT\" -> {\n+                x = iFrameMaxX;\n+                y = iFrameLoc.y;\n+            }\n+            case \"BOTTOM_RIGHT\" -> {\n+                x = iFrameMaxX;\n+                y = iFrameMaxY;\n+            }\n+            case \"BOTTOM_LEFT\" -> {\n+                x = iFrameLoc.x;\n+                y = iFrameMaxY;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + cornerLocation);\n+        }\n+        robot.mouseMove(x, y);\n+        if (Color.RED.equals(robot.getPixelColor(x, y))) {\n+            saveScreenCapture(cornerLocation + \"_\" + uiScale + \".png\");\n+            errorLog.append(\"uiScale: \"+ uiScale + \" Red background color\" +\n+                    \" detected at \" + cornerLocation +  \" corner\\n\");\n+        }\n+        robot.delay(300);\n+    }\n+\n+    private static void createAndShowGUI() {\n+        jFrame = new JFrame();\n+        jFrame.setSize(FRAME_SIZE, FRAME_SIZE);\n+        jFrame.setLayout(null);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        JLabel scale = new JLabel(\"UI Scale: \"+ uiScale);\n+\n+        iFrame = new JInternalFrame(\"iframe\", true);\n+        iFrame.setLayout(new GridBagLayout());\n+        iFrame.setBackground(Color.RED);\n+        iFrame.add(scale);\n+        iFrame.setLocation(30, 30);\n+        jFrame.getContentPane().add(iFrame);\n+        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n+        iFrame.setVisible(true);\n+\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+    \/\/ for debugging purpose, saves screen capture when test fails.\n+    private static void saveScreenCapture(String filename) {\n+        BufferedImage image = robot.createScreenCapture(jFrame.getBounds());\n+        try {\n+            ImageIO.write(image,\"png\", new File(filename));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/InternalFrameBorderTest.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"}]}