{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1850,0 +1850,58 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* AbsNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) return Type::TOP;\n+\n+  switch (t1->base()) {\n+  case Type::Int: {\n+    const TypeInt* ti = t1->is_int();\n+    if (ti->is_con()) {\n+      return TypeInt::make(uabs(ti->get_con()));\n+    }\n+    break;\n+  }\n+  case Type::Long: {\n+    const TypeLong* tl = t1->is_long();\n+    if (tl->is_con()) {\n+      return TypeLong::make(uabs(tl->get_con()));\n+    }\n+    break;\n+  }\n+  case Type::FloatCon:\n+    return TypeF::make(abs(t1->getf()));\n+  case Type::DoubleCon:\n+    return TypeD::make(abs(t1->getd()));\n+  default:\n+    break;\n+  }\n+\n+  return bottom_type();\n+}\n+\n+\/\/------------------------------Identity----------------------------------------\n+Node* AbsNode::Identity(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  \/\/ No need to do abs for non-negative values\n+  if (phase->type(in1)->higher_equal(TypeInt::POS) ||\n+      phase->type(in1)->higher_equal(TypeLong::POS)) {\n+    return in1;\n+  }\n+  \/\/ Convert \"abs(abs(x))\" into \"abs(x)\"\n+  if (in1->Opcode() == Opcode()) {\n+    return in1;\n+  }\n+  return this;\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* AbsNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  \/\/ Convert \"abs(0-x)\" into \"abs(x)\"\n+  if (in1->is_Sub() && phase->type(in1->in(1))->is_zero_type()) {\n+    set_req_X(1, in1->in(2), phase);\n+    return this;\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,0 +350,3 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -596,1 +596,1 @@\n-  bool is_con(int i) const { return is_con() && _lo == i; }\n+  bool is_con(jint i) const { return is_con() && _lo == i; }\n@@ -664,1 +664,1 @@\n-  bool is_con(int i) const { return is_con() && _lo == i; }\n+  bool is_con(jlong i) const { return is_con() && _lo == i; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8276673\n+ * @summary Test abs nodes optimization in C2.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIRAbs\n+ *\/\n+\n+public class TestIRAbs {\n+\n+    public static char [] cspecial = {\n+        0, 42, 128, 256, 1024, 4096, 65535\n+    };\n+\n+    public static int [] ispecial = {\n+        0, Integer.MAX_VALUE, Integer.MIN_VALUE, -42, 42, -1, 1\n+    };\n+\n+    public static long [] lspecial = {\n+        0, Long.MAX_VALUE, Long.MIN_VALUE, -42, 42, -1, 1\n+    };\n+\n+    public static float [] fspecial = {\n+        0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+        -1.0f,\n+        1.0f,\n+        -42.0f,\n+        42.0f\n+    };\n+\n+    public static double [] dspecial = {\n+        0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        -Double.MAX_VALUE,\n+        -Double.MIN_VALUE,\n+        Double.NaN,\n+        Double.POSITIVE_INFINITY,\n+        Double.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        -1,\n+        1,\n+        42,\n+        -42,\n+        Math.PI,\n+        Math.E,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY\n+    };\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ABS_I, IRNode.ABS_L, IRNode.ABS_F, IRNode.ABS_D})\n+    public void testAbsConstant() {\n+        \/\/ Test abs(constant) optimization for int\n+        Asserts.assertEquals(Integer.MAX_VALUE, Math.abs(Integer.MAX_VALUE));\n+        Asserts.assertEquals(Integer.MIN_VALUE, Math.abs(Integer.MIN_VALUE));\n+        Asserts.assertEquals(Integer.MAX_VALUE, Math.abs(-Integer.MAX_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for long\n+        Asserts.assertEquals(Long.MAX_VALUE, Math.abs(Long.MAX_VALUE));\n+        Asserts.assertEquals(Long.MIN_VALUE, Math.abs(Long.MIN_VALUE));\n+        Asserts.assertEquals(Long.MAX_VALUE, Math.abs(-Long.MAX_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for float\n+        Asserts.assertTrue(Float.isNaN(Math.abs(Float.NaN)));\n+        Asserts.assertEquals(Float.POSITIVE_INFINITY, Math.abs(Float.NEGATIVE_INFINITY));\n+        Asserts.assertEquals(Float.POSITIVE_INFINITY, Math.abs(Float.POSITIVE_INFINITY));\n+        Asserts.assertEquals(0.0f, Math.abs(0.0f));\n+        Asserts.assertEquals(0.0f, Math.abs(-0.0f));\n+        Asserts.assertEquals(Float.MAX_VALUE, Math.abs(Float.MAX_VALUE));\n+        Asserts.assertEquals(Float.MIN_VALUE, Math.abs(Float.MIN_VALUE));\n+        Asserts.assertEquals(Float.MAX_VALUE, Math.abs(-Float.MAX_VALUE));\n+        Asserts.assertEquals(Float.MIN_VALUE, Math.abs(-Float.MIN_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for double\n+        Asserts.assertTrue(Double.isNaN(Math.abs(Double.NaN)));\n+        Asserts.assertEquals(Double.POSITIVE_INFINITY, Math.abs(Double.NEGATIVE_INFINITY));\n+        Asserts.assertEquals(Double.POSITIVE_INFINITY, Math.abs(Double.POSITIVE_INFINITY));\n+        Asserts.assertEquals(0.0, Math.abs(0.0));\n+        Asserts.assertEquals(0.0, Math.abs(-0.0));\n+        Asserts.assertEquals(Double.MAX_VALUE, Math.abs(Double.MAX_VALUE));\n+        Asserts.assertEquals(Double.MIN_VALUE, Math.abs(Double.MIN_VALUE));\n+        Asserts.assertEquals(Double.MAX_VALUE, Math.abs(-Double.MAX_VALUE));\n+        Asserts.assertEquals(Double.MIN_VALUE, Math.abs(-Double.MIN_VALUE));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ABS_I, \"1\"})\n+    public int testInt0(int x) {\n+        return Math.abs(Math.abs(x)); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_I})\n+    @IR(counts = {IRNode.ABS_I, \"1\"})\n+    public int testInt1(int x) {\n+        return Math.abs(0 - x); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Run(test = {\"testInt0\", \"testInt1\"})\n+    public void checkTestInt(RunInfo info) {\n+        for (int i = 0; i < ispecial.length; i++) {\n+            Asserts.assertEquals(Math.abs(ispecial[i]), testInt0(ispecial[i]));\n+            Asserts.assertEquals(Math.abs(ispecial[i]), testInt1(ispecial[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    public long testLong0(long x) {\n+        return Math.abs(Math.abs(x)); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_L})\n+    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    public long testLong1(long x) {\n+        return Math.abs(0 - x); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Run(test = {\"testLong0\", \"testLong1\"})\n+    public void checkTestLong(RunInfo info) {\n+        for (int i = 0; i < lspecial.length; i++) {\n+            Asserts.assertEquals(Math.abs(lspecial[i]), testLong0(lspecial[i]));\n+            Asserts.assertEquals(Math.abs(lspecial[i]), testLong1(lspecial[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ABS_F, \"1\"})\n+    public float testFloat0(float x) {\n+        return Math.abs(Math.abs(x)); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_F})\n+    @IR(counts = {IRNode.ABS_F, \"1\"})\n+    public float testFloat1(float x) {\n+        return Math.abs(0 - x); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Run(test = {\"testFloat0\", \"testFloat1\"})\n+    public void checkTestFloat(RunInfo info) {\n+        for (int i = 0; i < fspecial.length; i++) {\n+            Asserts.assertEquals(Math.abs(fspecial[i]), testFloat0(fspecial[i]));\n+            Asserts.assertEquals(Math.abs(fspecial[i]), testFloat1(fspecial[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ABS_D, \"1\"})\n+    public double testDouble0(double x) {\n+        return Math.abs(Math.abs(x)); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB_D})\n+    @IR(counts = {IRNode.ABS_D, \"1\"})\n+    public double testDouble1(double x) {\n+        return Math.abs(0 - x); \/\/ transformed to Math.abs(x)\n+    }\n+\n+    @Run(test = {\"testDouble0\", \"testDouble1\"})\n+    public void checkTestDouble(RunInfo info) {\n+        for (int i = 0; i < dspecial.length; i++) {\n+            Asserts.assertEquals(Math.abs(dspecial[i]), testDouble0(dspecial[i]));\n+            Asserts.assertEquals(Math.abs(dspecial[i]), testDouble1(dspecial[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ABS_I})\n+    public void testChar() {\n+        for (int i = 0; i < cspecial.length; i++) {\n+            Asserts.assertEquals(cspecial[i], (char) Math.abs(cspecial[i]));\n+        }\n+    }\n+ }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRAbs.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -139,0 +139,4 @@\n+    public static final String ABS_I = START + \"AbsI\" + MID + END;\n+    public static final String ABS_L = START + \"AbsL\" + MID + END;\n+    public static final String ABS_F = START + \"AbsF\" + MID + END;\n+    public static final String ABS_D = START + \"AbsD\" + MID + END;\n@@ -148,0 +152,2 @@\n+    public static final String SUB_F = START + \"SubF\" + MID + END;\n+    public static final String SUB_D = START + \"SubD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}