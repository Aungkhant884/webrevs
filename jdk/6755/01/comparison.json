{"files":[{"patch":"@@ -1828,0 +1828,66 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* AbsNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) return Type::TOP;\n+\n+  switch (t1->base()) {\n+  case Type::Int: {\n+    const TypeInt* ti = t1->is_int();\n+    if (ti->is_con()) {\n+      \/\/ Special case for min_jint: Math.abs(min_jint) = min_jint.\n+      \/\/ Do not use C++ abs() for min_jint to avoid undefined behavior.\n+      return (ti->is_con(min_jint)) ? TypeInt::MIN : TypeInt::make(abs(ti->get_con()));\n+    }\n+    break;\n+  }\n+  case Type::Long: {\n+    const TypeLong* tl = t1->is_long();\n+    if (tl->is_con()) {\n+      \/\/ Special case for min_jlong: Math.abs(min_jlong) = min_jlong.\n+      \/\/ Do not use C++ abs() for min_jlong to avoid undefined behavior.\n+      return (tl->is_con(min_jlong)) ? TypeLong::MIN : TypeLong::make(abs(tl->get_con()));\n+    }\n+    break;\n+  }\n+  case Type::FloatCon:\n+    return TypeF::make(abs(t1->getf()));\n+  case Type::DoubleCon:\n+    return TypeD::make(abs(t1->getd()));\n+  default:\n+    break;\n+  }\n+\n+  return bottom_type();\n+}\n+\n+\/\/------------------------------Identity----------------------------------------\n+Node* AbsNode::Identity(PhaseGVN* phase) {\n+  Node* in1 = in(1);\n+  \/\/ No need to do abs for non-negative values\n+  if (phase->type(in1)->higher_equal(TypeInt::POS) ||\n+      phase->type(in1)->higher_equal(TypeLong::POS)) {\n+    return in1;\n+  }\n+  \/\/ Convert \"abs(abs(x))\" into \"abs(x)\"\n+  if (in1->Opcode() == Opcode()) {\n+    return in1;\n+  }\n+  return this;\n+}\n+\n+\/\/------------------------------Ideal------------------------------------------\n+Node* AbsNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  \/\/ Convert \"abs(0-x)\" into \"abs(x)\"\n+  if (in1->is_Sub() && phase->type(in1->in(1))->is_zero_type()) {\n+    set_req(1, in1->in(2));\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    if (igvn) {\n+      igvn->_worklist.push(in1);\n+    }\n+    return this;\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,0 +382,3 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-  bool is_con(int i) const { return is_con() && _lo == i; }\n+  bool is_con(jint i) const { return is_con() && _lo == i; }\n@@ -660,1 +660,1 @@\n-  bool is_con(int i) const { return is_con() && _lo == i; }\n+  bool is_con(jlong i) const { return is_con() && _lo == i; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-package compiler.c2;\n-\n@@ -28,2 +26,3 @@\n- * @bug 8248445\n- * @summary Use of AbsI \/ AbsL nodes should be limited to supported platforms\n+ * @bug 8248445 8276673\n+ * @summary Abs nodes detection and optimization in C2\n+ * @library \/test\/lib\n@@ -33,0 +32,1 @@\n+ * @run main\/othervm -XX:-TieredCompilation compiler.c2.TestAbs\n@@ -34,0 +34,6 @@\n+\n+package compiler.c2;\n+import jdk.test.lib.Asserts;\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+\n@@ -35,0 +41,136 @@\n+    private static int SIZE = 500;\n+\n+    public static char [] cspecial = {\n+        0, 42, 128, 256, 1024, 4096, 65535\n+    };\n+\n+    public static int [] ispecial = {\n+        0, Integer.MAX_VALUE, Integer.MIN_VALUE, -42, 42, -1, 1\n+    };\n+\n+    public static long [] lspecial = {\n+        0, Long.MAX_VALUE, Long.MIN_VALUE, -42, 42, -1, 1\n+    };\n+\n+    public static float [] fspecial = {\n+        0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        Long.MIN_VALUE,\n+        -1.0f,\n+        1.0f,\n+        -42.0f,\n+        42.0f,\n+        Float.intBitsToFloat((1 << FloatConsts.SIGNIFICAND_WIDTH) |\n+          ((1 << FloatConsts.SIGNIFICAND_WIDTH) - 1)),\n+        FloatConsts.MAG_BIT_MASK >>> 1\n+    };\n+\n+    public static double [] dspecial = {\n+        0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        -Double.MAX_VALUE,\n+        -Double.MIN_VALUE,\n+        Double.NaN,\n+        Double.POSITIVE_INFINITY,\n+        Double.NEGATIVE_INFINITY,\n+        Integer.MAX_VALUE,\n+        Integer.MIN_VALUE,\n+        Long.MIN_VALUE,\n+        Long.MAX_VALUE,\n+        -1,\n+        1,\n+        42,\n+        -42,\n+        Math.PI,\n+        Math.E,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        -Float.MAX_VALUE,\n+        -Float.MIN_VALUE,\n+        Float.NaN,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Double.longBitsToDouble((1L << DoubleConsts.SIGNIFICAND_WIDTH) |\n+          ((1L << DoubleConsts.SIGNIFICAND_WIDTH) - 1)),\n+        DoubleConsts.MAG_BIT_MASK >>> 1\n+    };\n+\n+    public static void testAbsConstant() {\n+        \/\/ Test abs(constant) optimization for int\n+        Asserts.assertEquals(Integer.MAX_VALUE, Math.abs(Integer.MAX_VALUE));\n+        Asserts.assertEquals(Integer.MIN_VALUE, Math.abs(Integer.MIN_VALUE));\n+        Asserts.assertEquals(Integer.MAX_VALUE, Math.abs(-Integer.MAX_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for long\n+        Asserts.assertEquals(Long.MAX_VALUE, Math.abs(Long.MAX_VALUE));\n+        Asserts.assertEquals(Long.MIN_VALUE, Math.abs(Long.MIN_VALUE));\n+        Asserts.assertEquals(Long.MAX_VALUE, Math.abs(-Long.MAX_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for float\n+        Asserts.assertEquals(Float.NaN, Math.abs(Float.NaN));\n+        Asserts.assertEquals(Float.POSITIVE_INFINITY, Math.abs(Float.NEGATIVE_INFINITY));\n+        Asserts.assertEquals(Float.POSITIVE_INFINITY, Math.abs(Float.POSITIVE_INFINITY));\n+        Asserts.assertEquals(0.0f, Math.abs(0.0f));\n+        Asserts.assertEquals(0.0f, Math.abs(-0.0f));\n+        Asserts.assertEquals(Float.MAX_VALUE, Math.abs(Float.MAX_VALUE));\n+        Asserts.assertEquals(Float.MIN_VALUE, Math.abs(Float.MIN_VALUE));\n+        Asserts.assertEquals(Float.MAX_VALUE, Math.abs(-Float.MAX_VALUE));\n+        Asserts.assertEquals(Float.MIN_VALUE, Math.abs(-Float.MIN_VALUE));\n+\n+        \/\/ Test abs(constant) optimization for double\n+        Asserts.assertEquals(Double.NaN, Math.abs(Double.NaN));\n+        Asserts.assertEquals(Double.POSITIVE_INFINITY, Math.abs(Double.NEGATIVE_INFINITY));\n+        Asserts.assertEquals(Double.POSITIVE_INFINITY, Math.abs(Double.POSITIVE_INFINITY));\n+        Asserts.assertEquals(0.0, Math.abs(0.0));\n+        Asserts.assertEquals(0.0, Math.abs(-0.0));\n+        Asserts.assertEquals(Double.MAX_VALUE, Math.abs(Double.MAX_VALUE));\n+        Asserts.assertEquals(Double.MIN_VALUE, Math.abs(Double.MIN_VALUE));\n+        Asserts.assertEquals(Double.MAX_VALUE, Math.abs(-Double.MAX_VALUE));\n+        Asserts.assertEquals(Double.MIN_VALUE, Math.abs(-Double.MIN_VALUE));\n+    }\n+\n+    private static void testAbsTransformInt(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            Asserts.assertEquals(Math.abs(Math.abs(a[i])), Math.abs(a[i]));\n+            Asserts.assertEquals(Math.abs(0 - a[i]), Math.abs(a[i]));\n+        }\n+    }\n+\n+    private static void testAbsTransformLong(long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            Asserts.assertEquals(Math.abs(Math.abs(a[i])), Math.abs(a[i]));\n+            Asserts.assertEquals(Math.abs(0 - a[i]), Math.abs(a[i]));\n+        }\n+    }\n+\n+    private static void testAbsTransformFloat(float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            Asserts.assertEquals(Math.abs(Math.abs(a[i])), Math.abs(a[i]));\n+            Asserts.assertEquals(Math.abs(0 - a[i]), Math.abs(a[i]));\n+        }\n+    }\n+\n+    private static void testAbsTransformDouble(double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            Asserts.assertEquals(Math.abs(Math.abs(a[i])), Math.abs(a[i]));\n+            Asserts.assertEquals(Math.abs(0 - a[i]), Math.abs(a[i]));\n+        }\n+    }\n+\n+    private static void testAbsOptChar(char[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            Asserts.assertEquals(a[i], (char) Math.abs(a[i]));\n+        }\n+    }\n@@ -48,0 +190,12 @@\n+\n+            testAbsConstant();\n+\n+            \/\/ Verify abs(abs(x)) = abs(x) for all types\n+            \/\/ Verify abs(0-x) = abs(x) for all types\n+            testAbsTransformInt(ispecial);\n+            testAbsTransformLong(lspecial);\n+            testAbsTransformFloat(fspecial);\n+            testAbsTransformDouble(dspecial);\n+\n+            \/\/ Verify abs(non-negative_value) = non-negative_value\n+            testAbsOptChar(cspecial);\n@@ -49,0 +203,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestAbs.java","additions":159,"deletions":4,"binary":false,"changes":163,"status":"modified"}]}