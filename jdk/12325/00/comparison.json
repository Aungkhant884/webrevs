{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-\/\/ interpreter_frame != NULL:\n+\/\/ interpreter_frame isn't null:\n@@ -126,1 +126,1 @@\n-\/\/   The frame interpreter_frame, if not NULL, is guaranteed to be the\n+\/\/   The frame interpreter_frame, if not null, is guaranteed to be the\n@@ -130,1 +130,1 @@\n-\/\/ is_top_frame == true:\n+\/\/ is_top_frame is true:\n@@ -134,1 +134,1 @@\n-\/\/   If this is != 0 we are returning to a deoptimized frame by popping\n+\/\/   If this isn't 0 we are returning to a deoptimized frame by popping\n","filename":"src\/hotspot\/cpu\/s390\/abstractInterpreter_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    if ((target == NULL) || (target == pc)) {\n+    if ((target == nullptr) || (target == pc)) {\n@@ -298,1 +298,1 @@\n-  AddressLiteral() : _address(NULL), _rspec() {}\n+  AddressLiteral() : _address(nullptr), _rspec() {}\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-      __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, \"locked object is NULL\", __LINE__);\n+      __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, \"locked object is null\", __LINE__);\n@@ -161,1 +161,1 @@\n-  if (call_addr == NULL) {\n+  if (call_addr == nullptr) {\n@@ -170,1 +170,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -216,1 +216,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -251,1 +251,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -261,1 +261,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -276,1 +276,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -289,1 +289,1 @@\n-  int oop_index = __ oop_recorder()->allocate_oop_index(NULL);\n+  int oop_index = __ oop_recorder()->allocate_oop_index(nullptr);\n@@ -294,1 +294,1 @@\n-  \/\/ The NULL will be dynamically patched later so the sequence to\n+  \/\/ The null will be dynamically patched later so the sequence to\n@@ -311,1 +311,1 @@\n-  int index = __ oop_recorder()->allocate_metadata_index(NULL);\n+  int index = __ oop_recorder()->allocate_metadata_index(nullptr);\n@@ -315,1 +315,1 @@\n-  \/\/ The NULL will be dynamically patched later so the sequence to\n+  \/\/ The null will be dynamically patched later so the sequence to\n@@ -356,3 +356,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  { _branch_target_blocks.append(op->block()); }\n-  if (op->ublock() != NULL) { _branch_target_blocks.append(op->ublock()); }\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  { _branch_target_blocks.append(op->block()); }\n+  if (op->ublock() != nullptr) { _branch_target_blocks.append(op->ublock()); }\n@@ -362,1 +362,1 @@\n-    if (op->info() != NULL) { add_debug_info_for_branch(op->info()); }\n+    if (op->info() != nullptr) { add_debug_info_for_branch(op->info()); }\n@@ -367,1 +367,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -507,1 +507,1 @@\n-  address virtual_call_oop_addr = NULL;\n+  address virtual_call_oop_addr = nullptr;\n@@ -549,1 +549,1 @@\n-      if (c->as_jobject() == NULL) {\n+      if (c->as_jobject() == nullptr) {\n@@ -599,1 +599,1 @@\n-        if (c->as_jobject() == NULL) {\n+        if (c->as_jobject() == nullptr) {\n@@ -669,1 +669,1 @@\n-        if (c->as_jobject() == NULL) {\n+        if (c->as_jobject() == nullptr) {\n@@ -712,1 +712,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -763,1 +763,1 @@\n-      if (const_addr == NULL) {\n+      if (const_addr == nullptr) {\n@@ -781,1 +781,1 @@\n-      if (const_addr == NULL) {\n+      if (const_addr == nullptr) {\n@@ -884,1 +884,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -972,1 +972,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -975,1 +975,1 @@\n-  if (info != NULL) add_debug_info_for_null_check(offset, info);\n+  if (info != nullptr) add_debug_info_for_null_check(offset, info);\n@@ -1077,1 +1077,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1179,1 +1179,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1183,1 +1183,1 @@\n-  if (info != NULL) add_debug_info_for_null_check(offset, info);\n+  if (info != nullptr) add_debug_info_for_null_check(offset, info);\n@@ -1214,1 +1214,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -1229,1 +1229,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1239,1 +1239,1 @@\n-  AddressLiteral meta = __ allocate_metadata_address(NULL);\n+  AddressLiteral meta = __ allocate_metadata_address(nullptr);\n@@ -1292,1 +1292,1 @@\n-        \/\/ We only need, for now, comparison with NULL for metadata.\n+        \/\/ We only need, for now, comparison with null for metadata.\n@@ -1295,1 +1295,1 @@\n-        if (m == NULL) {\n+        if (m == nullptr) {\n@@ -1303,1 +1303,1 @@\n-        if (o == NULL) {\n+        if (o == nullptr) {\n@@ -1314,1 +1314,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -1452,1 +1452,1 @@\n-    const2reg(opr1, result, lir_patch_none, NULL);\n+    const2reg(opr1, result, lir_patch_none, nullptr);\n@@ -1481,1 +1481,1 @@\n-      const2reg(opr2, result, lir_patch_none, NULL);\n+      const2reg(opr2, result, lir_patch_none, nullptr);\n@@ -1491,1 +1491,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -1938,1 +1938,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -1942,1 +1942,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -1945,1 +1945,1 @@\n-    if (copyfunc_addr == NULL) {\n+    if (copyfunc_addr == nullptr) {\n@@ -2010,1 +2010,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -2040,1 +2040,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -2118,1 +2118,1 @@\n-      __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &cont, &slow, nullptr);\n@@ -2130,1 +2130,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2459,2 +2459,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2464,1 +2464,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -2467,1 +2467,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -2469,1 +2469,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -2530,2 +2530,2 @@\n-                                     (need_slow_path ? success_target : NULL),\n-                                     failure_target, NULL,\n+                                     (need_slow_path ? success_target : nullptr),\n+                                     failure_target, nullptr,\n@@ -2575,2 +2575,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -2582,1 +2582,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -2585,1 +2585,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -2587,1 +2587,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -2616,1 +2616,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -2726,1 +2726,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2734,1 +2734,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2753,1 +2753,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2771,1 +2771,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2773,1 +2773,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2789,1 +2789,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2814,1 +2814,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2868,1 +2868,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2965,1 +2965,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -2994,1 +2994,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -3006,2 +3006,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -3030,1 +3030,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3043,1 +3043,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3063,1 +3063,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":75,"deletions":75,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -108,1 +108,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -110,1 +110,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -118,1 +118,1 @@\n-  if (i->type()->as_IntConstant() != NULL) {\n+  if (i->type()->as_IntConstant() != nullptr) {\n@@ -120,1 +120,1 @@\n-  } else if (i->type()->as_LongConstant() != NULL) {\n+  } else if (i->type()->as_LongConstant() != nullptr) {\n@@ -270,1 +270,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -329,1 +329,1 @@\n-    LIR_Opr result = call_runtime(x->x(), x->y(), entry, x->type(), NULL);\n+    LIR_Opr result = call_runtime(x->x(), x->y(), entry, x->type(), nullptr);\n@@ -390,1 +390,1 @@\n-      info = NULL;\n+      info = nullptr;\n@@ -411,1 +411,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -466,1 +466,1 @@\n-      info = NULL;\n+      info = nullptr;\n@@ -522,1 +522,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -561,1 +561,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -662,1 +662,1 @@\n-      address runtime_entry = NULL;\n+      address runtime_entry = nullptr;\n@@ -686,1 +686,1 @@\n-      LIR_Opr result = call_runtime(x->argument_at(0), runtime_entry, x->type(), NULL);\n+      LIR_Opr result = call_runtime(x->argument_at(0), runtime_entry, x->type(), nullptr);\n@@ -693,1 +693,1 @@\n-      LIR_Opr result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_entry, x->type(), NULL);\n+      LIR_Opr result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_entry, x->type(), nullptr);\n@@ -798,1 +798,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -829,1 +829,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -836,1 +836,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -885,1 +885,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -900,1 +900,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -903,1 +903,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -923,1 +923,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking).\n+  \/\/ location (null in the displaced hdr location indicates recursive locking).\n@@ -149,1 +149,1 @@\n-  \/\/ If the loaded hdr is NULL we had recursive locking, and we are done.\n+  \/\/ If the loaded hdr is null we had recursive locking, and we are done.\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  address return_pc = NULL;\n+  address return_pc = nullptr;\n@@ -72,1 +72,1 @@\n-  assert(return_pc != NULL, \"const section overflow\");\n+  assert(return_pc != nullptr, \"const section overflow\");\n@@ -285,1 +285,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -314,1 +314,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -530,1 +530,1 @@\n-        assert(Universe::heap() != NULL, \"java heap must be initialized to generate partial_subtype_check stub\");\n+        assert(Universe::heap() != nullptr, \"java heap must be initialized to generate partial_subtype_check stub\");\n@@ -550,1 +550,1 @@\n-      __ check_klass_subtype_slow_path(Rsubklass, Rsuperklass, Rarray_ptr, Rlength, NULL, &miss);\n+      __ check_klass_subtype_slow_path(Rsubklass, Rsuperklass, Rarray_ptr, Rlength, nullptr, &miss);\n@@ -630,1 +630,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -764,1 +764,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -787,1 +787,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1019,1 +1019,1 @@\n-      \/\/ Return false if one of them is NULL.\n+      \/\/ Return false if one of them is null.\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-address CompiledStaticCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = NULL*\/) {\n+address CompiledStaticCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = nullptr*\/) {\n@@ -47,1 +47,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -51,1 +51,1 @@\n-  assert(mark != NULL, \"mark must not be NULL\");\n+  assert(mark != nullptr, \"mark must not be null\");\n@@ -58,2 +58,2 @@\n-  if (stub == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed.\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed.\n@@ -63,1 +63,1 @@\n-  AddressLiteral meta = __ allocate_metadata_address(NULL);\n+  AddressLiteral meta = __ allocate_metadata_address(nullptr);\n@@ -70,1 +70,1 @@\n-    return NULL;  \/\/ CodeCache is full.\n+    return nullptr;  \/\/ CodeCache is full.\n@@ -78,1 +78,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -96,1 +96,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -121,1 +121,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -141,1 +141,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/s390\/compiledIC_s390.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -45,1 +45,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -78,1 +78,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -84,1 +84,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -89,1 +89,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -98,1 +98,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -103,1 +103,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -112,1 +112,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -117,1 +117,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -122,1 +122,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -127,1 +127,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL);\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/disassembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -114,1 +114,1 @@\n-    \/\/ In particular, (fp == NULL) might be true. So let's check and\n+    \/\/ In particular, fp might be null. So let's check and\n@@ -126,1 +126,1 @@\n-    if (sender_blob == NULL) {\n+    if (sender_blob == nullptr) {\n@@ -199,1 +199,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -211,1 +211,1 @@\n-  if (jfa->last_Java_pc() != NULL) {\n+  if (jfa->last_Java_pc() != nullptr) {\n@@ -252,1 +252,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -406,1 +406,1 @@\n-    const char* function_name = NULL;\n+    const char* function_name = nullptr;\n@@ -411,1 +411,1 @@\n-    CodeBlob* blob = NULL;\n+    CodeBlob* blob = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-\/\/ can distinguish identity and younger\/older relationship. NULL\n+\/\/ can distinguish identity and younger\/older relationship. null\n@@ -137,1 +137,1 @@\n-  assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+  assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -307,2 +307,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -310,1 +310,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -317,1 +317,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  if (on_oop && on_reference && L_handle_null == NULL) { L_handle_null = &done; }\n+  if (on_oop && on_reference && L_handle_null == nullptr) { L_handle_null = &done; }\n@@ -116,1 +116,1 @@\n-                         NULL \/* obj *\/,\n+                         nullptr \/* obj *\/,\n@@ -135,1 +135,1 @@\n-       preloaded = obj == NULL;\n+       preloaded = obj == nullptr;\n@@ -173,1 +173,1 @@\n-  \/\/ Is the previous value NULL?\n+  \/\/ Is the previous value null?\n@@ -184,1 +184,1 @@\n-    __ z_bre(filtered); \/\/ previous value is NULL, so we don't need to record it.\n+    __ z_bre(filtered); \/\/ previous value is null, so we don't need to record it.\n@@ -187,1 +187,1 @@\n-  \/\/ Decode the oop now. We know it's not NULL.\n+  \/\/ Decode the oop now. We know it's not null.\n@@ -189,1 +189,1 @@\n-    __ oop_decoder(Rpre_val, Rpre_val, \/*maybeNULL=*\/false);\n+    __ oop_decoder(Rpre_val, Rpre_val, \/*maybenullptr=*\/false);\n@@ -288,1 +288,1 @@\n-  \/\/ Crosses regions, storing NULL?\n+  \/\/ Crosses regions, storing null?\n@@ -301,1 +301,1 @@\n-  \/\/ Storing region crossing non-NULL, is card already dirty?\n+  \/\/ Storing region crossing non-null, is card already dirty?\n@@ -323,1 +323,1 @@\n-  \/\/ Storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n@@ -383,1 +383,1 @@\n-  \/\/ No need for post barrier if storing NULL\n+  \/\/ No need for post barrier if storing null\n@@ -398,1 +398,1 @@\n-  __ z_bre(Ldone);          \/\/ Use NULL result as-is.\n+  __ z_bre(Ldone);          \/\/ Use null result as-is.\n@@ -407,1 +407,1 @@\n-  g1_write_barrier_pre(masm, decorators, (const Address*)NULL, value, noreg, tmp1, tmp2, true);\n+  g1_write_barrier_pre(masm, decorators, (const Address*)nullptr, value, noreg, tmp1, tmp2, true);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-                            const Address*     obj,           \/\/ Address of oop or NULL if pre-loaded.\n+                            const Address*     obj,           \/\/ Address of oop or null if pre-loaded.\n@@ -68,1 +68,1 @@\n-                       const Address& src, Register dst, Register tmp1, Register tmp2, Label *L_handle_null = NULL);\n+                       const Address& src, Register dst, Register tmp1, Register tmp2, Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-      if (L_handle_null != NULL) { \/\/ Label provided.\n+      if (L_handle_null != nullptr) { \/\/ Label provided.\n@@ -64,1 +64,1 @@\n-      if (L_handle_null != NULL) {\n+      if (L_handle_null != nullptr) {\n@@ -111,1 +111,1 @@\n-  __ z_bre(Ldone);          \/\/ Use NULL result as-is.\n+  __ z_bre(Ldone);          \/\/ Use null result as-is.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-                       const Address& addr, Register dst, Register tmp1, Register tmp2, Label *L_handle_null = NULL);\n+                       const Address& addr, Register dst, Register tmp1, Register tmp2, Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-  \/\/ No need for post barrier if storing NULL\n+  \/\/ No need for post barrier if storing null\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-define_pd_global(bool,  UncommonNullCast,            true);  \/\/ Uncommon-trap NULLs passed to check cast.\n+define_pd_global(bool,  UncommonNullCast,            true);  \/\/ Uncommon-trap nulls passed to check cast.\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  assert(entry != NULL, \"Entry must have been generated by now\");\n+  assert(entry != nullptr, \"Entry must have been generated by now\");\n@@ -96,1 +96,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -277,1 +277,1 @@\n-    z_bre(L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    z_bre(L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -620,1 +620,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -998,1 +998,1 @@\n-  \/\/   monitor->lock()->set_displaced_header(NULL);\n+  \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1043,1 +1043,1 @@\n-  \/\/   monitor->lock()->set_displaced_header(NULL);\n+  \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1097,3 +1097,3 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1102,1 +1102,1 @@\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1123,3 +1123,3 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1137,1 +1137,1 @@\n-  \/\/   monitor->set_obj(NULL);\n+  \/\/   monitor->set_obj(nullptr);\n@@ -1179,1 +1179,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1465,1 +1465,1 @@\n-  \/\/ observed the receiver[start_row] is NULL.\n+  \/\/ observed the receiver[start_row] is null.\n@@ -1481,1 +1481,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1484,1 +1484,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1487,1 +1487,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-  bool do_NULL_check = offset() != 0 || is_static();\n+  bool do_nullptr_check = offset() != 0 || is_static();\n@@ -124,1 +124,1 @@\n-  if (do_NULL_check) {\n+  if (do_nullptr_check) {\n","filename":"src\/hotspot\/cpu\/s390\/interpreterRT_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -44,1 +44,1 @@\n-    _last_Java_pc = NULL;\n+    _last_Java_pc = nullptr;\n@@ -58,1 +58,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -63,1 +63,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n@@ -80,1 +80,1 @@\n-  intptr_t* last_Java_fp(void)        { return NULL; }\n+  intptr_t* last_Java_fp(void)        { return nullptr; }\n","filename":"src\/hotspot\/cpu\/s390\/javaFrameAnchor_s390.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-      name = NULL;  \/\/ unreachable\n+      name = nullptr;  \/\/ unreachable\n@@ -132,1 +132,1 @@\n-      slow_case_addr = NULL;  \/\/ unreachable\n+      slow_case_addr = nullptr;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/s390\/jniFastGetField_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/jvmciCodeInstaller_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-  return (long)((cs != NULL) ? cs->start()-pc() : 0);\n+  return (long)((cs != nullptr) ? cs->start()-pc() : 0);\n@@ -1145,1 +1145,1 @@\n-  assert(addr != NULL, \"should not happen\");\n+  assert(addr != nullptr, \"should not happen\");\n@@ -1147,1 +1147,1 @@\n-  if (addr == NULL) {\n+  if (addr == nullptr) {\n@@ -1798,1 +1798,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -1805,1 +1805,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -1812,1 +1812,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -1818,1 +1818,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -2175,1 +2175,1 @@\n-  address return_pc = NULL;\n+  address return_pc = nullptr;\n@@ -2380,1 +2380,1 @@\n-  _last_calls_return_pc = success ? pc() : NULL;\n+  _last_calls_return_pc = success ? pc() : nullptr;\n@@ -2574,1 +2574,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2635,1 +2635,1 @@\n-  assert(ucontext != NULL, \"must have ucontext\");\n+  assert(ucontext != nullptr, \"must have ucontext\");\n@@ -2653,1 +2653,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2781,1 +2781,1 @@\n-  \/\/ If the entry is NULL then we've reached the end of the table\n+  \/\/ If the entry is null then we've reached the end of the table\n@@ -2948,3 +2948,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n@@ -2953,1 +2953,1 @@\n-         \"at most one NULL in the batch, usually\");\n+         \"at most one null in the batch, usually\");\n@@ -3034,3 +3034,3 @@\n-  if (L_success == NULL) { L_success = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL) { L_failure = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr) { L_success = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr) { L_failure = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -3103,1 +3103,1 @@\n-                                &L_success, &failure, NULL);\n+                                &L_success, &failure, nullptr);\n@@ -3105,1 +3105,1 @@\n-                                temp1_reg, temp2_reg, &L_success, NULL);\n+                                temp1_reg, temp2_reg, &L_success, nullptr);\n@@ -3111,1 +3111,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -3114,1 +3114,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -3116,1 +3116,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -3206,1 +3206,1 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ The object's monitor m is unlocked iff m->owner is null,\n@@ -3209,1 +3209,1 @@\n-  \/\/ Try to CAS m->owner from NULL to current thread.\n+  \/\/ Try to CAS m->owner from null to current thread.\n@@ -3309,1 +3309,1 @@\n-  \/\/ last_Java_pc will always be set to NULL. It is set here so that\n+  \/\/ last_Java_pc will always be set to null. It is set here so that\n@@ -3405,1 +3405,1 @@\n-      \/\/ Provoke OS NULL exception if reg = NULL by\n+      \/\/ Provoke OS null exception if reg is null by\n@@ -3411,1 +3411,1 @@\n-      \/\/ will provoke OS NULL exception if reg = NULL.\n+      \/\/ will provoke OS null exception if reg is null.\n@@ -3450,1 +3450,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -3517,1 +3517,1 @@\n-\/\/ when (Universe::heap() != NULL). Hence, if the instructions\n+\/\/ when Universe::heap() isn't null. Hence, if the instructions\n@@ -3525,1 +3525,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -3560,1 +3560,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -3607,1 +3607,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -3682,2 +3682,2 @@\n-\/\/ maybeNULL       - True if Rop1 possibly is a NULL.\n-void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {\n+\/\/ maybenull       - True if Rop1 possibly is a null.\n+void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybenull) {\n@@ -3697,1 +3697,1 @@\n-    if (base == NULL) {\n+    if (base == nullptr) {\n@@ -3712,1 +3712,1 @@\n-      if (maybeNULL) {       \/\/ NULL ptr must be preserved!\n+      if (maybenull) {       \/\/ null ptr must be preserved!\n@@ -3815,3 +3815,3 @@\n-\/\/ maybeNULL       - True if Rop1 possibly is a NULL.\n-\/\/ maybeNULLtarget - Branch target for Rop1 == NULL, if flow control shall NOT continue with compare instruction.\n-void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {\n+\/\/ maybenull       - True if Rop1 possibly is a null.\n+\/\/ maybenulltarget - Branch target for Rop1 == nullptr, if flow control shall NOT continue with compare instruction.\n+void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybenull) {\n@@ -3826,1 +3826,1 @@\n-  assert(Universe::heap() != NULL, \"java heap must be initialized to call this method\");\n+  assert(Universe::heap() != nullptr, \"java heap must be initialized to call this method\");\n@@ -3836,1 +3836,1 @@\n-  if (base == NULL) {\n+  if (base == nullptr) {\n@@ -3851,1 +3851,1 @@\n-    if (maybeNULL) {       \/\/ NULL ptr must be preserved!\n+    if (maybenull) {       \/\/ null ptr must be preserved!\n@@ -3931,1 +3931,1 @@\n-void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,\n+void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybenull,\n@@ -3939,1 +3939,1 @@\n-  assert(Universe::heap() != NULL, \"java heap must be initialized to call this encoder\");\n+  assert(Universe::heap() != nullptr, \"java heap must be initialized to call this encoder\");\n@@ -3942,1 +3942,1 @@\n-  if (disjoint || (oop_base == NULL)) {\n+  if (disjoint || (oop_base == nullptr)) {\n@@ -3945,1 +3945,1 @@\n-      if (oop_base != NULL && !only32bitValid) {\n+      if (oop_base != nullptr && !only32bitValid) {\n@@ -3952,1 +3952,1 @@\n-      if (oop_base != NULL && !only32bitValid) {\n+      if (oop_base != nullptr && !only32bitValid) {\n@@ -3966,1 +3966,1 @@\n-  if (maybeNULL) {\n+  if (maybenull) {\n@@ -3993,1 +3993,1 @@\n-    \/\/ Check for NULL oop (must be left alone) and shift.\n+    \/\/ Check for null oop (must be left alone) and shift.\n@@ -4004,1 +4004,1 @@\n-      z_ltgr(Rdst, Rsrc);   \/\/ Move NULL to result register.\n+      z_ltgr(Rdst, Rsrc);   \/\/ Move null to result register.\n@@ -4067,1 +4067,1 @@\n-void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {\n+void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybenull, Register Rbase, int pow2_offset) {\n@@ -4074,1 +4074,1 @@\n-  assert(Universe::heap() != NULL, \"java heap must be initialized to call this decoder\");\n+  assert(Universe::heap() != nullptr, \"java heap must be initialized to call this decoder\");\n@@ -4080,1 +4080,1 @@\n-  if (oop_base != NULL) {\n+  if (oop_base != nullptr) {\n@@ -4091,1 +4091,1 @@\n-      if (maybeNULL) {  \/\/ NULL ptr must be preserved!\n+      if (maybenull) {  \/\/ null ptr must be preserved!\n@@ -4151,1 +4151,1 @@\n-      \/\/ Scale oop and check for NULL.\n+      \/\/ Scale oop and check for null.\n@@ -4153,1 +4153,1 @@\n-      if (maybeNULL) {  \/\/ NULL ptr must be preserved!\n+      if (maybenull) {  \/\/ null ptr must be preserved!\n@@ -4431,1 +4431,1 @@\n-  if (tocPos != NULL) {\n+  if (tocPos != nullptr) {\n@@ -4435,1 +4435,1 @@\n-  \/\/ Address_constant returned NULL, so no constant entry has been created.\n+  \/\/ Address_constant returned null, so no constant entry has been created.\n@@ -4449,1 +4449,1 @@\n-  if (tocPos != NULL) {\n+  if (tocPos != nullptr) {\n@@ -4463,1 +4463,1 @@\n-  \/\/ Address_constant returned NULL, so no constant entry has been created\n+  \/\/ Address_constant returned null, so no constant entry has been created\n@@ -4473,1 +4473,1 @@\n-  assert((address)code()->consts()->start() != NULL, \"Please add CP address\");\n+  assert((address)code()->consts()->start() != nullptr, \"Please add CP address\");\n@@ -4483,1 +4483,1 @@\n-  assert((address)code()->consts()->start() != NULL, \"Please add CP address\");\n+  assert((address)code()->consts()->start() != nullptr, \"Please add CP address\");\n@@ -4497,1 +4497,1 @@\n-  address dataLoc = NULL;\n+  address dataLoc = nullptr;\n@@ -4516,1 +4516,1 @@\n-  address dataLoc = NULL;\n+  address dataLoc = nullptr;\n@@ -4521,1 +4521,1 @@\n-    assert((cb == NULL) || (nm == (nmethod*)cb), \"instruction address should be in CodeBlob\");\n+    assert((cb == nullptr) || (nm == (nmethod*)cb), \"instruction address should be in CodeBlob\");\n@@ -5537,1 +5537,1 @@\n-  BLOCK_COMMENT(err_msg(\"stop_chain(%s,%s): %s {\", reentry==NULL?\"init\":\"cont\", allow_relocation?\"reloc \":\"static\", msg));\n+  BLOCK_COMMENT(err_msg(\"stop_chain(%s,%s): %s {\", reentry==nullptr?\"init\":\"cont\", allow_relocation?\"reloc \":\"static\", msg));\n@@ -5548,1 +5548,1 @@\n-  if ((reentry != NULL) && RelAddr::is_in_range_of_RelAddr16(reentry, pc())) {\n+  if ((reentry != nullptr) && RelAddr::is_in_range_of_RelAddr16(reentry, pc())) {\n@@ -5557,1 +5557,1 @@\n-      reentry = NULL;    \/\/ Prevent reentry if code relocation is allowed.\n+      reentry = nullptr;    \/\/ Prevent reentry if code relocation is allowed.\n@@ -5572,1 +5572,1 @@\n-  stop_chain(NULL, type, msg, id, false);\n+  stop_chain(nullptr, type, msg, id, false);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -716,2 +716,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n@@ -750,1 +750,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -752,1 +752,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -774,1 +774,1 @@\n-  \/\/ when (Universe::heap() != NULL). Hence, if the instructions\n+  \/\/ when Universe::heap() isn't null. Hence, if the instructions\n@@ -784,2 +784,2 @@\n-  void compare_heap_oop(Register Rop1, Address mem, bool maybeNULL);\n-  void compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL);\n+  void compare_heap_oop(Register Rop1, Address mem, bool maybenull);\n+  void compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybenull);\n@@ -794,1 +794,1 @@\n-                      Register tmp1, Register tmp2, Label *is_null = NULL);\n+                      Register tmp1, Register tmp2, Label *is_null = nullptr);\n@@ -800,1 +800,1 @@\n-                     DecoratorSet decorators = 0, Label *is_null = NULL);\n+                     DecoratorSet decorators = 0, Label *is_null = nullptr);\n@@ -805,1 +805,1 @@\n-  void oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,\n+  void oop_encoder(Register Rdst, Register Rsrc, bool maybenull,\n@@ -807,1 +807,1 @@\n-  void oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL,\n+  void oop_decoder(Register Rdst, Register Rsrc, bool maybenull,\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    if (CompressedOops::base() == NULL && CompressedOops::shift() == 0) return true;\n+    if (CompressedOops::base() == nullptr && CompressedOops::shift() == 0) return true;\n@@ -87,1 +87,1 @@\n-    return CompressedOops::base() == NULL;\n+    return CompressedOops::base() == nullptr;\n@@ -92,1 +92,1 @@\n-    return CompressedKlassPointers::base() == NULL;\n+    return CompressedKlassPointers::base() == nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, \"not yet generated!\");\n+  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n@@ -252,1 +252,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -259,1 +259,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -562,2 +562,2 @@\n-  bool has_mh = (strstr(adaptername, \"\/static\") == NULL &&\n-                 strstr(adaptername, \"linkTo\") == NULL);    \/\/ Static linkers don't have MH.\n+  bool has_mh = (strstr(adaptername, \"\/static\") == nullptr &&\n+                 strstr(adaptername, \"linkTo\") == nullptr);    \/\/ Static linkers don't have MH.\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  \/\/  - NULL\n+  \/\/  - null\n@@ -71,1 +71,1 @@\n-  if (msg == NULL) { \/\/ Output line without trailing blanks.\n+  if (msg == nullptr) { \/\/ Output line without trailing blanks.\n@@ -92,1 +92,1 @@\n-  print(NULL);\n+  print(nullptr);\n@@ -97,1 +97,1 @@\n-  Assembler::dump_code_range(tty, addr_at(0), range, (msg == NULL) ? \"\":msg);\n+  Assembler::dump_code_range(tty, addr_at(0), range, (msg == nullptr) ? \"\":msg);\n@@ -101,1 +101,1 @@\n-  dump(range, NULL);\n+  dump(range, nullptr);\n@@ -105,1 +105,1 @@\n-  dump(32, NULL);\n+  dump(32, nullptr);\n@@ -179,1 +179,1 @@\n-  if (cb == NULL || !cb->is_nmethod()) {\n+  if (cb == nullptr || !cb->is_nmethod()) {\n@@ -258,1 +258,1 @@\n-  address ctable = NULL;\n+  address ctable = nullptr;\n@@ -371,1 +371,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -388,1 +388,1 @@\n-    return *(intptr_t *)NULL;\n+    return *(intptr_t *)nullptr;\n@@ -484,2 +484,2 @@\n-  nmethod* nm = cb ? cb->as_nmethod_or_null() : NULL;\n-  if (nm != NULL) {\n+  nmethod* nm = cb ? cb->as_nmethod_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -487,2 +487,2 @@\n-    oop* oop_addr = NULL;\n-    Metadata** metadata_addr = NULL;\n+    oop* oop_addr = nullptr;\n+    Metadata** metadata_addr = nullptr;\n@@ -492,1 +492,1 @@\n-        if (oop_addr == NULL) {\n+        if (oop_addr == nullptr) {\n@@ -501,1 +501,1 @@\n-        if (metadata_addr == NULL) {\n+        if (metadata_addr == nullptr) {\n@@ -510,2 +510,2 @@\n-          (expected_type == relocInfo::metadata_type && metadata_addr != NULL) ||\n-          (expected_type == relocInfo::oop_type && oop_addr != NULL),\n+          (expected_type == relocInfo::metadata_type && metadata_addr != nullptr) ||\n+          (expected_type == relocInfo::oop_type && oop_addr != nullptr),\n@@ -543,1 +543,1 @@\n-void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, CompiledMethod *passed_nm \/* = NULL *\/) {\n+void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, CompiledMethod *passed_nm \/* = nullptr *\/) {\n@@ -568,1 +568,1 @@\n-void NativeMovConstReg::set_pcrel_data(intptr_t newData, CompiledMethod *passed_nm \/* = NULL *\/) {\n+void NativeMovConstReg::set_pcrel_data(intptr_t newData, CompiledMethod *passed_nm \/* = nullptr *\/) {\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,1 +260,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -328,1 +328,1 @@\n-    NativeCall *call = NULL;\n+    NativeCall *call = nullptr;\n@@ -489,2 +489,2 @@\n-  void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = NULL);\n-  void set_pcrel_data(intptr_t data, CompiledMethod *nm = NULL);\n+  void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = nullptr);\n+  void set_pcrel_data(intptr_t data, CompiledMethod *nm = nullptr);\n@@ -667,1 +667,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -672,2 +672,2 @@\n-  address instruction_address() const       { Unimplemented(); return NULL; }\n-  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+  address instruction_address() const       { Unimplemented(); return nullptr; }\n+  address next_instruction_address() const  { Unimplemented(); return nullptr; }\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-  \/\/ Since there is none, we just return NULL.\n-  address pd_location(VMReg reg) const {return NULL;}\n+  \/\/ Since there is none, we just return null.\n+  address pd_location(VMReg reg) const {return nullptr;}\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    if (orig_addr == NULL) {\n+    if (orig_addr == nullptr) {\n","filename":"src\/hotspot\/cpu\/s390\/relocInfo_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  \/\/ [Z_RET]!=NULL was possible in hotspot5 but not in sapjvm6.\n+  \/\/ [Z_RET] isn't null was possible in hotspot5 but not in sapjvm6.\n@@ -122,1 +122,1 @@\n-  __ asm_assert_ne(\"handler must not be NULL\", 0x852);\n+  __ asm_assert_ne(\"handler must not be null\", 0x852);\n@@ -148,1 +148,1 @@\n-  OopMapSet *oop_maps = NULL;\n+  OopMapSet *oop_maps = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  const RegisterSaver::LiveRegType* live_regs = NULL;\n+  const RegisterSaver::LiveRegType* live_regs = nullptr;\n@@ -401,1 +401,1 @@\n-  const RegisterSaver::LiveRegType* live_regs = NULL;\n+  const RegisterSaver::LiveRegType* live_regs = nullptr;\n@@ -451,1 +451,1 @@\n-  const RegisterSaver::LiveRegType* live_regs = NULL;\n+  const RegisterSaver::LiveRegType* live_regs = nullptr;\n@@ -765,1 +765,1 @@\n-  assert(regs2 == NULL, \"second VMRegPair array not used on this platform\");\n+  assert(regs2 == nullptr, \"second VMRegPair array not used on this platform\");\n@@ -1020,1 +1020,1 @@\n-    \/\/ Use a NULL handle if oop is NULL.\n+    \/\/ Use a null handle if oop is null.\n@@ -1046,1 +1046,1 @@\n-    \/\/ If Oop == NULL, use a NULL handle.\n+    \/\/ If Oop is null, use a null handle.\n@@ -1327,1 +1327,1 @@\n-                                       (OopMapSet *) NULL);\n+                                       (OopMapSet *) nullptr);\n@@ -1338,1 +1338,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1366,1 +1366,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1460,1 +1460,1 @@\n-  int stack_slots = c_calling_convention(out_sig_bt, out_regs, \/*regs2=*\/NULL, total_c_args) + \/\/ 1+2\n+  int stack_slots = c_calling_convention(out_sig_bt, out_regs, \/*regs2=*\/nullptr, total_c_args) + \/\/ 1+2\n@@ -2078,1 +2078,1 @@\n-  __ z_brne(patch_callsite);                    \/\/ Patch required if code != NULL (compiled target exists).\n+  __ z_brne(patch_callsite);                    \/\/ Patch required if code isn't null (compiled target exists).\n@@ -2361,1 +2361,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -2513,1 +2513,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2630,1 +2630,1 @@\n-  \/\/ Don't set last_Java_pc anymore here (is implicitly NULL then).\n+  \/\/ Don't set last_Java_pc anymore here (is implicitly null then).\n@@ -2847,1 +2847,1 @@\n-  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, NULL, framesize_in_bytes\/wordSize);\n+  _uncommon_trap_blob = UncommonTrapBlob::create(&buffer, nullptr, framesize_in_bytes\/wordSize);\n@@ -2857,1 +2857,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL,\n+  assert(StubRoutines::forward_exception_entry() != nullptr,\n@@ -2869,1 +2869,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2958,1 +2958,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2967,1 +2967,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -80,1 +80,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -55,1 +55,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -61,1 +61,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -67,1 +67,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL, \"must have been generated before\");\n+    assert(StubRoutines::_call_stub_return_address != nullptr, \"must have been generated before\");\n@@ -652,1 +652,1 @@\n-                                    NULL \/*oop_maps*\/, false);\n+                                    nullptr \/*oop_maps*\/, false);\n@@ -688,1 +688,1 @@\n-      assert(Universe::heap() != NULL, \"java heap must be initialized to generate partial_subtype_check stub\");\n+      assert(Universe::heap() != nullptr, \"java heap must be initialized to generate partial_subtype_check stub\");\n@@ -693,1 +693,1 @@\n-                                     Rarray_ptr, Rlength, NULL, &miss);\n+                                     Rarray_ptr, Rlength, nullptr, &miss);\n@@ -3174,1 +3174,1 @@\n-        \/\/ In PRODUCT builds, the function pointers will keep their initial (NULL) value.\n+        \/\/ In PRODUCT builds, the function pointers will keep their initial (null) value.\n@@ -3184,1 +3184,1 @@\n-        \/\/ In PRODUCT builds, the function pointers will keep their initial (NULL) value.\n+        \/\/ In PRODUCT builds, the function pointers will keep their initial (null) value.\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-address StubRoutines::zarch::_partial_subtype_check = NULL;\n+address StubRoutines::zarch::_partial_subtype_check = nullptr;\n@@ -39,1 +39,1 @@\n-address StubRoutines::zarch::_trot_table_addr = NULL;\n+address StubRoutines::zarch::_trot_table_addr = nullptr;\n@@ -41,1 +41,1 @@\n-address StubRoutines::zarch::_nmethod_entry_barrier = NULL;\n+address StubRoutines::zarch::_nmethod_entry_barrier = nullptr;\n@@ -51,1 +51,1 @@\n-  assert(table_addr != NULL, \"CRC lookup table address must be initialized by now\");\n+  assert(table_addr != nullptr, \"CRC lookup table address must be initialized by now\");\n@@ -93,1 +93,1 @@\n-    assert(_trot_table_addr != NULL, \"Translate table address must be initialized by now\");\n+    assert(_trot_table_addr != nullptr, \"Translate table address must be initialized by now\");\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-  \/\/ Load reference and check for NULL.\n+  \/\/ Load reference and check for null.\n@@ -592,1 +592,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -600,1 +600,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -611,1 +611,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -641,1 +641,1 @@\n-  \/\/  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/  \/\/ and null it as marker that esp is now tos until next java call\n@@ -686,1 +686,1 @@\n-  \/\/ TODO(ZASM): necessary? NULL last_sp until next java call\n+  \/\/ TODO(ZASM): necessary? null last_sp until next java call\n@@ -704,1 +704,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -783,2 +783,2 @@\n-  \/\/ (NULL bcp). We pass zero for it. The call returns the address\n-  \/\/ of the verified entry point for the method or NULL if the\n+  \/\/ (null bcp). We pass zero for it. The call returns the address\n+  \/\/ of the verified entry point for the method or null if the\n@@ -815,1 +815,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -853,1 +853,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -878,1 +878,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -912,1 +912,1 @@\n-      reentry = __ stop_chain_static(reentry, \"synchronization object is NULL\");\n+      reentry = __ stop_chain_static(reentry, \"synchronization object is null\");\n@@ -1135,1 +1135,1 @@\n-  \/\/ z_ijava_state->oop_temp = NULL;\n+  \/\/ z_ijava_state->oop_temp = nullptr;\n@@ -1140,1 +1140,1 @@\n-  \/\/ native_call: assert that mdo == NULL\n+  \/\/ native_call: assert that mdo is null\n@@ -1210,1 +1210,1 @@\n-  address runtime_entry = NULL;\n+  address runtime_entry = nullptr;\n@@ -1239,1 +1239,1 @@\n-  if (!use_instruction && runtime_entry == NULL) return NULL;\n+  if (!use_instruction && runtime_entry == nullptr) return nullptr;\n@@ -1346,1 +1346,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -1714,1 +1714,1 @@\n-  address reentry = NULL;\n+  address reentry = nullptr;\n@@ -2168,1 +2168,1 @@\n-    \/\/ argument, or NULL.\n+    \/\/ argument, or null.\n@@ -2381,1 +2381,1 @@\n-  guarantee(entry != NULL, \"entry must have been generated\");\n+  guarantee(entry != nullptr, \"entry must have been generated\");\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-\/\/ Pass NULL, if no shift instruction should be emitted.\n+\/\/ Pass null, if no shift instruction should be emitted.\n@@ -149,1 +149,1 @@\n-\/\/ Pass NULL, if no shift instruction should be emitted.\n+\/\/ Pass null, if no shift instruction should be emitted.\n@@ -467,1 +467,1 @@\n-  \/\/ Convert null sentinel to NULL.\n+  \/\/ Convert null sentinel to null.\n@@ -1170,1 +1170,1 @@\n-  \/\/ do array store check - check for NULL value first.\n+  \/\/ do array store check - check for null value first.\n@@ -1194,1 +1194,1 @@\n-  \/\/ Have a NULL in Rvalue.\n+  \/\/ Have a null in Rvalue.\n@@ -1198,1 +1198,1 @@\n-  \/\/ Store a NULL.\n+  \/\/ Store a null.\n@@ -1940,1 +1940,1 @@\n-                                 UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+                                 UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -1951,1 +1951,1 @@\n-                               UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+                               UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -1975,1 +1975,1 @@\n-    \/\/ Z_RET: osr nmethod (osr ok) or NULL (osr not possible).\n+    \/\/ Z_RET: osr nmethod (osr ok) or null (osr not possible).\n@@ -2388,1 +2388,1 @@\n-    __ clinit_barrier(klass, Z_thread, NULL \/*L_fast_path*\/, &clinit_barrier_slow);\n+    __ clinit_barrier(klass, Z_thread, nullptr \/*L_fast_path*\/, &clinit_barrier_slow);\n@@ -2550,1 +2550,1 @@\n-    __ clear_reg(Z_ARG2, true, false); \/\/ NULL object reference. Don't set CC.\n+    __ clear_reg(Z_ARG2, true, false); \/\/ null object reference. Don't set CC.\n@@ -2555,1 +2555,1 @@\n-  \/\/ Z_ARG2: object pointer or NULL\n+  \/\/ Z_ARG2: object pointer or null\n@@ -2867,1 +2867,1 @@\n-  \/\/ Z_ARG2: object pointer set up above (NULL if static)\n+  \/\/ Z_ARG2: object pointer set up above (null if static)\n@@ -3789,1 +3789,1 @@\n-  address prev_instr_address = NULL;\n+  address prev_instr_address = nullptr;\n@@ -3933,1 +3933,1 @@\n-  \/\/ If object is NULL, we are almost done.\n+  \/\/ If object is null, we are almost done.\n@@ -3987,1 +3987,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -4006,1 +4006,1 @@\n-  \/\/ If object is NULL, we are almost done.\n+  \/\/ If object is null, we are almost done.\n@@ -4057,1 +4057,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -4067,2 +4067,2 @@\n-  \/\/ tos = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ tos = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ tos = 0: obj is    null or  obj is not an instanceof the specified klass\n+  \/\/ tos = 1: obj isn't null and obj is     an instanceof the specified klass\n@@ -4144,1 +4144,1 @@\n-  \/\/ Check for NULL object.\n+  \/\/ Check for null object.\n@@ -4150,1 +4150,1 @@\n-  __ clear_reg(Rfree_slot, true, false); \/\/ Points to free slot or NULL. Don't set CC.\n+  __ clear_reg(Rfree_slot, true, false); \/\/ Points to free slot or null. Don't set CC.\n@@ -4163,1 +4163,1 @@\n-    address reentry = NULL;\n+    address reentry = nullptr;\n@@ -4196,1 +4196,1 @@\n-  \/\/ Rfree_slot != NULL -> found one\n+  \/\/ Rfree_slot isn't null -> found one\n@@ -4233,1 +4233,1 @@\n-  \/\/ Check for NULL object.\n+  \/\/ Check for null object.\n@@ -4251,1 +4251,1 @@\n-    address reentry = NULL;\n+    address reentry = nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -720,1 +720,1 @@\n-  const char* kw[] = { \"LPAR\", \"CPUs\", \"VM\", NULL };\n+  const char* kw[] = { \"LPAR\", \"CPUs\", \"VM\", nullptr };\n@@ -845,1 +845,1 @@\n-  if ((march != NULL) && (march[0] != '\\0')) {\n+  if ((march != nullptr) && (march[0] != '\\0')) {\n@@ -912,1 +912,1 @@\n-static long (*getFeatures)(unsigned long*, int, int) = NULL;\n+static long (*getFeatures)(unsigned long*, int, int) = nullptr;\n@@ -915,1 +915,1 @@\n-  if (getFeatures == NULL) {\n+  if (getFeatures == nullptr) {\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -85,1 +85,1 @@\n-  address        npe_addr     = __ pc(); \/\/ npe == NULL ptr exception\n+  address        npe_addr     = __ pc(); \/\/ npe is short for null pointer exception\n@@ -155,3 +155,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -196,1 +196,1 @@\n-  address npe_addr = __ pc(); \/\/ npe == NULL ptr exception\n+  address npe_addr = __ pc(); \/\/ npe is short for null pointer exception\n","filename":"src\/hotspot\/cpu\/s390\/vtableStubs_s390.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}