{"files":[{"patch":"@@ -357,0 +357,3 @@\n+  ~VM_PopulateDynamicDumpSharedSpace() {\n+    LambdaFormInvokers::cleanup_regenerated_classes();\n+  }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"oops\/klass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n@@ -46,0 +46,1 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n@@ -53,0 +54,1 @@\n+GrowableArrayCHeap<OopHandle, mtClassShared>* LambdaFormInvokers::_regenerated_mirrors = nullptr;\n@@ -84,0 +86,19 @@\n+\/\/ The regenerated Klass is not added to any class loader, so we need\n+\/\/ to keep its java_mirror alive to avoid class unloading.\n+void LambdaFormInvokers::add_regenerated_class(oop regenerated_class) {\n+  if (_regenerated_mirrors == nullptr) {\n+    _regenerated_mirrors = new GrowableArrayCHeap<OopHandle, mtClassShared>(150);\n+  }\n+  _regenerated_mirrors->append(OopHandle(Universe::vm_global(), regenerated_class));\n+}\n+\n+void LambdaFormInvokers::cleanup_regenerated_classes() {\n+  if (_regenerated_mirrors == nullptr) return;\n+\n+  for (int i = 0; i < _regenerated_mirrors->length(); i++) {\n+    _regenerated_mirrors->at(i).release(Universe::vm_global());\n+  }\n+  delete _regenerated_mirrors;\n+  _regenerated_mirrors = nullptr;\n+}\n+\n@@ -158,1 +179,1 @@\n-    reload_class(class_name, st, CHECK);\n+    regenerate_class(class_name, st, CHECK);\n@@ -162,2 +183,1 @@\n-\/\/ class_handle - the class name, bytes_handle - the class bytes\n-void LambdaFormInvokers::reload_class(char* name, ClassFileStream& st, TRAPS) {\n+void LambdaFormInvokers::regenerate_class(char* name, ClassFileStream& st, TRAPS) {\n@@ -183,0 +203,3 @@\n+  assert(result->java_mirror() != nullptr, \"must be\");\n+  add_regenerated_class(result->java_mirror());\n+\n@@ -194,1 +217,1 @@\n-  log_info(cds, lambda)(\"Replaced class %s, old: \" INTPTR_FORMAT \" new: \" INTPTR_FORMAT,\n+  log_info(cds, lambda)(\"Regenerated class %s, old: \" INTPTR_FORMAT \" new: \" INTPTR_FORMAT,\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -40,1 +41,3 @@\n-  static void reload_class(char* name, ClassFileStream& st, TRAPS);\n+  static GrowableArrayCHeap<OopHandle, mtClassShared>* _regenerated_mirrors;\n+  static void regenerate_class(char* name, ClassFileStream& st, TRAPS);\n+  static void add_regenerated_class(oop regenerated_class);\n@@ -48,0 +51,1 @@\n+  static void cleanup_regenerated_classes();\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    static final String REPLACE_OK = \"Replaced class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String REPLACE_OK = \"Regenerated class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpClassListWithLF.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}