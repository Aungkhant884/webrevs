{"files":[{"patch":"@@ -54,0 +54,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject dummy, jint cpu_number)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#define NS_PER_SEC 1000000000\n@@ -366,0 +367,25 @@\n+\/\/ Return the host cpu ticks since boot in nanoseconds\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    if (perfInit() == 0) {\n+        if (get_totalticks(-1, &counters.cpuTicks) < 0) {\n+            return -1;\n+        } else {\n+            long ticks_per_sec = sysconf(_SC_CLK_TCK);\n+            jlong result = (jlong)counters.cpuTicks.total;\n+            if (ticks_per_sec <= NS_PER_SEC) {\n+                long scale_factor = NS_PER_SEC\/ticks_per_sec;\n+                result = result * scale_factor;\n+            } else {\n+                long scale_factor = ticks_per_sec\/NS_PER_SEC;\n+                result = result \/ scale_factor;\n+            }\n+            return result;\n+        }\n+    } else {\n+        return -1;\n+    }\n+}\n+\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -170,0 +170,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject dummy, jint cpu_number)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/macosx\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+    private long shareCpuUsage = -1;  \/\/ used for cpu-shares-based cpuload calc.\n+    private long hostTotalTicks = -1; \/\/ used for cpu-shares-based cpuload calc.\n@@ -140,2 +142,0 @@\n-            long periodLength = containerMetrics.getCpuPeriod();\n-            long numPeriods = containerMetrics.getCpuNumPeriods();\n@@ -144,0 +144,1 @@\n+                long numPeriods = containerMetrics.getCpuNumPeriods();\n@@ -154,3 +155,32 @@\n-                if (periodLength > 0 && numPeriods > 0 && usageNanos > 0) {\n-                    long shareNanos = TimeUnit.MICROSECONDS.toNanos(periodLength * numPeriods * share \/ PER_CPU_SHARES);\n-                    double systemLoad = (double) usageNanos \/ shareNanos;\n+                if (usageNanos > 0) {\n+                    \/\/ If cpu shares are in effect calculate the cpu load\n+                    \/\/ based on the following formula (similar to how\n+                    \/\/ getCpuLoad0() is being calculated):\n+                    \/\/\n+                    \/\/   | usageticks - usageticks' |\n+                    \/\/  ------------------------------\n+                    \/\/   | totalticks - totalticks' |\n+                    \/\/\n+                    \/\/ where usageticks' and totalticks' are historical values\n+                    \/\/ retrieved via an earlier call of this method. Total ticks are\n+                    \/\/ scaled to the container effective number of cpus.\n+                    long distance = 0;\n+                    if (this.shareCpuUsage > -1) {\n+                        distance = usageNanos - this.shareCpuUsage;\n+                    }\n+                    this.shareCpuUsage = usageNanos;\n+                    long totalDistance = 0;\n+                    long hostTicks = getHostTotalCpuTicks0();\n+                    if (this.hostTotalTicks > -1 && hostTicks > -1) {\n+                         totalDistance = hostTicks - this.hostTotalTicks;\n+                    }\n+                    this.hostTotalTicks = hostTicks;\n+                    int totalCPUs = getHostOnlineCpuCount0();\n+                    int containerCPUs = getAvailableProcessors();\n+                    \/\/ scale the total host load to the actual container cpus\n+                    totalDistance = totalDistance * containerCPUs \/ totalCPUs;\n+                    double systemLoad = 0.0;\n+                    if (distance > 0 && totalDistance > 0) {\n+                        systemLoad = ((double)distance) \/ totalDistance;\n+                    }\n+\n@@ -223,0 +253,2 @@\n+    \/\/ CPU ticks since boot in nanoseconds\n+    private native long getHostTotalCpuTicks0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"}]}