{"files":[{"patch":"@@ -54,0 +54,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#define NS_PER_SEC 1000000000\n@@ -366,0 +367,25 @@\n+\/\/ Return the host cpu ticks since boot in nanoseconds\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    if (perfInit() == 0) {\n+        if (get_totalticks(-1, &counters.cpuTicks) < 0) {\n+            return -1;\n+        } else {\n+            long ticks_per_sec = sysconf(_SC_CLK_TCK);\n+            jlong result = (jlong)counters.cpuTicks.total;\n+            if (ticks_per_sec <= NS_PER_SEC) {\n+                long scale_factor = NS_PER_SEC\/ticks_per_sec;\n+                result = result * scale_factor;\n+            } else {\n+                long scale_factor = ticks_per_sec\/NS_PER_SEC;\n+                result = result \/ scale_factor;\n+            }\n+            return result;\n+        }\n+    } else {\n+        return -1;\n+    }\n+}\n+\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -170,0 +170,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/macosx\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    private static final int PER_CPU_SHARES = 1024;\n@@ -45,0 +46,2 @@\n+    private long shareCpuUsage = -1;  \/\/ used for cpu-shares-based cpuload calc.\n+    private long hostTotalTicks = -1; \/\/ used for cpu-shares-based cpuload calc.\n@@ -138,0 +141,2 @@\n+            long share = containerMetrics.getCpuShares();\n+            long usageNanos = containerMetrics.getCpuUsage();\n@@ -139,1 +144,0 @@\n-                long periodLength = containerMetrics.getCpuPeriod();\n@@ -141,4 +145,42 @@\n-                long usageNanos = containerMetrics.getCpuUsage();\n-                if (periodLength > 0 && numPeriods > 0 && usageNanos > 0) {\n-                    long elapsedNanos = TimeUnit.MICROSECONDS.toNanos(periodLength * numPeriods);\n-                    double systemLoad = (double) usageNanos \/ elapsedNanos;\n+                if (numPeriods > 0 && usageNanos > 0) {\n+                    long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                    double systemLoad = (double) usageNanos \/ quotaNanos;\n+                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+                    systemLoad = Math.max(0.0, systemLoad);\n+                    systemLoad = Math.min(1.0, systemLoad);\n+                    return systemLoad;\n+                }\n+                return -1;\n+            } else if (share > 0) {\n+                if (usageNanos > 0) {\n+                    \/\/ If cpu shares are in effect calculate the cpu load\n+                    \/\/ based on the following formula (similar to how\n+                    \/\/ getCpuLoad0() is being calculated):\n+                    \/\/\n+                    \/\/   | usageticks - usageticks' |\n+                    \/\/  ------------------------------\n+                    \/\/   | totalticks - totalticks' |\n+                    \/\/\n+                    \/\/ where usageticks' and totalticks' are historical values\n+                    \/\/ retrieved via an earlier call of this method. Total ticks are\n+                    \/\/ scaled to the container effective number of cpus.\n+                    long distance = 0;\n+                    if (this.shareCpuUsage > -1) {\n+                        distance = usageNanos - this.shareCpuUsage;\n+                    }\n+                    this.shareCpuUsage = usageNanos;\n+                    long totalDistance = 0;\n+                    long hostTicks = getHostTotalCpuTicks0();\n+                    if (this.hostTotalTicks > -1 && hostTicks > -1) {\n+                         totalDistance = hostTicks - this.hostTotalTicks;\n+                    }\n+                    this.hostTotalTicks = hostTicks;\n+                    int totalCPUs = getHostOnlineCpuCount0();\n+                    int containerCPUs = getAvailableProcessors();\n+                    \/\/ scale the total host load to the actual container cpus\n+                    totalDistance = totalDistance * containerCPUs \/ totalCPUs;\n+                    double systemLoad = 0.0;\n+                    if (distance > 0 && totalDistance > 0) {\n+                        systemLoad = ((double)distance) \/ totalDistance;\n+                    }\n+\n@@ -152,1 +194,1 @@\n-                \/\/ If CPU quotas are not active then find the average system load for\n+                \/\/ If CPU quotas and shares are not active then find the average system load for\n@@ -211,0 +253,2 @@\n+    \/\/ CPU ticks since boot in nanoseconds\n+    private native long getHostTotalCpuTicks0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"}]}