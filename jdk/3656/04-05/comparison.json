{"files":[{"patch":"@@ -45,2 +45,2 @@\n-    private long shareCpuUsage = -1;  \/\/ used for cpu-shares-based cpuload calc.\n-    private long hostTotalTicks = -1; \/\/ used for cpu-shares-based cpuload calc.\n+    private long usageTicks = 0; \/\/ used for cpu load calculation\n+    private long totalTicks = 0; \/\/ used for cpu load calculation\n@@ -137,0 +137,32 @@\n+    private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+        \/\/ If cpu quota or cpu shares are in effect calculate the cpu load\n+        \/\/ based on the following formula (similar to how\n+        \/\/ getCpuLoad0() is being calculated):\n+        \/\/\n+        \/\/   | usageTicks - usageTicks' |\n+        \/\/  ------------------------------\n+        \/\/   | totalTicks - totalTicks' |\n+        \/\/\n+        \/\/ where usageTicks' and totalTicks' are historical values\n+        \/\/ retrieved via an earlier call of this method.\n+        \/\/\n+        \/\/ Total ticks should be scaled to the container effective number\n+        \/\/ of cpus, if cpu shares are in effect.\n+        if (usageTicks < 0 || totalTicks <= 0) {\n+            return -1;\n+        }\n+        long distance = usageTicks - this.usageTicks;\n+        this.usageTicks = usageTicks;\n+        long totalDistance = totalTicks - this.totalTicks;\n+        this.totalTicks = totalTicks;\n+\n+        double systemLoad = 0.0;\n+        if (distance > 0 && totalDistance > 0) {\n+            systemLoad = ((double)distance) \/ totalDistance;\n+        }\n+        \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+        systemLoad = Math.max(0.0, systemLoad);\n+        systemLoad = Math.min(1.0, systemLoad);\n+        return systemLoad;\n+    }\n+\n@@ -144,9 +176,2 @@\n-                if (numPeriods > 0 && usageNanos > 0) {\n-                    long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-                    double systemLoad = (double) usageNanos \/ quotaNanos;\n-                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-                    systemLoad = Math.max(0.0, systemLoad);\n-                    systemLoad = Math.min(1.0, systemLoad);\n-                    return systemLoad;\n-                }\n-                return -1;\n+                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                return getUsageDividesTotal(usageNanos, quotaNanos);\n@@ -154,38 +179,6 @@\n-                if (usageNanos > 0) {\n-                    \/\/ If cpu shares are in effect calculate the cpu load\n-                    \/\/ based on the following formula (similar to how\n-                    \/\/ getCpuLoad0() is being calculated):\n-                    \/\/\n-                    \/\/   | usageticks - usageticks' |\n-                    \/\/  ------------------------------\n-                    \/\/   | totalticks - totalticks' |\n-                    \/\/\n-                    \/\/ where usageticks' and totalticks' are historical values\n-                    \/\/ retrieved via an earlier call of this method. Total ticks are\n-                    \/\/ scaled to the container effective number of cpus.\n-                    long distance = 0;\n-                    if (this.shareCpuUsage > -1) {\n-                        distance = usageNanos - this.shareCpuUsage;\n-                    }\n-                    this.shareCpuUsage = usageNanos;\n-                    long totalDistance = 0;\n-                    long hostTicks = getHostTotalCpuTicks0();\n-                    if (this.hostTotalTicks > -1 && hostTicks > -1) {\n-                         totalDistance = hostTicks - this.hostTotalTicks;\n-                    }\n-                    this.hostTotalTicks = hostTicks;\n-                    int totalCPUs = getHostOnlineCpuCount0();\n-                    int containerCPUs = getAvailableProcessors();\n-                    \/\/ scale the total host load to the actual container cpus\n-                    totalDistance = totalDistance * containerCPUs \/ totalCPUs;\n-                    double systemLoad = 0.0;\n-                    if (distance > 0 && totalDistance > 0) {\n-                        systemLoad = ((double)distance) \/ totalDistance;\n-                    }\n-\n-                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-                    systemLoad = Math.max(0.0, systemLoad);\n-                    systemLoad = Math.min(1.0, systemLoad);\n-                    return systemLoad;\n-                }\n-                return -1;\n+                long hostTicks = getHostTotalCpuTicks0();\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                \/\/ scale the total host load to the actual container cpus\n+                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+                return getUsageDividesTotal(usageNanos, hostTicks);\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":42,"deletions":49,"binary":false,"changes":91,"status":"modified"}]}