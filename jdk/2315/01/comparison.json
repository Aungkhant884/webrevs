{"files":[{"patch":"@@ -1433,0 +1433,1 @@\n+          Node* outer_loop_clone = NULL;\n@@ -1480,10 +1481,19 @@\n-              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined()) && is_dominator(n_ctrl, x_head)) {\n-                \/\/ Anti dependence analysis is sometimes too\n-                \/\/ conservative: a store in the outer strip mined loop\n-                \/\/ can prevent a load from floating out of the outer\n-                \/\/ strip mined loop but the load may not be referenced\n-                \/\/ from the safepoint: loop strip mining verification\n-                \/\/ code reports a problem in that case. Make sure the\n-                \/\/ load is not moved in the outer strip mined loop in\n-                \/\/ that case.\n-                x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined())) {\n+                if (is_dominator(n_ctrl, x_head)) {\n+                  \/\/ Anti dependence analysis is sometimes too\n+                  \/\/ conservative: a store in the outer strip mined loop\n+                  \/\/ can prevent a load from floating out of the outer\n+                  \/\/ strip mined loop but the load may not be referenced\n+                  \/\/ from the safepoint: loop strip mining verification\n+                  \/\/ code reports a problem in that case. Make sure the\n+                  \/\/ load is not moved in the outer strip mined loop in\n+                  \/\/ that case.\n+                  x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+                } else if (x_head->is_OuterStripMinedLoop()) {\n+                  \/\/ Do not add duplicate LoadNodes to the outer strip mined loop\n+                  if (outer_loop_clone != NULL) {\n+                    _igvn.replace_node(x, outer_loop_clone);\n+                    continue;\n+                  }\n+                  outer_loop_clone = x;\n+                }\n@@ -1506,2 +1516,1 @@\n-            BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-            if (!x->is_Load() && !x->is_DecodeNarrowPtr() && !x->is_AddP() && !bs->is_gc_barrier_node(x)) {\n+            if (!x->is_Load() && !x->is_DecodeNarrowPtr()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 8249607\n+ * @bug 8249607 8260420\n+ * @library \/test\/lib\n@@ -34,0 +35,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -42,1 +45,1 @@\n-    public void test() {\n+    public void test1() {\n@@ -100,0 +103,52 @@\n+\n+    static class MyClass {\n+        int x = 42;\n+    }\n+\n+    int res = 0;\n+\n+    \/\/ The obj1.x load has two uses: The 'res' store and the return. After cloning, both loads end up in the\n+    \/\/ OuterStripMinedLoop which triggers an assert in LoopNode::verify_strip_mined:\n+    \/\/ assert(found_sfpt) failed: no node in loop that's not input to safepoint\n+    int test2(MyClass obj1, MyClass obj2) {\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                obj2.x = 42; \/\/ Prevents obj1.x load from floating up because obj2 could alias obj1\n+                res = obj1.x;\n+            }\n+            for (int j = 0; j < 10_000; ++j) {\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Same as test2 but with reference to outer loop induction variable 'i' and different order of instructions.\n+    \/\/ Triggers an assert in PhaseIdealLoop::build_loop_late_post_work if loop strip mining verification is disabled:\n+    \/\/ assert(false) failed: Bad graph detected in build_loop_late\n+    int test3(MyClass obj1, MyClass obj2) {\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                res = obj1.x + i;\n+                obj2.x = 42;\n+            }\n+            for (int j = 0; j < 10_000; ++j) {\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Same as test2 but with reference to inner loop induction variable 'j' and different order of instructions.\n+    \/\/ Triggers an assert in PhaseCFG::insert_anti_dependences if loop strip mining verification is disabled:\n+    \/\/ assert(!LCA_orig->dominates(pred_block) || early->dominates(pred_block)) failed: early is high enough\n+    int test4(MyClass obj1, MyClass obj2) {\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                res = obj1.x + j;\n+                obj2.x = 42;\n+            }\n+            for (int j = 0; j < 10_000; ++j) {\n+            }\n+        }\n+        return res;\n+    }\n+\n@@ -102,0 +157,1 @@\n+        MyClass obj = new MyClass();\n@@ -103,1 +159,10 @@\n-            t.test();\n+            t.test1();\n+            int res = t.test2(obj, obj);\n+            Asserts.assertEquals(res, t.res);\n+            Asserts.assertEquals(res, 42);\n+            res = t.test3(obj, obj);\n+            Asserts.assertEquals(res, t.res);\n+            Asserts.assertEquals(res, 51);\n+            res = t.test4(obj, obj);\n+            Asserts.assertEquals(res, t.res);\n+            Asserts.assertEquals(res, 51);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSplitIfPinnedLoadInStripMinedLoop.java","additions":69,"deletions":4,"binary":false,"changes":73,"status":"modified"}]}