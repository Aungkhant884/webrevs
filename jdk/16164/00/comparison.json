{"files":[{"patch":"@@ -173,6 +173,0 @@\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname);\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname);\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -317,66 +317,0 @@\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-int\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-    static struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } const opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,           IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,          SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,             SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,             SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,             SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,          SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,          SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_REUSEPORT,          SOL_SOCKET,     SO_REUSEPORT },\n-        { java_net_SocketOptions_SO_BROADCAST,          SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_TOS,                IPPROTO_IP,     IP_TOS },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },\n-    };\n-\n-    int i;\n-\n-    if (ipv6_available()) {\n-        switch (cmd) {\n-            \/\/ Different multicast options if IPv6 is enabled\n-            case java_net_SocketOptions_IP_MULTICAST_IF:\n-            case java_net_SocketOptions_IP_MULTICAST_IF2:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_IF;\n-                return 0;\n-\n-            case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_MULTICAST_LOOP;\n-                return 0;\n-#if defined(MACOSX)\n-            \/\/ Map IP_TOS request to IPV6_TCLASS\n-            case java_net_SocketOptions_IP_TOS:\n-                *level = IPPROTO_IPV6;\n-                *optname = IPV6_TCLASS;\n-                return 0;\n-#endif\n-        }\n-    }\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -228,69 +228,0 @@\n-\/* call NET_MapSocketOptionV6 for the IPv6 fd only\n- * and NET_MapSocketOption for the IPv4 fd\n- *\/\n-JNIEXPORT int JNICALL\n-NET_MapSocketOptionV6(jint cmd, int *level, int *optname) {\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_IP_MULTICAST_IF:\n-        case java_net_SocketOptions_IP_MULTICAST_IF2:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_IF;\n-            return 0;\n-\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            *level = IPPROTO_IPV6;\n-            *optname = IPV6_MULTICAST_LOOP;\n-            return 0;\n-    }\n-    return NET_MapSocketOption (cmd, level, optname);\n-}\n-\n-\/*\n- * Map the Java level socket option to the platform specific\n- * level and option name.\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_MapSocketOption(jint cmd, int *level, int *optname) {\n-\n-    typedef struct {\n-        jint cmd;\n-        int level;\n-        int optname;\n-    } sockopts;\n-\n-    static sockopts opts[] = {\n-        { java_net_SocketOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },\n-        { java_net_SocketOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },\n-        { java_net_SocketOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },\n-        { java_net_SocketOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },\n-        { java_net_SocketOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },\n-        { java_net_SocketOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },\n-        { java_net_SocketOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },\n-        { java_net_SocketOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },\n-        { java_net_SocketOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },\n-        { java_net_SocketOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },\n-        { java_net_SocketOptions_IP_TOS,            IPPROTO_IP, IP_TOS },\n-\n-    };\n-\n-\n-    int i;\n-\n-    \/*\n-     * Map the Java level option to the native level\n-     *\/\n-    for (i=0; i<(int)(sizeof(opts) \/ sizeof(opts[0])); i++) {\n-        if (cmd == opts[i].cmd) {\n-            *level = opts[i].level;\n-            *optname = opts[i].optname;\n-            return 0;\n-        }\n-    }\n-\n-    \/* not found *\/\n-    return -1;\n-}\n-\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":69,"binary":false,"changes":69,"status":"modified"}]}