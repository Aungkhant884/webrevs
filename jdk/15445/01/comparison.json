{"files":[{"patch":"@@ -450,1 +450,1 @@\n-bool RegionNode::try_clean_mem_phi(PhaseGVN *phase) {\n+void RegionNode::try_clean_mem_phis(PhaseIterGVN* igvn) {\n@@ -467,21 +467,12 @@\n-  \/\/ code below replaces the Phi with the MergeMem so that the Region\n-  \/\/ is simplified.\n-\n-  PhiNode* phi = has_unique_phi();\n-  if (phi && phi->type() == Type::MEMORY && req() == 3 && phi->is_diamond_phi(true)) {\n-    MergeMemNode* m = nullptr;\n-    assert(phi->req() == 3, \"same as region\");\n-    for (uint i = 1; i < 3; ++i) {\n-      Node *mem = phi->in(i);\n-      if (mem && mem->is_MergeMem() && in(i)->outcnt() == 1) {\n-        \/\/ Nothing is control-dependent on path #i except the region itself.\n-        m = mem->as_MergeMem();\n-        uint j = 3 - i;\n-        Node* other = phi->in(j);\n-        if (other && other == m->base_memory()) {\n-          \/\/ m is a successor memory to other, and is not pinned inside the diamond, so push it out.\n-          \/\/ This will allow the diamond to collapse completely.\n-          phase->is_IterGVN()->replace_node(phi, m);\n-          return true;\n-        }\n-      }\n+  \/\/ code in PhiNode::try_clean_memory_phi() replaces the Phi with the\n+  \/\/ MergeMem in order to remove the Region if its last phi dies.\n+\n+  if (!is_diamond()) {\n+    return;\n+  }\n+\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* phi = fast_out(i);\n+    if (phi->is_Phi() && phi->as_Phi()->try_clean_memory_phi(igvn)) {\n+      --i;\n+      --imax;\n@@ -490,1 +481,0 @@\n-  return false;\n@@ -493,0 +483,38 @@\n+\/\/ Does this region merge a simple diamond formed by a proper IfNode?\n+\/\/\n+\/\/              Cmp\n+\/\/              \/\n+\/\/     ctrl   Bool\n+\/\/       \\    \/\n+\/\/       IfNode\n+\/\/      \/      \\\n+\/\/  IfFalse   IfTrue\n+\/\/      \\      \/\n+\/\/       Region\n+bool RegionNode::is_diamond() const {\n+  if (req() != 3) {\n+    return false;\n+  }\n+\n+  Node* left_path = in(1);\n+  Node* right_path = in(2);\n+  if (left_path == nullptr || right_path == nullptr) {\n+    return false;\n+  }\n+  Node* diamond_if = left_path->in(0);\n+  if (diamond_if == nullptr || !diamond_if->is_If() || diamond_if != right_path->in(0)) {\n+    \/\/ Not an IfNode merging a diamond or TOP.\n+    return false;\n+  }\n+\n+  \/\/ Check for a proper bool\/cmp\n+  const Node* bol = diamond_if->in(1);\n+  if (!bol->is_Bool()) {\n+    return false;\n+  }\n+  const Node* cmp = bol->in(1);\n+  if (!cmp->is_Cmp()) {\n+    return false;\n+  }\n+  return true;\n+}\n@@ -504,0 +532,1 @@\n+    try_clean_mem_phis(phase->is_IterGVN());\n@@ -505,3 +534,0 @@\n-    if (has_phis && try_clean_mem_phi(phase)) {\n-      has_phis = false;\n-    }\n@@ -1330,2 +1356,0 @@\n-\n-\/\/------------------------------is_diamond_phi---------------------------------\n@@ -1334,28 +1358,9 @@\n-\/\/ If check_control_only is true, do not inspect the If node at the\n-\/\/ top, and return -1 (not an edge number) on success.\n-int PhiNode::is_diamond_phi(bool check_control_only) const {\n-  \/\/ Check for a 2-path merge\n-  Node *region = in(0);\n-  if( !region ) return 0;\n-  if( region->req() != 3 ) return 0;\n-  if(         req() != 3 ) return 0;\n-  \/\/ Check that both paths come from the same If\n-  Node *ifp1 = region->in(1);\n-  Node *ifp2 = region->in(2);\n-  if( !ifp1 || !ifp2 ) return 0;\n-  Node *iff = ifp1->in(0);\n-  if( !iff || !iff->is_If() ) return 0;\n-  if( iff != ifp2->in(0) ) return 0;\n-  if (check_control_only)  return -1;\n-  \/\/ Check for a proper bool\/cmp\n-  const Node *b = iff->in(1);\n-  if( !b->is_Bool() ) return 0;\n-  const Node *cmp = b->in(1);\n-  if( !cmp->is_Cmp() ) return 0;\n-\n-  \/\/ Check for branching opposite expected\n-  if( ifp2->Opcode() == Op_IfTrue ) {\n-    assert( ifp1->Opcode() == Op_IfFalse, \"\" );\n-    return 2;\n-  } else {\n-    assert( ifp1->Opcode() == Op_IfTrue, \"\" );\n+int PhiNode::is_diamond_phi() const {\n+  Node* region = in(0);\n+  assert(region != nullptr && region->is_Region(), \"phi must have region\");\n+  if (!region->as_Region()->is_diamond()) {\n+    return 0;\n+  }\n+\n+  if (region->in(1)->is_IfTrue()) {\n+    assert(region->in(2)->is_IfFalse(), \"bad If\");\n@@ -1363,0 +1368,4 @@\n+  } else {\n+    \/\/ Flipped projections.\n+    assert(region->in(2)->is_IfTrue(), \"bad If\");\n+    return 2;\n@@ -1366,0 +1375,35 @@\n+\/\/ Do the following transformation if we find the corresponding graph shape, remove the involved memory phi and return\n+\/\/ true. Otherwise, return false if the transformation cannot be applied.\n+\/\/\n+\/\/           If                                     If\n+\/\/          \/  \\                                   \/  \\\n+\/\/    IfFalse  IfTrue  \/- Some Node          IfFalse  IfTrue\n+\/\/          \\  \/      \/    \/                       \\  \/        Some Node\n+\/\/         Region    \/ \/-MergeMem     ===>        Region          |\n+\/\/          \/   \\---Phi                             |          MergeMem\n+\/\/ [other phis]      \\                        [other phis]        |\n+\/\/                   use                                         use\n+bool PhiNode::try_clean_memory_phi(PhaseIterGVN* igvn) {\n+  if (_type != Type::MEMORY) {\n+    return false;\n+  }\n+  assert(is_diamond_phi() > 0, \"sanity\");\n+  assert(req() == 3, \"same as region\");\n+  const Node* region = in(0);\n+  for (uint i = 1; i < 3; i++) {\n+    Node* phi_input = in(i);\n+    if (phi_input != nullptr && phi_input->is_MergeMem() && region->in(i)->outcnt() == 1) {\n+      \/\/ Nothing is control-dependent on path #i except the region itself.\n+      MergeMemNode* merge_mem = phi_input->as_MergeMem();\n+      uint j = 3 - i;\n+      Node* other_phi_input = in(j);\n+      if (other_phi_input != nullptr && other_phi_input == merge_mem->base_memory()) {\n+        \/\/ merge_mem is a successor memory to other_phi_input, and is not pinned inside the diamond, so push it out.\n+        \/\/ This will allow the diamond to collapse completely if there are no other phis left.\n+        igvn->replace_node(this, merge_mem);\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":100,"deletions":56,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -135,1 +135,2 @@\n-  bool try_clean_mem_phi(PhaseGVN* phase);\n+  bool is_diamond() const;\n+  void try_clean_mem_phis(PhaseIterGVN* phase);\n@@ -236,1 +237,2 @@\n-  int  is_diamond_phi(bool check_control_only = false) const;\n+  int is_diamond_phi() const;\n+  bool try_clean_memory_phi(PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8314997\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @summary Test that diamond if-region is removed due to calling try_clean_mem_phi().\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.igvn.TestCleanMemPhi\n+ *\/\n+public class TestCleanMemPhi {\n+    static boolean flag, flag2;\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(0);\n+        testFramework.addFlags(\"-XX:+AlwaysIncrementalInline\", \"-XX:-PartialPeelLoop\", \"-XX:-LoopUnswitching\");\n+        testFramework.addScenarios(new Scenario(1, \"-XX:-StressIGVN\"),\n+                                   new Scenario(2, \"-XX:+StressIGVN\"));\n+        testFramework.start();\n+    }\n+\n+    static class A {\n+        int i;\n+    }\n+\n+\n+    static A a1 = new A();\n+    static A a2 = new A();\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"> 0\"})\n+    static void testCountedLoop() {\n+        int zero = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2) ;\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        \/\/ Loop is not converted to a counted loop because a diamond is not removed due to missing to call\n+        \/\/ try_clean_mem_phi() again on the diamond region.\n+        int i = 0;\n+        do {\n+            iFld = 34;\n+            if (flag2) {\n+                iFld++;\n+            }\n+\n+            int z = 34;\n+            if (flag) {\n+                lateInline(); \/\/ Inlined late -> leaves a MergeMem\n+                if (zero == 34) { \/\/ False but only cleaned up after CCP\n+                    iFld = 38;\n+                }\n+                z = 32; \/\/ Ensures to get a diamond If-Region\n+            }\n+            \/\/ Region merging a proper diamond after CCP with a memory phi merging loop phi and the MergeMem from lateInline().\n+            \/\/ Region is not added to the IGVN worklist anymore once the second phi dies.\n+            i++;\n+        } while (zero == 34 || (i < 1000 && a1 == a2)); \/\/ Could be converted to a counted loop after the diamond is removed after CCP.\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    static void testRemoveLoop() {\n+        int zero = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2) ;\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        \/\/ Loop is not converted to a counted loop and thus cannot be removed as empty loop because a diamond is not\n+        \/\/ removed due to missing to call try_clean_mem_phi() again on the diamond region.\n+        int i = 0;\n+        do {\n+            iFld = 34;\n+\n+            int z = 34;\n+            if (flag) {\n+                lateInline(); \/\/ Inlined late -> leaves a MergeMem\n+                if (zero == 34) { \/\/ False but only cleaned up after CCP\n+                    iFld = 38;\n+                }\n+                z = 32; \/\/ Ensures to get a diamond If-Region\n+            }\n+            \/\/ Region merging a proper diamond after CCP with a memory phi merging loop phi and the MergeMem from lateInline().\n+            \/\/ Region is not added to the IGVN worklist anymore once the second phi dies.\n+\n+            i++;\n+        } while (zero == 34 || (i < 21 && a1 == a2));\n+    }\n+\n+    static void lateInline() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/igvn\/TestCleanMemPhi.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}