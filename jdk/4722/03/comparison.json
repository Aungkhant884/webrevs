{"files":[{"patch":"@@ -96,0 +96,2 @@\n+  product(bool, UseStringCompareWithLdp, false,                         \\\n+          \"Use ldp enhance string compare intrinsic\")                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4863,0 +4863,143 @@\n+  \/\/ r0  = result\n+  \/\/ r1  = str1\n+  \/\/ r2  = cnt1\n+  \/\/ r3  = str2\n+  \/\/ r4  = cnt2\n+  \/\/ r10 = tmp1\n+  \/\/ r11 = tmp2\n+  address generate_compare_long_string_same_encoding_withLdp(bool isLL) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", isLL\n+                                            ? \"compare_long_string_same_encoding LL\"\n+                                            : \"compare_long_string_same_encoding UU\");\n+\n+    address  entry  = __ pc();\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n+             tmp1   = r10, tmp2 = r11, tmp1h = rscratch1, tmp2h = rscratch2;\n+\n+\n+    Label LOOP_COMPARE64, LOOP_COMPARE16, DIFF, LESS16, LESS8, CAL_DIFFERENCE, LENGTH_DIFF;\n+\n+    int largeLoopSize = 64\/(isLL ? 1 : 2);\n+\n+    \/\/ before jumping to stub, pre-load 8 bytes already, so do comparison directly\n+    __ eor(rscratch2, tmp1, tmp2);\n+    __ cbnz(rscratch2, CAL_DIFFERENCE);\n+\n+    __ sub(cnt2, cnt2, wordSize\/(isLL ? 1 : 2));\n+    \/\/ update pointers, because of previous read\n+    __ add(str1, str1, wordSize);\n+    __ add(str2, str2, wordSize);\n+\n+    __ align(OptoLoopAlignment);\n+    __ bind(LOOP_COMPARE64);\n+      __ ldp(tmp1, tmp1h, Address(str1));\n+      __ ldp(tmp2, tmp2h, Address(str2));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+\n+      __ ldp(tmp1, tmp1h, Address(str1,16));\n+      __ ldp(tmp2, tmp2h, Address(str2,16));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+\n+      __ ldp(tmp1, tmp1h, Address(str1, 32));\n+      __ ldp(tmp2, tmp2h, Address(str2, 32));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+\n+      __ ldp(tmp1, tmp1h, Address(str1,48));\n+      __ ldp(tmp2, tmp2h, Address(str2,48));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+\n+      __ sub(cnt2, cnt2, isLL ? 64 : 32);\n+      __ add(str1, str1, 64);\n+      __ add(str2, str2, 64);\n+      __ subs(rscratch2, cnt2, largeLoopSize);\n+      __ br(__ GE, LOOP_COMPARE64);\n+      __ cbz(cnt2, LENGTH_DIFF); \/\/ no more chars left?\n+\n+\n+    __ subs(rscratch1, cnt2, isLL ? 16 : 8);\n+    __ br(__ LE, LESS16);\n+    __ align(OptoLoopAlignment);\n+\n+    __ bind(LOOP_COMPARE16);\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(__ LT, LESS16);\n+\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(__ NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(__ GE, LOOP_COMPARE16);\n+      __ cbz(cnt2, LENGTH_DIFF);\n+\n+    __ bind(LESS16);\n+      \/\/ each 8 compare\n+      __ subs(cnt2, cnt2, isLL ? 8 : 4);\n+      __ br(__ LE, LESS8);\n+      __ ldr(tmp1, Address(__ post(str1, 8)));\n+      __ ldr(tmp2, Address(__ post(str2, 8)));\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, CAL_DIFFERENCE);\n+      __ sub(cnt2, cnt2, isLL ? 8 : 4);\n+\n+    __ bind(LESS8);                          \/\/ directly load last 8 bytes\n+      if (!isLL) {\n+        __ add(cnt2, cnt2, cnt2);\n+      }\n+      __ ldr(tmp1, Address(str1, cnt2));\n+      __ ldr(tmp2, Address(str2, cnt2));\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbz(rscratch2, LENGTH_DIFF);\n+      __ b(CAL_DIFFERENCE);\n+\n+\n+    __ bind(DIFF);\n+      __ cmp(tmp1, tmp2);\n+      __ csel(tmp1, tmp1, tmp1h, Assembler::NE);\n+      __ csel(tmp2, tmp2, tmp2h, Assembler::NE);\n+      \/\/ reuse rscratch2 register for the result of eor instruction\n+      __ eor(rscratch2, tmp1, tmp2);\n+\n+    __ bind(CAL_DIFFERENCE);\n+      __ rev(rscratch2, rscratch2);\n+      __ clz(rscratch2, rscratch2);\n+      __ andr(rscratch2, rscratch2, isLL ? -8 : -16);\n+      __ lsrv(tmp1, tmp1, rscratch2);\n+      __ lsrv(tmp2, tmp2, rscratch2);\n+      if (isLL) {\n+        __ uxtbw(tmp1, tmp1);\n+        __ uxtbw(tmp2, tmp2);\n+      } else {\n+        __ uxthw(tmp1, tmp1);\n+        __ uxthw(tmp2, tmp2);\n+      }\n+\n+      __ subw(result, tmp1, tmp2);\n+      __ b(LENGTH_DIFF);\n+\n+    __ bind(LENGTH_DIFF);\n+      __ ret(lr);\n+    return entry;\n+  }\n+\n+\n@@ -4974,4 +5117,7 @@\n-      StubRoutines::aarch64::_compare_long_string_LL\n-          = generate_compare_long_string_same_encoding(true);\n-      StubRoutines::aarch64::_compare_long_string_UU\n-          = generate_compare_long_string_same_encoding(false);\n+      if (UseStringCompareWithLdp) {\n+          StubRoutines::aarch64::_compare_long_string_LL = generate_compare_long_string_same_encoding_withLdp(true);\n+          StubRoutines::aarch64::_compare_long_string_UU = generate_compare_long_string_same_encoding_withLdp(false);\n+      } else {\n+          StubRoutines::aarch64::_compare_long_string_LL = generate_compare_long_string_same_encoding(true);\n+          StubRoutines::aarch64::_compare_long_string_UU = generate_compare_long_string_same_encoding(false);\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":150,"deletions":4,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::compare performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+public class StringCompare {\n+    @Param({\"77\", \"128\"})\n+    int size;\n+\n+    @Param({\"7\", \"15\", \"31\", \"47\", \"63\", \"71\"})\n+    int diff_pos;\n+\n+\n+    private String str1;\n+    private String str2;\n+\n+    @Setup(Level.Trial)\n+    public void init() {\n+        str1 = newString(size, 'c', diff_pos, '1');\n+        str2 = newString(size, 'c', diff_pos, '2');\n+    }\n+\n+    public String newString(int length, char charToFill, int diff_pos, char diff_char) {\n+        if (length > 0) {\n+            char[] array = new char[length];\n+            for (int i = 0; i < length; i++) {\n+                array[i] = charToFill;\n+            }\n+            array[diff_pos] = diff_char;\n+            return new String(array);\n+        }\n+        return \"\";\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareLLDiffStrings() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = { \"-XX:+UseStringCompareWithLdp\"})\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareLLDiffStringsWithLdp() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\"})\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareUUDiffStrings() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\", \"-XX:+UseStringCompareWithLdp\"})\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareUUDiffStringsWithLdp() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\", \"-XX:-UseCompressedClassPointers\"})\n+    public int compareUUDiffStringsTurnOffCCP() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\", \"-XX:-UseCompressedClassPointers\", \"-XX:+UseStringCompareWithLdp\"})\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareUUDiffStringsTurnOffCCPWithLdp() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompare.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}