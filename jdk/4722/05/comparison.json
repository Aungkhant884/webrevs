{"files":[{"patch":"@@ -4659,12 +4659,0 @@\n-  \/\/ code for comparing 16 bytes of strings with same encoding\n-  void compare_string_16_bytes_same(Label &DIFF1, Label &DIFF2) {\n-    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, tmp1 = r10, tmp2 = r11;\n-    __ ldr(rscratch1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, tmp1, tmp2);\n-    __ ldr(cnt1, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF1);\n-    __ ldr(tmp1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, rscratch1, cnt1);\n-    __ ldr(tmp2, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF2);\n-  }\n@@ -4877,4 +4865,4 @@\n-        tmp1 = r10, tmp2 = r11;\n-    Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,\n-        LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,\n-        DIFF_LAST_POSITION, DIFF_LAST_POSITION2;\n+        tmp1 = r10, tmp2 = r11, tmp1h = rscratch1, tmp2h = rscratch2;\n+\n+    Label LARGE_LOOP_PREFETCH, LOOP_COMPARE16, DIFF, LESS16, LESS8, CAL_DIFFERENCE, LENGTH_DIFF;\n+\n@@ -4883,3 +4871,6 @@\n-    int largeLoopExitCondition = MAX2(64, SoftwarePrefetchHintDistance)\/(isLL ? 1 : 2);\n-    \/\/ cnt1\/cnt2 contains amount of characters to compare. cnt1 can be re-used\n-    \/\/ update cnt2 counter with already loaded 8 bytes\n+    int largeLoopExitCondition = MAX(64, SoftwarePrefetchHintDistance)\/(isLL ? 1 : 2);\n+\n+    \/\/ before jumping to stub, pre-load 8 bytes already, so do comparison directly\n+    __ eor(rscratch2, tmp1, tmp2);\n+    __ cbnz(rscratch2, CAL_DIFFERENCE);\n+\n@@ -4894,2 +4885,9 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+\n+        __ align(OptoLoopAlignment);\n+        for (int i = 0; i < 4; i++) {\n+          __ ldp(tmp1, tmp1h, Address(str1, i * 16));\n+          __ ldp(tmp2, tmp2h, Address(str2, i * 16));\n+          __ cmp(tmp1, tmp2);\n+          __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+          __ br(Assembler::NE, DIFF);\n+        }\n@@ -4897,1 +4895,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+        __ add(str1, str1, 64);\n+        __ add(str2, str2, 64);\n@@ -4899,3 +4898,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        __ br(__ GT, LARGE_LOOP_PREFETCH);\n-        __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); \/\/ no more chars left?\n+        __ br(Assembler::GE, LARGE_LOOP_PREFETCH);\n+        __ cbz(cnt2, LENGTH_DIFF); \/\/ no more chars left?\n@@ -4903,3 +4901,3 @@\n-    \/\/ less than 16 bytes left?\n-    __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-    __ br(__ LT, TAIL);\n+\n+    __ subs(rscratch1, cnt2, isLL ? 16 : 8);\n+    __ br(Assembler::LE, LESS16);\n@@ -4907,7 +4905,22 @@\n-    __ bind(SMALL_LOOP);\n-      compare_string_16_bytes_same(DIFF, DIFF2);\n-      __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ GE, SMALL_LOOP);\n-    __ bind(TAIL);\n-      __ adds(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ EQ, LAST_CHECK_AND_LENGTH_DIFF);\n+    __ bind(LOOP_COMPARE16);\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::LT, LESS16);\n+\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::GE, LOOP_COMPARE16);\n+      __ cbz(cnt2, LENGTH_DIFF);\n+\n+    __ bind(LESS16);\n+      \/\/ each 8 compare\n@@ -4915,3 +4928,1 @@\n-      __ br(__ LE, CHECK_LAST);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+      __ br(Assembler::LE, LESS8);\n@@ -4920,0 +4931,2 @@\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, CAL_DIFFERENCE);\n@@ -4921,1 +4934,2 @@\n-    __ bind(CHECK_LAST);\n+\n+    __ bind(LESS8); \/\/ directly load last 8 bytes\n@@ -4923,1 +4937,1 @@\n-        __ add(cnt2, cnt2, cnt2); \/\/ now in bytes\n+        __ add(cnt2, cnt2, cnt2);\n@@ -4925,0 +4939,2 @@\n+      __ ldr(tmp1, Address(str1, cnt2));\n+      __ ldr(tmp2, Address(str2, cnt2));\n@@ -4926,4 +4942,0 @@\n-      __ cbnz(rscratch2, DIFF);\n-      __ ldr(rscratch1, Address(str1, cnt2));\n-      __ ldr(cnt1, Address(str2, cnt2));\n-      __ eor(rscratch2, rscratch1, cnt1);\n@@ -4931,18 +4943,2 @@\n-      \/\/ Find the first different characters in the longwords and\n-      \/\/ compute their difference.\n-    __ bind(DIFF2);\n-      __ rev(rscratch2, rscratch2);\n-      __ clz(rscratch2, rscratch2);\n-      __ andr(rscratch2, rscratch2, isLL ? -8 : -16);\n-      __ lsrv(rscratch1, rscratch1, rscratch2);\n-      if (isLL) {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxtbw(rscratch1, rscratch1);\n-        __ uxtbw(cnt1, cnt1);\n-      } else {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxthw(rscratch1, rscratch1);\n-        __ uxthw(cnt1, cnt1);\n-      }\n-      __ subw(result, rscratch1, cnt1);\n-      __ b(LENGTH_DIFF);\n+      __ b(CAL_DIFFERENCE);\n+\n@@ -4950,0 +4946,7 @@\n+      __ cmp(tmp1, tmp2);\n+      __ csel(tmp1, tmp1, tmp1h, Assembler::NE);\n+      __ csel(tmp2, tmp2, tmp2h, Assembler::NE);\n+      \/\/ reuse rscratch2 register for the result of eor instruction\n+      __ eor(rscratch2, tmp1, tmp2);\n+\n+    __ bind(CAL_DIFFERENCE);\n@@ -4954,0 +4957,1 @@\n+      __ lsrv(tmp2, tmp2, rscratch2);\n@@ -4955,1 +4959,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -4959,1 +4962,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -4964,4 +4966,1 @@\n-      __ b(LENGTH_DIFF);\n-    __ bind(LAST_CHECK_AND_LENGTH_DIFF);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":67,"deletions":68,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::compare performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+public class StringCompare {\n+    @Param({\"256\"})\n+    int size;\n+\n+    @Param({\"7\", \"15\", \"31\", \"47\", \"63\", \"127\", \"255\"})\n+    int diff_pos;\n+\n+\n+    private String str1;\n+    private String str2;\n+\n+    @Setup(Level.Trial)\n+    public void init() {\n+        str1 = newString(size, 'c', diff_pos, '1');\n+        str2 = newString(size, 'c', diff_pos, '2');\n+    }\n+\n+    public String newString(int length, char charToFill, int diff_pos, char diff_char) {\n+        if (length > 0) {\n+            char[] array = new char[length];\n+            for (int i = 0; i < length; i++) {\n+                array[i] = charToFill;\n+            }\n+            array[diff_pos] = diff_char;\n+            return new String(array);\n+        }\n+        return \"\";\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareLLDiffStrings() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\"})\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int compareUUDiffStrings() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Fork(jvmArgsAppend = {\"-XX:-CompactStrings\", \"-XX:-UseCompressedClassPointers\"})\n+    public int compareUUDiffStringsTurnOffCCP() {\n+        int result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str1.compareTo(str2);\n+        }\n+        return result;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompare.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}