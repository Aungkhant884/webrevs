{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -254,2 +256,3 @@\n-    private static MethodHandle makeToString(Class<?> receiverClass,\n-                                            List<MethodHandle> getters,\n+    private static MethodHandle makeToString(MethodHandles.Lookup lookup,\n+                                            Class<?> receiverClass,\n+                                            MethodHandle[] getters,\n@@ -257,32 +260,17 @@\n-        \/\/ This is a pretty lousy algorithm; we spread the receiver over N places,\n-        \/\/ apply the N getters, apply N toString operations, and concat the result with String.format\n-        \/\/ Better to use String.format directly, or delegate to StringConcatFactory\n-        \/\/ Also probably want some quoting around String components\n-\n-        assert getters.size() == names.size();\n-\n-        int[] invArgs = new int[getters.size()];\n-        Arrays.fill(invArgs, 0);\n-        MethodHandle[] filters = new MethodHandle[getters.size()];\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(receiverClass.getSimpleName()).append(\"[\");\n-        for (int i=0; i<getters.size(); i++) {\n-            MethodHandle getter = getters.get(i); \/\/ (R)T\n-            MethodHandle stringify = stringifier(getter.type().returnType()); \/\/ (T)String\n-            MethodHandle stringifyThisField = MethodHandles.filterArguments(stringify, 0, getter);    \/\/ (R)String\n-            filters[i] = stringifyThisField;\n-            sb.append(names.get(i)).append(\"=%s\");\n-            if (i != getters.size() - 1)\n-                sb.append(\", \");\n-        }\n-        sb.append(']');\n-        String formatString = sb.toString();\n-        MethodHandle formatter = MethodHandles.insertArguments(STRING_FORMAT, 0, formatString)\n-                                              .asCollector(String[].class, getters.size()); \/\/ (R*)String\n-        if (getters.size() == 0) {\n-            \/\/ Add back extra R\n-            formatter = MethodHandles.dropArguments(formatter, 0, receiverClass);\n-        }\n-        else {\n-            MethodHandle filtered = MethodHandles.filterArguments(formatter, 0, filters);\n-            formatter = MethodHandles.permuteArguments(filtered, MethodType.methodType(String.class, receiverClass), invArgs);\n+        assert getters.length == names.size();\n+        Class<?>[] types = Stream.of(getters)\n+                .map(g -> g.type().returnType())\n+                .toList()\n+                .toArray(new Class<?>[getters.length]);\n+        MethodType concatMethodType = MethodType.methodType(String.class, types);\n+        String recipe = \"\\2\" + (getters.length > 0 ?\n+                        \"\\2\\1\\2\".repeat(getters.length - 1) + \"\\2\\1\" :\n+                        \"\") + \"\\2\";\n+        String[] constants = new String[2 + (getters.length > 0 ? 2 * getters.length - 1 : 0)];\n+        constants[0] = receiverClass.getSimpleName() + \"[\";\n+        constants[constants.length - 1] = \"]\";\n+        for (int i = 0; i < names.size(); i++) {\n+            constants[1 + 2 * i] = names.get(i) + \"=\";\n+            if (i != names.size() - 1) {\n+                constants[1 + 2 * i + 1] = \", \";\n+            }\n@@ -291,1 +279,18 @@\n-        return formatter;\n+        MethodHandle mh;\n+        try {\n+            mh = StringConcatFactory.makeConcatWithConstants(\n+                    lookup, \"\",\n+                    concatMethodType,\n+                    recipe,\n+                    (Object[]) constants\n+            ).getTarget();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+        mh = MethodHandles.filterArguments(mh, 0, getters);\n+        mh = MethodHandles.permuteArguments(\n+                mh,\n+                MethodType.methodType(String.class, receiverClass),\n+                new int[getters.length]\n+        );\n+        return mh;\n@@ -370,1 +375,1 @@\n-                yield makeToString(recordClass, getterList, nameList);\n+                yield makeToString(lookup, recordClass, getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":41,"deletions":36,"binary":false,"changes":77,"status":"modified"}]}