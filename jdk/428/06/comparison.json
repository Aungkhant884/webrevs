{"files":[{"patch":"@@ -2922,0 +2922,3 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n+\n@@ -2925,1 +2928,0 @@\n-  __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -83,1 +85,0 @@\n-  maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1602,1 +1602,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_leaf_base:\"\n+    stop(\"InterpreterMacroAssembler::call_VM_base:\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1384,1 +1384,2 @@\n-  maybe_isb();\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -4390,4 +4391,9 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), rtype);\n-  ldrw(zr, Address(r, 0));\n-  return inst_mark();\n+  address mark;\n+  {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), rtype);\n+    ldrw(zr, Address(r, 0));\n+    mark = inst_mark();\n+  }\n+  verify_cross_modify_fence_not_required();\n+  return mark;\n@@ -4458,0 +4464,1 @@\n+  verify_cross_modify_fence_not_required();\n@@ -5318,0 +5325,26 @@\n+\n+void MacroAssembler::safepoint_isb() {\n+  isb();\n+#ifndef PRODUCT\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Clear the thread state.\n+    strb(zr, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+  }\n+#endif\n+}\n+\n+#ifndef PRODUCT\n+void MacroAssembler::verify_cross_modify_fence_not_required() {\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Check if thread needs a cross modify fence.\n+    ldrb(rscratch1, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+    Label fence_not_required;\n+    cbz(rscratch1, fence_not_required);\n+    \/\/ If it does then fail.\n+    lea(rscratch1, CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure));\n+    mov(c_rarg0, rthread);\n+    blr(rscratch1);\n+    bind(fence_not_required);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1318,2 +1318,3 @@\n-  \/\/ ISB may be needed because of a safepoint\n-  void maybe_isb() { isb(); }\n+\n+  \/\/ Place an ISB after code may have been modified due to a safepoint.\n+  void safepoint_isb();\n@@ -1395,0 +1396,5 @@\n+\n+private:\n+  \/\/ Check the current thread doesn't need a cross modify fence.\n+  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -377,1 +377,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1154,1 +1157,0 @@\n-    __ maybe_isb();\n@@ -1861,1 +1863,1 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n@@ -2039,0 +2041,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2066,0 +2070,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2085,1 +2091,1 @@\n-    __ maybe_isb();\n+\n@@ -2769,0 +2775,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2782,1 +2790,0 @@\n-  __ maybe_isb();\n@@ -2880,0 +2887,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2889,2 +2898,0 @@\n-  __ maybe_isb();\n-\n@@ -3012,1 +3019,2 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -5625,0 +5625,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -5632,1 +5634,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1360,1 +1360,0 @@\n-  __ maybe_isb();\n@@ -1413,1 +1412,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-inline void OrderAccess::cross_modify_fence()\n+inline void OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/orderAccess_aix_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/orderAccess_bsd_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()             { }\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/orderAccess_bsd_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,3 @@\n-inline void OrderAccess::cross_modify_fence() { }\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  asm volatile(\"isb\" : : : \"memory\");\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/orderAccess_linux_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-inline void OrderAccess::cross_modify_fence()   { }\n+inline void OrderAccess::cross_modify_fence_impl()   { }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/orderAccess_linux_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void   OrderAccess::cross_modify_fence()\n+inline void   OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/orderAccess_linux_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-inline void OrderAccess::cross_modify_fence() { inlasm_zarch_sync(); }\n+inline void OrderAccess::cross_modify_fence_impl() { inlasm_zarch_sync(); }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/orderAccess_linux_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/orderAccess_linux_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()            { }\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/orderAccess_linux_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/orderAccess_windows_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2508,1 +2508,5 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence, false,                              \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+\n+#ifndef PRODUCT\n@@ -29,0 +31,1 @@\n+#endif\n@@ -41,0 +44,8 @@\n+\n+#ifndef PRODUCT\n+void OrderAccess::cross_modify_fence_verify() {\n+    if (VerifyCrossModifyFence) {\n+      JavaThread::current()->set_requires_cross_modify_fence(false);\n+    }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-\/\/ Finally, we define a \"fence\" operation, as a bidirectional barrier.\n+\/\/ We define a \"fence\" operation, as a bidirectional barrier.\n@@ -232,0 +232,10 @@\n+\/\/\n+\/\/ Finally, we define a \"cross_modify_fence\" operation, as a bidirectional\n+\/\/ barrier for the instruction code cache. It guarantees that any memory access\n+\/\/ to the instruction code preceding the fence is not reordered w.r.t. any\n+\/\/ memory accesses to instruction code subsequent to the fence in program order.\n+\/\/ It  should be used in conjunction with safepointing to ensure that changes\n+\/\/ to the instruction stream are seen on exit from a safepoint. Namely:\n+\/\/ [1] Directly before running a new thread [See JavaThread::run()]\n+\/\/ [2] Whilst in the VM, on exit from being suspended in a safepoint. [See\n+\/\/     SafepointMechanism::process_if_requested_slow()]\n@@ -245,1 +255,4 @@\n-  static void     cross_modify_fence();\n+  static void     cross_modify_fence() {\n+    cross_modify_fence_impl();\n+    cross_modify_fence_verify();\n+  }\n@@ -262,0 +275,4 @@\n+\n+  static void cross_modify_fence_impl();\n+\n+  static void cross_modify_fence_verify() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.hpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -384,0 +384,8 @@\n+  \/\/ Mark all threads\n+  if (VerifyCrossModifyFence) {\n+    JavaThreadIteratorWithHandle jtiwh;\n+    for (; JavaThread *cur = jtiwh.next(); ) {\n+      cur->set_requires_cross_modify_fence(true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1585,0 +1585,3 @@\n+\n+  set_requires_cross_modify_fence(false);\n+\n@@ -4816,0 +4819,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1099,0 +1099,1 @@\n+  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n@@ -1330,0 +1331,2 @@\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n@@ -1605,0 +1608,1 @@\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n@@ -1894,0 +1898,2 @@\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}