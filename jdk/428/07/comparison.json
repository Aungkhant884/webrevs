{"files":[{"patch":"@@ -2925,1 +2925,0 @@\n-  __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1620,1 +1620,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_leaf_base:\"\n+    stop(\"InterpreterMacroAssembler::call_VM_base:\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1384,1 +1384,0 @@\n-  maybe_isb();\n@@ -4390,4 +4389,9 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), rtype);\n-  ldrw(zr, Address(r, 0));\n-  return inst_mark();\n+  address mark;\n+  {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), rtype);\n+    ldrw(zr, Address(r, 0));\n+    mark = inst_mark();\n+  }\n+  verify_cross_modify_fence_not_required();\n+  return mark;\n@@ -4458,0 +4462,1 @@\n+  verify_cross_modify_fence_not_required();\n@@ -5318,0 +5323,26 @@\n+\n+void MacroAssembler::safepoint_isb() {\n+  isb();\n+#ifndef PRODUCT\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Clear the thread state.\n+    strb(zr, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+  }\n+#endif\n+}\n+\n+#ifndef PRODUCT\n+void MacroAssembler::verify_cross_modify_fence_not_required() {\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Check if thread needs a cross modify fence.\n+    ldrb(rscratch1, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+    Label fence_not_required;\n+    cbz(rscratch1, fence_not_required);\n+    \/\/ If it does then fail.\n+    lea(rscratch1, CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure));\n+    mov(c_rarg0, rthread);\n+    blr(rscratch1);\n+    bind(fence_not_required);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1318,2 +1318,3 @@\n-  \/\/ ISB may be needed because of a safepoint\n-  void maybe_isb() { isb(); }\n+\n+  \/\/ Place an ISB after code may have been modified due to a safepoint.\n+  void safepoint_isb();\n@@ -1395,0 +1396,5 @@\n+\n+private:\n+  \/\/ Check the current thread doesn't need a cross modify fence.\n+  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1153,1 +1156,0 @@\n-    __ maybe_isb();\n@@ -1860,1 +1862,1 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n@@ -2084,1 +2086,1 @@\n-    __ maybe_isb();\n+\n@@ -2790,1 +2792,0 @@\n-  __ maybe_isb();\n@@ -2897,2 +2898,0 @@\n-  __ maybe_isb();\n-\n@@ -3020,1 +3019,2 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5632,1 +5632,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1360,1 +1360,0 @@\n-  __ maybe_isb();\n@@ -1413,1 +1412,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-inline void OrderAccess::cross_modify_fence()\n+inline void OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/orderAccess_aix_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/orderAccess_bsd_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()             { }\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/orderAccess_bsd_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,3 @@\n-inline void OrderAccess::cross_modify_fence() { }\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  asm volatile(\"isb\" : : : \"memory\");\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/orderAccess_linux_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-inline void OrderAccess::cross_modify_fence()   { }\n+inline void OrderAccess::cross_modify_fence_impl()   { }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/orderAccess_linux_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void   OrderAccess::cross_modify_fence()\n+inline void   OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/orderAccess_linux_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-inline void OrderAccess::cross_modify_fence() { inlasm_zarch_sync(); }\n+inline void OrderAccess::cross_modify_fence_impl() { inlasm_zarch_sync(); }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/orderAccess_linux_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/orderAccess_linux_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()            { }\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/orderAccess_linux_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/orderAccess_windows_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2493,1 +2493,6 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence,                                     \\\n+          false AARCH64_ONLY(DEBUG_ONLY(||true)),                            \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+\n+#ifndef PRODUCT\n@@ -29,0 +31,1 @@\n+#endif\n@@ -41,0 +44,8 @@\n+\n+#ifndef PRODUCT\n+void OrderAccess::cross_modify_fence_verify() {\n+    if (VerifyCrossModifyFence) {\n+      JavaThread::current()->set_requires_cross_modify_fence(false);\n+    }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-\/\/ Finally, we define a \"fence\" operation, as a bidirectional barrier.\n+\/\/ We define a \"fence\" operation, as a bidirectional barrier.\n@@ -232,0 +232,4 @@\n+\/\/\n+\/\/ Finally, we define an \"instruction_fence\" operation, which ensures that all\n+\/\/ instructions that come after the fence in program order are fetched\n+\/\/ from the cache or memory after the fence has completed.\n@@ -245,1 +249,4 @@\n-  static void     cross_modify_fence();\n+  static void     cross_modify_fence() {\n+    cross_modify_fence_impl();\n+    cross_modify_fence_verify();\n+  }\n@@ -262,0 +269,4 @@\n+\n+  static void cross_modify_fence_impl();\n+\n+  static void cross_modify_fence_verify() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -384,0 +384,8 @@\n+  \/\/ Mark all threads\n+  if (VerifyCrossModifyFence) {\n+    JavaThreadIteratorWithHandle jtiwh;\n+    for (; JavaThread *cur = jtiwh.next(); ) {\n+      cur->set_requires_cross_modify_fence(true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1585,0 +1585,3 @@\n+\n+  set_requires_cross_modify_fence(false);\n+\n@@ -4805,0 +4808,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1099,0 +1099,1 @@\n+  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n@@ -1330,0 +1331,2 @@\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n@@ -1605,0 +1608,1 @@\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n@@ -1894,0 +1898,2 @@\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}