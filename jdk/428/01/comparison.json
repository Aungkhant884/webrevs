{"files":[{"patch":"@@ -2920,0 +2920,3 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n+\n@@ -2923,1 +2926,0 @@\n-  __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -83,1 +85,0 @@\n-  maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1586,1 +1586,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_leaf_base:\"\n+    stop(\"InterpreterMacroAssembler::call_VM_base:\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1405,1 +1405,2 @@\n-  maybe_isb();\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -4418,4 +4419,9 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), rtype);\n-  ldrw(zr, Address(r, 0));\n-  return inst_mark();\n+  address mark;\n+  {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), rtype);\n+    ldrw(zr, Address(r, 0));\n+    mark = inst_mark();\n+  }\n+  verify_cross_modify_fence_not_required();\n+  return mark;\n@@ -4486,0 +4492,1 @@\n+  verify_cross_modify_fence_not_required();\n@@ -5313,0 +5320,26 @@\n+\n+void MacroAssembler::safepoint_isb() {\n+  isb();\n+#ifndef PRODUCT\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Clear the thread state.\n+    strb(zr, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+  }\n+#endif\n+}\n+\n+#ifndef PRODUCT\n+void MacroAssembler::verify_cross_modify_fence_not_required() {\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Check if thread needs a cross modify fence.\n+    ldrb(rscratch1, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+    Label fence_not_required;\n+    cbz(rscratch1, fence_not_required);\n+    \/\/ If it does then fail.\n+    lea(rscratch1, CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure));\n+    mov(c_rarg0, rthread);\n+    blr(rscratch1);\n+    bind(fence_not_required);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1310,2 +1310,3 @@\n-  \/\/ ISB may be needed because of a safepoint\n-  void maybe_isb() { isb(); }\n+\n+  \/\/ Place an ISB after code may have been modified due to a safepoint.\n+  void safepoint_isb();\n@@ -1387,0 +1388,5 @@\n+\n+private:\n+  \/\/ Check the current thread doesn't need a cross modify fence.\n+  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1167,1 +1170,0 @@\n-    __ maybe_isb();\n@@ -1877,1 +1879,1 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n@@ -2048,0 +2050,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2075,0 +2079,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2098,1 +2104,1 @@\n-    __ maybe_isb();\n+\n@@ -2793,0 +2799,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2806,1 +2814,0 @@\n-  __ maybe_isb();\n@@ -2904,0 +2911,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2913,2 +2922,0 @@\n-  __ maybe_isb();\n-\n@@ -3036,1 +3043,2 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -5020,0 +5020,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -5027,1 +5029,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1360,1 +1360,0 @@\n-  __ maybe_isb();\n@@ -1404,1 +1403,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-inline void OrderAccess::cross_modify_fence()\n+inline void OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/orderAccess_aix_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/orderAccess_bsd_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()             { }\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/orderAccess_bsd_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+#define inlasm_isb()    asm volatile(\"isb\" : : : \"memory\")\n+\n@@ -56,1 +58,5 @@\n-inline void OrderAccess::cross_modify_fence() { }\n+inline void OrderAccess::cross_modify_fence_impl() {\n+  inlasm_isb();\n+}\n+\n+#undef inlasm_isb\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/orderAccess_linux_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-inline void OrderAccess::cross_modify_fence()   { }\n+inline void OrderAccess::cross_modify_fence_impl()   { }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/orderAccess_linux_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void   OrderAccess::cross_modify_fence()\n+inline void   OrderAccess::cross_modify_fence_impl()\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/orderAccess_linux_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-inline void OrderAccess::cross_modify_fence() { inlasm_zarch_sync(); }\n+inline void OrderAccess::cross_modify_fence_impl() { inlasm_zarch_sync(); }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/orderAccess_linux_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/orderAccess_linux_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::cross_modify_fence_impl()            { }\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/orderAccess_linux_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::cross_modify_fence_impl() {\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/orderAccess_windows_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2487,1 +2487,5 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence, false,                              \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+\n+#ifndef PRODUCT\n@@ -29,0 +31,1 @@\n+#endif\n@@ -41,0 +44,8 @@\n+\n+#ifndef PRODUCT\n+void OrderAccess::cross_modify_fence_verify() {\n+    if (VerifyCrossModifyFence) {\n+      JavaThread::current()->set_requires_cross_modify_fence(false);\n+    }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-\/\/ Finally, we define a \"fence\" operation, as a bidirectional barrier.\n+\/\/ We define a \"fence\" operation, as a bidirectional barrier.\n@@ -232,0 +232,14 @@\n+\/\/\n+\/\/ Finally, we define an \"instruction_fence\" operation, as a bidirectional\n+\/\/ barrier for the instruction code cache. It guarantees that any memory access\n+\/\/ to the instruction code preceding the fence is not reordered w.r.t. any\n+\/\/ memory accesses to instruction code subsequent to the fence in program order.\n+\/\/ It  should be used in conjunction with safepointing to ensure that changes\n+\/\/ to the instruction stream are seen on exit from a safepoint. Namely:\n+\/\/ [1] Directly before running a new thread [See JavaThread::run()]\n+\/\/ [2] Whilst in the VM, on exit from being suspended in a safepoint. [See\n+\/\/     SafepointMechanism::process_if_requested_slow()]\n+\/\/ [3] Whilst in the VM, on exit from blocking [See ThreadBlockInVM\n+\/\/     and ThreadBlockInVMWithDeadlockCheck]\n+\/\/ [4] At the end of a JNI call, on exit from blocking. [See\n+\/\/     JavaThread::check_safepoint_and_suspend_for_native_trans()]\n@@ -245,1 +259,4 @@\n-  static void     cross_modify_fence();\n+  static void     cross_modify_fence() {\n+    cross_modify_fence_impl();\n+    cross_modify_fence_verify();\n+  }\n@@ -262,0 +279,4 @@\n+\n+  static void cross_modify_fence_impl();\n+\n+  static void cross_modify_fence_verify() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -383,0 +383,8 @@\n+  \/\/ Mark all threads\n+  if (VerifyCrossModifyFence) {\n+    JavaThreadIteratorWithHandle jtiwh;\n+    for (; JavaThread *cur = jtiwh.next(); ) {\n+      cur->set_requires_cross_modify_fence(true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1731,0 +1731,1 @@\n+  set_requires_cross_modify_fence(false);\n@@ -5133,0 +5134,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1099,0 +1099,1 @@\n+  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n@@ -1345,0 +1346,2 @@\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n@@ -1806,0 +1809,1 @@\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n@@ -2094,0 +2098,2 @@\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}