{"files":[{"patch":"@@ -2920,0 +2920,3 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n+\n@@ -2923,1 +2926,0 @@\n-  __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -83,1 +85,0 @@\n-  maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1586,1 +1586,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_leaf_base:\"\n+    stop(\"InterpreterMacroAssembler::call_VM_base:\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1405,1 +1405,2 @@\n-  maybe_isb();\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -4410,4 +4411,9 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), rtype);\n-  ldrw(zr, Address(r, 0));\n-  return inst_mark();\n+  address mark;\n+  {\n+    InstructionMark im(this);\n+    code_section()->relocate(inst_mark(), rtype);\n+    ldrw(zr, Address(r, 0));\n+    mark = inst_mark();\n+  }\n+  verify_cross_modify_fence_not_required();\n+  return mark;\n@@ -4478,0 +4484,1 @@\n+  verify_cross_modify_fence_not_required();\n@@ -5305,0 +5312,26 @@\n+\n+void MacroAssembler::safepoint_isb() {\n+  isb();\n+#ifndef PRODUCT\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Clear the thread state.\n+    strb(zr, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+  }\n+#endif\n+}\n+\n+#ifndef PRODUCT\n+void MacroAssembler::verify_cross_modify_fence_not_required() {\n+  if (VerifyCrossModifyFence) {\n+    \/\/ Check if thread needs a cross modify fence.\n+    ldrb(rscratch1, Address(rthread, in_bytes(JavaThread::requires_cross_modify_fence_offset())));\n+    Label fence_not_required;\n+    cbz(rscratch1, fence_not_required);\n+    \/\/ If it does then fail.\n+    lea(rscratch1, CAST_FROM_FN_PTR(address, JavaThread::verify_cross_modify_fence_failure));\n+    mov(c_rarg0, rthread);\n+    blr(rscratch1);\n+    bind(fence_not_required);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1300,2 +1300,3 @@\n-  \/\/ ISB may be needed because of a safepoint\n-  void maybe_isb() { isb(); }\n+\n+  \/\/ Place an ISB after code may have been modified due to a safepoint.\n+  void safepoint_isb();\n@@ -1377,0 +1378,5 @@\n+\n+private:\n+  \/\/ Check the current thread doesn't need a cross modify fence.\n+  void verify_cross_modify_fence_not_required() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1167,1 +1170,0 @@\n-    __ maybe_isb();\n@@ -1877,1 +1879,4 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n+  \/\/ If a safepoint is in progress, then the resulting suspend will cause an ISB\n+  \/\/ to happen before returning. However, if a safepoint started but has already\n+  \/\/ completed then we need to ISB instead.\n@@ -1883,0 +1888,2 @@\n+    \/\/ No need to suspend, therefore ISB.\n+    __ safepoint_isb();\n@@ -2048,0 +2055,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2075,0 +2084,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2098,1 +2109,1 @@\n-    __ maybe_isb();\n+\n@@ -2793,0 +2804,2 @@\n+  \/\/ An instruction sync is required here after the call into the VM. However,\n+  \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2806,1 +2819,0 @@\n-  __ maybe_isb();\n@@ -2904,0 +2916,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -2913,2 +2927,0 @@\n-  __ maybe_isb();\n-\n@@ -3036,1 +3048,2 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -5017,0 +5017,2 @@\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n@@ -5024,1 +5026,0 @@\n-    __ maybe_isb();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1357,1 +1357,5 @@\n-  \/\/ Call the native method.\n+  \/\/ Call the native method. Requires an explicit ISB afterwards because a\n+  \/\/ safepoint may have occured since the thread moved into _thread_in_native\n+  \/\/ state. If the safepoint is still ongoing after this point, then there\n+  \/\/ will be another ISB due to cross_modify_fence call inside the safepoint\n+  \/\/ in progress check.\n@@ -1360,1 +1364,1 @@\n-  __ maybe_isb();\n+  __ safepoint_isb();\n@@ -1404,1 +1408,2 @@\n-    __ maybe_isb();\n+    \/\/ An instruction sync is required here after the call into the VM. However,\n+    \/\/ that will have been caught in the VM by a cross_modify_fence call.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-inline void OrderAccess::cross_modify_fence()\n+inline void OrderAccess::instruction_fence()\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/orderAccess_aix_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::instruction_fence() {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/orderAccess_bsd_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::instruction_fence()             { }\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/orderAccess_bsd_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+#define inlasm_isb()    asm volatile(\"isb\" : : : \"memory\")\n+\n@@ -56,1 +58,5 @@\n-inline void OrderAccess::cross_modify_fence() { }\n+inline void OrderAccess::instruction_fence() {\n+  inlasm_isb();\n+}\n+\n+#undef inlasm_isb\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/orderAccess_linux_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-inline void OrderAccess::cross_modify_fence()   { }\n+inline void OrderAccess::instruction_fence()   { }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/orderAccess_linux_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline void   OrderAccess::cross_modify_fence()\n+inline void   OrderAccess::instruction_fence()\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/orderAccess_linux_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-inline void OrderAccess::cross_modify_fence() { inlasm_zarch_sync(); }\n+inline void OrderAccess::instruction_fence() { inlasm_zarch_sync(); }\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/orderAccess_linux_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::instruction_fence() {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/orderAccess_linux_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-inline void OrderAccess::cross_modify_fence()            { }\n+inline void OrderAccess::instruction_fence()            { }\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/orderAccess_linux_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-inline void OrderAccess::cross_modify_fence() {\n+inline void OrderAccess::instruction_fence() {\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/orderAccess_windows_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2487,1 +2487,5 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence, false,                              \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-    OrderAccess::cross_modify_fence();\n+    _thread->cross_modify_fence();\n@@ -298,1 +298,1 @@\n-    OrderAccess::cross_modify_fence();\n+    _thread->cross_modify_fence();\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-\/\/ Finally, we define a \"fence\" operation, as a bidirectional barrier.\n+\/\/ We define a \"fence\" operation, as a bidirectional barrier.\n@@ -232,0 +232,7 @@\n+\/\/\n+\/\/ Finally, we define an \"instruction_fence\" operation, as a bidirectional\n+\/\/ barrier for the instruction code cache. It guarantees that any memory access\n+\/\/ to the instruction code preceding the fence is not reordered w.r.t. any\n+\/\/ memory accesses to instruction code subsequent to the fence in program order.\n+\/\/ Ideally it should only be called from JavaThread::cross_modify_fence().\n+\/\/\n@@ -245,1 +252,1 @@\n-  static void     cross_modify_fence();\n+  static void     instruction_fence();\n@@ -258,0 +265,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/orderAccess.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -383,0 +383,8 @@\n+  \/\/ Mark all threads\n+  if (VerifyCrossModifyFence) {\n+    JavaThreadIteratorWithHandle jtiwh;\n+    for (; JavaThread *cur = jtiwh.next(); ) {\n+      cur->set_requires_cross_modify_fence(true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  OrderAccess::cross_modify_fence();\n+  thread->cross_modify_fence();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1725,0 +1725,1 @@\n+  set_requires_cross_modify_fence(false);\n@@ -1944,1 +1945,1 @@\n-  OrderAccess::cross_modify_fence();\n+  cross_modify_fence();\n@@ -2596,1 +2597,1 @@\n-  OrderAccess::cross_modify_fence();\n+  cross_modify_fence();\n@@ -5127,0 +5128,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1099,0 +1099,1 @@\n+  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n@@ -1345,0 +1346,2 @@\n+  void set_requires_cross_modify_fence(bool val) PRODUCT_RETURN NOT_PRODUCT({ _requires_cross_modify_fence = val; })\n+\n@@ -1806,0 +1809,1 @@\n+  NOT_PRODUCT(static ByteSize requires_cross_modify_fence_offset()  { return byte_offset_of(JavaThread, _requires_cross_modify_fence); })\n@@ -2094,0 +2098,21 @@\n+\n+  \/\/ cross_modify_fence places an instruction_fence and should be used in\n+  \/\/ conjunction with safepointing to ensure that changes to the instruction\n+  \/\/ stream are seen on exit from a safepoint. Namely:\n+  \/\/ [1] Directly before running a new thread [See JavaThread::run()]\n+  \/\/ [2] Whilst in the VM, on exit from being suspended in a safepoint. [See\n+  \/\/     SafepointMechanism::process_if_requested_slow()]\n+  \/\/ [3] Whilst in the VM, on exit from blocking [See ThreadBlockInVM\n+  \/\/     and ThreadBlockInVMWithDeadlockCheck]\n+  \/\/ [4] At the end of a JNI call, on exit from blocking. This only happens if a\n+  \/\/     safepoint had started but not completed when the JNI call finished.\n+  \/\/     Note this does not catch the case where there was a safepoint but it\n+  \/\/     completed before the JNI finished. [See check_safepoint_and_suspend_for_native_trans()]\n+  inline void cross_modify_fence() {\n+    OrderAccess::instruction_fence();\n+    if (VerifyCrossModifyFence) {\n+      set_requires_cross_modify_fence(false);\n+    }\n+  }\n+\n+  static void verify_cross_modify_fence_failure(JavaThread *thread) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}