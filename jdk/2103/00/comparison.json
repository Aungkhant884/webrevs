{"files":[{"patch":"@@ -3009,10 +3009,0 @@\n-void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n-  assert(UseAVX > 0, \"requires some form of AVX\");\n-  if (reachable(src)) {\n-    Assembler::vpaddb(dst, nds, as_Address(src), vector_len);\n-  } else {\n-    lea(rscratch, src);\n-    Assembler::vpaddb(dst, nds, Address(rscratch, 0), vector_len);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1244,1 +1244,0 @@\n-  void vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -613,15 +613,0 @@\n-  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n-    address start = __ pc();\n-    __ emit_data(0x70707070, relocInfo::none, 0);\n-    __ emit_data(0x70707070, relocInfo::none, 0);\n-    __ emit_data(0x70707070, relocInfo::none, 0);\n-    __ emit_data(0x70707070, relocInfo::none, 0);\n-    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n-    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n-    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n-    __ emit_data(0xF0F0F0F0, relocInfo::none, 0);\n-    return start;\n-  }\n-\n@@ -3984,1 +3969,0 @@\n-    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -811,11 +811,0 @@\n-  address generate_vector_byte_shuffle_mask(const char *stub_name) {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n-    address start = __ pc();\n-    __ emit_data64(0x7070707070707070, relocInfo::none);\n-    __ emit_data64(0x7070707070707070, relocInfo::none);\n-    __ emit_data64(0xF0F0F0F0F0F0F0F0, relocInfo::none);\n-    __ emit_data64(0xF0F0F0F0F0F0F0F0, relocInfo::none);\n-    return start;\n-  }\n-\n@@ -6842,1 +6831,0 @@\n-    StubRoutines::x86::_vector_byte_shuffle_mask = generate_vector_byte_shuffle_mask(\"vector_byte_shuffle_mask\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-address StubRoutines::x86::_vector_byte_shuffle_mask = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-  static address _vector_byte_shuffle_mask;\n@@ -284,4 +283,0 @@\n-  static address vector_byte_shuffle_mask() {\n-    return _vector_byte_shuffle_mask;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1357,1 +1357,0 @@\n-  static address vector_byte_shufflemask() { return StubRoutines::x86::vector_byte_shuffle_mask(); }\n@@ -1695,1 +1694,1 @@\n-      } else if (bt == T_BYTE && size_in_bits > 256 && !VM_Version::supports_avx512_vbmi())  {\n+      } else if (bt == T_BYTE && size_in_bits >= 256 && !VM_Version::supports_avx512_vbmi())  {\n@@ -1697,1 +1696,1 @@\n-      } else if (bt == T_SHORT && size_in_bits > 256 && !VM_Version::supports_avx512bw())  {\n+      } else if (bt == T_SHORT && size_in_bits >= 256 && !VM_Version::supports_avx512bw())  {\n@@ -7504,1 +7503,1 @@\n-instruct rearrangeB_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+instruct rearrangeB_avx(vec dst, vec src, vec shuffle) %{\n@@ -7508,2 +7507,1 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n+  format %{ \"vector_rearrange $dst, $shuffle, $src\" %}\n@@ -7511,11 +7509,1 @@\n-    assert(UseAVX >= 2, \"required\");\n-    \/\/ Swap src into vtmp1\n-    __ vperm2i128($vtmp1$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 1);\n-    \/\/ Shuffle swapped src to get entries from other 128 bit lane\n-    __ vpshufb($vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n-    \/\/ Shuffle original src to get entries from self 128 bit lane\n-    __ vpshufb($dst$$XMMRegister, $src$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n-    \/\/ Create a blend mask by setting high bits for entries coming from other lane in shuffle\n-    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n-    \/\/ Perform the blend\n-    __ vpblendvb($dst$$XMMRegister, $dst$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, Assembler::AVX_256bit);\n+    __ vpshufb($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister, Assembler::AVX_256bit);\n@@ -7542,1 +7530,1 @@\n-            vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            vector_length(n) <= 8 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -7549,19 +7537,0 @@\n-    int vlen_in_bytes = vector_length_in_bytes(this);\n-    if (vlen_in_bytes <= 8) {\n-      \/\/ Multiply each shuffle by two to get byte index\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n-      __ psllw($vtmp$$XMMRegister, 1);\n-\n-      \/\/ Duplicate to create 2 copies of byte index\n-      __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n-      __ psllw($dst$$XMMRegister, 8);\n-      __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n-\n-      \/\/ Add one to get alternate byte index\n-      __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n-      __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n-      \/\/ Multiply each shuffle by two to get byte index\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -7569,3 +7538,3 @@\n-      \/\/ Duplicate to create 2 copies of byte index\n-      __ vpsllw($dst$$XMMRegister, $vtmp$$XMMRegister,  8, vlen_enc);\n-      __ vpor($dst$$XMMRegister, $dst$$XMMRegister, $vtmp$$XMMRegister, vlen_enc);\n+    \/\/ Multiply each shuffle by two to get byte index\n+    __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ psllw($vtmp$$XMMRegister, 1);\n@@ -7573,3 +7542,8 @@\n-      \/\/ Add one to get alternate byte index\n-      __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, $scratch$$Register);\n-    }\n+    \/\/ Duplicate to create 2 copies of byte index\n+    __ movdqu($dst$$XMMRegister, $vtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    __ por($dst$$XMMRegister, $vtmp$$XMMRegister);\n+\n+    \/\/ Add one to get alternate byte index\n+    __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n+    __ paddb($dst$$XMMRegister, $vtmp$$XMMRegister);\n@@ -7592,22 +7566,0 @@\n-instruct rearrangeS_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n-  predicate(vector_element_basic_type(n) == T_SHORT &&\n-            vector_length(n) == 16 && !VM_Version::supports_avx512bw());\n-  match(Set dst (VectorRearrange src shuffle));\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n-  ins_encode %{\n-    assert(UseAVX >= 2, \"required\");\n-    \/\/ Swap src into vtmp1\n-    __ vperm2i128($vtmp1$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 1);\n-    \/\/ Shuffle swapped src to get entries from other 128 bit lane\n-    __ vpshufb($vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n-    \/\/ Shuffle original src to get entries from self 128 bit lane\n-    __ vpshufb($dst$$XMMRegister, $src$$XMMRegister, $shuffle$$XMMRegister, Assembler::AVX_256bit);\n-    \/\/ Create a blend mask by setting high bits for entries coming from other lane in shuffle\n-    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n-    \/\/ Perform the blend\n-    __ vpblendvb($dst$$XMMRegister, $dst$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, Assembler::AVX_256bit);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":66,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Byte128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte128Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Byte128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte128Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Byte256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte256Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Byte256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte256Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Byte512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte512Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Byte512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte512Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Byte64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte64Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Byte64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Byte64Shuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         ByteMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (ByteMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         ByteMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((byte)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1984,5 +1984,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Byte> Iota = iotaShuffle();\n-        VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((ByteVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        byte[] a0 = this.vec();\n+        byte[] a1 = that.vec();\n+        byte[] res = new byte[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -2010,11 +2013,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ByteVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Byte> Iota = iotaShuffle();\n-        VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -2035,6 +2027,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Byte> Iota = iotaShuffle();\n-        VectorMask<Byte> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((byte)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((ByteVector)w).blend(this.rearrange(Iota), BlendMask);\n+        byte[] slice = this.vec();\n+        byte[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -2070,13 +2071,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ByteVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Byte> Iota = iotaShuffle();\n-        VectorMask<Byte> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((byte)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Double128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double128Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Double128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double128Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Double256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double256Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Double256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double256Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Double512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double512Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Double512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double512Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Double64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double64Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Double64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Double64Shuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         DoubleMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (DoubleMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         DoubleMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((double)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1897,5 +1897,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Double> Iota = iotaShuffle();\n-        VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((DoubleVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        double[] a0 = this.vec();\n+        double[] a1 = that.vec();\n+        double[] res = new double[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -1923,11 +1926,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    DoubleVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Double> Iota = iotaShuffle();\n-        VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -1948,6 +1940,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Double> Iota = iotaShuffle();\n-        VectorMask<Double> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((double)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((DoubleVector)w).blend(this.rearrange(Iota), BlendMask);\n+        double[] slice = this.vec();\n+        double[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -1983,13 +1984,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    DoubleVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Double> Iota = iotaShuffle();\n-        VectorMask<Double> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((double)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Float128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float128Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Float128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float128Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Float256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float256Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Float256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float256Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Float512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float512Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Float512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float512Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (Float64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float64Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (Float64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Float64Shuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,8 @@\n-        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         FloatMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -405,1 +412,8 @@\n-        return (FloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         FloatMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((float)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1909,5 +1909,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Float> Iota = iotaShuffle();\n-        VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((FloatVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        float[] a0 = this.vec();\n+        float[] a1 = that.vec();\n+        float[] res = new float[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -1935,11 +1938,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    FloatVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Float> Iota = iotaShuffle();\n-        VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -1960,6 +1952,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Float> Iota = iotaShuffle();\n-        VectorMask<Float> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((float)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((FloatVector)w).blend(this.rearrange(Iota), BlendMask);\n+        float[] slice = this.vec();\n+        float[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -1995,13 +1996,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    FloatVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Float> Iota = iotaShuffle();\n-        VectorMask<Float> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((float)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Int128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int128Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Int128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int128Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Int256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int256Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Int256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int256Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Int512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int512Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Int512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int512Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Int64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int64Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Int64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Int64Shuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         IntMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (IntMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         IntMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((int)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1983,5 +1983,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Integer> Iota = iotaShuffle();\n-        VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((IntVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        int[] a0 = this.vec();\n+        int[] a1 = that.vec();\n+        int[] res = new int[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -2009,11 +2012,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    IntVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Integer> Iota = iotaShuffle();\n-        VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -2034,6 +2026,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Integer> Iota = iotaShuffle();\n-        VectorMask<Integer> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((int)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((IntVector)w).blend(this.rearrange(Iota), BlendMask);\n+        int[] slice = this.vec();\n+        int[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -2069,13 +2070,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    IntVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Integer> Iota = iotaShuffle();\n-        VectorMask<Integer> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((int)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,8 @@\n-        return (Long128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long128Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -401,1 +408,8 @@\n-        return (Long128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long128Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,8 @@\n-        return (Long256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long256Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -401,1 +408,8 @@\n-        return (Long256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long256Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,8 @@\n-        return (Long512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long512Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -401,1 +408,8 @@\n-        return (Long512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long512Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,8 @@\n-        return (Long64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long64Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -401,1 +408,8 @@\n-        return (Long64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Long64Shuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,8 @@\n-        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         LongMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -401,1 +408,8 @@\n-        return (LongMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         LongMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((long)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1854,5 +1854,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Long> Iota = iotaShuffle();\n-        VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((LongVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        long[] a0 = this.vec();\n+        long[] a1 = that.vec();\n+        long[] res = new long[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -1880,11 +1883,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    LongVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Long> Iota = iotaShuffle();\n-        VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -1905,6 +1897,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Long> Iota = iotaShuffle();\n-        VectorMask<Long> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((long)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((LongVector)w).blend(this.rearrange(Iota), BlendMask);\n+        long[] slice = this.vec();\n+        long[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -1940,13 +1941,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    LongVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Long> Iota = iotaShuffle();\n-        VectorMask<Long> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((long)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Short128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short128Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Short128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short128Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Short256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short256Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Short256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short256Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Short512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short512Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Short512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short512Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (Short64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short64Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (Short64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         Short64Shuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,8 @@\n-        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         ShortMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -411,1 +418,8 @@\n-        return (ShortMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         ShortMaxShuffle Iota = iotaShuffle();\n+         VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast((short)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1984,5 +1984,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Short> Iota = iotaShuffle();\n-        VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return ((ShortVector)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        short[] a0 = this.vec();\n+        short[] a1 = that.vec();\n+        short[] res = new short[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -2010,11 +2013,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ShortVector sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Short> Iota = iotaShuffle();\n-        VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -2035,6 +2027,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Short> Iota = iotaShuffle();\n-        VectorMask<Short> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast((short)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return ((ShortVector)w).blend(this.rearrange(Iota), BlendMask);\n+        short[] slice = this.vec();\n+        short[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -2070,13 +2071,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    ShortVector\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<Short> Iota = iotaShuffle();\n-        VectorMask<Short> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast((short)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -2253,5 +2253,8 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<$Boxtype$> Iota = iotaShuffle();\n-        VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return (($abstractvectortype$)v1).rearrange(Iota).blend(this.rearrange(Iota), BlendMask);\n+        $type$[] a0 = this.vec();\n+        $type$[] a1 = that.vec();\n+        $type$[] res = new $type$[a0.length];\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        System.arraycopy(a0, origin, res, 0, firstPart);\n+        System.arraycopy(a1, 0, res, firstPart, origin);\n+        return vectorFactory(res);\n@@ -2279,11 +2282,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    $abstractvectortype$ sliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<$Boxtype$> Iota = iotaShuffle();\n-        VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n-        Iota = iotaShuffle(origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n@@ -2304,6 +2296,15 @@\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<$Boxtype$> Iota = iotaShuffle();\n-        VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n-                                                                  (broadcast(($type$)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return (($abstractvectortype$)w).blend(this.rearrange(Iota), BlendMask);\n+        $type$[] slice = this.vec();\n+        $type$[] res = that.vec().clone();\n+        int vlen = res.length;\n+        int firstPart = vlen - origin;\n+        switch (part) {\n+        case 0:\n+            System.arraycopy(slice, 0, res, origin, firstPart);\n+            break;\n+        case 1:\n+            System.arraycopy(slice, firstPart, res, 0, origin);\n+            break;\n+        default:\n+            throw wrongPartForSlice(part);\n+        }\n+        return vectorFactory(res);\n@@ -2339,13 +2340,0 @@\n-    \/*package-private*\/\n-    final\n-    @ForceInline\n-    $abstractvectortype$\n-    unsliceTemplate(int origin) {\n-        Objects.checkIndex(origin, length());\n-        VectorShuffle<$Boxtype$> Iota = iotaShuffle();\n-        VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.GE,\n-                                                                  (broadcast(($type$)(origin))));\n-        Iota = iotaShuffle(-origin, 1, true);\n-        return vspecies().zero().blend(this.rearrange(Iota), BlendMask);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,8 @@\n-        return ($vectortype$) super.sliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         $shuffletype$ Iota = iotaShuffle();\n+         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(VLENGTH-origin))));\n+         Iota = iotaShuffle(origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n@@ -417,1 +424,8 @@\n-        return ($vectortype$) super.unsliceTemplate(origin);  \/\/ specialize\n+       if ((origin < 0) || (origin >= VLENGTH)) {\n+         throw new ArrayIndexOutOfBoundsException(\"Index \" + origin + \" out of bounds for vector length \" + VLENGTH);\n+       } else {\n+         $shuffletype$ Iota = iotaShuffle();\n+         VectorMask<$Boxtype$> BlendMask = Iota.toVector().compare(VectorOperators.GE, (broadcast(($type$)(origin))));\n+         Iota = iotaShuffle(-origin, 1, true);\n+         return ZERO.blend(this.rearrange(Iota), BlendMask);\n+       }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"}]}