{"files":[{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary Generate large number of Secret Keys using same KEM\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom GenLargeNumberOfKeys\n+ *\/\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+import javax.crypto.KEM;\n+import java.security.spec.ECGenParameterSpec;\n+import jdk.test.lib.Asserts;\n+\n+public class GenLargeNumberOfKeys {\n+\n+    private static final int COUNT = 1000;\n+\n+    \/*\n+     * X448 produce keysize of 64 bytes which is larger in it's class\n+     * secp521r1 produce keysize of 64 bytes which is larger in it's class\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        testAlgo(kem, \"XDH\", \"X448\");\n+        testAlgo(kem, \"EC\", \"secp521r1\");\n+    }\n+\n+    private static void testAlgo(KEM kem, String algo, String curveId) throws Exception {\n+        KeyPair kp = genKeyPair(algo, curveId);\n+        KEM.Encapsulator e = kem.newEncapsulator(kp.getPublic());\n+        KEM.Decapsulator d = kem.newDecapsulator(kp.getPrivate());\n+        for (int i = 0; i < COUNT; i++) {\n+            test(e, d);\n+        }\n+        System.out.println(algo + \": test Successful\");\n+    }\n+\n+    private static KeyPair genKeyPair(String algo, String curveId) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+        kpg.initialize(new ECGenParameterSpec(curveId));\n+        return kpg.generateKeyPair();\n+    }\n+\n+    private static void test(KEM.Encapsulator e, KEM.Decapsulator d)\n+            throws Exception {\n+        KEM.Encapsulated enc = e.encapsulate();\n+        Asserts.assertEQ(d.encapsulationSize(), enc.encapsulation().length);\n+        Asserts.assertEQ(d.secretSize(), enc.key().getEncoded().length);\n+        Asserts.assertTrue(Arrays.equals(d.decapsulate(enc.encapsulation()).getEncoded(), enc.key().getEncoded()));\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/GenLargeNumberOfKeys.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary KEM using KeyPair generated through SunPKCS11 provider using NSS\n+ * @library \/test\/lib ..\/..\/..\/sun\/security\/pkcs11\n+ *\/\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.Arrays;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import jdk.test.lib.Asserts;\n+\n+public class KemInterop extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new KemInterop(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        test(\"EC\", \"secp256r1\", p);\n+        test(\"EC\", \"secp384r1\", p);\n+        test(\"EC\", \"secp521r1\", p);\n+        test(\"X25519\", null, p);\n+        test(\"X448\", null, p);\n+        test(\"XDH\", null, p);\n+        test(\"XDH\", \"X25519\", p);\n+        test(\"XDH\", \"X448\", p);\n+    }\n+\n+    private static void test(String algo, String curveId, Provider p) throws Exception {\n+\n+        @FunctionalInterface\n+        interface KemTest<KP, SR> {\n+\n+            void test(KP kp, SR scr);\n+        }\n+\n+        KemTest<KeyPair, SecureRandom> kemWithPKCSKeys = (kpr, scr) -> {\n+            try {\n+                KEM kem = KEM.getInstance(\"DHKEM\", \"SunJCE\");\n+                KEM.Encapsulator encT = encapsulator(kem, kpr.getPublic(), scr);\n+                KEM.Encapsulator encT1 = encapsulator(kem, kpr.getPublic(), scr);\n+                KEM.Encapsulated enc = encT.encapsulate();\n+                KEM.Encapsulated enc1 = encT.encapsulate();\n+                KEM.Encapsulated enc2 = encT1.encapsulate();\n+\n+                Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), enc.key().getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(enc.encapsulation(), enc.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc1.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc1.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc2.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc2.encapsulation()));\n+\n+                KEM.Decapsulator decT = kem.newDecapsulator(kpr.getPrivate());\n+                SecretKey dsk = decT.decapsulate(enc.encapsulation());\n+                Asserts.assertTrue(Arrays.equals(dsk.getEncoded(), enc.key().getEncoded()));\n+\n+                Asserts.assertEQ(encT.encapsulationSize(), enc.encapsulation().length);\n+                Asserts.assertEQ(encT.encapsulationSize(), decT.encapsulationSize());\n+                Asserts.assertEQ(encT.secretSize(), enc.key().getEncoded().length);\n+                Asserts.assertEQ(encT.secretSize(), decT.secretSize());\n+\n+                KEM.Encapsulated enc3 = encT.encapsulate(0, encT.secretSize(), \"AES\");\n+                KEM.Decapsulator decT1 = kem.newDecapsulator(kpr.getPrivate());\n+                SecretKey dsk1 = decT1.decapsulate(enc3.encapsulation(), 0, decT1.secretSize(), \"AES\");\n+                Asserts.assertTrue(Arrays.equals(dsk1.getEncoded(), enc3.key().getEncoded()));\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+            System.out.println(\"Success\");\n+        };\n+\n+        KeyPair kp = null;\n+        SecureRandom sr = null;\n+        try {\n+            System.out.print(\"Algo-\" + algo + \":\" + \"Curve-\" + curveId + \":\");\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo, p);\n+            try {\n+                sr = SecureRandom.getInstance(\"PKCS11\");\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ Get default SecureRandom incase PKCS11 not found\n+                sr = new SecureRandom();\n+            }\n+            if (curveId != null) {\n+                kpg.initialize(new ECGenParameterSpec(curveId), sr);\n+            }\n+            kp = kpg.generateKeyPair();\n+        } catch (NoSuchAlgorithmException e) {\n+            System.out.println(\"Unsupported. Test execution Ignored\");\n+            return;\n+        }\n+\n+        kemWithPKCSKeys.test(kp, null);\n+        kemWithPKCSKeys.test(kp, sr);\n+    }\n+\n+    private static KEM.Encapsulator encapsulator(KEM kem, PublicKey pk, SecureRandom sr)\n+            throws Exception {\n+        if (sr == null) {\n+            return kem.newEncapsulator(pk);\n+        } else {\n+            return kem.newEncapsulator(pk, sr);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/KemInterop.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8297878\n+ * @summary KEM API test\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom KemTest\n+ *\/\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.ExecutorCompletionService;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import javax.crypto.DecapsulateException;\n+import jdk.test.lib.Asserts;\n+\n+public class KemTest {\n+\n+    private static final int THREAD_COUNT = 100;\n+    private static final int THREAD_POOL_SIZE = 20;\n+    private static final String ALGO = \"DHKEM\";\n+    private static final String PROVIDER = \"SunJCE\";\n+\n+    public static void main(String[] args) throws Exception {\n+        KEM kem = KEM.getInstance(ALGO, PROVIDER);\n+        Asserts.assertEQ(kem.getAlgorithm(), ALGO);\n+        testSize(kem);\n+        testParallelEncapsulator(kem, \"EC\", \"secp256r1\");\n+        testParallelEncapsulate(kem, \"EC\", \"secp256r1\");\n+        testParallelDecapsulator(kem, \"EC\", \"secp256r1\");\n+        testParallelDecapsulate(kem, \"EC\", \"secp256r1\");\n+    }\n+\n+    @FunctionalInterface\n+    interface GenKeyPair<A, C, K> {\n+\n+        K gen(A a, C c);\n+    }\n+    private static final GenKeyPair<String, String, KeyPair> keyPair = (algo, curveId) -> {\n+        try {\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo);\n+            if (curveId != null) {\n+                kpg.initialize(new ECGenParameterSpec(curveId));\n+            }\n+            return kpg.generateKeyPair();\n+        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+            throw new RuntimeException(e);\n+        }\n+    };\n+\n+    \/*\n+     * As per https:\/\/www.rfc-editor.org\/rfc\/rfc9180#name-key-encapsulation-mechanism\n+     * Nsecret: The length in bytes of a KEM shared secret produced by this KEM.\n+     * Nenc: The length in bytes of an encapsulated key produced by this KEM.\n+     *\/\n+    private static void testSize(KEM kem) throws Exception {\n+\n+        @FunctionalInterface\n+        interface LengthTest<A, C, S, E> {\n+\n+            void test(A a, C c, S s, E e);\n+        }\n+        LengthTest<String, String, Integer, Integer> secretLen = (algo, curveId, nSecret, nEnc) -> {\n+            try {\n+                KeyPair kp = keyPair.gen(algo, curveId);\n+                KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+                Asserts.assertEQ(encT.providerName(), PROVIDER);\n+                KEM.Encapsulated enc = encT.encapsulate();\n+                KEM.Encapsulated enc1 = encT.encapsulate();\n+\n+                KEM kem1 = KEM.getInstance(ALGO, PROVIDER);\n+                KEM.Encapsulator encT2 = kem1.newEncapsulator(kp.getPublic());\n+                KEM.Encapsulated enc2 = encT2.encapsulate();\n+\n+                Asserts.assertEQ(enc.key().getEncoded().length, nSecret);\n+                Asserts.assertEQ(enc.encapsulation().length, nEnc);\n+\n+                Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), enc.key().getEncoded()));\n+                Asserts.assertTrue(Arrays.equals(enc.encapsulation(), enc.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc1.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc1.encapsulation()));\n+\n+                Asserts.assertFalse(Arrays.equals(enc.key().getEncoded(), enc2.key().getEncoded()));\n+                Asserts.assertFalse(Arrays.equals(enc.encapsulation(), enc2.encapsulation()));\n+\n+                SecretKey sk = enc.key();\n+                KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+                SecretKey dsk = decT.decapsulate(enc.encapsulation());\n+                Asserts.assertEQ(decT.providerName(), PROVIDER);\n+                Asserts.assertTrue(Arrays.equals(sk.getEncoded(), dsk.getEncoded()));\n+\n+                Asserts.assertEQ(encT.encapsulationSize(), enc.encapsulation().length);\n+                Asserts.assertEQ(encT.encapsulationSize(), decT.encapsulationSize());\n+                Asserts.assertEQ(encT.secretSize(), enc.key().getEncoded().length);\n+                Asserts.assertEQ(encT.secretSize(), decT.secretSize());\n+\n+                KEM.Encapsulated enc3 = encT.encapsulate(0, encT.secretSize(), \"AES\");\n+                KEM.Decapsulator decT1 = kem.newDecapsulator(kp.getPrivate());\n+                SecretKey dsk1 = decT1.decapsulate(\n+                        enc3.encapsulation(), 0, decT1.secretSize(), \"AES\");\n+                Asserts.assertTrue(Arrays.equals(dsk1.getEncoded(), enc3.key().getEncoded()));\n+\n+                try {\n+                    decT.decapsulate(new byte[enc.encapsulation().length]);\n+                    throw new RuntimeException(\"Shouldn't reach here\");\n+                } catch (DecapsulateException de) {\n+                    \/\/de.printStackTrace();\n+                    System.out.println(\"Expected Failure: mismatched encapsulation\");\n+                }\n+\n+                System.out.println(\"KEM Secret length:\" + algo + \":\" + curveId\n+                        + \":nSecret:\" + nSecret + \":nEnc:\" + nEnc);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+        \/\/ Secret length in bytes.\n+        secretLen.test(\"EC\", \"secp256r1\", 32, 65);\n+        secretLen.test(\"EC\", \"secp384r1\", 48, 97);\n+        secretLen.test(\"EC\", \"secp521r1\", 64, 133);\n+        secretLen.test(\"X25519\", null, 32, 32);\n+        secretLen.test(\"X448\", null, 64, 56);\n+        secretLen.test(\"XDH\", null, 32, 32);\n+        secretLen.test(\"XDH\", \"X25519\", 32, 32);\n+        secretLen.test(\"XDH\", \"X448\", 64, 56);\n+        try {\n+            secretLen.test(\"Ed25519\", null, 32, 32);\n+        } catch (Exception e) {\n+            if (!e.getMessage().contains(\"java.security.InvalidKeyException\")) {\n+                throw e;\n+            }\n+            System.out.println(\"Expected Exception: Bad Key type: Ed25519\");\n+        }\n+        try {\n+            secretLen.test(\"RSA\", null, 256, 256);\n+        } catch (Exception e) {\n+            if (!e.getMessage().contains(\"java.security.InvalidKeyException\")) {\n+                throw e;\n+            }\n+            System.out.println(\"Expected Exception: Bad Key type: RSA\");\n+        }\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * A KEM object is immutable. It is safe to call multiple newEncapsulator and\n+     * newDecapsulator methods on the same KEM object at the same time.\n+     *\/\n+    private static void testParallelEncapsulator(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Encapsulator> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Encapsulator>> futures = new ArrayList<>();\n+\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Encapsulator> task = () -> {\n+                    return kem.newEncapsulator(kp.getPublic());\n+                };\n+                futures.add(cs.submit(task));\n+            }\n+\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            for (Future<KEM.Encapsulator> future : futures) {\n+                KEM.Encapsulated enc = future.get().encapsulate();\n+                Asserts.assertTrue(Arrays.equals(decT.decapsulate(enc.encapsulation()).getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Encapsulator Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelEncapsulate(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Encapsulated> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Encapsulated>> futures = new ArrayList<>();\n+            KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Encapsulated> task = () -> {\n+                    return encT.encapsulate();\n+                };\n+                futures.add(cs.submit(task));\n+            }\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            for (Future<KEM.Encapsulated> future : futures) {\n+                Asserts.assertTrue(Arrays.equals(decT.decapsulate(future.get().encapsulation()).getEncoded(),\n+                        future.get().key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Encapsulate Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelDecapsulator(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<KEM.Decapsulator> cs = new ExecutorCompletionService<>(executor);\n+            List<Future<KEM.Decapsulator>> futures = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<KEM.Decapsulator> task = () -> {\n+                    return kem.newDecapsulator(kp.getPrivate());\n+                };\n+                futures.add(cs.submit(task));\n+            }\n+\n+            KEM.Encapsulated enc = kem.newEncapsulator(kp.getPublic()).encapsulate();\n+            for (Future<KEM.Decapsulator> decT : futures) {\n+                Asserts.assertTrue(Arrays.equals(decT.get().decapsulate(enc.encapsulation()).getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Decapsulator Test: Success\");\n+    }\n+\n+    \/*\n+     * As per JavaDoc API,\n+     * Encapsulator and Decapsulator objects are also immutable.\n+     * It is safe to invoke multiple encapsulate and decapsulate methods on the same\n+     * Encapsulator or Decapsulator object at the same time.\n+     *\/\n+    private static void testParallelDecapsulate(KEM kem, String algo, String curveId)\n+            throws Exception {\n+        KeyPair kp = keyPair.gen(algo, curveId);\n+        ExecutorService executor = null;\n+        try {\n+            executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n+            CompletionService<SecretKey> cs = new ExecutorCompletionService<>(executor);\n+            KEM.Encapsulator encT = kem.newEncapsulator(kp.getPublic());\n+            KEM.Encapsulated enc = encT.encapsulate();\n+\n+            KEM.Decapsulator decT = kem.newDecapsulator(kp.getPrivate());\n+            List<Future<SecretKey>> futures = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                Callable<SecretKey> task = () -> {\n+                    return decT.decapsulate(enc.encapsulation());\n+                };\n+                futures.add(cs.submit(task));\n+            }\n+            for (Future<SecretKey> future : futures) {\n+                Asserts.assertTrue(Arrays.equals(future.get().getEncoded(),\n+                        enc.key().getEncoded()));\n+            }\n+        } finally {\n+            if (executor != null) {\n+                executor.shutdown();\n+            }\n+        }\n+        System.out.println(\"Parallel Decapsulate Test: Success\");\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/KemTest.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"}]}