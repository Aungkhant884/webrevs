{"files":[{"patch":"@@ -1,577 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.test.lib.hprof.parser;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.Closeable;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.RandomAccessFile;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.zip.DataFormatException;\n-import java.util.zip.Inflater;\n-\n-public class GzipRandomAccess implements AutoCloseable, Closeable {\n-    \/\/ A comparator which compares chunks by their file offset.\n-    private static FileOffsetComparator fileOffsetComp = new FileOffsetComparator();\n-\n-    \/\/ A comparator which compares chunks by their offset.\n-    private static OffsetComparator offsetComp = new OffsetComparator();\n-\n-    \/\/ The size to use when reading from the random access file.\n-    private static final int READ_SIZE = 65536;\n-\n-    \/\/ The last used buffer.\n-    private Buffer last;\n-\n-    \/\/ The underlying random access file to use.\n-    private final RandomAccessFile raf;\n-\n-    \/\/ The length of the random access file.\n-    private final long fileSize;\n-\n-    \/\/ The maximum size of a buffer cache.\n-    private final int cacheSize;\n-\n-    \/\/ The maximum numbers of buffers to cache.\n-    private final int maxCachedBuffers;\n-\n-    \/\/ A buffer used to read from the file.\n-    private final byte[] in;\n-\n-    \/\/ A sorted list of the buffers we know so far.\n-    private final ArrayList<Buffer> buffers;\n-\n-    \/\/ The inflater to use.\n-    private final Inflater inf;\n-\n-    \/\/ The head of the list which contains the buffers with cached data.\n-    private final Buffer cacheHead;\n-\n-    \/\/ The number of cached buffers in the list.\n-    private int cachedBuffers;\n-\n-    \/\/ This is private to ensure we only handle the specific hprof gzip files\n-    \/\/ written by the VM.\n-    private GzipRandomAccess(String file, int bufferSize, int maxCachedBuffers)\n-            throws IOException {\n-        last = null;\n-        raf = new RandomAccessFile(file, \"r\");\n-        fileSize = raf.length();\n-        this.cacheSize = bufferSize;\n-        this.maxCachedBuffers = maxCachedBuffers;\n-        cachedBuffers = 0;\n-        in = new byte[READ_SIZE];\n-        buffers = new ArrayList<>();\n-        inf = new Inflater(true);\n-        cacheHead = new Buffer(-1, -1);\n-        cacheHead.next = cacheHead;\n-        cacheHead.prev = cacheHead;\n-        buffers.add(new Buffer(0, 0));\n-    }\n-\n-    \/**\n-     * Clears the cache.\n-     *\/\n-    public synchronized void clearCache() {\n-        while (cacheHead.next != cacheHead) {\n-            assert cacheHead.next.cache != null;\n-            Buffer buf = cacheHead.next;\n-            remove(buf);\n-            buf.cache = null;\n-        }\n-\n-        last = null;\n-        cachedBuffers = 0;\n-    }\n-\n-    \/**\n-     * Returns an approximate file offset for the given offset. The return value should\n-     * only be used for progress indication and the like. Note that you should only query\n-     * offsets you've already read.\n-     *\n-     * @param offset The offset.\n-     * @return The approximate file offset.\n-     *\/\n-    public synchronized long getFileOffset(long offset) {\n-        int pos = Collections.binarySearch(buffers, new Buffer(0, offset), offsetComp);\n-        int realPos = pos >= 0 ? pos : -pos - 2;\n-\n-        if (realPos >= buffers.size() - 1) {\n-            return buffers.get(buffers.size() - 1).fileOffset;\n-        }\n-\n-        \/\/ Assume uniform compression.\n-        Buffer buf = buffers.get(realPos);\n-        long diff = offset - buf.offset;\n-        long bufFileEnd = buffers.get(realPos + 1).fileOffset;\n-        long fileDiff = bufFileEnd - buf.fileOffset;\n-        double filePerDiff = (double) Math.max(1, fileDiff) \/ Math.max(1, buf.cacheLen);\n-\n-        return buf.fileOffset + (long) (filePerDiff * diff);\n-    }\n-\n-    \/**\n-     * @return Returns the size of the underlying file.\n-     *\/\n-    public long getFileSize() {\n-        return fileSize;\n-    }\n-\n-    \/**\n-     * Returns an @link {@link InputStream} to read from the given offset. Note\n-     * that closing the input stream does not close the underlying @link\n-     * {@link GzipRandomAccess} object.\n-     *\n-     * @param offset The offset.\n-     * @return The input stream.\n-     *\/\n-    public InputStream asStream(long offset) {\n-        return new InputStreamImpl(offset, this);\n-    }\n-\n-    \/**\n-     * Returns a @link ReadBuffer which uses this object to do the actual\n-     * operation. Note that closing the returned object closes the\n-     * underlying @link {@link GzipRandomAccess} object.\n-     *\n-     * @return The @link ReadBuffer.\n-     *\/\n-    public ReadBuffer asFileBuffer() {\n-        return new ReadBufferImpl(this);\n-    }\n-\n-    \/**\n-     * Closes the object and clears the cache. The object is unusable after this\n-     * call.\n-     *\/\n-    @Override\n-    public synchronized void close() throws IOException {\n-        clearCache();\n-        buffers.clear();\n-        raf.close();\n-        inf.end();\n-    }\n-\n-    \/**\n-     * Reads bytes from the gzip file.\n-     *\n-     * @param offset The offset from which to start the read.\n-     * @param b The buffer to read into.\n-     * @param off The offset in the buffer to use.\n-     * @param len The number of bytes to read at most.\n-     * @return The number of bytes read or -1 if we are at the end of the file.\n-     * @throws IOException On error.\n-     *\/\n-    public synchronized int read(long offset, byte[] b, int off, int len) throws IOException {\n-        Buffer buf = last;\n-\n-        while (buf == null || (buf.offset > offset) || (buf.offset + buf.cacheLen <= offset)) {\n-            int pos = Collections.binarySearch(buffers, new Buffer(0, offset), offsetComp);\n-            buf = buffers.get(pos >= 0 ? pos : -pos - 2);\n-\n-            if (buf.fileOffset >= fileSize) {\n-                return -1;\n-            }\n-\n-            if (buf.cache != null) {\n-                \/\/ If already loaded, move to front of the cache list.\n-                last = buf;\n-\n-                if (cacheHead.next != buf) {\n-                    remove(buf);\n-                    addFirst(buf);\n-                }\n-            } else {\n-                try {\n-                    \/\/ Note that the load will also add the following buffer to the list,\n-                    \/\/ so the while loop will eventually terminate.\n-                    loadBuffer(buf);\n-                } catch (DataFormatException e) {\n-                    throw new IOException(e);\n-                }\n-            }\n-        }\n-\n-        int copyOffset = (int) (offset - buf.offset);\n-        int toCopyMax = buf.cacheLen - copyOffset;\n-        int toCopy = Math.min(toCopyMax, len);\n-\n-        if (toCopy <= 0) {\n-            return -1;\n-        }\n-\n-        System.arraycopy(buf.cache, copyOffset, b, off, toCopy);\n-\n-        return toCopy;\n-    }\n-\n-    \/**\n-     * Returns the access object for the given file or <code>null<\/code> if not\n-     * supported for the file.\n-     *\n-     * @param file The file name.\n-     * @param cacheSizeInMB The size of the cache to use in megabytes.\n-     * @return The access object or <code>null<\/code>.\n-     *\/\n-    public static GzipRandomAccess getAccess(String file, int cacheSizeInMB)\n-            throws IOException {\n-        try  (RandomAccessFile raf = new RandomAccessFile(file, \"r\")) {\n-            int header = raf.readInt();\n-\n-            if ((header >>> 8) != 0x1f8b08) {\n-                \/\/ No gzip with deflate.\n-                return null;\n-            }\n-\n-            if ((header & 16) == 0) {\n-                \/\/ No comment\n-                return null;\n-            }\n-\n-            raf.readInt(); \/\/ timestamp\n-            raf.readChar(); \/\/ Extra flags and os.\n-\n-            if ((header & 4) != 0) {\n-                \/\/ Skip extra flags.\n-                raf.skipBytes(raf.read() + (raf.read() << 256));\n-            }\n-\n-            \/\/ Skip name\n-            if ((header & 8) != 0) {\n-                while (raf.read() != 0) {\n-                    \/\/ Wait for the last 0.\n-                }\n-            }\n-\n-            \/\/ Read the comment.\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            int b;\n-\n-            while ((b = raf.read()) > 0) {\n-                bos.write(b);\n-            }\n-\n-            \/\/ Check if the block size is included in the comment.\n-            String comment = bos.toString(\"UTF-8\");\n-            String expectedPrefix = \"HPROF BLOCKSIZE=\";\n-\n-            if (comment.startsWith(expectedPrefix)) {\n-                String chunkSizeStr = comment.substring(expectedPrefix.length()).split(\" \")[0];\n-\n-                try {\n-                    int chunkSize = Integer.parseInt(chunkSizeStr);\n-\n-                    if (chunkSize > 0) {\n-                        long nrOfChunks = Math.max(1000, cacheSizeInMB * 1024L * 1024L \/\n-                                                         chunkSize);\n-\n-                        return new GzipRandomAccess(file, chunkSize, (int) nrOfChunks);\n-                    }\n-                } catch (NumberFormatException e) {\n-                    \/\/ Could not parse.\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    \/\/ Loads the content of a buffer. If this is the first time the buffer is\n-    \/\/ loaded, the next buffer is added too (but not loaded).\n-    private void loadBuffer(Buffer buf) throws IOException, DataFormatException {\n-        \/\/ If we have used all caches, take a cache from the least recently used cached buffer.\n-        if (cachedBuffers >= maxCachedBuffers) {\n-            Buffer toRemove = cacheHead.prev;\n-            remove(toRemove);\n-            buf.cache = toRemove.cache;\n-            toRemove.cache = null;\n-        } else {\n-            \/\/ Otherwise allocate a new cache.\n-            buf.cache = new byte[cacheSize];\n-            cachedBuffers += 1;\n-        }\n-\n-        \/\/ Move to front of LRU list.\n-        last = buf;\n-        addFirst(buf);\n-\n-        \/\/ Fill in the cache\n-        inf.reset();\n-        raf.seek(buf.fileOffset);\n-\n-        int read = raf.read(in, 0, READ_SIZE);\n-        int inCount = read;\n-        int outCount = 0;\n-\n-        \/\/ Skip header, but check at least a little\n-        if (read < 4) {\n-            throw new IOException(\"Missing data\");\n-        }\n-\n-        if ((in[0] != 0x1f) || ((in[1] & 0xff) != 0x8b)) {\n-            throw new IOException(\"Missing gzip id\");\n-        }\n-\n-        if (in[2] != 8) {\n-            throw new IOException(\"Only supports deflate\");\n-        }\n-\n-        int off = 10;\n-\n-        \/\/ Extras\n-        if ((in[3] & 4) != 0) {\n-            int len = (in[off + 1] & 0xff) * 256 + (in[off] & 0xff);\n-            off += 2 + len;\n-        }\n-\n-        \/\/ Name\n-        if ((in[3] & 8) != 0) {\n-            int len = 0;\n-\n-            while (in[off + len] != 0) {\n-                ++len;\n-            }\n-\n-            off += len + 1;\n-        }\n-\n-        \/\/ Comment\n-        if ((in[3] & 16) != 0) {\n-            int len = 0;\n-\n-            while (in[off + len] != 0) {\n-                ++len;\n-            }\n-\n-            off += len + 1;\n-        }\n-\n-        \/\/ Header CRC\n-        if ((in[3] & 2) != 0) {\n-            off += 2;\n-        }\n-\n-        inf.setInput(in, off, read - off);\n-        outCount = inf.inflate(buf.cache, 0, buf.cache.length);\n-\n-        while (!inf.finished()) {\n-            if (inf.needsInput()) {\n-                read = raf.read(in, 0, READ_SIZE);\n-                inf.setInput(in, 0, read);\n-                inCount += read;\n-            }\n-\n-            outCount += inf.inflate(buf.cache, outCount, buf.cache.length - outCount);\n-        }\n-\n-        \/\/ Add the following buffer too if needed.\n-        if ((inf.getRemaining() != 0) || (inCount + buf.fileOffset + 8 != fileSize)) {\n-            long nextFileOffset = inCount - inf.getRemaining() + buf.fileOffset + 8 \/* CRC *\/;\n-            long nextOffset = outCount + buf.offset;\n-\n-            Buffer nextChunk = new Buffer(nextFileOffset, nextOffset);\n-            int pos = Collections.binarySearch(buffers, nextChunk, fileOffsetComp);\n-\n-            if (pos < 0) {\n-                buffers.add(-pos - 1, nextChunk);\n-            }\n-        }\n-\n-        buf.cacheLen = outCount;\n-    }\n-\n-    \/\/ Adds the buffer to the front of the LRU list.\n-    private void addFirst(Buffer buf) {\n-        assert buf.next == null;\n-        assert buf.prev == null;\n-        assert buf.cache != null;\n-\n-        if (cacheHead.prev == cacheHead) {\n-            cacheHead.prev = buf;\n-        }\n-\n-        cacheHead.next.prev = buf;\n-        buf.next = cacheHead.next;\n-        buf.prev = cacheHead;\n-        cacheHead.next = buf;\n-    }\n-\n-    \/\/ Removes the buffer from the LRU list.\n-    private void remove(Buffer buf) {\n-        assert buf.prev != null;\n-        assert buf.next != null;\n-        assert buf.cache != null;\n-        assert cacheHead.prev != cacheHead;\n-\n-        buf.prev.next = buf.next;\n-        buf.next.prev = buf.prev;\n-        buf.next = null;\n-        buf.prev = null;\n-    }\n-\n-    \/\/ Represents a gzipped buffer. The gzipped hprof file consists of a list of these buffers.\n-    private static class Buffer {\n-        public byte[] cache;\n-        public int cacheLen;\n-        public final long fileOffset;\n-        public final long offset;\n-        public Buffer next;\n-        public Buffer prev;\n-\n-        public Buffer(long fileOffset, long offset) {\n-            this.cache = null;\n-            this.cacheLen = 0;\n-            this.fileOffset = fileOffset;\n-            this.offset = offset;\n-            this.next = null;\n-            this.prev = null;\n-        }\n-    }\n-\n-    \/\/ Compares chunks by file offset.\n-    private static class FileOffsetComparator implements Comparator<Buffer> {\n-\n-        @Override\n-        public int compare(Buffer x, Buffer y) {\n-            return Long.compare(x.fileOffset, y.fileOffset);\n-        }\n-    }\n-\n-    \/\/ Compares chunks by offset.\n-    private static class OffsetComparator implements Comparator<Buffer> {\n-\n-        @Override\n-        public int compare(Buffer x, Buffer y) {\n-            return Long.compare(x.offset, y.offset);\n-        }\n-    }\n-\n-    \/\/ Implements an InputStream for this object.\n-    private static class InputStreamImpl extends InputStream {\n-\n-        private long offset;\n-        private final GzipRandomAccess access;\n-\n-        public InputStreamImpl(long offset, GzipRandomAccess access) {\n-            this.offset = offset;\n-            this.access = access;\n-        }\n-\n-        @Override\n-        public synchronized int read(byte[] b, int off, int len) throws IOException {\n-            int read = access.read(offset, b, off, len);\n-\n-            if (read > 0) {\n-                this.offset += read;\n-            }\n-\n-            return read;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            byte[] b = new byte[1];\n-            int read = read(b, 0, 1);\n-\n-            if (read != 1) {\n-                return -1;\n-            }\n-\n-            return b[0] & 0xff;\n-        }\n-    }\n-\n-    \/\/ Implements a ReadBuffer for this object.\n-    public static class ReadBufferImpl implements ReadBuffer {\n-\n-        private final GzipRandomAccess access;\n-        private final byte[] tmp = new byte[8];\n-\n-        public ReadBufferImpl(GzipRandomAccess access) {\n-            this.access = access;\n-        }\n-\n-        private void readFully(long pos, int len) throws IOException {\n-            int left = len;\n-            int off = 0;\n-\n-            while (left > 0) {\n-                int read = access.read(pos, tmp, off, left);\n-\n-                if (read <= 0) {\n-                    throw new EOFException(\"Could not read at \" + pos);\n-                }\n-\n-                left -= read;\n-                off += read;\n-                pos += read;\n-            }\n-        }\n-\n-        private int readInt(int offset) {\n-            return (((tmp[offset + 0] & 0xff) << 24) | ((tmp[offset + 1] & 0xff) << 16) |\n-                     ((tmp[offset + 2] & 0xff) << 8) | (tmp[offset + 3] & 0xff));\n-        }\n-\n-        @Override\n-        public void close() throws Exception {\n-            access.close();\n-        }\n-\n-        @Override\n-        public char getChar(long pos) throws IOException {\n-            readFully(pos, 2);\n-            return (char) (((tmp[0] & 0xff) << 8) | (tmp[1] & 0xff));\n-        }\n-\n-        @Override\n-        public byte getByte(long pos) throws IOException {\n-            readFully(pos, 1);\n-            return tmp[0];\n-        }\n-\n-        @Override\n-        public short getShort(long pos) throws IOException {\n-            return (short) getChar(pos);\n-        }\n-\n-        @Override\n-        public int getInt(long pos) throws IOException {\n-            readFully(pos, 4);\n-            return readInt(0);\n-        }\n-\n-        @Override\n-        public long getLong(long pos) throws IOException {\n-            readFully(pos, 8);\n-            long i1 = readInt(0);\n-            int i2 = readInt(4);\n-\n-            return (i1 << 32) | (i2 & 0xffffffffl);\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/GzipRandomAccess.java","additions":0,"deletions":577,"binary":false,"changes":577,"status":"deleted"},{"patch":"@@ -87,1 +87,0 @@\n-        GzipRandomAccess access = null;\n@@ -97,1 +96,2 @@\n-            } else if ((access = GzipRandomAccess.getAccess(heapFile, 16)) != null) {\n+            } else if ((i >>> 8) == GZIP_HEADER_MAGIC) {\n+                \/\/ Possible gziped file, try decompress it and get the stack trace.\n@@ -99,2 +99,19 @@\n-                try (BufferedInputStream gzBis = new BufferedInputStream(access.asStream(0));\n-                     PositionDataInputStream pdin = new PositionDataInputStream(gzBis)) {\n+                String deCompressedFile = \"heapdump\" + System.currentTimeMillis() + \".hprof\";\n+                File out = new File(deCompressedFile);\n+                \/\/ Decompress to get dump file.\n+                try (FileInputStream heapFis = new FileInputStream(heapFile);\n+                     GZIPInputStream gis = new GZIPInputStream(heapFis);\n+                     FileOutputStream fos = new FileOutputStream(out)) {\n+                    byte[] buffer = new byte[1024 * 1024];\n+                    int len = 0;\n+                    while ((len = gis.read(buffer)) > 0) {\n+                        fos.write(buffer, 0, len);\n+                    }\n+                } catch (Exception e) {\n+                    out.delete();\n+                    throw new IOException(\"Cannot decompress the compressed hprof file\", e);\n+                }\n+                \/\/ Check dump data header and print stack trace.\n+                try (FileInputStream outFis = new FileInputStream(out);\n+                     BufferedInputStream outBis = new BufferedInputStream(outFis);\n+                     PositionDataInputStream pdin = new PositionDataInputStream(outBis)) {\n@@ -103,3 +120,3 @@\n-                        Reader r\n-                            = new HprofReader(access.asFileBuffer(), pdin, dumpNumber,\n-                                              callStack, debugLevel);\n+                        HprofReader r\n+                            = new HprofReader(deCompressedFile, pdin, dumpNumber,\n+                                              true, debugLevel);\n@@ -108,1 +125,1 @@\n-                        throw new IOException(\"Wrong magic number in gzipped file: \" + i);\n+                        throw new IOException(\"Unrecognized magic number found in decompressed data: \" + i);\n@@ -110,0 +127,2 @@\n+                } finally {\n+                    out.delete();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/Reader.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"}]}