{"files":[{"patch":"@@ -1456,1 +1456,0 @@\n-  k->eager_initialize(THREAD);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -714,19 +714,0 @@\n-void InstanceKlass::eager_initialize(Thread *thread) {\n-  if (!EagerInitialization) return;\n-\n-  if (this->is_not_initialized()) {\n-    \/\/ abort if the the class has a class initializer\n-    if (this->class_initializer() != NULL) return;\n-\n-    \/\/ abort if it is java.lang.Object (initialization is handled in genesis)\n-    Klass* super_klass = super();\n-    if (super_klass == NULL) return;\n-\n-    \/\/ abort if the super class should be initialized\n-    if (!InstanceKlass::cast(super_klass)->is_initialized()) return;\n-\n-    \/\/ call body to expose the this pointer\n-    eager_initialize_impl();\n-  }\n-}\n-\n@@ -767,32 +748,0 @@\n-void InstanceKlass::eager_initialize_impl() {\n-  EXCEPTION_MARK;\n-  HandleMark hm(THREAD);\n-  Handle h_init_lock(THREAD, init_lock());\n-  ObjectLocker ol(h_init_lock, THREAD);\n-\n-  \/\/ abort if someone beat us to the initialization\n-  if (!is_not_initialized()) return;  \/\/ note: not equivalent to is_initialized()\n-\n-  ClassState old_state = init_state();\n-  link_class_impl(THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-    \/\/ Abort if linking the class throws an exception.\n-\n-    \/\/ Use a test to avoid redundantly resetting the state if there's\n-    \/\/ no change.  Set_init_state() asserts that state changes make\n-    \/\/ progress, whereas here we might just be spinning in place.\n-    if (old_state != _init_state)\n-      set_init_state(old_state);\n-  } else {\n-    \/\/ linking successful, mark class as initialized\n-    set_init_state(fully_initialized);\n-    fence_and_clear_init_lock();\n-    \/\/ trace\n-    if (log_is_enabled(Info, class, init)) {\n-      ResourceMark rm(THREAD);\n-      log_info(class, init)(\"[Initialized %s without side effects]\", external_name());\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -577,3 +577,0 @@\n-  \/\/ set the class to initialized if no static initializer is present\n-  void eager_initialize(Thread *thread);\n-\n@@ -1182,1 +1179,0 @@\n-  void eager_initialize_impl                     ();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -976,3 +976,0 @@\n-  develop(bool, EagerInitialization, false,                                 \\\n-          \"Eagerly initialize classes if possible\")                         \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,13 +56,1 @@\n-        \/\/ (2)\n-        if (Platform.isDebugBuild()) {\n-            pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:class+init=info\",\n-                                                       \"-Xverify:all\",\n-                                                       \"-XX:+EagerInitialization\",\n-                                                       \"-Xmx128m\",\n-                                                       InnerClass.class.getName());\n-            out = new OutputAnalyzer(pb.start());\n-            out.shouldContain(\"[Initialized\").shouldContain(\"without side effects]\");\n-            out.shouldHaveExitValue(0);\n-        }\n-\n-        \/\/ (3) class+init should turn off.\n+        \/\/ (2) class+init should turn off.\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ClassInitializationTest.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}