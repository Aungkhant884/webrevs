{"files":[{"patch":"@@ -572,12 +572,0 @@\n-     * Nested tags are not permitted.\n-     *\/\n-    private List<DCTree> inlineContent() {\n-        return inlineContent(false);\n-    }\n-\n-    \/**\n-     * Read general text content of an inline tag, including HTML entities and elements.\n-     * Matching pairs of { } are skipped; the text is terminated by the first\n-     * unmatched }. It is an error if the beginning of the next tag is detected.\n-     *\n-     * @param allowNestedTags whether or not to allow nested tags\n@@ -586,1 +574,1 @@\n-    private List<DCTree> inlineContent(boolean allowNestedTags) {\n+    private List<DCTree> inlineContent() {\n@@ -623,1 +611,1 @@\n-                    if (ch == '@' && allowNestedTags) {\n+                    if (ch == '@') {\n@@ -1314,1 +1302,1 @@\n-                            description = inlineContent(true);\n+                            description = inlineContent();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -385,2 +385,2 @@\n-    private Content getInlineTagOutput(Element element, DocTree holder, DocTree tree, boolean isFirstSentence, boolean inSummary) {\n-        return getTagletWriterInstance(isFirstSentence, inSummary)\n+    private Content getInlineTagOutput(Element element, DocTree holder, DocTree tree, TagletWriterImpl.Context context) {\n+        return getTagletWriterInstance(context)\n@@ -403,2 +403,1 @@\n-     * @param isFirstSentence  true if we want to write the first sentence\n-     * @param inSummary  true if tags are to be added in a summary section\n+     * @param context  the enclosing context for the trees\n@@ -407,2 +406,2 @@\n-    public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {\n-        return new TagletWriterImpl(this, isFirstSentence, inSummary);\n+    public TagletWriter getTagletWriterInstance(TagletWriterImpl.Context context) {\n+        return new TagletWriterImpl(this, context);\n@@ -1019,1 +1018,1 @@\n-    public Content seeTagToContent(Element element, DocTree see) {\n+    public Content seeTagToContent(Element element, DocTree see, TagletWriterImpl.Context context) {\n@@ -1021,4 +1020,0 @@\n-        if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {\n-            return new ContentBuilder();\n-        }\n-\n@@ -1027,4 +1022,32 @@\n-        String seetext = replaceDocRootDir(removeTrailingSlash(utils.normalizeNewlines(ch.getText(see)).toString()));\n-        \/\/ Check if @see is an href or \"string\"\n-        if (seetext.startsWith(\"<\") || seetext.startsWith(\"\\\"\")) {\n-            return new RawHtml(seetext);\n+\n+        String seeText = utils.normalizeNewlines(ch.getText(see)).toString();\n+        List<? extends DocTree> label;\n+        switch (kind) {\n+            case LINK, LINK_PLAIN ->\n+                \/\/ {@link[plain] reference label...}\n+                label = ((LinkTree) see).getLabel();\n+\n+            case SEE -> {\n+                List<? extends DocTree> ref = ((SeeTree) see).getReference();\n+                assert !ref.isEmpty();\n+                switch (ref.get(0).getKind()) {\n+                    case TEXT -> {\n+                        \/\/ @see \"Reference\"\n+                        return new StringContent(seeText);\n+                    }\n+                    case START_ELEMENT -> {\n+                        \/\/ @see <a href=\"...\">...<\/a>\n+                        return new RawHtml(replaceDocRootDir(removeTrailingSlash(seeText)));\n+                    }\n+                    case REFERENCE -> {\n+                        \/\/ @see reference label...\n+                        label = ref.subList(1, ref.size());\n+                        break;\n+                    }\n+                    default ->\n+                        throw new IllegalStateException(ref.get(0).getKind().toString());\n+                }\n+            }\n+\n+            default ->\n+                throw new IllegalStateException(kind.toString());\n@@ -1032,0 +1055,1 @@\n+\n@@ -1033,1 +1057,2 @@\n-        Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));\n+        Content labelContent = plainOrCode(isLinkPlain,\n+                commentTagsToContent(see, element, label, context));\n@@ -1036,1 +1061,1 @@\n-        Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));\n+        Content text = plainOrCode(kind == LINK_PLAIN, new StringContent(removeTrailingSlash(seeText)));\n@@ -1048,1 +1073,1 @@\n-                return getModuleLink(refModule, label.isEmpty() ? text : label);\n+                return getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent);\n@@ -1054,2 +1079,2 @@\n-                if (label.isEmpty())\n-                    label = plainOrCode(isLinkPlain,\n+                if (labelContent.isEmpty())\n+                    labelContent = plainOrCode(isLinkPlain,\n@@ -1057,1 +1082,1 @@\n-                return getPackageLink(refPackage, label);\n+                return getPackageLink(refPackage, labelContent);\n@@ -1068,1 +1093,1 @@\n-                            (label.isEmpty() ? text : label));\n+                            (labelContent.isEmpty() ? text : labelContent));\n@@ -1074,2 +1099,2 @@\n-                            seetext);\n-                    return (label.isEmpty() ? text: label);\n+                            seeText);\n+                    return (labelContent.isEmpty() ? text: labelContent);\n@@ -1080,2 +1105,2 @@\n-            if (label.isEmpty()) {\n-                if (!refClass.getTypeParameters().isEmpty() && seetext.contains(\"<\")) {\n+            if (labelContent.isEmpty()) {\n+                if (!refClass.getTypeParameters().isEmpty() && seeText.contains(\"<\")) {\n@@ -1089,1 +1114,1 @@\n-                label = plainOrCode(isLinkPlain, new StringContent(utils.getSimpleName(refClass)));\n+                labelContent = plainOrCode(isLinkPlain, new StringContent(utils.getSimpleName(refClass)));\n@@ -1092,1 +1117,1 @@\n-                    .label(label));\n+                    .label(labelContent));\n@@ -1096,1 +1121,1 @@\n-            return (label.isEmpty() ? text: label);\n+            return (labelContent.isEmpty() ? text: labelContent);\n@@ -1127,1 +1152,1 @@\n-                        tagName, seetext);\n+                        tagName, seeText);\n@@ -1148,1 +1173,1 @@\n-                    refMem, (label.isEmpty() ? text: label), null, false);\n+                    refMem, (labelContent.isEmpty() ? text: labelContent), null, false);\n@@ -1360,1 +1385,23 @@\n-                                        boolean inSummary)\n+                                        boolean inSummary) {\n+        return commentTagsToContent(holderTag, element, trees,\n+                new TagletWriterImpl.Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to text strings, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param holderTag specific tag where comment resides\n+     * @param element   specific element where comment resides\n+     * @param trees     list of text trees and inline tag trees (often alternating)\n+     *                  present in the text of interest for this element\n+     * @param context   the enclosing context for the trees\n+     *\n+     * @return a Content object\n+     *\/\n+    public Content commentTagsToContent(DocTree holderTag,\n+                                        Element element,\n+                                        List<? extends DocTree> trees,\n+                                        TagletWriterImpl.Context context)\n@@ -1378,1 +1425,1 @@\n-            if (isFirstSentence) {\n+            if (context.isFirstSentence) {\n@@ -1476,2 +1523,1 @@\n-                    Content docRootContent = getInlineTagOutput(element, holderTag, node,\n-                            isFirstSentence, false);\n+                    Content docRootContent = getInlineTagOutput(element, holderTag, node, context);\n@@ -1509,2 +1555,1 @@\n-                    Content output = getInlineTagOutput(element, holderTag, node,\n-                            isFirstSentence, false);\n+                    Content output = getInlineTagOutput(element, holderTag, node, context);\n@@ -1513,1 +1558,1 @@\n-                    return (isFirstSentence && !output.isEmpty());\n+                    return (context.isFirstSentence && !output.isEmpty());\n@@ -1518,1 +1563,1 @@\n-                    Content output = getInlineTagOutput(element, holderTag, node, isFirstSentence, inSummary);\n+                    Content output = getInlineTagOutput(element, holderTag, node, context);\n@@ -1527,3 +1572,12 @@\n-                    \/\/ we need to pass the DocTreeImpl here, so ignore node\n-                    Content content = seeTagToContent(element, tag);\n-                    result.add(content);\n+                    var inTags = context.inTags;\n+                    if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n+                        messages.warning(ch.getDocTreePath(node), \"doclet.see.nested_link\", \"{@\" + node.getTagName() + \"}\");\n+                        Content label = commentTagsToContent(node, element, node.getLabel(), context);\n+                        if (label.isEmpty()) {\n+                            label = new StringContent(node.getReference().getSignature());\n+                        }\n+                        result.add(label);\n+                    } else {\n+                        Content content = seeTagToContent(element, node, context.within(node));\n+                        result.add(content);\n+                    }\n@@ -1545,2 +1599,1 @@\n-                    \/\/ we need to pass the DocTreeImpl here, so ignore node\n-                    result.add(seeTagToContent(element, tag));\n+                    result.add(seeTagToContent(element, node, context));\n@@ -1565,1 +1618,1 @@\n-                    Content output = getInlineTagOutput(element, holderTag, node, isFirstSentence, false);\n+                    Content output = getInlineTagOutput(element, holderTag, node, context);\n@@ -1572,1 +1625,1 @@\n-                    Content output = getInlineTagOutput(element, holderTag, node, isFirstSentence, inSummary);\n+                    Content output = getInlineTagOutput(element, holderTag, node, context);\n@@ -1584,1 +1637,1 @@\n-                    boolean stripTrailing = isFirstSentence && isLast;\n+                    boolean stripTrailing = context.isFirstSentence && isLast;\n@@ -1605,1 +1658,1 @@\n-                    Content output = getInlineTagOutput(element, holderTag, node, isFirstSentence, false);\n+                    Content output = getInlineTagOutput(element, holderTag, node, context);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":101,"deletions":48,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.EnumSet;\n@@ -29,0 +30,1 @@\n+import java.util.Set;\n@@ -80,0 +82,53 @@\n+    \/**\n+     * A class that provides the information about the enclosing context for\n+     * a series of {@code DocTree} nodes.\n+     * This context may be used to determine the content that should be generated from the tree nodes.\n+     *\/\n+    static class Context {\n+        \/**\n+         * Whether or not the trees are appearing in a context of just the first sentence,\n+         * such as in the summary table of the enclosing element.\n+         *\/\n+        final boolean isFirstSentence;\n+        \/**\n+         * Whether or not the trees are appearing in the \"summary\" section of the\n+         * page for a declaration.\n+         *\/\n+        final boolean inSummary;\n+        \/**\n+         * The set of enclosing kinds of tags.\n+         *\/\n+        final Set<DocTree.Kind> inTags;\n+\n+        \/**\n+         * Creates an outermost context, with no enclosing tags.\n+         *\n+         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n+         *                        first sentence and {@code false} otherwise\n+         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n+         *                        of the page for a declaration and {@code false} otherwise\n+         *\/\n+        Context(boolean isFirstSentence, boolean inSummary) {\n+            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n+        }\n+\n+        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n+            this.isFirstSentence = isFirstSentence;\n+            this.inSummary = inSummary;\n+            this.inTags = inTags;\n+        }\n+\n+        \/**\n+         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n+         * kinds of tags.\n+         *\n+         * @param tree the enclosing tree\n+         *\n+         * @return the new {@code Context}\n+         *\/\n+        Context within(DocTree tree) {\n+            var newInTags = EnumSet.copyOf(inTags);\n+            newInTags.add(tree.getKind());\n+            return new Context(isFirstSentence, inSummary, newInTags);\n+        }\n+    }\n@@ -85,1 +140,0 @@\n-    private final boolean inSummary;\n@@ -88,0 +142,1 @@\n+    private final Context context;\n@@ -110,1 +165,11 @@\n-        super(isFirstSentence);\n+        this(htmlWriter, new Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n+     * @param context    the enclosing context for any tags\n+     *\/\n+    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n+        super(context.isFirstSentence);\n@@ -112,1 +177,1 @@\n-        this.inSummary = inSummary;\n+        this.context = context;\n@@ -142,1 +207,0 @@\n-        String desc = ch.getText(tag.getDescription());\n@@ -144,1 +208,10 @@\n-        return createAnchorAndSearchIndex(element, tagText, desc, tag);\n+        Content desc = htmlWriter.commentTagsToContent(tag, element, tag.getDescription(), context.within(tag));\n+        String descText = extractText(desc);\n+\n+        return createAnchorAndSearchIndex(element, tagText, descText, tag);\n+    }\n+\n+    \/\/ ugly but simple;\n+    \/\/ alternatives would be to walk the Content tree, or to add new functionality to Content\n+    private String extractText(Content c) {\n+        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n@@ -225,1 +298,1 @@\n-        body.add(htmlWriter.commentTagsToContent(paramTag, element, description, false, inSummary));\n+        body.add(htmlWriter.commentTagsToContent(paramTag, element, description, context.within(paramTag)));\n@@ -233,1 +306,1 @@\n-        Content content = htmlWriter.commentTagsToContent(returnTag, element, desc , false, inSummary);\n+        Content content = htmlWriter.commentTagsToContent(returnTag, element, desc , context.within(returnTag));\n@@ -244,1 +317,1 @@\n-            body.add(htmlWriter.seeTagToContent(holder, dt));\n+            body.add(htmlWriter.seeTagToContent(holder, dt, context.within(dt)));\n@@ -295,1 +368,1 @@\n-            body.add(htmlWriter.commentTagsToContent(simpleTag, element, bodyTags, false, inSummary));\n+            body.add(htmlWriter.commentTagsToContent(simpleTag, element, bodyTags, context.within(simpleTag)));\n@@ -336,1 +409,1 @@\n-        Content desc = htmlWriter.commentTagsToContent(throwsTag, element, description, false, inSummary);\n+        Content desc = htmlWriter.commentTagsToContent(throwsTag, element, description, context.within(throwsTag));\n@@ -376,1 +449,1 @@\n-                tags, isFirstSentence, inSummary);\n+                tags, holderTag == null ? context : context.within(holderTag));\n@@ -392,1 +465,1 @@\n-        if (isFirstSentence && inSummary) {\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":85,"deletions":12,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+doclet.see.nested_link=Tag {0}: nested link\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-        return writer.commentTagsToOutput(holder, ((SummaryTree)tag).getSummary());\n+        return writer.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n+                writer.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SummaryTaglet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -147,0 +147,3 @@\n+    private boolean inIndex;\n+    private boolean inLink;\n+    private boolean inSummary;\n@@ -786,0 +789,3 @@\n+        if (inIndex) {\n+            env.messages.warning(HTML, tree, \"dc.tag.nested.tag\", \"@\" + tree.getTagName());\n+        }\n@@ -793,1 +799,7 @@\n-        return super.visitIndex(tree, ignore);\n+        boolean prevInIndex = inIndex;\n+        try {\n+            inIndex = true;\n+            return super.visitIndex(tree, ignore);\n+        } finally {\n+            inIndex = prevInIndex;\n+        }\n@@ -807,0 +819,4 @@\n+        if (inLink) {\n+            env.messages.warning(HTML, tree, \"dc.tag.nested.tag\", \"@\" + tree.getTagName());\n+        }\n+        boolean prevInLink = inLink;\n@@ -812,0 +828,1 @@\n+            inLink = true;\n@@ -815,0 +832,1 @@\n+            inLink = prevInLink;\n@@ -944,1 +962,1 @@\n-    public Void visitSummary(SummaryTree node, Void aVoid) {\n+    public Void visitSummary(SummaryTree tree, Void aVoid) {\n@@ -946,1 +964,4 @@\n-        int idx = env.currDocComment.getFullBody().indexOf(node);\n+        if (inSummary) {\n+            env.messages.warning(HTML, tree, \"dc.tag.nested.tag\", \"@\" + tree.getTagName());\n+        }\n+        int idx = env.currDocComment.getFullBody().indexOf(tree);\n@@ -950,1 +971,8 @@\n-            env.messages.warning(SYNTAX, node, \"dc.invalid.summary\", node.getTagName());\n+            env.messages.warning(SYNTAX, tree, \"dc.invalid.summary\", tree.getTagName());\n+        }\n+        boolean prevInSummary = inSummary;\n+        try {\n+            inSummary = true;\n+            return super.visitSummary(tree, aVoid);\n+        } finally {\n+            inSummary = prevInSummary;\n@@ -952,1 +980,0 @@\n-        return super.visitSummary(node, aVoid);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+dc.tag.nested.tag=nested tag: {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,3 +128,3 @@\n-                \"<div class=\\\"block\\\"><code>java.util.Foo<String><\/code>\\n\"\n-                + \" Baz<Object>\\n\"\n-                + \" <code>#b(List<Integer>)<\/code><\/div>\",\n+                \"<div class=\\\"block\\\"><code>java.util.Foo&lt;String&gt;<\/code>\\n\"\n+                + \" Baz&lt;Object&gt;\\n\"\n+                + \" <code>#b(List&lt;Integer&gt;)<\/code><\/div>\",\n@@ -134,3 +134,3 @@\n-                + \"<dd><code>java.util.List<Bar><\/code>, \\n\"\n-                + \"<code>Baz<Object, String><\/code>, \\n\"\n-                + \"<code>B#b(List<Baz>)<\/code><\/dd>\\n<\/dl>\");\n+                + \"<dd><code>java.util.List&lt;Bar&gt;<\/code>, \\n\"\n+                + \"<code>Baz&lt;Object, String&gt;<\/code>, \\n\"\n+                + \"<code>B#b(List&lt;Baz&gt;)<\/code><\/dd>\\n<\/dl>\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testGenericTypeLink\/TestGenericTypeLink.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8257925\n+ * @summary  enable more support for nested inline tags\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.*\n+ * @run main TestNestedIndexTag\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import static javadoc.tester.JavadocTester.Output.OUT;\n+\n+public class TestNestedIndexTag extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestNestedIndexTag tester = new TestNestedIndexTag();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())});\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    enum DocLintKind {\n+        DOCLINT(\"-Xdoclint\"),\n+        NO_DOCLINT(\"-Xdoclint:none\");\n+        final String option;\n+        DocLintKind(String option) {\n+            this.option = option;\n+        }\n+    }\n+\n+    @Test\n+    public void testIndexIndexDocLint(Path base) throws IOException {\n+        testIndexIndex(base, DocLintKind.DOCLINT);\n+    }\n+\n+    @Test\n+    public void testIndexIndexNoDocLint(Path base) throws IOException {\n+        testIndexIndex(base, DocLintKind.NO_DOCLINT);\n+    }\n+\n+\n+    public void testIndexIndex(Path base, DocLintKind dlk) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** First sentence. {@index abc ABC {@index def DEF} GHI} *\/\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                dlk.option,\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"tag-search-index.js\", false,\n+                \"{@index\");\n+        checkOutput(Output.OUT, dlk == DocLintKind.DOCLINT,\n+                \"C.java:2: warning: nested tag: @index\");\n+    }\n+\n+    @Test\n+    public void testIndexValue(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** First sentence. {@index abc ABC {@value Short#MAX_VALUE} DEF} *\/\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"tag-search-index.js\", false,\n+                \"{@index\");\n+        checkOutput(\"tag-search-index.js\", true,\n+                \"ABC 32767 DEF\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNestedInlineTags\/TestNestedIndexTag.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8257925\n+ * @summary  enable more support for nested inline tags\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.*\n+ * @run main TestNestedLinkTag\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Locale;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestNestedLinkTag extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestNestedLinkTag tester = new TestNestedLinkTag();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())});\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    enum TagKind {\n+        LINK,\n+        LINKPLAIN;\n+        final String tag;\n+        TagKind() {\n+            tag = name().toLowerCase(Locale.ROOT);\n+        }\n+    }\n+\n+    enum DocLintKind {\n+        DOCLINT(\"-Xdoclint\"),\n+        NO_DOCLINT(\"-Xdoclint:none\");\n+        final String option;\n+        DocLintKind(String option) {\n+            this.option = option;\n+        }\n+    }\n+\n+    @Test\n+    public void testLinkLinkCombo(Path base) throws IOException {\n+        for (TagKind outer : TagKind.values()) {\n+            for (TagKind inner : TagKind.values()) {\n+                for (DocLintKind dl : DocLintKind.values()) {\n+                    Path dir = Files.createDirectories((base.resolve(outer + \"-\" + inner + \"-\" + dl)));\n+                    testLinkLinkCombo(dir, outer, inner, dl);\n+                }\n+            }\n+        }\n+    }\n+\n+    void testLinkLinkCombo(Path base, TagKind outer, TagKind inner, DocLintKind dlk) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** First sentence. {@#OUTER# #m1() ABC {@#INNER# #m2() DEF} GHI} *\/\n+                    public class C {\n+                        \/** Comment m1. *\/\n+                        public void m1() { }\n+                        \/** Comment m2. *\/\n+                        public void m2() { }\n+                    }\n+                    \"\"\"\n+                    .replaceAll(\"#OUTER#\", outer.tag)\n+                    .replaceAll(\"#INNER#\", inner.tag));\n+\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                dlk.option,\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@link\",\n+                \"ABC <a href=\\\"#m2()\\\"\");\n+        checkOutput(\"p\/C.html\", true,\n+                \"ABC DEF GHI\");\n+        checkOutput(Output.OUT, dlk == DocLintKind.DOCLINT,\n+                \"C.java:2: warning: nested tag: @link\");\n+    }\n+\n+    @Test\n+    public void testLinkValue(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** First sentence. {@link #m1() ABC {@value Short#MAX_VALUE} DEF} *\/\n+                    public class C {\n+                        \/** Comment. *\/\n+                        public void m1() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@value\");\n+        checkOutput(\"p\/C.html\", true,\n+                \"ABC 32767 DEF\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNestedInlineTags\/TestNestedLinkTag.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8257925\n+ * @summary  enable more support for nested inline tags\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.*\n+ * @run main TestNestedReturnTag\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestNestedReturnTag extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestNestedReturnTag tester = new TestNestedReturnTag();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())});\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    enum DocLintKind {\n+        DOCLINT(\"-Xdoclint\"),\n+        NO_DOCLINT(\"-Xdoclint:none\");\n+        final String option;\n+        DocLintKind(String option) {\n+            this.option = option;\n+        }\n+    }\n+\n+    @Test\n+    public void testReturnReturnDocLint(Path base) throws IOException {\n+        testReturnReturn(base, DocLintKind.DOCLINT);\n+    }\n+\n+    @Test\n+    public void testReturnReturnNoDocLint(Path base) throws IOException {\n+        testReturnReturn(base, DocLintKind.NO_DOCLINT);\n+    }\n+\n+    void testReturnReturn(Path base, DocLintKind dlk) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/** {@return abc ABC {@return def DEF} GHI} *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                dlk.option,\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@return\");\n+        checkOutput(Output.OUT, dlk == DocLintKind.DOCLINT,\n+                \"C.java:4: warning: @return has already been specified\");\n+    }\n+\n+    @Test\n+    public void testReturnValue(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** Comment. *\/\n+                    public class C {\n+                        \/** {@return abc ABC {@value Short#MAX_VALUE} DEF} *\/\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@value\");\n+        checkOutput(\"p\/C.html\", true,\n+                \"ABC 32767 DEF\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNestedInlineTags\/TestNestedReturnTag.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8257925\n+ * @summary  enable more support for nested inline tags\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.*\n+ * @run main TestNestedSummaryTag\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestNestedSummaryTag extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestNestedSummaryTag tester = new TestNestedSummaryTag();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName())});\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    enum DocLintKind {\n+        DOCLINT(\"-Xdoclint\"),\n+        NO_DOCLINT(\"-Xdoclint:none\");\n+        final String option;\n+        DocLintKind(String option) {\n+            this.option = option;\n+        }\n+    }\n+\n+    @Test\n+    public void testSummarySummaryDocLint(Path base) throws IOException {\n+        testSummarySummary(base, DocLintKind.DOCLINT);\n+    }\n+\n+    @Test\n+    public void testSummarySummaryNoDocLint(Path base) throws IOException {\n+        testSummarySummary(base, DocLintKind.NO_DOCLINT);\n+    }\n+\n+    void testSummarySummary(Path base, DocLintKind dlk) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** {@summary abc ABC {@summary def DEF} GHI} *\/\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                dlk.option,\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@summary\");\n+        checkOutput(Output.OUT, dlk == DocLintKind.DOCLINT,\n+                \"C.java:2: warning: nested tag: @summary\");\n+    }\n+\n+    @Test\n+    public void testSummaryValue(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/** {@summary abc ABC {@value Short#MAX_VALUE} DEF} *\/\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@value\");\n+        checkOutput(\"p\/C.html\", true,\n+                \"ABC 32767 DEF\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNestedInlineTags\/TestNestedSummaryTag.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -84,1 +84,1 @@\n-                    <code>Foo<String><\/code><\/dd>\n+                    <code>Foo&lt;String&gt;<\/code><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                <div class=\"block\"> First sentence <\/div>\n+                <div class=\"block\"> First sentence<\/div>\n@@ -76,1 +76,1 @@\n-                <div class=\"block\">First sentence <\/div>\n+                <div class=\"block\">First sentence<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSummaryTag\/TestSummaryTag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,2 +168,8 @@\n-      description: 1\n-        Text[TEXT, pos:20, \"{@see_xyz}\"_def]\n+      description: 3\n+        Text[TEXT, pos:20, \"]\n+        UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:21\n+          tag:see\n+          content: 1\n+            Text[TEXT, pos:27, xyz]\n+        ]\n+        Text[TEXT, pos:31, \"_def]\n","filename":"test\/langtools\/tools\/javac\/doctree\/IndexTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}