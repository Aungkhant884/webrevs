{"files":[{"patch":"@@ -85,4 +85,0 @@\n- * * Base is the base class for the list.  This is typically\n- * used to specify the allocation class, such as CHeapObj<>.  The default\n- * is void, indicating the list is not derived from an allocation class.\n- *\n@@ -112,1 +108,0 @@\n- * <code>\n@@ -128,1 +123,0 @@\n- * <\/code>\n@@ -133,1 +127,0 @@\n- * <code>\n@@ -150,1 +143,0 @@\n- * <\/code>\n@@ -154,2 +146,1 @@\n-         bool has_size = false,\n-         typename Base = void>\n+         bool has_size = false>\n@@ -215,4 +206,1 @@\n-  template<typename T,\n-           IntrusiveListEntryAccessor<T>,\n-           bool,\n-           typename>\n+  template<typename T, IntrusiveListEntryAccessor<T>, bool>\n@@ -259,3 +247,0 @@\n-  class NoAllocationBase {};\n-  template<typename Base> struct ResolveBase;\n-\n@@ -263,1 +248,1 @@\n-  template<bool has_size, typename Base> class SizeBase;\n+  template<bool has_size> class SizeBase;\n@@ -319,14 +304,0 @@\n-\/\/ Metafunction for resolving the Base template parameter for\n-\/\/ IntrusiveList, handling the default void type and transforming it\n-\/\/ into the internal NoAllocationBase.\n-\n-template<typename Base>\n-struct IntrusiveListImpl::ResolveBase {\n-  using type = Base;\n-};\n-\n-template<>\n-struct IntrusiveListImpl::ResolveBase<void> {\n-  using type = NoAllocationBase;\n-};\n-\n@@ -334,2 +305,1 @@\n-\/\/ or not providing constant-time size.  Base is the corresponding template\n-\/\/ parameter from IntrusiveList.\n+\/\/ or not providing constant-time size.\n@@ -337,2 +307,2 @@\n-template<bool has_size, typename Base>\n-class IntrusiveListImpl::SizeBase : public ResolveBase<Base>::type {\n+template<bool has_size>\n+class IntrusiveListImpl::SizeBase {\n@@ -347,2 +317,2 @@\n-template<typename Base>\n-class IntrusiveListImpl::SizeBase<true, Base> : public ResolveBase<Base>::type {\n+template<>\n+class IntrusiveListImpl::SizeBase<true> {\n@@ -377,3 +347,2 @@\n-         bool has_size,\n-         typename Base>\n-struct IntrusiveListImpl::IsListType<IntrusiveList<T, accessor, has_size, Base>>\n+         bool has_size>\n+struct IntrusiveListImpl::IsListType<IntrusiveList<T, accessor, has_size>>\n@@ -816,3 +785,2 @@\n-         bool has_size,\n-         typename Base>\n-class IntrusiveList : public IntrusiveListImpl::SizeBase<has_size, Base> {\n+         bool has_size>\n+class IntrusiveList : public IntrusiveListImpl::SizeBase<has_size> {\n@@ -820,1 +788,1 @@\n-  template<typename U, IntrusiveListEntryAccessor<U>, bool, typename>\n+  template<typename U, IntrusiveListEntryAccessor<U>, bool>\n@@ -829,1 +797,1 @@\n-  using Super = Impl::SizeBase<has_size, Base>;\n+  using Super = Impl::SizeBase<has_size>;\n@@ -839,2 +807,2 @@\n-  \/\/ size support and the base types of the lists don't affect whether\n-  \/\/ splicing is permitted.\n+  \/\/ size support for either of the lists doesn't affect whether splicing is\n+  \/\/ permitted.\n@@ -982,28 +950,0 @@\n-  \/**\n-   * Returns a [const_]reference to the n'th element of the list.\n-   *\n-   * precondition: n < length()\n-   * complexity: O(length())\n-   *\/\n-  reference operator[](size_type n) {\n-    return nth_element(begin(), end(), n);\n-  }\n-\n-  const_reference operator[](size_type n) const {\n-    return nth_element(cbegin(), cend(), n);\n-  }\n-\n-private:\n-\n-  \/\/ Implementation of operator[].\n-  template<typename Iterator>\n-  static typename Iterator::reference\n-  nth_element(Iterator it, Iterator end, size_type n) {\n-    for (size_type index = 0; true; ++it, ++index) {\n-      assert(it != end, \"index out of bounds: %ju\", uintmax_t(n));\n-      if (index == n) return *it;\n-    }\n-  }\n-\n-public:\n-\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":16,"deletions":76,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-using CHeapList1 = IntrusiveList<Value, &Value::entry1, false, CHeapObj<mtInternal>>;\n@@ -229,10 +228,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ CHeapObj List construction\n-\n-TEST(IntrusiveListBasics, construct_CHeapObj) {\n-  CHeapList1* list1 = new CHeapList1();\n-  EXPECT_TRUE(list1->empty());\n-  EXPECT_EQ(0u, list1->length());\n-  delete list1;\n-}\n-\n@@ -241,1 +230,1 @@\n-\/\/ front(), back(), operator[]\n+\/\/ front(), back()\n@@ -305,3 +294,0 @@\n-  for (size_t i = 0; i < nvalues; ++i) {\n-    EXPECT_EQ(i, list2[i].value());\n-  }\n@@ -332,3 +318,0 @@\n-  for (size_t i = 0; i < nvalues; ++i) {\n-    EXPECT_EQ(i, list2[i].value());\n-  }\n@@ -1278,34 +1261,0 @@\n-\/\/ Verify we can splice between lists with different Base template paramters.\n-TEST_F(IntrusiveListTestSplice, splice_different_base) {\n-  CHeapList1 cheap;\n-  size_t a_size = list_a.length();\n-  size_t b_size = list_b.length();\n-  List1::iterator a_begin = list_a.begin();\n-  List1::iterator a_penultimate = --list_a.end();\n-\n-  List1::iterator sresult = cheap.splice(cheap.begin(), list_a);\n-  EXPECT_EQ(cheap.begin(), sresult);\n-  EXPECT_EQ(a_size, cheap.length());\n-  EXPECT_TRUE(list_a.empty());\n-  EXPECT_EQ(a_begin, cheap.cbegin());\n-  EXPECT_EQ(a_penultimate, --cheap.cend());\n-  {\n-    SCOPED_TRACE(\"check transfer to cheap\");\n-    check(cheap.cbegin(), cheap.cend(), 0);\n-  }\n-\n-  List1::iterator b_begin = list_b.begin();\n-  list_b.splice(b_begin, cheap);\n-  EXPECT_EQ(a_size + b_size, list_b.length());\n-  EXPECT_TRUE(cheap.empty());\n-  EXPECT_EQ(a_begin, list_b.cbegin());\n-  {\n-    SCOPED_TRACE(\"check cheap (was a) prepend to b\");\n-    check(list_b.cbegin(), b_begin, 0);\n-  }\n-  {\n-    SCOPED_TRACE(\"check old b\");\n-    check(b_begin, list_b.cend(), group_size);\n-  }\n-}\n-\n@@ -1572,1 +1521,0 @@\n-  typedef IntrusiveList<Value, &Value::entry1, true, CHeapObj<mtInternal> > CHeapListWithSize;\n@@ -1574,1 +1522,1 @@\n-  virtual void SetUp() {\n+  void SetUp() override {\n@@ -1579,1 +1527,1 @@\n-  virtual void TearDown() {\n+  void TearDown() override {\n","filename":"test\/hotspot\/gtest\/utilities\/test_intrusiveList.cpp","additions":3,"deletions":55,"binary":false,"changes":58,"status":"modified"}]}