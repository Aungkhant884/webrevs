{"files":[{"patch":"@@ -629,1 +629,1 @@\n-  \/\/ Implicit conversion from non-const to const element type.\n+  \/** Implicit conversion from non-const to const element type. *\/\n@@ -812,1 +812,1 @@\n-                       std::is_convertible<typename Other::iterator, iterator>>::value;\n+                       HasConvertibleIterator<Other, iterator>>::value;\n@@ -815,0 +815,9 @@\n+  \/\/ Helper for can_splice_from, delaying instantiation that includes\n+  \/\/ \"Other::iterator\" until Other is known to be a List type.\n+  template<typename Other, typename Iterator>\n+  struct HasConvertibleIterator\n+    : public BoolConstant<std::is_convertible<typename Other::iterator, Iterator>::value>\n+  {};\n+\n+  \/\/ Swapping can be thought of as bi-directional slicing (see\n+  \/\/ can_splice_from).  So Other::iterator must be the same as iterator.\n@@ -818,1 +827,1 @@\n-                       std::is_same<typename Other::iterator, iterator>>::value;\n+                       HasSameIterator<Other, iterator>>::value;\n@@ -821,0 +830,7 @@\n+  \/\/ Helper for can_swap, delaying instantiation that includes\n+  \/\/ \"Other::iterator\" until Other is known to be a List type.\n+  template<typename Other, typename Iterator>\n+  struct HasSameIterator\n+    : public BoolConstant<std::is_same<typename Other::iterator, Iterator>::value>\n+  {};\n+\n@@ -1232,0 +1248,12 @@\n+  \/\/ The use of SFINAE with splice() and swap() is done for two reasons.\n+  \/\/\n+  \/\/ It provides better compile-time error messages for certain kinds of usage\n+  \/\/ mistakes.  For example, if a splice from_list is not actually a list, or\n+  \/\/ a list with a different get_entry function, we get some kind of \"no\n+  \/\/ applicable function\" failure at the call site, rather than some obscure\n+  \/\/ access failure deep inside the implementation of the operation.\n+  \/\/\n+  \/\/ It ensures const-correctness at the API boundary, permitting the\n+  \/\/ implementation to be simpler by decaying to const iterators and\n+  \/\/ references in various places.\n+\n@@ -1334,1 +1362,1 @@\n-  template<typename FromList, ENABLE_IF(Impl::IsListType<FromList>::value)>\n+  template<typename FromList, ENABLE_IF(can_splice_from<FromList>())>\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1368,0 +1368,3 @@\n+\n+  \/\/ Some invalid uses to allow one to examine the compiler errors.\n+\n@@ -1372,0 +1375,6 @@\n+\n+  \/\/ This doesn't compile either, as expected.  Splicing from a non-list.\n+  \/\/ class Foo {};\n+  \/\/ Foo foo{};\n+  \/\/ clist.splice(clist.end(), foo);\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_intrusiveList.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}