{"files":[{"patch":"@@ -57,1 +57,1 @@\n-const IntrusiveListImpl* IntrusiveListImpl::entry_list(const Entry* entry) {\n+const IntrusiveListImpl* IntrusiveListImpl::entry_list(const Entry& entry) {\n@@ -59,3 +59,3 @@\n-  if (entry->_list == nullptr) {\n-    assert(entry->_next == nullptr, \"invariant\");\n-    assert(entry->_prev == nullptr, \"invariant\");\n+  if (entry._list == nullptr) {\n+    assert(entry._next == nullptr, \"invariant\");\n+    assert(entry._prev == nullptr, \"invariant\");\n@@ -63,2 +63,2 @@\n-    assert(entry->_next != nullptr, \"invariant\");\n-    assert(entry->_prev != nullptr, \"invariant\");\n+    assert(entry._next != nullptr, \"invariant\");\n+    assert(entry._prev != nullptr, \"invariant\");\n@@ -66,1 +66,1 @@\n-  return entry->_list;\n+  return entry._list;\n@@ -69,2 +69,2 @@\n-void IntrusiveListImpl::set_entry_list(const Entry* entry, IntrusiveListImpl* list) {\n-  entry->_list = list;\n+void IntrusiveListImpl::set_entry_list(const Entry& entry, IntrusiveListImpl* list) {\n+  entry._list = list;\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,9 @@\n+\/**\n+ * The type of a function for accessing the list entry of an IntrusiveList's\n+ * element type T.  Such a function takes a reference to const T and returns a\n+ * reference to const IntrusiveListEntry.\n+ *\/\n+template<typename T>\n+using IntrusiveListEntryAccessor =\n+  const IntrusiveListEntry& (*)(std::add_const_t<T>&);\n+\n@@ -68,2 +77,2 @@\n- * * entry_member is a pointer to class member referring to the\n- * IntrusiveListEntry subobject of T used by this list.\n+ * * get_entry is a function of type IntrusiveListEntryAccessor<T> used\n+ * for accessing the IntrusiveListEntry subobject of T used by this list.\n@@ -101,1 +110,0 @@\n- * public:\n@@ -105,0 +113,6 @@\n+ * public:\n+ *   ...\n+ *   static const IntrusiveListEntry& get_entry(const MyClass& v) {\n+ *     return v._entry;\n+ *   }\n+ *   ...\n@@ -108,1 +122,1 @@\n- *   IntrusiveList<MyClass, &MyClass::_entry> mylist;\n+ *   IntrusiveList<MyClass, &MyClass::get_entry> mylist;\n@@ -112,1 +126,1 @@\n- * Alternatively, the scope of the entry member can be limited, with a\n+ * Alternatively, the scope of the entry accessor can be limited, with a\n@@ -119,0 +133,3 @@\n+ *   static const IntrusiveListEntry& get_entry(const MyClass& v) {\n+ *     return v._entry;\n+ *   }\n@@ -122,1 +139,1 @@\n- *   using MyList = IntrusiveList<MyClass, &MyClass::_entry>;\n+ *   usnig MyList = IntrusiveList<MyClass, &get_entry>;\n@@ -132,1 +149,1 @@\n-         IntrusiveListEntry T::*entry_member,\n+         IntrusiveListEntryAccessor<T> entry_accessor,\n@@ -193,1 +210,5 @@\n-  template<typename T, Entry T::*, bool, typename> friend class IntrusiveList;\n+  template<typename T,\n+           IntrusiveListEntryAccessor<T>,\n+           bool,\n+           typename>\n+  friend class IntrusiveList;\n@@ -227,4 +248,4 @@\n-  static void detach(const Entry* entry) {\n-    entry->_prev = nullptr;\n-    entry->_next = nullptr;\n-    DEBUG_ONLY(entry->_list = nullptr;)\n+  static void detach(const Entry& entry) {\n+    entry._prev = nullptr;\n+    entry._next = nullptr;\n+    DEBUG_ONLY(entry._list = nullptr;)\n@@ -242,1 +263,1 @@\n-  template<typename T, Entry T::*entry_member>\n+  template<typename T>\n@@ -255,4 +276,0 @@\n-\n-    static const Entry* get_entry(const_reference value) {\n-      return &(value.*entry_member);\n-    }\n@@ -272,1 +289,1 @@\n-           Entry T::*entry_member,\n+           IntrusiveListEntryAccessor<T> entry_accessor,\n@@ -282,0 +299,2 @@\n+  template<typename Iterator> struct EntryAccess;\n+\n@@ -289,1 +308,1 @@\n-  static const IntrusiveListImpl* entry_list(const Entry* entry);\n+  static const IntrusiveListImpl* entry_list(const Entry& entry);\n@@ -291,1 +310,1 @@\n-  static void set_entry_list(const Entry* entry, IntrusiveListImpl* list);\n+  static void set_entry_list(const Entry& entry, IntrusiveListImpl* list);\n@@ -339,0 +358,1 @@\n+\/\/ Destructure iterator type to be provide calling the entry accessor.\n@@ -340,6 +360,10 @@\n-         IntrusiveListEntry T::*entry_member,\n-         bool has_size,\n-         typename Base>\n-struct IntrusiveListImpl::IsListType<IntrusiveList<T, entry_member, has_size, Base>>\n-  : public std::true_type\n-{};\n+         IntrusiveListEntryAccessor<T> accessor,\n+         bool is_forward>\n+struct IntrusiveListImpl::EntryAccess<\n+  IntrusiveListImpl::IteratorImpl<T, accessor, is_forward>>\n+{\n+  using const_reference = std::add_lvalue_reference_t<std::add_const_t<T>>;\n+  static const Entry& get_entry(const_reference v) {\n+    return accessor(v);\n+  }\n+};\n@@ -347,7 +371,0 @@\n-\/\/ With MSVC the above specialization doesn't match if T is const-qualified\n-\/\/ but the entry member's class type isn't (which it seemingly can't be, since\n-\/\/ the syntax for pointer-to-data-member doesn't support it).  So we need this\n-\/\/ additional specialization for MSVC.  gcc and clang don't need this.  This\n-\/\/ seems likely a compiler bug, probably(?) in MSVC, but relevant standardese\n-\/\/ has so far eluded me.\n-#if defined(TARGET_COMPILER_visCPP)\n@@ -355,1 +372,1 @@\n-         IntrusiveListEntry T::*entry_member,\n+         IntrusiveListEntryAccessor<T> accessor,\n@@ -358,1 +375,1 @@\n-struct IntrusiveListImpl::IsListType<IntrusiveList<const T, entry_member, has_size, Base>>\n+struct IntrusiveListImpl::IsListType<IntrusiveList<T, accessor, has_size, Base>>\n@@ -361,1 +378,0 @@\n-#endif \/\/ TARGET_COMPILER_visCPP\n@@ -433,1 +449,1 @@\n-  static const Entry* resolve_to_entry(Iterator i) {\n+  static const Entry& resolve_to_entry(Iterator i) {\n@@ -437,1 +453,1 @@\n-      return remove_tag_from_root_entry(encoded);\n+      return *(remove_tag_from_root_entry(encoded));\n@@ -439,1 +455,1 @@\n-      return ListTraits::get_entry(dereference_element_ptr(encoded));\n+      return get_entry(dereference_element_ptr(encoded));\n@@ -449,1 +465,1 @@\n-    return Iterator(resolve_to_entry(i)->_next);\n+    return Iterator(resolve_to_entry(i)._next);\n@@ -453,1 +469,1 @@\n-    return Iterator(resolve_to_entry(i)->_prev);\n+    return Iterator(resolve_to_entry(i)._prev);\n@@ -457,1 +473,1 @@\n-    return Iterator(ListTraits::get_entry(value)->_next);\n+    return Iterator(get_entry(value)._next);\n@@ -461,1 +477,1 @@\n-    return Iterator(ListTraits::get_entry(value)->_prev);\n+    return Iterator(get_entry(value)._prev);\n@@ -465,2 +481,2 @@\n-    ListTraits::get_entry(prev)->_next = encoded_value(next);\n-    resolve_to_entry(next)->_prev = make_encoded_value(prev);\n+    get_entry(prev)._next = encoded_value(next);\n+    resolve_to_entry(next)._prev = make_encoded_value(prev);\n@@ -470,2 +486,2 @@\n-    resolve_to_entry(prev)->_next = make_encoded_value(next);\n-    ListTraits::get_entry(next)->_prev = encoded_value(prev);\n+    resolve_to_entry(prev)._next = make_encoded_value(next);\n+    get_entry(next)._prev = encoded_value(prev);\n@@ -475,2 +491,2 @@\n-    resolve_to_entry(prev)->_next = encoded_value(next);\n-    resolve_to_entry(next)->_prev = encoded_value(prev);\n+    resolve_to_entry(prev)._next = encoded_value(next);\n+    resolve_to_entry(next)._prev = encoded_value(prev);\n@@ -492,0 +508,4 @@\n+  static const Entry& get_entry(const_reference v) {\n+    return EntryAccess<Iterator>::get_entry(v);\n+  }\n+\n@@ -589,1 +609,1 @@\n-         IntrusiveListEntry T::*entry_member,\n+         IntrusiveListEntryAccessor<T> get_entry,\n@@ -598,1 +618,1 @@\n-  using ListTraits = Impl::ListTraits<T, entry_member>;\n+  using ListTraits = Impl::ListTraits<T>;\n@@ -607,1 +627,1 @@\n-    using NonConst = IteratorImpl<std::remove_const_t<T>, entry_member, _is_forward>;\n+    using NonConst = IteratorImpl<std::remove_const_t<T>, get_entry, _is_forward>;\n@@ -789,1 +809,1 @@\n-         IntrusiveListEntry T::*entry_member,\n+         IntrusiveListEntryAccessor<T> get_entry,\n@@ -794,1 +814,1 @@\n-  template<typename U, IntrusiveListEntry U::*, bool, typename>\n+  template<typename U, IntrusiveListEntryAccessor<U>, bool, typename>\n@@ -802,1 +822,1 @@\n-  using ListTraits = Impl::ListTraits<T, entry_member>;\n+  using ListTraits = Impl::ListTraits<T>;\n@@ -854,1 +874,1 @@\n-    Impl::IteratorImpl<T, entry_member, true>;\n+    Impl::IteratorImpl<T, get_entry, true>;\n@@ -858,1 +878,1 @@\n-    Impl::IteratorImpl<std::add_const_t<T>, entry_member, true>;\n+    Impl::IteratorImpl<std::add_const_t<T>, get_entry, true>;\n@@ -862,1 +882,1 @@\n-    Impl::IteratorImpl<T, entry_member, false>;\n+    Impl::IteratorImpl<T, get_entry, false>;\n@@ -866,1 +886,1 @@\n-    Impl::IteratorImpl<std::add_const_t<T>, entry_member, false>;\n+    Impl::IteratorImpl<std::add_const_t<T>, get_entry, false>;\n@@ -1206,1 +1226,1 @@\n-    assert(Impl::entry_list(ListTraits::get_entry(value)) == nullptr, \"precondition\");\n+    assert(Impl::entry_list(get_entry(value)) == nullptr, \"precondition\");\n@@ -1471,1 +1491,1 @@\n-    assert(Impl::entry_list(ListTraits::get_entry(value)) == &_impl,\n+    assert(Impl::entry_list(get_entry(value)) == &_impl,\n@@ -1478,1 +1498,1 @@\n-    Impl::set_entry_list(ListTraits::get_entry(value), list);\n+    Impl::set_entry_list(get_entry(value), list);\n@@ -1503,1 +1523,1 @@\n-    Impl::detach(ListTraits::get_entry(value));\n+    Impl::detach(get_entry(value));\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":83,"deletions":63,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -55,2 +55,4 @@\n-  bool is_attached1() const { return _entry1.is_attached(); }\n-  bool is_attached2() const { return _entry2.is_attached(); }\n+  static const Entry& entry1(const Value& v) { return v._entry1; }\n+  static const Entry& entry2(const Value& v) { return v._entry2; }\n+  bool is_attached1() const { return entry1(*this).is_attached(); }\n+  bool is_attached2() const { return entry2(*this).is_attached(); }\n@@ -64,3 +66,3 @@\n-using List1 = IntrusiveList<Value, &Value::_entry1>;\n-using CHeapList1 = IntrusiveList<Value, &Value::_entry1, false, CHeapObj<mtInternal>>;\n-using List2 = IntrusiveList<Value, &Value::_entry2>;\n+using List1 = IntrusiveList<Value, &Value::entry1>;\n+using CHeapList1 = IntrusiveList<Value, &Value::entry1, false, CHeapObj<mtInternal>>;\n+using List2 = IntrusiveList<Value, &Value::entry2>;\n@@ -68,2 +70,2 @@\n-using CList1 = IntrusiveList<const Value, &Value::_entry1>;\n-using CList2 = IntrusiveList<const Value, &Value::_entry2>;\n+using CList1 = IntrusiveList<const Value, &Value::entry1>;\n+using CList2 = IntrusiveList<const Value, &Value::entry2>;\n@@ -1497,2 +1499,2 @@\n-  typedef IntrusiveList<Value, &Value::_entry1, true> ListWithSize;\n-  typedef IntrusiveList<Value, &Value::_entry1, true, CHeapObj<mtInternal> > CHeapListWithSize;\n+  typedef IntrusiveList<Value, &Value::entry1, true> ListWithSize;\n+  typedef IntrusiveList<Value, &Value::entry1, true, CHeapObj<mtInternal> > CHeapListWithSize;\n","filename":"test\/hotspot\/gtest\/utilities\/test_intrusiveList.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"}]}