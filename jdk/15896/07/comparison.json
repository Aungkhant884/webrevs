{"files":[{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/intrusiveList.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef ASSERT\n+IntrusiveListEntry::~IntrusiveListEntry() {\n+  assert(_list == nullptr, \"deleting list entry while in list\");\n+  assert(_prev == nullptr, \"invariant\");\n+  assert(_next == nullptr, \"invariant\");\n+}\n+#endif \/\/ ASSERT\n+\n+IntrusiveListImpl::IntrusiveListImpl() {\n+  _root._prev = add_tag_to_root_entry(&_root);\n+  _root._next = add_tag_to_root_entry(&_root);\n+  DEBUG_ONLY(_root._list = this;)\n+}\n+\n+#ifdef ASSERT\n+IntrusiveListImpl::~IntrusiveListImpl() {\n+  assert(is_tagged_root_entry(_root._prev), \"deleting non-empty list\");\n+  assert(is_tagged_root_entry(_root._next), \"deleting non-empty list\");\n+  \/\/ Clear _root's information before running its asserting destructor.\n+  _root._prev = nullptr;\n+  _root._next = nullptr;\n+  _root._list = nullptr;\n+}\n+#endif \/\/ ASSERT\n+\n+#ifdef ASSERT\n+\n+const IntrusiveListImpl* IntrusiveListImpl::entry_list(const Entry& entry) {\n+  \/\/ Ensure consistency.\n+  if (entry._list == nullptr) {\n+    assert(entry._next == nullptr, \"invariant\");\n+    assert(entry._prev == nullptr, \"invariant\");\n+  } else {\n+    assert(entry._next != nullptr, \"invariant\");\n+    assert(entry._prev != nullptr, \"invariant\");\n+  }\n+  return entry._list;\n+}\n+\n+void IntrusiveListImpl::set_entry_list(const Entry& entry, IntrusiveListImpl* list) {\n+  entry._list = list;\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,1528 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_INTRUSIVELIST_HPP\n+#define SHARE_UTILITIES_INTRUSIVELIST_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"metaprogramming\/logical.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n+\n+class IntrusiveListEntry;\n+class IntrusiveListImpl;\n+\n+\/**\n+ * The type of a function for accessing the list entry of an IntrusiveList's\n+ * element type T.  Such a function takes a reference to const T and returns a\n+ * reference to const IntrusiveListEntry.\n+ *\/\n+template<typename T>\n+using IntrusiveListEntryAccessor =\n+  const IntrusiveListEntry& (*)(std::add_const_t<T>&);\n+\n+\/**\n+ * The IntrusiveList class template provides a doubly-linked list in\n+ * which the links between elements are embedded directly into objects\n+ * contained in the list.  As a result, there are no copies involved\n+ * when inserting objects into the list or referencing list objects,\n+ * and removing an object from a list need not involve destroying the\n+ * object.\n+ *\n+ * To be used in a IntrusiveList, an object must have a\n+ * IntrusiveListEntry member.  An IntrusiveList is associated with the\n+ * class of its elements and the entry member.\n+ *\n+ * An object can be in multiple lists at the same time, so long as\n+ * each list uses a different entry member.  That is, the class of the\n+ * object must have multiple IntrusiveListEntry members, one for each\n+ * list the object is simultaneously an element.\n+ *\n+ * The API for IntrusiveList is modelled on the containers provided by\n+ * the C++ standard library.  In particular, iteration over the\n+ * elements is provided via iterator classes.\n+ *\n+ * IntrusiveLists support polymorphic elements.  Because the objects\n+ * in a list are externally managed, rather than being embedded values\n+ * in the list, the actual type of such objects may be more specific\n+ * than the list's element type.\n+ *\n+ * * T is the class of the elements in the list.  Must be a class type,\n+ * possibly const-qualified.\n+ *\n+ * * get_entry is a function of type IntrusiveListEntryAccessor<T> used\n+ * for accessing the IntrusiveListEntry subobject of T used by this list.\n+ *\n+ * * has_size determines whether the list has a size()\n+ * operation, returning the number of elements in the list.  If the\n+ * operation is present, it has constant-time complexity.  The default\n+ * is to not provide a constant-time size() operation.\n+ *\n+ * A const-element iterator has a const-qualified element type.  Such an\n+ * iterator provides const-qualified access to the elements it designates.\n+ * A list's const_iterator type is always a const-element iterator type.\n+ *\n+ * A const-element list has a const-qualified element type.  Such a list\n+ * provides const-element iterators and const-qualified access to its\n+ * elements.  A const list similarly provides const access to elements, but\n+ * does not support changing the sequence of elements.\n+ *\n+ * A const object can only be added to a const-element list.  Adding a const\n+ * object to a non-const-element list would be an implicit casting away of the\n+ * object's const qualifier.\n+ *\n+ * Some operations that remove elements from a list take a disposer argument.\n+ * This is a function or function object that will be called with one\n+ * argument, of type pointer to T, to a removed element.  This function should\n+ * \"dispose\" of the argument object when called, such as by deleting it.  The\n+ * result of the call is ignored.\n+ *\n+ * Usage of IntrusiveList involves defining an element class which\n+ * contains a IntrusiveListEntry member, and using a corresponding\n+ * specialization of the IntrusiveList class, e.g.\n+ *\n+ * class MyClass {\n+ *   ...\n+ *   IntrusiveListEntry _entry;\n+ *   ...\n+ * public:\n+ *   ...\n+ *   static const IntrusiveListEntry& get_entry(const MyClass& v) {\n+ *     return v._entry;\n+ *   }\n+ *   ...\n+ * };\n+ *\n+ *   ...\n+ *   IntrusiveList<MyClass, &MyClass::get_entry> mylist;\n+ *   ... use mylist ...\n+ *\n+ * Alternatively, the scope of the entry accessor can be limited, with a\n+ * type alias of a list specialization providing access, e.g.\n+ *\n+ * class MyClass {\n+ *   ...\n+ *   IntrusiveListEntry _entry;\n+ *   static const IntrusiveListEntry& get_entry(const MyClass& v) {\n+ *     return v._entry;\n+ *   }\n+ *   ...\n+ * public:\n+ *   ...\n+ *   using MyList = IntrusiveList<MyClass, &get_entry>;\n+ *   ...\n+ * };\n+ *\n+ *   ...\n+ *   MyClass::MyList mylist;\n+ *   ... use mylist ...\n+ *\/\n+template<typename T,\n+         IntrusiveListEntryAccessor<T> entry_accessor,\n+         bool has_size = false>\n+class IntrusiveList;\n+\n+\/**\n+ * A class with an IntrusiveListEntry member can be used as an element\n+ * of a corresponding specialization of IntrusiveList.\n+ *\/\n+class IntrusiveListEntry {\n+  friend class IntrusiveListImpl;\n+\n+public:\n+  \/** Make an entry not attached to any list. *\/\n+  IntrusiveListEntry()\n+    : _prev(nullptr),\n+      _next(nullptr)\n+      DEBUG_ONLY(COMMA _list(nullptr))\n+   {}\n+\n+  \/**\n+   * Destroy the entry.\n+   *\n+   * precondition: not an element of a list.\n+   *\/\n+  ~IntrusiveListEntry() NOT_DEBUG(= default);\n+\n+  NONCOPYABLE(IntrusiveListEntry);\n+\n+  \/** Test whether this entry is attached to some list. *\/\n+  bool is_attached() const {\n+    bool result = (_prev != nullptr);\n+    assert(result == (_next != nullptr), \"inconsistent entry\");\n+    return result;\n+  }\n+\n+private:\n+  \/\/ _prev and _next are the links between elements \/ root entries in\n+  \/\/ an associated list.  The values of these members are type-erased\n+  \/\/ void*.  The IntrusiveListImpl::IteratorOperations class is used\n+  \/\/ to encode, decode, and manipulate the type-erased values.\n+  \/\/\n+  \/\/ Members are mutable and we deal exclusively with pointers to\n+  \/\/ const to make const_references and const_iterators easier to use;\n+  \/\/ an object being const doesn't prevent modifying its list state.\n+  mutable const void* _prev;\n+  mutable const void* _next;\n+  \/\/ The list containing this entry, if any.\n+  \/\/ Debug-only, for use in validity checks.\n+  DEBUG_ONLY(mutable IntrusiveListImpl* _list;)\n+};\n+\n+\/\/ IntrusiveListImpl provides implementation support for IntrusiveList.\n+\/\/ There's nothing for clients to see here. That support is all private, with\n+\/\/ the IntrusiveList class given access via friendship.\n+class IntrusiveListImpl {\n+public:\n+  struct TestSupport;            \/\/ For unit tests\n+\n+private:\n+  using Entry = IntrusiveListEntry;\n+\n+  template<typename T, IntrusiveListEntryAccessor<T>, bool>\n+  friend class IntrusiveList;\n+\n+  using size_type = size_t;\n+  using difference_type = ptrdiff_t;\n+\n+  Entry _root;\n+\n+  IntrusiveListImpl();\n+  ~IntrusiveListImpl() NOT_DEBUG(= default);\n+\n+  NONCOPYABLE(IntrusiveListImpl);\n+\n+  \/\/ Tag manipulation for encoded void*; see IteratorOperations.\n+  static const uintptr_t _tag_alignment = 2;\n+\n+  static bool is_tagged_root_entry(const void* ptr) {\n+    return !is_aligned(ptr, _tag_alignment);\n+  }\n+\n+  static const void* add_tag_to_root_entry(const Entry* entry) {\n+    assert(is_aligned(entry, _tag_alignment), \"must be\");\n+    const void* untagged = entry;\n+    return static_cast<const char*>(untagged) + 1;\n+  }\n+\n+  static const Entry* remove_tag_from_root_entry(const void* ptr) {\n+    assert(is_tagged_root_entry(ptr), \"precondition\");\n+    const void* untagged = static_cast<const char*>(ptr) - 1;\n+    assert(is_aligned(untagged, _tag_alignment), \"must be\");\n+    return static_cast<const Entry*>(untagged);\n+  }\n+\n+  const Entry* root_entry() const { return &_root; }\n+\n+  static void detach(const Entry& entry) {\n+    entry._prev = nullptr;\n+    entry._next = nullptr;\n+    DEBUG_ONLY(entry._list = nullptr;)\n+  }\n+\n+  \/\/ Support for optional constant-time size() operation.\n+  template<bool has_size> class SizeBase;\n+\n+  \/\/ Relevant type aliases.  A corresponding specialization is used directly\n+  \/\/ by IntrusiveList, and by the list's iterators to obtain their\n+  \/\/ corresponding nested types.\n+  template<typename T>\n+  struct ListTraits : public AllStatic {\n+    static_assert(std::is_class<T>::value, \"precondition\");\n+    \/\/ May be const, but not volatile.\n+    static_assert(!std::is_volatile<T>::value, \"precondition\");\n+\n+    using size_type = IntrusiveListImpl::size_type;\n+    using difference_type = IntrusiveListImpl::difference_type;\n+    using value_type = T;\n+    using pointer = std::add_pointer_t<value_type>;\n+    using const_pointer = std::add_pointer_t<std::add_const_t<value_type>>;\n+    using reference = std::add_lvalue_reference_t<value_type>;\n+    using const_reference = std::add_lvalue_reference_t<std::add_const_t<value_type>>;\n+  };\n+\n+  \/\/ Stand-in for std::distance.\n+  template<typename Iterator1, typename Iterator2>\n+  static difference_type distance(Iterator1 from, Iterator2 to) {\n+    difference_type result = 0;\n+    for ( ; from != to; ++result, ++from) {}\n+    return result;\n+  }\n+\n+  \/\/ Iterator support.  IntrusiveList defines its iterator types as\n+  \/\/ specializations of this class.\n+  template<typename T,\n+           IntrusiveListEntryAccessor<T> entry_accessor,\n+           bool is_forward>\n+  class IteratorImpl;\n+\n+  \/\/ Iterator support.  Provides (static) functions for manipulating\n+  \/\/ iterators.  These are used to implement iterators and list\n+  \/\/ operations related to iterators, but are not part of the public\n+  \/\/ API for iterators.\n+  template<typename Iterator> class IteratorOperations;\n+\n+  template<typename Iterator> struct EntryAccess;\n+\n+  \/\/ Predicate metafunction for determining whether T is a non-const\n+  \/\/ IntrusiveList type.\n+  template<typename T>\n+  struct IsListType : public std::false_type {};\n+\n+#ifdef ASSERT\n+  \/\/ Get entry's containing list; null if entry not in a list.\n+  static const IntrusiveListImpl* entry_list(const Entry& entry);\n+  \/\/ Set entry's containing list; list may be null.\n+  static void set_entry_list(const Entry& entry, IntrusiveListImpl* list);\n+#endif \/\/ ASSERT\n+};\n+\n+\/\/ Base class for IntrusiveList, with specializations either providing\n+\/\/ or not providing constant-time size.\n+\n+template<bool has_size>\n+class IntrusiveListImpl::SizeBase {\n+protected:\n+  SizeBase() = default;\n+  ~SizeBase() = default;\n+\n+  size_type* size_ptr() { return nullptr; }\n+  void adjust_size(difference_type n) {}\n+};\n+\n+template<>\n+class IntrusiveListImpl::SizeBase<true> {\n+public:\n+  size_type size() const { return _size; }\n+\n+protected:\n+  SizeBase() : _size(0) {}\n+  ~SizeBase() = default;\n+\n+  size_type* size_ptr() { return &_size; }\n+  void adjust_size(difference_type n) { _size += n; }\n+\n+private:\n+  size_type _size;\n+};\n+\n+\/\/ Destructure iterator type to be provide calling the entry accessor.\n+template<typename T,\n+         IntrusiveListEntryAccessor<T> accessor,\n+         bool is_forward>\n+struct IntrusiveListImpl::EntryAccess<\n+  IntrusiveListImpl::IteratorImpl<T, accessor, is_forward>>\n+{\n+  static const Entry& get_entry(typename ListTraits<T>::const_reference v) {\n+    return accessor(v);\n+  }\n+};\n+\n+template<typename T,\n+         IntrusiveListEntryAccessor<T> accessor,\n+         bool has_size>\n+struct IntrusiveListImpl::IsListType<IntrusiveList<T, accessor, has_size>>\n+  : public std::true_type\n+{};\n+\n+\/\/ The IteratorOperations class provides operations for encoding,\n+\/\/ decoding, and manipulating type-erased void* values representing\n+\/\/ objects in a list.  The encoded void* provides a discriminated\n+\/\/ union of the following:\n+\/\/\n+\/\/ - T*: a pointer to a list element.\n+\/\/ - IntrusiveListEntry*: a pointer to a list's root entry.\n+\/\/ - nullptr: a pointer to no object.\n+\/\/\n+\/\/ IntrusiveListEntry uses such encoded values to refer to the next or\n+\/\/ previous object in a list, e.g. to represent the links between\n+\/\/ objects.\n+\/\/\n+\/\/ IteratorImpl uses such encoded values to refer to the object that\n+\/\/ represents the iterator.  A singular iterator is represented by an\n+\/\/ encoded null.  A dereferenceable iterator is represented by an\n+\/\/ encoded pointer to a list element.  An encoded list root entry is\n+\/\/ used to represent either an end-of-list or before-the-beginning\n+\/\/ iterator, depending on context.\n+\/\/\n+\/\/ The encoding of these values uses a tagged void pointer scheme.\n+\/\/ null represents itself.  A list element (T*) is distinguished from\n+\/\/ a IntrusiveListEntry* via the low address bit.  If the low bit is\n+\/\/ set, the value is a IntrusiveListEntry*; specifically, it is one\n+\/\/ byte past the pointer to the entry.  Otherwise, it is a list\n+\/\/ element.  [This requires all value types and IntrusiveListEntry to\n+\/\/ have an alignment of at least 2.]\n+\/\/\n+\/\/ This encoding leads to minimal cost for typical correct iteration patterns.\n+\/\/ Dereferencing an iterator referring to a list element consists of just\n+\/\/ reinterpreting the type of the iterator's internal value.  And for\n+\/\/ iteration over a range denoted by a pair of iterators, until the iteration\n+\/\/ reaches the end of the range the current iterator always refers to a list\n+\/\/ element.  Similarly, incrementing an iterator consists of just a load from\n+\/\/ the iterator's internal value plus a constant offset.\n+\/\/\n+\/\/ IteratorOperations also provides a suite of operations for\n+\/\/ manipulating iterators and list elements, making use of that\n+\/\/ encoding.  This allows the implementation of iterators and lists to\n+\/\/ be written in terms of these higher level operations, without\n+\/\/ needing to deal with the underlying encoding directly.\n+\/\/\n+\/\/ Note that various functions provided by this class take a const_reference\n+\/\/ argument.  This means some of these functions may break the rule against\n+\/\/ putting const elements in lists with non-const elements.  It is up to\n+\/\/ callers to ensure that doesn't really happen and result in implicitly\n+\/\/ casting away const of the passed argument.  That is, if the list has\n+\/\/ non-const elements then the actual argument must be non-const, even though\n+\/\/ the function parameter is const_reference.  We do it this way because\n+\/\/ having the overloads for both, with one being conditional, would\n+\/\/ significantly expand the code surface and complexity here.  Instead we\n+\/\/ expect the list API to enforce the invariant, which has the added benefit\n+\/\/ of having improper usage fail to compile at that level rather than deep in\n+\/\/ the implementation.  See splice() for example.\n+template<typename Iterator>\n+class IntrusiveListImpl::IteratorOperations : AllStatic {\n+  using Impl = IntrusiveListImpl;\n+  using ListTraits = typename Iterator::ListTraits;\n+  using const_reference = typename ListTraits::const_reference;\n+\n+  static const bool _is_forward = Iterator::_is_forward;\n+\n+  static const void* make_encoded_value(const_reference value) {\n+    return &value;\n+  }\n+\n+  static const void* make_encoded_value(const Entry* entry) {\n+    return add_tag_to_root_entry(entry);\n+  }\n+\n+  static const Entry& resolve_to_entry(Iterator i) {\n+    assert_not_singular(i);\n+    const void* encoded = encoded_value(i);\n+    if (is_tagged_root_entry(encoded)) {\n+      return *(remove_tag_from_root_entry(encoded));\n+    } else {\n+      return get_entry(dereference_element_ptr(encoded));\n+    }\n+  }\n+\n+  \/\/ Get the list element from an encoded pointer to list element.\n+  static const_reference dereference_element_ptr(const void* encoded_ptr) {\n+    return *static_cast<typename ListTraits::const_pointer>(encoded_ptr);\n+  }\n+\n+  static Iterator next(Iterator i) {\n+    return Iterator(resolve_to_entry(i)._next);\n+  }\n+\n+  static Iterator prev(Iterator i) {\n+    return Iterator(resolve_to_entry(i)._prev);\n+  }\n+\n+  static Iterator next(const_reference value) {\n+    return Iterator(get_entry(value)._next);\n+  }\n+\n+  static Iterator prev(const_reference value) {\n+    return Iterator(get_entry(value)._prev);\n+  }\n+\n+  static void attach_impl(const_reference prev, Iterator next) {\n+    get_entry(prev)._next = encoded_value(next);\n+    resolve_to_entry(next)._prev = make_encoded_value(prev);\n+  }\n+\n+  static void attach_impl(Iterator prev, const_reference next) {\n+    resolve_to_entry(prev)._next = make_encoded_value(next);\n+    get_entry(next)._prev = encoded_value(prev);\n+  }\n+\n+  static void iter_attach_impl(Iterator prev, Iterator next) {\n+    resolve_to_entry(prev)._next = encoded_value(next);\n+    resolve_to_entry(next)._prev = encoded_value(prev);\n+  }\n+\n+public:\n+  static const void* encoded_value(Iterator i) { return i._encoded_value; }\n+\n+  static bool is_singular(Iterator i) {\n+    return encoded_value(i) == nullptr;\n+  }\n+\n+  static bool is_root_entry(Iterator i) {\n+    return is_tagged_root_entry(encoded_value(i));\n+  }\n+\n+  \/\/ Corresponding is_element is not used, so not provided.\n+\n+  static const Entry& get_entry(const_reference v) {\n+    return EntryAccess<Iterator>::get_entry(v);\n+  }\n+\n+  static const_reference dereference(Iterator i) {\n+    assert_not_singular(i);\n+    assert(!is_root_entry(i), \"dereference end-of-list iterator\");\n+    return dereference_element_ptr(encoded_value(i));\n+  }\n+\n+  \/\/ Get the predecessor \/ successor (according to the iterator's\n+  \/\/ direction) of the argument.  Reference arguments are preferred;\n+  \/\/ the iterator form should only be used when the iterator is not\n+  \/\/ already known to be dereferenceable.  (The iterator form of\n+  \/\/ successor is not provided; for an iterator to have a successor,\n+  \/\/ the iterator must be dereferenceable.)\n+\n+  static Iterator successor(const_reference value) {\n+    return _is_forward ? next(value) : prev(value);\n+  }\n+\n+  static Iterator predecessor(const_reference value) {\n+    return _is_forward ? prev(value) : next(value);\n+  }\n+\n+  static Iterator iter_predecessor(Iterator i) {\n+    return _is_forward ? prev(i) : next(i);\n+  }\n+\n+  \/\/ Attach pred to succ such that, after the operation,\n+  \/\/ predecessor(succ) == pred.  A reference argument is required when\n+  \/\/ it is not already in the list, since iterator_to is invalid in\n+  \/\/ that situation.  Reference arguments are preferred; an iterator\n+  \/\/ argument should only be used when it is not already known to be\n+  \/\/ dereferenceable.  That is, the first argument should only be an\n+  \/\/ iterator if it might be a before-the-beginning (pseudo)iterator.\n+  \/\/ Similarly, the second argument should only be an iterator if it\n+  \/\/ might be an end-of-list iterator.  (The two-reference case is not\n+  \/\/ provided because that form is never needed.)\n+\n+  \/\/ Mixed reference \/ iterator attachment.\n+  \/\/ C++11: use rvalue references and perfect forwarding.\n+  template<typename PredType, typename SuccType>\n+  static void attach(const PredType& pred, const SuccType& succ) {\n+    _is_forward ? attach_impl(pred, succ) : attach_impl(succ, pred);\n+  }\n+\n+  \/\/ Iterator to iterator attachment.\n+  static void iter_attach(Iterator pred, Iterator succ) {\n+    _is_forward ? iter_attach_impl(pred, succ) : iter_attach_impl(succ, pred);\n+  }\n+\n+  template<typename Iterator2>\n+  static Iterator make_iterator(Iterator2 i) {\n+    return Iterator(IteratorOperations<Iterator2>::encoded_value(i));\n+  }\n+\n+  static Iterator make_iterator_to(const_reference value) {\n+    return Iterator(make_encoded_value(value));\n+  }\n+\n+  static Iterator make_begin_iterator(const Impl& impl) {\n+    const Entry* entry = impl.root_entry();\n+    return Iterator(_is_forward ? entry->_next : entry->_prev);\n+  }\n+\n+  static Iterator make_end_iterator(const Impl& impl) {\n+    return Iterator(make_encoded_value(impl.root_entry()));\n+  }\n+\n+  static void assert_not_singular(Iterator i) {\n+    assert(!is_singular(i), \"singular iterator\");\n+  }\n+\n+  static void assert_is_in_some_list(Iterator i) {\n+    assert_not_singular(i);\n+    assert(list_ptr(i) != nullptr,\n+           \"Invalid iterator \" PTR_FORMAT, p2i(encoded_value(i)));\n+  }\n+\n+#ifdef ASSERT\n+\n+  static const Impl* list_ptr(Iterator i) {\n+    return entry_list(resolve_to_entry(i));\n+  }\n+\n+#endif \/\/ ASSERT\n+};\n+\n+\/**\n+ * Bi-directional constant (e.g. not output) iterator for iterating\n+ * over the elements of an IntrusiveList.  The IntrusiveList class\n+ * uses specializations of this class as its iterator types.\n+ *\n+ * An iterator may be either const-element or non-const-element.  The value\n+ * type of a const-element iterator is const-qualified, and a const-element\n+ * iterator only provides access to const-qualified elements.  Similarly, a\n+ * non-const-element iterator provides access to unqualified elements.  A\n+ * non-const-element iterator can be converted to a const-element iterator,\n+ * but not vice versa.\n+ *\/\n+template<typename T,\n+         IntrusiveListEntryAccessor<T> get_entry,\n+         bool is_forward>\n+class IntrusiveListImpl::IteratorImpl {\n+  friend class IntrusiveListImpl;\n+\n+  static const bool _is_forward = is_forward;\n+  static const bool _is_const_element = std::is_const<T>::value;\n+\n+  using Impl = IntrusiveListImpl;\n+  using ListTraits = Impl::ListTraits<T>;\n+  using IOps = Impl::IteratorOperations<IteratorImpl>;\n+\n+  \/\/ Test whether From is an iterator type different from this type that can\n+  \/\/ be implicitly converted to this iterator type.  A const_element iterator\n+  \/\/ type supports implicit conversion from the corresponding\n+  \/\/ non-const-element iterator type.\n+  template<typename From>\n+  static constexpr bool is_convertible_iterator() {\n+    using NonConst = IteratorImpl<std::remove_const_t<T>, get_entry, _is_forward>;\n+    return _is_const_element && std::is_same<From, NonConst>::value;\n+  }\n+\n+public:\n+  \/** Type of an iterator's value. *\/\n+  using value_type = typename ListTraits::value_type;\n+\n+  \/** Type of a reference to an iterator's value. *\/\n+  using reference = typename ListTraits::reference;\n+\n+  \/** Type of a pointer to an iterator's value. *\/\n+  using pointer = typename ListTraits::pointer;\n+\n+  \/** Type for distance between iterators. *\/\n+  using difference_type = typename ListTraits::difference_type;\n+\n+  \/\/ TODO: We don't have access to <iterator>, so we can't provide the\n+  \/\/ iterator_category type.  Maybe someday...\n+  \/\/ using iterator_category = std::bidirectional_iterator_tag;\n+\n+  \/** Construct a singular iterator. *\/\n+  IteratorImpl() : _encoded_value(nullptr) {}\n+\n+  ~IteratorImpl() = default;\n+  IteratorImpl(const IteratorImpl&) = default;\n+  IteratorImpl& operator=(const IteratorImpl&) = default;\n+\n+  \/\/ Implicit conversion from non-const to const element type.\n+  template<typename From, ENABLE_IF(is_convertible_iterator<From>())>\n+  IteratorImpl(const From& other)\n+    : _encoded_value(IteratorOperations<From>::encoded_value(other))\n+  {}\n+\n+  template<typename From, ENABLE_IF(is_convertible_iterator<From>())>\n+  IteratorImpl& operator=(const From& other) {\n+    return *this = IteratorImpl(other);\n+  }\n+\n+  \/**\n+   * Return a reference to the iterator's value.\n+   *\n+   * precondition: this is dereferenceable.\n+   * complexity: constant.\n+   *\/\n+  reference operator*() const {\n+    return const_cast<reference>(IOps::dereference(*this));\n+  }\n+\n+  \/**\n+   * Return a pointer to the iterator's value.\n+   *\n+   * precondition: this is dereferenceable.\n+   * complexity: constant.\n+   *\/\n+  pointer operator->() const {\n+    return &this->operator*();\n+  }\n+\n+  \/**\n+   * Change this iterator to refer to the successor element (per the\n+   * iterator's direction) in the list, or to the end of the list.\n+   * Return a reference to this iterator.\n+   *\n+   * precondition: this is dereferenceable.\n+   * postcondition: this is dereferenceable or end-of-list.\n+   * complexity: constant.\n+   *\/\n+  IteratorImpl& operator++() {\n+    IOps::assert_is_in_some_list(*this);\n+    *this = IOps::successor(this->operator*());\n+    return *this;\n+  }\n+\n+  \/**\n+   * Make a copy of this iterator, then change this iterator to refer\n+   * to the successor element (per the iterator's direction) in the\n+   * list, or to the end of the list.  Return the copy.\n+   *\n+   * precondition: this is dereferenceable.\n+   * postcondition: this is dereferenceable or end-of-list.\n+   * complexity: constant.\n+   *\/\n+  IteratorImpl operator++(int) {\n+    IteratorImpl result = *this;\n+    this->operator++();\n+    return result;\n+  }\n+\n+  \/**\n+   * Change this iterator to refer to the preceeding element (per the\n+   * iterator's direction) in the list.  Return a reference to this\n+   * iterator.\n+   *\n+   * precondition: There exists an iterator i such that ++i equals this.\n+   * postcondition: this is dereferenceable.\n+   * complexity: constant.\n+   *\/\n+  IteratorImpl& operator--() {\n+    IOps::assert_is_in_some_list(*this);\n+    *this = IOps::iter_predecessor(*this);\n+    \/\/ Must not have been (r)begin iterator.\n+    assert(!IOps::is_root_entry(*this), \"iterator decrement underflow\");\n+    return *this;\n+  }\n+\n+  \/**\n+   * Make a copy of this iterator, then change this iterator to refer\n+   * to the preceeding element (per the iterator's direction) in the\n+   * list.  Return the copy.\n+   *\n+   * precondition: There exists an iterator i such that ++i equals this.\n+   * postcondition: this is dereferenceable.\n+   * complexity: constant.\n+   *\/\n+  IteratorImpl operator--(int) {\n+    IteratorImpl result = *this;\n+    this->operator--();\n+    return result;\n+  }\n+\n+  \/**\n+   * Return true if this and other refer to the same element of a list,\n+   * or both refer to end-of-list.\n+   *\n+   * precondition: this and other are both dereferenceable or end-of-list.\n+   * complexity: constant.\n+   *\/\n+  bool operator==(const IteratorImpl& other) const {\n+    IOps::assert_is_in_some_list(*this);\n+    IOps::assert_is_in_some_list(other);\n+    return IOps::encoded_value(*this) == IOps::encoded_value(other);\n+  }\n+\n+  \/**\n+   * Return true if this and other are not ==.\n+   *\n+   * precondition: this and other are both dereferenceable or end-of-list.\n+   * complexity: constant.\n+   *\/\n+  bool operator!=(const IteratorImpl& other) const {\n+    return !(*this == other);\n+  }\n+\n+  \/\/ Add ConvertibleFrom OP IteratorImpl overloads, because these are\n+  \/\/ not handled by the corresponding member function plus implicit\n+  \/\/ conversions.  For example, const_iterator == iterator is handled\n+  \/\/ by const_iterator::operator==(const_iterator) plus implicit\n+  \/\/ conversion of iterator to const_iterator.  But we need an\n+  \/\/ additional overload to handle iterator == const_iterator when those\n+  \/\/ types are different.\n+\n+  template<typename From, ENABLE_IF(is_convertible_iterator<From>())>\n+  friend bool operator==(const From& lhs, const IteratorImpl& rhs) {\n+    return rhs == lhs;\n+  }\n+\n+  template<typename From, ENABLE_IF(is_convertible_iterator<From>())>\n+  friend bool operator!=(const From& lhs, const IteratorImpl& rhs) {\n+    return rhs != lhs;\n+  }\n+\n+private:\n+  \/\/ An iterator refers to either an object in the list, the root\n+  \/\/ entry of the list, or null if singular.  See IteratorOperations\n+  \/\/ for details of the encoding.\n+  const void* _encoded_value;\n+\n+  \/\/ Allow explicit construction from an encoded const void*\n+  \/\/ value.  But require exactly that type, disallowing any implicit\n+  \/\/ conversions.  Without that restriction, certain kinds of usage\n+  \/\/ errors become both more likely and harder to diagnose the\n+  \/\/ resulting compilation errors.  [The remaining diagnostic\n+  \/\/ difficulties could be eliminated by making EncodedValue a non-public\n+  \/\/ class for carrying the encoded void* to iterator construction.]\n+  template<typename EncodedValue,\n+           ENABLE_IF(std::is_same<EncodedValue, const void*>::value)>\n+  explicit IteratorImpl(EncodedValue encoded_value)\n+    : _encoded_value(encoded_value)\n+  {}\n+};\n+\n+template<typename T,\n+         IntrusiveListEntryAccessor<T> get_entry,\n+         bool has_size>\n+class IntrusiveList : public IntrusiveListImpl::SizeBase<has_size> {\n+  \/\/ Give access to other instantiations, for splice().\n+  template<typename U, IntrusiveListEntryAccessor<U>, bool>\n+  friend class IntrusiveList;\n+\n+  \/\/ Give access for unit testing.\n+  friend struct IntrusiveListImpl::TestSupport;\n+\n+  using Entry = IntrusiveListEntry;\n+  using Impl = IntrusiveListImpl;\n+  using ListTraits = Impl::ListTraits<T>;\n+  using Super = Impl::SizeBase<has_size>;\n+\n+  \/\/ A subsequence of one list can be transferred to another list via splice\n+  \/\/ if the lists have the same (ignoring const qualifiers) element type, use\n+  \/\/ the same entry member, and either the receiver is a const-element list\n+  \/\/ or neither is a const-element list.  A const element of a list cannot be\n+  \/\/ transferred to a list with non-const elements.  That would effectively be\n+  \/\/ a quiet casting away of const.  Assuming Other is a List, these\n+  \/\/ constraints are equivalent to the constraints on conversion of\n+  \/\/ Other::iterator -> iterator.  The presence or absence of constant-time\n+  \/\/ size support for either of the lists doesn't affect whether splicing is\n+  \/\/ permitted.\n+  template<typename Other>\n+  static constexpr bool can_splice_from() {\n+    return Conjunction<Impl::IsListType<Other>,\n+                       std::is_convertible<typename Other::iterator, iterator>>::value;\n+  }\n+\n+  template<typename Other>\n+  static constexpr bool can_swap() {\n+    return Conjunction<Impl::IsListType<Other>,\n+                       std::is_same<typename Other::iterator, iterator>>::value;\n+  }\n+\n+public:\n+  \/** Flag indicating presence of a constant-time size() operation. *\/\n+  static const bool _has_size = has_size;\n+\n+  \/** Type of the size of the list. *\/\n+  using size_type = typename ListTraits::size_type;\n+\n+  \/** The difference type for iterators. *\/\n+  using difference_type = typename ListTraits::difference_type;\n+\n+  \/** Type of list elements. *\/\n+  using value_type = typename ListTraits::value_type;\n+\n+  \/** Type of a pointer to a list element. *\/\n+  using pointer = typename ListTraits::pointer;\n+\n+  \/** Type of a pointer to a const list element. *\/\n+  using const_pointer = typename ListTraits::const_pointer;\n+\n+  \/** Type of a reference to a list element. *\/\n+  using reference = typename ListTraits::reference;\n+\n+  \/** Type of a reference to a const list element. *\/\n+  using const_reference = typename ListTraits::const_reference;\n+\n+  \/** Forward iterator type. *\/\n+  using iterator =\n+    Impl::IteratorImpl<T, get_entry, true>;\n+\n+  \/** Forward iterator type with const elements. *\/\n+  using const_iterator =\n+    Impl::IteratorImpl<std::add_const_t<T>, get_entry, true>;\n+\n+  \/** Reverse iterator type. *\/\n+  using reverse_iterator =\n+    Impl::IteratorImpl<T, get_entry, false>;\n+\n+  \/** Reverse iterator type with const elements. *\/\n+  using const_reverse_iterator =\n+    Impl::IteratorImpl<std::add_const_t<T>, get_entry, false>;\n+\n+  \/** Make an empty list. *\/\n+  IntrusiveList() : _impl() {}\n+\n+  \/**\n+   * Destroy the list.\n+   *\n+   * precondition: empty()\n+   *\/\n+  ~IntrusiveList() = default;\n+\n+  NONCOPYABLE(IntrusiveList);\n+\n+  \/**\n+   * Inserts value at the front of the list.  Does not affect the\n+   * validity of iterators or element references for this list.\n+   *\n+   * precondition: value must not already be in a list using the same entry.\n+   * complexity: constant.\n+   *\/\n+  void push_front(reference value) {\n+    insert(begin(), value);\n+  }\n+\n+  \/**\n+   * Inserts value at the back of the list.  Does not affect the\n+   * validity of iterators or element references for this list.\n+   *\n+   * precondition: value must not already be in a list using the same entry.\n+   * complexity: constant.\n+   *\/\n+  void push_back(reference value) {\n+    insert(end(), value);\n+  }\n+\n+  \/**\n+   * Removes the front element from the list, and applies the\n+   * disposer, if any, to the removed element.  The list may not be in\n+   * a consistent state when the disposer is called.  Invalidates\n+   * iterators for the removed element.\n+   *\n+   * precondition: !empty()\n+   * complexity: constant.\n+   *\/\n+  void pop_front() {\n+    pop_front_and_dispose(NopDisposer());\n+  }\n+\n+  template<typename Disposer>\n+  void pop_front_and_dispose(Disposer disposer) {\n+    erase_and_dispose(begin(), disposer);\n+  }\n+\n+  \/**\n+   * Removes the back element from the list, and applies the disposer,\n+   * if any, to the removed element.  The list may not be in a\n+   * consistent state when the disposer is called.  Invalidates\n+   * iterators for the removed element.\n+   *\n+   * precondition: !empty()\n+   * complexity: constant.\n+   *\/\n+  void pop_back() {\n+    pop_back_and_dispose(NopDisposer());\n+  }\n+\n+  template<typename Disposer>\n+  void pop_back_and_dispose(Disposer disposer) {\n+    erase_and_dispose(rbegin(), disposer);\n+  }\n+\n+  \/**\n+   * Returns a [const_]reference to the front element of the list.\n+   *\n+   * precondition: !empty()\n+   * complexity: constant.\n+   *\/\n+  reference front() { return *begin(); }\n+  const_reference front() const { return *begin(); }\n+\n+  \/**\n+   * Returns a [const_]reference to the back element of the list.\n+   *\n+   * precondition: !empty()\n+   * complexity: constant.\n+   *\/\n+  reference back() { return *rbegin(); }\n+  const_reference back() const { return *rbegin(); }\n+\n+  \/**\n+   * Returns a [const_]iterator referring to the first element of the\n+   * list, or end-of-list if the list is empty.\n+   *\n+   * complexity: constant.\n+   *\/\n+  iterator begin() {\n+    return Impl::IteratorOperations<iterator>::make_begin_iterator(_impl);\n+  }\n+\n+  const_iterator begin() const {\n+    return cbegin();\n+  }\n+\n+  const_iterator cbegin() const {\n+    return Impl::IteratorOperations<const_iterator>::make_begin_iterator(_impl);\n+  }\n+\n+  \/**\n+   * Returns a [const_]iterator referring to the end-of-list.\n+   *\n+   * complexity: constant.\n+   *\/\n+  iterator end() {\n+    return Impl::IteratorOperations<iterator>::make_end_iterator(_impl);\n+  }\n+\n+  const_iterator end() const {\n+    return cend();\n+  }\n+\n+  const_iterator cend() const {\n+    return Impl::IteratorOperations<const_iterator>::make_end_iterator(_impl);\n+  }\n+\n+  \/**\n+   * Returns a [const_]reverse_iterator referring to the last element\n+   * of the list, or end-of-reversed-list if the list is empty.\n+   *\n+   * complexity: constant.\n+   *\/\n+  reverse_iterator rbegin() {\n+    return Impl::IteratorOperations<reverse_iterator>::make_begin_iterator(_impl);\n+  }\n+\n+  const_reverse_iterator rbegin() const {\n+    return crbegin();\n+  }\n+\n+  const_reverse_iterator crbegin() const {\n+    return Impl::IteratorOperations<const_reverse_iterator>::make_begin_iterator(_impl);\n+  }\n+\n+  \/**\n+   * Returns a [const_]reverse_iterator referring to the\n+   * end-of-reversed-list.\n+   *\n+   * complexity: constant.\n+   *\/\n+  reverse_iterator rend() {\n+    return Impl::IteratorOperations<reverse_iterator>::make_end_iterator(_impl);\n+  }\n+\n+  const_reverse_iterator rend() const {\n+    return crend();\n+  }\n+\n+  const_reverse_iterator crend() const {\n+    return Impl::IteratorOperations<const_reverse_iterator>::make_end_iterator(_impl);\n+  }\n+\n+  \/**\n+   * Returns true if list contains no elements.\n+   *\n+   * complexity: constant.\n+   *\/\n+  bool empty() const {\n+    return cbegin() == cend();\n+  }\n+\n+  \/**\n+   * Returns the number of elements in the list.\n+   *\n+   * complexity: O(length())\n+   *\/\n+  size_type length() const {\n+    return static_cast<size_type>(Impl::distance(cbegin(), cend()));\n+  }\n+\n+  \/**\n+   * Removes the element referred to by i from the list, then applies\n+   * the disposer, if any, to the removed element.  The list may not\n+   * be in a consistent state when the disposer is called.  Returns an\n+   * iterator for the successor of i.  Invalidates iterators referring\n+   * to the removed element.\n+   *\n+   * precondition: i must be a dereferenceable iterator for the list.\n+   * complexity: constant.\n+   *\/\n+  iterator erase(const_iterator i) {\n+    return erase_and_dispose(i, NopDisposer());\n+  }\n+\n+  reverse_iterator erase(const_reverse_iterator i) {\n+    return erase_and_dispose(i, NopDisposer());\n+  }\n+\n+  template<typename Disposer>\n+  iterator erase_and_dispose(const_iterator i, Disposer disposer) {\n+    return erase_one_and_dispose<iterator>(i, disposer);\n+  }\n+\n+  template<typename Disposer>\n+  reverse_iterator erase_and_dispose(const_reverse_iterator i, Disposer disposer) {\n+    return erase_one_and_dispose<reverse_iterator>(i, disposer);\n+  }\n+\n+  \/**\n+   * Removes v from the list.  Returns an iterator for the successor\n+   * of v in the list.  Invalidates iterators referring to v.\n+   *\n+   * precondition: v must be in the list.\n+   * complexity: constant.\n+   *\/\n+  iterator erase(const_reference v) {\n+    \/\/ This may seem a little roundabout, but it gets good debug-only error\n+    \/\/ checking with minimal source code and no additional overhead in release.\n+    return erase(iterator_to(v));\n+  }\n+\n+private:\n+\n+  template<typename Result, typename Iterator, typename Disposer>\n+  Result erase_one_and_dispose(Iterator i, Disposer disposer) {\n+    using IOps = Impl::IteratorOperations<Iterator>;\n+    assert_is_iterator(i);\n+    const_reference value = *i++;\n+    IOps::iter_attach(IOps::predecessor(value), i);\n+    detach(value);\n+    disposer(disposer_arg(value));\n+    return make_iterator<Result>(i);\n+  }\n+\n+public:\n+\n+  \/**\n+   * Removes the elements in the range designated by from and to.\n+   * Applies the disposer, if any, to each removed element.  The list\n+   * may not be in a consistent state when the disposer is called.\n+   * Returns an iterator referring to the end of the removed range.\n+   * Invalidates iterators referring to the removed elements.\n+   *\n+   * precondition: from and to must form a valid range for the list.\n+   * complexity: O(number of elements removed)\n+   *\/\n+  iterator erase(const_iterator from, const_iterator to) {\n+    return erase_and_dispose(from, to, NopDisposer());\n+  }\n+\n+  reverse_iterator erase(const_reverse_iterator from, const_reverse_iterator to) {\n+    return erase_and_dispose(from, to, NopDisposer());\n+  }\n+\n+  template<typename Disposer>\n+  iterator erase_and_dispose(const_iterator from, const_iterator to, Disposer disposer) {\n+    return erase_range_and_dispose<iterator>(from, to, disposer);\n+  }\n+\n+  template<typename Disposer>\n+  reverse_iterator erase_and_dispose(const_reverse_iterator from,\n+                                     const_reverse_iterator to,\n+                                     Disposer disposer) {\n+    return erase_range_and_dispose<reverse_iterator>(from, to, disposer);\n+  }\n+\n+private:\n+\n+  template<typename Result, typename Iterator, typename Disposer>\n+  Result erase_range_and_dispose(Iterator from, Iterator to, Disposer disposer) {\n+    using IOps = Impl::IteratorOperations<Iterator>;\n+    assert_is_iterator(from);\n+    assert_is_iterator(to);\n+    if (from != to) {\n+      IOps::iter_attach(IOps::predecessor(*from), to);\n+      do {\n+        const_reference value = *from++;\n+        detach(value);\n+        disposer(disposer_arg(value));\n+      } while (from != to);\n+    }\n+    return make_iterator<Result>(to);\n+  }\n+\n+public:\n+\n+  \/**\n+   * Conditionally removes elements from the list.  Successively calls the\n+   * predicate with a const_reference to each element of the list.  If the\n+   * result of such a call is true then that element is removed from the list.\n+   * Applies the disposer, if any, to each removed element.  The list may not\n+   * be in a consistent state when the disposer is called.  Returns the number\n+   * of removed elements.  Invalidates iterators referring to the removed\n+   * elements.\n+   *\n+   * complexity: O(length())\n+   *\/\n+\n+  template<typename Predicate>\n+  size_type erase_if(Predicate predicate) {\n+    return erase_and_dispose_if(predicate, NopDisposer());\n+  }\n+\n+  template<typename Predicate, typename Disposer>\n+  size_type erase_and_dispose_if(Predicate predicate, Disposer disposer) {\n+    const_iterator pos = cbegin();\n+    const_iterator end = cend();\n+    size_type removed = 0;\n+    while (pos != end) {\n+      const_reference v = *pos;\n+      if (predicate(v)) {\n+        pos = erase(pos);\n+        disposer(disposer_arg(v));\n+        ++removed;\n+      } else {\n+        ++pos;\n+      }\n+    }\n+    return removed;\n+  }\n+\n+  \/**\n+   * Removes all of the elements from the list.  Applies the disposer,\n+   * if any, to each element as it is removed.  The list may not be in\n+   * a consistent state when the disposer is called.  Invalidates all\n+   * non-end-of-list iterators for this list.\n+   *\n+   * postcondition: empty()\n+   * complexity: O(length())\n+   *\/\n+  void clear() {\n+    erase(begin(), end());\n+  }\n+\n+  template<typename Disposer>\n+  void clear_and_dispose(Disposer disposer) {\n+    erase_and_dispose(begin(), end(), disposer);\n+  }\n+\n+  \/**\n+   * Inserts value into the list before pos.  Returns an iterator\n+   * referring to the newly inserted value.  Does not invalidate any\n+   * iterators.\n+   *\n+   * precondition: pos must be a valid iterator for the list.\n+   * precondition: value must not already be in a list using the same entry.\n+   * postcondition: ++result == pos\n+   * complexity: constant.\n+   *\/\n+  iterator insert(const_iterator pos, reference value) {\n+    return insert_impl<iterator>(pos, value);\n+  }\n+\n+  reverse_iterator insert(const_reverse_iterator pos, reference value) {\n+    return insert_impl<reverse_iterator>(pos, value);\n+  }\n+\n+private:\n+\n+  template<typename Result, typename Iterator>\n+  Result insert_impl(Iterator pos, reference value) {\n+    assert(Impl::entry_list(get_entry(value)) == nullptr, \"precondition\");\n+    assert_is_iterator(pos);\n+    using IOps = Impl::IteratorOperations<Iterator>;\n+    IOps::attach(IOps::iter_predecessor(pos), value);\n+    IOps::attach(value, pos);\n+    DEBUG_ONLY(set_list(value, &_impl);)\n+    adjust_size(1);\n+    return make_iterator_to<Result>(value);\n+  }\n+\n+public:\n+\n+  \/**\n+   * Transfers the elements of from_list in the range designated by\n+   * from and to to this list, inserted before pos.  Returns an\n+   * iterator referring to the head of the spliced in range.  Does\n+   * not invalidate any iterators.\n+   *\n+   * precondition: pos must be a valid iterator for this list.\n+   * precondition: from and to must form a valid range for from_list.\n+   * precondition: pos is not in the range to transfer, i.e. either\n+   * - this != &from_list, or\n+   * - pos is reachable from to, or\n+   * - pos is not reachable from from.\n+   *\n+   * postcondition: iterators referring to elements in the transferred range\n+   * are valid iterators for this list rather than from_list.\n+   *\n+   * complexity: constant if either (a) this == &from_list, (b) neither\n+   * this nor from_list has a constant-time size() operation, or (c)\n+   * from_list has a constant-time size() operation and is being\n+   * transferred in its entirety; otherwise O(number of elements\n+   * transferred).\n+   *\/\n+  template<typename FromList, ENABLE_IF(can_splice_from<FromList>())>\n+  iterator splice(const_iterator pos,\n+                  FromList& from_list,\n+                  typename FromList::iterator from,\n+                  typename FromList::const_iterator to) {\n+    using Iterator = const_iterator;\n+    using Result = iterator;\n+    using IOps = Impl::IteratorOperations<Iterator>;\n+\n+    assert_is_iterator(pos);\n+    from_list.assert_is_iterator(from);\n+    from_list.assert_is_iterator(to);\n+\n+    if (from == to) {\n+      \/\/ Done if empty range.\n+      return make_iterator<Result>(pos);\n+    } else if (is_same_list(from_list) && (pos == to)) {\n+      \/\/ Done if already in desired position.\n+      return make_iterator_to<Result>(*from);\n+    }\n+\n+    \/\/ Adjust sizes if needed.  Only need adjustment if different\n+    \/\/ lists and at least one of the lists has a constant-time size.\n+    if ((_has_size || from_list._has_size) && !is_same_list(from_list)) {\n+      difference_type transferring;\n+      if (from_list._has_size &&\n+          (from == from_list.cbegin()) &&\n+          (to == from_list.cend())) {\n+        \/\/ If from_list has constant-time size() and we're transferring\n+        \/\/ all of it, we can use that size value to avoid counting the\n+        \/\/ number of elements being transferred.\n+        transferring = *from_list.size_ptr();\n+      } else {\n+        \/\/ Count the number of elements being transferred.\n+        transferring = Impl::distance(from, to);\n+      }\n+      from_list.adjust_size(-transferring);\n+      adjust_size(transferring);\n+    }\n+\n+#ifdef ASSERT\n+    \/\/ Transfer elements to this list, and verify pos not in [from, to).\n+    if (is_same_list(from_list)) {\n+      for (Iterator i = from; i != to; ++i) {\n+        assert(i != pos, \"splice range includes destination\");\n+      }\n+    } else {\n+      for (Iterator i = from; i != to; ++i) {\n+        set_list(*i, &_impl);\n+      }\n+    }\n+#endif \/\/ ASSERT\n+\n+    \/\/ to is end of non-empty range, so has a dereferenceable predecessor.\n+    Iterator to_pred = --Iterator(to); \/\/ Fetch before clobbered\n+    \/\/ from is dereferenceable since it neither follows nor equals to.\n+    const_reference from_value = *from;\n+    IOps::iter_attach(IOps::predecessor(from_value), to);\n+    IOps::attach(IOps::iter_predecessor(pos), from_value);\n+    IOps::attach(*to_pred, pos);\n+    return make_iterator_to<Result>(from_value);\n+  }\n+\n+  \/**\n+   * Transfers all elements of from_list to this list, inserted before\n+   * pos.  Returns an iterator referring to the head of the spliced in\n+   * range.  Does not invalidate any iterators.\n+   *\n+   * precondition: pos must be a valid iterator for this list.\n+   * precondition: this != &from_list.\n+   *\n+   * postcondition: iterators referring to elements that were in\n+   * from_list are valid iterators for this list rather than\n+   * from_list.\n+   *\n+   * Complexity: constant if either (a) this does not have a\n+   * constant-time size() operation, or (b) from_list has a\n+   * constant-time size() operation; otherwise O(number of elements\n+   * transferred).\n+   *\/\n+  template<typename FromList, ENABLE_IF(Impl::IsListType<FromList>::value)>\n+  iterator splice(const_iterator pos, FromList& from_list) {\n+    assert(!is_same_list(from_list), \"precondition\");\n+    return splice(pos, from_list, from_list.begin(), from_list.end());\n+  }\n+\n+  \/**\n+   * Transfers the element of from_list referred to by from to this\n+   * list, inserted before pos.  Returns an iterator referring to the\n+   * inserted element.  Does not invalidate any iterators.\n+   *\n+   * precondition: pos must be a valid iterator for this list.\n+   * precondition: from must be a dereferenceable iterator of from_list.\n+   * precondition: pos is not in the range to transfer, i.e. if\n+   * this == &from_list then pos != from.\n+   *\n+   * postcondition: iterators referring to the transferred element are\n+   * valid iterators for this list rather than from_list.\n+   *\n+   * complexity: constant.\n+   *\/\n+  template<typename FromList, ENABLE_IF(can_splice_from<FromList>())>\n+  iterator splice(const_iterator pos,\n+                  FromList& from_list,\n+                  typename FromList::iterator from) {\n+    using IOps = Impl::IteratorOperations<const_iterator>;\n+\n+    assert_is_iterator(pos);\n+    from_list.assert_is_iterator(from);\n+\n+#ifdef ASSERT\n+    \/\/ Transfer element to this list, or verify pos not in [from, to).\n+    if (is_same_list(from_list)) {\n+      assert(from != pos, \"Splice range includes destination\");\n+    } else {\n+      set_list(*from, &_impl);\n+    }\n+#endif \/\/ ASSERT\n+\n+    const_reference from_value = *from;\n+\n+    \/\/ Remove from_value from from_list.\n+    IOps::iter_attach(IOps::predecessor(from_value), IOps::successor(from_value));\n+    from_list.adjust_size(-1);\n+\n+    \/\/ Add from_value to this list before pos.\n+    IOps::attach(IOps::iter_predecessor(pos), from_value);\n+    IOps::attach(from_value, pos);\n+    adjust_size(1);\n+\n+    return make_iterator_to<iterator>(from_value);\n+  }\n+\n+  \/**\n+   * Exchange the elements of this list and other, maintaining the order of\n+   * the elements.  Does not invalidate any iterators.\n+   *\n+   * precondition: this and other are different lists.\n+   *\n+   * postcondition: iterators referring to elements in this list become valid\n+   * iterators for other, and vice versa.\n+   *\n+   * complexity: if one of the lists has constant-time size and the other does\n+   * not, then O(number of elements in the list without constant-time size);\n+   * otherwise constant (when neither or both lists have constant-time size).\n+   *\/\n+  template<typename OtherList, ENABLE_IF(can_swap<OtherList>())>\n+  void swap(OtherList& other) {\n+    assert(!is_same_list(other), \"self-swap\");\n+    if (!_has_size) {\n+      \/\/ This list does not have constant-time size. First, transfer other's\n+      \/\/ elements to the front of this list (a constant-time operation).  Then\n+      \/\/ transfer this list's original elements to other (linear time if other\n+      \/\/ has constant-time size, constant-time if it doesn't).\n+      iterator old_begin = begin();\n+      splice(old_begin, other);\n+      other.splice(other.begin(), *this, old_begin, end());\n+    } else if (!OtherList::_has_size) {\n+      \/\/ This list has constant-time size but other doesn't.  First,\n+      \/\/ transfer all of this list's elements to other (a constant-time\n+      \/\/ operation).  Then transfer other's original elements to this list\n+      \/\/ (linear time).\n+      typename OtherList::iterator other_begin = other.begin();\n+      other.splice(other_begin, *this);\n+      splice(begin(), other, other_begin, other.end());\n+    } else {\n+      \/\/ Both lists have constant-time sizes that need to be managed.  Use an\n+      \/\/ intermediate temporary so all transfers are of entire lists.  This\n+      \/\/ stays within the constant-time domain for all of the transfers.\n+      IntrusiveList temp{};\n+      temp.splice(temp.begin(), other);\n+      other.splice(other.begin(), *this);\n+      splice(begin(), temp);\n+    }\n+  }\n+\n+  \/**\n+   * Returns a [const_][reverse_]iterator referring to value.\n+   *\n+   * precondition: value must be an element of the list.\n+   * complexity: constant.\n+   *\/\n+  iterator iterator_to(reference value) {\n+    return make_iterator_to<iterator>(value);\n+  }\n+\n+  const_iterator iterator_to(const_reference value) const {\n+    return const_iterator_to(value);\n+  }\n+\n+  const_iterator const_iterator_to(const_reference value) const {\n+    return make_iterator_to<const_iterator>(value);\n+  }\n+\n+  reverse_iterator reverse_iterator_to(reference value) {\n+    return make_iterator_to<reverse_iterator>(value);\n+  }\n+\n+  const_reverse_iterator reverse_iterator_to(const_reference value) const {\n+    return const_reverse_iterator_to(value);\n+  }\n+\n+  const_reverse_iterator const_reverse_iterator_to(const_reference value) const {\n+    return make_iterator_to<const_reverse_iterator>(value);\n+  }\n+\n+private:\n+  Impl _impl;\n+\n+  size_type* size_ptr() {\n+    return Super::size_ptr();\n+  }\n+\n+  void adjust_size(difference_type value) {\n+    Super::adjust_size(value);\n+  }\n+\n+  template<typename OtherList>\n+  bool is_same_list(const OtherList& other) const {\n+    return &_impl == &other._impl;\n+  }\n+\n+  template<typename Iterator>\n+  void assert_is_iterator(const Iterator& i) const {\n+    using IOps = Impl::IteratorOperations<Iterator>;\n+    assert(IOps::list_ptr(i) == &_impl,\n+           \"Iterator \" PTR_FORMAT \" not for this list \" PTR_FORMAT,\n+           p2i(IOps::encoded_value(i)), p2i(this));\n+  }\n+\n+  void assert_is_element(const_reference value) const {\n+    assert(Impl::entry_list(get_entry(value)) == &_impl,\n+           \"Value \" PTR_FORMAT \" not in this list \" PTR_FORMAT,\n+           p2i(&value), p2i(this));\n+  }\n+\n+#ifdef ASSERT\n+  void set_list(const_reference value, Impl* list) {\n+    Impl::set_entry_list(get_entry(value), list);\n+  }\n+#endif\n+\n+  template<typename Result, typename From>\n+  Result make_iterator(From i) const {\n+    assert_is_iterator(i);\n+    return Impl::IteratorOperations<Result>::make_iterator(i);\n+  }\n+\n+  \/\/ This can break the rules about putting const elements in non-const\n+  \/\/ iterators or lists.  It is up to callers to ensure that doesn't happen\n+  \/\/ and result in implicitly casting away const of the passed argument.\n+  template<typename Iterator>\n+  Iterator make_iterator_to(const_reference value) const {\n+    assert_is_element(value);\n+    return Impl::IteratorOperations<Iterator>::make_iterator_to(value);\n+  }\n+\n+  struct NopDisposer {\n+    void operator()(pointer) const {}\n+  };\n+\n+  \/\/ The pointer type is const-qualified per to the elements of the list, so\n+  \/\/ it's okay to possibly cast away const when disposing.\n+  static pointer disposer_arg(const_reference value) {\n+    return const_cast<pointer>(&value);\n+  }\n+\n+  void detach(const_reference value) {\n+    assert_is_element(value);\n+    Impl::detach(get_entry(value));\n+    adjust_size(-1);\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_INTRUSIVELIST_HPP\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":1528,"deletions":0,"binary":false,"changes":1528,"status":"added"},{"patch":"@@ -0,0 +1,1644 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/intrusiveList.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n+#include \"unittest.hpp\"\n+\n+\/\/ Note: Hotspot gtest integration doesn't yet support typed tests, so\n+\/\/ a lot of the tests of the different iterator types are done by hand.\n+\n+using Entry = IntrusiveListEntry;\n+\n+struct TestIntrusiveListValue : public CHeapObj<mtInternal> {\n+  size_t _value;\n+\n+  \/\/ Note: Entry members need to be public, to work around VS2013 bug.\n+\n+  Entry _entry1;                \/\/ Entry for first list.\n+\n+  \/\/ Used to prove we can have an object in two different kinds of\n+  \/\/ list.  We only use _entry1 for most other tests.\n+  Entry _entry2;                \/\/ Entry for second list.\n+\n+  TestIntrusiveListValue(size_t value) : _value(value) { }\n+\n+  NONCOPYABLE(TestIntrusiveListValue);\n+\n+  using Value = TestIntrusiveListValue; \/\/ convenience\n+\n+  size_t value() const { return _value; }\n+  static const Entry& entry1(const Value& v) { return v._entry1; }\n+  static const Entry& entry2(const Value& v) { return v._entry2; }\n+  bool is_attached1() const { return entry1(*this).is_attached(); }\n+  bool is_attached2() const { return entry2(*this).is_attached(); }\n+  Value* This() { return this; }\n+  const Value* This() const { return this; }\n+};\n+\n+\/\/ Convenience type aliases.\n+using Value = TestIntrusiveListValue;\n+\n+using List1 = IntrusiveList<Value, &Value::entry1>;\n+using List2 = IntrusiveList<Value, &Value::entry2>;\n+\n+using CList1 = IntrusiveList<const Value, &Value::entry1>;\n+using CList2 = IntrusiveList<const Value, &Value::entry2>;\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Some preliminary tests.\n+\n+struct IntrusiveListImpl::TestSupport {\n+  \/\/ Verify expected iterator conversions.\n+  using L1Iterator = typename List1::iterator;\n+  using L1CIterator = typename List1::const_iterator;\n+  using C1Iterator = typename CList1::iterator;\n+  using C1CIterator = typename CList1::const_iterator;\n+  static_assert(std::is_convertible<L1Iterator, L1Iterator>::value,\n+                \"not convertible: List1::iterator -> List1::iterator\");\n+  static_assert(std::is_convertible<L1CIterator, L1CIterator>::value,\n+                \"not convertible: List1::const_iterator -> List1::const_iterator\");\n+  static_assert(std::is_convertible<L1CIterator, L1CIterator>::value,\n+                \"not convertible: List1::const_iterator -> List1::const_iterator\");\n+  static_assert(std::is_convertible<L1Iterator, L1CIterator>::value,\n+                \"not convertible: List1::iterator -> List1::const_iterator\");\n+  static_assert(!std::is_convertible<L1CIterator, L1Iterator>::value,\n+                \"convertible: List1::iterator -> List1::const_iterator\");\n+\n+  using L2Iterator = typename List2::iterator;\n+  static_assert(!std::is_convertible<L1Iterator, L2Iterator>::value,\n+                \"convertible: List1::iterator -> List2::iterator\");\n+  static_assert(!std::is_convertible<L2Iterator, L1Iterator>::value,\n+                \"convertible: List2::iterator -> List1::iterator\");\n+\n+  \/\/ Verify can_splice_from for pairwise combinations of const\/non-const value type.\n+  static_assert(List1::can_splice_from<List1>(), \"cannot splice List1 -> List1\");\n+  static_assert(CList1::can_splice_from<CList1>(), \"cannot splice CList1 -> CList1\");\n+  static_assert(!List1::can_splice_from<CList1>(), \"can splice CList1 -> List1\");\n+  static_assert(CList1::can_splice_from<List1>(), \"cannot splice List1 -> CList1\");\n+\n+  \/\/ Verify CanSplice is false for different list entries.\n+  static_assert(!List2::can_splice_from<List1>(), \"can splice List1 -> List2\");\n+\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Test fixtures.\n+\n+class IntrusiveListTestWithValues : public ::testing::Test {\n+public:\n+  IntrusiveListTestWithValues() {\n+    for (size_t i = 0; i < nvalues; ++i) {\n+      values[i] = new Value(i);\n+    }\n+  }\n+\n+  ~IntrusiveListTestWithValues() {\n+    for (size_t i = 0; i < nvalues; ++i) {\n+      delete values[i];\n+    }\n+  }\n+\n+  static const size_t nvalues = 10;\n+  Value* values[nvalues];\n+};\n+\n+const size_t IntrusiveListTestWithValues::nvalues;\n+\n+class IntrusiveListTestWithList1 : public IntrusiveListTestWithValues {\n+public:\n+  IntrusiveListTestWithList1() {\n+    fill_list();\n+  }\n+\n+  ~IntrusiveListTestWithList1() {\n+    list1.clear();\n+  }\n+\n+  List1 list1;\n+\n+  \/\/ Add all values[] to list1, in the same order in values[] and list.\n+  void fill_list() {\n+    for (size_t i = 0; i < nvalues; ++i) {\n+      list1.push_back(*values[i]);\n+    }\n+  }\n+};\n+\n+class IntrusiveListTestWithCList1 : public IntrusiveListTestWithValues {\n+public:\n+  IntrusiveListTestWithCList1() {\n+    fill_list();\n+  }\n+\n+  ~IntrusiveListTestWithCList1() {\n+    list1.clear();\n+  }\n+\n+  CList1 list1;\n+\n+  \/\/ Add all values[] to list1, in the same order in values[] and list.\n+  void fill_list() {\n+    for (size_t i = 0; i < nvalues; ++i) {\n+      list1.push_back(*values[i]);\n+    }\n+  }\n+};\n+\n+class IntrusiveListTestWithDisposal : public IntrusiveListTestWithList1 {\n+public:\n+  IntrusiveListTestWithDisposal() : ndisposed(0), disposed() { }\n+\n+  size_t ndisposed;\n+  const Value* disposed[nvalues];\n+\n+  class CollectingDisposer {\n+  public:\n+    CollectingDisposer(IntrusiveListTestWithDisposal* test) : _test(test) { }\n+\n+    void operator()(const Value* value) const {\n+      _test->disposed[_test->ndisposed++] = value;\n+    }\n+\n+  private:\n+    IntrusiveListTestWithDisposal* _test;\n+  };\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper functions\n+\n+\/\/ Doesn't distinguish between reference and non-reference types.\n+template<typename Expected, typename T>\n+static bool is_expected_type(T) {\n+  return std::is_same<Expected, T>::value;\n+}\n+\n+\/\/ This lets us distinguish between non-const reference and const\n+\/\/ reference or value.\n+template<typename Expected, typename T>\n+static bool is_expected_ref_type(T&) {\n+  return std::is_same<Expected, T&>::value;\n+};\n+\n+template<typename It>\n+static It step_iterator(It it, ptrdiff_t n) {\n+  if (n < 0) {\n+    for (ptrdiff_t i = 0; i > n; --i) {\n+      --it;\n+    }\n+  } else {\n+    for (ptrdiff_t i = 0; i < n; ++i) {\n+      ++it;\n+    }\n+  }\n+  return it;\n+}\n+\n+template<typename List>\n+static typename List::reference list_elt(List& list, size_t n) {\n+  return *step_iterator(list.begin(), n);\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ push_front(), pop_front(), length(), empty()\n+\/\/ front(), back()\n+\n+TEST_F(IntrusiveListTestWithValues, push_front) {\n+  List1 list1;\n+  for (size_t i = 0; i < nvalues; ++i) {\n+    EXPECT_FALSE(values[i]->is_attached1());\n+    EXPECT_FALSE(values[i]->is_attached2());\n+    list1.push_front(*values[i]);\n+    EXPECT_TRUE(values[i]->is_attached1());\n+    EXPECT_FALSE(values[i]->is_attached2());\n+    EXPECT_FALSE(list1.empty());\n+    EXPECT_EQ(i + 1, list1.length());\n+    EXPECT_EQ(values[i]->value(), list1.front().value());\n+    EXPECT_EQ(values[0]->value(), list1.back().value());\n+  }\n+  {\n+    size_t i = nvalues;\n+    for (const Value& v : list1) {\n+      EXPECT_EQ(--i, v.value());\n+    }\n+  }\n+  list1.clear();\n+}\n+\n+\/\/ Basic test of using list with const elements.\n+TEST_F(IntrusiveListTestWithValues, push_front_const) {\n+  CList1 list1;\n+\n+  \/\/ Verify we can add a const object.  This doesn't compile for List1.\n+  const Value& v0 = *values[0];\n+  list1.push_front(v0);\n+  list1.clear();\n+\n+  for (size_t i = 0; i < nvalues; ++i) {\n+    list1.push_front(*values[i]);\n+    EXPECT_FALSE(list1.empty());\n+    EXPECT_EQ(i + 1, list1.length());\n+    EXPECT_EQ(values[i]->value(), list1.front().value());\n+    EXPECT_EQ(values[0]->value(), list1.back().value());\n+  }\n+  {\n+    size_t i = nvalues;\n+    for (const Value& v : list1) {\n+      EXPECT_EQ(--i, v.value());\n+    }\n+  }\n+  list1.clear();\n+}\n+\n+TEST_F(IntrusiveListTestWithValues, push_back) {\n+  List2 list2;\n+  for (size_t i = 0; i < nvalues; ++i) {\n+    list2.push_back(*values[i]);\n+    EXPECT_FALSE(list2.empty());\n+    EXPECT_EQ(i + 1, list2.length());\n+    EXPECT_EQ(values[i]->value(), list2.back().value());\n+    EXPECT_EQ(values[0]->value(), list2.front().value());\n+  }\n+  {\n+    size_t i = 0;\n+    for (const Value& v : list2) {\n+      EXPECT_EQ(i++, v.value());\n+    }\n+  }\n+  list2.clear();\n+}\n+\n+TEST_F(IntrusiveListTestWithValues, push_back_const) {\n+  CList2 list2;\n+\n+  \/\/ Verify we can add a const object.  This doesn't compile for List1.\n+  const Value& v0 = *values[0];\n+  list2.push_back(v0);\n+  list2.clear();\n+\n+  for (size_t i = 0; i < nvalues; ++i) {\n+    list2.push_back(*values[i]);\n+    EXPECT_FALSE(list2.empty());\n+    EXPECT_EQ(i + 1, list2.length());\n+    EXPECT_EQ(values[i]->value(), list2.back().value());\n+    EXPECT_EQ(values[0]->value(), list2.front().value());\n+  }\n+  {\n+    size_t i = 0;\n+    for (const Value& v : list2) {\n+      EXPECT_EQ(i++, v.value());\n+    }\n+  }\n+  list2.clear();\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Verify we can construct a singular iterator of each type.\n+\n+template<typename T> static void ignore(const T&) { }\n+\n+template<typename It>\n+static void construct_singular_iterator() {\n+  It it;\n+  \/\/ There's not much we can do with a singular iterator to test further.\n+  ignore(it);\n+}\n+\n+TEST(IntrusiveListBasics, construct_singular_iterators) {\n+  construct_singular_iterator<List1::iterator>();\n+  construct_singular_iterator<List1::const_iterator>();\n+  construct_singular_iterator<List1::reverse_iterator>();\n+  construct_singular_iterator<List1::const_reverse_iterator>();\n+}\n+\n+\/\/ normal constructor and destructor are tested in the normal course\n+\/\/ of testing other things.\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ copy construction\n+\n+template<typename To, typename It>\n+static void test_copy_constructor2(const It& it) {\n+  To copy(it);\n+  EXPECT_EQ(it, copy);\n+  EXPECT_EQ(it->This(), copy->This());\n+  ++copy;\n+  EXPECT_NE(it, copy);\n+}\n+\n+template<typename It>\n+static void test_copy_constructor(const It& it) {\n+  test_copy_constructor2<It>(it);\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, copy_construct) {\n+  test_copy_constructor(list1.begin());\n+  test_copy_constructor(list1.cbegin());\n+  test_copy_constructor(list1.rbegin());\n+  test_copy_constructor(list1.crbegin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ copy assign\n+\n+template<typename To, typename It>\n+static void test_copy_assign2(const It& it) {\n+  It tmp(it);\n+  EXPECT_EQ(it, tmp);\n+\n+  To copy;\n+  \/\/ Can't compare against singular copy.\n+  copy = ++tmp;\n+  EXPECT_NE(it, copy);\n+  EXPECT_EQ(tmp, copy);\n+  EXPECT_EQ(tmp->This(), copy->This());\n+}\n+\n+template<typename It>\n+static void test_copy_assign(const It& it) {\n+  test_copy_assign2<It>(it);\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, copy_assign) {\n+  test_copy_assign(list1.begin());\n+  test_copy_assign(list1.cbegin());\n+  test_copy_assign(list1.rbegin());\n+  test_copy_assign(list1.crbegin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ copy conversion\n+\/\/ conversion assign\n+\n+TEST_F(IntrusiveListTestWithList1, copy_conversion) {\n+  test_copy_constructor2<List1::const_iterator>(list1.begin());\n+  test_copy_constructor2<List1::const_reverse_iterator>(list1.rbegin());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, conversion_assign) {\n+  test_copy_assign2<List1::const_iterator>(list1.begin());\n+  test_copy_assign2<List1::const_reverse_iterator>(list1.rbegin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ operator*\n+\/\/ operator->\n+\n+TEST_F(IntrusiveListTestWithList1, reference_type) {\n+  EXPECT_TRUE(is_expected_ref_type<List1::reference>(*list1.begin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reference>(*list1.cbegin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::reference>(*list1.rbegin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reference>(*list1.crbegin()));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, pointer_type) {\n+  EXPECT_TRUE(is_expected_type<List1::pointer>(list1.begin()->This()));\n+  EXPECT_TRUE(is_expected_type<List1::const_pointer>(list1.cbegin()->This()));\n+  EXPECT_TRUE(is_expected_type<List1::pointer>(list1.rbegin()->This()));\n+  EXPECT_TRUE(is_expected_type<List1::const_pointer>(list1.cbegin()->This()));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, dereference) {\n+  EXPECT_EQ(0u, (*list1.begin()).value());\n+  EXPECT_EQ(0u, (*list1.cbegin()).value());\n+  EXPECT_EQ(nvalues - 1, (*list1.rbegin()).value());\n+  EXPECT_EQ(nvalues - 1, (*list1.crbegin()).value());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, get_pointer) {\n+  EXPECT_EQ(0u, list1.begin()->value());\n+  EXPECT_EQ(0u, list1.begin()->value());\n+  EXPECT_EQ(nvalues - 1, list1.rbegin()->value());\n+  EXPECT_EQ(nvalues - 1, list1.crbegin()->value());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ operator++()\n+\/\/ operator++(int)\n+\/\/ operator--()\n+\/\/ operator--(int)\n+\n+TEST_F(IntrusiveListTestWithList1, preincrement_type) {\n+  EXPECT_TRUE(is_expected_ref_type<List1::iterator&>(++list1.begin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_iterator&>(++list1.cbegin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::reverse_iterator&>(++list1.rbegin()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reverse_iterator&>(++list1.crbegin()));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, postincrement_type) {\n+  EXPECT_TRUE(is_expected_type<List1::iterator>(list1.begin()++));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(list1.cbegin()++));\n+  EXPECT_TRUE(is_expected_type<List1::reverse_iterator>(list1.rbegin()++));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(list1.crbegin()++));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, predecrement_type) {\n+  EXPECT_TRUE(is_expected_ref_type<List1::iterator&>(--list1.end()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_iterator&>(--list1.cend()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::reverse_iterator&>(--list1.rend()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reverse_iterator&>(--list1.crend()));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, postdecrement_type) {\n+  EXPECT_TRUE(is_expected_type<List1::iterator>(list1.end()--));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(list1.cend()--));\n+  EXPECT_TRUE(is_expected_type<List1::reverse_iterator>(list1.rend()--));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(list1.crend()--));\n+}\n+\n+class IntrusiveListTestPreStepper : public IntrusiveListTestWithList1 {\n+public:\n+  template<typename Stepper, typename It>\n+  void test_prestepper(Stepper step, It it, size_t idx, size_t idx1) {\n+    It it1 = it;\n+    EXPECT_EQ(it, it1);\n+    EXPECT_EQ(values[idx], it->This());\n+    EXPECT_EQ(values[idx], it1->This());\n+\n+    It it2 = step(it);\n+    EXPECT_NE(it, it1);\n+    EXPECT_EQ(it, it2);\n+    EXPECT_NE(it1, it2);\n+    EXPECT_EQ(values[idx1], it->This());\n+    EXPECT_EQ(values[idx], it1->This());\n+    EXPECT_EQ(values[idx1], it2->This());\n+\n+    It it3 = step(it1);\n+    EXPECT_EQ(it, it1);\n+    EXPECT_EQ(it, it2);\n+    EXPECT_EQ(it, it3);\n+    EXPECT_EQ(values[idx1], it->This());\n+    EXPECT_EQ(values[idx1], it1->This());\n+    EXPECT_EQ(values[idx1], it2->This());\n+    EXPECT_EQ(values[idx1], it3->This());\n+  }\n+\n+  template<bool increment> struct PreStepper;\n+};\n+\n+template<bool increment>\n+struct IntrusiveListTestPreStepper::PreStepper {\n+  template<typename It> It& operator()(It& it) const { return ++it; }\n+};\n+\n+template<>\n+struct IntrusiveListTestPreStepper::PreStepper<false> {\n+  template<typename It> It& operator()(It& it) const { return --it; }\n+};\n+\n+TEST_F(IntrusiveListTestPreStepper, preincrement) {\n+  PreStepper<true> step;\n+  {\n+    SCOPED_TRACE(\"forward non-const iterator\");\n+    test_prestepper(step, list1.begin(), 0, 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"forward const iterator\");\n+    test_prestepper(step, list1.cbegin(), 0, 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse non-const iterator\");\n+    test_prestepper(step, list1.rbegin(), nvalues - 1, nvalues - 2);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse const iterator\");\n+    test_prestepper(step, list1.crbegin(), nvalues - 1, nvalues - 2);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestPreStepper, predecrement) {\n+  PreStepper<false> step;\n+  {\n+    SCOPED_TRACE(\"forward non-const iterator\");\n+    test_prestepper(step, ++list1.begin(), 1, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"forward const iterator\");\n+    test_prestepper(step, ++list1.cbegin(), 1, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse non-const iterator\");\n+    test_prestepper(step, ++list1.rbegin(), nvalues - 2, nvalues - 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse const iterator\");\n+    test_prestepper(step, ++list1.crbegin(), nvalues - 2, nvalues - 1);\n+  }\n+}\n+\n+class IntrusiveListTestPostStepper : public IntrusiveListTestWithList1 {\n+public:\n+  template<typename Stepper, typename It>\n+  void test_poststepper(Stepper step, It it, size_t idx, size_t idx1) {\n+    It it1 = it;\n+    EXPECT_EQ(it, it1);\n+    EXPECT_EQ(values[idx], it->This());\n+    EXPECT_EQ(values[idx], it1->This());\n+\n+    It it2 = step(it);\n+    EXPECT_NE(it, it2);\n+    EXPECT_EQ(it1, it2);\n+    EXPECT_EQ(values[idx1], it->This());\n+    EXPECT_EQ(values[idx], it1->This());\n+    EXPECT_EQ(values[idx], it2->This());\n+\n+    It it3 = step(it1);\n+    EXPECT_EQ(it, it1);\n+    EXPECT_EQ(it2, it3);\n+    EXPECT_NE(it, it2);\n+    EXPECT_NE(it, it3);\n+    EXPECT_NE(it1, it2);\n+    EXPECT_NE(it1, it3);\n+    EXPECT_EQ(values[idx1], it->This());\n+    EXPECT_EQ(values[idx1], it1->This());\n+    EXPECT_EQ(values[idx], it2->This());\n+    EXPECT_EQ(values[idx], it3->This());\n+  }\n+\n+  template<bool increment> struct PostStepper;\n+};\n+\n+template<bool increment>\n+struct IntrusiveListTestPostStepper::PostStepper {\n+  template<typename It> It operator()(It& it) const { return it++; }\n+};\n+\n+template<>\n+struct IntrusiveListTestPostStepper::PostStepper<false> {\n+  template<typename It> It operator()(It& it) const { return it--; }\n+};\n+\n+TEST_F(IntrusiveListTestPostStepper, postincrement) {\n+  PostStepper<true> step;\n+  {\n+    SCOPED_TRACE(\"forward non-const iterator\");\n+    test_poststepper(step, list1.begin(), 0, 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"forward const iterator\");\n+    test_poststepper(step, list1.cbegin(), 0, 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse non-const iterator\");\n+    test_poststepper(step, list1.rbegin(), nvalues - 1, nvalues - 2);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse const iterator\");\n+    test_poststepper(step, list1.crbegin(), nvalues - 1, nvalues - 2);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestPostStepper, postdecrement) {\n+  PostStepper<false> step;\n+  {\n+    SCOPED_TRACE(\"forward non-const iterator\");\n+    test_poststepper(step, ++list1.begin(), 1, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"forward const iterator\");\n+    test_poststepper(step, ++list1.cbegin(), 1, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse non-const iterator\");\n+    test_poststepper(step, ++list1.rbegin(), nvalues - 2, nvalues - 1);\n+  }\n+  {\n+    SCOPED_TRACE(\"reverse const iterator\");\n+    test_poststepper(step, ++list1.crbegin(), nvalues - 2, nvalues - 1);\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ operator==\n+\/\/ operator!=\n+\/\/ operator== with peer, both argument orders\n+\/\/ operator!= with peer, both argument orders\n+\n+template<typename It, typename CIt>\n+static void test_iterator_compare(It it, CIt cit) {\n+  It it1 = it;\n+  It it2 = it1;\n+  ++it2;\n+\n+  CIt cit1 = cit;\n+  CIt cit2 = cit1;\n+  ++cit2;\n+\n+  EXPECT_EQ(it, it1);\n+  EXPECT_NE(it, it2);\n+\n+  EXPECT_EQ(cit, cit1);\n+  EXPECT_NE(cit, cit2);\n+\n+  EXPECT_EQ(it, cit);\n+  EXPECT_EQ(cit, it);\n+  EXPECT_NE(it, cit2);\n+  EXPECT_NE(cit2, it);\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, compare) {\n+  test_iterator_compare(list1.begin(), list1.cbegin());\n+  test_iterator_compare(list1.rbegin(), list1.crbegin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ pop_front\n+\/\/ pop_back\n+\/\/ pop_front_and_dispose\n+\/\/ pop_back_and_dispose\n+\n+TEST_F(IntrusiveListTestWithDisposal, pop) {\n+  ASSERT_EQ(nvalues, list1.length());\n+  ASSERT_EQ(values[0], list1.front().This());\n+  ASSERT_EQ(values[nvalues - 1], list1.back().This());\n+\n+  list1.pop_front();\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(values[1], list1.front().This());\n+\n+  list1.pop_front_and_dispose(CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - 2, list1.length());\n+  EXPECT_EQ(values[2], list1.front().This());\n+  EXPECT_EQ(1u, ndisposed);\n+  EXPECT_EQ(values[1], disposed[0]);\n+\n+  list1.pop_back();\n+  EXPECT_EQ(nvalues - 3, list1.length());\n+  EXPECT_EQ(values[nvalues - 2], list1.back().This());\n+\n+  list1.pop_back_and_dispose(CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - 4, list1.length());\n+  EXPECT_EQ(values[nvalues - 3], list1.back().This());\n+  EXPECT_EQ(2u, ndisposed);\n+  EXPECT_EQ(values[nvalues - 2], disposed[1]);\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ front -- const and non-const\n+\/\/ back -- const and non-const\n+\n+TEST_F(IntrusiveListTestWithList1, end_access) {\n+  const List1& clist1 = list1;\n+\n+  EXPECT_TRUE(is_expected_ref_type<List1::reference>(list1.front()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::reference>(list1.back()));\n+\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reference>(clist1.front()));\n+  EXPECT_TRUE(is_expected_ref_type<List1::const_reference>(clist1.back()));\n+\n+  EXPECT_EQ(values[0], list1.front().This());\n+  EXPECT_EQ(values[0], clist1.front().This());\n+\n+  EXPECT_EQ(values[nvalues - 1], list1.back().This());\n+  EXPECT_EQ(values[nvalues - 1], clist1.back().This());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ begin -- const and non-const\n+\/\/ cbegin\n+\/\/ end -- const and non-const\n+\/\/ cend\n+\/\/ rbegin -- const and non-const\n+\/\/ crbegin\n+\/\/ rend -- const and non-const\n+\/\/ crend\n+\n+TEST_F(IntrusiveListTestWithList1, iter_type) {\n+  const List1& clist1 = list1;\n+\n+  EXPECT_TRUE(is_expected_type<List1::iterator>(list1.begin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(clist1.begin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(list1.cbegin()));\n+\n+  EXPECT_TRUE(is_expected_type<List1::iterator>(list1.end()));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(clist1.end()));\n+  EXPECT_TRUE(is_expected_type<List1::const_iterator>(list1.cend()));\n+\n+  EXPECT_TRUE(is_expected_type<List1::reverse_iterator>(list1.rbegin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(clist1.rbegin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(list1.crbegin()));\n+\n+  EXPECT_TRUE(is_expected_type<List1::reverse_iterator>(list1.rbegin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(clist1.rbegin()));\n+  EXPECT_TRUE(is_expected_type<List1::const_reverse_iterator>(list1.crbegin()));\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, iters) {\n+  const List1& clist1 = list1;\n+\n+  List1::pointer front = values[0];\n+  List1::pointer back = values[nvalues - 1];\n+\n+  EXPECT_EQ(front, list1.begin()->This());\n+  EXPECT_EQ(front, clist1.begin()->This());\n+  EXPECT_EQ(front, list1.cbegin()->This());\n+\n+  EXPECT_EQ(back, (--list1.end())->This());\n+  EXPECT_EQ(back, (--clist1.end())->This());\n+  EXPECT_EQ(back, (--list1.cend())->This());\n+\n+  EXPECT_EQ(back, list1.rbegin()->This());\n+  EXPECT_EQ(back, clist1.rbegin()->This());\n+  EXPECT_EQ(back, list1.crbegin()->This());\n+\n+  EXPECT_EQ(front, (--list1.rend())->This());\n+  EXPECT_EQ(front, (--clist1.rend())->This());\n+  EXPECT_EQ(front, (--list1.crend())->This());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ erase -- one and range, forward and reversed\n+\/\/ erase_and_dispose -- one and range, forward and reversed\n+\n+TEST_F(IntrusiveListTestWithList1, erase1) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = step;\n+  List1::const_iterator it = step_iterator(list1.begin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::iterator nit = list1.erase(it);\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index + 1, nit->value());\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, erase1_reversed) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = (nvalues - 1) - step;\n+  List1::const_reverse_iterator it = step_iterator(list1.rbegin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::reverse_iterator nit = list1.erase(it);\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index - 1, nit->value());\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.rbegin());\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase1_dispose) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = step;\n+  List1::const_iterator it = step_iterator(list1.begin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::iterator nit = list1.erase_and_dispose(it, CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index + 1, nit->value());\n+\n+  EXPECT_EQ(1u, ndisposed);\n+  EXPECT_EQ(value.value(), disposed[0]->value());\n+  EXPECT_EQ(value.This(), disposed[0]);\n+\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, erase_element) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = step;\n+  List1::const_iterator it = step_iterator(list1.begin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::iterator nit = list1.erase(value);\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index + 1, nit->value());\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase1_dispose_reversed) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = (nvalues - 1) - step;\n+  List1::const_reverse_iterator it = step_iterator(list1.rbegin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::reverse_iterator nit = list1.erase_and_dispose(it, CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index - 1, nit->value());\n+\n+  EXPECT_EQ(1u, ndisposed);\n+  EXPECT_EQ(value.value(), disposed[0]->value());\n+  EXPECT_EQ(value.This(), disposed[0]);\n+\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.rbegin());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, erase2) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step1 = 2;\n+  unsigned index1 = step1;\n+  List1::const_iterator it1 = step_iterator(list1.begin(), step1);\n+  List1::const_reference value1 = *it1;\n+  EXPECT_EQ(index1, value1.value());\n+\n+  int step2 = 2;\n+  unsigned index2 = index1 + step2;\n+  List1::const_iterator it2 = step_iterator(it1, step2);\n+  List1::const_reference value2 = *it2;\n+  EXPECT_EQ(index2, value2.value());\n+\n+  List1::iterator nit = list1.erase(it1, it2);\n+  EXPECT_EQ(nvalues - step2, list1.length());\n+  EXPECT_EQ(index2, nit->value());\n+  EXPECT_EQ(it2, nit);\n+\n+  nit = step_iterator(nit, -step1);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+TEST_F(IntrusiveListTestWithList1, erase2_reversed) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step1 = 2;\n+  unsigned index1 = (nvalues - 1) - step1;\n+  List1::const_reverse_iterator it1 = step_iterator(list1.rbegin(), step1);\n+  List1::const_reference value1 = *it1;\n+  EXPECT_EQ(index1, value1.value());\n+\n+  int step2 = 2;\n+  unsigned index2 = index1 - step2;\n+  List1::const_reverse_iterator it2 = step_iterator(it1, step2);\n+  List1::const_reference value2 = *it2;\n+  EXPECT_EQ(index2, value2.value());\n+\n+  List1::reverse_iterator nit = list1.erase(it1, it2);\n+  EXPECT_EQ(nvalues - step2, list1.length());\n+  EXPECT_EQ(index2, nit->value());\n+  EXPECT_EQ(it2, nit);\n+\n+  nit = step_iterator(nit, -step1);\n+  EXPECT_EQ(nit, list1.rbegin());\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase2_dispose) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step1 = 2;\n+  unsigned index1 = step1;\n+  List1::const_iterator it1 = step_iterator(list1.begin(), step1);\n+  List1::const_reference value1 = *it1;\n+  EXPECT_EQ(index1, value1.value());\n+\n+  int step2 = 1;\n+  unsigned index2 = index1 + step2;\n+  List1::const_iterator it2 = step_iterator(it1, step2);\n+  List1::const_reference value2 = *it2;\n+  EXPECT_EQ(index2, value2.value());\n+\n+  int step3 = step2 + 1;\n+  unsigned index3 = index1 + step3;\n+  ++it2;\n+  List1::iterator nit = list1.erase_and_dispose(it1, it2, CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - step3, list1.length());\n+  EXPECT_EQ(index3, nit->value());\n+  EXPECT_EQ(it2, nit);\n+\n+  EXPECT_EQ(unsigned(step3), ndisposed);\n+  EXPECT_EQ(value1.value(), disposed[0]->value());\n+  EXPECT_EQ(value1.This(), disposed[0]);\n+  EXPECT_EQ(value2.value(), disposed[1]->value());\n+  EXPECT_EQ(value2.This(), disposed[1]);\n+\n+  nit = step_iterator(nit, -step1);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase2_dispose_reversed) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step1 = 2;\n+  unsigned index1 = (nvalues - 1) - step1;\n+  List1::const_reverse_iterator it1 = step_iterator(list1.rbegin(), step1);\n+  List1::const_reference value1 = *it1;\n+  EXPECT_EQ(index1, value1.value());\n+\n+  int step2 = 1;\n+  unsigned index2 = index1 - step2;\n+  List1::const_reverse_iterator it2 = step_iterator(it1, step2);\n+  List1::const_reference value2 = *it2;\n+  EXPECT_EQ(index2, value2.value());\n+\n+  int step3 = step2 + 1;\n+  unsigned index3 = index1 - step3;\n+  ++it2;\n+  List1::reverse_iterator nit = list1.erase_and_dispose(it1, it2, CollectingDisposer(this));\n+  EXPECT_EQ(nvalues - step3, list1.length());\n+  EXPECT_EQ(index3, nit->value());\n+  EXPECT_EQ(it2, nit);\n+\n+  EXPECT_EQ(unsigned(step3), ndisposed);\n+  EXPECT_EQ(value1.value(), disposed[0]->value());\n+  EXPECT_EQ(value1.This(), disposed[0]);\n+  EXPECT_EQ(value2.value(), disposed[1]->value());\n+  EXPECT_EQ(value2.This(), disposed[1]);\n+\n+  nit = step_iterator(nit, -step1);\n+  EXPECT_EQ(nit, list1.rbegin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ erase_if\n+\/\/ erase_and_dispose_if\n+\n+TEST_F(IntrusiveListTestWithList1, erase_if) {\n+  EXPECT_EQ(nvalues, list1.length());\n+  EXPECT_TRUE(is_even(nvalues));\n+\n+  auto has_even_value = [&](List1::const_reference v) { return is_even(v.value()); };\n+  List1::size_type removed = list1.erase_if(has_even_value);\n+\n+  EXPECT_EQ(nvalues \/ 2, removed);\n+  EXPECT_EQ(nvalues \/ 2, list1.length());\n+\n+  size_t i = 0;\n+  for (List1::const_reference v : list1) {\n+    EXPECT_EQ(++i, v.value());\n+    i += 1;\n+  }\n+  EXPECT_EQ(i, nvalues);\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase_and_dispose_if) {\n+  EXPECT_EQ(nvalues, list1.length());\n+  EXPECT_TRUE((nvalues & 1) == 0);\n+\n+  auto has_even_value = [&](List1::const_reference v) { return is_even(v.value()); };\n+  List1::size_type removed\n+    = list1.erase_and_dispose_if(has_even_value, CollectingDisposer(this));\n+\n+  EXPECT_EQ(nvalues \/ 2, removed);\n+  EXPECT_EQ(nvalues \/ 2, list1.length());\n+\n+  {\n+    size_t i = 0;\n+    for (List1::const_reference v : list1) {\n+      EXPECT_EQ(++i, v.value());\n+      i += 1;\n+    }\n+    EXPECT_EQ(i, nvalues);\n+  }\n+  {\n+    EXPECT_EQ(nvalues \/ 2, ndisposed);\n+    size_t i = 0;\n+    for ( ; i < ndisposed; ++i) {\n+      EXPECT_TRUE(disposed[i] != nullptr);\n+      EXPECT_EQ(disposed[i]->value(), 2 * i);\n+    }\n+    for ( ; i < nvalues; ++i) {\n+      EXPECT_TRUE(disposed[i] == nullptr);\n+    }\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ clear\n+\/\/ clear_and_dispose\n+\n+TEST_F(IntrusiveListTestWithList1, clear) {\n+  EXPECT_FALSE(list1.empty());\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  list1.clear();\n+  EXPECT_TRUE(list1.empty());\n+  EXPECT_EQ(0u, list1.length());\n+\n+  \/\/ verify all values can be reinserted.\n+  fill_list();\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, clear_dispose) {\n+  EXPECT_FALSE(list1.empty());\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  list1.clear_and_dispose(CollectingDisposer(this));\n+  EXPECT_TRUE(list1.empty());\n+  EXPECT_EQ(0u, list1.length());\n+  EXPECT_EQ(nvalues, ndisposed);\n+\n+  for (size_t i = 0; i < nvalues; ++i) {\n+    EXPECT_EQ(values[i], disposed[i]);\n+  }\n+\n+  \/\/ verify all values can be reinserted.\n+  fill_list();\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ insert\n+\n+TEST_F(IntrusiveListTestWithList1, insert) {\n+  List1::pointer pvalue = values[0];\n+  EXPECT_EQ(pvalue, list1.begin()->This());\n+  list1.pop_front();\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_NE(pvalue, list1.begin()->This());\n+\n+  List1::iterator it = step_iterator(list1.begin(), 3);\n+  EXPECT_EQ(values[4], it->This());\n+\n+  List1::iterator nit = list1.insert(it, *pvalue);\n+  EXPECT_EQ(values[4], it->This());\n+  EXPECT_EQ(nvalues, list1.length());\n+  EXPECT_EQ(pvalue, nit->This());\n+  EXPECT_NE(it, nit);\n+  EXPECT_EQ(it, ++nit);\n+  nit = step_iterator(nit, -4);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ splice\n+\n+class IntrusiveListTestSplice : public IntrusiveListTestWithValues {\n+public:\n+  IntrusiveListTestSplice() {\n+    fill_lists();\n+  }\n+\n+  ~IntrusiveListTestSplice() {\n+    clear_lists();\n+  }\n+\n+  static const size_t group_size = nvalues \/ 2;\n+  List1 list_a;\n+  List1 list_b;\n+\n+  void fill_lists() {\n+    for (size_t i = 0; i < group_size; ++i) {\n+      list_a.push_back(*values[i]);\n+      list_b.push_back(*values[i + group_size]);\n+    }\n+  }\n+\n+  void clear_lists() {\n+    list_a.clear();\n+    list_b.clear();\n+  }\n+\n+  template<typename Iterator1, typename Iterator2>\n+  void check(Iterator1 start, Iterator2 end, size_t index) const {\n+    for (Iterator1 it = start; it != end; ++it) {\n+      ASSERT_EQ(values[index++], &*it);\n+    }\n+  }\n+};\n+\n+TEST_F(IntrusiveListTestSplice, splice_all_front) {\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator b_begin = list_b.begin();\n+\n+  List1::iterator sresult = list_a.splice(a_begin, list_b);\n+  EXPECT_EQ(list_a.begin(), sresult);\n+  EXPECT_EQ(list_a.length(), a_size + b_size);\n+  EXPECT_TRUE(list_b.empty());\n+  EXPECT_EQ(b_begin, list_a.cbegin());\n+  EXPECT_EQ(a_end, list_a.cend());\n+  {\n+    SCOPED_TRACE(\"check new values\");\n+    check(list_a.cbegin(), a_begin, group_size);\n+  }\n+  {\n+    SCOPED_TRACE(\"check old values\");\n+    check(a_begin, list_a.cend(), 0);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_all_back) {\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator a_penult = --List1::iterator(a_end);\n+  List1::iterator b_begin = list_b.begin();\n+\n+  List1::iterator sresult = list_a.splice(list_a.end(), list_b);\n+  EXPECT_EQ(++a_penult, List1::iterator(sresult));\n+  EXPECT_EQ(list_a.length(), a_size + b_size);\n+  EXPECT_TRUE(list_b.empty());\n+  EXPECT_EQ(a_begin, list_a.cbegin());\n+  EXPECT_EQ(a_end, list_a.cend());\n+  {\n+    SCOPED_TRACE(\"check old values\");\n+    check(list_a.cbegin(), b_begin, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"check new values\");\n+    check(b_begin, list_a.cend(), group_size);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_all_middle) {\n+  const size_t middle_distance = 2;\n+  STATIC_ASSERT(middle_distance < group_size);\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_middle = step_iterator(a_begin, middle_distance);\n+  List1::iterator a_pre_middle = --List1::iterator(a_middle);\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator b_begin = list_b.begin();\n+\n+  List1::iterator sresult = list_a.splice(a_middle, list_b);\n+  EXPECT_EQ(++a_pre_middle, List1::iterator(sresult));\n+  EXPECT_EQ(list_a.length(), a_size + b_size);\n+  EXPECT_TRUE(list_b.empty());\n+  EXPECT_EQ(a_begin, list_a.cbegin());\n+  EXPECT_EQ(a_end, list_a.cend());\n+  {\n+    SCOPED_TRACE(\"check initial old values\");\n+    check(a_begin, b_begin, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"check new values\");\n+    check(b_begin, a_middle, group_size);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing old values\");\n+    check(a_middle, a_end, middle_distance);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_some_middle) {\n+  const size_t middle_distance = 2;\n+  STATIC_ASSERT(middle_distance < group_size);\n+  const size_t move_start = 1;\n+  STATIC_ASSERT(move_start < group_size);\n+  const size_t move_size = 2;\n+  STATIC_ASSERT(move_start + move_size < group_size);\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_middle = step_iterator(a_begin, middle_distance);\n+  List1::iterator a_pre_middle = --List1::iterator(a_middle);\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator b_begin = list_b.begin();\n+  List1::iterator b_move_start = step_iterator(b_begin, move_start);\n+  List1::iterator b_move_end = step_iterator(b_move_start, move_size);\n+  List1::iterator b_end = list_b.end();\n+\n+  List1::iterator sresult = list_a.splice(a_middle, list_b, b_move_start, b_move_end);\n+  EXPECT_EQ(++a_pre_middle, List1::iterator(sresult));\n+  EXPECT_EQ(list_a.length(), a_size + move_size);\n+  EXPECT_EQ(list_b.length(), b_size - move_size);\n+  EXPECT_EQ(a_begin, list_a.cbegin());\n+  EXPECT_EQ(a_end, list_a.cend());\n+  EXPECT_EQ(b_begin, list_b.cbegin());\n+  EXPECT_EQ(b_end, list_b.cend());\n+  {\n+    SCOPED_TRACE(\"check initial a values\");\n+    check(list_a.cbegin(), b_move_start, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"check new a values\");\n+    check(b_move_start, a_middle, group_size + move_start);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing a values\");\n+    check(a_middle, list_a.cend(), middle_distance);\n+  }\n+  {\n+    SCOPED_TRACE(\"check initial b values\");\n+    check(b_begin, b_move_end, group_size);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing b values\");\n+    check(b_move_end, b_end, group_size + move_start + move_size);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_one_front) {\n+  const size_t move_start = 1;\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator b_begin = list_b.begin();\n+  List1::iterator b_move_start = step_iterator(b_begin, move_start);\n+  List1::iterator b_move_end = step_iterator(b_move_start, 1);\n+  List1::iterator b_end = list_b.end();\n+\n+  List1::iterator sresult = list_a.splice(a_begin, list_b, b_move_start);\n+  EXPECT_EQ(list_a.begin(), sresult);\n+  EXPECT_EQ(list_a.length(), a_size + 1);\n+  EXPECT_EQ(list_b.length(), b_size - 1);\n+  EXPECT_EQ(a_begin, ++list_a.begin());\n+  EXPECT_EQ(a_end, list_a.end());\n+  EXPECT_EQ(b_begin, list_b.begin());\n+  EXPECT_EQ(b_end, list_b.end());\n+  {\n+    SCOPED_TRACE(\"check new leading a values\");\n+    check(list_a.cbegin(), a_begin, group_size + move_start);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing a values\");\n+    check(a_begin, a_end, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"check initial b values\");\n+    check(b_begin, b_move_end, group_size);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing b values\");\n+    check(b_move_end, b_end, group_size + move_start + 1);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_one_back) {\n+  const size_t move_start = 1;\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator a_penult = --List1::iterator(a_end);\n+  List1::iterator b_begin = list_b.begin();\n+  List1::iterator b_move_start = step_iterator(b_begin, move_start);\n+  List1::iterator b_move_end = step_iterator(b_move_start, 1);\n+  List1::iterator b_end = list_b.end();\n+\n+  List1::iterator sresult = list_a.splice(a_end, list_b, b_move_start);\n+  EXPECT_EQ(++a_penult, List1::const_iterator(sresult));\n+  EXPECT_EQ(++a_penult, a_end);\n+  EXPECT_EQ(list_a.length(), a_size + 1);\n+  EXPECT_EQ(list_b.length(), b_size - 1);\n+  EXPECT_EQ(a_begin, list_a.begin());\n+  EXPECT_EQ(a_end, list_a.end());\n+  {\n+    SCOPED_TRACE(\"check old values\");\n+    check(list_a.cbegin(), b_move_start, 0);\n+  }\n+  {\n+    SCOPED_TRACE(\"check new values\");\n+    check(b_move_start, list_a.cend(), group_size + move_start);\n+  }\n+  {\n+    SCOPED_TRACE(\"check initial a values\");\n+    check(b_begin, b_move_end, group_size);\n+  }\n+  {\n+    SCOPED_TRACE(\"check trailing b values\");\n+    check(b_move_end, b_end, group_size + move_start + 1);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_one_in_place) {\n+  const size_t move_start = 1;\n+  size_t a_size = list_a.length();\n+  List1::iterator a_begin = list_a.begin();\n+  List1::iterator a_end = list_a.end();\n+  List1::iterator a_move_start = step_iterator(a_begin, move_start);\n+  List1::iterator a_move_end = step_iterator(a_move_start, 1);\n+\n+  List1::iterator sresult = list_a.splice(a_move_end, list_a, a_move_start);\n+  EXPECT_EQ(a_move_start, List1::const_iterator(sresult));\n+  EXPECT_EQ(list_a.length(), a_size);\n+  EXPECT_EQ(list_a.begin(), a_begin);\n+  EXPECT_EQ(list_a.end(), a_end);\n+  EXPECT_EQ(a_move_start, step_iterator(a_begin, move_start));\n+  EXPECT_EQ(a_move_end, step_iterator(a_begin, move_start + 1));\n+  {\n+    SCOPED_TRACE(\"check values\");\n+    check(a_begin, a_end, 0);\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestSplice, splice_into_const) {\n+  CList1 clist{};\n+  size_t a_size = list_a.length();\n+  size_t b_size = list_b.length();\n+  CList1::iterator sresult_a = clist.splice(clist.end(), list_a);\n+  CList1::iterator sresult_b = clist.splice(clist.end(), list_b);\n+  EXPECT_EQ(clist.length(), a_size + b_size);\n+  EXPECT_EQ(sresult_a, clist.begin());\n+  {\n+    SCOPED_TRACE(\"check values\");\n+    check(clist.begin(), clist.end(), 0);\n+  }\n+  \/\/ This doesn't compile, which is as expected.  Transfer from list with\n+  \/\/ const elements to a list with non-const elements is disallowed, because\n+  \/\/ it implicitly casts away const.\n+  \/\/ List1::iterator sresult_c = list_a.splice(list_a.end(), clist);\n+  clist.clear();\n+}\n+\n+TEST_F(IntrusiveListTestSplice, swap) {\n+  List1::reference front_a = list_a.front();\n+  List1::reference front_b = list_b.front();\n+  list_a.swap(list_b);\n+  EXPECT_EQ(&front_a, &list_b.front());\n+  EXPECT_EQ(&front_b, &list_a.front());\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ iterator_to - const and non-const\n+\n+#define CHECK_ITERATOR_TYPE(the_iterator, expected_type)                    \\\n+  static_assert(std::is_same<decltype(the_iterator), expected_type>::value, \\\n+                \"unexpected iterator type\")                                 \\\n+  \/* *\/\n+\n+TEST_F(IntrusiveListTestWithList1, iterator_to) {\n+  {\n+    List1::pointer pvalue = values[3];\n+    auto it = list1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    List1::const_pointer pvalue = values[3];\n+    auto it = list1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    List1::pointer pvalue = values[3];\n+    auto it = list1.const_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    const List1& clist1 = list1;\n+    List1::pointer pvalue = values[3];\n+    auto it = clist1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    List1::pointer pvalue = values[3];\n+    auto it = list1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    List1::const_pointer pvalue = values[3];\n+    auto it = list1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    List1::pointer pvalue = values[3];\n+    auto it = list1.const_reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    const List1& clist1 = list1;\n+    List1::pointer pvalue = values[3];\n+    auto it = clist1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, List1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestWithCList1, iterator_to_const) {\n+  {\n+    CList1::pointer pvalue = values[3];\n+    auto it = list1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    CList1::const_pointer pvalue = values[3];\n+    auto it = list1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    CList1::pointer pvalue = values[3];\n+    auto it = list1.const_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    const CList1& clist1 = list1;\n+    CList1::pointer pvalue = values[3];\n+    auto it = clist1.iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    CList1::pointer pvalue = values[3];\n+    auto it = list1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    CList1::const_pointer pvalue = values[3];\n+    auto it = list1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    CList1::pointer pvalue = values[3];\n+    auto it = list1.const_reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+\n+  {\n+    const CList1& clist1 = list1;\n+    CList1::pointer pvalue = values[3];\n+    auto it = clist1.reverse_iterator_to(*pvalue);\n+    CHECK_ITERATOR_TYPE(it, CList1::const_reverse_iterator);\n+    EXPECT_EQ(pvalue, it->This());\n+  }\n+}\n+\n+#undef CHECK_ITERATOR_TYPE\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ optional constant-time size\n+\n+class IntrusiveListTestWithSize : public IntrusiveListTestWithValues {\n+  typedef IntrusiveListTestWithValues super;\n+\n+public:\n+  typedef IntrusiveList<Value, &Value::entry1, true> ListWithSize;\n+\n+  void SetUp() override {\n+    super::SetUp();\n+    fill_list();\n+  }\n+\n+  void TearDown() override {\n+    list.clear();\n+    EXPECT_EQ(0u, list.size());\n+    EXPECT_EQ(list.length(), list.size());\n+    super::TearDown();\n+  }\n+\n+  void fill_list() {\n+    for (size_t i = 0; i < nvalues; ++i) {\n+      if (is_even(i)) {\n+        list.push_back(*values[i]);\n+      } else {\n+        list.push_front(*values[i]);\n+      }\n+      EXPECT_EQ(i + 1, list.size());\n+      EXPECT_EQ(list.length(), list.size());\n+    }\n+  }\n+\n+  struct NopDisposer {\n+    void operator()(const Value* value) const {}\n+  };\n+\n+  ListWithSize list;\n+};\n+\n+\/\/ Test push_front\/back and clear.\n+\/\/ Everything is in the setup\/teardown\n+TEST_F(IntrusiveListTestWithSize, basics) {}\n+\n+TEST_F(IntrusiveListTestWithSize, pop) {\n+  size_t expected = nvalues;\n+  STATIC_ASSERT(4 <= nvalues);\n+\n+  list.pop_back();\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+\n+  list.pop_back_and_dispose(NopDisposer());\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+\n+  list.pop_front();\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+\n+  list.pop_front_and_dispose(NopDisposer());\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+}\n+\n+TEST_F(IntrusiveListTestWithSize, erase) {\n+  typedef ListWithSize::const_iterator const_iterator;\n+\n+  size_t expected = nvalues;\n+  STATIC_ASSERT(7 <= nvalues);\n+\n+  list.erase(++list.begin());\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+\n+  list.erase_and_dispose(++list.begin(), NopDisposer());\n+  --expected;\n+  EXPECT_EQ(expected, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+\n+  {\n+    const_iterator start = ++list.begin();\n+    const_iterator end = step_iterator(start, 2);\n+    list.erase(start, end);\n+    expected -= 2;\n+    EXPECT_EQ(expected, list.size());\n+    EXPECT_EQ(list.length(), list.size());\n+  }\n+\n+  {\n+    const_iterator start = ++list.begin();\n+    const_iterator end = step_iterator(start, 2);\n+    list.erase_and_dispose(start, end, NopDisposer());\n+    expected -= 2;\n+    EXPECT_EQ(expected, list.size());\n+    EXPECT_EQ(list.length(), list.size());\n+  }\n+}\n+\n+TEST_F(IntrusiveListTestWithSize, splice) {\n+  using iterator = ListWithSize::iterator;\n+  List1 list1;\n+\n+  \/\/ Transfer part of list to list1.\n+  iterator from = step_iterator(list.begin(), 2);\n+  iterator to = step_iterator(from, 4);\n+  list1.splice(list1.end(), list, from, to);\n+  EXPECT_EQ(nvalues - 4, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+  EXPECT_EQ(4u, list1.length());\n+\n+  \/\/ Transfer all of list1 back to list.\n+  list.splice(to, list1);\n+  EXPECT_EQ(nvalues, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+  EXPECT_TRUE(list1.empty());\n+\n+  \/\/ Transfer all of list to list1.\n+  \/\/ Transferring entire list having size() operation is special-cased.\n+  list1.splice(list1.end(), list);\n+  EXPECT_EQ(0u, list.size());\n+  EXPECT_EQ(list.length(), list.size());\n+  EXPECT_TRUE(list.empty());\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  list1.clear();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_intrusiveList.cpp","additions":1644,"deletions":0,"binary":false,"changes":1644,"status":"added"}]}