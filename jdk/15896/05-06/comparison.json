{"files":[{"patch":"@@ -74,2 +74,2 @@\n- * * T is the class of the elements in the list.  Must be a possibly\n- * const-qualified class type.\n+ * * T is the class of the elements in the list.  Must be a class type,\n+ * possibly const-qualified.\n@@ -86,2 +86,2 @@\n- * used to specify the allocation class.  The default is void, indicating\n- * no allocation class for the list.\n+ * used to specify the allocation class, such as CHeapObj<>.  The default\n+ * is void, indicating the list is not derived from an allocation class.\n@@ -89,8 +89,12 @@\n- * The value type for a list may be const-qualified.  Such a list provides\n- * const iterators and access to const-qualified elements.  A list whose value\n- * type is not const-qualified can provide both const and non-const iterators\n- * and can provide access to either const or unqualified elements, depending\n- * on the operation used.  A list that is itself const only provides const\n- * iterators and access to const-qualified elements.  A const object cannot be\n- * added to a list whose value type is not const-qualified, as that would be\n- * an implicit casting away of the const qualifier.\n+ * A const-element iterator has a const-qualified element type.  Such an\n+ * iterator provides const-qualified access to the elements it designates.\n+ * A list's const_iterator type is always a const-element iterator type.\n+ *\n+ * A const-element list has a const-qualified element type.  Such a list\n+ * provides const-element iterators and const-qualified access to its\n+ * elements.  A const list similarly provides const access to elements, but\n+ * does not support changing the sequence of elements.\n+ *\n+ * A const object can only be added to a const-element list.  Adding a const\n+ * object to a non-const-element list would be an implicit casting away of the\n+ * object's const qualifier.\n@@ -139,1 +143,1 @@\n- *   usnig MyList = IntrusiveList<MyClass, &get_entry>;\n+ *   using MyList = IntrusiveList<MyClass, &get_entry>;\n@@ -201,0 +205,3 @@\n+\/\/ IntrusiveListImpl provides implementation support for IntrusiveList.\n+\/\/ There's nothing for clients to see here. That support is all private, with\n+\/\/ the IntrusiveList class given access via friendship.\n@@ -208,2 +215,0 @@\n-  \/\/ Nothing for clients to see here, everything is private.  Only\n-  \/\/ the IntrusiveList class template has access, via friendship.\n@@ -260,3 +265,3 @@\n-  \/\/ Conversion from T* to Entry*, along with relevant type aliases.  A\n-  \/\/ corresponding specialization is used directly by IntrusiveList,\n-  \/\/ and by the list's iterators.\n+  \/\/ Relevant type aliases.  A corresponding specialization is used directly\n+  \/\/ by IntrusiveList, and by the list's iterators to obtain their\n+  \/\/ corresponding nested types.\n@@ -365,2 +370,1 @@\n-  using const_reference = std::add_lvalue_reference_t<std::add_const_t<T>>;\n-  static const Entry& get_entry(const_reference v) {\n+  static const Entry& get_entry(typename ListTraits<T>::const_reference v) {\n@@ -602,5 +606,6 @@\n- * An iterator may be either const or non-const.  The value type of a const\n- * iterator is const-qualified, and a const iterator only provides access to\n- * const-qualified elements.  Similarly, a non-const iterator provides access\n- * to unqualified elements.  A non-const iterator can be implicitly converted\n- * to a const iterator, but not vice versa.\n+ * An iterator may be either const-element or non-const-element.  The value\n+ * type of a const-element iterator is const-qualified, and a const-element\n+ * iterator only provides access to const-qualified elements.  Similarly, a\n+ * non-const-element iterator provides access to unqualified elements.  A\n+ * non-const-element iterator can be converted to a const-element iterator,\n+ * but not vice versa.\n@@ -615,1 +620,1 @@\n-  static const bool _is_const = std::is_const<T>::value;\n+  static const bool _is_const_element = std::is_const<T>::value;\n@@ -622,3 +627,3 @@\n-  \/\/ be implicitly converted to this iterator type.  A const iterator type\n-  \/\/ supports implicit conversion from the corresponding non-const iterator\n-  \/\/ type.\n+  \/\/ be implicitly converted to this iterator type.  A const_element iterator\n+  \/\/ type supports implicit conversion from the corresponding\n+  \/\/ non-const-element iterator type.\n@@ -628,1 +633,1 @@\n-    return _is_const && std::is_same<From, NonConst>::value;\n+    return _is_const_element && std::is_same<From, NonConst>::value;\n@@ -776,1 +781,2 @@\n-  \/\/ additional overload to handle iterator == const_iterator.\n+  \/\/ additional overload to handle iterator == const_iterator when those\n+  \/\/ types are different.\n@@ -827,2 +833,2 @@\n-  \/\/ the same entry member, and either the receiver's element type is const or\n-  \/\/ neither element type is const.  A const element of a list cannot be\n+  \/\/ the same entry member, and either the receiver is a const-element list\n+  \/\/ or neither is a const-element list.  A const element of a list cannot be\n@@ -863,1 +869,1 @@\n-  \/** Type of a const pointer to a list element. *\/\n+  \/** Type of a pointer to a const list element. *\/\n@@ -869,1 +875,1 @@\n-  \/** Type of a const reference to a list element. *\/\n+  \/** Type of a reference to a const list element. *\/\n@@ -872,1 +878,1 @@\n-  \/** Forward iterator type allowing modification of elements. *\/\n+  \/** Forward iterator type. *\/\n@@ -876,1 +882,1 @@\n-  \/** Forward iterator type disallowing modification of elements. *\/\n+  \/** Forward iterator type with const elements. *\/\n@@ -880,1 +886,1 @@\n-  \/** Reverse iterator type allowing modification of elements. *\/\n+  \/** Reverse iterator type. *\/\n@@ -884,1 +890,1 @@\n-  \/** Reverse iterator type disallowing modification of elements. *\/\n+  \/** Reverse iterator type with const elements. *\/\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":45,"deletions":39,"binary":false,"changes":84,"status":"modified"}]}