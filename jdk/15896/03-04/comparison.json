{"files":[{"patch":"@@ -100,3 +100,3 @@\n- * argument, a const reference to a removed element.  This function should\n- * \"dispose\" of the argument object when called, such as by deleting the\n- * object.  The result of the call is ignored.\n+ * argument, of type pointer to T, to a removed element.  This function should\n+ * \"dispose\" of the argument object when called, such as by deleting it.  The\n+ * result of the call is ignored.\n@@ -1121,0 +1121,13 @@\n+  \/**\n+   * Removes v from the list.  Returns an iterator for the successor\n+   * of v in the list.  Invalidates iterators referring to v.\n+   *\n+   * precondition: v must be in the list.\n+   * complexity: constant.\n+   *\/\n+  iterator erase(const_reference v) {\n+    \/\/ This may seem a little roundabout, but it gets good debug-only error\n+    \/\/ checking with minimal source code and no additional overhead in release.\n+    return erase(iterator_to(v));\n+  }\n+\n@@ -1130,1 +1143,1 @@\n-    disposer(value);\n+    disposer(disposer_arg(value));\n@@ -1178,1 +1191,1 @@\n-        disposer(value);\n+        disposer(disposer_arg(value));\n@@ -1186,0 +1199,35 @@\n+  \/**\n+   * Conditionally removes elements from the list.  Successively calls the\n+   * predicate with a const_reference to each element of the list.  If the\n+   * result of such a call is true then that element is removed from the list.\n+   * Applies the disposer, if any, to each removed element.  The list may not\n+   * be in a consistent state when the disposer is called.  Returns the number\n+   * of removed elements.  Invalidates iterators referring to the removed\n+   * elements.\n+   *\n+   * complexity: O(length())\n+   *\/\n+\n+  template<typename Predicate>\n+  size_type erase_if(Predicate predicate) {\n+    return erase_and_dispose_if(predicate, NopDisposer());\n+  }\n+\n+  template<typename Predicate, typename Disposer>\n+  size_type erase_and_dispose_if(Predicate predicate, Disposer disposer) {\n+    const_iterator pos = cbegin();\n+    const_iterator end = cend();\n+    size_type removed = 0;\n+    while (pos != end) {\n+      const_reference v = *pos;\n+      if (predicate(v)) {\n+        pos = erase(pos);\n+        disposer(disposer_arg(v));\n+        ++removed;\n+      } else {\n+        ++pos;\n+      }\n+    }\n+    return removed;\n+  }\n+\n@@ -1518,1 +1566,1 @@\n-    void operator()(const_reference) const {}\n+    void operator()(pointer) const {}\n@@ -1521,0 +1569,6 @@\n+  \/\/ The pointer type is const-qualified per to the elements of the list, so\n+  \/\/ it's okay to possibly cast away const when disposing.\n+  static pointer disposer_arg(const_reference value) {\n+    return const_cast<pointer>(&value);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/intrusiveList.hpp","additions":60,"deletions":6,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -184,2 +185,2 @@\n-    void operator()(const Value& value) const {\n-      _test->disposed[_test->ndisposed++] = &value;\n+    void operator()(const Value* value) const {\n+      _test->disposed[_test->ndisposed++] = value;\n@@ -851,0 +852,17 @@\n+TEST_F(IntrusiveListTestWithList1, erase_element) {\n+  EXPECT_EQ(nvalues, list1.length());\n+\n+  int step = 2;\n+  unsigned index = step;\n+  List1::const_iterator it = step_iterator(list1.begin(), step);\n+  List1::const_reference value = *it;\n+  EXPECT_EQ(index, value.value());\n+  EXPECT_EQ(values[index], value.This());\n+\n+  List1::iterator nit = list1.erase(value);\n+  EXPECT_EQ(nvalues - 1, list1.length());\n+  EXPECT_EQ(index + 1, nit->value());\n+  nit = step_iterator(nit, -step);\n+  EXPECT_EQ(nit, list1.begin());\n+}\n+\n@@ -987,0 +1005,54 @@\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ erase_if\n+\/\/ erase_and_dispose_if\n+\n+TEST_F(IntrusiveListTestWithList1, erase_if) {\n+  EXPECT_EQ(nvalues, list1.length());\n+  EXPECT_TRUE(is_even(nvalues));\n+\n+  auto has_even_value = [&](List1::const_reference v) { return is_even(v.value()); };\n+  List1::size_type removed = list1.erase_if(has_even_value);\n+\n+  EXPECT_EQ(nvalues \/ 2, removed);\n+  EXPECT_EQ(nvalues \/ 2, list1.length());\n+\n+  size_t i = 0;\n+  for (List1::const_reference v : list1) {\n+    EXPECT_EQ(++i, v.value());\n+    i += 1;\n+  }\n+  EXPECT_EQ(i, nvalues);\n+}\n+\n+TEST_F(IntrusiveListTestWithDisposal, erase_and_dispose_if) {\n+  EXPECT_EQ(nvalues, list1.length());\n+  EXPECT_TRUE((nvalues & 1) == 0);\n+\n+  auto has_even_value = [&](List1::const_reference v) { return is_even(v.value()); };\n+  List1::size_type removed\n+    = list1.erase_and_dispose_if(has_even_value, CollectingDisposer(this));\n+\n+  EXPECT_EQ(nvalues \/ 2, removed);\n+  EXPECT_EQ(nvalues \/ 2, list1.length());\n+\n+  {\n+    size_t i = 0;\n+    for (List1::const_reference v : list1) {\n+      EXPECT_EQ(++i, v.value());\n+      i += 1;\n+    }\n+    EXPECT_EQ(i, nvalues);\n+  }\n+  {\n+    EXPECT_EQ(nvalues \/ 2, ndisposed);\n+    size_t i = 0;\n+    for ( ; i < ndisposed; ++i) {\n+      EXPECT_TRUE(disposed[i] != nullptr);\n+      EXPECT_EQ(disposed[i]->value(), 2 * i);\n+    }\n+    for ( ; i < nvalues; ++i) {\n+      EXPECT_TRUE(disposed[i] == nullptr);\n+    }\n+  }\n+}\n+\n@@ -1527,1 +1599,1 @@\n-    void operator()(const Value& value) const {}\n+    void operator()(const Value* value) const {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_intrusiveList.cpp","additions":75,"deletions":3,"binary":false,"changes":78,"status":"modified"}]}