{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,0 @@\n-import jdk.test.lib.jittester.factories.IRNodeBuilder;\n-import jdk.test.lib.jittester.types.TypeKlass;\n-import jdk.test.lib.jittester.utils.FixedTrees;\n-import jdk.test.lib.jittester.utils.OptionResolver;\n-import jdk.test.lib.jittester.utils.OptionResolver.Option;\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -42,50 +36,0 @@\n-    private static Pair<IRNode, IRNode> generateIRTree(String name) {\n-        SymbolTable.removeAll();\n-        TypeList.removeAll();\n-\n-        IRNodeBuilder builder = new IRNodeBuilder()\n-                .setPrefix(name)\n-                .setName(name)\n-                .setLevel(0);\n-\n-        Long complexityLimit = ProductionParams.complexityLimit.value();\n-        IRNode privateClasses = null;\n-        if (!ProductionParams.disableClasses.value()) {\n-            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n-            try {\n-                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n-                        .getClassDefinitionBlockFactory()\n-                        .produce();\n-            } catch (ProductionFailedException ex) {\n-                ex.printStackTrace(System.out);\n-            }\n-        }\n-        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n-        IRNode mainClass = null;\n-        try {\n-            mainClass = builder.setComplexityLimit(mainClassComplexity)\n-                    .getMainKlassFactory()\n-                    .produce();\n-            TypeKlass aClass = new TypeKlass(name);\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n-        } catch (ProductionFailedException ex) {\n-            ex.printStackTrace(System.out);\n-        }\n-        return new Pair<>(mainClass, privateClasses);\n-    }\n-\n-    private static void initializeTestGenerator(String[] params) {\n-        OptionResolver parser = new OptionResolver();\n-        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n-                \"conf\/default.properties\", \"File to read properties from\");\n-        ProductionParams.register(parser);\n-        parser.parse(params, propertyFileOpt);\n-        PseudoRandom.reset(ProductionParams.seed.value());\n-        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n-                ProductionParams.excludeMethodsFile.value());\n-        if (ProductionParams.specificSeed.isSet()) {\n-            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n-        }\n-    }\n-\n@@ -111,1 +55,1 @@\n-        initializeTestGenerator(args);\n+        IRTreeGenerator.initializeFromCmdlineArgs(args);\n@@ -122,1 +66,1 @@\n-            Pair<IRNode, IRNode> irTree = generateIRTree(name);\n+            Pair<IRNode, IRNode> irTree = IRTreeGenerator.generateIRTree(name);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/Automatic.java","additions":3,"deletions":59,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.function.Function;\n@@ -38,2 +37,2 @@\n-class ByteCodeGenerator extends TestsGenerator {\n-    private static final String DEFAULT_SUFFIX = \"bytecode_tests\";\n+public class ByteCodeGenerator extends TestsGenerator {\n+    public static final String DEFAULT_SUFFIX = \"bytecode_tests\";\n@@ -41,2 +40,4 @@\n-    ByteCodeGenerator() {\n-        super(DEFAULT_SUFFIX, s -> new String[0], \"-Xcomp\");\n+    protected final HeaderFormatter headerFormatter;\n+\n+    protected ByteCodeGenerator() {\n+        this(new HeaderFormatter.Builder().build());\n@@ -45,2 +46,3 @@\n-    ByteCodeGenerator(String suffix, Function<String, String[]> preRunActions, String jtDriverOptions) {\n-        super(suffix, preRunActions, jtDriverOptions);\n+    protected ByteCodeGenerator(HeaderFormatter headerFormatter) {\n+        super(DEFAULT_SUFFIX);\n+        this.headerFormatter = headerFormatter;\n@@ -59,1 +61,1 @@\n-        writeFile(generatorDir, mainClassName + \".java\", getJtregHeader(mainClassName));\n+        writeFile(generatorDir, mainClassName + \".java\", headerFormatter.getJtregHeader(mainClassName));\n@@ -62,1 +64,1 @@\n-    private void generateClassFiles(IRNode mainClass, IRNode privateClasses) {\n+    protected void generateClassFiles(IRNode mainClass, IRNode privateClasses) {\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ByteCodeGenerator.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+  * Compares reference output to the one that's being verified.\n+  *\n+  * The class can tolerate some errors (like OutOfMemoryError),\n+  * as their nature is unpredictable and ignore missing intrinsics in\n+  * compiled code stack traces.\n+  *\/\n+public class ErrorTolerance {\n+\n+    \/\/ Put the most annoying intrinsics here\n+    private static final List<Predicate<String>> PATTERNS = List.of(\n+        Pattern.compile(\".*at java.base.*misc.Unsafe.allocateUninitializedArray0.*\").asPredicate()\n+    );\n+\n+    private static final Predicate<String> OOME = Pattern.compile(\n+            \"Exception in thread \\\".*\\\" java.lang.OutOfMemoryError.*\").asPredicate();\n+    private static final Predicate<String> SOE = Pattern.compile(\n+            \".*StackOverFlowError.*\").asPredicate();\n+\n+    private static boolean isIntrinsicCandidate(String line) {\n+        return PATTERNS.stream()\n+                       .map(pattern -> pattern.test(line))\n+                       .reduce(false, (acc, match) -> acc | match);\n+    }\n+\n+    public static void assertIsAcceptable(String message, Stream<String> gold, Stream<String> run) {\n+            Iterator<String> goldIt = gold.iterator();\n+            Iterator<String> runIt = run.iterator();\n+\n+            while (goldIt.hasNext() && runIt.hasNext()) {\n+                String goldLine = goldIt.next();\n+                String runLine = runIt.next();\n+\n+                \/\/ Skipping intrinsics in 'run'\n+                while (isIntrinsicCandidate(goldLine) &&\n+                       !runLine.equals(goldLine) &&\n+                       goldIt.hasNext()) {\n+                    goldLine = goldIt.next();\n+                }\n+\n+                if (!goldLine.equals(runLine)) {\n+                    String fullMessage = \"While \" + message + \":\\n\" +\n+                                         \"Expected: \" + goldLine + \"\\n\" +\n+                                         \"Actual  : \" + runLine + \"\\n\";\n+                    Asserts.fail(fullMessage);\n+                }\n+            }\n+            Asserts.assertEquals(goldIt.hasNext(), runIt.hasNext(), message + \": files are different\");\n+    }\n+\n+    public static void assertIsAcceptable(Path gold, Path run) {\n+        String comparisonNames = \"'\" + gold + \"' and '\" + run + \"'\";\n+        try {\n+            assertIsAcceptable(\"comparing files \" + comparisonNames,\n+                    Files.lines(gold), Files.lines(run));\n+        } catch (IOException e) {\n+            throw new Error(\"Could not compare files: '\" + comparisonNames);\n+        }\n+    }\n+\n+    public static boolean isReliable(Stream<String> gold) {\n+        return !gold.anyMatch(line -> OOME.test(line) || SOE.test(line));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ErrorTolerance.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.jittester.types.TypeKlass;\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n+\n+public final class HeaderFormatter {\n+    public static final String DISABLE_WARNINGS = \"-XX:-PrintWarnings\";\n+\n+    private final Builder builder;\n+\n+    public static class Builder {\n+        private Function<String, String[]>  preRunActions = s -> new String[0];\n+        private String jtDriverOptions = \"-Xcomp\";\n+        private String libraries = \"\/ ..\/\";\n+        private boolean printJitTesterHierarchy = true;\n+        private boolean buildPrinter = true;\n+\n+        public Builder preRunActions(Function<String, String[]> from) {\n+            preRunActions = from;\n+            return this;\n+        }\n+\n+        public Builder jtDriverOptions(String from) {\n+            jtDriverOptions = from;\n+            return this;\n+        }\n+\n+        public Builder libraries(String from) {\n+            libraries = from;\n+            return this;\n+        }\n+\n+        public Builder printJitTesterHierarchy(boolean from) {\n+            printJitTesterHierarchy = from;\n+            return this;\n+        }\n+\n+        public Builder buildPrinter(boolean from) {\n+            buildPrinter = false;\n+            return this;\n+        }\n+\n+        public HeaderFormatter build() {\n+            return new HeaderFormatter(this);\n+        }\n+    }\n+\n+    private HeaderFormatter(Builder builder) {\n+        this.builder = builder;\n+    }\n+\n+    public  String getJtregHeader(String mainClassName) {\n+        String synopsis = \"seed = '\" + ProductionParams.seed.value() + \"'\"\n+                + \", specificSeed = '\" + PseudoRandom.getCurrentSeed() + \"'\";\n+        StringBuilder header = new StringBuilder();\n+        header.append(\"\/*\\n * @test\\n * @summary \")\n+              .append(synopsis)\n+              .append(\" \\n * @library \" + builder.libraries + \"\\n\");\n+       header.append(\" * @run build jdk.test.lib.jittester.jtreg.JitTesterDriver\"\n+                        + (builder.buildPrinter ? \" jdk.test.lib.jittester.jtreg.Printer\\n\" : \"\\n\"));\n+       for (String action : builder.preRunActions.apply(mainClassName)) {\n+            header.append(\" * \")\n+                  .append(action)\n+                  .append(\"\\n\");\n+        }\n+        header.append(\" * @run driver\/timeout=180 jdk.test.lib.jittester.jtreg.JitTesterDriver \")\n+              .append(DISABLE_WARNINGS)\n+              .append(\" \")\n+              .append(builder.jtDriverOptions)\n+              .append(\" \")\n+              .append(mainClassName)\n+              .append(\"\\n *\/\\n\\n\");\n+        if (ProductionParams.printHierarchy.value() && builder.printJitTesterHierarchy) {\n+            header.append(\"\/*\\n\")\n+                  .append(printHierarchy())\n+                  .append(\"*\/\\n\");\n+        }\n+        return header.toString();\n+    }\n+\n+    private static String printHierarchy() {\n+        return TypeList.getAll()\n+                .stream()\n+                .filter(t -> t instanceof TypeKlass)\n+                .map(t -> typeDescription((TypeKlass) t))\n+                .collect(Collectors.joining(\"\\n\", \"CLASS HIERARCHY:\\n\", \"\\n\"));\n+    }\n+\n+    private static String typeDescription(TypeKlass type) {\n+        StringBuilder result = new StringBuilder();\n+        String parents = type.getParentsNames().stream().collect(Collectors.joining(\",\"));\n+        result.append(type.isAbstract() ? \"abstract \" : \"\")\n+              .append(type.isFinal() ? \"final \" : \"\")\n+              .append(type.isInterface() ? \"interface \" : \"class \")\n+              .append(type.getName())\n+              .append(parents.isEmpty() ? \"\" : \": \" + parents);\n+        return result.toString();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/HeaderFormatter.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import jdk.test.lib.util.Pair;\n+\n+import jdk.test.lib.jittester.factories.IRNodeBuilder;\n+import jdk.test.lib.jittester.types.TypeKlass;\n+import jdk.test.lib.jittester.utils.FixedTrees;\n+import jdk.test.lib.jittester.utils.OptionResolver;\n+import jdk.test.lib.jittester.utils.OptionResolver.Option;\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n+\n+public class IRTreeGenerator {\n+    private static final ReentrantLock LOCK = new ReentrantLock();\n+\n+    public static boolean tryLock() {\n+        return LOCK.tryLock();\n+    }\n+\n+    public static void unlock() {\n+        LOCK.unlock();\n+    }\n+\n+    public static Pair<IRNode, IRNode> generateIRTree(String name) {\n+        ProductionLimiter.resetTimer();\n+        \/\/NB: SymbolTable is a widely-used singleton, hence all the locking.\n+        SymbolTable.removeAll();\n+        TypeList.removeAll();\n+\n+        IRNodeBuilder builder = new IRNodeBuilder()\n+                .setPrefix(name)\n+                .setName(name)\n+                .setLevel(0);\n+\n+        Long complexityLimit = ProductionParams.complexityLimit.value();\n+        IRNode privateClasses = null;\n+        if (!ProductionParams.disableClasses.value()) {\n+            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n+            try {\n+                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n+                        .getClassDefinitionBlockFactory()\n+                        .produce();\n+            } catch (ProductionFailedException ex) {\n+                ex.printStackTrace(System.out);\n+            }\n+        }\n+        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n+        IRNode mainClass = null;\n+        try {\n+            mainClass = builder.setComplexityLimit(mainClassComplexity)\n+                    .getMainKlassFactory()\n+                    .produce();\n+            TypeKlass aClass = new TypeKlass(name);\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n+        } catch (ProductionFailedException ex) {\n+            ex.printStackTrace(System.out);\n+        }\n+        return new Pair<IRNode, IRNode>(mainClass, privateClasses);\n+    }\n+\n+    public static void initializeFromCmdlineArgs(String[] args) {\n+        OptionResolver parser = new OptionResolver();\n+        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n+                \"conf\/default.properties\", \"File to read properties from\");\n+        ProductionParams.register(parser);\n+        parser.parse(args, propertyFileOpt);\n+        PseudoRandom.reset(ProductionParams.seed.value());\n+        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n+                ProductionParams.excludeMethodsFile.value());\n+        if (ProductionParams.specificSeed.isSet()) {\n+            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/IRTreeGenerator.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.function.Function;\n@@ -34,1 +33,1 @@\n-    private static final String DEFAULT_SUFFIX = \"java_tests\";\n+    public static final String DEFAULT_SUFFIX = \"java_tests\";\n@@ -36,2 +35,6 @@\n-    JavaCodeGenerator() {\n-        this(DEFAULT_SUFFIX, JavaCodeGenerator::generatePrerunAction, \"-Xcomp\");\n+    private final HeaderFormatter headerFormatter;\n+\n+    protected JavaCodeGenerator() {\n+        this(new HeaderFormatter.Builder()\n+                                .preRunActions(JavaCodeGenerator::generatePrerunAction)\n+                                .build());\n@@ -40,2 +43,3 @@\n-    JavaCodeGenerator(String prefix, Function<String, String[]> preRunActions, String jtDriverOptions) {\n-        super(prefix, preRunActions, jtDriverOptions);\n+    protected JavaCodeGenerator(HeaderFormatter headerFormatter) {\n+        super(DEFAULT_SUFFIX);\n+        this.headerFormatter = headerFormatter;\n@@ -44,0 +48,1 @@\n+\n@@ -53,1 +58,1 @@\n-    private void generateSources(IRNode mainClass, IRNode privateClasses) {\n+    protected void generateSources(IRNode mainClass, IRNode privateClasses) {\n@@ -57,1 +62,1 @@\n-        code.append(getJtregHeader(mainClassName));\n+        code.append(headerFormatter.getJtregHeader(mainClassName));\n@@ -66,2 +71,2 @@\n-    private void compileJavaFile(String mainClassName) {\n-        String classPath = tmpDir.toString();\n+    protected void compileJavaFile(String mainClassName) {\n+        String classPath = tmpDir.path.toString();\n@@ -73,1 +78,2 @@\n-            int r = runProcess(pb, tmpDir.resolve(mainClassName + \".javac\").toString());\n+            int r = ProcessRunner.runProcess(pb,\n+                    tmpDir.path.resolve(mainClassName).toString(), Phase.COMPILE);\n@@ -82,1 +88,1 @@\n-    private static String[] generatePrerunAction(String mainClassName) {\n+    protected static String[] generatePrerunAction(String mainClassName) {\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/JavaCodeGenerator.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+public enum Phase {\n+    GENERATE(300, \"generate\"),\n+    COMPILE(300, \"javac\"),\n+    GOLD_RUN(70, \"gold\"),\n+    RUN(120, \"run\"),\n+    IGNORE(10, \"ignore\");\n+\n+    public final int timeoutSeconds;\n+    public final String suffix;\n+\n+    private Phase(int timeoutSeconds, String suffix) {\n+        this.timeoutSeconds = timeoutSeconds;\n+        this.suffix = suffix;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/Phase.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.BufferedWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+public class ProcessRunner {\n+\n+    private static boolean waitForProcess(Process process, long timeoutSeconds) {\n+        long now = System.currentTimeMillis();\n+        long end = now + timeoutSeconds * 1000;\n+        do {\n+            try {\n+                if (process.waitFor(end - now, TimeUnit.MILLISECONDS)) {\n+                    return true;\n+                }\n+            } catch (InterruptedException ignored) {\n+            }\n+            now = System.currentTimeMillis();\n+        } while (process.isAlive() && (now < end));\n+\n+        process.destroyForcibly();\n+        return false;\n+    }\n+\n+    private static String escapeString(String src) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        src.chars().forEachOrdered(code -> {\n+            if  ((code >= 32) && (code <= 126) && (code != 92) || (code == 9)) {\n+                \/\/ From space to ~ and tabs, excluding \\ which is needed for escapes\n+                sb.append((char) code);\n+            } else {\n+                \/\/ All unreadable, encoding-dependent and \\ are escaped\n+                sb.append(\"\\\\u\" + String.format(\"%04X\", code));\n+            }\n+        });\n+\n+        return sb.toString();\n+    }\n+\n+    private static void escapeRawFileContents(String name) throws IOException {\n+        Path rawPath = Path.of(name + \".utf8\");\n+        Path escPath = Path.of(name);\n+\n+        try (BufferedWriter writer = Files.newBufferedWriter(\n+                    escPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+                Stream<String> lines = Files.lines(rawPath)) {\n+            lines.map(ProcessRunner::escapeString).forEachOrdered(line -> {\n+                try {\n+                    writer.write(line);\n+                    writer.newLine();\n+                } catch (IOException e) {\n+                    throw new Error(\"Can't write file \" + escPath);\n+                }\n+            });\n+            writer.flush();\n+        }\n+    }\n+\n+    public static int runProcess(ProcessBuilder pb, String name, Phase phase)\n+            throws IOException, InterruptedException {\n+        final String nameAndPhase = name + \".\" + phase.suffix;\n+        pb.redirectError(new File(nameAndPhase + \".err.utf8\"));\n+        pb.redirectOutput(new File(nameAndPhase + \".out.utf8\"));\n+        Process process = pb.start();\n+\n+        int result = -1;\n+        if (waitForProcess(process, phase.timeoutSeconds)) {\n+            try (FileWriter file = new FileWriter(nameAndPhase + \".exit\")) {\n+                file.write(Integer.toString(process.exitValue()));\n+            }\n+            result = process.exitValue();\n+        } else {\n+            try (FileWriter file = new FileWriter(nameAndPhase + \".exit\")) {\n+                file.write(\"TIMEOUT\");\n+            }\n+        }\n+\n+        if (phase == Phase.RUN || phase == Phase.GOLD_RUN) {\n+            escapeRawFileContents(nameAndPhase + \".err\");\n+            escapeRawFileContents(nameAndPhase + \".out\");\n+        }\n+\n+        return result;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProcessRunner.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -25,0 +25,4 @@\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n@@ -30,0 +34,2 @@\n+    private static Instant limitInstant;\n+\n@@ -47,0 +53,17 @@\n+\n+        if (Instant.now().isAfter(limitInstant)) {\n+            long paramsLimitSeconds = ProductionParams.productionLimitSeconds.value();\n+            Duration elapsed = Duration.between(limitInstant.minusSeconds(paramsLimitSeconds), Instant.now());\n+            Duration timeLimit = Duration.ofSeconds(paramsLimitSeconds);\n+\n+            throw new RuntimeException(\n+                    String.format(\"A test generation took %s while limit is %s\",\n+                        String.format(\"%d:%02d:%02d\",\n+                            elapsed.toHoursPart(), elapsed.toMinutesPart(), elapsed.toSecondsPart()),\n+                        String.format(\"%d:%02d:%02d\",\n+                            timeLimit.toHoursPart(), timeLimit.toMinutesPart(), timeLimit.toSecondsPart())));\n+        }\n+    }\n+\n+    public static void resetTimer() {\n+        limitInstant = Instant.now().plusSeconds(ProductionParams.productionLimitSeconds.value());\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProductionLimiter.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    public static Option<Integer> productionLimitSeconds = null;\n@@ -74,0 +75,1 @@\n+    public static Option<String> tempDir = null;\n@@ -84,0 +86,1 @@\n+        productionLimitSeconds = optionResolver.addIntegerOption(\"production-limit-seconds\", 600, \"Limit the time a test generation may take\");\n@@ -125,0 +128,1 @@\n+        tempDir = optionResolver.addStringOption(\"temp-dir\", \".\", \"Temp dir path\");\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProductionParams.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+\n+public class TempDir {\n+    public final Path path;\n+\n+    public TempDir(String suffix) {\n+        try {\n+            if (ProductionParams.tempDir.isSet()) {\n+                Path tmpRoot = Path.of(ProductionParams.tempDir.value());\n+                TestsGenerator.ensureExisting(tmpRoot);\n+                path = Files.createTempDirectory(tmpRoot, suffix).toAbsolutePath();\n+            } else {\n+                path = Files.createTempDirectory(suffix).toAbsolutePath();\n+                Runtime.getRuntime().addShutdownHook(new Thread(this::delete));\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Can't create a tmp dir for \" + suffix, e);\n+        }\n+\n+        System.out.println(\"DBG: Temp folder created: '\" + path + \"'\");\n+    }\n+\n+    private void delete() {\n+        var deleteVisitor = new SimpleFileVisitor<Path>() {\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n+                deleteOrError(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                deleteOrError(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            private void deleteOrError(Path what) {\n+                try {\n+                    Files.delete(what);\n+                } catch (IOException e) {\n+                    throw new Error(\"Could not delete '\" + what + \"'\", e);\n+                }\n+            }\n+        };\n+\n+        try {\n+            Files.walkFileTree(path, deleteVisitor);\n+        } catch (IOException e) {\n+            throw new Error(\"Could not delete '\" + path + \"'\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TempDir.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -34,4 +33,2 @@\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import jdk.test.lib.jittester.types.TypeKlass;\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n+import java.util.Optional;\n+\n@@ -45,4 +42,1 @@\n-    protected final Path tmpDir;\n-    protected final Function<String, String[]> preRunActions;\n-    protected final String jtDriverOptions;\n-    private static final String DISABLE_WARNINGS = \"-XX:-PrintWarnings\";\n+    protected final TempDir tmpDir;\n@@ -51,5 +45,0 @@\n-        this(suffix, s -> new String[0], \"\");\n-    }\n-\n-    protected TestsGenerator(String suffix, Function<String, String[]> preRunActions,\n-            String jtDriverOptions) {\n@@ -57,7 +46,1 @@\n-        try {\n-            tmpDir = Files.createTempDirectory(suffix).toAbsolutePath();\n-        } catch (IOException e) {\n-            throw new Error(\"Can't get a tmp dir for \" + suffix, e);\n-        }\n-        this.preRunActions = preRunActions;\n-        this.jtDriverOptions = jtDriverOptions;\n+        tmpDir = new TempDir(suffix);\n@@ -67,1 +50,1 @@\n-        String classPath = tmpDir.toString() + File.pathSeparator\n+        String classPath = tmpDir.path + File.pathSeparator\n@@ -69,3 +52,2 @@\n-        ProcessBuilder pb = new ProcessBuilder(JAVA, \"-Xint\", DISABLE_WARNINGS, \"-Xverify\",\n-                \"-cp\", classPath, mainClassName);\n-        String goldFile = mainClassName + \".gold\";\n+        ProcessBuilder pb = new ProcessBuilder(JAVA, \"-Xint\", HeaderFormatter.DISABLE_WARNINGS, \"-Xverify\",\n+                \"-cp\", classPath, \"-Dstdout.encoding=UTF-8\", mainClassName);\n@@ -73,1 +55,1 @@\n-            runProcess(pb, generatorDir.resolve(goldFile).toString());\n+            ProcessRunner.runProcess(pb, generatorDir.resolve(mainClassName).toString(), Phase.GOLD_RUN);\n@@ -79,18 +61,0 @@\n-    protected static int runProcess(ProcessBuilder pb, String name)\n-            throws IOException, InterruptedException {\n-        pb.redirectError(new File(name + \".err\"));\n-        pb.redirectOutput(new File(name + \".out\"));\n-        Process process = pb.start();\n-        try {\n-            if (process.waitFor(DEFAULT_JTREG_TIMEOUT, TimeUnit.SECONDS)) {\n-                try (FileWriter file = new FileWriter(name + \".exit\")) {\n-                    file.write(Integer.toString(process.exitValue()));\n-                }\n-                return process.exitValue();\n-            }\n-        } finally {\n-            process.destroyForcibly();\n-        }\n-        return -1;\n-    }\n-\n@@ -100,1 +64,1 @@\n-                \"-d\", tmpDir.toString(),\n+                \"-d\", tmpDir.path.toString(),\n@@ -109,1 +73,2 @@\n-            int exitCode = runProcess(pbPrinter, root.resolve(\"Printer\").toString());\n+            int exitCode = ProcessRunner.runProcess(pbPrinter,\n+                    root.resolve(\"Printer\").toString(), Phase.COMPILE);\n@@ -128,29 +93,0 @@\n-    protected String getJtregHeader(String mainClassName) {\n-        String synopsis = \"seed = '\" + ProductionParams.seed.value() + \"'\"\n-                + \", specificSeed = '\" + PseudoRandom.getCurrentSeed() + \"'\";\n-        StringBuilder header = new StringBuilder();\n-        header.append(\"\/*\\n * @test\\n * @summary \")\n-              .append(synopsis)\n-              .append(\" \\n * @library \/ ..\/\\n\");\n-        header.append(\" * @run build jdk.test.lib.jittester.jtreg.JitTesterDriver \"\n-                        + \"jdk.test.lib.jittester.jtreg.Printer\\n\");\n-        for (String action : preRunActions.apply(mainClassName)) {\n-            header.append(\" * \")\n-                  .append(action)\n-                  .append(\"\\n\");\n-        }\n-        header.append(\" * @run driver jdk.test.lib.jittester.jtreg.JitTesterDriver \")\n-              .append(DISABLE_WARNINGS)\n-              .append(\" \")\n-              .append(jtDriverOptions)\n-              .append(\" \")\n-              .append(mainClassName)\n-              .append(\"\\n *\/\\n\\n\");\n-        if (ProductionParams.printHierarchy.value()) {\n-            header.append(\"\/*\\n\")\n-                  .append(printHierarchy())\n-                  .append(\"*\/\\n\");\n-        }\n-        return header.toString();\n-    }\n-\n@@ -169,19 +105,0 @@\n-    private static String printHierarchy() {\n-        return TypeList.getAll()\n-                .stream()\n-                .filter(t -> t instanceof TypeKlass)\n-                .map(t -> typeDescription((TypeKlass) t))\n-                .collect(Collectors.joining(\"\\n\",\"CLASS HIERARCHY:\\n\", \"\\n\"));\n-    }\n-\n-    private static String typeDescription(TypeKlass type) {\n-        StringBuilder result = new StringBuilder();\n-        String parents = type.getParentsNames().stream().collect(Collectors.joining(\",\"));\n-        result.append(type.isAbstract() ? \"abstract \" : \"\")\n-              .append(type.isFinal() ? \"final \" : \"\")\n-              .append(type.isInterface() ? \"interface \" : \"class \")\n-              .append(type.getName())\n-              .append(parents.isEmpty() ? \"\" : \": \" + parents);\n-        return result.toString();\n-    }\n-\n@@ -189,1 +106,1 @@\n-        String[] env = { \"JDK_HOME\", \"JAVA_HOME\", \"BOOTDIR\" };\n+        String[] env = { \"test.jdk\", \"JDK_HOME\", \"JAVA_HOME\", \"BOOTDIR\" };\n@@ -191,1 +108,2 @@\n-            String path = System.getenv(name);\n+            String path = Optional.ofNullable(System.getenv(name))\n+                                  .orElse(System.getProperty(name));\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TestsGenerator.java","additions":15,"deletions":97,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -32,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -35,3 +35,0 @@\n-import java.util.Arrays;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n@@ -40,0 +37,4 @@\n+import jdk.test.lib.jittester.ErrorTolerance;\n+import jdk.test.lib.jittester.Phase;\n+import jdk.test.lib.jittester.ProcessRunner;\n+\n@@ -42,1 +43,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws IOException {\n@@ -48,7 +49,0 @@\n-        OutputAnalyzer oa;\n-        try {\n-            ProcessBuilder pb = ProcessTools.createTestJvm(args);\n-            oa = new OutputAnalyzer(pb.start());\n-        } catch (Exception e) {\n-            throw new Error(\"Unexpected exception on test jvm start :\" + e, e);\n-        }\n@@ -57,2 +51,0 @@\n-        Pattern splitOut = Pattern.compile(\"\\\\n\"); \/\/ tests use \\n only in stdout\n-        Pattern splitErr = Pattern.compile(\"\\\\r?\\\\n\"); \/\/ can handle both \\r\\n and \\n\n@@ -60,6 +52,0 @@\n-        String goldOut = formatOutput(streamGoldFile(testDir, name, \"out\"));\n-        String anlzOut = formatOutput(Arrays.stream(splitOut.split(oa.getStdout())));\n-        Asserts.assertEQ(anlzOut, goldOut, \"Actual stdout isn't equal to golden one\");\n-        String goldErr = formatOutput(streamGoldFile(testDir, name, \"err\"));\n-        String anlzErr = formatOutput(Arrays.stream(splitErr.split(oa.getStderr())));\n-        Asserts.assertEQ(anlzErr, goldErr, \"Actual stderr isn't equal to golden one\");\n@@ -67,3 +53,18 @@\n-        int exitValue = Integer.parseInt(streamGoldFile(testDir, name, \"exit\").findFirst().get());\n-        oa.shouldHaveExitValue(exitValue);\n-    }\n+        try {\n+            ProcessBuilder pb = ProcessTools.createTestJvm(args);\n+            ProcessRunner.runProcess(pb, name, Phase.RUN);\n+\n+            \/\/ Verification\n+            String goldExitValue = streamFile(testDir, name, Phase.GOLD_RUN, \"exit\").findFirst().get();\n+            long goldOutSize = Files.size(Paths.get(Utils.TEST_SRC).resolve(name + \".gold.out\"));\n+            if (!goldExitValue.equals(\"TIMEOUT\") && goldOutSize < 2000000) {\n+                Stream<String> goldOut = streamFile(Paths.get(Utils.TEST_SRC), name, Phase.GOLD_RUN, \"out\");\n+                Stream<String> goldErr = streamFile(Paths.get(Utils.TEST_SRC), name, Phase.GOLD_RUN, \"err\");\n+\n+                if (ErrorTolerance.isReliable(goldOut) && ErrorTolerance.isReliable(goldErr)) {\n+                    String runExitValue = streamFile(Path.of(\".\"), name, Phase.RUN, \"exit\").findFirst().get();\n+                    Asserts.assertEQ(goldExitValue, runExitValue, \"Exit codes mismatch\");\n+\n+                    ErrorTolerance.assertIsAcceptable(\n+                            Paths.get(Utils.TEST_SRC).resolve(name + \".\" + Phase.GOLD_RUN.suffix + \".err\"),\n+                            Paths.get(\".\").resolve(name + \".\" + Phase.RUN.suffix + \".err\"));\n@@ -71,4 +72,8 @@\n-    private static String formatOutput(Stream<String> stream) {\n-        String result = stream.collect(Collectors.joining(Utils.NEW_LINE));\n-        if (result.length() > 0) {\n-            result += Utils.NEW_LINE;\n+                    ErrorTolerance.assertIsAcceptable(\n+                            Paths.get(Utils.TEST_SRC).resolve(name + \".\" + Phase.GOLD_RUN.suffix + \".out\"),\n+                            Paths.get(\".\").resolve(name + \".\" + Phase.RUN.suffix + \".out\"));\n+                }\n+\n+            }\n+        } catch (Exception e) {\n+            throw new Error(\"Unexpected exception on test jvm start :\" + e, e);\n@@ -76,1 +81,0 @@\n-        return result;\n@@ -79,1 +83,2 @@\n-    private static Stream<String> streamGoldFile(Path dir, String name, String suffix) {\n+    private static Stream<String> streamFile(Path dir, String name, Phase phase, String kind) {\n+        String fullName = name + \".\" + phase.suffix + \".\" + kind;\n@@ -81,1 +86,1 @@\n-            return Files.lines(dir.resolve(name + \".gold.\" + suffix));\n+            return Files.lines(dir.resolve(fullName), Charset.forName(\"UTF-8\"));\n@@ -83,1 +88,1 @@\n-            throw new Error(String.format(\"Can't read golden %s for %s : %s\", suffix, name, e), e);\n+            throw new Error(String.format(\"Can't read file: %s\", fullName), e);\n@@ -86,0 +91,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/jtreg\/JitTesterDriver.java","additions":38,"deletions":32,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Check error reporting and tolerating mechanics\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/testlibrary\/jittester\/src\n+ * @run testng jdk.test.lib.jittester.ErrorToleranceTest\n+ *\/\n+public class ErrorToleranceTest {\n+\n+    @Test\n+    public void allowsForIdenticalStacks() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void signalsDifferentStacks() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at wrong.module\/some.WrongObject.method(WrongObject.java:10)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test\n+    public void skipsIntrinsicCandidateFrames() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \/\/        ^^^^ An intrinsic candidate ^^^^\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void doesNotSkipIntrinsicCandidateFramesInGold() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \/\/        ^^^^ An intrinsic candidate ^^^^\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void intrinsicCandidateDoesNotPreventChecks() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \/\/        ^^^^ An intrinsic candidate ^^^^\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at erroneous.module\/some.WrongClazz.wrongMethod(WrongClazz.java:13)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void checksTheWholeStack1() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.simpleConcat(StringConcatHelper.java:365)\",\n+            \"    at java.base\/java.lang.invoke.DirectMethodHandle$Holder.invokeStatic(DirectMethodHandle$Holder)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void checksTheWholeStack2() {\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.simpleConcat(StringConcatHelper.java:365)\",\n+            \"    at java.base\/java.lang.invoke.DirectMethodHandle$Holder.invokeStatic(DirectMethodHandle$Holder)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.SomeException: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(run), Arrays.stream(gold));\n+    }\n+\n+    @Test\n+    public void ignoresDifferencesWithOOME() {\n+        \/\/OOME is too difficult to verify reliably, so we should just ignore such stack traces\n+\n+        String[] gold = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.OutOfMemoryError: Java heap space\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray0(Unsafe.java:1387)\",\n+            \"    at java.base\/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1380)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.newArray(StringConcatHelper.java:441)\",\n+            \"    at java.base\/java.lang.invoke.DirectMethodHandle$Holder.invokeStatic(DirectMethodHandle$Holder)\",\n+            \"    at java.base\/java.lang.invoke.LambdaForm$MH\/0x00000008000c9000.invoke(LambdaForm$MH)\",\n+            \"    at java.base\/java.lang.invoke.Invokers$Holder.linkToTargetMethod(Invokers$Holder)\",\n+            \"    at Test_221.method_float_float_192(Test_221.java:1706)\",\n+            \"    at Test_221.mainTest(Test_221.java:1952)\",\n+            \"    at Test_221.main(Test_221.java:1968)\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Exception in thread \\\"main\\\" java.lang.OutOfMemoryError: Overflow: String length out of range\",\n+            \"    at java.base\/java.lang.StringConcatHelper.checkOverflow(StringConcatHelper.java:57)\",\n+            \"    at java.base\/java.lang.StringConcatHelper.mix(StringConcatHelper.java:116)\",\n+            \"    at Test_221.method_float_float_192(Test_221.java:1706)\",\n+            \"    at Test_221.mainTest(Test_221.java:1952)\",\n+            \"    at Test_221.main(Test_221.java:1968)\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(run), Arrays.stream(gold));\n+    }\n+\n+    @Test(expectedExceptions = { java.lang.RuntimeException.class })\n+    public void reportsFilesThatDiffer() {\n+        String[] gold = new String[] {\n+            \"Correct line 1\",\n+            \"The line that zigs sometimes\",\n+            \"Correct line 2\"\n+        };\n+\n+        String[] run = new String[] {\n+            \"Correct line 1\",\n+            \"The line that zags sometimes\",\n+            \"Correct line 2\"\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+    @Test\n+    public void goldHaveStackOverflowWhileRunDoesnt() {\n+        String[] gold = new String[] {\n+            \"[Fuzzer] End of execution.\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] StackOverFlowError caught.\",\n+            \"[Fuzzer] Field traceCount: 2238\",\n+        };\n+\n+        String[] run = new String[] {\n+            \"[Fuzzer] traceID27\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 7919\",\n+            \"[Fuzzer] traceID2\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 15838\",\n+            \"[Fuzzer] traceID0\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 23757\",\n+            \"[Fuzzer] traceID28\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 31676\",\n+            \"[Fuzzer] traceID27\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 39595\",\n+            \"[Fuzzer] traceID2\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 47514\",\n+            \"[Fuzzer] traceID0\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 55433\",\n+            \"[Fuzzer] traceID28\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 63352\",\n+            \"[Fuzzer] traceID27\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 71271\",\n+            \"[Fuzzer] traceID2\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 79190\",\n+            \"[Fuzzer] traceID0\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 87109\",\n+            \"[Fuzzer] traceID28\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 95028\",\n+            \"[Fuzzer] traceID27\",\n+            \"[Fuzzer] Field field_0: 0\",\n+            \"[Fuzzer] Field traceCount: 102947\",\n+            \"[Fuzzer] trace max reached, exit.\",\n+        };\n+\n+        ErrorTolerance.assertIsAcceptable(\"\", Arrays.stream(gold), Arrays.stream(run));\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/jittester\/ErrorToleranceTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}