{"files":[{"patch":"@@ -3953,3 +3953,9 @@\n-        \/\/ If it's small enough, use smallToString.\n-        if (mag.length <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)\n-           return smallToString(radix);\n+        BigInteger abs = this.abs();\n+\n+        \/\/ Ensure buffer capacity sufficient to contain string representation\n+        \/\/     floor(bitLength*log(2)\/log(radix)) + 1\n+        \/\/ plus an additional character for the sign if negative.\n+        int b = abs.bitLength();\n+        int numChars = (int)(Math.floor(b*LOG_TWO\/logCache[radix]) + 1) +\n+            (signum < 0 ? 1 : 0);\n+        StringBuilder sb = new StringBuilder(numChars);\n@@ -3957,3 +3963,0 @@\n-        \/\/ Otherwise use recursive toString, which requires positive arguments.\n-        \/\/ The results will be concatenated into this StringBuilder\n-        StringBuilder sb = new StringBuilder();\n@@ -3961,2 +3964,1 @@\n-            toString(this.negate(), sb, radix, 0);\n-            sb.insert(0, '-');\n+            sb.append('-');\n@@ -3964,2 +3966,3 @@\n-        else\n-            toString(this, sb, radix, 0);\n+\n+        \/\/ Use recursive toString.\n+        toString(abs, sb, radix, 0);\n@@ -3970,2 +3973,29 @@\n-    \/** This method is used to perform toString when arguments are small. *\/\n-    private String smallToString(int radix) {\n+    \/**\n+     * If {@code numZeros > 0}, appends that many zeros to the\n+     * specified StringBuilder; otherwise, does nothing.\n+     *\n+     * @param sb        The StringBuilder that will be appended to.\n+     * @param numZeros  The number of zeros to append.\n+     *\/\n+    private static void padWithZeros(StringBuilder buf, int numZeros) {\n+        while (numZeros >= NUM_ZEROS) {\n+            buf.append(ZEROS);\n+            numZeros -= NUM_ZEROS;\n+        }\n+        if (numZeros > 0) {\n+            buf.append(ZEROS, 0, numZeros);\n+        }\n+    }\n+\n+    \/**\n+     * This method is used to perform toString when arguments are small.\n+     * The value must be non-negative. If {@code digits <= 0} no padding\n+     * (pre-pending with zeros) will be effected.\n+     *\n+     * @param radix  The base to convert to.\n+     * @param sb     The StringBuilder that will be appended to in place.\n+     * @param digits The minimum number of digits to pad to.\n+     *\/\n+    private void smallToString(int radix, StringBuilder buf, int digits) {\n+        assert signum >= 0;\n+\n@@ -3973,1 +4003,2 @@\n-            return \"0\";\n+            padWithZeros(buf, digits);\n+            return;\n@@ -3978,1 +4009,1 @@\n-        String digitGroup[] = new String[maxNumDigitGroups];\n+        long[] digitGroups = new long[maxNumDigitGroups];\n@@ -3981,1 +4012,1 @@\n-        BigInteger tmp = this.abs();\n+        BigInteger tmp = this;\n@@ -3993,1 +4024,1 @@\n-            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);\n+            digitGroups[numGroups++] = r2.longValue();\n@@ -3997,6 +4028,6 @@\n-        \/\/ Put sign (if any) and first digit group into result buffer\n-        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);\n-        if (signum < 0) {\n-            buf.append('-');\n-        }\n-        buf.append(digitGroup[numGroups-1]);\n+        \/\/ Get string version of first digit group\n+        String s = Long.toString(digitGroups[numGroups-1], radix);\n+\n+        \/\/ Pad with internal zeros if necessary.\n+        padWithZeros(buf, digits - (s.length() +\n+            (numGroups - 1)*digitsPerLong[radix]));\n@@ -4004,1 +4035,4 @@\n-        \/\/ Append remaining digit groups padded with leading zeros\n+        \/\/ Put first digit group into result buffer\n+        buf.append(s);\n+\n+        \/\/ Append remaining digit groups each padded with leading zeros\n@@ -4007,1 +4041,2 @@\n-            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();\n+            s = Long.toString(digitGroups[i], radix);\n+            int numLeadingZeros = digitsPerLong[radix] - s.length();\n@@ -4009,1 +4044,1 @@\n-                buf.append(zeros[numLeadingZeros]);\n+                buf.append(ZEROS, 0, numLeadingZeros);\n@@ -4011,1 +4046,1 @@\n-            buf.append(digitGroup[i]);\n+            buf.append(s);\n@@ -4013,1 +4048,0 @@\n-        return buf.toString();\n@@ -4019,1 +4053,2 @@\n-     * for base conversions.\n+     * for base conversions. This method can only be called for non-negative\n+     * numbers.\n@@ -4029,2 +4064,4 @@\n-    private static void toString(BigInteger u, StringBuilder sb, int radix,\n-                                 int digits) {\n+    private static void toString(BigInteger u, StringBuilder sb,\n+                                 int radix, int digits) {\n+        assert u.signum() >= 0;\n+\n@@ -4032,1 +4069,3 @@\n-        \/\/ method, padding with leading zeroes when necessary.\n+        \/\/ method, padding with leading zeroes when necessary unless we're\n+        \/\/ at the beginning of the string or digits <= 0. As u.signum() >= 0,\n+        \/\/ smallToString() will not prepend a negative sign.\n@@ -4034,11 +4073,1 @@\n-            String s = u.smallToString(radix);\n-\n-            \/\/ Pad with internal zeros if necessary.\n-            \/\/ Don't pad if we're at the beginning of the string.\n-            if ((s.length() < digits) && (sb.length() > 0)) {\n-                for (int i=s.length(); i < digits; i++) {\n-                    sb.append('0');\n-                }\n-            }\n-\n-            sb.append(s);\n+            u.smallToString(radix, sb, digits);\n@@ -4048,3 +4077,0 @@\n-        int b, n;\n-        b = u.bitLength();\n-\n@@ -4054,1 +4080,4 @@\n-        n = (int) Math.round(Math.log(b * LOG_TWO \/ logCache[radix]) \/ LOG_TWO - 1.0);\n+        int b = u.bitLength();\n+        int n = (int) Math.round(Math.log(b * LOG_TWO \/ logCache[radix]) \/\n+                                 LOG_TWO - 1.0);\n+\n@@ -4062,1 +4091,1 @@\n-        toString(results[0], sb, radix, digits-expectedDigits);\n+        toString(results[0], sb, radix, digits - expectedDigits);\n@@ -4094,8 +4123,5 @@\n-    \/* zero[i] is a string of i consecutive zeros. *\/\n-    private static String zeros[] = new String[64];\n-    static {\n-        zeros[63] =\n-            \"000000000000000000000000000000000000000000000000000000000000000\";\n-        for (int i=0; i < 63; i++)\n-            zeros[i] = zeros[63].substring(0, i);\n-    }\n+    \/* Size of ZEROS string. *\/\n+    private static int NUM_ZEROS = 63;\n+\n+    \/* ZEROS is a string of NUM_ZEROS consecutive zeros. *\/\n+    private static final String ZEROS = \"0\".repeat(NUM_ZEROS);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027\n+ * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845\n@@ -798,1 +798,1 @@\n-            byte xBytes[] = new byte[Math.abs(random.nextInt())%100+1];\n+            byte xBytes[] = new byte[Math.abs(random.nextInt())%200+1];\n@@ -839,0 +839,10 @@\n+        \/\/ Check value with many trailing zeros.\n+        String val = \"123456789\" + \"0\".repeat(200);\n+        BigInteger b = new BigInteger(val);\n+        String s = b.toString();\n+        if (!val.equals(s)) {\n+            System.err.format(\"Expected length %d but got %d%n\",\n+                val.length(), s.length());\n+            failCount++;\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"}]}