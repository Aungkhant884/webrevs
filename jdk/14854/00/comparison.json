{"files":[{"patch":"@@ -1512,1 +1512,4 @@\n-            \/\/ ArrayListSpliterator not used here due to late-binding\n+            \/\/ This Spliterator needs to late-bind to the subList, not the outer\n+            \/\/ ArrayList. Note that it is legal for structural changes to be made\n+            \/\/ to a subList after spliterator() is called but before any spliterator\n+            \/\/ operations that would causing binding are performed.\n@@ -1631,3 +1634,1 @@\n-         * against; thus improving precision.  (This doesn't apply to\n-         * SubLists, that create spliterators with current non-lazy\n-         * values).  (2) We perform only a single\n+         * against; thus improving precision. (2) We perform only a single\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        return Spliterators.spliteratorUnknownSize(base.descendingIterator(), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderDequeView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,2 +154,1 @@\n-        \/\/ TODO can probably improve this\n-        return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        return Spliterators.spliteratorUnknownSize(descendingIterator(base), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedSetView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -951,1 +951,2 @@\n-        private long estimatedSize; \/\/ estimated size, to help to split evenly\n+        private long estimatedSize; \/\/ if >= 0, the estimated size, to help to split evenly\n+                                    \/\/ if -1, exact size is known to be fence - index\n@@ -955,0 +956,1 @@\n+         * Its size is known exactly and it is SIZED and SUBSIZED.\n@@ -965,1 +967,2 @@\n-         * Creates a spliterator covering the given array and range\n+         * Creates a spliterator covering the given array and range.\n+         * Its size is known exactly and it is SIZED and SUBSIZED.\n@@ -981,0 +984,12 @@\n+        \/**\n+         * Creates a spliterator covering the given array and range but that is\n+         * not SIZED or SUBSIZED. This case occurs as a result of splitting another\n+         * spliterator that is not sized, so it's inappropriate for one of its\n+         * sub-spliterators to be sized.\n+         * @param array the array, assumed to be unmodified during use\n+         * @param origin the least index (inclusive) to cover\n+         * @param fence one past the greatest index to cover\n+         * @param characteristics characteristics of this spliterator's source; {@code SIZED} and\n+         *        {@code SUBSIZED} are removed if present\n+         * @param estimatedSize the size estimate; should always be nonnegative\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1825,2 +1825,1 @@\n-            \/\/ TODO can probably improve this\n-            return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+            return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}