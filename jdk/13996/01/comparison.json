{"files":[{"patch":"@@ -1064,31 +1064,0 @@\n-    \/**\n-     * Expand an int[(ROUNDS+1)][4] into int[(ROUNDS+1)*4].\n-     * For decryption round keys, need to rotate right by 4 ints.\n-     * @param kr The round keys for encryption or decryption.\n-     * @param decrypting True if 'kr' is for decryption and false otherwise.\n-     *\/\n-    private static final int[] expandToSubKey(int[][] kr, boolean decrypting) {\n-        int total = kr.length;\n-        int[] expK = new int[total*4];\n-        if (decrypting) {\n-            \/\/ decrypting, rotate right by 4 ints\n-            \/\/ i.e. i==0\n-            for(int j=0; j<4; j++) {\n-                expK[j] = kr[total-1][j];\n-            }\n-            for(int i=1; i<total; i++) {\n-                for(int j=0; j<4; j++) {\n-                    expK[i*4 + j] = kr[i-1][j];\n-                }\n-            }\n-        } else {\n-            \/\/ encrypting, straight expansion\n-            for(int i=0; i<total; i++) {\n-                for(int j=0; j<4; j++) {\n-                    expK[i*4 + j] = kr[i][j];\n-                }\n-            }\n-        }\n-        return expK;\n-    }\n-\n@@ -1364,0 +1333,2 @@\n+        final int BC = 4;\n+\n@@ -1365,1 +1336,1 @@\n-        int ROUND_KEY_COUNT = (ROUNDS + 1) * 4;\n+        int ROUND_KEY_COUNT = (ROUNDS + 1) * BC;\n@@ -1367,3 +1338,2 @@\n-        int BC = 4;\n-        int[][] Ke = new int[ROUNDS + 1][4]; \/\/ encryption round keys\n-        int[][] Kd = new int[ROUNDS + 1][4]; \/\/ decryption round keys\n+        int[] Ke = new int[ROUND_KEY_COUNT]; \/\/ encryption round keys\n+        int[] Kd = new int[ROUND_KEY_COUNT]; \/\/ decryption round keys\n@@ -1387,2 +1357,2 @@\n-            Ke[t \/ 4][t % 4] = tk[j];\n-            Kd[ROUNDS - (t \/ 4)][t % 4] = tk[j];\n+            Ke[t] = tk[j];\n+            Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n@@ -1412,2 +1382,2 @@\n-                Ke[t \/ 4][t % 4] = tk[j];\n-                Kd[ROUNDS - (t \/ 4)][t % 4] = tk[j];\n+                Ke[t] = tk[j];\n+                Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n@@ -1419,5 +1389,6 @@\n-                tt = Kd[r][j];\n-                Kd[r][j] = U1[(tt >>> 24) & 0xFF] ^\n-                           U2[(tt >>> 16) & 0xFF] ^\n-                           U3[(tt >>>  8) & 0xFF] ^\n-                           U4[ tt         & 0xFF];\n+                int idx = r*BC + j;\n+                tt = Kd[idx];\n+                Kd[idx] = U1[(tt >>> 24) & 0xFF] ^\n+                          U2[(tt >>> 16) & 0xFF] ^\n+                          U3[(tt >>>  8) & 0xFF] ^\n+                          U4[ tt         & 0xFF];\n@@ -1427,4 +1398,12 @@\n-        \/\/ assemble the encryption (Ke) and decryption (Kd) round keys\n-        \/\/ and expand them into arrays of ints.\n-        int[] expandedKe = expandToSubKey(Ke, false); \/\/ decrypting==false\n-        int[] expandedKd = expandToSubKey(Kd, true);  \/\/ decrypting==true\n+        \/\/ For decryption round keys, need to rotate right by 4 ints.\n+        \/\/ Do that without allocating and zeroing the small buffer.\n+        int KdTail_0 = Kd[Kd.length - 4];\n+        int KdTail_1 = Kd[Kd.length - 3];\n+        int KdTail_2 = Kd[Kd.length - 2];\n+        int KdTail_3 = Kd[Kd.length - 1];\n+        System.arraycopy(Kd, 0, Kd, 4, Kd.length - 4);\n+        Kd[0] = KdTail_0;\n+        Kd[1] = KdTail_1;\n+        Kd[2] = KdTail_2;\n+        Kd[3] = KdTail_3;\n+\n@@ -1432,6 +1411,0 @@\n-        for (int[] ia: Ke) {\n-            Arrays.fill(ia, 0);\n-        }\n-        for (int[] ia: Kd) {\n-            Arrays.fill(ia, 0);\n-        }\n@@ -1447,0 +1420,2 @@\n+        } else {\n+            sessionK = new int[2][];\n@@ -1448,1 +1423,2 @@\n-        sessionK = new int[][] { expandedKe, expandedKd };\n+        sessionK[0] = Ke;\n+        sessionK[1] = Kd;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":31,"deletions":55,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms1g\", \"-Xmx1g\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class AESReinit {\n+\n+    private Cipher cipher;\n+    private Random random;\n+\n+    byte[] key = new byte[16];\n+    byte[] iv  = new byte[16];\n+\n+    @Setup\n+    public void prepare() throws Exception {\n+        random = new Random();\n+        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+        key = new byte[16];\n+        iv = new byte[16];\n+    }\n+\n+    @Benchmark\n+    public void test() throws Exception {\n+        random.nextBytes(key);\n+        random.nextBytes(iv);\n+        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n+        GCMParameterSpec param = new GCMParameterSpec(128, iv);\n+        cipher.init(Cipher.ENCRYPT_MODE, secretKey, param);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/AESReinit.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}