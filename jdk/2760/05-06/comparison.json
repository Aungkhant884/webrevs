{"files":[{"patch":"@@ -48,2 +48,6 @@\n-    _mark_region_cache(mark_stats, RegionMarkStatsCacheSize) {\n-  _mark_region_cache.reset();\n+    \/\/ cache size is big enough that not increase pause during marking\n+    \/\/ by avoiding hit misses as so as possible\n+    _mark_region_cache(mark_stats, round_up_power_of_2(G1CollectedHeap::heap()->max_regions())) {\n+  if (MarkSweepDeadRatio > 0) {\n+    _mark_region_cache.initialize();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,4 +66,1 @@\n-  G1RegionMarkStatsCache    _mark_region_cache;\n-  \/\/ Number of entries in the per-task stats entry. This seems enough to have a very\n-  \/\/ low cache miss rate.\n-  static const uint RegionMarkStatsCacheSize = 1024;\n+  G1RegionMarkStatsCache _mark_region_cache;\n@@ -107,1 +104,3 @@\n-    _mark_region_cache.evict_all();\n+    if (MarkSweepDeadRatio > 0) {\n+      _mark_region_cache.evict_all();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-  uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n@@ -72,0 +71,1 @@\n+    uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+    assert(!hr->is_humongous(), \"humongous objects not supported.\");\n@@ -67,1 +68,0 @@\n-      assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n@@ -210,1 +210,0 @@\n-  assert(!current->is_humongous(), \"Should be no humongous regions\");\n@@ -213,0 +212,1 @@\n+  HeapWord* live_end = current->bottom();\n@@ -217,2 +217,0 @@\n-    oop obj = oop(next_addr);\n-    size_t obj_size = obj->size();\n@@ -220,0 +218,2 @@\n+      oop obj = oop(next_addr);\n+      size_t obj_size = obj->size();\n@@ -229,0 +229,4 @@\n+\n+      next_addr += obj_size;\n+      \/\/ update live byte range end\n+      live_end = next_addr;\n@@ -230,2 +234,5 @@\n-      \/\/ Fill dummy object to replace dead object\n-      Universe::heap()->fill_with_dummy_object(next_addr, next_addr + obj_size, true);\n+      next_addr = _bitmap->get_next_marked_addr(next_addr, limit);\n+      assert(next_addr > live_end, \"next_addr must be bigger than live_end\");\n+      assert(_bitmap->is_marked(next_addr) || next_addr == limit, \"next_addr is the limit or is marked\");\n+      \/\/ fill dummy object to replace dead range\n+      Universe::heap()->fill_with_dummy_object(live_end, next_addr, true);\n@@ -233,1 +240,0 @@\n-    next_addr += obj_size;\n@@ -235,0 +241,1 @@\n+  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -47,0 +48,11 @@\n+ \/\/ cache size is equal to or bigger than region size to intialize region_index\n+void G1RegionMarkStatsCache::initialize() {\n+  _cache_hits = 0;\n+  _cache_misses = 0;\n+  uint size = G1CollectedHeap::heap()->max_regions();\n+\n+  for (uint i = 0; i < size; i++) {\n+    _cache[i]._region_idx = i;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+  void initialize();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}