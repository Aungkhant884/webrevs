{"files":[{"patch":"@@ -1091,1 +1091,2 @@\n-                                         bool clear_all_soft_refs) {\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction) {\n@@ -1102,1 +1103,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs);\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximal_compaction);\n@@ -1117,0 +1118,1 @@\n+  bool do_maximal_compaction = clear_all_soft_refs;\n@@ -1118,1 +1120,2 @@\n-                                  clear_all_soft_refs);\n+                                  clear_all_soft_refs,\n+                                  do_maximal_compaction);\n@@ -1160,0 +1163,1 @@\n+    bool do_maximal_compaction = clear_all_soft_refs;\n@@ -1162,1 +1166,2 @@\n-                                       clear_all_soft_refs);\n+                                       clear_all_soft_refs,\n+                                       do_maximal_compaction);\n@@ -2874,1 +2879,2 @@\n-                                     true \/* clear_all_soft_refs *\/);\n+                                     true  \/* clear_all_soft_refs *\/,\n+                                     false \/* do_maximal_compaction *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -500,0 +500,1 @@\n+  \/\/ - if do_maximal_compaction is true, full gc will do maximal compaction.\n@@ -503,1 +504,2 @@\n-                          bool clear_all_soft_refs);\n+                          bool clear_all_soft_refs,\n+                          bool do_maximal_compaction = false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,4 @@\n-G1FullCollector::G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs) :\n+G1FullCollector::G1FullCollector(G1CollectedHeap* heap,\n+                                 bool explicit_gc,\n+                                 bool clear_soft_refs,\n+                                 bool do_maximal_compaction) :\n@@ -110,1 +113,1 @@\n-    _scope(heap->g1mm(), explicit_gc, clear_soft_refs),\n+    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximal_compaction),\n@@ -135,1 +138,0 @@\n-    _skipping_compaction_sets[i] = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n@@ -146,1 +148,0 @@\n-    delete _skipping_compaction_sets[i];\n@@ -230,2 +231,4 @@\n-void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n-  if (hr->is_free()) {\n+void G1FullCollector::update_attribute_table(HeapRegion* hr, bool force_pinned) {\n+  if (force_pinned) {\n+    \/\/ Pin high live ratio region\n+    _region_attr_table.set_pinned(hr->hrm_index());\n@@ -234,0 +237,1 @@\n+\n@@ -239,0 +243,2 @@\n+    \/\/ Update _region_attr_table after free pinned regions,\n+    \/\/ as the region can not be accessed in G1ResetPinnedClosure.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -72,4 +72,0 @@\n-\n-  GrowableArray<HeapRegion*>**   _skipping_compaction_sets;\n-  G1RegionMarkStats*             _live_stats;\n-\n@@ -84,1 +80,4 @@\n-  G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs);\n+  G1FullCollector(G1CollectedHeap* heap,\n+                  bool explicit_gc,\n+                  bool clear_soft_refs,\n+                  bool do_maximal_compaction);\n@@ -95,4 +94,0 @@\n-  GrowableArray<HeapRegion*>* skipping_compaction_set(uint id) { return _skipping_compaction_sets[id]; }\n-  size_t live_bytes_after_full_gc_mark(uint region_idx) {\n-    return MarkSweepDeadRatio > 0 ? _live_stats[region_idx]._live_words * HeapWordSize : 0;\n-  }\n@@ -105,0 +100,1 @@\n+  size_t                   hr_live_words(uint hr_index) { return _live_stats[hr_index]._live_words; }\n@@ -106,1 +102,1 @@\n-  void update_attribute_table(HeapRegion* hr);\n+  void update_attribute_table(HeapRegion* hr, bool force_pinned = false);\n@@ -109,0 +105,1 @@\n+  inline bool is_in_pinned_or_closed(uint hr_index) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+bool G1FullCollector::is_in_pinned_or_closed(uint hr_index) const {\n+  return _region_attr_table.is_pinned_or_closed(hr_index);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -38,1 +39,1 @@\n-  G1CMBitMap* _bitmap;\n+  G1FullCollector* _collector;\n@@ -41,1 +42,1 @@\n-  G1ResetPinnedClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+  G1ResetPinnedClosure(G1FullCollector* collector) : _collector(collector) { }\n@@ -44,1 +45,5 @@\n-    if (!r->is_pinned()) {\n+    uint hr_index = r->hrm_index();\n+    \/\/ In the prepare phase, we \"pin\" the regions with high survival ratio\n+    \/\/ by _region_attr_table, so here we use _region_attr_table rather than\n+    \/\/ HeapRegion itself to tell whether a region is pinned.\n+    if (!_collector->is_in_pinned_or_closed(hr_index)) {\n@@ -47,1 +52,3 @@\n-    assert(!r->is_starts_humongous() || _bitmap->is_marked((oop)r->bottom()),\n+    assert(_collector->hr_live_words(hr_index) > _collector->scope()->hr_live_words_threshold() ||\n+           !r->is_starts_humongous() ||\n+           _collector->mark_bitmap()->is_marked(r->bottom()),\n@@ -50,0 +57,1 @@\n+\n@@ -85,8 +93,0 @@\n-void G1FullGCCompactTask::process_skipping_compaction_region(HeapRegion* hr) {\n-  if (G1VerifyBitmaps) {\n-    collector()->mark_bitmap()->clear_region(hr);\n-  }\n-\n-  hr->reset_no_compaction_region_during_compaction();\n-}\n-\n@@ -102,10 +102,1 @@\n-  if (MarkSweepDeadRatio > 0) {\n-    GrowableArray<HeapRegion*>* skipping_compaction_queue = collector()->skipping_compaction_set(worker_id);\n-    for (GrowableArrayIterator<HeapRegion*> it = skipping_compaction_queue->begin();\n-         it != skipping_compaction_queue->end();\n-         ++it) {\n-      process_skipping_compaction_region(*it);\n-    }\n-  }\n-\n-  G1ResetPinnedClosure hc(collector()->mark_bitmap());\n+  G1ResetPinnedClosure hc(collector());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  void process_skipping_compaction_region(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+  bool is_pinned_or_closed(uint hr_index) const {\n+    return get_by_index(hr_index) >= Pinned;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n@@ -44,0 +43,1 @@\n+  bool force_pinned = false;\n@@ -64,4 +64,5 @@\n-    assert(!hr->is_humongous(), \"humongous objects not supported.\");\n-    size_t live_bytes = _collector->live_bytes_after_full_gc_mark(hr->hrm_index());\n-    if(live_bytes <= _hr_live_bytes_threshold) {\n-      \/\/ low survivor ratio prepare compaction\n+    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n+    size_t live_words = _collector->hr_live_words(hr->hrm_index());\n+    size_t live_words_threshold = _collector->scope()->hr_live_words_threshold();\n+\n+    if(live_words <= live_words_threshold) {\n@@ -71,4 +72,6 @@\n-             \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n-      \/\/ deal with skipping compaction regions\n-      prepare_for_skipping_compaction(hr);\n-      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live bytes: \" SIZE_FORMAT, hr->hrm_index(), live_bytes);\n+                \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n+      \/\/ Force the high live ration region pinned,\n+      \/\/ as we need skip these regions in the later compact step.\n+      force_pinned = true;\n+      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n+                            hr->hrm_index(), live_words);\n@@ -80,2 +83,1 @@\n-\n-  _collector->update_attribute_table(hr);\n+  _collector->update_attribute_table(hr, force_pinned);\n@@ -105,2 +107,1 @@\n-  GrowableArray<HeapRegion*>* skipping_compaction_set = collector()->skipping_compaction_set(worker_id);\n-  G1CalculatePointersClosure closure(collector(), compaction_point, skipping_compaction_set);\n+  G1CalculatePointersClosure closure(collector(), compaction_point);\n@@ -119,2 +120,1 @@\n-                                                                            G1FullGCCompactionPoint* cp,\n-                                                                            GrowableArray<HeapRegion*>* skipping_compaction_set) :\n+                                                                            G1FullGCCompactionPoint* cp) :\n@@ -125,3 +125,1 @@\n-    _skipping_compaction_set(skipping_compaction_set),\n-    _regions_freed(false),\n-    _hr_live_bytes_threshold((size_t)HeapRegion::GrainBytes * (100 - MarkSweepDeadRatio) \/ 100) { }\n+    _regions_freed(false) { }\n@@ -161,0 +159,1 @@\n+\n@@ -208,44 +207,0 @@\n-void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_skipping_compaction(HeapRegion* hr) {\n-  HeapRegion* current = hr;\n-  HeapWord* limit = current->top();\n-  HeapWord* next_addr = current->bottom();\n-  HeapWord* live_end = current->bottom();\n-  _skipping_compaction_set->append(current);\n-  HeapWord* threshold = current->initialize_threshold();\n-  HeapWord* pre_addr;\n-\n-  while (next_addr < limit) {\n-    Prefetch::write(next_addr, PrefetchScanIntervalInBytes);\n-    pre_addr = next_addr;\n-\n-    if (_bitmap->is_marked(next_addr)) {\n-      oop obj = oop(next_addr);\n-      size_t obj_size = obj->size();\n-      \/\/ Object should not move but mark-word is used so it looks like the\n-      \/\/ object is forwarded. Need to clear the mark and it's no problem\n-      \/\/ since it will be restored by preserved marks. There is an exception\n-      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n-      \/\/ even if the mark-word is used. This is no problem since\n-      \/\/ forwardee() will return NULL in the compaction phase as well.\n-      if (obj->forwardee() != NULL) {\n-        obj->init_mark();\n-      }\n-\n-      next_addr += obj_size;\n-      \/\/ update live byte range end\n-      live_end = next_addr;\n-    } else {\n-      next_addr = _bitmap->get_next_marked_addr(next_addr, limit);\n-      assert(next_addr > live_end, \"next_addr must be bigger than live_end\");\n-      assert(next_addr == limit || _bitmap->is_marked(next_addr), \"next_addr is the limit or is marked\");\n-      \/\/ fill dummy object to replace dead range\n-      Universe::heap()->fill_with_dummy_object(live_end, next_addr, true);\n-    }\n-\n-    if (next_addr > threshold) {\n-      threshold = current->cross_threshold(pre_addr, next_addr);\n-    }\n-  }\n-  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":17,"deletions":62,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -58,1 +59,0 @@\n-    GrowableArray<HeapRegion*>* _skipping_compaction_set;\n@@ -60,1 +60,0 @@\n-    size_t _hr_live_bytes_threshold;\n@@ -68,1 +67,0 @@\n-    void prepare_for_skipping_compaction(HeapRegion* hr);\n@@ -72,2 +70,1 @@\n-                               G1FullGCCompactionPoint* cp,\n-                               GrowableArray<HeapRegion*>* skipping_compaction_set);\n+                               G1FullGCCompactionPoint* cp);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft) :\n+G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                             bool explicit_gc,\n+                             bool clear_soft,\n+                             bool do_maximal_compaction) :\n@@ -40,1 +43,4 @@\n-    _heap_transition(_g1h) {\n+    _heap_transition(_g1h),\n+    _hr_live_words_threshold(do_maximal_compaction ?\n+                               HeapRegion::GrainWords :\n+                               (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) {\n@@ -78,0 +84,4 @@\n+\n+size_t G1FullGCScope::hr_live_words_threshold() {\n+  return _hr_live_words_threshold;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  size_t                  _hr_live_words_threshold;\n@@ -58,1 +59,4 @@\n-  G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft);\n+  G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                bool explicit_gc,\n+                bool clear_soft,\n+                bool do_maximal_compaction);\n@@ -67,0 +71,1 @@\n+  size_t hr_live_words_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1RegionMarkStatsCache.hpp\"\n@@ -333,0 +332,1 @@\n+\n@@ -491,5 +491,0 @@\n-  void reset_no_compaction_region_during_compaction() {\n-    zero_marked_bytes();\n-    init_top_at_mark_start();\n-    reset_after_full_gc_common();\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-  assert(is_pinned(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm TestG1SkipCompaction\n+ * @run main\/othervm -Xms256m -Xmx256m TestG1SkipCompaction\n@@ -77,1 +77,1 @@\n-                    memory.add(new char[1024]);\n+                    memory.add(new char[8 * 1024]);\n@@ -85,1 +85,1 @@\n-     }\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}