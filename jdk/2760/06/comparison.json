{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n@@ -124,0 +125,7 @@\n+\n+  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_regions(), mtGC);\n+  for (uint j = 0; j < heap->max_regions(); j++) {\n+    _live_stats[j].clear();\n+  }\n+  _skipping_compaction_sets = NEW_C_HEAP_ARRAY(GrowableArray<HeapRegion*>*, _num_workers, mtGC);\n+\n@@ -125,1 +133,1 @@\n-    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i));\n+    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i), _live_stats);\n@@ -127,0 +135,1 @@\n+    _skipping_compaction_sets[i] = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n@@ -137,0 +146,1 @@\n+    delete _skipping_compaction_sets[i];\n@@ -140,0 +150,2 @@\n+  FREE_C_HEAP_ARRAY(G1FullGCCompactionPoint*, _skipping_compaction_sets);\n+  FREE_C_HEAP_ARRAY(G1RegionMarkStats, _live_stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+  GrowableArray<HeapRegion*>**   _skipping_compaction_sets;\n+  G1RegionMarkStats*             _live_stats;\n+\n@@ -90,0 +93,4 @@\n+  GrowableArray<HeapRegion*>* skipping_compaction_set(uint id) { return _skipping_compaction_sets[id]; }\n+  size_t live_bytes_after_full_gc_mark(uint region_idx) {\n+    return MarkSweepDeadRatio > 0 ? _live_stats[region_idx]._live_words * HeapWordSize : 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+void G1FullGCCompactTask::process_skipping_compaction_region(HeapRegion* hr) {\n+  collector()->mark_bitmap()->clear_region(hr);\n+  hr->reset_no_compaction_region_during_compaction();\n+}\n+\n@@ -94,0 +99,9 @@\n+  if (MarkSweepDeadRatio > 0) {\n+    GrowableArray<HeapRegion*>* skipping_compaction_queue = collector()->skipping_compaction_set(worker_id);\n+    for (GrowableArrayIterator<HeapRegion*> it = skipping_compaction_queue->begin();\n+         it != skipping_compaction_queue->end();\n+         ++it) {\n+      process_skipping_compaction_region(*it);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  void process_skipping_compaction_region(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n@@ -63,1 +64,2 @@\n-\n+  \/\/ flush live bytes to regions\n+  marker->flush_mark_region_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n@@ -35,1 +36,2 @@\n-                               PreservedMarks* preserved_stack) :\n+                               PreservedMarks* preserved_stack,\n+                               G1RegionMarkStats* mark_stats) :\n@@ -45,1 +47,7 @@\n-    _cld_closure(mark_closure(), ClassLoaderData::_claim_strong) {\n+    _cld_closure(mark_closure(), ClassLoaderData::_claim_strong),\n+    \/\/ cache size is big enough that not increase pause during marking\n+    \/\/ by avoiding hit misses as so as possible\n+    _mark_region_cache(mark_stats, round_up_power_of_2(G1CollectedHeap::heap()->max_regions())) {\n+  if (MarkSweepDeadRatio > 0) {\n+    _mark_region_cache.initialize();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+  G1RegionMarkStatsCache _mark_region_cache;\n+\n@@ -77,1 +79,2 @@\n-  G1FullGCMarker(G1FullCollector* collector, uint worker_id, PreservedMarks* preserved_stack);\n+  G1FullGCMarker(G1FullCollector* collector, uint worker_id,\n+                 PreservedMarks* preserved_stack, G1RegionMarkStats* mark_stats);\n@@ -99,0 +102,6 @@\n+\n+  void flush_mark_region_cache() {\n+    if (MarkSweepDeadRatio > 0) {\n+      _mark_region_cache.evict_all();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+  \/\/ Collect live bytes, which is used to tell\n+  \/\/ whether to skip high live bytes heap regions.\n+  if (MarkSweepDeadRatio > 0) {\n+    uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n+    _mark_region_cache.add_live_words(hr_index, (size_t)obj->size());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n@@ -63,2 +64,12 @@\n-    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n-    prepare_for_compaction(hr);\n+    assert(!hr->is_humongous(), \"humongous objects not supported.\");\n+    size_t live_bytes = _collector->live_bytes_after_full_gc_mark(hr->hrm_index());\n+    if(live_bytes <= _hr_live_bytes_threshold) {\n+      \/\/ low survivor ratio prepare compaction\n+      prepare_for_compaction(hr);\n+    } else {\n+      assert(MarkSweepDeadRatio > 0,\n+             \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n+      \/\/ deal with skipping compaction regions\n+      prepare_for_skipping_compaction(hr);\n+      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live bytes: \" SIZE_FORMAT, hr->hrm_index(), live_bytes);\n+    }\n@@ -94,1 +105,2 @@\n-  G1CalculatePointersClosure closure(collector(), compaction_point);\n+  GrowableArray<HeapRegion*>* skipping_compaction_set = collector()->skipping_compaction_set(worker_id);\n+  G1CalculatePointersClosure closure(collector(), compaction_point, skipping_compaction_set);\n@@ -107,1 +119,2 @@\n-                                                                            G1FullGCCompactionPoint* cp) :\n+                                                                            G1FullGCCompactionPoint* cp,\n+                                                                            GrowableArray<HeapRegion*>* skipping_compaction_set) :\n@@ -112,1 +125,3 @@\n-    _regions_freed(false) { }\n+    _skipping_compaction_set(skipping_compaction_set),\n+    _regions_freed(false),\n+    _hr_live_bytes_threshold((size_t)HeapRegion::GrainBytes * (100 - MarkSweepDeadRatio) \/ 100) { }\n@@ -146,1 +161,0 @@\n-\n@@ -194,0 +208,36 @@\n+void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_skipping_compaction(HeapRegion* hr) {\n+  HeapRegion* current = hr;\n+  HeapWord* limit = current->top();\n+  HeapWord* next_addr = current->bottom();\n+  HeapWord* live_end = current->bottom();\n+  _skipping_compaction_set->append(current);\n+\n+  while (next_addr < limit) {\n+    Prefetch::write(next_addr, PrefetchScanIntervalInBytes);\n+    if (_bitmap->is_marked(next_addr)) {\n+      oop obj = oop(next_addr);\n+      size_t obj_size = obj->size();\n+      \/\/ Object should not move but mark-word is used so it looks like the\n+      \/\/ object is forwarded. Need to clear the mark and it's no problem\n+      \/\/ since it will be restored by preserved marks. There is an exception\n+      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n+      \/\/ even if the mark-word is used. This is no problem since\n+      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      if (obj->forwardee() != NULL) {\n+        obj->init_mark();\n+      }\n+\n+      next_addr += obj_size;\n+      \/\/ update live byte range end\n+      live_end = next_addr;\n+    } else {\n+      next_addr = _bitmap->get_next_marked_addr(next_addr, limit);\n+      assert(next_addr > live_end, \"next_addr must be bigger than live_end\");\n+      assert(_bitmap->is_marked(next_addr) || next_addr == limit, \"next_addr is the limit or is marked\");\n+      \/\/ fill dummy object to replace dead range\n+      Universe::heap()->fill_with_dummy_object(live_end, next_addr, true);\n+    }\n+  }\n+  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":56,"deletions":6,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-\n@@ -59,0 +58,1 @@\n+    GrowableArray<HeapRegion*>* _skipping_compaction_set;\n@@ -60,0 +60,1 @@\n+    size_t _hr_live_bytes_threshold;\n@@ -67,0 +68,1 @@\n+    void prepare_for_skipping_compaction(HeapRegion* hr);\n@@ -70,1 +72,2 @@\n-                               G1FullGCCompactionPoint* cp);\n+                               G1FullGCCompactionPoint* cp,\n+                               GrowableArray<HeapRegion*>* skipping_compaction_set);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -47,0 +48,11 @@\n+ \/\/ cache size is equal to or bigger than region size to intialize region_index\n+void G1RegionMarkStatsCache::initialize() {\n+  _cache_hits = 0;\n+  _cache_misses = 0;\n+  uint size = G1CollectedHeap::heap()->max_regions();\n+\n+  for (uint i = 0; i < size; i++) {\n+    _cache[i]._region_idx = i;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+  void initialize();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.hpp\"\n@@ -332,1 +333,0 @@\n-\n@@ -491,0 +491,4 @@\n+  void reset_no_compaction_region_during_compaction() {\n+    zero_marked_bytes();\n+    init_top_at_mark_start();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -673,1 +673,5 @@\n-          \"also has a smaller default value; see arguments.cpp.\")           \\\n+          \"also has a smaller default value; see arguments.cpp. \"           \\\n+          \"G1 full gc treats this as dead bytes upper threshold to skip \"   \\\n+          \"compaction of heap regions, i.e. if a heap region has dead \"     \\\n+          \"bytes less than this value, then this region will not be \"       \\\n+          \"compacted during G1 full GC.\")                                   \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/*\n+ * @test TestG1SkipCompaction\n+ * @summary Test for JDK-8262068 Improve G1 Full GC by skipping compaction\n+ *          for regions with high survival ratio.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm TestG1SkipCompaction\n+ *\/\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1SkipCompaction {\n+    public static void runTest() throws Exception {\n+        final String[] arguments = {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:MarkSweepDeadRatio=3\",\n+            \"-Xmx8m\",\n+            \"-Xms8M\",\n+            \"-Xlog:gc+phases=debug\",\n+            \"-XX:G1HeapRegionSize=1m\",\n+            GCTest.class.getName()\n+            };\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+\n+        String pattern = \".*skip compaction region.*\";\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(output.getStdout());\n+\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Could not find any no moving region output\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    static class GCTest {\n+        public static List<char[]> memory;\n+        public static void main(String[] args) throws Exception {\n+            memory = new ArrayList<>();\n+            try {\n+                while (true) {\n+                    memory.add(new char[1024]);\n+                    System.gc();\n+                }\n+            } catch (OutOfMemoryError e) {\n+                memory = null;\n+                System.gc();\n+            }\n+        }\n+     }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}