{"files":[{"patch":"@@ -124,0 +124,5 @@\n+\n+  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_regions(), mtGC);\n+  for (uint j = 0; j < heap->max_regions(); j++) {\n+    _live_stats[j].clear();\n+  }\n@@ -125,0 +130,1 @@\n+\n@@ -126,1 +132,1 @@\n-    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i));\n+    _markers[i] = new G1FullGCMarker(this, i, _preserved_marks_set.get(i), _live_stats);\n@@ -144,0 +150,1 @@\n+  FREE_C_HEAP_ARRAY(G1RegionMarkStats, _live_stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  G1RegionMarkStats*             _live_stats;\n@@ -93,0 +94,3 @@\n+  size_t live_bytes_after_full_gc_mark(uint region_idx) {\n+    return MarkSweepDeadRatio > 0 ? _live_stats[region_idx]._live_words * HeapWordSize : 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n+  if (MarkSweepDeadRatio > 0) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation. Alibaba designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"gc\/g1\/g1FullGCMarkRegionCache.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-G1FullGCMarkRegionCache::G1FullGCMarkRegionCache() {\n-  _cache = NEW_C_HEAP_ARRAY(size_t, G1CollectedHeap::heap()->max_regions(), mtGC);\n-  memset(_cache, 0 , sizeof(size_t)*G1CollectedHeap::heap()->max_regions());\n-}\n-void G1FullGCMarkRegionCache::inc_live(uint hr_index, size_t words) {\n-  _cache[hr_index] += words;\n-}\n-\n-void* G1FullGCMarkRegionCache::operator new(size_t size) {\n-  return (address)AllocateHeap(size, mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);\n-}\n-\n-void G1FullGCMarkRegionCache::operator delete(void* p) {\n-  FreeHeap(p);\n-}\n-\n-G1FullGCMarkRegionCache::~G1FullGCMarkRegionCache() {\n-  for (uint i = 0; i < G1CollectedHeap::heap()->max_regions(); ++i) {\n-    if (_cache[i]) {\n-      Atomic::add(G1CollectedHeap::heap()->region_at(i)->live_words_after_full_gc_mark_addr(), _cache[i]);\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(size_t, _cache);\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkRegionCache.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation. Alibaba designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\/\n-\n-#ifndef SHARE_VM_GC_G1_G1FULLGCMARKREGIONCACHE_HPP\n-#define SHARE_VM_GC_G1_G1FULLGCMARKREGIONCACHE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-\n-class G1FullGCMarkRegionCache {\n-private:\n-  size_t* _cache;\n-public:\n-  G1FullGCMarkRegionCache();\n-  void inc_live(uint hr_index, size_t words);\n-\n-  void* operator new(size_t size);\n-  void  operator delete(void* p);\n-\n-  ~G1FullGCMarkRegionCache();\n-};\n-\n-#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkRegionCache.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -35,1 +35,2 @@\n-                               PreservedMarks* preserved_stack) :\n+                               PreservedMarks* preserved_stack,\n+                               G1RegionMarkStats* mark_stats) :\n@@ -46,5 +47,2 @@\n-    _mark_region_cache(NULL) {\n-  if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n-    _mark_region_cache = new G1FullGCMarkRegionCache();\n-  }\n-\n+    _mark_region_cache(mark_stats, RegionMarkStatsCacheSize) {\n+  _mark_region_cache.reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1FullGCMarkRegionCache.hpp\"\n@@ -67,1 +66,4 @@\n-  G1FullGCMarkRegionCache*   _mark_region_cache;\n+  G1RegionMarkStatsCache    _mark_region_cache;\n+  \/\/ Number of entries in the per-task stats entry. This seems enough to have a very\n+  \/\/ low cache miss rate.\n+  static const uint RegionMarkStatsCacheSize = 1024;\n@@ -80,1 +82,2 @@\n-  G1FullGCMarker(G1FullCollector* collector, uint worker_id, PreservedMarks* preserved_stack);\n+  G1FullGCMarker(G1FullCollector* collector, uint worker_id,\n+                 PreservedMarks* preserved_stack, G1RegionMarkStats* mark_stats);\n@@ -104,2 +107,1 @@\n-    delete _mark_region_cache;\n-    _mark_region_cache = NULL;\n+    _mark_region_cache.evict_all();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+  \/\/ Collect live bytes, which is used to tell\n+  \/\/ whether to skip high live bytes heap regions.\n+  uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n+  if (MarkSweepDeadRatio > 0) {\n+    _mark_region_cache.add_live_words(hr_index, (size_t)obj->size());\n+  }\n@@ -75,4 +82,0 @@\n-      uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n-      if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n-        _mark_region_cache->inc_live(hr_index, (size_t)obj->size());\n-      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    size_t live_bytes = hr->live_bytes_after_full_gc_mark();\n+    size_t live_bytes = _collector->live_bytes_after_full_gc_mark(hr->hrm_index());\n@@ -69,0 +69,2 @@\n+      assert(MarkSweepDeadRatio > 0,\n+             \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n@@ -124,1 +126,1 @@\n-    _hr_live_bytes_threshold((size_t)HeapRegion::GrainBytes * G1SkipCompactionLiveBytesLowerThreshold \/ 100) { }\n+    _hr_live_bytes_threshold((size_t)HeapRegion::GrainBytes * (100 - MarkSweepDeadRatio) \/ 100) { }\n@@ -158,1 +160,0 @@\n-  hr->set_live_words_after_full_gc_mark((size_t)0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-    evict(cache_idx);\n@@ -38,0 +37,1 @@\n+    evict(cache_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,6 +305,1 @@\n-          range(0.0, (double)max_uintx)                                     \\\n-                                                                            \\\n-  product(double, G1SkipCompactionLiveBytesLowerThreshold, 100.0,           \\\n-          \"The lower threshold of heap region live bytes percent\"           \\\n-          \"in G1 full GC\")                                                  \\\n-          range(50.0, 100.0)\n+          range(0.0, (double)max_uintx)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  _live_words(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1RegionMarkStatsCache.hpp\"\n@@ -238,1 +239,0 @@\n-  size_t _live_words;\n@@ -333,3 +333,0 @@\n-  size_t* live_words_after_full_gc_mark_addr() { return &_live_words; }\n-  size_t live_bytes_after_full_gc_mark() { return _live_words * HeapWordSize; }\n-  void set_live_words_after_full_gc_mark(size_t live_words) { _live_words = live_words; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -673,1 +673,5 @@\n-          \"also has a smaller default value; see arguments.cpp.\")           \\\n+          \"also has a smaller default value; see arguments.cpp. \"           \\\n+          \"G1 full gc treats this as dead bytes upper threshold to skip \"   \\\n+          \"compaction of heap regions, i.e. if a heap region has dead \"     \\\n+          \"bytes less than this value, then this region will not be \"       \\\n+          \"compacted during G1 full GC.\")                                   \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n- * @summary Test that a full gc with -XX:G1SkipCompactionLiveBytesLowerThreshold=\n+ * @summary Test for JDK-8262068 Improve G1 Full GC by skipping compaction\n+ *          for regions with high survival ratio.\n@@ -45,1 +46,1 @@\n-            \"-XX:G1SkipCompactionLiveBytesLowerThreshold=97\",\n+            \"-XX:MarkSweepDeadRatio=3\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}