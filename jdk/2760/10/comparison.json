{"files":[{"patch":"@@ -1091,1 +1091,2 @@\n-                                         bool clear_all_soft_refs) {\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction) {\n@@ -1102,1 +1103,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs);\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximal_compaction);\n@@ -1117,0 +1118,1 @@\n+  bool do_maximal_compaction = clear_all_soft_refs;\n@@ -1118,1 +1120,2 @@\n-                                  clear_all_soft_refs);\n+                                  clear_all_soft_refs,\n+                                  do_maximal_compaction);\n@@ -1160,0 +1163,1 @@\n+    bool do_maximal_compaction = clear_all_soft_refs;\n@@ -1162,1 +1166,2 @@\n-                                       clear_all_soft_refs);\n+                                       clear_all_soft_refs,\n+                                       do_maximal_compaction);\n@@ -2874,1 +2879,2 @@\n-                                     true \/* clear_all_soft_refs *\/);\n+                                     true  \/* clear_all_soft_refs *\/,\n+                                     false \/* do_maximal_compaction *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  \/\/ - if do_maximal_compaction is true, full gc will do maximal compaction.\n@@ -505,1 +506,2 @@\n-                          bool clear_all_soft_refs);\n+                          bool clear_all_soft_refs,\n+                          bool do_maximal_compaction = false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,4 @@\n-G1FullCollector::G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs) :\n+G1FullCollector::G1FullCollector(G1CollectedHeap* heap,\n+                                 bool explicit_gc,\n+                                 bool clear_soft_refs,\n+                                 bool do_maximal_compaction) :\n@@ -110,1 +113,1 @@\n-    _scope(heap->g1mm(), explicit_gc, clear_soft_refs),\n+    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximal_compaction),\n@@ -228,2 +231,4 @@\n-void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n-  if (hr->is_free()) {\n+void G1FullCollector::update_attribute_table(HeapRegion* hr, bool force_pinned) {\n+  if (force_pinned) {\n+    \/\/ Pin high live ratio region\n+    _region_attr_table.set_pinned(hr->hrm_index());\n@@ -232,0 +237,1 @@\n+\n@@ -237,0 +243,2 @@\n+    \/\/ Update _region_attr_table after free pinned regions,\n+    \/\/ as the region can not be accessed in G1ResetPinnedClosure.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-\n@@ -81,1 +80,4 @@\n-  G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs);\n+  G1FullCollector(G1CollectedHeap* heap,\n+                  bool explicit_gc,\n+                  bool clear_soft_refs,\n+                  bool do_maximal_compaction);\n@@ -98,0 +100,1 @@\n+  size_t                   hr_live_words(uint hr_index) { return _live_stats[hr_index]._live_words; }\n@@ -99,1 +102,1 @@\n-  void update_attribute_table(HeapRegion* hr);\n+  void update_attribute_table(HeapRegion* hr, bool force_pinned = false);\n@@ -102,0 +105,1 @@\n+  inline bool is_in_pinned_or_closed(uint hr_index) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+bool G1FullCollector::is_in_pinned_or_closed(uint hr_index) const {\n+  return _region_attr_table.is_pinned_or_closed(hr_index);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -38,1 +39,1 @@\n-  G1CMBitMap* _bitmap;\n+  G1FullCollector* _collector;\n@@ -41,1 +42,1 @@\n-  G1ResetPinnedClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+  G1ResetPinnedClosure(G1FullCollector* collector) : _collector(collector) { }\n@@ -44,1 +45,5 @@\n-    if (!r->is_pinned()) {\n+    uint hr_index = r->hrm_index();\n+    \/\/ In the prepare phase, we \"pin\" the regions with high survival ratio\n+    \/\/ by _region_attr_table, so here we use _region_attr_table rather than\n+    \/\/ HeapRegion itself to tell whether a region is pinned.\n+    if (!_collector->is_in_pinned_or_closed(hr_index)) {\n@@ -47,1 +52,3 @@\n-    assert(!r->is_starts_humongous() || _bitmap->is_marked(cast_to_oop(r->bottom())),\n+    assert(_collector->hr_live_words(hr_index) > _collector->scope()->hr_live_words_threshold() ||\n+           !r->is_starts_humongous() ||\n+           _collector->mark_bitmap()->is_marked(cast_to_oop(r->bottom())),\n@@ -50,0 +57,1 @@\n+\n@@ -94,1 +102,1 @@\n-  G1ResetPinnedClosure hc(collector()->mark_bitmap());\n+  G1ResetPinnedClosure hc(collector());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+  bool is_pinned_or_closed(uint hr_index) const {\n+    return get_by_index(hr_index) >= Pinned;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  bool force_pinned = false;\n@@ -64,1 +65,14 @@\n-    prepare_for_compaction(hr);\n+    size_t live_words = _collector->hr_live_words(hr->hrm_index());\n+    size_t live_words_threshold = _collector->scope()->hr_live_words_threshold();\n+\n+    if(live_words <= live_words_threshold) {\n+      prepare_for_compaction(hr);\n+    } else {\n+      assert(MarkSweepDeadRatio > 0,\n+                \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n+      \/\/ Force the high live ration region pinned,\n+      \/\/ as we need skip these regions in the later compact step.\n+      force_pinned = true;\n+      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n+                            hr->hrm_index(), live_words);\n+    }\n@@ -69,2 +83,1 @@\n-\n-  _collector->update_attribute_table(hr);\n+  _collector->update_attribute_table(hr, force_pinned);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft) :\n+G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                             bool explicit_gc,\n+                             bool clear_soft,\n+                             bool do_maximal_compaction) :\n@@ -40,1 +43,4 @@\n-    _heap_transition(_g1h) {\n+    _heap_transition(_g1h),\n+    _hr_live_words_threshold(do_maximal_compaction ?\n+                               HeapRegion::GrainWords :\n+                               (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) {\n@@ -78,0 +84,4 @@\n+\n+size_t G1FullGCScope::hr_live_words_threshold() {\n+  return _hr_live_words_threshold;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  size_t                  _hr_live_words_threshold;\n@@ -58,1 +59,4 @@\n-  G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft);\n+  G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                bool explicit_gc,\n+                bool clear_soft,\n+                bool do_maximal_compaction);\n@@ -67,0 +71,1 @@\n+  size_t hr_live_words_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -306,1 +306,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-  assert(is_pinned(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,1 +674,5 @@\n-          \"also has a smaller default value; see arguments.cpp.\")           \\\n+          \"also has a smaller default value; see arguments.cpp. \"           \\\n+          \"G1 full gc treats this as dead bytes upper threshold to skip \"   \\\n+          \"compaction of heap regions, i.e. if a heap region has dead \"     \\\n+          \"bytes less than this value, then this region will not be \"       \\\n+          \"compacted during G1 full GC.\")                                   \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/*\n+ * @test TestG1SkipCompaction\n+ * @summary Test for JDK-8262068 Improve G1 Full GC by skipping compaction\n+ *          for regions with high survival ratio.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -Xms256m -Xmx256m TestG1SkipCompaction\n+ *\/\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1SkipCompaction {\n+    public static void runTest() throws Exception {\n+        final String[] arguments = {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:MarkSweepDeadRatio=3\",\n+            \"-Xmx8m\",\n+            \"-Xms8M\",\n+            \"-Xlog:gc+phases=debug\",\n+            \"-XX:G1HeapRegionSize=1m\",\n+            GCTest.class.getName()\n+            };\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+\n+        String pattern = \".*skip compaction region.*\";\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(output.getStdout());\n+\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Could not find any no moving region output\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    static class GCTest {\n+        public static List<char[]> memory;\n+        public static void main(String[] args) throws Exception {\n+            memory = new ArrayList<>();\n+            try {\n+                while (true) {\n+                    memory.add(new char[8 * 1024]);\n+                    System.gc();\n+                }\n+            } catch (OutOfMemoryError e) {\n+                memory = null;\n+                System.gc();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}