{"files":[{"patch":"@@ -124,0 +124,1 @@\n+  _skipping_compaction_sets = NEW_C_HEAP_ARRAY(GrowableArray<HeapRegion*>*, _num_workers, mtGC);\n@@ -127,0 +128,1 @@\n+    _skipping_compaction_sets[i] = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n@@ -137,0 +139,1 @@\n+    delete _skipping_compaction_sets[i];\n@@ -140,0 +143,1 @@\n+  FREE_C_HEAP_ARRAY(G1FullGCCompactionPoint*, _skipping_compaction_sets);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  GrowableArray<HeapRegion*>**   _skipping_compaction_sets;\n+\n@@ -90,0 +92,1 @@\n+  GrowableArray<HeapRegion*>* skipping_compaction_set(uint id) { return _skipping_compaction_sets[id]; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+void G1FullGCCompactTask::process_skipping_compaction_region(HeapRegion* hr) {\n+  collector()->mark_bitmap()->clear_region(hr);\n+  hr->reset_no_compaction_region_during_compaction();\n+}\n+\n@@ -94,0 +99,9 @@\n+  if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n+    GrowableArray<HeapRegion*>* skipping_compaction_queue = collector()->skipping_compaction_set(worker_id);\n+    for (GrowableArrayIterator<HeapRegion*> it = skipping_compaction_queue->begin();\n+         it != skipping_compaction_queue->end();\n+         ++it) {\n+      process_skipping_compaction_region(*it);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  void process_skipping_compaction_region(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"gc\/g1\/g1FullGCMarkRegionCache.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+G1FullGCMarkRegionCache::G1FullGCMarkRegionCache() {\n+  _cache = NEW_C_HEAP_ARRAY(size_t, G1CollectedHeap::heap()->max_regions(), mtGC);\n+  memset(_cache, 0 , sizeof(size_t)*G1CollectedHeap::heap()->max_regions());\n+}\n+void G1FullGCMarkRegionCache::inc_live(uint hr_index, size_t words) {\n+  _cache[hr_index] += words;\n+}\n+\n+void* G1FullGCMarkRegionCache::operator new(size_t size) {\n+  return (address)AllocateHeap(size, mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);\n+}\n+\n+void G1FullGCMarkRegionCache::operator delete(void* p) {\n+  FreeHeap(p);\n+}\n+\n+G1FullGCMarkRegionCache::~G1FullGCMarkRegionCache() {\n+  for (uint i = 0; i < G1CollectedHeap::heap()->max_regions(); ++i) {\n+    if (_cache[i]) {\n+      Atomic::add(G1CollectedHeap::heap()->region_at(i)->live_words_after_full_gc_mark_addr(), _cache[i]);\n+    }\n+  }\n+  FREE_C_HEAP_ARRAY(size_t, _cache);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkRegionCache.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+#ifndef SHARE_VM_GC_G1_G1FULLGCMARKREGIONCACHE_HPP\n+#define SHARE_VM_GC_G1_G1FULLGCMARKREGIONCACHE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class G1FullGCMarkRegionCache {\n+private:\n+  size_t* _cache;\n+public:\n+  G1FullGCMarkRegionCache();\n+  void inc_live(uint hr_index, size_t words);\n+\n+  void* operator new(size_t size);\n+  void  operator delete(void* p);\n+\n+  ~G1FullGCMarkRegionCache();\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkRegionCache.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -63,1 +63,2 @@\n-\n+  \/\/ flush live bytes to regions\n+  marker->flush_mark_region_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,6 @@\n-    _cld_closure(mark_closure(), ClassLoaderData::_claim_strong) {\n+    _cld_closure(mark_closure(), ClassLoaderData::_claim_strong),\n+    _mark_region_cache(NULL) {\n+  if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n+    _mark_region_cache = new G1FullGCMarkRegionCache();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullGCMarkRegionCache.hpp\"\n@@ -66,0 +67,2 @@\n+  G1FullGCMarkRegionCache*   _mark_region_cache;\n+\n@@ -99,0 +102,5 @@\n+\n+  void flush_mark_region_cache() {\n+    delete _mark_region_cache;\n+    _mark_region_cache = NULL;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+      uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n+      if (G1SkipCompactionLiveBytesLowerThreshold < 100) {\n+        _mark_region_cache->inc_live(hr_index, (size_t)obj->size());\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,10 @@\n-    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n-    prepare_for_compaction(hr);\n+    size_t live_bytes = hr->live_bytes_after_full_gc_mark();\n+    if(live_bytes <= _hr_live_bytes_threshold) {\n+      \/\/ low survivor ratio prepare compaction\n+      assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n+      prepare_for_compaction(hr);\n+    } else {\n+      \/\/ deal with skipping compaction regions\n+      prepare_for_skipping_compaction(hr);\n+      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live bytes: \" SIZE_FORMAT, hr->hrm_index(), live_bytes);\n+    }\n@@ -94,1 +102,2 @@\n-  G1CalculatePointersClosure closure(collector(), compaction_point);\n+  GrowableArray<HeapRegion*>* skipping_compaction_set = collector()->skipping_compaction_set(worker_id);\n+  G1CalculatePointersClosure closure(collector(), compaction_point, skipping_compaction_set);\n@@ -107,1 +116,2 @@\n-                                                                            G1FullGCCompactionPoint* cp) :\n+                                                                            G1FullGCCompactionPoint* cp,\n+                                                                            GrowableArray<HeapRegion*>* skipping_compaction_set) :\n@@ -112,1 +122,3 @@\n-    _regions_freed(false) { }\n+    _skipping_compaction_set(skipping_compaction_set),\n+    _regions_freed(false),\n+    _hr_live_bytes_threshold((size_t)HeapRegion::GrainBytes * G1SkipCompactionLiveBytesLowerThreshold \/ 100) { }\n@@ -146,1 +158,1 @@\n-\n+  hr->set_live_words_after_full_gc_mark((size_t)0);\n@@ -194,0 +206,29 @@\n+void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_skipping_compaction(HeapRegion* hr) {\n+  HeapRegion* current = hr;\n+  assert(!current->is_humongous(), \"Should be no humongous regions\");\n+  HeapWord* limit = current->top();\n+  HeapWord* next_addr = current->bottom();\n+  _skipping_compaction_set->append(current);\n+\n+  while (next_addr < limit) {\n+    Prefetch::write(next_addr, PrefetchScanIntervalInBytes);\n+    oop obj = oop(next_addr);\n+    size_t obj_size = obj->size();\n+    if (_bitmap->is_marked(next_addr)) {\n+      \/\/ Object should not move but mark-word is used so it looks like the\n+      \/\/ object is forwarded. Need to clear the mark and it's no problem\n+      \/\/ since it will be restored by preserved marks. There is an exception\n+      \/\/ with BiasedLocking, in this case forwardee() will return NULL\n+      \/\/ even if the mark-word is used. This is no problem since\n+      \/\/ forwardee() will return NULL in the compaction phase as well.\n+      if (obj->forwardee() != NULL) {\n+        obj->init_mark();\n+      }\n+    } else {\n+      \/\/ Fill dummy object to replace dead object\n+      Universe::heap()->fill_with_dummy_object(next_addr, next_addr + obj_size, true);\n+    }\n+    next_addr += obj_size;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-\n@@ -59,0 +58,1 @@\n+    GrowableArray<HeapRegion*>* _skipping_compaction_set;\n@@ -60,0 +60,1 @@\n+    size_t _hr_live_bytes_threshold;\n@@ -67,0 +68,1 @@\n+    void prepare_for_skipping_compaction(HeapRegion* hr);\n@@ -70,1 +72,2 @@\n-                               G1FullGCCompactionPoint* cp);\n+                               G1FullGCCompactionPoint* cp,\n+                               GrowableArray<HeapRegion*>* skipping_compaction_set);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,2 +305,6 @@\n-          range(0.0, (double)max_uintx)\n-\n+          range(0.0, (double)max_uintx)                                     \\\n+                                                                            \\\n+  product(double, G1SkipCompactionLiveBytesLowerThreshold, 100.0,           \\\n+          \"The lower threshold of heap region live bytes percent\"           \\\n+          \"in G1 full GC\")                                                  \\\n+          range(50.0, 100.0)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+  _live_words(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+  size_t _live_words;\n@@ -332,1 +333,3 @@\n-\n+  size_t* live_words_after_full_gc_mark_addr() { return &_live_words; }\n+  size_t live_bytes_after_full_gc_mark() { return _live_words * HeapWordSize; }\n+  void set_live_words_after_full_gc_mark(size_t live_words) { _live_words = live_words; }\n@@ -491,0 +494,4 @@\n+  void reset_no_compaction_region_during_compaction() {\n+    zero_marked_bytes();\n+    init_top_at_mark_start();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/*\n+ * @test TestG1SkipCompaction\n+ * @summary Test that a full gc with -XX:G1SkipCompactionLiveBytesLowerThreshold=\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm TestG1SkipCompaction\n+ *\/\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1SkipCompaction {\n+    public static void runTest() throws Exception {\n+        final String[] arguments = {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:G1SkipCompactionLiveBytesLowerThreshold=97\",\n+            \"-Xmx8m\",\n+            \"-Xms8M\",\n+            \"-Xlog:gc+phases=debug\",\n+            \"-XX:G1HeapRegionSize=1m\",\n+            GCTest.class.getName()\n+            };\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+\n+        String pattern = \".*skip compaction region.*\";\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(output.getStdout());\n+\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Could not find any no moving region output\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    static class GCTest {\n+        public static List<char[]> memory;\n+        public static void main(String[] args) throws Exception {\n+            memory = new ArrayList<>();\n+            try {\n+                while (true) {\n+                    memory.add(new char[1024]);\n+                    System.gc();\n+                }\n+            } catch (OutOfMemoryError e) {\n+                memory = null;\n+                System.gc();\n+            }\n+        }\n+     }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}