{"files":[{"patch":"@@ -1091,1 +1091,2 @@\n-                                         bool clear_all_soft_refs) {\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximum_compaction) {\n@@ -1102,1 +1103,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs);\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction);\n@@ -1117,0 +1118,3 @@\n+  \/\/ When clear_all_soft_refs is set we want to do a maximum compaction\n+  \/\/ not leaving any dead wood.\n+  bool do_maximum_compaction = clear_all_soft_refs;\n@@ -1118,1 +1122,2 @@\n-                                  clear_all_soft_refs);\n+                                  clear_all_soft_refs,\n+                                  do_maximum_compaction);\n@@ -1160,0 +1165,3 @@\n+    \/\/ When clear_all_soft_refs is set we want to do a maximum compaction\n+    \/\/ not leaving any dead wood.\n+    bool do_maximum_compaction = clear_all_soft_refs;\n@@ -1162,1 +1170,2 @@\n-                                       clear_all_soft_refs);\n+                                       clear_all_soft_refs,\n+                                       do_maximum_compaction);\n@@ -2874,1 +2883,2 @@\n-                                     true \/* clear_all_soft_refs *\/);\n+                                     true  \/* clear_all_soft_refs *\/,\n+                                     false \/* do_maximum_compaction *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -502,0 +502,2 @@\n+  \/\/ - if do_maximum_compaction is true, full gc will do a maximally\n+  \/\/   compacting collection, leaving no dead wood.\n@@ -505,1 +507,2 @@\n-                          bool clear_all_soft_refs);\n+                          bool clear_all_soft_refs,\n+                          bool do_maximum_compaction);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,1 +108,4 @@\n-G1FullCollector::G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs) :\n+G1FullCollector::G1FullCollector(G1CollectedHeap* heap,\n+                                 bool explicit_gc,\n+                                 bool clear_soft_refs,\n+                                 bool do_maximum_compaction) :\n@@ -110,1 +113,1 @@\n-    _scope(heap->g1mm(), explicit_gc, clear_soft_refs),\n+    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximum_compaction),\n@@ -228,2 +231,3 @@\n-void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n-  if (hr->is_free()) {\n+void G1FullCollector::update_attribute_table(HeapRegion* hr, bool force_pinned) {\n+  if (force_pinned) {\n+    _region_attr_table.set_pinned(hr->hrm_index());\n@@ -237,0 +241,1 @@\n+    \/\/ Everything else is processed normally.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,1 +81,4 @@\n-  G1FullCollector(G1CollectedHeap* heap, bool explicit_gc, bool clear_soft_refs);\n+  G1FullCollector(G1CollectedHeap* heap,\n+                  bool explicit_gc,\n+                  bool clear_soft_refs,\n+                  bool do_maximum_compaction);\n@@ -98,0 +101,1 @@\n+  size_t                   live_words(uint region_index) { return _live_stats[region_index]._live_words; }\n@@ -99,1 +103,1 @@\n-  void update_attribute_table(HeapRegion* hr);\n+  void update_attribute_table(HeapRegion* hr, bool force_pinned = false);\n@@ -103,0 +107,1 @@\n+  inline bool is_in_pinned(uint region_index) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+bool G1FullCollector::is_in_pinned(uint region_index) const {\n+  return _region_attr_table.is_pinned(region_index);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n@@ -38,1 +39,1 @@\n-  G1CMBitMap* _bitmap;\n+  G1FullCollector* _collector;\n@@ -41,1 +42,1 @@\n-  G1ResetPinnedClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+  G1ResetPinnedClosure(G1FullCollector* collector) : _collector(collector) { }\n@@ -44,1 +45,2 @@\n-    if (!r->is_pinned()) {\n+    uint region_index = r->hrm_index();\n+    if (!_collector->is_in_pinned(region_index)) {\n@@ -47,1 +49,3 @@\n-    assert(!r->is_starts_humongous() || _bitmap->is_marked(cast_to_oop(r->bottom())),\n+    assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold() ||\n+           !r->is_starts_humongous() ||\n+           _collector->mark_bitmap()->is_marked(cast_to_oop(r->bottom())),\n@@ -49,1 +53,1 @@\n-    r->reset_pinned_after_full_gc();\n+    r->reset_not_compacted_after_full_gc();\n@@ -94,1 +98,1 @@\n-  G1ResetPinnedClosure hc(collector()->mark_bitmap());\n+  G1ResetPinnedClosure hc(collector());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\/\/ In particular, the table collects whether a region should be considered pinned\n+\/\/ during full gc (only), and that there are two reasons a\n+\/\/ region is pinned (and excluded from compaction):\n+\/\/ (1) the HeapRegion itself has been pinned at the start of Full GC.\n+\/\/ (2) the occupancy of the region is too high to be considered eligible for compaction.\n@@ -70,0 +75,4 @@\n+  bool is_pinned(uint idx) const {\n+    return get_by_index(idx) == Pinned;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,5 @@\n-  if (hr->is_pinned()) {\n+  bool force_pinned = false;\n+  if (should_compact(hr)) {\n+    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n+    prepare_for_compaction(hr);\n+  } else {\n@@ -57,0 +61,2 @@\n+    } else if (hr->is_closed_archive()) {\n+      \/\/ nothing to do with closed archive region\n@@ -58,3 +64,8 @@\n-      \/\/ There are no other pinned regions than humongous or all kinds of archive regions\n-      \/\/ at this time.\n-      assert(hr->is_closed_archive(), \"Only closed archive regions can also be pinned.\");\n+      assert(MarkSweepDeadRatio > 0,\n+                \"it should not trigger skipping compaction, when MarkSweepDeadRatio == 0\");\n+\n+      \/\/ Force the high live ration region pinned,\n+      \/\/ as we need skip these regions in the later compact step.\n+      force_pinned = true;\n+      log_debug(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n+                            hr->hrm_index(), _collector->live_words(hr->hrm_index()));\n@@ -62,3 +73,0 @@\n-  } else {\n-    assert(!hr->is_humongous(), \"moving humongous objects not supported.\");\n-    prepare_for_compaction(hr);\n@@ -69,2 +77,1 @@\n-\n-  _collector->update_attribute_table(hr);\n+  _collector->update_attribute_table(hr, force_pinned);\n@@ -143,0 +150,13 @@\n+bool G1FullGCPrepareTask::G1CalculatePointersClosure::should_compact(HeapRegion* hr) {\n+  if (hr->is_pinned()) {\n+    return false;\n+  }\n+  size_t live_words = _collector->live_words(hr->hrm_index());\n+  size_t live_words_threshold = _collector->scope()->region_compaction_threshold();\n+  if (live_words <= live_words_threshold) {\n+    return true;\n+  }\n+  \/\/ High live ratio region will not be compacted.\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    bool should_compact(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft) :\n+G1FullGCScope::G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                             bool explicit_gc,\n+                             bool clear_soft,\n+                             bool do_maximum_compaction) :\n@@ -40,1 +43,4 @@\n-    _heap_transition(_g1h) {\n+    _heap_transition(_g1h),\n+    _region_compaction_threshold(do_maximum_compaction ?\n+                                 HeapRegion::GrainWords :\n+                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) {\n@@ -78,0 +84,4 @@\n+\n+size_t G1FullGCScope::region_compaction_threshold() {\n+  return _region_compaction_threshold;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  size_t                  _region_compaction_threshold;\n@@ -58,1 +59,4 @@\n-  G1FullGCScope(G1MonitoringSupport* monitoring_support, bool explicit_gc, bool clear_soft);\n+  G1FullGCScope(G1MonitoringSupport* monitoring_support,\n+                bool explicit_gc,\n+                bool clear_soft,\n+                bool do_maximal_compaction);\n@@ -67,0 +71,1 @@\n+  size_t region_compaction_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-  uint hr_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n-  add_live_words(hr_index, (size_t) obj->size());\n+  uint region_index = G1CollectedHeap::heap()->addr_to_region(cast_from_oop<HeapWord*>(obj));\n+  add_live_words(region_index, (size_t) obj->size());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,3 @@\n-  _gc_succeeded = g1h->do_full_collection(true \/* explicit_gc *\/, false \/* clear_all_soft_refs *\/);\n+  _gc_succeeded = g1h->do_full_collection(true  \/* explicit_gc *\/,\n+                                          false \/* clear_all_soft_refs *\/,\n+                                          false \/* do_maximum_compaction *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-  void reset_pinned_after_full_gc();\n+  void reset_not_compacted_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-inline void HeapRegion::reset_pinned_after_full_gc() {\n+inline void HeapRegion::reset_not_compacted_after_full_gc() {\n@@ -203,1 +203,0 @@\n-  assert(is_pinned(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -674,1 +674,5 @@\n-          \"also has a smaller default value; see arguments.cpp.\")           \\\n+          \"also has a smaller default value; see arguments.cpp. \"           \\\n+          \"G1 full gc treats this as an allowed garbage threshold to skip \" \\\n+          \"compaction of heap regions, i.e. if a heap region has less \"     \\\n+          \"garbage than this value, then the region will not be compacted\"  \\\n+          \"during G1 full GC.\")                                             \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/*\n+ * @test TestG1SkipCompaction\n+ * @summary Test for JDK-8262068 Improve G1 Full GC by skipping compaction\n+ *          for regions with high survival ratio.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -Xms256m -Xmx256m TestG1SkipCompaction\n+ *\/\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1SkipCompaction {\n+    public static void runTest() throws Exception {\n+        final String[] arguments = {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:MarkSweepDeadRatio=3\",\n+            \"-Xmx8m\",\n+            \"-Xms8M\",\n+            \"-Xlog:gc+phases=debug\",\n+            \"-XX:G1HeapRegionSize=1m\",\n+            GCTest.class.getName()\n+            };\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+\n+        String pattern = \".*skip compaction region.*\";\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(output.getStdout());\n+\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Could not find any no moving region output\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    static class GCTest {\n+        public static List<char[]> memory;\n+        public static void main(String[] args) throws Exception {\n+            memory = new ArrayList<>();\n+            try {\n+                while (true) {\n+                    memory.add(new char[8 * 1024]);\n+                    System.gc();\n+                }\n+            } catch (OutOfMemoryError e) {\n+                memory = null;\n+                System.gc();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}