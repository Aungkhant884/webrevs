{"files":[{"patch":"@@ -54,0 +54,2 @@\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -177,1 +179,4 @@\n-    final Object startTlsLock = new Object();\n+    final ReentrantLock startTlsLock = new ReentrantLock();\n+\n+    \/\/ Connection instance lock\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -376,2 +381,7 @@\n-    synchronized int getMsgId() {\n-        return ++outMsgId;\n+    int getMsgId() {\n+        lock.lock();\n+        try {\n+            return ++outMsgId;\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -411,1 +421,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -414,0 +425,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -430,1 +443,2 @@\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -435,0 +449,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -479,9 +495,13 @@\n-    private synchronized void addRequest(LdapRequest ldapRequest) {\n-\n-        LdapRequest ldr = pendingRequests;\n-        if (ldr == null) {\n-            pendingRequests = ldapRequest;\n-            ldapRequest.next = null;\n-        } else {\n-            ldapRequest.next = pendingRequests;\n-            pendingRequests = ldapRequest;\n+    private void addRequest(LdapRequest ldapRequest) {\n+        lock.lock();\n+        try {\n+            LdapRequest ldr = pendingRequests;\n+            if (ldr == null) {\n+                pendingRequests = ldapRequest;\n+                ldapRequest.next = null;\n+            } else {\n+                ldapRequest.next = pendingRequests;\n+                pendingRequests = ldapRequest;\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -491,6 +511,9 @@\n-    synchronized LdapRequest findRequest(int msgId) {\n-\n-        LdapRequest ldr = pendingRequests;\n-        while (ldr != null) {\n-            if (ldr.msgId == msgId) {\n-                return ldr;\n+    LdapRequest findRequest(int msgId) {\n+        lock.lock();\n+        try {\n+            LdapRequest ldr = pendingRequests;\n+            while (ldr != null) {\n+                if (ldr.msgId == msgId) {\n+                    return ldr;\n+                }\n+                ldr = ldr.next;\n@@ -498,1 +521,3 @@\n-            ldr = ldr.next;\n+            return null;\n+        } finally {\n+            lock.unlock();\n@@ -500,1 +525,0 @@\n-        return null;\n@@ -504,3 +528,5 @@\n-    synchronized void removeRequest(LdapRequest req) {\n-        LdapRequest ldr = pendingRequests;\n-        LdapRequest ldrprev = null;\n+    void removeRequest(LdapRequest req) {\n+        lock.lock();\n+        try {\n+            LdapRequest ldr = pendingRequests;\n+            LdapRequest ldrprev = null;\n@@ -508,3 +534,3 @@\n-        while (ldr != null) {\n-            if (ldr == req) {\n-                ldr.cancel();\n+            while (ldr != null) {\n+                if (ldr == req) {\n+                    ldr.cancel();\n@@ -512,4 +538,6 @@\n-                if (ldrprev != null) {\n-                    ldrprev.next = ldr.next;\n-                } else {\n-                    pendingRequests = ldr.next;\n+                    if (ldrprev != null) {\n+                        ldrprev.next = ldr.next;\n+                    } else {\n+                        pendingRequests = ldr.next;\n+                    }\n+                    ldr.next = null;\n@@ -517,1 +545,2 @@\n-                ldr.next = null;\n+                ldrprev = ldr;\n+                ldr = ldr.next;\n@@ -519,2 +548,2 @@\n-            ldrprev = ldr;\n-            ldr = ldr.next;\n+        } finally {\n+            lock.unlock();\n@@ -549,1 +578,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -552,0 +582,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -561,2 +593,4 @@\n-    synchronized void abandonOutstandingReqs(Control[] reqCtls) {\n-        LdapRequest ldr = pendingRequests;\n+    void abandonOutstandingReqs(Control[] reqCtls) {\n+        lock.lock();\n+        try {\n+            LdapRequest ldr = pendingRequests;\n@@ -564,3 +598,6 @@\n-        while (ldr != null) {\n-            abandonRequest(ldr, reqCtls);\n-            pendingRequests = ldr = ldr.next;\n+            while (ldr != null) {\n+                abandonRequest(ldr, reqCtls);\n+                pendingRequests = ldr = ldr.next;\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -604,1 +641,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -607,0 +645,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -628,2 +668,2 @@\n-\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -674,2 +714,1 @@\n-                        ldr = ldr.next;\n-                    }\n+                    ldr = ldr.next;\n@@ -678,0 +717,3 @@\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -726,5 +768,7 @@\n-    public synchronized void replaceStreams(InputStream newIn, OutputStream newOut) {\n-        if (debug) {\n-            System.err.println(\"Replacing \" + inStream + \" with: \" + newIn);\n-            System.err.println(\"Replacing \" + outStream + \" with: \" + newOut);\n-        }\n+    public void replaceStreams(InputStream newIn, OutputStream newOut) {\n+        lock.lock();\n+        try {\n+            if (debug) {\n+                System.err.println(\"Replacing \" + inStream + \" with: \" + newIn);\n+                System.err.println(\"Replacing \" + outStream + \" with: \" + newOut);\n+            }\n@@ -732,1 +776,1 @@\n-        inStream = newIn;\n+            inStream = newIn;\n@@ -734,7 +778,7 @@\n-        \/\/ Cleanup old stream\n-        try {\n-            outStream.flush();\n-        } catch (IOException ie) {\n-            if (debug)\n-                System.err.println(\"Connection: cannot flush outstream: \" + ie);\n-        }\n+            \/\/ Cleanup old stream\n+            try {\n+                outStream.flush();\n+            } catch (IOException ie) {\n+                if (debug)\n+                    System.err.println(\"Connection: cannot flush outstream: \" + ie);\n+            }\n@@ -742,2 +786,5 @@\n-        \/\/ Replace stream\n-        outStream = newOut;\n+            \/\/ Replace stream\n+            outStream = newOut;\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -749,4 +796,12 @@\n-    public synchronized void replaceStreams(InputStream newIn, OutputStream newOut, boolean isStartTls) {\n-        synchronized (startTlsLock) {\n-            replaceStreams(newIn, newOut);\n-            isUpgradedToStartTls = isStartTls;\n+    public void replaceStreams(InputStream newIn, OutputStream newOut, boolean isStartTls) {\n+        lock.lock();\n+        try {\n+            startTlsLock.lock();\n+            try {\n+                replaceStreams(newIn, newOut);\n+                isUpgradedToStartTls = isStartTls;\n+            } finally {\n+                startTlsLock.unlock();\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -768,2 +823,7 @@\n-    private synchronized InputStream getInputStream() {\n-        return inStream;\n+    private InputStream getInputStream() {\n+        lock.lock();\n+        try {\n+            return inStream;\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -820,1 +880,3 @@\n-    private final Object pauseLock = new Object();  \/\/ lock for reader to wait on while paused\n+    \/\/ lock for reader to wait on while paused\n+    private final ReentrantLock pauseLock = new ReentrantLock();\n+    private final Condition pauseCondition = pauseLock.newCondition();\n@@ -827,1 +889,2 @@\n-        synchronized (pauseLock) {\n+        pauseLock.lock();\n+        try {\n@@ -834,1 +897,1 @@\n-                pauseLock.notify();\n+                pauseCondition.signal();\n@@ -836,0 +899,2 @@\n+        } finally {\n+            pauseLock.unlock();\n@@ -842,1 +907,1 @@\n-     * MUST be called from within synchronized (pauseLock) clause.\n+     * MUST be called with pauseLock locked.\n@@ -845,0 +910,1 @@\n+        assert pauseLock.isHeldByCurrentThread();\n@@ -852,1 +918,1 @@\n-                pauseLock.wait(); \/\/ notified by unpauseReader\n+                pauseCondition.await(); \/\/ notified by unpauseReader\n@@ -988,1 +1054,2 @@\n-                                synchronized (pauseLock) {\n+                                pauseLock.lock();\n+                                try {\n@@ -999,0 +1066,2 @@\n+                                } finally {\n+                                    pauseLock.unlock();\n@@ -1080,3 +1149,5 @@\n-    public synchronized void setHandshakeCompletedListener(SSLSocket sslSocket) {\n-        if (tlsHandshakeListener != null)\n-            tlsHandshakeListener.tlsHandshakeCompleted.cancel(false);\n+    public void setHandshakeCompletedListener(SSLSocket sslSocket) {\n+        lock.lock();\n+        try {\n+            if (tlsHandshakeListener != null)\n+                tlsHandshakeListener.tlsHandshakeCompleted.cancel(false);\n@@ -1084,2 +1155,5 @@\n-        tlsHandshakeListener = new HandshakeListener();\n-        sslSocket.addHandshakeCompletedListener(tlsHandshakeListener);\n+            tlsHandshakeListener = new HandshakeListener();\n+            sslSocket.addHandshakeCompletedListener(tlsHandshakeListener);\n+        } finally {\n+            lock.unlock();\n+        }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":152,"deletions":78,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -50,0 +52,4 @@\n+    \/\/ EventQueue instance lock\n+    private final ReentrantLock lock = new ReentrantLock();\n+    private final Condition condition = lock.newCondition();\n+\n@@ -89,10 +95,16 @@\n-    synchronized void enqueue(EventObject event, Vector<NamingListener> vector) {\n-        QueueElement newElt = new QueueElement(event, vector);\n-\n-        if (head == null) {\n-            head = newElt;\n-            tail = newElt;\n-        } else {\n-            newElt.next = head;\n-            head.prev = newElt;\n-            head = newElt;\n+    void enqueue(EventObject event, Vector<NamingListener> vector) {\n+        lock.lock();\n+        try {\n+            QueueElement newElt = new QueueElement(event, vector);\n+\n+            if (head == null) {\n+                head = newElt;\n+                tail = newElt;\n+            } else {\n+                newElt.next = head;\n+                head.prev = newElt;\n+                head = newElt;\n+            }\n+            condition.signal();\n+        } finally {\n+            lock.unlock();\n@@ -100,1 +112,0 @@\n-        notify();\n@@ -111,10 +122,16 @@\n-    private synchronized QueueElement dequeue()\n-                                throws InterruptedException {\n-        while (tail == null)\n-            wait();\n-        QueueElement elt = tail;\n-        tail = elt.prev;\n-        if (tail == null) {\n-            head = null;\n-        } else {\n-            tail.next = null;\n+    private QueueElement dequeue() throws InterruptedException {\n+        lock.lock();\n+        try {\n+            while (tail == null)\n+                condition.await();\n+            QueueElement elt = tail;\n+            tail = elt.prev;\n+            if (tail == null) {\n+                head = null;\n+            } else {\n+                tail.next = null;\n+            }\n+            elt.prev = elt.next = null;\n+            return elt;\n+        } finally {\n+            lock.unlock();\n@@ -122,2 +139,0 @@\n-        elt.prev = elt.next = null;\n-        return elt;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/EventQueue.java","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -120,0 +121,3 @@\n+    \/\/ EventSupport instance lock. Accessed by LdapCtx\n+    final ReentrantLock lock = new ReentrantLock();\n+\n@@ -152,1 +156,1 @@\n-    synchronized void addNamingListener(String nm, int scope,\n+    void addNamingListener(String nm, int scope,\n@@ -155,16 +159,13 @@\n-        if (l instanceof ObjectChangeListener ||\n-            l instanceof NamespaceChangeListener) {\n-            NotifierArgs args = new NotifierArgs(nm, scope, l);\n-\n-            NamingEventNotifier notifier = notifiers.get(args);\n-            if (notifier == null) {\n-                notifier = new NamingEventNotifier(this, ctx, args, l);\n-                notifiers.put(args, notifier);\n-            } else {\n-                notifier.addNamingListener(l);\n-            }\n-        }\n-        if (l instanceof UnsolicitedNotificationListener) {\n-            \/\/ Add listener to this's list of unsolicited notifiers\n-            if (unsolicited == null) {\n-                unsolicited = new Vector<>(3);\n+        lock.lock();\n+        try {\n+            if (l instanceof ObjectChangeListener ||\n+                l instanceof NamespaceChangeListener) {\n+                NotifierArgs args = new NotifierArgs(nm, scope, l);\n+\n+                NamingEventNotifier notifier = notifiers.get(args);\n+                if (notifier == null) {\n+                    notifier = new NamingEventNotifier(this, ctx, args, l);\n+                    notifiers.put(args, notifier);\n+                } else {\n+                    notifier.addNamingListener(l);\n+                }\n@@ -172,0 +173,5 @@\n+            if (l instanceof UnsolicitedNotificationListener) {\n+                \/\/ Add listener to this's list of unsolicited notifiers\n+                if (unsolicited == null) {\n+                    unsolicited = new Vector<>(3);\n+                }\n@@ -173,1 +179,4 @@\n-            unsolicited.addElement((UnsolicitedNotificationListener)l);\n+                unsolicited.addElement((UnsolicitedNotificationListener) l);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -181,1 +190,1 @@\n-    synchronized void addNamingListener(String nm, String filter,\n+    void addNamingListener(String nm, String filter,\n@@ -184,10 +193,13 @@\n-        if (l instanceof ObjectChangeListener ||\n-            l instanceof NamespaceChangeListener) {\n-            NotifierArgs args = new NotifierArgs(nm, filter, ctls, l);\n-\n-            NamingEventNotifier notifier = notifiers.get(args);\n-            if (notifier == null) {\n-                notifier = new NamingEventNotifier(this, ctx, args, l);\n-                notifiers.put(args, notifier);\n-            } else {\n-                notifier.addNamingListener(l);\n+        lock.lock();\n+        try {\n+            if (l instanceof ObjectChangeListener ||\n+                l instanceof NamespaceChangeListener) {\n+                NotifierArgs args = new NotifierArgs(nm, filter, ctls, l);\n+\n+                NamingEventNotifier notifier = notifiers.get(args);\n+                if (notifier == null) {\n+                    notifier = new NamingEventNotifier(this, ctx, args, l);\n+                    notifiers.put(args, notifier);\n+                } else {\n+                    notifier.addNamingListener(l);\n+                }\n@@ -195,5 +207,6 @@\n-        }\n-        if (l instanceof UnsolicitedNotificationListener) {\n-            \/\/ Add listener to this's list of unsolicited notifiers\n-            if (unsolicited == null) {\n-                unsolicited = new Vector<>(3);\n+            if (l instanceof UnsolicitedNotificationListener) {\n+                \/\/ Add listener to this's list of unsolicited notifiers\n+                if (unsolicited == null) {\n+                    unsolicited = new Vector<>(3);\n+                }\n+                unsolicited.addElement((UnsolicitedNotificationListener) l);\n@@ -201,1 +214,2 @@\n-            unsolicited.addElement((UnsolicitedNotificationListener)l);\n+        } finally {\n+            lock.unlock();\n@@ -208,15 +222,12 @@\n-    synchronized void removeNamingListener(NamingListener l) {\n-        if (debug) {\n-            System.err.println(\"EventSupport removing listener\");\n-        }\n-        \/\/ Go through list of notifiers, remove 'l' from each.\n-        \/\/ If 'l' is notifier's only listener, remove notifier too.\n-        Iterator<NamingEventNotifier> iterator = notifiers.values().iterator();\n-        while (iterator.hasNext()) {\n-            NamingEventNotifier notifier = iterator.next();\n-            if (notifier != null) {\n-                if (debug) {\n-                    System.err.println(\"EventSupport removing listener from notifier\");\n-                }\n-                notifier.removeNamingListener(l);\n-                if (!notifier.hasNamingListeners()) {\n+    void removeNamingListener(NamingListener l) {\n+        lock.lock();\n+        try {\n+            if (debug) {\n+                System.err.println(\"EventSupport removing listener\");\n+            }\n+            \/\/ Go through list of notifiers, remove 'l' from each.\n+            \/\/ If 'l' is notifier's only listener, remove notifier too.\n+            Iterator<NamingEventNotifier> iterator = notifiers.values().iterator();\n+            while (iterator.hasNext()) {\n+                NamingEventNotifier notifier = iterator.next();\n+                if (notifier != null) {\n@@ -224,1 +235,9 @@\n-                        System.err.println(\"EventSupport stopping notifier\");\n+                        System.err.println(\"EventSupport removing listener from notifier\");\n+                    }\n+                    notifier.removeNamingListener(l);\n+                    if (!notifier.hasNamingListeners()) {\n+                        if (debug) {\n+                            System.err.println(\"EventSupport stopping notifier\");\n+                        }\n+                        notifier.stop();\n+                        iterator.remove();\n@@ -226,2 +245,0 @@\n-                    notifier.stop();\n-                    iterator.remove();\n@@ -230,7 +247,9 @@\n-        }\n-        \/\/ Remove from list of unsolicited notifier\n-        if (debug) {\n-            System.err.println(\"EventSupport removing unsolicited: \" + unsolicited);\n-        }\n-        if (unsolicited != null) {\n-            unsolicited.removeElement(l);\n+            \/\/ Remove from list of unsolicited notifier\n+            if (debug) {\n+                System.err.println(\"EventSupport removing unsolicited: \" + unsolicited);\n+            }\n+            if (unsolicited != null) {\n+                unsolicited.removeElement(l);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -240,2 +259,7 @@\n-    synchronized boolean hasUnsolicited() {\n-        return (unsolicited != null && unsolicited.size() > 0);\n+    boolean hasUnsolicited() {\n+        lock.lock();\n+        try {\n+            return (unsolicited != null && unsolicited.size() > 0);\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -249,9 +273,14 @@\n-    synchronized void removeDeadNotifier(NotifierArgs info) {\n-        if (debug) {\n-            System.err.println(\"EventSupport.removeDeadNotifier: \" + info.name);\n-        }\n-        if (notifiers != null) {\n-            \/\/ Only do this if cleanup() not been triggered, otherwise here\n-            \/\/ will throw NullPointerException since notifiers will be set to\n-            \/\/ null in cleanup()\n-            notifiers.remove(info);\n+    void removeDeadNotifier(NotifierArgs info) {\n+        lock.lock();\n+        try {\n+            if (debug) {\n+                System.err.println(\"EventSupport.removeDeadNotifier: \" + info.name);\n+            }\n+            if (notifiers != null) {\n+                \/\/ Only do this if cleanup() not been triggered, otherwise here\n+                \/\/ will throw NullPointerException since notifiers will be set to\n+                \/\/ null in cleanup()\n+                notifiers.remove(info);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -266,11 +295,13 @@\n-    synchronized void fireUnsolicited(Object obj) {\n-        if (debug) {\n-            System.err.println(\"EventSupport.fireUnsolicited: \" + obj + \" \"\n-                + unsolicited);\n-        }\n-        if (unsolicited == null || unsolicited.size() == 0) {\n-            \/\/ This shouldn't really happen, but might in case\n-            \/\/ there is a timing problem that removes a listener\n-            \/\/ before a fired event reaches here.\n-            return;\n-        }\n+    void fireUnsolicited(Object obj) {\n+        lock.lock();\n+        try {\n+            if (debug) {\n+                System.err.println(\"EventSupport.fireUnsolicited: \" + obj + \" \"\n+                        + unsolicited);\n+            }\n+            if (unsolicited == null || unsolicited.size() == 0) {\n+                \/\/ This shouldn't really happen, but might in case\n+                \/\/ there is a timing problem that removes a listener\n+                \/\/ before a fired event reaches here.\n+                return;\n+            }\n@@ -278,1 +309,1 @@\n-        if (obj instanceof UnsolicitedNotification) {\n+            if (obj instanceof UnsolicitedNotification) {\n@@ -280,1 +311,1 @@\n-            \/\/ Fire UnsolicitedNotification to unsolicited listeners\n+                \/\/ Fire UnsolicitedNotification to unsolicited listeners\n@@ -282,3 +313,3 @@\n-            UnsolicitedNotificationEvent evt =\n-                new UnsolicitedNotificationEvent(ctx, (UnsolicitedNotification)obj);\n-            queueEvent(evt, unsolicited);\n+                UnsolicitedNotificationEvent evt =\n+                        new UnsolicitedNotificationEvent(ctx, (UnsolicitedNotification) obj);\n+                queueEvent(evt, unsolicited);\n@@ -286,1 +317,1 @@\n-        } else if (obj instanceof NamingException) {\n+            } else if (obj instanceof NamingException) {\n@@ -288,1 +319,1 @@\n-            \/\/ Fire NamingExceptionEvent to unsolicited listeners.\n+                \/\/ Fire NamingExceptionEvent to unsolicited listeners.\n@@ -290,3 +321,3 @@\n-            NamingExceptionEvent evt =\n-                new NamingExceptionEvent(ctx, (NamingException)obj);\n-            queueEvent(evt, unsolicited);\n+                NamingExceptionEvent evt =\n+                        new NamingExceptionEvent(ctx, (NamingException) obj);\n+                queueEvent(evt, unsolicited);\n@@ -294,5 +325,5 @@\n-            \/\/ When an exception occurs, the unsolicited listeners\n-            \/\/ are automatically deregistered.\n-            \/\/ When LdapClient.processUnsolicited() fires a NamingException,\n-            \/\/ it will update its listener list so we don't have to.\n-            \/\/ Likewise for LdapCtx.\n+                \/\/ When an exception occurs, the unsolicited listeners\n+                \/\/ are automatically deregistered.\n+                \/\/ When LdapClient.processUnsolicited() fires a NamingException,\n+                \/\/ it will update its listener list so we don't have to.\n+                \/\/ Likewise for LdapCtx.\n@@ -300,1 +331,4 @@\n-            unsolicited = null;\n+                unsolicited = null;\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -309,5 +343,9 @@\n-    synchronized void cleanup() {\n-        if (debug) System.err.println(\"EventSupport clean up\");\n-        if (notifiers != null) {\n-            for (NamingEventNotifier notifier : notifiers.values()) {\n-                notifier.stop();\n+    void cleanup() {\n+        lock.lock();\n+        try {\n+            if (debug) System.err.println(\"EventSupport clean up\");\n+            if (notifiers != null) {\n+                for (NamingEventNotifier notifier : notifiers.values()) {\n+                    notifier.stop();\n+                }\n+                notifiers = null;\n@@ -315,5 +353,7 @@\n-            notifiers = null;\n-        }\n-        if (eventQueue != null) {\n-            eventQueue.stop();\n-            eventQueue = null;\n+            if (eventQueue != null) {\n+                eventQueue.stop();\n+                eventQueue = null;\n+            }\n+            \/\/ %%% Should we fire NamingExceptionEvents to unsolicited listeners?\n+        } finally {\n+            lock.unlock();\n@@ -321,1 +361,0 @@\n-        \/\/ %%% Should we fire NamingExceptionEvents to unsolicited listeners?\n@@ -335,6 +374,26 @@\n-    synchronized void queueEvent(EventObject event,\n-                                 Vector<? extends NamingListener> vector) {\n-        if (notifiers == null) {\n-            \/\/ That means cleanup() already done, not queue event anymore,\n-            \/\/ otherwise, new created EventQueue will not been cleanup.\n-            return;\n+    void queueEvent(EventObject event,\n+                    Vector<? extends NamingListener> vector) {\n+        lock.lock();\n+        try {\n+            if (notifiers == null) {\n+                \/\/ That means cleanup() already done, not queue event anymore,\n+                \/\/ otherwise, new created EventQueue will not been cleanup.\n+                return;\n+            }\n+            if (eventQueue == null)\n+                eventQueue = new EventQueue();\n+\n+            \/*\n+             * Copy the vector in order to freeze the state of the set\n+             * of EventListeners the event should be delivered to prior\n+             * to delivery.  This ensures that any changes made to the\n+             * Vector from a target listener's method during the delivery\n+             * of this event will not take effect until after the event is\n+             * delivered.\n+             *\/\n+            @SuppressWarnings(\"unchecked\") \/\/ clone()\n+            Vector<NamingListener> v =\n+                    (Vector<NamingListener>) vector.clone();\n+            eventQueue.enqueue(event, v);\n+        } finally {\n+            lock.unlock();\n@@ -342,15 +401,0 @@\n-        if (eventQueue == null)\n-            eventQueue = new EventQueue();\n-\n-        \/*\n-         * Copy the vector in order to freeze the state of the set\n-         * of EventListeners the event should be delivered to prior\n-         * to delivery.  This ensures that any changes made to the\n-         * Vector from a target listener's method during the delivery\n-         * of this event will not take effect until after the event is\n-         * delivered.\n-         *\/\n-        @SuppressWarnings(\"unchecked\") \/\/ clone()\n-        Vector<NamingListener> v =\n-                (Vector<NamingListener>)vector.clone();\n-        eventQueue.enqueue(event, v);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/EventSupport.java","additions":175,"deletions":131,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -128,0 +129,2 @@\n+    \/\/ LdapClient instance lock, accessed by LdapCtx\n+    final ReentrantLock lock = new ReentrantLock();\n@@ -148,2 +151,7 @@\n-    synchronized boolean authenticateCalled() {\n-        return authenticateCalled;\n+    boolean authenticateCalled() {\n+        lock.lock();\n+        try {\n+            return authenticateCalled;\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -152,2 +160,1 @@\n-    synchronized LdapResult\n-    authenticate(boolean initial, String name, Object pw, int version,\n+    LdapResult authenticate(boolean initial, String name, Object pw, int version,\n@@ -156,5 +163,1 @@\n-\n-        int readTimeout = conn.readTimeout;\n-        conn.readTimeout = conn.connectTimeout;\n-        LdapResult res = null;\n-\n+        lock.lock();\n@@ -162,2 +165,3 @@\n-            authenticateCalled = true;\n-\n+            int readTimeout = conn.readTimeout;\n+            conn.readTimeout = conn.connectTimeout;\n+            LdapResult res;\n@@ -165,6 +169,1 @@\n-                ensureOpen();\n-            } catch (IOException e) {\n-                NamingException ne = new CommunicationException();\n-                ne.setRootCause(e);\n-                throw ne;\n-            }\n+                authenticateCalled = true;\n@@ -172,12 +171,7 @@\n-            switch (version) {\n-            case LDAP_VERSION3_VERSION2:\n-            case LDAP_VERSION3:\n-                isLdapv3 = true;\n-                break;\n-            case LDAP_VERSION2:\n-                isLdapv3 = false;\n-                break;\n-            default:\n-                throw new CommunicationException(\"Protocol version \" + version +\n-                    \" not supported\");\n-            }\n+                try {\n+                    ensureOpen();\n+                } catch (IOException e) {\n+                    NamingException ne = new CommunicationException();\n+                    ne.setRootCause(e);\n+                    throw ne;\n+                }\n@@ -185,2 +179,12 @@\n-            if (authMechanism.equalsIgnoreCase(\"none\") ||\n-                authMechanism.equalsIgnoreCase(\"anonymous\")) {\n+                switch (version) {\n+                    case LDAP_VERSION3_VERSION2:\n+                    case LDAP_VERSION3:\n+                        isLdapv3 = true;\n+                        break;\n+                    case LDAP_VERSION2:\n+                        isLdapv3 = false;\n+                        break;\n+                    default:\n+                        throw new CommunicationException(\"Protocol version \" + version +\n+                                \" not supported\");\n+                }\n@@ -188,6 +192,31 @@\n-                \/\/ Perform LDAP bind if we are reauthenticating, using LDAPv2,\n-                \/\/ supporting failover to LDAPv2, or controls have been supplied.\n-                if (!initial ||\n-                    (version == LDAP_VERSION2) ||\n-                    (version == LDAP_VERSION3_VERSION2) ||\n-                    ((ctls != null) && (ctls.length > 0))) {\n+                if (authMechanism.equalsIgnoreCase(\"none\") ||\n+                        authMechanism.equalsIgnoreCase(\"anonymous\")) {\n+\n+                    \/\/ Perform LDAP bind if we are reauthenticating, using LDAPv2,\n+                    \/\/ supporting failover to LDAPv2, or controls have been supplied.\n+                    if (!initial ||\n+                            (version == LDAP_VERSION2) ||\n+                            (version == LDAP_VERSION3_VERSION2) ||\n+                            ((ctls != null) && (ctls.length > 0))) {\n+                        try {\n+                            \/\/ anonymous bind; update name\/pw for LDAPv2 retry\n+                            res = ldapBind(name = null, (byte[]) (pw = null), ctls, null,\n+                                    false);\n+                            if (res.status == LdapClient.LDAP_SUCCESS) {\n+                                conn.setBound();\n+                            }\n+                        } catch (IOException e) {\n+                            NamingException ne =\n+                                    new CommunicationException(\"anonymous bind failed: \" +\n+                                            conn.host + \":\" + conn.port);\n+                            ne.setRootCause(e);\n+                            throw ne;\n+                        }\n+                    } else {\n+                        \/\/ Skip LDAP bind for LDAPv3 anonymous bind\n+                        res = new LdapResult();\n+                        res.status = LdapClient.LDAP_SUCCESS;\n+                    }\n+                } else if (authMechanism.equalsIgnoreCase(\"simple\")) {\n+                    \/\/ simple authentication\n+                    byte[] encodedPw = null;\n@@ -195,3 +224,2 @@\n-                        \/\/ anonymous bind; update name\/pw for LDAPv2 retry\n-                        res = ldapBind(name=null, (byte[])(pw=null), ctls, null,\n-                            false);\n+                        encodedPw = encodePassword(pw, isLdapv3);\n+                        res = ldapBind(name, encodedPw, ctls, null, false);\n@@ -203,2 +231,2 @@\n-                            new CommunicationException(\"anonymous bind failed: \" +\n-                            conn.host + \":\" + conn.port);\n+                                new CommunicationException(\"simple bind failed: \" +\n+                                        conn.host + \":\" + conn.port);\n@@ -207,27 +235,7 @@\n-                    }\n-                } else {\n-                    \/\/ Skip LDAP bind for LDAPv3 anonymous bind\n-                    res = new LdapResult();\n-                    res.status = LdapClient.LDAP_SUCCESS;\n-                }\n-            } else if (authMechanism.equalsIgnoreCase(\"simple\")) {\n-                \/\/ simple authentication\n-                byte[] encodedPw = null;\n-                try {\n-                    encodedPw = encodePassword(pw, isLdapv3);\n-                    res = ldapBind(name, encodedPw, ctls, null, false);\n-                    if (res.status == LdapClient.LDAP_SUCCESS) {\n-                        conn.setBound();\n-                    }\n-                } catch (IOException e) {\n-                    NamingException ne =\n-                        new CommunicationException(\"simple bind failed: \" +\n-                            conn.host + \":\" + conn.port);\n-                    ne.setRootCause(e);\n-                    throw ne;\n-                } finally {\n-                    \/\/ If pw was copied to a new array, clear that array as\n-                    \/\/ a security precaution.\n-                    if (encodedPw != pw && encodedPw != null) {\n-                        for (int i = 0; i < encodedPw.length; i++) {\n-                            encodedPw[i] = 0;\n+                    } finally {\n+                        \/\/ If pw was copied to a new array, clear that array as\n+                        \/\/ a security precaution.\n+                        if (encodedPw != pw && encodedPw != null) {\n+                            for (int i = 0; i < encodedPw.length; i++) {\n+                                encodedPw[i] = 0;\n+                            }\n@@ -236,8 +244,14 @@\n-                }\n-            } else if (isLdapv3) {\n-                \/\/ SASL authentication\n-                try {\n-                    res = LdapSasl.saslBind(this, conn, conn.host, name, pw,\n-                        authMechanism, env, ctls);\n-                    if (res.status == LdapClient.LDAP_SUCCESS) {\n-                        conn.setBound();\n+                } else if (isLdapv3) {\n+                    \/\/ SASL authentication\n+                    try {\n+                        res = LdapSasl.saslBind(this, conn, conn.host, name, pw,\n+                                authMechanism, env, ctls);\n+                        if (res.status == LdapClient.LDAP_SUCCESS) {\n+                            conn.setBound();\n+                        }\n+                    } catch (IOException e) {\n+                        NamingException ne =\n+                                new CommunicationException(\"SASL bind failed: \" +\n+                                        conn.host + \":\" + conn.port);\n+                        ne.setRootCause(e);\n+                        throw ne;\n@@ -245,6 +259,2 @@\n-                } catch (IOException e) {\n-                    NamingException ne =\n-                        new CommunicationException(\"SASL bind failed: \" +\n-                        conn.host + \":\" + conn.port);\n-                    ne.setRootCause(e);\n-                    throw ne;\n+                } else {\n+                    throw new AuthenticationNotSupportedException(authMechanism);\n@@ -252,3 +262,0 @@\n-            } else {\n-                throw new AuthenticationNotSupportedException(authMechanism);\n-            }\n@@ -256,30 +263,31 @@\n-            \/\/\n-            \/\/ re-try login using v2 if failing over\n-            \/\/\n-            if (initial &&\n-                (res.status == LdapClient.LDAP_PROTOCOL_ERROR) &&\n-                (version == LdapClient.LDAP_VERSION3_VERSION2) &&\n-                (authMechanism.equalsIgnoreCase(\"none\") ||\n-                    authMechanism.equalsIgnoreCase(\"anonymous\") ||\n-                    authMechanism.equalsIgnoreCase(\"simple\"))) {\n-\n-                byte[] encodedPw = null;\n-                try {\n-                    isLdapv3 = false;\n-                    encodedPw = encodePassword(pw, false);\n-                    res = ldapBind(name, encodedPw, ctls, null, false);\n-                    if (res.status == LdapClient.LDAP_SUCCESS) {\n-                        conn.setBound();\n-                    }\n-                } catch (IOException e) {\n-                    NamingException ne =\n-                        new CommunicationException(authMechanism + \":\" +\n-                            conn.host +     \":\" + conn.port);\n-                    ne.setRootCause(e);\n-                    throw ne;\n-                } finally {\n-                    \/\/ If pw was copied to a new array, clear that array as\n-                    \/\/ a security precaution.\n-                    if (encodedPw != pw && encodedPw != null) {\n-                        for (int i = 0; i < encodedPw.length; i++) {\n-                            encodedPw[i] = 0;\n+                \/\/\n+                \/\/ re-try login using v2 if failing over\n+                \/\/\n+                if (initial &&\n+                        (res.status == LdapClient.LDAP_PROTOCOL_ERROR) &&\n+                        (version == LdapClient.LDAP_VERSION3_VERSION2) &&\n+                        (authMechanism.equalsIgnoreCase(\"none\") ||\n+                                authMechanism.equalsIgnoreCase(\"anonymous\") ||\n+                                authMechanism.equalsIgnoreCase(\"simple\"))) {\n+\n+                    byte[] encodedPw = null;\n+                    try {\n+                        isLdapv3 = false;\n+                        encodedPw = encodePassword(pw, false);\n+                        res = ldapBind(name, encodedPw, ctls, null, false);\n+                        if (res.status == LdapClient.LDAP_SUCCESS) {\n+                            conn.setBound();\n+                        }\n+                    } catch (IOException e) {\n+                        NamingException ne =\n+                                new CommunicationException(authMechanism + \":\" +\n+                                        conn.host + \":\" + conn.port);\n+                        ne.setRootCause(e);\n+                        throw ne;\n+                    } finally {\n+                        \/\/ If pw was copied to a new array, clear that array as\n+                        \/\/ a security precaution.\n+                        if (encodedPw != pw && encodedPw != null) {\n+                            for (int i = 0; i < encodedPw.length; i++) {\n+                                encodedPw[i] = 0;\n+                            }\n@@ -289,1 +297,0 @@\n-            }\n@@ -291,9 +298,14 @@\n-            \/\/ principal name not found\n-            \/\/ (map NameNotFoundException to AuthenticationException)\n-            \/\/ %%% This is a workaround for Netscape servers returning\n-            \/\/ %%% no such object when the principal name is not found\n-            \/\/ %%% Note that when this workaround is applied, it does not allow\n-            \/\/ %%% response controls to be recorded by the calling context\n-            if (res.status == LdapClient.LDAP_NO_SUCH_OBJECT) {\n-                throw new AuthenticationException(\n-                    getErrorMessage(res.status, res.errorMessage));\n+                \/\/ principal name not found\n+                \/\/ (map NameNotFoundException to AuthenticationException)\n+                \/\/ %%% This is a workaround for Netscape servers returning\n+                \/\/ %%% no such object when the principal name is not found\n+                \/\/ %%% Note that when this workaround is applied, it does not allow\n+                \/\/ %%% response controls to be recorded by the calling context\n+                if (res.status == LdapClient.LDAP_NO_SUCH_OBJECT) {\n+                    throw new AuthenticationException(\n+                            getErrorMessage(res.status, res.errorMessage));\n+                }\n+                conn.setV3(isLdapv3);\n+                return res;\n+            } finally {\n+                conn.readTimeout = readTimeout;\n@@ -301,2 +313,0 @@\n-            conn.setV3(isLdapv3);\n-            return res;\n@@ -304,1 +314,1 @@\n-            conn.readTimeout = readTimeout;\n+            lock.unlock();\n@@ -316,1 +326,1 @@\n-    public synchronized LdapResult ldapBind(String dn, byte[]toServer,\n+    public LdapResult ldapBind(String dn, byte[]toServer,\n@@ -318,1 +328,1 @@\n-        throws java.io.IOException, NamingException {\n+            throws IOException, NamingException {\n@@ -320,1 +330,3 @@\n-        ensureOpen();\n+        lock.lock();\n+        try {\n+            ensureOpen();\n@@ -322,2 +334,2 @@\n-        \/\/ flush outstanding requests\n-        conn.abandonOutstandingReqs(null);\n+            \/\/ flush outstanding requests\n+            conn.abandonOutstandingReqs(null);\n@@ -325,4 +337,4 @@\n-        BerEncoder ber = new BerEncoder();\n-        int curMsgId = conn.getMsgId();\n-        LdapResult res = new LdapResult();\n-        res.status = LDAP_OPERATIONS_ERROR;\n+            BerEncoder ber = new BerEncoder();\n+            int curMsgId = conn.getMsgId();\n+            LdapResult res = new LdapResult();\n+            res.status = LDAP_OPERATIONS_ERROR;\n@@ -330,4 +342,4 @@\n-        \/\/\n-        \/\/ build the bind request.\n-        \/\/\n-        ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);\n+            \/\/\n+            \/\/ build the bind request.\n+            \/\/\n+            ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);\n@@ -336,12 +348,15 @@\n-                ber.encodeInt(isLdapv3 ? LDAP_VERSION3 : LDAP_VERSION2);\n-                ber.encodeString(dn, isLdapv3);\n-\n-                \/\/ if authentication mechanism specified, it is SASL\n-                if (auth != null) {\n-                    ber.beginSeq(Ber.ASN_CONTEXT | Ber.ASN_CONSTRUCTOR | 3);\n-                        ber.encodeString(auth, isLdapv3);    \/\/ SASL mechanism\n-                        if (toServer != null) {\n-                            ber.encodeOctetString(toServer,\n-                                Ber.ASN_OCTET_STR);\n-                        }\n-                    ber.endSeq();\n+            ber.encodeInt(isLdapv3 ? LDAP_VERSION3 : LDAP_VERSION2);\n+            ber.encodeString(dn, isLdapv3);\n+\n+            \/\/ if authentication mechanism specified, it is SASL\n+            if (auth != null) {\n+                ber.beginSeq(Ber.ASN_CONTEXT | Ber.ASN_CONSTRUCTOR | 3);\n+                ber.encodeString(auth, isLdapv3);    \/\/ SASL mechanism\n+                if (toServer != null) {\n+                    ber.encodeOctetString(toServer,\n+                            Ber.ASN_OCTET_STR);\n+                }\n+                ber.endSeq();\n+            } else {\n+                if (toServer != null) {\n+                    ber.encodeOctetString(toServer, Ber.ASN_CONTEXT);\n@@ -349,5 +364,1 @@\n-                    if (toServer != null) {\n-                        ber.encodeOctetString(toServer, Ber.ASN_CONTEXT);\n-                    } else {\n-                        ber.encodeOctetString(null, Ber.ASN_CONTEXT, 0, 0);\n-                    }\n+                    ber.encodeOctetString(null, Ber.ASN_CONTEXT, 0, 0);\n@@ -355,0 +366,1 @@\n+            }\n@@ -361,1 +373,1 @@\n-        ber.endSeq();\n+            ber.endSeq();\n@@ -363,4 +375,4 @@\n-        LdapRequest req = conn.writeRequest(ber, curMsgId, pauseAfterReceipt);\n-        if (toServer != null) {\n-            ber.reset();        \/\/ clear internally-stored password\n-        }\n+            LdapRequest req = conn.writeRequest(ber, curMsgId, pauseAfterReceipt);\n+            if (toServer != null) {\n+                ber.reset();        \/\/ clear internally-stored password\n+            }\n@@ -368,2 +380,2 @@\n-        \/\/ Read reply\n-        BerDecoder rber = conn.readReply(req);\n+            \/\/ Read reply\n+            BerDecoder rber = conn.readReply(req);\n@@ -371,5 +383,5 @@\n-        rber.parseSeq(null);    \/\/ init seq\n-        rber.parseInt();        \/\/ msg id\n-        if (rber.parseByte() !=  LDAP_REP_BIND) {\n-            return res;\n-        }\n+            rber.parseSeq(null);    \/\/ init seq\n+            rber.parseInt();        \/\/ msg id\n+            if (rber.parseByte() != LDAP_REP_BIND) {\n+                return res;\n+            }\n@@ -377,2 +389,2 @@\n-        rber.parseLength();\n-        parseResult(rber, res, isLdapv3);\n+            rber.parseLength();\n+            parseResult(rber, res, isLdapv3);\n@@ -380,6 +392,6 @@\n-        \/\/ handle server's credentials (if present)\n-        if (isLdapv3 &&\n-            (rber.bytesLeft() > 0) &&\n-            (rber.peekByte() == (Ber.ASN_CONTEXT | 7))) {\n-            res.serverCreds = rber.parseOctetString((Ber.ASN_CONTEXT | 7), null);\n-        }\n+            \/\/ handle server's credentials (if present)\n+            if (isLdapv3 &&\n+                (rber.bytesLeft() > 0) &&\n+                (rber.peekByte() == (Ber.ASN_CONTEXT | 7))) {\n+                res.serverCreds = rber.parseOctetString((Ber.ASN_CONTEXT | 7), null);\n+            }\n@@ -387,1 +399,1 @@\n-        res.resControls = isLdapv3 ? parseControls(rber) : null;\n+            res.resControls = isLdapv3 ? parseControls(rber) : null;\n@@ -389,2 +401,5 @@\n-        conn.removeRequest(req);\n-        return res;\n+            conn.removeRequest(req);\n+            return res;\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -409,4 +424,9 @@\n-    synchronized void incRefCount() {\n-        ++referenceCount;\n-        if (debug > 1) {\n-            System.err.println(\"LdapClient.incRefCount: \" + referenceCount + \" \" + this);\n+    void incRefCount() {\n+        lock.lock();\n+        try {\n+            ++referenceCount;\n+            if (debug > 1) {\n+                System.err.println(\"LdapClient.incRefCount: \" + referenceCount + \" \" + this);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -414,1 +434,0 @@\n-\n@@ -437,2 +456,4 @@\n-    synchronized void close(Control[] reqCtls, boolean hardClose) {\n-        --referenceCount;\n+    void close(Control[] reqCtls, boolean hardClose) {\n+        lock.lock();\n+        try {\n+            --referenceCount;\n@@ -440,5 +461,5 @@\n-        if (debug > 1) {\n-            System.err.println(\"LdapClient: \" + this);\n-            System.err.println(\"LdapClient: close() called: \" + referenceCount);\n-            (new Throwable()).printStackTrace();\n-        }\n+            if (debug > 1) {\n+                System.err.println(\"LdapClient: \" + this);\n+                System.err.println(\"LdapClient: close() called: \" + referenceCount);\n+                (new Throwable()).printStackTrace();\n+            }\n@@ -446,9 +467,4 @@\n-        if (referenceCount <= 0) {\n-            if (debug > 0) System.err.println(\"LdapClient: closed connection \" + this);\n-            if (!pooled) {\n-                \/\/ Not being pooled; continue with closing\n-                conn.cleanup(reqCtls, false);\n-            } else {\n-                \/\/ Pooled\n-                \/\/ Is this a real close or a request to return conn to pool\n-                if (hardClose) {\n+            if (referenceCount <= 0) {\n+                if (debug > 0) System.err.println(\"LdapClient: closed connection \" + this);\n+                if (!pooled) {\n+                    \/\/ Not being pooled; continue with closing\n@@ -456,1 +472,0 @@\n-                    pcb.removePooledConnection(this);\n@@ -458,1 +473,8 @@\n-                    pcb.releasePooledConnection(this);\n+                    \/\/ Pooled\n+                    \/\/ Is this a real close or a request to return conn to pool\n+                    if (hardClose) {\n+                        conn.cleanup(reqCtls, false);\n+                        pcb.removePooledConnection(this);\n+                    } else {\n+                        pcb.releasePooledConnection(this);\n+                    }\n@@ -461,0 +483,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -490,2 +514,7 @@\n-    public synchronized void closeConnection() {\n-        forceClose(false); \/\/ this is a pool callback so no need to clean pool\n+    public void closeConnection() {\n+        lock.lock();\n+        try {\n+            forceClose(false); \/\/ this is a pool callback so no need to clean pool\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -1494,1 +1523,2 @@\n-    private Vector<LdapCtx> unsolicited = new Vector<>(3);\n+    private final Vector<LdapCtx> unsolicited = new Vector<>(3);\n+    private final ReentrantLock unsolicitedLock = new ReentrantLock();\n@@ -1536,1 +1566,2 @@\n-            synchronized (unsolicited) {\n+            unsolicitedLock.lock();\n+            try {\n@@ -1554,0 +1585,2 @@\n+            } finally {\n+                unsolicitedLock.unlock();\n@@ -1582,1 +1615,2 @@\n-        synchronized (unsolicited) {\n+        unsolicitedLock.lock();\n+        try {\n@@ -1587,0 +1621,2 @@\n+        } finally {\n+            unsolicitedLock.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapClient.java","additions":247,"deletions":211,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -303,0 +304,1 @@\n+    private final ReentrantLock lock = new ReentrantLock(); \/\/ LdapCtx instance lock\n@@ -2652,5 +2654,7 @@\n-    public synchronized void close() throws NamingException {\n-        if (debug) {\n-            System.err.println(\"LdapCtx: close() called \" + this);\n-            (new Throwable()).printStackTrace();\n-        }\n+    public void close() throws NamingException {\n+        lock.lock();\n+        try {\n+            if (debug) {\n+                System.err.println(\"LdapCtx: close() called \" + this);\n+                (new Throwable()).printStackTrace();\n+            }\n@@ -2658,5 +2662,5 @@\n-        \/\/ Event (normal and unsolicited)\n-        if (eventSupport != null) {\n-            eventSupport.cleanup(); \/\/ idempotent\n-            removeUnsolicited();\n-        }\n+            \/\/ Event (normal and unsolicited)\n+            if (eventSupport != null) {\n+                eventSupport.cleanup(); \/\/ idempotent\n+                removeUnsolicited();\n+            }\n@@ -2664,6 +2668,10 @@\n-        \/\/ Enumerations that are keeping the connection alive\n-        if (enumCount > 0) {\n-            if (debug)\n-                System.err.println(\"LdapCtx: close deferred\");\n-            closeRequested = true;\n-            return;\n+            \/\/ Enumerations that are keeping the connection alive\n+            if (enumCount > 0) {\n+                if (debug)\n+                    System.err.println(\"LdapCtx: close deferred\");\n+                closeRequested = true;\n+                return;\n+            }\n+            closeConnection(SOFT_CLOSE);\n+        } finally {\n+            lock.unlock();\n@@ -2671,1 +2679,0 @@\n-        closeConnection(SOFT_CLOSE);\n@@ -2788,1 +2795,3 @@\n-                synchronized (clnt) {\n+                ReentrantLock clientLock = clnt.lock;\n+                clientLock.lock();\n+                try {\n@@ -2795,0 +2804,2 @@\n+                } finally {\n+                    clientLock.unlock();\n@@ -2894,1 +2905,3 @@\n-            synchronized (clnt.conn.startTlsLock) {\n+            ReentrantLock startTlsLock = clnt.conn.startTlsLock;\n+            startTlsLock.lock();\n+            try {\n@@ -2898,0 +2911,2 @@\n+            } finally {\n+                startTlsLock.unlock();\n@@ -2970,3 +2985,8 @@\n-    synchronized void incEnumCount() {\n-        ++enumCount;\n-        if (debug) System.err.println(\"LdapCtx: \" + this + \" enum inc: \" + enumCount);\n+    void incEnumCount() {\n+        lock.lock();\n+        try {\n+            ++enumCount;\n+            if (debug) System.err.println(\"LdapCtx: \" + this + \" enum inc: \" + enumCount);\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -2975,3 +2995,5 @@\n-    synchronized void decEnumCount() {\n-        --enumCount;\n-        if (debug) System.err.println(\"LdapCtx: \" + this + \" enum dec: \" + enumCount);\n+    void decEnumCount() {\n+        lock.lock();\n+        try {\n+            --enumCount;\n+            if (debug) System.err.println(\"LdapCtx: \" + this + \" enum dec: \" + enumCount);\n@@ -2979,5 +3001,6 @@\n-        if (enumCount == 0 && closeRequested) {\n-            try {\n-                close();\n-            } catch (NamingException e) {\n-                \/\/ ignore failures\n+            if (enumCount == 0 && closeRequested) {\n+                try {\n+                    close();\n+                } catch (NamingException e) {\n+                    \/\/ ignore failures\n+                }\n@@ -2985,0 +3008,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -3579,5 +3604,8 @@\n-    public void addNamingListener(String nm, String filter, SearchControls ctls,\n-        NamingListener l) throws NamingException {\n-            if (eventSupport == null)\n-                eventSupport = new EventSupport(this);\n-            eventSupport.addNamingListener(getTargetName(new CompositeName(nm)),\n+    public void addNamingListener(String nm, String filter,\n+                                  SearchControls ctls, NamingListener l)\n+            throws NamingException {\n+\n+        if (eventSupport == null)\n+            eventSupport = new EventSupport(this);\n+\n+        eventSupport.addNamingListener(getTargetName(new CompositeName(nm)),\n@@ -3586,4 +3614,4 @@\n-            \/\/ If first time asking for unsol\n-            if (l instanceof UnsolicitedNotificationListener && !unsolicited) {\n-                addUnsolicited();\n-            }\n+        \/\/ If first time asking for unsol\n+        if (l instanceof UnsolicitedNotificationListener && !unsolicited) {\n+            addUnsolicited();\n+        }\n@@ -3656,1 +3684,3 @@\n-        synchronized (eventSupport) {\n+        ReentrantLock eventSupportLock = eventSupport.lock;\n+        eventSupportLock.lock();\n+        try {\n@@ -3659,0 +3689,2 @@\n+        } finally {\n+            eventSupportLock.unlock();\n@@ -3685,1 +3717,3 @@\n-        synchronized(eventSupport) {\n+        ReentrantLock eventSupportLock = eventSupport.lock;\n+        eventSupportLock.lock();\n+        try {\n@@ -3690,0 +3724,2 @@\n+        } finally {\n+            eventSupportLock.unlock();\n@@ -3702,1 +3738,3 @@\n-        synchronized(eventSupport) {\n+        ReentrantLock eventSupportLock = eventSupport.lock;\n+        eventSupportLock.lock();\n+        try {\n@@ -3713,0 +3751,2 @@\n+        } finally {\n+            eventSupportLock.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapCtx.java","additions":83,"deletions":43,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -46,1 +47,1 @@\n-    private static final Object LOCK = new int[0];\n+    private static final ReentrantLock LOCK = new ReentrantLock();\n@@ -78,1 +79,2 @@\n-        synchronized (LOCK) {\n+        LOCK.lock();\n+        try {\n@@ -81,0 +83,2 @@\n+        } finally {\n+            LOCK.unlock();\n@@ -99,1 +103,2 @@\n-        synchronized (LOCK) {\n+        LOCK.lock();\n+        try {\n@@ -106,0 +111,2 @@\n+        } finally {\n+            LOCK.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapDnsProviderService.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.naming.NamingException;\n@@ -34,0 +33,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -49,0 +49,2 @@\n+    \/\/ LdapRequest instance lock\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -65,3 +67,8 @@\n-    synchronized void close() {\n-        closed = true;\n-        replies.offer(EOF);\n+    void close() {\n+        lock.lock();\n+        try {\n+            closed = true;\n+            replies.offer(EOF);\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -74,8 +81,2 @@\n-    synchronized boolean addReplyBer(BerDecoder ber) {\n-        \/\/ check the closed boolean value here as we don't want anything\n-        \/\/ to be added to the queue after close() has been called.\n-        if (cancelled || closed) {\n-            return false;\n-        }\n-\n-        \/\/ peek at the BER buffer to check if it is a SearchResultDone PDU\n+    boolean addReplyBer(BerDecoder ber) {\n+        lock.lock();\n@@ -83,7 +84,5 @@\n-            ber.parseSeq(null);\n-            ber.parseInt();\n-            completed = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n-        } catch (IOException e) {\n-            \/\/ ignore\n-        }\n-        ber.reset();\n+            \/\/ check the closed boolean value here as we don't want anything\n+            \/\/ to be added to the queue after close() has been called.\n+            if (cancelled || closed) {\n+                return false;\n+            }\n@@ -91,6 +90,9 @@\n-        \/\/ Add a new reply to the queue of unprocessed replies.\n-        try {\n-            replies.put(ber);\n-        } catch (InterruptedException e) {\n-            \/\/ ignore\n-        }\n+            \/\/ peek at the BER buffer to check if it is a SearchResultDone PDU\n+            try {\n+                ber.parseSeq(null);\n+                ber.parseInt();\n+                completed = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n+            } catch (IOException e) {\n+                \/\/ ignore\n+            }\n+            ber.reset();\n@@ -98,1 +100,11 @@\n-        return pauseAfterReceipt;\n+            \/\/ Add a new reply to the queue of unprocessed replies.\n+            try {\n+                replies.put(ber);\n+            } catch (InterruptedException e) {\n+                \/\/ ignore\n+            }\n+\n+            return pauseAfterReceipt;\n+        } finally {\n+            lock.unlock();\n+        }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapRequest.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -397,0 +399,3 @@\n+        \/\/ SchemaInfo instance lock\n+        private final ReentrantLock lock = new ReentrantLock();\n+\n@@ -407,4 +412,9 @@\n-        synchronized void close() throws NamingException {\n-            if (schemaEntry != null) {\n-                schemaEntry.close();\n-                schemaEntry = null;\n+        void close() throws NamingException {\n+            lock.lock();\n+            try {\n+                if (schemaEntry != null) {\n+                    schemaEntry.close();\n+                    schemaEntry = null;\n+                }\n+            } finally {\n+                lock.unlock();\n@@ -420,1 +430,1 @@\n-        synchronized void modifyAttributes(Hashtable<?,?> env,\n+        void modifyAttributes(Hashtable<?,?> env,\n@@ -423,2 +433,8 @@\n-            if (schemaEntry == null) {\n-                schemaEntry = reopenEntry(env);\n+            lock.lock();\n+            try {\n+                if (schemaEntry == null) {\n+                    schemaEntry = reopenEntry(env);\n+                }\n+                schemaEntry.modifyAttributes(\"\", mods);\n+            } finally {\n+                lock.unlock();\n@@ -426,1 +442,0 @@\n-            schemaEntry.modifyAttributes(\"\", mods);\n@@ -429,1 +444,1 @@\n-        synchronized void modifyAttributes(Hashtable<?,?> env, int mod,\n+        void modifyAttributes(Hashtable<?,?> env, int mod,\n@@ -431,2 +446,8 @@\n-            if (schemaEntry == null) {\n-                schemaEntry = reopenEntry(env);\n+            lock.lock();\n+            try {\n+                if (schemaEntry == null) {\n+                    schemaEntry = reopenEntry(env);\n+                }\n+                schemaEntry.modifyAttributes(\"\", mod, attrs);\n+            } finally {\n+                lock.unlock();\n@@ -434,1 +455,0 @@\n-            schemaEntry.modifyAttributes(\"\", mod, attrs);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSchemaCtx.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+\n@@ -49,0 +51,2 @@\n+    \/\/ ConnectionDesc instance lock\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -85,9 +89,14 @@\n-    synchronized boolean release() {\n-        d(\"release()\");\n-        if (state == BUSY) {\n-            state = IDLE;\n-\n-            idleSince = System.currentTimeMillis();\n-            return true;  \/\/ Connection released, ready for reuse\n-        } else {\n-            return false; \/\/ Connection wasn't busy to begin with\n+    boolean release() {\n+        lock.lock();\n+        try {\n+            d(\"release()\");\n+            if (state == BUSY) {\n+                state = IDLE;\n+\n+                idleSince = System.currentTimeMillis();\n+                return true;  \/\/ Connection released, ready for reuse\n+            } else {\n+                return false; \/\/ Connection wasn't busy to begin with\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -103,7 +112,14 @@\n-    synchronized PooledConnection tryUse() {\n-        d(\"tryUse()\");\n-\n-        if (state == IDLE) {\n-            state = BUSY;\n-            ++useCount;\n-            return conn;\n+    PooledConnection tryUse() {\n+        lock.lock();\n+        try {\n+            d(\"tryUse()\");\n+\n+            if (state == IDLE) {\n+                state = BUSY;\n+                ++useCount;\n+                return conn;\n+            }\n+\n+            return null;\n+        } finally {\n+            lock.unlock();\n@@ -111,2 +127,0 @@\n-\n-        return null;\n@@ -124,12 +138,17 @@\n-    synchronized boolean expire(long threshold) {\n-        if (state == IDLE && idleSince < threshold) {\n-\n-            d(\"expire(): expired\");\n-\n-            state = EXPIRED;\n-            conn.closeConnection();  \/\/ Close real connection\n-\n-            return true;  \/\/ Expiration successful\n-        } else {\n-            d(\"expire(): not expired\");\n-            return false; \/\/ Expiration did not occur\n+    boolean expire(long threshold) {\n+        lock.lock();\n+        try {\n+            if (state == IDLE && idleSince < threshold) {\n+\n+                d(\"expire(): expired\");\n+\n+                state = EXPIRED;\n+                conn.closeConnection();  \/\/ Close real connection\n+\n+                return true;  \/\/ Expiration successful\n+            } else {\n+                d(\"expire(): not expired\");\n+                return false; \/\/ Expiration did not occur\n+            }\n+        } finally {\n+            lock.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/ConnectionDesc.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import javax.naming.CommunicationException;\n@@ -321,3 +320,8 @@\n-    synchronized void close() {\n-        expire(System.currentTimeMillis());     \/\/ Expire idle connections\n-        closed = true;   \/\/ Close in-use connections when they are returned\n+    void close() {\n+        lock.lock();\n+        try {\n+            expire(System.currentTimeMillis());     \/\/ Expire idle connections\n+            closed = true;   \/\/ Close in-use connections when they are returned\n+        } finally {\n+            lock.unlock();\n+        }\n@@ -333,1 +337,2 @@\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -351,0 +356,2 @@\n+        } finally {\n+          lock.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Connections.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,1 @@\n+    private final ReentrantLock mapLock = new ReentrantLock();\n@@ -128,1 +129,2 @@\n-            synchronized (map) {\n+            mapLock.lock();\n+            try {\n@@ -130,0 +132,2 @@\n+            } finally {\n+                mapLock.unlock();\n@@ -162,1 +166,2 @@\n-        synchronized (map) {\n+        mapLock.lock();\n+        try {\n@@ -182,0 +187,2 @@\n+        } finally {\n+            mapLock.unlock();\n@@ -237,1 +244,2 @@\n-        synchronized (map) {\n+        mapLock.lock();\n+        try {\n@@ -239,0 +247,2 @@\n+        } finally {\n+            mapLock.unlock();\n@@ -251,1 +261,2 @@\n-        synchronized (map) {\n+        mapLock.lock();\n+        try {\n@@ -253,0 +264,2 @@\n+        } finally {\n+            mapLock.unlock();\n@@ -291,1 +304,2 @@\n-        synchronized (map) {\n+        mapLock.lock();\n+        try {\n@@ -299,0 +313,2 @@\n+        } finally {\n+            mapLock.unlock();\n@@ -305,2 +321,5 @@\n-        synchronized (map) {\n-            return super.toString() + \" \" + map.toString();\n+        mapLock.lock();\n+        try {\n+            return super.toString() + \" \" + map;\n+        } finally {\n+            mapLock.unlock();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Pool.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"}]}