{"files":[{"patch":"@@ -445,19 +445,0 @@\n-\n-        \/\/ Discard any direct 'this' reference that can't be valid because its\n-        \/\/ type is not compatible with the target class we're analyzing for.\n-        \/\/ Note, tricky code could cast away and then cast back to evade this.\n-        if (referenceExpressionNode) {\n-\n-            \/\/ We treat instance methods as having a \"value\" equal to their instance\n-            Type type = tree.type;\n-            Symbol sym = TreeInfo.symbolFor(tree);\n-            if (sym != null &&\n-                sym.kind == MTH &&\n-                (sym.flags() & Flags.STATIC) == 0) {\n-                type = sym.owner.type;\n-            }\n-\n-            \/\/ If the expression type is incompatible with 'this', discard it\n-            if (type != null && !targetClass.sym.isSubClass(type.tsym, types))\n-                refs.remove(ExprRef.direct(depth));\n-        }\n@@ -1096,1 +1077,1 @@\n-    private <T> void visitScoped(boolean promote, Runnable action) {\n+    private void visitScoped(boolean promote, Runnable action) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static com.sun.tools.javac.code.TypeTag.CLASS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}