{"files":[{"patch":"@@ -174,1 +174,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked this-escape, \\\n@@ -181,1 +181,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast this-escape, \\\n@@ -185,1 +185,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast this-escape, \\\n@@ -192,1 +192,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked cast lossy-conversions, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked cast lossy-conversions this-escape, \\\n@@ -197,1 +197,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked, \\\n+    DISABLED_WARNINGS := rawtypes unchecked this-escape, \\\n@@ -202,1 +202,1 @@\n-    DISABLED_WARNINGS := rawtypes, \\\n+    DISABLED_WARNINGS := rawtypes this-escape, \\\n@@ -208,1 +208,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked, \\\n+    DISABLED_WARNINGS := rawtypes unchecked this-escape, \\\n@@ -218,1 +218,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked deprecation, \\\n+    DISABLED_WARNINGS := rawtypes unchecked deprecation this-escape, \\\n@@ -223,0 +223,1 @@\n+    DISABLED_WARNINGS := this-escape, \\\n","filename":"make\/CompileDemos.gmk","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := fallthrough, \\\n+    DISABLED_WARNINGS := fallthrough this-escape, \\\n","filename":"make\/CompileModuleTools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/CompileToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.datatransfer\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n+DISABLED_WARNINGS_java += lossy-conversions this-escape\n","filename":"make\/modules\/java.desktop\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.logging\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.management\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.naming\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.net.http\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.rmi\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.security.jgss\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.security.sasl\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.sql.rowset\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.sql\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.xml.crypto\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n+DISABLED_WARNINGS_java += lossy-conversions this-escape\n","filename":"make\/modules\/java.xml\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.accessibility\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.attach\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.charsets\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.compiler\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.ec\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.mscapi\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.dynalink\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-    fallthrough\n+    fallthrough this-escape\n","filename":"make\/modules\/jdk.hotspot.agent\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += missing-explicit-ctor\n+DISABLED_WARNINGS_java += missing-explicit-ctor this-escape\n","filename":"make\/modules\/jdk.httpserver\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.jvmstat\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.le\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.opt\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.javadoc\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jcmd\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jconsole\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdi\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.jlink\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jshell\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.jstatd\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.localedata\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.management\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.naming.dns\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.zipfs\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -54,1 +54,1 @@\n-    DISABLED_WARNINGS := options serial try, \\\n+    DISABLED_WARNINGS := options serial try this-escape, \\\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,0 +309,5 @@\n+        \/**\n+         * Warn about possible 'this' escapes before subclass instance is fully initialized.\n+         *\/\n+        THIS_ESCAPE(\"this-escape\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2340,0 +2340,17 @@\n+    \/** Determine whether the given outer class strictly encloses the inner one.\n+     *\/\n+    public boolean hasOuterClass(Type innerType, Type outerType) {\n+        if (!innerType.hasTag(CLASS) || !outerType.hasTag(CLASS))\n+            return false;\n+        innerType = erasure(innerType);\n+        outerType = erasure(outerType);\n+        for (Type type = innerType.getEnclosingType();\n+                type != null && type.hasTag(CLASS);\n+                type = type.getEnclosingType()) {\n+            if (erasure(type).equalsIgnoreMetadata(outerType)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+        new ThisEscapeAnalyzer(names, types, log, lint).analyzeTree(env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1469 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.Map.Entry;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Pair;\n+\n+import static com.sun.tools.javac.code.Kinds.Kind.*;\n+import static com.sun.tools.javac.code.TypeTag.*;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n+\n+\/**\n+ * Looks for possible 'this' escapes and generates corresponding warnings.\n+ *\n+ * <p>\n+ * A 'this' escape is when a constructor invokes a method that could be overridden in a\n+ * subclass, in which case the method will execute before the subclass constructor has\n+ * finished initializing the instance.\n+ *\n+ * <p>\n+ * This class attempts to identify possible 'this' escapes while also striking a balance\n+ * between false positives, false negatives, and code complexity. We do this by \"executing\"\n+ * the code in candidate constructors and tracking where the original 'this' reference goes.\n+ * If it ever passes to code outside of the current compilation unit, we declare a possible leak.\n+ * On the other hand, when constructors and non-overridable methods within the same compilation\n+ * unit are invoked, we \"invoke\" them to follow references.\n+ *\n+ * <p>\n+ * When tracking references, we distinguish between direct references and indirect references,\n+ * but do no further refinement. In particular, we do not attempt to track references stored\n+ * in fields at all. So we are mainly just trying to track what's on the Java stack.\n+ *\n+ * <p>\n+ * A few notes on this implementation:\n+ * <ul>\n+ *  <li>We \"execute\" constructors and track where the 'this' reference goes as the constructor executes.\n+ *  <li>We use a very simplified flow analysis that you might call a \"flood analysis\", where the union\n+ *      of every possible code branch is taken.\n+ *  <li>A \"leak\" is defined as the possible passing of a subclassed 'this' reference to code defined\n+ *      outside of the current compilation unit.\n+ *  <ul>\n+ *      <li>In other words, we don't try to protect the current compilation unit from itself.\n+ *      <li>For example, we ignore private constructors because they can never be directly invoked\n+ *          by external subclasses, etc. However, they can be indirectly invoked by other constructors.\n+ *  <\/ul>\n+ *  <li>If a constructor invokes a method defined in the same compilation unit, and that method cannot\n+ *      be overridden, then our analysis can safely \"recurse\" into the method.\n+ *  <ul>\n+ *      <li>When this occurs the warning displays each step in the stack trace to help in comprehension.\n+ *  <\/ul>\n+ *  <li>The possible locations for a 'this' reference that we try to track are:\n+ *  <ul>\n+ *      <li>Current 'this' instance\n+ *      <li>Current outer 'this' instance\n+ *      <li>Local parameter\/variable\n+ *      <li>Method return value\n+ *      <li>Current expression value (i.e. top of stack)\n+ *  <\/ul>\n+ *  <li>We assume that native methods do not leak.\n+ *  <li>We don't try to track assignments to &amp; from fields (for future study).\n+ *  <li>We don't try to follow {@code super()} invocations.\n+ *  <li>We categorize tracked references as direct or indirect to add a tiny bit of nuance.\n+ *  <\/ul>\n+ *\/\n+class ThisEscapeAnalyzer extends TreeScanner {\n+\n+    private final Names names;\n+    private final Types types;\n+    private final Log log;\n+    private       Lint lint;\n+\n+\/\/ These fields are scoped to the entire COMPILATION UNIT\n+\n+    \/** Maps symbols of all methods to their corresponding declarations.\n+     *\/\n+    private final Map<Symbol, MethodInfo> methodMap = new LinkedHashMap<>();\n+\n+    \/** Contains symbols of fields and methods that have warnings suppressed.\n+     *\/\n+    private final Set<Symbol> suppressed = new HashSet<>();\n+\n+    \/** The declaring class of the constructor we're currently analyzing.\n+     *  This is the 'this' type we're trying to detect leaks of.\n+     *\/\n+    private JCClassDecl targetClass;\n+\n+    \/** Snapshots of {@link #callStack} where possible 'this' escapes occur.\n+     *\/\n+    private ArrayList<DiagnosticPosition[]> warningList = new ArrayList<>();\n+\n+\/\/ These fields are scoped to the CONSTRUCTOR BEING ANALYZED\n+\n+    \/** The declaring class of the \"invoked\" method we're currently analyzing.\n+     *  This is either the analyzed constructor or some method it invokes.\n+     *\/\n+    private JCClassDecl methodClass;\n+\n+    \/** The current \"call stack\" during our analysis. The first entry is some method\n+     *  invoked from the target constructor; if empty, we're still in the constructor.\n+     *\/\n+    private final ArrayDeque<DiagnosticPosition> callStack = new ArrayDeque<>();\n+\n+    \/** Used to terminate recursion in {@link #invokeInvokable invokeInvokable()}.\n+     *\/\n+    private final Set<Pair<JCTree, RefSet<Ref>>> invocations = new HashSet<>();\n+\n+    \/** Snapshot of {@link #callStack} where a possible 'this' escape occurs.\n+     *  If non-null, a 'this' escape warning has been found in the current\n+     *  constructor statement, initialization block statement, or field initializer.\n+     *\/\n+    private DiagnosticPosition[] pendingWarning;\n+\n+\/\/ These fields are scoped to the CONSTRUCTOR OR INVOKED METHOD BEING ANALYZED\n+\n+    \/** Current lexical scope depth in the constructor or method we're currently analyzing.\n+     *  Depth zero is the outermost scope. Depth -1 means we're not analyzing.\n+     *\/\n+    private int depth = -1;\n+\n+    \/** Possible 'this' references in the constructor or method we're currently analyzing.\n+     *  Null value means we're not analyzing.\n+     *\/\n+    private RefSet<Ref> refs;\n+\n+\/\/ Constructor\n+\n+    ThisEscapeAnalyzer(Names names, Types types, Log log, Lint lint) {\n+        this.names = names;\n+        this.types = types;\n+        this.log = log;\n+        this.lint = lint;\n+    }\n+\n+\/\/\n+\/\/ Main method\n+\/\/\n+\n+    public void analyzeTree(Env<AttrContext> env) {\n+        this.analyzeTree(env, env.tree);\n+    }\n+\n+    public void analyzeTree(Env<AttrContext> env, JCTree tree) {\n+\n+        \/\/ Sanity check\n+        Assert.check(this.checkInvariants(false, false));\n+\n+        \/\/ Short circuit if warnings are totally disabled\n+        if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+            return;\n+\n+        \/\/ Build a mapping from symbols of methods to their declarations.\n+        \/\/ Classify all ctors and methods as analyzable and\/or invokable.\n+        \/\/ Track which methods and variables have warnings are suppressed.\n+        new TreeScanner() {\n+\n+            private Lint lint = ThisEscapeAnalyzer.this.lint;\n+            private JCClassDecl currentClass;\n+            private boolean privateOuter;\n+\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                final JCClassDecl currentClassPrev = this.currentClass;\n+                final boolean privateOuterPrev = this.privateOuter;\n+                final Lint lintPrev = this.lint;\n+                this.lint = this.lint.augment(tree.sym);\n+                try {\n+                    this.currentClass = tree;\n+                    this.privateOuter |= tree.sym.isAnonymous();\n+                    this.privateOuter |= (tree.mods.flags & Flags.PRIVATE) != 0;\n+\n+                    \/\/ Recurse\n+                    super.visitClassDef(tree);\n+                } finally {\n+                    this.currentClass = currentClassPrev;\n+                    this.privateOuter = privateOuterPrev;\n+                    this.lint = lintPrev;\n+                }\n+            }\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                final Lint lintPrev = this.lint;\n+                this.lint = this.lint.augment(tree.sym);\n+                try {\n+                    \/\/ Track warning suppression\n+                    if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        ThisEscapeAnalyzer.this.suppressed.add(tree.sym);\n+\n+                    \/\/ Recurse\n+                    super.visitVarDef(tree);\n+                } finally {\n+                    this.lint = lintPrev;\n+                }\n+            }\n+\n+            @Override\n+            public void visitMethodDef(JCMethodDecl tree) {\n+                final Lint lintPrev = this.lint;\n+                this.lint = this.lint.augment(tree.sym);\n+                try {\n+                    \/\/ Track warning suppression\n+                    if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        ThisEscapeAnalyzer.this.suppressed.add(tree.sym);\n+\n+                    \/\/ Determine if this is a constructor we should analyze\n+                    final boolean analyzable = this.currentClassIsExternallyExtendable() &&\n+                        TreeInfo.isConstructor(tree) &&\n+                        !tree.sym.isPrivate() &&\n+                        !ThisEscapeAnalyzer.this.suppressed.contains(tree.sym);\n+\n+                    \/\/ Determine if this method is \"invokable\" in an analysis (can't be overridden)\n+                    final boolean invokable = !this.currentClassIsExternallyExtendable() ||\n+                        TreeInfo.isConstructor(tree) ||\n+                        (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+\n+                    \/\/ Add method or constructor to map\n+                    final MethodInfo info = new MethodInfo(this.currentClass, tree, analyzable, invokable);\n+                    ThisEscapeAnalyzer.this.methodMap.put(tree.sym, info);\n+\n+                    \/\/ Recurse\n+                    super.visitMethodDef(tree);\n+                } finally {\n+                    this.lint = lintPrev;\n+                }\n+            }\n+\n+            \/\/ Determines if the current class could be extended in some external compilation unit\n+            private boolean currentClassIsExternallyExtendable() {\n+                return !this.currentClass.sym.isFinal() &&\n+                  !(this.currentClass.sym.isSealed() && this.currentClass.permitting.isEmpty()) &&\n+                  !(this.currentClass.sym.owner.kind == MTH) &&\n+                  !this.privateOuter;\n+            }\n+        }.scan(tree);\n+\n+        \/\/ TODO: eliminate sealed classes where all permitted subclasses are in this compilation unit\n+\n+        \/\/ Now analyze all of the analyzable constructors we found\n+        for (Map.Entry<Symbol, MethodInfo> entry : this.methodMap.entrySet()) {\n+\n+            \/\/ We are looking for analyzable constructors only\n+            final Symbol sym = entry.getKey();\n+            final MethodInfo methodInfo = entry.getValue();\n+            if (!methodInfo.isAnalyzable())\n+                continue;\n+\n+            \/\/ Analyze constructor body\n+            this.targetClass = methodInfo.getDeclaringClass();\n+            this.methodClass = this.targetClass;\n+            Assert.check(this.depth == -1);\n+            Assert.check(this.refs == null);\n+            this.pushScope();\n+            try {\n+\n+                \/\/ Add the initial 'this' reference\n+                this.refs = RefSet.newEmpty();\n+                this.refs.add(ThisRef.direct());\n+\n+                \/\/ Scan constructor statements\n+                this.analyzeStatements(methodInfo.getDeclaration().body.stats);\n+            } finally {\n+                this.popScope();\n+                this.methodClass = null;\n+                this.targetClass = null;\n+                this.refs = null;\n+            }\n+        }\n+\n+        \/\/ Eliminate duplicate warnings. Warning B duplicates warning A if the stack trace of A is a prefix\n+        \/\/ of the stack trace of B. For example, if constructor Foo(int x) has a leak, and constructor\n+        \/\/ Foo() invokes this(0), then emitting a warning for Foo() would be redundant.\n+        final BiPredicate<DiagnosticPosition[], DiagnosticPosition[]> extendsAsPrefix = (warning1, warning2) -> {\n+            if (warning2.length < warning1.length)\n+                return false;\n+            for (int index = 0; index < warning1.length; index++) {\n+                if (warning2[index].getPreferredPosition() != warning1[index].getPreferredPosition())\n+                    return false;\n+            }\n+            return true;\n+        };\n+\n+        \/\/ Stack traces are ordered top to bottom, and so duplicates always have the same first element(s).\n+        \/\/ Sort the stack traces lexicographically, so that duplicates immediately follow what they duplicate.\n+        final Comparator<DiagnosticPosition[]> ordering = (warning1, warning2) -> {\n+            for (int index1 = 0, index2 = 0; true; index1++, index2++) {\n+                final boolean end1 = index1 >= warning1.length;\n+                final boolean end2 = index2 >= warning2.length;\n+                if (end1 && end2)\n+                    return 0;\n+                if (end1)\n+                    return -1;\n+                if (end2)\n+                    return 1;\n+                final int posn1 = warning1[index1].getPreferredPosition();\n+                final int posn2 = warning2[index2].getPreferredPosition();\n+                final int diff = Integer.compare(posn1, posn2);\n+                if (diff != 0)\n+                    return diff;\n+            }\n+        };\n+        this.warningList.sort(ordering);\n+\n+        \/\/ Now emit the warnings, but skipping over duplicates as we go through the list\n+        DiagnosticPosition[] previous = null;\n+        for (DiagnosticPosition[] warning : this.warningList) {\n+\n+            \/\/ Skip duplicates\n+            if (previous != null && extendsAsPrefix.test(previous, warning))\n+                continue;\n+            previous = warning;\n+\n+            \/\/ Emit warnings showing the entire stack trace\n+            JCDiagnostic.Warning key = Warnings.PossibleThisEscape;\n+            int remain = warning.length;\n+            do {\n+                final DiagnosticPosition pos = warning[--remain];\n+                this.log.warning(Lint.LintCategory.THIS_ESCAPE, pos, key);\n+                key = Warnings.PossibleThisEscapeLocation;\n+            } while (remain > 0);\n+        }\n+        this.warningList.clear();\n+    }\n+\n+    private void analyzeStatements(List<JCStatement> stats) {\n+        for (JCStatement stat : stats) {\n+\n+            \/\/ Analyze statement\n+            this.scan(stat);\n+\n+            \/\/ Capture any pending warning generated\n+            if (this.copyPendingWarning())\n+                break;                      \/\/ report at most one warning per constructor\n+        }\n+    }\n+\n+    @Override\n+    public void scan(JCTree tree) {\n+\n+        \/\/ Check node\n+        if (tree == null || tree.type == Type.stuckType)\n+            return;\n+\n+        \/\/ Sanity check\n+        Assert.check(this.checkInvariants(true, false));\n+\n+        \/\/ Can this expression node possibly leave a 'this' reference on the stack?\n+        final boolean referenceExpressionNode;\n+        switch (tree.getTag()) {\n+        case CASE:\n+        case SWITCH_EXPRESSION:\n+        case CONDEXPR:\n+        case YIELD:\n+        case APPLY:\n+        case NEWCLASS:\n+        case NEWARRAY:\n+        case LAMBDA:\n+        case PARENS:\n+        case ASSIGN:\n+        case TYPECAST:\n+        case INDEXED:\n+        case SELECT:\n+        case REFERENCE:\n+        case IDENT:\n+        case NULLCHK:\n+        case LETEXPR:\n+            referenceExpressionNode = true;\n+            break;\n+        default:\n+            referenceExpressionNode = false;\n+            break;\n+        }\n+\n+        \/\/ Scan node\n+        super.scan(tree);\n+\n+        \/\/ Sanity check\n+        Assert.check(this.checkInvariants(true, referenceExpressionNode));\n+\n+        \/\/ Discard any direct 'this' reference that's incompatible with the target type\n+        if (referenceExpressionNode) {\n+\n+            \/\/ We treat instance methods as having a \"value\" equal to their instance\n+            Type type = tree.type;\n+            final Symbol sym = TreeInfo.symbolFor(tree);\n+            if (sym != null &&\n+                sym.kind == MTH &&\n+                (sym.flags() & Flags.STATIC) == 0) {\n+                type = sym.owner.type;\n+            }\n+\n+            \/\/ If the expression type is incompatible with 'this', discard it\n+            if (type != null && !this.isSubtype(this.targetClass.sym.type, type))\n+                this.refs.remove(ExprRef.direct(this.depth));\n+        }\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Class Declarations\n+\/\/\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        return;     \/\/ we're busy analyzing another class - skip\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Variable Declarations\n+\/\/\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+\n+        \/\/ Skip if ignoring warnings for this variable\n+        if (this.suppressed.contains(tree.sym))\n+            return;\n+\n+        \/\/ Scan initializer, if any\n+        this.scan(tree.init);\n+        if (this.isParamOrVar(tree.sym))\n+            this.refs.replaceExprs(this.depth, direct -> new VarRef(tree.sym, direct));\n+        else\n+            this.refs.discardExprs(this.depth);         \/\/ we don't track fields yet\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Methods\n+\/\/\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        Assert.check(false);        \/\/ we should never get here\n+    }\n+\n+    @Override\n+    public void visitApply(JCMethodInvocation invoke) {\n+\n+        \/\/ Get method symbol\n+        final MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n+\n+        \/\/ Recurse on method expression\n+        this.scan(invoke.meth);\n+        final boolean direct = this.refs.remove(ExprRef.direct(this.depth));\n+        final boolean indirect = this.refs.remove(ExprRef.indirect(this.depth));\n+\n+        \/\/ Determine if method receiver represents a possible reference\n+        final RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n+        if (sym != null && !sym.isStatic()) {\n+            if (direct)\n+                receiverRefs.add(ThisRef.direct());\n+            if (indirect)\n+                receiverRefs.add(ThisRef.indirect());\n+        }\n+\n+        \/\/ If \"super()\": ignore - we don't try to track into superclasses.\n+        \/\/ However, we do need to \"invoke\" non-static initializers\/blocks.\n+        final Name name = TreeInfo.name(invoke.meth);\n+        if (name == this.names._super) {\n+            this.scanInitializers();\n+            return;\n+        }\n+\n+        \/\/ \"Invoke\" the method\n+        this.invoke(invoke, sym, invoke.args, receiverRefs);\n+    }\n+\n+    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+\n+        \/\/ Skip if ignoring warnings for the invoked method\n+        if (this.suppressed.contains(sym))\n+            return;\n+\n+        \/\/ Ignore final methods in java.lang.Object (getClass(), notify(), etc.)\n+        if (sym != null &&\n+            sym.owner.kind == TYP &&\n+            ((ClassSymbol)sym.owner).fullname == this.names.java_lang_Object &&\n+            sym.isFinal()) {\n+            return;\n+        }\n+\n+        \/\/ Analyze method if possible, otherwise assume nothing\n+        final MethodInfo methodInfo = this.methodMap.get(sym);\n+        if (methodInfo != null && methodInfo.isInvokable())\n+            this.invokeInvokable(site, args, receiverRefs, methodInfo);\n+        else\n+            this.invokeUnknown(site, args, receiverRefs);\n+    }\n+\n+    \/\/ Scan field initializers and initialization blocks\n+    private void scanInitializers() {\n+        final DiagnosticPosition[] pendingWarningPrev = this.pendingWarning;\n+        this.pendingWarning = null;\n+        try {\n+            for (List<JCTree> defs = this.methodClass.defs; defs.nonEmpty(); defs = defs.tail) {\n+\n+                \/\/ Ignore static stuff\n+                if ((TreeInfo.flags(defs.head) & Flags.STATIC) != 0)\n+                    continue;\n+\n+                \/\/ Handle field initializers\n+                if (defs.head.hasTag(VARDEF)) {\n+                    this.scan((JCVariableDecl)defs.head);\n+                    this.copyPendingWarning();\n+                    continue;\n+                }\n+\n+                \/\/ Handle initialization block\n+                if (defs.head.hasTag(BLOCK)) {\n+                    this.visitScoped((JCBlock)defs.head, false, block -> this.analyzeStatements(block.stats));\n+                    continue;\n+                }\n+            }\n+        } finally {\n+            this.pendingWarning = pendingWarningPrev;\n+        }\n+    }\n+\n+    \/\/ Handle the invocation of a local analyzable method or constructor\n+    private void invokeInvokable(JCTree site, List<JCExpression> args,\n+        RefSet<?> receiverRefs, MethodInfo methodInfo) {\n+        Assert.check(methodInfo.isInvokable());\n+\n+        \/\/ Collect 'this' references found in method parameters\n+        final JCMethodDecl method = methodInfo.getDeclaration();\n+        final RefSet<VarRef> paramRefs = RefSet.newEmpty();\n+        List<JCVariableDecl> params = method.params;\n+        while (args.nonEmpty() && params.nonEmpty()) {\n+            final VarSymbol sym = params.head.sym;\n+            this.scan(args.head);\n+            this.refs.removeExprs(this.depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n+            args = args.tail;\n+            params = params.tail;\n+        }\n+\n+        \/\/ \"Invoke\" the method\n+        final JCClassDecl methodClassPrev = this.methodClass;\n+        this.methodClass = methodInfo.getDeclaringClass();\n+        final RefSet<Ref> refsPrev = this.refs;\n+        this.refs = RefSet.newEmpty();\n+        final int depthPrev = this.depth;\n+        this.depth = 0;\n+        this.callStack.push(site);\n+        try {\n+\n+            \/\/ Add initial references from method receiver\n+            this.refs.addAll(receiverRefs);\n+\n+            \/\/ Add initial references from parameters\n+            this.refs.addAll(paramRefs);\n+\n+            \/\/ Stop trivial cases here\n+            if (this.refs.isEmpty())\n+                return;\n+\n+            \/\/ Stop infinite recursion here\n+            final Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, this.refs.clone());\n+            if (!this.invocations.add(invocation))\n+                return;\n+\n+            \/\/ Scan method body to \"execute\" it\n+            try {\n+                this.scan(method.body);\n+            } finally {\n+                this.invocations.remove(invocation);\n+            }\n+\n+            \/\/ \"Return\" any references from method return value\n+            if (this.refs.remove(ReturnRef.direct()))\n+                refsPrev.add(ExprRef.direct(depthPrev));\n+            if (this.refs.remove(ReturnRef.indirect()))\n+                refsPrev.add(ExprRef.indirect(depthPrev));\n+        } finally {\n+            this.callStack.pop();\n+            this.depth = depthPrev;\n+            this.refs = refsPrev;\n+            this.methodClass = methodClassPrev;\n+        }\n+    }\n+\n+    \/\/ Handle invocation of an unknown or overridable method or constructor\n+    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<?> receiverRefs) {\n+\n+        \/\/ Detect leak via receiver\n+        if (!receiverRefs.isEmpty())\n+            this.leakAt(invoke);\n+\n+        \/\/ Detect leaks via method parameters\n+        for (JCExpression arg : args) {\n+            this.scan(arg);\n+            if (this.refs.discardExprs(this.depth))\n+                this.leakAt(arg);\n+        }\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - new Foo()\n+\/\/\n+\n+    @Override\n+    public void visitNewClass(JCNewClass tree) {\n+        final MethodInfo methodInfo = this.methodMap.get(tree.constructor);\n+        if (methodInfo != null && methodInfo.isInvokable())\n+            this.invokeInvokable(tree, tree.args, this.outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n+        else\n+            this.invokeUnknown(tree, tree.args, this.outerThisRefs(tree.encl, tree.clazz.type));\n+    }\n+\n+    \/\/ Determine 'this' references passed to a constructor via the outer 'this' instance\n+    private RefSet<OuterRef> outerThisRefs(JCExpression explicitOuterThis, Type type) {\n+        final RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n+        if (explicitOuterThis != null) {\n+            this.scan(explicitOuterThis);\n+            this.refs.removeExprs(this.depth, direct -> outerRefs.add(new OuterRef(direct)));\n+        } else if (this.types.hasOuterClass(type, this.methodClass.type)) {\n+            if (this.refs.contains(ThisRef.direct()))\n+                outerRefs.add(OuterRef.direct());\n+            if (this.refs.contains(ThisRef.indirect()))\n+                outerRefs.add(OuterRef.indirect());\n+        }\n+        return outerRefs;\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Codey Bits\n+\/\/\n+\n+    @Override\n+    public void visitBlock(JCBlock tree) {\n+        this.visitScoped(tree, false, super::visitBlock);\n+        Assert.check(this.checkInvariants(true, false));\n+    }\n+\n+    @Override\n+    public void visitDoLoop(JCDoWhileLoop tree) {\n+        this.visitLooped(tree, super::visitDoLoop);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(JCWhileLoop tree) {\n+        this.visitLooped(tree, super::visitWhileLoop);\n+    }\n+\n+    @Override\n+    public void visitForLoop(JCForLoop tree) {\n+        this.visitLooped(tree, super::visitForLoop);\n+    }\n+\n+    @Override\n+    public void visitForeachLoop(JCEnhancedForLoop tree) {\n+        this.visitLooped(tree, super::visitForeachLoop);\n+    }\n+\n+    @Override\n+    public void visitSwitch(JCSwitch tree) {\n+        this.visitScoped(tree, false, t -> {\n+            this.scan(t.selector);\n+            this.refs.discardExprs(this.depth);\n+            this.scan(t.cases);\n+        });\n+    }\n+\n+    @Override\n+    public void visitSwitchExpression(JCSwitchExpression tree) {\n+        this.visitScoped(tree, true, t -> {\n+            this.scan(t.selector);\n+            this.refs.discardExprs(this.depth);\n+            final RefSet<ExprRef> combinedRefs = new RefSet<>();\n+            for (List<JCCase> cases = t.cases; cases.nonEmpty(); cases = cases.tail) {\n+                this.scan(cases.head);\n+                combinedRefs.addAll(this.refs.removeExprs(this.depth));\n+            }\n+            this.refs.addAll(combinedRefs);\n+        });\n+    }\n+\n+    @Override\n+    public void visitCase(JCCase tree) {\n+        this.scan(tree.stats);          \/\/ no need to scan labels\n+    }\n+\n+    @Override\n+    public void visitLetExpr(LetExpr tree) {\n+        this.visitScoped(tree, true, super::visitLetExpr);\n+    }\n+\n+    @Override\n+    public void visitReturn(JCReturn tree) {\n+        this.scan(tree.expr);\n+        this.refs.replaceExprs(this.depth, ReturnRef::new);\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda lambda) {\n+        this.visitDeferred(() -> this.visitScoped(lambda, false, super::visitLambda));\n+    }\n+\n+    @Override\n+    public void visitAssign(JCAssign tree) {\n+        this.scan(tree.lhs);\n+        this.refs.discardExprs(this.depth);\n+        this.scan(tree.rhs);\n+        final VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n+        if (this.isParamOrVar(sym))\n+            this.refs.replaceExprs(this.depth, direct -> new VarRef(sym, direct));\n+        else\n+            this.refs.discardExprs(this.depth);         \/\/ we don't track fields yet\n+    }\n+\n+    @Override\n+    public void visitIndexed(JCArrayAccess tree) {\n+        this.scan(tree.indexed);\n+        this.refs.remove(ExprRef.direct(this.depth));\n+        final boolean indirectRef = this.refs.remove(ExprRef.indirect(this.depth));\n+        this.scan(tree.index);\n+        this.refs.discardExprs(this.depth);\n+        if (indirectRef) {\n+            this.refs.add(ExprRef.direct(this.depth));\n+            this.refs.add(ExprRef.indirect(this.depth));\n+        }\n+    }\n+\n+    @Override\n+    public void visitSelect(JCFieldAccess tree) {\n+\n+        \/\/ Scan the selected thing\n+        this.scan(tree.selected);\n+        final boolean selectedDirectRef = this.refs.remove(ExprRef.direct(this.depth));\n+        final boolean selectedIndirectRef = this.refs.remove(ExprRef.indirect(this.depth));\n+\n+        \/\/ Explicit 'this' reference?\n+        final Type.ClassType currentClassType = (Type.ClassType)this.methodClass.sym.type;\n+        if (TreeInfo.isExplicitThisReference(this.types, currentClassType, tree)) {\n+            if (this.refs.contains(ThisRef.direct()))\n+                this.refs.add(ExprRef.direct(this.depth));\n+            if (this.refs.contains(ThisRef.indirect()))\n+                this.refs.add(ExprRef.indirect(this.depth));\n+            return;\n+        }\n+\n+        \/\/ Explicit outer 'this' reference?\n+        final Type selectedType = this.types.erasure(tree.selected.type);\n+        if (selectedType.hasTag(CLASS)) {\n+            final Type.ClassType selectedClassType = (Type.ClassType)selectedType;\n+            if (tree.name == this.names._this &&\n+                this.types.hasOuterClass(currentClassType, selectedClassType)) {\n+                if (this.refs.contains(OuterRef.direct()))\n+                    this.refs.add(ExprRef.direct(this.depth));\n+                if (this.refs.contains(OuterRef.indirect()))\n+                    this.refs.add(ExprRef.indirect(this.depth));\n+                return;\n+            }\n+        }\n+\n+        \/\/ Methods - the \"value\" of a non-static method is a reference to its instance\n+        final Symbol sym = tree.sym;\n+        if (sym.kind == MTH) {\n+            if ((sym.flags() & Flags.STATIC) == 0) {\n+                if (selectedDirectRef)\n+                    this.refs.add(ExprRef.direct(this.depth));\n+                if (selectedIndirectRef)\n+                    this.refs.add(ExprRef.indirect(this.depth));\n+            }\n+            return;\n+        }\n+\n+        \/\/ Unknown\n+        return;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+\n+        \/\/ Scan target expression and extract 'this' references, if any\n+        this.scan(tree.expr);\n+        final boolean direct = this.refs.remove(ExprRef.direct(this.depth));\n+        final boolean indirect = this.refs.remove(ExprRef.indirect(this.depth));\n+\n+        \/\/ Gather receiver references for deferred invocation\n+        final RefSet<Ref> receiverRefs = RefSet.newEmpty();\n+        switch (tree.kind) {\n+        case UNBOUND:\n+        case STATIC:\n+        case TOPLEVEL:\n+        case ARRAY_CTOR:\n+            return;\n+        case SUPER:\n+            if (this.refs.contains(ThisRef.direct()))\n+                receiverRefs.add(ThisRef.direct());\n+            if (this.refs.contains(ThisRef.indirect()))\n+                receiverRefs.add(ThisRef.indirect());\n+            break;\n+        case BOUND:\n+            if (direct)\n+                receiverRefs.add(ThisRef.direct());\n+            if (indirect)\n+                receiverRefs.add(ThisRef.indirect());\n+            break;\n+        case IMPLICIT_INNER:\n+            receiverRefs.addAll(this.outerThisRefs(null, tree.expr.type));\n+            break;\n+        default:\n+            throw new RuntimeException(\"non-exhaustive?\");\n+        }\n+\n+        \/\/ Treat method reference just like the equivalent lambda\n+        this.visitDeferred(() -> this.invoke(tree, (MethodSymbol)tree.sym, List.nil(), receiverRefs));\n+    }\n+\n+    @Override\n+    public void visitIdent(JCIdent tree) {\n+\n+        \/\/ Reference to this?\n+        if (tree.name == names._this || tree.name == names._super) {\n+            if (this.refs.contains(ThisRef.direct()))\n+                this.refs.add(ExprRef.direct(this.depth));\n+            if (this.refs.contains(ThisRef.indirect()))\n+                this.refs.add(ExprRef.indirect(this.depth));\n+            return;\n+        }\n+\n+        \/\/ Parameter or local variable?\n+        if (this.isParamOrVar(tree.sym)) {\n+            final VarSymbol sym = (VarSymbol)tree.sym;\n+            if (this.refs.contains(VarRef.direct(sym)))\n+                this.refs.add(ExprRef.direct(this.depth));\n+            if (this.refs.contains(VarRef.indirect(sym)))\n+                this.refs.add(ExprRef.indirect(this.depth));\n+            return;\n+        }\n+\n+        \/\/ An unqualified, non-static method invocation must reference 'this' or outer 'this'.\n+        \/\/ The \"value\" of a non-static method is a reference to its instance.\n+        if (tree.sym.kind == MTH && (tree.sym.flags() & Flags.STATIC) == 0) {\n+            final MethodSymbol sym = (MethodSymbol)tree.sym;\n+\n+            \/\/ Check for implicit 'this' reference\n+            final Type.ClassType currentClassType = (Type.ClassType)this.methodClass.sym.type;\n+            final Type methodOwnerType = sym.owner.type;\n+            if (this.isSubtype(currentClassType, methodOwnerType)) {\n+                if (this.refs.contains(ThisRef.direct()))\n+                    this.refs.add(ExprRef.direct(this.depth));\n+                if (this.refs.contains(ThisRef.indirect()))\n+                    this.refs.add(ExprRef.indirect(this.depth));\n+                return;\n+            }\n+\n+            \/\/ Check for implicit outer 'this' reference\n+            if (this.types.hasOuterClass(currentClassType, methodOwnerType)) {\n+                if (this.refs.contains(OuterRef.direct()))\n+                    this.refs.add(ExprRef.direct(this.depth));\n+                if (this.refs.contains(OuterRef.indirect()))\n+                    this.refs.add(ExprRef.indirect(this.depth));\n+                return;\n+            }\n+\n+            \/\/ What could it be?\n+            \/\/Assert.check(false);\n+            return;\n+        }\n+\n+        \/\/ Unknown\n+        return;\n+    }\n+\n+    @Override\n+    public void visitSynchronized(JCSynchronized tree) {\n+        this.scan(tree.lock);\n+        this.refs.discardExprs(this.depth);\n+        this.scan(tree.body);\n+    }\n+\n+    @Override\n+    public void visitConditional(JCConditional tree) {\n+        this.scan(tree.cond);\n+        this.refs.discardExprs(this.depth);\n+        final RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        this.scan(tree.truepart);\n+        combinedRefs.addAll(this.refs.removeExprs(this.depth));\n+        this.scan(tree.falsepart);\n+        combinedRefs.addAll(this.refs.removeExprs(this.depth));\n+        this.refs.addAll(combinedRefs);\n+    }\n+\n+    @Override\n+    public void visitIf(JCIf tree) {\n+        this.scan(tree.cond);\n+        this.refs.discardExprs(this.depth);\n+        this.scan(tree.thenpart);\n+        this.scan(tree.elsepart);\n+    }\n+\n+    @Override\n+    public void visitExec(JCExpressionStatement tree) {\n+        this.scan(tree.expr);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+    @Override\n+    public void visitThrow(JCThrow tree) {\n+        this.scan(tree.expr);\n+        this.refs.discardExprs(this.depth);      \/\/ we don't try to follow refs from thrown exceptions\n+    }\n+\n+    @Override\n+    public void visitAssert(JCAssert tree) {\n+        this.scan(tree.cond);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+    @Override\n+    public void visitNewArray(JCNewArray tree) {\n+        boolean ref = false;\n+        if (tree.elems != null) {\n+            for (List<JCExpression> elems = tree.elems; elems.nonEmpty(); elems = elems.tail) {\n+                this.scan(elems.head);\n+                ref |= this.refs.discardExprs(this.depth);\n+            }\n+        }\n+        if (ref)\n+            this.refs.add(ExprRef.indirect(this.depth));\n+    }\n+\n+    @Override\n+    public void visitTypeCast(JCTypeCast tree) {\n+        this.scan(tree.expr);\n+    }\n+\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+    }\n+\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern that) {\n+    }\n+\n+    @Override\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        this.scan(tree.expr);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+    @Override\n+    public void visitTypeArray(JCArrayTypeTree tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeApply(JCTypeApply tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeUnion(JCTypeUnion tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeIntersection(JCTypeIntersection tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeParameter(JCTypeParameter tree) {\n+    }\n+\n+    @Override\n+    public void visitWildcard(JCWildcard tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeBoundKind(TypeBoundKind that) {\n+    }\n+\n+    @Override\n+    public void visitModifiers(JCModifiers tree) {\n+    }\n+\n+    @Override\n+    public void visitAnnotation(JCAnnotation tree) {\n+    }\n+\n+    @Override\n+    public void visitAnnotatedType(JCAnnotatedType tree) {\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Non-Reference Stuff\n+\/\/\n+\n+    @Override\n+    public void visitAssignop(JCAssignOp tree) {\n+        this.scan(tree.lhs);\n+        this.refs.discardExprs(this.depth);\n+        this.scan(tree.rhs);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+    @Override\n+    public void visitUnary(JCUnary tree) {\n+        this.scan(tree.arg);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+    @Override\n+    public void visitBinary(JCBinary tree) {\n+        this.scan(tree.lhs);\n+        this.refs.discardExprs(this.depth);\n+        this.scan(tree.rhs);\n+        this.refs.discardExprs(this.depth);\n+    }\n+\n+\/\/ Helper methods\n+\n+    \/\/ Recurse through indirect code that might get executed later, e.g., a lambda.\n+    \/\/ We stash any pending warning and the current RefSet, then recurse into the deferred\n+    \/\/ code (still using the current RefSet) to see if it would leak. Then we restore the\n+    \/\/ pending warning and the current RefSet. Finally, if the deferred code would have\n+    \/\/ leaked, we create an indirect ExprRef because it must be holding a 'this' reference.\n+    \/\/ If the deferred code would not leak, then obviously no leak is possible, period.\n+    private <T extends JCTree> void visitDeferred(Runnable recurse) {\n+        final DiagnosticPosition[] pendingWarningPrev = this.pendingWarning;\n+        this.pendingWarning = null;\n+        final RefSet<Ref> refsPrev = this.refs.clone();\n+        final boolean deferredCodeLeaks;\n+        try {\n+            recurse.run();\n+            deferredCodeLeaks = this.pendingWarning != null;\n+        } finally {\n+            this.refs = refsPrev;\n+            this.pendingWarning = pendingWarningPrev;\n+        }\n+        if (deferredCodeLeaks)\n+            this.refs.add(ExprRef.indirect(this.depth));\n+    }\n+\n+    \/\/ Repeat loop as needed until the current set of references converges\n+    private <T extends JCTree> void visitLooped(T tree, Consumer<T> visitor) {\n+        this.visitScoped(tree, false, t -> {\n+            while (true) {\n+                final RefSet<Ref> prevRefs = this.refs.clone();\n+                visitor.accept(t);\n+                if (this.refs.equals(prevRefs))\n+                    break;\n+            }\n+        });\n+    }\n+\n+    \/\/ Handle the tree node within a new scope\n+    private <T extends JCTree> void visitScoped(T tree, boolean promote, Consumer<T> handler) {\n+        this.pushScope();\n+        try {\n+\n+            \/\/ Invoke handler\n+            Assert.check(this.checkInvariants(true, false));\n+            handler.accept(tree);\n+            Assert.check(this.checkInvariants(true, promote));\n+\n+            \/\/ \"Promote\" any remaining ExprRef's to the enclosing lexical scope\n+            if (promote) {\n+                this.refs.removeExprs(this.depth,\n+                    direct -> this.refs.add(new ExprRef(this.depth - 1, direct)));\n+            }\n+        } finally {\n+            this.popScope();\n+        }\n+    }\n+\n+    private void pushScope() {\n+        this.depth++;\n+    }\n+\n+    private void popScope() {\n+        Assert.check(this.depth >= 0);\n+        this.depth--;\n+        this.refs.removeIf(ref -> ref.getDepth() > this.depth);\n+    }\n+\n+    \/\/ Note a possible 'this' reference leak at the specified location\n+    private void leakAt(JCTree tree) {\n+\n+        \/\/ Generate at most one warning per statement\n+        if (this.pendingWarning != null)\n+            return;\n+\n+        \/\/ Snapshot the current stack trace\n+        this.callStack.push(tree.pos());\n+        this.pendingWarning = this.callStack.toArray(new DiagnosticPosition[0]);\n+        this.callStack.pop();\n+    }\n+\n+    \/\/ Copy pending warning, if any, to the warning list and reset\n+    private boolean copyPendingWarning() {\n+        if (this.pendingWarning == null)\n+            return false;\n+        this.warningList.add(this.pendingWarning);\n+        this.pendingWarning = null;\n+        return true;\n+    }\n+\n+    \/\/ Does the symbol correspond to a parameter or local variable (not a field)?\n+    private boolean isParamOrVar(Symbol sym) {\n+        return sym != null &&\n+            sym.kind == VAR &&\n+            (sym.owner.kind == MTH || sym.owner.kind == VAR);\n+    }\n+\n+    \/\/ Is type A a subtype of B when both types are erased?\n+    private boolean isSubtype(Type a, Type b) {\n+        return this.types.isSubtypeUnchecked(this.types.erasure(a), this.types.erasure(b));\n+    }\n+\n+    \/\/ When scanning nodes we can be in one of two modes:\n+    \/\/  (a) Looking for constructors - we do not recurse into any code blocks\n+    \/\/  (b) Analyzing a constructor - we are tracing its possible execution paths\n+    private boolean isAnalyzing() {\n+        return this.targetClass != null;\n+    }\n+\n+\/\/ Debugging\n+\n+    \/\/ Invariant checks\n+    private boolean checkInvariants(boolean analyzing, boolean allowExpr) {\n+        Assert.check(analyzing == this.isAnalyzing());\n+        if (this.isAnalyzing()) {\n+            Assert.check(this.methodClass != null);\n+            Assert.check(this.targetClass != null);\n+            Assert.check(this.refs != null);\n+            Assert.check(this.depth >= 0);\n+            Assert.check(this.refs.stream().noneMatch(ref -> ref.getDepth() > this.depth));\n+            Assert.check(allowExpr || !this.refs.contains(ExprRef.direct(this.depth)));\n+            Assert.check(allowExpr || !this.refs.contains(ExprRef.indirect(this.depth)));\n+        } else {\n+            Assert.check(this.targetClass == null);\n+            Assert.check(this.refs == null);\n+            Assert.check(this.depth == -1);\n+            Assert.check(this.callStack.isEmpty());\n+            Assert.check(this.pendingWarning == null);\n+            Assert.check(this.invocations.isEmpty());\n+        }\n+        return true;\n+    }\n+\n+\/\/ Ref's\n+\n+    \/** Represents a location that could possibly hold a 'this' reference.\n+     *\n+     *  <p>\n+     *  If not \"direct\", the reference is found through at least one indirection.\n+     *\/\n+    private abstract static class Ref {\n+\n+        private final int depth;\n+        private final boolean direct;\n+\n+        Ref(int depth, boolean direct) {\n+            this.depth = depth;\n+            this.direct = direct;\n+        }\n+\n+        public int getDepth() {\n+            return this.depth;\n+        }\n+\n+        public boolean isDirect() {\n+            return this.direct;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return this.getClass().hashCode()\n+                ^ Integer.hashCode(this.depth)\n+                ^ Boolean.hashCode(this.direct);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (obj == null || obj.getClass() != this.getClass())\n+                return false;\n+            final Ref that = (Ref)obj;\n+            return this.depth == that.depth\n+              && this.direct == that.direct;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final ArrayList<String> properties = new ArrayList<>();\n+            this.addProperties(properties);\n+            return this.getClass().getSimpleName()\n+              + \"[\" + properties.stream().collect(Collectors.joining(\",\")) + \"]\";\n+        }\n+\n+        protected void addProperties(ArrayList<String> properties) {\n+            properties.add(\"depth=\" + this.depth);\n+            properties.add(this.direct ? \"direct\" : \"indirect\");\n+        }\n+    }\n+\n+    \/** A reference from the current 'this' instance.\n+     *\/\n+    private static class ThisRef extends Ref {\n+\n+        ThisRef(boolean direct) {\n+            super(0, direct);\n+        }\n+\n+        public static ThisRef direct() {\n+            return new ThisRef(true);\n+        }\n+\n+        public static ThisRef indirect() {\n+            return new ThisRef(false);\n+        }\n+    }\n+\n+    \/** A reference from the current outer 'this' instance.\n+     *\/\n+    private static class OuterRef extends Ref {\n+\n+        OuterRef(boolean direct) {\n+            super(0, direct);\n+        }\n+\n+        public static OuterRef direct() {\n+            return new OuterRef(true);\n+        }\n+\n+        public static OuterRef indirect() {\n+            return new OuterRef(false);\n+        }\n+    }\n+\n+    \/** A reference from the expression that was just evaluated.\n+     *  In other words, a reference that's sitting on top of the stack.\n+     *\/\n+    private static class ExprRef extends Ref {\n+\n+        ExprRef(int depth, boolean direct) {\n+            super(depth, direct);\n+        }\n+\n+        public static ExprRef direct(int depth) {\n+            return new ExprRef(depth, true);\n+        }\n+\n+        public static ExprRef indirect(int depth) {\n+            return new ExprRef(depth, false);\n+        }\n+    }\n+\n+    \/** A reference from the return value of the current method being \"invoked\".\n+     *\/\n+    private static class ReturnRef extends Ref {\n+\n+        ReturnRef(boolean direct) {\n+            super(0, direct);\n+        }\n+\n+        public static ReturnRef direct() {\n+            return new ReturnRef(true);\n+        }\n+\n+        public static ReturnRef indirect() {\n+            return new ReturnRef(false);\n+        }\n+    }\n+\n+    \/** A reference from a variable.\n+     *\/\n+    private static class VarRef extends Ref {\n+\n+        private final VarSymbol sym;\n+\n+        VarRef(VarSymbol sym, boolean direct) {\n+            super(0, direct);\n+            this.sym = sym;\n+        }\n+\n+        public VarSymbol getSymbol() {\n+            return this.sym;\n+        }\n+\n+        public static VarRef direct(VarSymbol sym) {\n+            return new VarRef(sym, true);\n+        }\n+\n+        public static VarRef indirect(VarSymbol sym) {\n+            return new VarRef(sym, false);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode()\n+                ^ Objects.hashCode(this.sym);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!super.equals(obj))\n+                return false;\n+            final VarRef that = (VarRef)obj;\n+            return Objects.equals(this.sym, that.sym);\n+        }\n+\n+        @Override\n+        protected void addProperties(ArrayList<String> properties) {\n+            super.addProperties(properties);\n+            properties.add(\"sym=\" + this.sym);\n+        }\n+    }\n+\n+\/\/ RefSet\n+\n+    \/** Contains locations currently known to hold a possible 'this' reference.\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    private static class RefSet<T extends Ref> extends HashSet<T> {\n+\n+        public static <T extends Ref> RefSet<T> newEmpty() {\n+            return new RefSet<>();\n+        }\n+\n+        \/**\n+         * Discard any {@link ExprRef}'s at the specified depth.\n+         * Do this when discarding whatever is on top of the stack.\n+         *\/\n+        public boolean discardExprs(int depth) {\n+            return this.remove(ExprRef.direct(depth)) | this.remove(ExprRef.indirect(depth));\n+        }\n+\n+        \/**\n+         * Extract any {@link ExprRef}'s at the specified depth.\n+         *\/\n+        public RefSet<ExprRef> removeExprs(int depth) {\n+            return Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n+              .filter(this::remove)\n+              .collect(Collectors.toCollection(RefSet::new));\n+        }\n+\n+        \/**\n+         * Extract any {@link ExprRef}'s at the specified depth and do something with them.\n+         *\/\n+        public void removeExprs(int depth, Consumer<? super Boolean> handler) {\n+            Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n+              .filter(this::remove)\n+              .map(ExprRef::isDirect)\n+              .forEach(handler);\n+        }\n+\n+        \/**\n+         * Replace any {@link ExprRef}'s at the specified depth.\n+         *\/\n+        public void replaceExprs(int depth, Function<Boolean, ? extends T> mapper) {\n+            this.removeExprs(depth, direct -> this.add(mapper.apply(direct)));\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public RefSet<T> clone() {\n+            return (RefSet<T>)super.clone();\n+        }\n+    }\n+\n+\/\/ MethodInfo\n+\n+    \/\/ Information about a constructor or method in the compilation unit\n+    private static class MethodInfo {\n+\n+        private final JCClassDecl declaringClass;\n+        private final JCMethodDecl declaration;\n+        private final boolean analyzable;           \/\/ it's a constructor we should analyze\n+        private final boolean invokable;            \/\/ it may be \"invoked\" during analysis\n+\n+        MethodInfo(JCClassDecl declaringClass, JCMethodDecl declaration,\n+            boolean analyzable, boolean invokable) {\n+            this.declaringClass = declaringClass;\n+            this.declaration = declaration;\n+            this.analyzable = analyzable;\n+            this.invokable = invokable;\n+        }\n+\n+        public JCClassDecl getDeclaringClass() {\n+            return this.declaringClass;\n+        }\n+\n+        public JCMethodDecl getDeclaration() {\n+            return this.declaration;\n+        }\n+\n+        public boolean isAnalyzable() {\n+            return this.analyzable;\n+        }\n+\n+        public boolean isInvokable() {\n+            return this.invokable;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.getClass().getSimpleName()\n+              + \"[meth=\" + this.declaringClass.name + \".\" + this.declaration.name + \"()\"\n+              + (this.analyzable ? \",analyzable\" : \"\")\n+              + (this.invokable ? \",invokable\" : \"\")\n+              + \"]\";\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1469,"deletions":0,"binary":false,"changes":1469,"status":"added"},{"patch":"@@ -656,0 +656,6 @@\n+compiler.warn.possible.this.escape=\\\n+    possible ''this'' escape before subclass is fully initialized\n+\n+compiler.warn.possible.this.escape.location=\\\n+    previous possible ''this'' escape happens here via invocation\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+javac.opt.Xlint.desc.this-escape=\\\n+    Warn when a constructor invokes a method that could be overriden in a subclass;\\n\\\n+    such a method would execute before the subclass constructor completes its initialization.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static com.sun.tools.javac.code.TypeTag.CLASS;\n@@ -215,0 +216,35 @@\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+            case IDENT:\n+            {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this;\n+            }\n+            case SELECT:\n+            {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(CLASS))\n+                    return false;\n+                Type.ClassType selectedClassType = (Type.ClassType)selectedType;\n+                currentClass = (Type.ClassType)types.erasure(currentClass);\n+                Names names = select.name.table.names;\n+                return types.isSubtype(currentClass, selectedClassType) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this && !types.hasOuterClass(currentClass, selectedClassType)));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+ * <tr><th scope=\"row\">{@code this-escape}          <td>superclass constructor leaking {@code this} before subclass initialized\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.possible.this.escape\n+\/\/ key: compiler.warn.possible.this.escape.location\n+\/\/ options: -Xlint:this-escape\n+\n+public class ThisEscape {\n+\n+    public ThisEscape() {\n+        this.method();\n+    }\n+\n+    public final void method() {\n+        this.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ThisEscape.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeArrayElement.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeArrayElement.java\n+ * @summary Verify 'this' escape detection can follow references embedded as array elements\n+ *\/\n+\n+public class ThisEscapeArrayElement {\n+\n+    public ThisEscapeArrayElement() {\n+        final Object[][] array = new Object[][] { { this } };\n+        ((ThisEscapeArrayElement)array[0][0]).mightLeak();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeArrayElement.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeArrayElement.java:12:56: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeArrayElement.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeBasic.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeBasic.java\n+ * @summary Verify basic 'this' escape detection\n+ *\/\n+\n+public class ThisEscapeBasic {\n+\n+    public ThisEscapeBasic() {\n+        this.mightLeak();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeBasic.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeBasic.java:11:23: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeBasic.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeComplex.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeComplex.java\n+ * @summary Verify 'this' escape detection can follow references through various Java code structures\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public class ThisEscapeComplex {\n+\n+    public ThisEscapeComplex() {\n+        this.method1().mightLeak();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+\n+    private ThisEscapeComplex method1() {\n+        while (true) {\n+            do {\n+                for (ThisEscapeComplex x = this.method2(); new Object().hashCode() < 10; ) {\n+                    for (int y : new int[] { 123, 456 }) {\n+                        return x;\n+                    }\n+                }\n+            } while (true);\n+        }\n+    }\n+\n+    private ThisEscapeComplex method2() {\n+        switch (new Object().hashCode()) {\n+        case 1:\n+        case 2:\n+        case 3:\n+            return null;\n+        default:\n+            return this.method3();\n+        }\n+    }\n+\n+    private ThisEscapeComplex method3() {\n+        return switch (new Object().hashCode()) {\n+            case 1, 2, 3 -> this.method4();\n+            default -> null;\n+        };\n+    }\n+\n+    private ThisEscapeComplex method4() {\n+        return ThisEscapeComplex.this.method5();\n+    }\n+\n+    private ThisEscapeComplex method5() {\n+        final ThisEscapeComplex foo = this.method6();\n+        return foo;\n+    }\n+\n+    private ThisEscapeComplex method6() {\n+        synchronized (new Object()) {\n+            return this.method7();\n+        }\n+    }\n+\n+    private ThisEscapeComplex method7() {\n+        ThisEscapeComplex x = null;\n+        ThisEscapeComplex y = this.method8();\n+        if (new Object().hashCode() == 3)\n+            return x;\n+        else\n+            return y;\n+    }\n+\n+    private ThisEscapeComplex method8() {\n+        return (ThisEscapeComplex)(Object)this.method9();\n+    }\n+\n+    private ThisEscapeComplex method9() {\n+        return new Object().hashCode() == 3 ? this : null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeComplex.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeComplex.java:13:33: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeComplex.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeCtors.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeCtors.java\n+ * @summary Verify pruning of 'this' escape warnings for various constructors\n+ *\/\n+\n+public class ThisEscapeCtors {\n+\n+    \/\/ This constructor should NOT generate a warning because it would be a\n+    \/\/ duplicate of the warning already generated for ThisEscapeCtors(short).\n+    public ThisEscapeCtors(char x) {\n+        this((short)x);\n+    }\n+\n+    \/\/ This constructor should generate a warning because it invokes leaky this()\n+    \/\/ and is accessible to subclasses.\n+    public ThisEscapeCtors(short x) {\n+        this();\n+    }\n+\n+    \/\/ This constructor should generate a warning because it invokes leaky this()\n+    \/\/ and is accessible to subclasses.\n+    public ThisEscapeCtors(int x) {\n+        this();\n+    }\n+\n+    \/\/ This constructor should NOT generate a warning because it is not accessbile\n+    \/\/ to subclasses. However, other constructors do invoke it, and that should cause\n+    \/\/ them to generate an indirect warning.\n+    private ThisEscapeCtors() {\n+        this.mightLeak();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeCtors.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+ThisEscapeCtors.java:19:13: compiler.warn.possible.this.escape\n+ThisEscapeCtors.java:32:23: compiler.warn.possible.this.escape.location\n+ThisEscapeCtors.java:25:13: compiler.warn.possible.this.escape\n+ThisEscapeCtors.java:32:23: compiler.warn.possible.this.escape.location\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeCtors.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeFields.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeFields.java\n+ * @summary Verify 'this' escape detection in field initializers\n+ *\/\n+\n+public class ThisEscapeFields {\n+\n+    private final int field1 = this.mightLeak1();\n+\n+    private final int field2 = this.mightLeak2();\n+\n+    public int mightLeak1() {\n+        return 123;\n+    }\n+\n+    public int mightLeak2() {\n+        return 456;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeFields.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ThisEscapeFields.java:10:47: compiler.warn.possible.this.escape\n+ThisEscapeFields.java:12:47: compiler.warn.possible.this.escape\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeFields.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeLambda.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeLambda.java\n+ * @summary Verify 'this' escape detection properly handles lambdas\n+ *\/\n+\n+public class ThisEscapeLambda {\n+\n+    public ThisEscapeLambda() {\n+        Runnable r = () -> {\n+            this.mightLeak();\n+        };\n+        System.out.println(r);\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLambda.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeLambda.java:14:28: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLambda.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeLoop.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeLoop.java\n+ * @summary Verify 'this' escape detection properly handles loop convergence\n+ *\/\n+\n+public class ThisEscapeLoop {\n+\n+    public ThisEscapeLoop() {\n+        ThisEscapeLoop ref1 = this;\n+        ThisEscapeLoop ref2 = null;\n+        ThisEscapeLoop ref3 = null;\n+        ThisEscapeLoop ref4 = null;\n+        for (int i = 0; i < 100; i++) {\n+            ref4 = ref3;\n+            ref3 = ref2;\n+            ref2 = ref1;\n+            if (ref4 != null)\n+                ref4.mightLeak();\n+        }\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLoop.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeLoop.java:20:31: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLoop.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015831\n+ * @summary Verify 'this' escape detection doesn't generate certain false positives\n+ *\/\n+public class ThisEscapeNoEscapes {\n+\n+    public ThisEscapeNoEscapes() {\n+        this.noLeak1();                             \/\/ invoked method is private\n+        this.noLeak2();                             \/\/ invoked method is final\n+        ThisEscapeNoEscapes.noLeak3();              \/\/ invoked method is static\n+        this.noLeak4(this);                         \/\/ parameter is 'this' but it's not leaked\n+        this.noLeak5(new ThisEscapeNoEscapes(0));   \/\/ parameter is not 'this', so no leak\n+        this.noLeak6(null, this, null);             \/\/ method leaks 1st and 3rd parameters only\n+        this.noLeak7();                             \/\/ method does complicated stuff but doesn't leak\n+        Runnable r1 = () -> {                       \/\/ lambda does not leak 'this'\n+            if (System.out == System.err)\n+                throw new RuntimeException();\n+        };\n+        System.out.println(r1);                     \/\/ lambda does not leak 'this'\n+        Runnable r2 = () -> {                       \/\/ lambda leaks 'this' but is never used\n+            this.mightLeak1();\n+        };\n+        Runnable r3 = this::mightLeak1;             \/\/ reference leaks 'this' but is never used\n+    }\n+\n+    public ThisEscapeNoEscapes(int x) {\n+    }\n+\n+    public void mightLeak1() {\n+    }\n+\n+    private void noLeak1() {\n+    }\n+\n+    public final void noLeak2() {\n+    }\n+\n+    public static void noLeak3() {\n+    }\n+\n+    public static void noLeak4(ThisEscapeNoEscapes param) {\n+        param.noLeak1();\n+        param.noLeak2();\n+    }\n+\n+    public final void noLeak5(ThisEscapeNoEscapes param) {\n+        param.mightLeak1();\n+    }\n+\n+    public final void noLeak6(ThisEscapeNoEscapes param1,\n+        ThisEscapeNoEscapes param2, ThisEscapeNoEscapes param3) {\n+        if (param1 != null)\n+            param1.mightLeak1();\n+        if (param2 != null)\n+            param2.noLeak2();\n+        if (param3 != null)\n+            param3.mightLeak1();\n+    }\n+\n+    public final void noLeak7() {\n+        ((ThisEscapeNoEscapes)(Object)this).noLeak2();\n+        final ThisEscapeNoEscapes obj1 = switch (new Object().hashCode()) {\n+            case 1, 2, 3 -> null;\n+            default -> new ThisEscapeNoEscapes(0);\n+        };\n+        obj1.mightLeak1();\n+    }\n+\n+\/\/ PrivateClass\n+\n+    private static class PrivateClass {\n+\n+        PrivateClass() {\n+            this.cantLeak();                    \/\/ method is inside a private class\n+        }\n+\n+        public void cantLeak() {\n+        }\n+    }\n+\n+\/\/ FinalClass\n+\n+    public static final class FinalClass extends ThisEscapeNoEscapes {\n+\n+        public FinalClass() {\n+            this.mightLeak1();                  \/\/ class and therefore method is final\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ThisEscapeNoEscapes();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeNoEscapes.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeOuterThis.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeOuterThis.java\n+ * @summary Verify 'this' escape detection handles leaks via outer 'this'\n+ *\/\n+\n+public class ThisEscapeOuterThis {\n+\n+    public ThisEscapeOuterThis() {\n+        new InnerClass();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+\n+    public class InnerClass {\n+\n+        InnerClass() {\n+            ThisEscapeOuterThis.this.mightLeak();\n+        }\n+    }\n+\n+    \/\/ No leak here because class 'Local' cannot be externally extended\n+    public static void method1() {\n+        class Local {\n+            Local() {\n+                this.wontLeak();\n+            }\n+            void wontLeak() {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeOuterThis.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ThisEscapeOuterThis.java:11:9: compiler.warn.possible.this.escape\n+ThisEscapeOuterThis.java:20:47: compiler.warn.possible.this.escape.location\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeOuterThis.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeParameter.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeParameter.java\n+ * @summary Verify 'this' escape detection handles leaks via passing 'this' as a parameter\n+ *\/\n+\n+public class ThisEscapeParameter {\n+\n+    public ThisEscapeParameter() {\n+        ThisEscapeParameter.method(this);\n+    }\n+\n+    public static void method(Object obj) {\n+        obj.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeParameter.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ThisEscapeParameter.java:11:35: compiler.warn.possible.this.escape\n+ThisEscapeParameter.java:15:21: compiler.warn.possible.this.escape.location\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeParameter.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeRecursion.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeRecursion.java\n+ * @summary Verify 'this' escape detection properly handles leaks via recursive methods\n+ *\/\n+\n+public class ThisEscapeRecursion {\n+\n+    public ThisEscapeRecursion() {\n+        this.noLeak(0);         \/\/ no leak here\n+        this.mightLeak();       \/\/ possible leak here\n+    }\n+\n+    public final void noLeak(int depth) {\n+        if (depth < 10)\n+            this.noLeak(depth - 1);\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeRecursion.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeRecursion.java:12:23: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeRecursion.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeReference.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeReference.java\n+ * @summary Verify proper handling of 'this' escape warnings from method references\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ThisEscapeReference {\n+\n+\/\/ Test 1 - ReferenceKind.SUPER\n+\n+    public static class Test1 {\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    public static class Test1b extends Test1 {\n+        public Test1b() {\n+            new Thread(super::mightLeak);   \/\/ this is a leak\n+        }\n+    }\n+\n+    public static class Test1c extends Test1 {\n+        public Test1c() {\n+            new Thread(super::notify);      \/\/ this is not a leak\n+        }\n+    }\n+\n+\/\/ Test 2 - ReferenceKind.BOUND\n+\n+    public static class Test2 {\n+\n+        public Test2() {\n+            new Thread(this::mightLeak);    \/\/ this is a leak\n+        }\n+\n+        public Test2(int x) {\n+            final Test2 foo = new Test2();\n+            new Thread(foo::mightLeak);     \/\/ this is not a leak\n+        }\n+\n+        public Test2(char x) {\n+            new Thread(this::noLeak);       \/\/ this is not a leak\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        private void noLeak() {\n+        }\n+    }\n+\n+\/\/ Test 3 - ReferenceKind.IMPLICIT_INNER\n+\n+    public static class Test3 {\n+\n+        public Test3() {\n+            new Thread(Inner1::new);        \/\/ this is a leak\n+        }\n+\n+        public Test3(int x) {\n+            new Thread(Inner2::new);        \/\/ this is not a leak\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        public class Inner1 {\n+            public Inner1() {\n+                Test3.this.mightLeak();\n+            }\n+        }\n+\n+        public class Inner2 {\n+            public Inner2() {\n+                new Test3().mightLeak();\n+            }\n+        }\n+    }\n+\n+\/\/ Test 4 - ReferenceKind.UNBOUND, STATIC, TOPLEVEL, ARRAY_CTOR\n+\n+    public static class Test4 {\n+\n+        \/\/ ReferenceKind.UNBOUND\n+        public Test4() {\n+            Test4.bar(Test4::sameHashCode);\n+        }\n+\n+        \/\/ ReferenceKind.STATIC\n+        public Test4(int x) {\n+            new Thread(Test4::noLeak);      \/\/ this is not a leak\n+        }\n+\n+        \/\/ ReferenceKind.ARRAY_CTOR\n+        public Test4(char x) {\n+            Test4.foo(String[]::new);       \/\/ this is not a leak\n+        }\n+\n+        \/\/ ReferenceKind.TOPLEVEL\n+        public Test4(short x) {\n+            Test4.foo(Test4::new);          \/\/ this is not a leak\n+        }\n+\n+        public static void noLeak() {\n+        }\n+\n+        public static void foo(IntFunction<?> x) {\n+            x.hashCode();\n+        }\n+\n+        public static void bar(BiPredicate<Test4, Object> x) {\n+            x.hashCode();\n+        }\n+\n+        public boolean sameHashCode(Object obj) {\n+            return obj.hashCode() == this.hashCode();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReference.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+ThisEscapeReference.java:21:24: compiler.warn.possible.this.escape\n+ThisEscapeReference.java:36:24: compiler.warn.possible.this.escape\n+ThisEscapeReference.java:60:24: compiler.warn.possible.this.escape\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReference.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeReturnValue.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeReturnValue.java\n+ * @summary Verify 'this' escape detection properly handles leaks via method return values\n+ *\/\n+\n+public class ThisEscapeReturnValue {\n+\n+    public ThisEscapeReturnValue() {\n+        final Object rval = ThisEscapeReturnValue.method(this);\n+        ((ThisEscapeReturnValue)rval).mightLeak();\n+    }\n+\n+    public static Object method(Object obj) {\n+        return obj;\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReturnValue.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeReturnValue.java:12:48: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReturnValue.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015831\n+ * @summary Verify 'this' escape warnings can be properly suppressed\n+ *\/\n+public class ThisEscapeSuppressed {\n+\n+    public ThisEscapeSuppressed() {\n+        this.mightLeak();\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public void mightLeak() {\n+    }\n+\n+    public static void main(String[] args) {\n+        new ThisEscapeSuppressed();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeSuppressed.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeUnqualified.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeUnqualified.java\n+ * @summary Verify proper 'this' escape interpretation of unqualified non-static method invocations.\n+ *\/\n+\n+public class ThisEscapeUnqualified {\n+\n+    \/\/ This class has a leak\n+    public static class Example1 {\n+\n+        public Example1() {\n+            new Inner();\n+        }\n+\n+        public final class Inner {\n+            public Inner() {\n+                mightLeak();    \/\/ refers to Example1.mightLeak()\n+            }\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ This class does NOT have a leak\n+    public static class Example2 {\n+\n+        public Example2() {\n+            new Inner();\n+        }\n+\n+        public final class Inner {\n+            public Inner() {\n+                mightLeak();    \/\/ refers to Inner.mightLeak()\n+            }\n+\n+            public void mightLeak() {\n+            }\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeUnqualified.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ThisEscapeUnqualified.java:14:13: compiler.warn.possible.this.escape\n+ThisEscapeUnqualified.java:19:26: compiler.warn.possible.this.escape.location\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeUnqualified.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}