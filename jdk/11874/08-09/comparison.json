{"files":[{"patch":"@@ -300,2 +300,8 @@\n-        \/\/ Now analyze all of the analyzable constructors we found\n-        for (MethodInfo methodInfo : methodMap.values()) {\n+        \/\/ Analyze non-static field initializers and initialization blocks,\n+        \/\/ but only for classes having at least one analyzable constructor.\n+        methodMap.values().stream()\n+                .filter(MethodInfo::isAnalyzable)\n+                .map(MethodInfo::getDeclaringClass)\n+                .distinct()\n+                .forEach(klass -> {\n+            for (List<JCTree> defs = klass.defs; defs.nonEmpty(); defs = defs.tail) {\n@@ -303,11 +309,3 @@\n-            \/\/ We are looking for analyzable constructors only\n-            if (!methodInfo.isAnalyzable())\n-                continue;\n-\n-            \/\/ Analyze constructor body\n-            targetClass = methodInfo.getDeclaringClass();\n-            methodClass = targetClass;\n-            Assert.check(depth == -1);\n-            Assert.check(refs == null);\n-            pushScope();\n-            try {\n+                \/\/ Ignore static stuff\n+                if ((TreeInfo.flags(defs.head) & Flags.STATIC) != 0)\n+                    continue;\n@@ -315,3 +313,9 @@\n-                \/\/ Add the initial 'this' reference\n-                refs = RefSet.newEmpty();\n-                refs.add(ThisRef.direct());\n+                \/\/ Handle field initializers\n+                if (defs.head.hasTag(VARDEF)) {\n+                    JCVariableDecl vardef = (JCVariableDecl)defs.head;\n+                    visitTopLevel(klass, () -> {\n+                        scan(vardef);\n+                        copyPendingWarning();\n+                    });\n+                    continue;\n+                }\n@@ -319,7 +323,6 @@\n-                \/\/ Scan constructor statements\n-                analyzeStatements(methodInfo.getDeclaration().body.stats);\n-            } finally {\n-                popScope();\n-                methodClass = null;\n-                targetClass = null;\n-                refs = null;\n+                \/\/ Handle initialization blocks\n+                if (defs.head.hasTag(BLOCK)) {\n+                    JCBlock block = (JCBlock)defs.head;\n+                    visitTopLevel(klass, () -> analyzeStatements(block.stats));\n+                    continue;\n+                }\n@@ -327,1 +330,9 @@\n-        }\n+        });\n+\n+        \/\/ Analyze all of the analyzable constructors we found\n+        methodMap.values().stream()\n+                .filter(MethodInfo::isAnalyzable)\n+                .forEach(methodInfo -> {\n+            visitTopLevel(methodInfo.getDeclaringClass(),\n+                () -> analyzeStatements(methodInfo.getDeclaration().body.stats));\n+        });\n@@ -384,0 +395,1 @@\n+    \/\/ Analyze statements, but stop at (and record) the first warning generated\n@@ -386,2 +398,0 @@\n-\n-            \/\/ Analyze statement\n@@ -389,2 +399,0 @@\n-\n-            \/\/ Capture any pending warning generated\n@@ -392,1 +400,1 @@\n-                break;                      \/\/ report at most one warning per constructor\n+                break;\n@@ -515,5 +523,2 @@\n-        \/\/ If \"super()\": ignore - we don't try to track into superclasses.\n-        \/\/ However, we do need to \"invoke\" non-static initializers\/blocks.\n-        Name name = TreeInfo.name(invoke.meth);\n-        if (name == names._super) {\n-            scanInitializers();\n+        \/\/ If \"super()\": ignore - we don't try to track into superclasses\n+        if (TreeInfo.name(invoke.meth) == names._super)\n@@ -521,1 +526,0 @@\n-        }\n@@ -549,29 +553,0 @@\n-    \/\/ Scan field initializers and initialization blocks\n-    private void scanInitializers() {\n-        DiagnosticPosition[] pendingWarningPrev = pendingWarning;\n-        pendingWarning = null;\n-        try {\n-            for (List<JCTree> defs = methodClass.defs; defs.nonEmpty(); defs = defs.tail) {\n-\n-                \/\/ Ignore static stuff\n-                if ((TreeInfo.flags(defs.head) & Flags.STATIC) != 0)\n-                    continue;\n-\n-                \/\/ Handle field initializers\n-                if (defs.head.hasTag(VARDEF)) {\n-                    scan((JCVariableDecl)defs.head);\n-                    copyPendingWarning();\n-                    continue;\n-                }\n-\n-                \/\/ Handle initialization block\n-                if (defs.head.hasTag(BLOCK)) {\n-                    visitScoped((JCBlock)defs.head, false, block -> analyzeStatements(block.stats));\n-                    continue;\n-                }\n-            }\n-        } finally {\n-            pendingWarning = pendingWarningPrev;\n-        }\n-    }\n-\n@@ -683,1 +658,1 @@\n-        visitScoped(tree, false, super::visitBlock);\n+        visitScoped(false, () -> super.visitBlock(tree));\n@@ -709,2 +684,2 @@\n-        visitScoped(tree, false, t -> {\n-            scan(t.selector);\n+        visitScoped(false, () -> {\n+            scan(tree.selector);\n@@ -712,1 +687,1 @@\n-            scan(t.cases);\n+            scan(tree.cases);\n@@ -718,2 +693,2 @@\n-        visitScoped(tree, true, t -> {\n-            scan(t.selector);\n+        visitScoped(true, () -> {\n+            scan(tree.selector);\n@@ -722,1 +697,1 @@\n-            for (List<JCCase> cases = t.cases; cases.nonEmpty(); cases = cases.tail) {\n+            for (List<JCCase> cases = tree.cases; cases.nonEmpty(); cases = cases.tail) {\n@@ -744,1 +719,1 @@\n-        visitScoped(tree, true, super::visitLetExpr);\n+        visitScoped(true, () -> super.visitLetExpr(tree));\n@@ -755,1 +730,1 @@\n-        visitDeferred(() -> visitScoped(lambda, false, super::visitLambda));\n+        visitDeferred(() -> visitScoped(false, () -> super.visitLambda(lambda)));\n@@ -1063,0 +1038,23 @@\n+    private void visitTopLevel(JCClassDecl klass, Runnable action) {\n+        Assert.check(targetClass == null);\n+        Assert.check(methodClass == null);\n+        Assert.check(depth == -1);\n+        Assert.check(refs == null);\n+        targetClass = klass;\n+        methodClass = klass;\n+        try {\n+\n+            \/\/ Add the initial 'this' reference\n+            refs = RefSet.newEmpty();\n+            refs.add(ThisRef.direct());\n+\n+            \/\/ Perform action\n+            this.visitScoped(false, action);\n+        } finally {\n+            Assert.check(depth == -1);\n+            methodClass = null;\n+            targetClass = null;\n+            refs = null;\n+        }\n+    }\n+\n@@ -1087,1 +1085,1 @@\n-        visitScoped(tree, false, t -> {\n+        visitScoped(false, () -> {\n@@ -1090,1 +1088,1 @@\n-                visitor.accept(t);\n+                visitor.accept(tree);\n@@ -1097,2 +1095,2 @@\n-    \/\/ Handle the tree node within a new scope\n-    private <T extends JCTree> void visitScoped(T tree, boolean promote, Consumer<T> handler) {\n+    \/\/ Perform the given action within a new scope\n+    private <T> void visitScoped(boolean promote, Runnable action) {\n@@ -1102,1 +1100,1 @@\n-            \/\/ Invoke handler\n+            \/\/ Perform action\n@@ -1104,1 +1102,1 @@\n-            handler.accept(tree);\n+            action.run();\n@@ -1107,1 +1105,1 @@\n-            \/\/ \"Promote\" any remaining ExprRef's to the enclosing lexical scope\n+            \/\/ \"Promote\" ExprRef's to the enclosing lexical scope, if requested\n@@ -1109,0 +1107,1 @@\n+                Assert.check(depth > 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":79,"deletions":80,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -0,0 +1,587 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscape.out -Xlint:this-escape -XDrawDiagnostics ThisEscape.java\n+ * @summary Verify 'this' escape detection\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ThisEscape {\n+\n+    \/\/ Verify 'this' escape detection can follow references embedded as array elements\n+    public static class ThisEscapeArrayElement {\n+\n+        public ThisEscapeArrayElement() {\n+            final Object[][] array = new Object[][] { { this } };\n+            ((ThisEscapeArrayElement)array[0][0]).mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify basic 'this' escape detection\n+    public static class ThisEscapeBasic {\n+\n+        public ThisEscapeBasic() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection can follow references through various Java code structures\n+    public static class ThisEscapeComplex {\n+\n+        public ThisEscapeComplex() {\n+            this.method1().mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        private ThisEscapeComplex method1() {\n+            while (true) {\n+                do {\n+                    for (ThisEscapeComplex x = this.method2(); new Object().hashCode() < 10; ) {\n+                        for (int y : new int[] { 123, 456 }) {\n+                            return x;\n+                        }\n+                    }\n+                } while (true);\n+            }\n+        }\n+\n+        private ThisEscapeComplex method2() {\n+            switch (new Object().hashCode()) {\n+            case 1:\n+            case 2:\n+            case 3:\n+                return null;\n+            default:\n+                return this.method3();\n+            }\n+        }\n+\n+        private ThisEscapeComplex method3() {\n+            return switch (new Object().hashCode()) {\n+                case 1, 2, 3 -> this.method4();\n+                default -> null;\n+            };\n+        }\n+\n+        private ThisEscapeComplex method4() {\n+            return ThisEscapeComplex.this.method5();\n+        }\n+\n+        private ThisEscapeComplex method5() {\n+            final ThisEscapeComplex foo = this.method6();\n+            return foo;\n+        }\n+\n+        private ThisEscapeComplex method6() {\n+            synchronized (new Object()) {\n+                return this.method7();\n+            }\n+        }\n+\n+        private ThisEscapeComplex method7() {\n+            ThisEscapeComplex x = null;\n+            ThisEscapeComplex y = this.method8();\n+            if (new Object().hashCode() == 3)\n+                return x;\n+            else\n+                return y;\n+        }\n+\n+        private ThisEscapeComplex method8() {\n+            return (ThisEscapeComplex)(Object)this.method9();\n+        }\n+\n+        private ThisEscapeComplex method9() {\n+            return new Object().hashCode() == 3 ? this : null;\n+        }\n+    }\n+\n+    \/\/ Verify pruning of 'this' escape warnings for various constructors\n+    public static class ThisEscapeCtors {\n+\n+        \/\/ This constructor should NOT generate a warning because it would be a\n+        \/\/ duplicate of the warning already generated for ThisEscapeCtors(short).\n+        public ThisEscapeCtors(char x) {\n+            this((short)x);\n+        }\n+\n+        \/\/ This constructor should generate a warning because it invokes leaky this()\n+        \/\/ and is accessible to subclasses.\n+        public ThisEscapeCtors(short x) {\n+            this();\n+        }\n+\n+        \/\/ This constructor should generate a warning because it invokes leaky this()\n+        \/\/ and is accessible to subclasses.\n+        public ThisEscapeCtors(int x) {\n+            this();\n+        }\n+\n+        \/\/ This constructor should NOT generate a warning because it is not accessbile\n+        \/\/ to subclasses. However, other constructors do invoke it, and that should cause\n+        \/\/ them to generate an indirect warning.\n+        private ThisEscapeCtors() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection in field initializers\n+    public static class ThisEscapeFields {\n+\n+        private final int field1 = this.mightLeak1();\n+\n+        private final int field2 = this.mightLeak2();\n+\n+        public int mightLeak1() {\n+            return 123;\n+        }\n+\n+        public int mightLeak2() {\n+            return 456;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles lambdas\n+    public static class ThisEscapeLambda {\n+\n+        public ThisEscapeLambda() {\n+            Runnable r = () -> {\n+                this.mightLeak();\n+            };\n+            System.out.println(r);\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles loop convergence\n+    public static class ThisEscapeLoop {\n+\n+        public ThisEscapeLoop() {\n+            ThisEscapeLoop ref1 = this;\n+            ThisEscapeLoop ref2 = null;\n+            ThisEscapeLoop ref3 = null;\n+            ThisEscapeLoop ref4 = null;\n+            for (int i = 0; i < 100; i++) {\n+                ref4 = ref3;\n+                ref3 = ref2;\n+                ref2 = ref1;\n+                if (ref4 != null)\n+                    ref4.mightLeak();\n+            }\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via outer 'this'\n+    public static class ThisEscapeOuterThis {\n+\n+        public ThisEscapeOuterThis() {\n+            new InnerClass();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        public class InnerClass {\n+\n+            InnerClass() {\n+                ThisEscapeOuterThis.this.mightLeak();\n+            }\n+        }\n+\n+        \/\/ No leak here because class 'Local' cannot be externally extended\n+        public static void method1() {\n+            class Local {\n+                Local() {\n+                    this.wontLeak();\n+                }\n+                void wontLeak() {\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via passing 'this' as a parameter\n+    public static class ThisEscapeParameter {\n+\n+        public ThisEscapeParameter() {\n+            ThisEscapeParameter.method(this);\n+        }\n+\n+        public static void method(Object obj) {\n+            obj.hashCode();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles leaks via recursive methods\n+    public static class ThisEscapeRecursion {\n+\n+        public ThisEscapeRecursion() {\n+            this.noLeak(0);         \/\/ no leak here\n+            this.mightLeak();       \/\/ possible leak here\n+        }\n+\n+        public final void noLeak(int depth) {\n+            if (depth < 10)\n+                this.noLeak(depth - 1);\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify proper handling of 'this' escape warnings from method references\n+    public static class ThisEscapeReference {\n+\n+    \/\/ Test 1 - ReferenceKind.SUPER\n+\n+        public static class Test1 {\n+            public void mightLeak() {\n+            }\n+        }\n+\n+        public static class Test1b extends Test1 {\n+            public Test1b() {\n+                new Thread(super::mightLeak);   \/\/ this is a leak\n+            }\n+        }\n+\n+        public static class Test1c extends Test1 {\n+            public Test1c() {\n+                new Thread(super::notify);      \/\/ this is not a leak\n+            }\n+        }\n+\n+    \/\/ Test 2 - ReferenceKind.BOUND\n+\n+        public static class Test2 {\n+\n+            public Test2() {\n+                new Thread(this::mightLeak);    \/\/ this is a leak\n+            }\n+\n+            public Test2(int x) {\n+                final Test2 foo = new Test2();\n+                new Thread(foo::mightLeak);     \/\/ this is not a leak\n+            }\n+\n+            public Test2(char x) {\n+                new Thread(this::noLeak);       \/\/ this is not a leak\n+            }\n+\n+            public void mightLeak() {\n+            }\n+\n+            private void noLeak() {\n+            }\n+        }\n+\n+    \/\/ Test 3 - ReferenceKind.IMPLICIT_INNER\n+\n+        public static class Test3 {\n+\n+            public Test3() {\n+                new Thread(Inner1::new);        \/\/ this is a leak\n+            }\n+\n+            public Test3(int x) {\n+                new Thread(Inner2::new);        \/\/ this is not a leak\n+            }\n+\n+            public void mightLeak() {\n+            }\n+\n+            public class Inner1 {\n+                public Inner1() {\n+                    Test3.this.mightLeak();\n+                }\n+            }\n+\n+            public class Inner2 {\n+                public Inner2() {\n+                    new Test3().mightLeak();\n+                }\n+            }\n+        }\n+\n+    \/\/ Test 4 - ReferenceKind.UNBOUND, STATIC, TOPLEVEL, ARRAY_CTOR\n+\n+        public static class Test4 {\n+\n+            \/\/ ReferenceKind.UNBOUND\n+            public Test4() {\n+                Test4.bar(Test4::sameHashCode);\n+            }\n+\n+            \/\/ ReferenceKind.STATIC\n+            public Test4(int x) {\n+                new Thread(Test4::noLeak);      \/\/ this is not a leak\n+            }\n+\n+            \/\/ ReferenceKind.ARRAY_CTOR\n+            public Test4(char x) {\n+                Test4.foo(String[]::new);       \/\/ this is not a leak\n+            }\n+\n+            \/\/ ReferenceKind.TOPLEVEL\n+            public Test4(short x) {\n+                Test4.foo(Test4::new);          \/\/ this is not a leak\n+            }\n+\n+            public static void noLeak() {\n+            }\n+\n+            public static void foo(IntFunction<?> x) {\n+                x.hashCode();\n+            }\n+\n+            public static void bar(BiPredicate<Test4, Object> x) {\n+                x.hashCode();\n+            }\n+\n+            public boolean sameHashCode(Object obj) {\n+                return obj.hashCode() == this.hashCode();\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles leaks via method return values\n+    public static class ThisEscapeReturnValue {\n+\n+        public ThisEscapeReturnValue() {\n+            final Object rval = ThisEscapeReturnValue.method(this);\n+            ((ThisEscapeReturnValue)rval).mightLeak();\n+        }\n+\n+        public static Object method(Object obj) {\n+            return obj;\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection from a thrown 'this'\n+    public static class ThisEscapeThrown extends RuntimeException {\n+\n+        public ThisEscapeThrown(Object obj) {\n+            if (obj == null)\n+                throw this;\n+        }\n+    }\n+\n+    \/\/ Verify proper 'this' escape interpretation of unqualified non-static method invocations\n+    public static class ThisEscapeUnqualified {\n+\n+        \/\/ This class has a leak\n+        public static class Example1 {\n+\n+            public Example1() {\n+                new Inner();\n+            }\n+\n+            public final class Inner {\n+                public Inner() {\n+                    mightLeak();    \/\/ refers to Example1.mightLeak()\n+                }\n+            }\n+\n+            public void mightLeak() {\n+            }\n+        }\n+\n+        \/\/ This class does NOT have a leak\n+        public static class Example2 {\n+\n+            public Example2() {\n+                new Inner();\n+            }\n+\n+            public final class Inner {\n+                public Inner() {\n+                    mightLeak();    \/\/ refers to Inner.mightLeak()\n+                }\n+\n+                public void mightLeak() {\n+                }\n+            }\n+\n+            public void mightLeak() {\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via switch expression yields\n+    public static class ThisEscapeYield {\n+\n+        public ThisEscapeYield(int x) {\n+            ThisEscapeYield y = switch (x) {\n+                case 3:\n+                    if (x > 17)\n+                        yield this;\n+                    else\n+                        yield null;\n+                default:\n+                    yield null;\n+            };\n+            if (y != null)\n+                y.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on constructors\n+    public static class ThisEscapeSuppressCtor {\n+\n+        private final int x = this.mightLeak();\n+\n+        @SuppressWarnings(\"this-escape\")\n+        public ThisEscapeSuppressCtor() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on fields\n+    public static class ThisEscapeSuppressField {\n+\n+        @SuppressWarnings(\"this-escape\")\n+        private final int x = this.mightLeak();\n+\n+        public ThisEscapeSuppressField() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on classes\n+    public static class ThisEscapeSuppressClass {\n+\n+        @SuppressWarnings(\"this-escape\")\n+        private final int x = this.mightLeak();\n+\n+        @SuppressWarnings(\"this-escape\")\n+        public ThisEscapeSuppressClass() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection doesn't generate certain false positives\n+    public static class ThisEscapeNoEscapes {\n+\n+        public ThisEscapeNoEscapes() {\n+            this.noLeak1();                             \/\/ invoked method is private\n+            this.noLeak2();                             \/\/ invoked method is final\n+            ThisEscapeNoEscapes.noLeak3();              \/\/ invoked method is static\n+            this.noLeak4(this);                         \/\/ parameter is 'this' but it's not leaked\n+            this.noLeak5(new ThisEscapeNoEscapes(0));   \/\/ parameter is not 'this', so no leak\n+            this.noLeak6(null, this, null);             \/\/ method leaks 1st and 3rd parameters only\n+            this.noLeak7();                             \/\/ method does complicated stuff but doesn't leak\n+            Runnable r1 = () -> {                       \/\/ lambda does not leak 'this'\n+                if (System.out == System.err)\n+                    throw new RuntimeException();\n+            };\n+            System.out.println(r1);                     \/\/ lambda does not leak 'this'\n+            Runnable r2 = () -> {                       \/\/ lambda leaks 'this' but is never used\n+                this.mightLeak1();\n+            };\n+            Runnable r3 = this::mightLeak1;             \/\/ reference leaks 'this' but is never used\n+        }\n+\n+        public ThisEscapeNoEscapes(int x) {\n+        }\n+\n+        public void mightLeak1() {\n+        }\n+\n+        private void noLeak1() {\n+        }\n+\n+        public final void noLeak2() {\n+        }\n+\n+        public static void noLeak3() {\n+        }\n+\n+        public static void noLeak4(ThisEscapeNoEscapes param) {\n+            param.noLeak1();\n+            param.noLeak2();\n+        }\n+\n+        public final void noLeak5(ThisEscapeNoEscapes param) {\n+            param.mightLeak1();\n+        }\n+\n+        public final void noLeak6(ThisEscapeNoEscapes param1,\n+            ThisEscapeNoEscapes param2, ThisEscapeNoEscapes param3) {\n+            if (param1 != null)\n+                param1.mightLeak1();\n+            if (param2 != null)\n+                param2.noLeak2();\n+            if (param3 != null)\n+                param3.mightLeak1();\n+        }\n+\n+        public final void noLeak7() {\n+            ((ThisEscapeNoEscapes)(Object)this).noLeak2();\n+            final ThisEscapeNoEscapes obj1 = switch (new Object().hashCode()) {\n+                case 1, 2, 3 -> null;\n+                default -> new ThisEscapeNoEscapes(0);\n+            };\n+            obj1.mightLeak1();\n+        }\n+\n+    \/\/ PrivateClass\n+\n+        private static class PrivateClass {\n+\n+            PrivateClass() {\n+                this.cantLeak();                    \/\/ method is inside a private class\n+            }\n+\n+            public void cantLeak() {\n+            }\n+        }\n+\n+    \/\/ FinalClass\n+\n+        public static final class FinalClass extends ThisEscapeNoEscapes {\n+\n+            public FinalClass() {\n+                this.mightLeak1();                  \/\/ class and therefore method is final\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            new ThisEscapeNoEscapes();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":587,"deletions":0,"binary":false,"changes":587,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+ThisEscape.java:17:60: compiler.warn.possible.this.escape\n+ThisEscape.java:28:27: compiler.warn.possible.this.escape\n+ThisEscape.java:39:37: compiler.warn.possible.this.escape\n+ThisEscape.java:120:17: compiler.warn.possible.this.escape\n+ThisEscape.java:133:27: compiler.warn.possible.this.escape.location\n+ThisEscape.java:126:17: compiler.warn.possible.this.escape\n+ThisEscape.java:133:27: compiler.warn.possible.this.escape.location\n+ThisEscape.java:143:51: compiler.warn.possible.this.escape\n+ThisEscape.java:145:51: compiler.warn.possible.this.escape\n+ThisEscape.java:163:32: compiler.warn.possible.this.escape\n+ThisEscape.java:183:35: compiler.warn.possible.this.escape\n+ThisEscape.java:195:13: compiler.warn.possible.this.escape\n+ThisEscape.java:204:51: compiler.warn.possible.this.escape.location\n+ThisEscape.java:224:39: compiler.warn.possible.this.escape\n+ThisEscape.java:228:25: compiler.warn.possible.this.escape.location\n+ThisEscape.java:237:27: compiler.warn.possible.this.escape\n+ThisEscape.java:261:28: compiler.warn.possible.this.escape\n+ThisEscape.java:276:28: compiler.warn.possible.this.escape\n+ThisEscape.java:300:28: compiler.warn.possible.this.escape\n+ThisEscape.java:369:52: compiler.warn.possible.this.escape\n+ThisEscape.java:385:17: compiler.warn.possible.this.escape\n+ThisEscape.java:396:17: compiler.warn.possible.this.escape\n+ThisEscape.java:401:30: compiler.warn.possible.this.escape.location\n+ThisEscape.java:444:28: compiler.warn.possible.this.escape\n+ThisEscape.java:473:27: compiler.warn.possible.this.escape\n+25 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -1,17 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeArrayElement.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeArrayElement.java\n- * @summary Verify 'this' escape detection can follow references embedded as array elements\n- *\/\n-\n-public class ThisEscapeArrayElement {\n-\n-    public ThisEscapeArrayElement() {\n-        final Object[][] array = new Object[][] { { this } };\n-        ((ThisEscapeArrayElement)array[0][0]).mightLeak();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeArrayElement.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeArrayElement.java:12:56: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeArrayElement.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,16 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeBasic.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeBasic.java\n- * @summary Verify basic 'this' escape detection\n- *\/\n-\n-public class ThisEscapeBasic {\n-\n-    public ThisEscapeBasic() {\n-        this.mightLeak();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeBasic.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeBasic.java:11:23: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeBasic.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeComplex.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeComplex.java\n- * @summary Verify 'this' escape detection can follow references through various Java code structures\n- *\/\n-\n-import java.util.function.Supplier;\n-\n-public class ThisEscapeComplex {\n-\n-    public ThisEscapeComplex() {\n-        this.method1().mightLeak();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-\n-    private ThisEscapeComplex method1() {\n-        while (true) {\n-            do {\n-                for (ThisEscapeComplex x = this.method2(); new Object().hashCode() < 10; ) {\n-                    for (int y : new int[] { 123, 456 }) {\n-                        return x;\n-                    }\n-                }\n-            } while (true);\n-        }\n-    }\n-\n-    private ThisEscapeComplex method2() {\n-        switch (new Object().hashCode()) {\n-        case 1:\n-        case 2:\n-        case 3:\n-            return null;\n-        default:\n-            return this.method3();\n-        }\n-    }\n-\n-    private ThisEscapeComplex method3() {\n-        return switch (new Object().hashCode()) {\n-            case 1, 2, 3 -> this.method4();\n-            default -> null;\n-        };\n-    }\n-\n-    private ThisEscapeComplex method4() {\n-        return ThisEscapeComplex.this.method5();\n-    }\n-\n-    private ThisEscapeComplex method5() {\n-        final ThisEscapeComplex foo = this.method6();\n-        return foo;\n-    }\n-\n-    private ThisEscapeComplex method6() {\n-        synchronized (new Object()) {\n-            return this.method7();\n-        }\n-    }\n-\n-    private ThisEscapeComplex method7() {\n-        ThisEscapeComplex x = null;\n-        ThisEscapeComplex y = this.method8();\n-        if (new Object().hashCode() == 3)\n-            return x;\n-        else\n-            return y;\n-    }\n-\n-    private ThisEscapeComplex method8() {\n-        return (ThisEscapeComplex)(Object)this.method9();\n-    }\n-\n-    private ThisEscapeComplex method9() {\n-        return new Object().hashCode() == 3 ? this : null;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeComplex.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeComplex.java:13:33: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeComplex.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeCtors.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeCtors.java\n- * @summary Verify pruning of 'this' escape warnings for various constructors\n- *\/\n-\n-public class ThisEscapeCtors {\n-\n-    \/\/ This constructor should NOT generate a warning because it would be a\n-    \/\/ duplicate of the warning already generated for ThisEscapeCtors(short).\n-    public ThisEscapeCtors(char x) {\n-        this((short)x);\n-    }\n-\n-    \/\/ This constructor should generate a warning because it invokes leaky this()\n-    \/\/ and is accessible to subclasses.\n-    public ThisEscapeCtors(short x) {\n-        this();\n-    }\n-\n-    \/\/ This constructor should generate a warning because it invokes leaky this()\n-    \/\/ and is accessible to subclasses.\n-    public ThisEscapeCtors(int x) {\n-        this();\n-    }\n-\n-    \/\/ This constructor should NOT generate a warning because it is not accessbile\n-    \/\/ to subclasses. However, other constructors do invoke it, and that should cause\n-    \/\/ them to generate an indirect warning.\n-    private ThisEscapeCtors() {\n-        this.mightLeak();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeCtors.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ThisEscapeCtors.java:19:13: compiler.warn.possible.this.escape\n-ThisEscapeCtors.java:32:23: compiler.warn.possible.this.escape.location\n-ThisEscapeCtors.java:25:13: compiler.warn.possible.this.escape\n-ThisEscapeCtors.java:32:23: compiler.warn.possible.this.escape.location\n-4 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeCtors.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeFields.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeFields.java\n- * @summary Verify 'this' escape detection in field initializers\n- *\/\n-\n-public class ThisEscapeFields {\n-\n-    private final int field1 = this.mightLeak1();\n-\n-    private final int field2 = this.mightLeak2();\n-\n-    public int mightLeak1() {\n-        return 123;\n-    }\n-\n-    public int mightLeak2() {\n-        return 456;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeFields.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ThisEscapeFields.java:10:47: compiler.warn.possible.this.escape\n-ThisEscapeFields.java:12:47: compiler.warn.possible.this.escape\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeFields.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeLambda.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeLambda.java\n- * @summary Verify 'this' escape detection properly handles lambdas\n- *\/\n-\n-public class ThisEscapeLambda {\n-\n-    public ThisEscapeLambda() {\n-        Runnable r = () -> {\n-            this.mightLeak();\n-        };\n-        System.out.println(r);\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLambda.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeLambda.java:14:28: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLambda.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeLoop.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeLoop.java\n- * @summary Verify 'this' escape detection properly handles loop convergence\n- *\/\n-\n-public class ThisEscapeLoop {\n-\n-    public ThisEscapeLoop() {\n-        ThisEscapeLoop ref1 = this;\n-        ThisEscapeLoop ref2 = null;\n-        ThisEscapeLoop ref3 = null;\n-        ThisEscapeLoop ref4 = null;\n-        for (int i = 0; i < 100; i++) {\n-            ref4 = ref3;\n-            ref3 = ref2;\n-            ref2 = ref1;\n-            if (ref4 != null)\n-                ref4.mightLeak();\n-        }\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLoop.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeLoop.java:20:31: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeLoop.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8015831\n- * @summary Verify 'this' escape detection doesn't generate certain false positives\n- *\/\n-public class ThisEscapeNoEscapes {\n-\n-    public ThisEscapeNoEscapes() {\n-        this.noLeak1();                             \/\/ invoked method is private\n-        this.noLeak2();                             \/\/ invoked method is final\n-        ThisEscapeNoEscapes.noLeak3();              \/\/ invoked method is static\n-        this.noLeak4(this);                         \/\/ parameter is 'this' but it's not leaked\n-        this.noLeak5(new ThisEscapeNoEscapes(0));   \/\/ parameter is not 'this', so no leak\n-        this.noLeak6(null, this, null);             \/\/ method leaks 1st and 3rd parameters only\n-        this.noLeak7();                             \/\/ method does complicated stuff but doesn't leak\n-        Runnable r1 = () -> {                       \/\/ lambda does not leak 'this'\n-            if (System.out == System.err)\n-                throw new RuntimeException();\n-        };\n-        System.out.println(r1);                     \/\/ lambda does not leak 'this'\n-        Runnable r2 = () -> {                       \/\/ lambda leaks 'this' but is never used\n-            this.mightLeak1();\n-        };\n-        Runnable r3 = this::mightLeak1;             \/\/ reference leaks 'this' but is never used\n-    }\n-\n-    public ThisEscapeNoEscapes(int x) {\n-    }\n-\n-    public void mightLeak1() {\n-    }\n-\n-    private void noLeak1() {\n-    }\n-\n-    public final void noLeak2() {\n-    }\n-\n-    public static void noLeak3() {\n-    }\n-\n-    public static void noLeak4(ThisEscapeNoEscapes param) {\n-        param.noLeak1();\n-        param.noLeak2();\n-    }\n-\n-    public final void noLeak5(ThisEscapeNoEscapes param) {\n-        param.mightLeak1();\n-    }\n-\n-    public final void noLeak6(ThisEscapeNoEscapes param1,\n-        ThisEscapeNoEscapes param2, ThisEscapeNoEscapes param3) {\n-        if (param1 != null)\n-            param1.mightLeak1();\n-        if (param2 != null)\n-            param2.noLeak2();\n-        if (param3 != null)\n-            param3.mightLeak1();\n-    }\n-\n-    public final void noLeak7() {\n-        ((ThisEscapeNoEscapes)(Object)this).noLeak2();\n-        final ThisEscapeNoEscapes obj1 = switch (new Object().hashCode()) {\n-            case 1, 2, 3 -> null;\n-            default -> new ThisEscapeNoEscapes(0);\n-        };\n-        obj1.mightLeak1();\n-    }\n-\n-\/\/ PrivateClass\n-\n-    private static class PrivateClass {\n-\n-        PrivateClass() {\n-            this.cantLeak();                    \/\/ method is inside a private class\n-        }\n-\n-        public void cantLeak() {\n-        }\n-    }\n-\n-\/\/ FinalClass\n-\n-    public static final class FinalClass extends ThisEscapeNoEscapes {\n-\n-        public FinalClass() {\n-            this.mightLeak1();                  \/\/ class and therefore method is final\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new ThisEscapeNoEscapes();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeNoEscapes.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeOuterThis.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeOuterThis.java\n- * @summary Verify 'this' escape detection handles leaks via outer 'this'\n- *\/\n-\n-public class ThisEscapeOuterThis {\n-\n-    public ThisEscapeOuterThis() {\n-        new InnerClass();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-\n-    public class InnerClass {\n-\n-        InnerClass() {\n-            ThisEscapeOuterThis.this.mightLeak();\n-        }\n-    }\n-\n-    \/\/ No leak here because class 'Local' cannot be externally extended\n-    public static void method1() {\n-        class Local {\n-            Local() {\n-                this.wontLeak();\n-            }\n-            void wontLeak() {\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeOuterThis.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ThisEscapeOuterThis.java:11:9: compiler.warn.possible.this.escape\n-ThisEscapeOuterThis.java:20:47: compiler.warn.possible.this.escape.location\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeOuterThis.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeParameter.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeParameter.java\n- * @summary Verify 'this' escape detection handles leaks via passing 'this' as a parameter\n- *\/\n-\n-public class ThisEscapeParameter {\n-\n-    public ThisEscapeParameter() {\n-        ThisEscapeParameter.method(this);\n-    }\n-\n-    public static void method(Object obj) {\n-        obj.hashCode();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeParameter.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ThisEscapeParameter.java:11:35: compiler.warn.possible.this.escape\n-ThisEscapeParameter.java:15:21: compiler.warn.possible.this.escape.location\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeParameter.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeRecursion.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeRecursion.java\n- * @summary Verify 'this' escape detection properly handles leaks via recursive methods\n- *\/\n-\n-public class ThisEscapeRecursion {\n-\n-    public ThisEscapeRecursion() {\n-        this.noLeak(0);         \/\/ no leak here\n-        this.mightLeak();       \/\/ possible leak here\n-    }\n-\n-    public final void noLeak(int depth) {\n-        if (depth < 10)\n-            this.noLeak(depth - 1);\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeRecursion.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeRecursion.java:12:23: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeRecursion.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeReference.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeReference.java\n- * @summary Verify proper handling of 'this' escape warnings from method references\n- *\/\n-\n-import java.util.function.*;\n-\n-public class ThisEscapeReference {\n-\n-\/\/ Test 1 - ReferenceKind.SUPER\n-\n-    public static class Test1 {\n-        public void mightLeak() {\n-        }\n-    }\n-\n-    public static class Test1b extends Test1 {\n-        public Test1b() {\n-            new Thread(super::mightLeak);   \/\/ this is a leak\n-        }\n-    }\n-\n-    public static class Test1c extends Test1 {\n-        public Test1c() {\n-            new Thread(super::notify);      \/\/ this is not a leak\n-        }\n-    }\n-\n-\/\/ Test 2 - ReferenceKind.BOUND\n-\n-    public static class Test2 {\n-\n-        public Test2() {\n-            new Thread(this::mightLeak);    \/\/ this is a leak\n-        }\n-\n-        public Test2(int x) {\n-            final Test2 foo = new Test2();\n-            new Thread(foo::mightLeak);     \/\/ this is not a leak\n-        }\n-\n-        public Test2(char x) {\n-            new Thread(this::noLeak);       \/\/ this is not a leak\n-        }\n-\n-        public void mightLeak() {\n-        }\n-\n-        private void noLeak() {\n-        }\n-    }\n-\n-\/\/ Test 3 - ReferenceKind.IMPLICIT_INNER\n-\n-    public static class Test3 {\n-\n-        public Test3() {\n-            new Thread(Inner1::new);        \/\/ this is a leak\n-        }\n-\n-        public Test3(int x) {\n-            new Thread(Inner2::new);        \/\/ this is not a leak\n-        }\n-\n-        public void mightLeak() {\n-        }\n-\n-        public class Inner1 {\n-            public Inner1() {\n-                Test3.this.mightLeak();\n-            }\n-        }\n-\n-        public class Inner2 {\n-            public Inner2() {\n-                new Test3().mightLeak();\n-            }\n-        }\n-    }\n-\n-\/\/ Test 4 - ReferenceKind.UNBOUND, STATIC, TOPLEVEL, ARRAY_CTOR\n-\n-    public static class Test4 {\n-\n-        \/\/ ReferenceKind.UNBOUND\n-        public Test4() {\n-            Test4.bar(Test4::sameHashCode);\n-        }\n-\n-        \/\/ ReferenceKind.STATIC\n-        public Test4(int x) {\n-            new Thread(Test4::noLeak);      \/\/ this is not a leak\n-        }\n-\n-        \/\/ ReferenceKind.ARRAY_CTOR\n-        public Test4(char x) {\n-            Test4.foo(String[]::new);       \/\/ this is not a leak\n-        }\n-\n-        \/\/ ReferenceKind.TOPLEVEL\n-        public Test4(short x) {\n-            Test4.foo(Test4::new);          \/\/ this is not a leak\n-        }\n-\n-        public static void noLeak() {\n-        }\n-\n-        public static void foo(IntFunction<?> x) {\n-            x.hashCode();\n-        }\n-\n-        public static void bar(BiPredicate<Test4, Object> x) {\n-            x.hashCode();\n-        }\n-\n-        public boolean sameHashCode(Object obj) {\n-            return obj.hashCode() == this.hashCode();\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReference.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-ThisEscapeReference.java:21:24: compiler.warn.possible.this.escape\n-ThisEscapeReference.java:36:24: compiler.warn.possible.this.escape\n-ThisEscapeReference.java:60:24: compiler.warn.possible.this.escape\n-3 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReference.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeReturnValue.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeReturnValue.java\n- * @summary Verify 'this' escape detection properly handles leaks via method return values\n- *\/\n-\n-public class ThisEscapeReturnValue {\n-\n-    public ThisEscapeReturnValue() {\n-        final Object rval = ThisEscapeReturnValue.method(this);\n-        ((ThisEscapeReturnValue)rval).mightLeak();\n-    }\n-\n-    public static Object method(Object obj) {\n-        return obj;\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReturnValue.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeReturnValue.java:12:48: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeReturnValue.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8015831\n- * @summary Verify 'this' escape warnings can be properly suppressed\n- *\/\n-public class ThisEscapeSuppressed {\n-\n-    public ThisEscapeSuppressed() {\n-        this.mightLeak();\n-    }\n-\n-    @SuppressWarnings(\"this-escape\")\n-    public void mightLeak() {\n-    }\n-\n-    public static void main(String[] args) {\n-        new ThisEscapeSuppressed();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeSuppressed.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeThrown.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeThrown.java\n- * @summary Verify 'this' escape detection from a thrown 'this'\n- *\/\n-\n-public class ThisEscapeThrown extends RuntimeException {\n-\n-    public ThisEscapeThrown(Object obj) {\n-        if (obj == null)\n-            throw this;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeThrown.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeThrown.java:12:13: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeThrown.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeUnqualified.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeUnqualified.java\n- * @summary Verify proper 'this' escape interpretation of unqualified non-static method invocations.\n- *\/\n-\n-public class ThisEscapeUnqualified {\n-\n-    \/\/ This class has a leak\n-    public static class Example1 {\n-\n-        public Example1() {\n-            new Inner();\n-        }\n-\n-        public final class Inner {\n-            public Inner() {\n-                mightLeak();    \/\/ refers to Example1.mightLeak()\n-            }\n-        }\n-\n-        public void mightLeak() {\n-        }\n-    }\n-\n-    \/\/ This class does NOT have a leak\n-    public static class Example2 {\n-\n-        public Example2() {\n-            new Inner();\n-        }\n-\n-        public final class Inner {\n-            public Inner() {\n-                mightLeak();    \/\/ refers to Inner.mightLeak()\n-            }\n-\n-            public void mightLeak() {\n-            }\n-        }\n-\n-        public void mightLeak() {\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeUnqualified.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ThisEscapeUnqualified.java:14:13: compiler.warn.possible.this.escape\n-ThisEscapeUnqualified.java:19:26: compiler.warn.possible.this.escape.location\n-2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeUnqualified.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8015831\n- * @compile\/ref=ThisEscapeYield.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeYield.java\n- * @summary Verify 'this' escape detection handles leaks via switch expression yields\n- *\/\n-\n-public class ThisEscapeYield {\n-\n-    public ThisEscapeYield(int x) {\n-        ThisEscapeYield y = switch (x) {\n-            case 3:\n-                if (x > 17)\n-                    yield this;\n-                else\n-                    yield null;\n-            default:\n-                yield null;\n-        };\n-        if (y != null)\n-            y.mightLeak();\n-    }\n-\n-    public void mightLeak() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeYield.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ThisEscapeYield.java:21:24: compiler.warn.possible.this.escape\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeYield.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"}]}