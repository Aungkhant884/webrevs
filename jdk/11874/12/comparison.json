{"files":[{"patch":"@@ -174,1 +174,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked this-escape, \\\n@@ -181,1 +181,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked static serial cast this-escape, \\\n@@ -185,1 +185,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast this-escape, \\\n@@ -192,1 +192,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked cast lossy-conversions, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked cast lossy-conversions this-escape, \\\n@@ -197,1 +197,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked, \\\n+    DISABLED_WARNINGS := rawtypes unchecked this-escape, \\\n@@ -202,1 +202,1 @@\n-    DISABLED_WARNINGS := rawtypes, \\\n+    DISABLED_WARNINGS := rawtypes this-escape, \\\n@@ -208,1 +208,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked, \\\n+    DISABLED_WARNINGS := rawtypes unchecked this-escape, \\\n@@ -218,1 +218,1 @@\n-    DISABLED_WARNINGS := rawtypes unchecked deprecation, \\\n+    DISABLED_WARNINGS := rawtypes unchecked deprecation this-escape, \\\n@@ -223,0 +223,1 @@\n+    DISABLED_WARNINGS := this-escape, \\\n","filename":"make\/CompileDemos.gmk","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := fallthrough, \\\n+    DISABLED_WARNINGS := fallthrough this-escape, \\\n","filename":"make\/CompileModuleTools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/CompileToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.datatransfer\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n+DISABLED_WARNINGS_java += lossy-conversions this-escape\n","filename":"make\/modules\/java.desktop\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.logging\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.management\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.naming\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.net.http\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.rmi\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.security.jgss\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.security.sasl\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.sql.rowset\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.sql\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/java.xml.crypto\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n+DISABLED_WARNINGS_java += lossy-conversions this-escape\n","filename":"make\/modules\/java.xml\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.accessibility\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.attach\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.charsets\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.compiler\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.ec\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.mscapi\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.dynalink\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-    fallthrough\n+    fallthrough this-escape\n","filename":"make\/modules\/jdk.hotspot.agent\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-DISABLED_WARNINGS_java += missing-explicit-ctor\n+DISABLED_WARNINGS_java += missing-explicit-ctor this-escape\n","filename":"make\/modules\/jdk.httpserver\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.jvmstat\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.le\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.opt\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options this-escape, \\\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.javadoc\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jcmd\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jconsole\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jdi\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.jlink\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.jshell\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.jstatd\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.localedata\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.management\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.naming.dns\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += this-escape\n+\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-COPY += .properties .caps .txt\n+DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.zipfs\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.le\/Java.gmk","status":"copied"},{"patch":"@@ -54,1 +54,1 @@\n-    DISABLED_WARNINGS := options serial try, \\\n+    DISABLED_WARNINGS := options serial try this-escape, \\\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    DISABLED_WARNINGS := rawtypes serial options, \\\n+    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n+    DISABLED_WARNINGS := this-escape processing rawtypes cast serial preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -309,0 +309,5 @@\n+        \/**\n+         * Warn about possible 'this' escapes before subclass instance is fully initialized.\n+         *\/\n+        THIS_ESCAPE(\"this-escape\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+        new ThisEscapeAnalyzer(names, syms, types, log, lint).analyzeTree(env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1468 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.Map.Entry;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Pair;\n+\n+import static com.sun.tools.javac.code.Kinds.Kind.*;\n+import static com.sun.tools.javac.code.TypeTag.*;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n+\n+\/**\n+ * Looks for possible 'this' escapes and generates corresponding warnings.\n+ *\n+ * <p>\n+ * A 'this' escape is when a constructor invokes a method that could be overridden in a\n+ * subclass, in which case the method will execute before the subclass constructor has\n+ * finished initializing the instance.\n+ *\n+ * <p>\n+ * This class attempts to identify possible 'this' escapes while also striking a balance\n+ * between false positives, false negatives, and code complexity. We do this by \"executing\"\n+ * the code in candidate constructors and tracking where the original 'this' reference goes.\n+ * If it ever passes to code outside of the current compilation unit, we declare a possible leak.\n+ * On the other hand, when constructors and non-overridable methods within the same compilation\n+ * unit are invoked, we \"invoke\" them to follow references.\n+ *\n+ * <p>\n+ * As we analyze constructors and the methods they invoke, we track the various things in scope\n+ * that could possibly reference the 'this' instance we are following. Such references are\n+ * represented by {@link Ref} instances, of which there are these varieties:\n+ * <ul>\n+ *  <li>The current 'this' reference; see {@link ThisRef}\n+ *  <li>The current outer 'this' reference; see {@link OuterRef}\n+ *  <li>Local variables and method parameters; see {@link VarRef}\n+ *  <li>The current expression being evaluated, i.e.,what's on top of the Java stack; see {@link ExprRef}\n+ *  <li>The current method's return value; see {@link ReturnRef}\n+ * <\/ul>\n+ *\n+ * <p>\n+ * For each type of reference, we distinguish between <i>direct<\/i> and <i>indirect<\/i> references.\n+ * A direct reference means the reference directly refers to the 'this' instance we are tracking.\n+ * An indirect reference means the reference refers to the 'this' instance we are tracking through\n+ * at least one level of indirection.\n+ *\n+ * <p>\n+ * Currently we do not attempt to explicitly track references stored in fields (for future study).\n+ *\n+ * <p>\n+ * A few notes on this implementation:\n+ * <ul>\n+ *  <li>We \"execute\" constructors and track where the 'this' reference goes as the constructor executes.\n+ *  <li>We use a very simplified flow analysis that you might call a \"flood analysis\", where the union\n+ *      of every possible code branch is taken.\n+ *  <li>A \"leak\" is defined as the possible passing of a subclassed 'this' reference to code defined\n+ *      outside of the current compilation unit.\n+ *  <ul>\n+ *      <li>In other words, we don't try to protect the current compilation unit from itself.\n+ *      <li>For example, we ignore private constructors because they can never be directly invoked\n+ *          by external subclasses, etc. However, they can be indirectly invoked by other constructors.\n+ *  <\/ul>\n+ *  <li>If a constructor invokes a method defined in the same compilation unit, and that method cannot\n+ *      be overridden, then our analysis can safely \"recurse\" into the method.\n+ *  <ul>\n+ *      <li>When this occurs the warning displays each step in the stack trace to help in comprehension.\n+ *  <\/ul>\n+ *  <li>We assume that native methods do not leak.\n+ *  <li>We don't try to follow {@code super()} invocations; that's for the superclass analysis to handle.\n+ *  <\/ul>\n+ *\/\n+class ThisEscapeAnalyzer extends TreeScanner {\n+\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Types types;\n+    private final Log log;\n+    private       Lint lint;\n+\n+\/\/ These fields are scoped to the entire compilation unit\n+\n+    \/** Maps symbols of all methods to their corresponding declarations.\n+     *\/\n+    private final Map<Symbol, MethodInfo> methodMap = new LinkedHashMap<>();\n+\n+    \/** Contains symbols of fields and constructors that have warnings suppressed.\n+     *\/\n+    private final Set<Symbol> suppressed = new HashSet<>();\n+\n+    \/** The declaring class of the constructor we're currently analyzing.\n+     *  This is the 'this' type we're trying to detect leaks of.\n+     *\/\n+    private JCClassDecl targetClass;\n+\n+    \/** Snapshots of {@link #callStack} where possible 'this' escapes occur.\n+     *\/\n+    private final ArrayList<DiagnosticPosition[]> warningList = new ArrayList<>();\n+\n+\/\/ These fields are scoped to the constructor being analyzed\n+\n+    \/** The declaring class of the \"invoked\" method we're currently analyzing.\n+     *  This is either the analyzed constructor or some method it invokes.\n+     *\/\n+    private JCClassDecl methodClass;\n+\n+    \/** The current \"call stack\" during our analysis. The first entry is some method\n+     *  invoked from the target constructor; if empty, we're still in the constructor.\n+     *\/\n+    private final ArrayDeque<DiagnosticPosition> callStack = new ArrayDeque<>();\n+\n+    \/** Used to terminate recursion in {@link #invokeInvokable invokeInvokable()}.\n+     *\/\n+    private final Set<Pair<JCTree, RefSet<Ref>>> invocations = new HashSet<>();\n+\n+    \/** Snapshot of {@link #callStack} where a possible 'this' escape occurs.\n+     *  If non-null, a 'this' escape warning has been found in the current\n+     *  constructor statement, initialization block statement, or field initializer.\n+     *\/\n+    private DiagnosticPosition[] pendingWarning;\n+\n+\/\/ These fields are scoped to the constructor or invoked method being analyzed\n+\n+    \/** Current lexical scope depth in the constructor or method we're currently analyzing.\n+     *  Depth zero is the outermost scope. Depth -1 means we're not analyzing.\n+     *\/\n+    private int depth = -1;\n+\n+    \/** Possible 'this' references in the constructor or method we're currently analyzing.\n+     *  Null value means we're not analyzing.\n+     *\/\n+    private RefSet<Ref> refs;\n+\n+\/\/ Constructor\n+\n+    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Log log, Lint lint) {\n+        this.names = names;\n+        this.syms = syms;\n+        this.types = types;\n+        this.log = log;\n+        this.lint = lint;\n+    }\n+\n+\/\/\n+\/\/ Main method\n+\/\/\n+\n+    public void analyzeTree(Env<AttrContext> env) {\n+\n+        \/\/ Sanity check\n+        Assert.check(checkInvariants(false, false));\n+        Assert.check(methodMap.isEmpty());      \/\/ we are not prepared to be used more than once\n+\n+        \/\/ Short circuit if warnings are totally disabled\n+        if (!lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+            return;\n+\n+        \/\/ Build a set of symbols for classes declared in this file\n+        final Set<Symbol> classSyms = new HashSet<>();\n+        new TreeScanner() {\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                classSyms.add(tree.sym);\n+                super.visitClassDef(tree);\n+            }\n+        }.scan(env.tree);\n+\n+        \/\/ Build a mapping from symbols of methods to their declarations.\n+        \/\/ Classify all ctors and methods as analyzable and\/or invokable.\n+        \/\/ Track which constructors and fields have warnings suppressed.\n+        new TreeScanner() {\n+\n+            private Lint lint = ThisEscapeAnalyzer.this.lint;\n+            private JCClassDecl currentClass;\n+            private boolean privateOuter;\n+\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                JCClassDecl currentClassPrev = currentClass;\n+                boolean privateOuterPrev = privateOuter;\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n+                try {\n+                    currentClass = tree;\n+                    privateOuter |= tree.sym.isAnonymous();\n+                    privateOuter |= (tree.mods.flags & Flags.PRIVATE) != 0;\n+\n+                    \/\/ Recurse\n+                    super.visitClassDef(tree);\n+                } finally {\n+                    currentClass = currentClassPrev;\n+                    privateOuter = privateOuterPrev;\n+                    lint = lintPrev;\n+                }\n+            }\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n+                try {\n+\n+                    \/\/ Track warning suppression of fields\n+                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        suppressed.add(tree.sym);\n+\n+                    \/\/ Recurse\n+                    super.visitVarDef(tree);\n+                } finally {\n+                    lint = lintPrev;\n+                }\n+            }\n+\n+            @Override\n+            public void visitMethodDef(JCMethodDecl tree) {\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n+                try {\n+\n+                    \/\/ Track warning suppression of constructors\n+                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        suppressed.add(tree.sym);\n+\n+                    \/\/ Determine if this is a constructor we should analyze\n+                    boolean analyzable = currentClassIsExternallyExtendable() &&\n+                        TreeInfo.isConstructor(tree) &&\n+                        !tree.sym.isPrivate() &&\n+                        !suppressed.contains(tree.sym);\n+\n+                    \/\/ Determine if this method is \"invokable\" in an analysis (can't be overridden)\n+                    boolean invokable = !currentClassIsExternallyExtendable() ||\n+                        TreeInfo.isConstructor(tree) ||\n+                        (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+\n+                    \/\/ Add method or constructor to map\n+                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, analyzable, invokable));\n+\n+                    \/\/ Recurse\n+                    super.visitMethodDef(tree);\n+                } finally {\n+                    lint = lintPrev;\n+                }\n+            }\n+\n+            \/\/ Determines if the current class could be extended in some external compilation unit\n+            private boolean currentClassIsExternallyExtendable() {\n+                return !currentClass.sym.isFinal() &&\n+                  !(currentClass.sym.isSealed() &&\n+                      currentClass.permitting.stream()\n+                        .map(TreeInfo::symbolFor)\n+                        .allMatch(classSyms::contains)) &&\n+                  !currentClass.sym.isDirectlyOrIndirectlyLocal() &&\n+                  !privateOuter;\n+            }\n+        }.scan(env.tree);\n+\n+        \/\/ Analyze non-static field initializers and initialization blocks,\n+        \/\/ but only for classes having at least one analyzable constructor.\n+        methodMap.values().stream()\n+                .filter(MethodInfo::analyzable)\n+                .map(MethodInfo::declaringClass)\n+                .distinct()\n+                .forEach(klass -> {\n+            for (List<JCTree> defs = klass.defs; defs.nonEmpty(); defs = defs.tail) {\n+\n+                \/\/ Ignore static stuff\n+                if ((TreeInfo.flags(defs.head) & Flags.STATIC) != 0)\n+                    continue;\n+\n+                \/\/ Handle field initializers\n+                if (defs.head instanceof JCVariableDecl vardef) {\n+                    visitTopLevel(klass, () -> {\n+                        scan(vardef);\n+                        copyPendingWarning();\n+                    });\n+                    continue;\n+                }\n+\n+                \/\/ Handle initialization blocks\n+                if (defs.head instanceof JCBlock block) {\n+                    visitTopLevel(klass, () -> analyzeStatements(block.stats));\n+                    continue;\n+                }\n+            }\n+        });\n+\n+        \/\/ Analyze all of the analyzable constructors we found\n+        methodMap.values().stream()\n+                .filter(MethodInfo::analyzable)\n+                .forEach(methodInfo -> {\n+            visitTopLevel(methodInfo.declaringClass(),\n+                () -> analyzeStatements(methodInfo.declaration().body.stats));\n+        });\n+\n+        \/\/ Eliminate duplicate warnings. Warning B duplicates warning A if the stack trace of A is a prefix\n+        \/\/ of the stack trace of B. For example, if constructor Foo(int x) has a leak, and constructor\n+        \/\/ Foo() invokes this(0), then emitting a warning for Foo() would be redundant.\n+        BiPredicate<DiagnosticPosition[], DiagnosticPosition[]> extendsAsPrefix = (warning1, warning2) -> {\n+            if (warning2.length < warning1.length)\n+                return false;\n+            for (int index = 0; index < warning1.length; index++) {\n+                if (warning2[index].getPreferredPosition() != warning1[index].getPreferredPosition())\n+                    return false;\n+            }\n+            return true;\n+        };\n+\n+        \/\/ Stack traces are ordered top to bottom, and so duplicates always have the same first element(s).\n+        \/\/ Sort the stack traces lexicographically, so that duplicates immediately follow what they duplicate.\n+        Comparator<DiagnosticPosition[]> ordering = (warning1, warning2) -> {\n+            for (int index1 = 0, index2 = 0; true; index1++, index2++) {\n+                boolean end1 = index1 >= warning1.length;\n+                boolean end2 = index2 >= warning2.length;\n+                if (end1 && end2)\n+                    return 0;\n+                if (end1)\n+                    return -1;\n+                if (end2)\n+                    return 1;\n+                int posn1 = warning1[index1].getPreferredPosition();\n+                int posn2 = warning2[index2].getPreferredPosition();\n+                int diff = Integer.compare(posn1, posn2);\n+                if (diff != 0)\n+                    return diff;\n+            }\n+        };\n+        warningList.sort(ordering);\n+\n+        \/\/ Now emit the warnings, but skipping over duplicates as we go through the list\n+        DiagnosticPosition[] previous = null;\n+        for (DiagnosticPosition[] warning : warningList) {\n+\n+            \/\/ Skip duplicates\n+            if (previous != null && extendsAsPrefix.test(previous, warning))\n+                continue;\n+            previous = warning;\n+\n+            \/\/ Emit warnings showing the entire stack trace\n+            JCDiagnostic.Warning key = Warnings.PossibleThisEscape;\n+            int remain = warning.length;\n+            do {\n+                DiagnosticPosition pos = warning[--remain];\n+                log.warning(Lint.LintCategory.THIS_ESCAPE, pos, key);\n+                key = Warnings.PossibleThisEscapeLocation;\n+            } while (remain > 0);\n+        }\n+        warningList.clear();\n+    }\n+\n+    \/\/ Analyze statements, but stop at (and record) the first warning generated\n+    private void analyzeStatements(List<JCStatement> stats) {\n+        for (JCStatement stat : stats) {\n+            scan(stat);\n+            if (copyPendingWarning())\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void scan(JCTree tree) {\n+\n+        \/\/ Check node\n+        if (tree == null || tree.type == Type.stuckType)\n+            return;\n+\n+        \/\/ Sanity check\n+        Assert.check(checkInvariants(true, false));\n+\n+        \/\/ Can this expression node possibly leave a 'this' reference on the stack?\n+        boolean referenceExpressionNode;\n+        switch (tree.getTag()) {\n+            case SWITCH_EXPRESSION:\n+            case CONDEXPR:\n+            case YIELD:\n+            case APPLY:\n+            case NEWCLASS:\n+            case NEWARRAY:\n+            case LAMBDA:\n+            case PARENS:\n+            case ASSIGN:\n+            case TYPECAST:\n+            case INDEXED:\n+            case SELECT:\n+            case REFERENCE:\n+            case IDENT:\n+            case NULLCHK:\n+            case LETEXPR:\n+                referenceExpressionNode = true;\n+                break;\n+            default:\n+                referenceExpressionNode = false;\n+                break;\n+        }\n+\n+        \/\/ Scan node\n+        super.scan(tree);\n+\n+        \/\/ Sanity check\n+        Assert.check(checkInvariants(true, referenceExpressionNode));\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Class Declarations\n+\/\/\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        return;     \/\/ we're busy analyzing another class - skip\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Variable Declarations\n+\/\/\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+\n+        \/\/ Skip if ignoring warnings for this field\n+        if (suppressed.contains(tree.sym))\n+            return;\n+\n+        \/\/ Scan initializer, if any\n+        scan(tree.init);\n+        if (isParamOrVar(tree.sym))\n+            refs.replaceExprs(depth, direct -> new VarRef(tree.sym, direct));\n+        else\n+            refs.discardExprs(depth);           \/\/ we don't track fields yet\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Methods\n+\/\/\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        Assert.check(false);        \/\/ we should never get here\n+    }\n+\n+    @Override\n+    public void visitApply(JCMethodInvocation invoke) {\n+\n+        \/\/ Get method symbol\n+        MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n+\n+        \/\/ Recurse on method expression\n+        scan(invoke.meth);\n+        boolean direct = refs.remove(ExprRef.direct(depth));\n+        boolean indirect = refs.remove(ExprRef.indirect(depth));\n+\n+        \/\/ Determine if method receiver represents a possible reference\n+        RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n+        if (sym != null && !sym.isStatic()) {\n+            if (direct)\n+                receiverRefs.add(ThisRef.direct());\n+            if (indirect)\n+                receiverRefs.add(ThisRef.indirect());\n+        }\n+\n+        \/\/ If \"super()\": ignore - we don't try to track into superclasses\n+        if (TreeInfo.name(invoke.meth) == names._super)\n+            return;\n+\n+        \/\/ \"Invoke\" the method\n+        invoke(invoke, sym, invoke.args, receiverRefs);\n+    }\n+\n+    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+\n+        \/\/ Skip if ignoring warnings for a constructor invoked via 'this()'\n+        if (suppressed.contains(sym))\n+            return;\n+\n+        \/\/ Ignore final methods in java.lang.Object (getClass(), notify(), etc.)\n+        if (sym != null &&\n+            sym.owner.kind == TYP &&\n+            sym.owner.type.tsym == syms.objectType.tsym &&\n+            sym.isFinal()) {\n+            return;\n+        }\n+\n+        \/\/ Analyze method if possible, otherwise assume nothing\n+        MethodInfo methodInfo = methodMap.get(sym);\n+        if (methodInfo != null && methodInfo.invokable())\n+            invokeInvokable(site, args, receiverRefs, methodInfo);\n+        else\n+            invokeUnknown(site, args, receiverRefs);\n+    }\n+\n+    \/\/ Handle the invocation of a local analyzable method or constructor\n+    private void invokeInvokable(JCTree site, List<JCExpression> args,\n+        RefSet<?> receiverRefs, MethodInfo methodInfo) {\n+        Assert.check(methodInfo.invokable());\n+\n+        \/\/ Collect 'this' references found in method parameters\n+        JCMethodDecl method = methodInfo.declaration();\n+        RefSet<VarRef> paramRefs = RefSet.newEmpty();\n+        List<JCVariableDecl> params = method.params;\n+        while (args.nonEmpty() && params.nonEmpty()) {\n+            VarSymbol sym = params.head.sym;\n+            scan(args.head);\n+            refs.removeExprs(depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n+            args = args.tail;\n+            params = params.tail;\n+        }\n+\n+        \/\/ \"Invoke\" the method\n+        JCClassDecl methodClassPrev = methodClass;\n+        methodClass = methodInfo.declaringClass();\n+        RefSet<Ref> refsPrev = refs;\n+        refs = RefSet.newEmpty();\n+        int depthPrev = depth;\n+        depth = 0;\n+        callStack.push(site);\n+        try {\n+\n+            \/\/ Add initial references from method receiver\n+            refs.addAll(receiverRefs);\n+\n+            \/\/ Add initial references from parameters\n+            refs.addAll(paramRefs);\n+\n+            \/\/ Stop trivial cases here\n+            if (refs.isEmpty())\n+                return;\n+\n+            \/\/ Stop infinite recursion here\n+            Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, refs.clone());\n+            if (!invocations.add(invocation))\n+                return;\n+\n+            \/\/ Scan method body to \"execute\" it\n+            try {\n+                scan(method.body);\n+            } finally {\n+                invocations.remove(invocation);\n+            }\n+\n+            \/\/ \"Return\" any references from method return value\n+            refs.mapInto(refsPrev, ReturnRef.class, direct -> new ExprRef(depthPrev, direct));\n+        } finally {\n+            callStack.pop();\n+            depth = depthPrev;\n+            refs = refsPrev;\n+            methodClass = methodClassPrev;\n+        }\n+    }\n+\n+    \/\/ Handle invocation of an unknown or overridable method or constructor\n+    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<?> receiverRefs) {\n+\n+        \/\/ Detect leak via receiver\n+        if (!receiverRefs.isEmpty())\n+            leakAt(invoke);\n+\n+        \/\/ Detect leaks via method parameters\n+        for (JCExpression arg : args) {\n+            scan(arg);\n+            if (refs.discardExprs(depth))\n+                leakAt(arg);\n+        }\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - new Foo()\n+\/\/\n+\n+    @Override\n+    public void visitNewClass(JCNewClass tree) {\n+        MethodInfo methodInfo = methodMap.get(tree.constructor);\n+        if (methodInfo != null && methodInfo.invokable())\n+            invokeInvokable(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n+        else\n+            invokeUnknown(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type));\n+    }\n+\n+    \/\/ Determine 'this' references passed to a constructor via the outer 'this' instance\n+    private RefSet<OuterRef> outerThisRefs(JCExpression explicitOuterThis, Type type) {\n+        RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n+        if (explicitOuterThis != null) {\n+            scan(explicitOuterThis);\n+            refs.removeExprs(depth, direct -> outerRefs.add(new OuterRef(direct)));\n+        } else if (type.tsym != methodClass.sym && type.tsym.isEnclosedBy(methodClass.sym)) {\n+            refs.mapInto(outerRefs, ThisRef.class, OuterRef::new);\n+        }\n+        return outerRefs;\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Codey Bits\n+\/\/\n+\n+    @Override\n+    public void visitBlock(JCBlock tree) {\n+        visitScoped(false, () -> super.visitBlock(tree));\n+        Assert.check(checkInvariants(true, false));\n+    }\n+\n+    @Override\n+    public void visitDoLoop(JCDoWhileLoop tree) {\n+        visitLooped(tree, super::visitDoLoop);\n+    }\n+\n+    @Override\n+    public void visitWhileLoop(JCWhileLoop tree) {\n+        visitLooped(tree, super::visitWhileLoop);\n+    }\n+\n+    @Override\n+    public void visitForLoop(JCForLoop tree) {\n+        visitLooped(tree, super::visitForLoop);\n+    }\n+\n+    @Override\n+    public void visitForeachLoop(JCEnhancedForLoop tree) {\n+        visitLooped(tree, super::visitForeachLoop);\n+    }\n+\n+    @Override\n+    public void visitSwitch(JCSwitch tree) {\n+        visitScoped(false, () -> {\n+            scan(tree.selector);\n+            refs.discardExprs(depth);\n+            scan(tree.cases);\n+        });\n+    }\n+\n+    @Override\n+    public void visitSwitchExpression(JCSwitchExpression tree) {\n+        visitScoped(true, () -> {\n+            scan(tree.selector);\n+            refs.discardExprs(depth);\n+            RefSet<ExprRef> combinedRefs = new RefSet<>();\n+            for (List<JCCase> cases = tree.cases; cases.nonEmpty(); cases = cases.tail) {\n+                scan(cases.head.stats);\n+                refs.replace(YieldRef.class, direct -> new ExprRef(depth, direct));\n+                combinedRefs.addAll(refs.removeExprs(depth));\n+            }\n+            refs.addAll(combinedRefs);\n+        });\n+    }\n+\n+    @Override\n+    public void visitCase(JCCase tree) {\n+        scan(tree.stats);          \/\/ no need to scan labels\n+    }\n+\n+    @Override\n+    public void visitYield(JCYield tree) {\n+        scan(tree.value);\n+        refs.replaceExprs(depth, YieldRef::new);\n+    }\n+\n+    @Override\n+    public void visitLetExpr(LetExpr tree) {\n+        visitScoped(true, () -> super.visitLetExpr(tree));\n+    }\n+\n+    @Override\n+    public void visitReturn(JCReturn tree) {\n+        scan(tree.expr);\n+        refs.replaceExprs(depth, ReturnRef::new);\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda lambda) {\n+        visitDeferred(() -> visitScoped(false, () -> super.visitLambda(lambda)));\n+    }\n+\n+    @Override\n+    public void visitAssign(JCAssign tree) {\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n+        if (isParamOrVar(sym))\n+            refs.replaceExprs(depth, direct -> new VarRef(sym, direct));\n+        else\n+            refs.discardExprs(depth);         \/\/ we don't track fields yet\n+    }\n+\n+    @Override\n+    public void visitIndexed(JCArrayAccess tree) {\n+        scan(tree.indexed);\n+        refs.remove(ExprRef.direct(depth));\n+        boolean indirectRef = refs.remove(ExprRef.indirect(depth));\n+        scan(tree.index);\n+        refs.discardExprs(depth);\n+        if (indirectRef) {\n+            refs.add(ExprRef.direct(depth));\n+            refs.add(ExprRef.indirect(depth));\n+        }\n+    }\n+\n+    @Override\n+    public void visitSelect(JCFieldAccess tree) {\n+\n+        \/\/ Scan the selected thing\n+        scan(tree.selected);\n+        boolean selectedDirectRef = refs.remove(ExprRef.direct(depth));\n+        boolean selectedIndirectRef = refs.remove(ExprRef.indirect(depth));\n+\n+        \/\/ Explicit 'this' reference?\n+        Type.ClassType currentClassType = (Type.ClassType)methodClass.sym.type;\n+        if (isExplicitThisReference(types, currentClassType, tree)) {\n+            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+            return;\n+        }\n+\n+        \/\/ Explicit outer 'this' reference?\n+        Type selectedType = types.erasure(tree.selected.type);\n+        if (selectedType.hasTag(CLASS)) {\n+            ClassSymbol currentClassSym = (ClassSymbol)currentClassType.tsym;\n+            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n+            if (tree.name == names._this &&\n+                    selectedTypeSym != currentClassSym &&\n+                    currentClassSym.isEnclosedBy(selectedTypeSym)) {\n+                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n+                return;\n+            }\n+        }\n+\n+        \/\/ Methods - the \"value\" of a non-static method is a reference to its instance\n+        Symbol sym = tree.sym;\n+        if (sym.kind == MTH) {\n+            if ((sym.flags() & Flags.STATIC) == 0) {\n+                if (selectedDirectRef)\n+                    refs.add(ExprRef.direct(depth));\n+                if (selectedIndirectRef)\n+                    refs.add(ExprRef.indirect(depth));\n+            }\n+            return;\n+        }\n+\n+        \/\/ Unknown\n+        return;\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+\n+        \/\/ Scan target expression and extract 'this' references, if any\n+        scan(tree.expr);\n+        boolean direct = refs.remove(ExprRef.direct(depth));\n+        boolean indirect = refs.remove(ExprRef.indirect(depth));\n+\n+        \/\/ Gather receiver references for deferred invocation\n+        RefSet<Ref> receiverRefs = RefSet.newEmpty();\n+        switch (tree.kind) {\n+        case UNBOUND:\n+        case STATIC:\n+        case TOPLEVEL:\n+        case ARRAY_CTOR:\n+            return;\n+        case SUPER:\n+            refs.mapInto(receiverRefs, ThisRef.class, ThisRef::new);\n+            break;\n+        case BOUND:\n+            if (direct)\n+                receiverRefs.add(ThisRef.direct());\n+            if (indirect)\n+                receiverRefs.add(ThisRef.indirect());\n+            break;\n+        case IMPLICIT_INNER:\n+            receiverRefs.addAll(outerThisRefs(null, tree.expr.type));\n+            break;\n+        default:\n+            throw new RuntimeException(\"non-exhaustive?\");\n+        }\n+\n+        \/\/ Treat method reference just like the equivalent lambda\n+        visitDeferred(() -> invoke(tree, (MethodSymbol)tree.sym, List.nil(), receiverRefs));\n+    }\n+\n+    @Override\n+    public void visitIdent(JCIdent tree) {\n+\n+        \/\/ Reference to this?\n+        if (tree.name == names._this || tree.name == names._super) {\n+            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+            return;\n+        }\n+\n+        \/\/ Parameter or local variable?\n+        if (isParamOrVar(tree.sym)) {\n+            VarSymbol sym = (VarSymbol)tree.sym;\n+            if (refs.contains(VarRef.direct(sym)))\n+                refs.add(ExprRef.direct(depth));\n+            if (refs.contains(VarRef.indirect(sym)))\n+                refs.add(ExprRef.indirect(depth));\n+            return;\n+        }\n+\n+        \/\/ An unqualified, non-static method invocation must reference 'this' or outer 'this'.\n+        \/\/ The \"value\" of a non-static method is a reference to its instance.\n+        if (tree.sym.kind == MTH && (tree.sym.flags() & Flags.STATIC) == 0) {\n+            MethodSymbol sym = (MethodSymbol)tree.sym;\n+\n+            \/\/ Check for implicit 'this' reference\n+            ClassSymbol methodClassSym = methodClass.sym;\n+            if (methodClassSym.isSubClass(sym.owner, types)) {\n+                refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+                return;\n+            }\n+\n+            \/\/ Check for implicit outer 'this' reference\n+            if (methodClassSym.isEnclosedBy((ClassSymbol)sym.owner)) {\n+                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n+                return;\n+            }\n+\n+            \/\/ What could it be?\n+            \/\/Assert.check(false);\n+            return;\n+        }\n+\n+        \/\/ Unknown\n+        return;\n+    }\n+\n+    @Override\n+    public void visitSynchronized(JCSynchronized tree) {\n+        scan(tree.lock);\n+        refs.discardExprs(depth);\n+        scan(tree.body);\n+    }\n+\n+    @Override\n+    public void visitConditional(JCConditional tree) {\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n+        RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        scan(tree.truepart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        scan(tree.falsepart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.addAll(combinedRefs);\n+    }\n+\n+    @Override\n+    public void visitIf(JCIf tree) {\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n+        scan(tree.thenpart);\n+        scan(tree.elsepart);\n+    }\n+\n+    @Override\n+    public void visitExec(JCExpressionStatement tree) {\n+        scan(tree.expr);\n+        refs.discardExprs(depth);\n+    }\n+\n+    @Override\n+    public void visitThrow(JCThrow tree) {\n+        scan(tree.expr);\n+        if (refs.discardExprs(depth))     \/\/ we don't try to \"catch\" refs from thrown exceptions\n+            leakAt(tree);\n+    }\n+\n+    @Override\n+    public void visitAssert(JCAssert tree) {\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n+        scan(tree.detail);\n+        refs.discardExprs(depth);\n+    }\n+\n+    @Override\n+    public void visitNewArray(JCNewArray tree) {\n+        boolean ref = false;\n+        if (tree.elems != null) {\n+            for (List<JCExpression> elems = tree.elems; elems.nonEmpty(); elems = elems.tail) {\n+                scan(elems.head);\n+                ref |= refs.discardExprs(depth);\n+            }\n+        }\n+        if (ref)\n+            refs.add(ExprRef.indirect(depth));\n+    }\n+\n+    @Override\n+    public void visitTypeCast(JCTypeCast tree) {\n+        scan(tree.expr);\n+    }\n+\n+    @Override\n+    public void visitConstantCaseLabel(JCConstantCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitPatternCaseLabel(JCPatternCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+    }\n+\n+    @Override\n+    public void visitRecordPattern(JCRecordPattern that) {\n+    }\n+\n+    @Override\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        scan(tree.expr);\n+        refs.discardExprs(depth);\n+    }\n+\n+    @Override\n+    public void visitTypeArray(JCArrayTypeTree tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeApply(JCTypeApply tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeUnion(JCTypeUnion tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeIntersection(JCTypeIntersection tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeParameter(JCTypeParameter tree) {\n+    }\n+\n+    @Override\n+    public void visitWildcard(JCWildcard tree) {\n+    }\n+\n+    @Override\n+    public void visitTypeBoundKind(TypeBoundKind that) {\n+    }\n+\n+    @Override\n+    public void visitModifiers(JCModifiers tree) {\n+    }\n+\n+    @Override\n+    public void visitAnnotation(JCAnnotation tree) {\n+    }\n+\n+    @Override\n+    public void visitAnnotatedType(JCAnnotatedType tree) {\n+    }\n+\n+\/\/\n+\/\/ Visitor methods - Non-Reference Stuff\n+\/\/\n+\n+    @Override\n+    public void visitAssignop(JCAssignOp tree) {\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        refs.discardExprs(depth);\n+    }\n+\n+    @Override\n+    public void visitUnary(JCUnary tree) {\n+        scan(tree.arg);\n+        refs.discardExprs(depth);\n+    }\n+\n+    @Override\n+    public void visitBinary(JCBinary tree) {\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        refs.discardExprs(depth);\n+    }\n+\n+\/\/ Helper methods\n+\n+    private void visitTopLevel(JCClassDecl klass, Runnable action) {\n+        Assert.check(targetClass == null);\n+        Assert.check(methodClass == null);\n+        Assert.check(depth == -1);\n+        Assert.check(refs == null);\n+        targetClass = klass;\n+        methodClass = klass;\n+        try {\n+\n+            \/\/ Add the initial 'this' reference\n+            refs = RefSet.newEmpty();\n+            refs.add(ThisRef.direct());\n+\n+            \/\/ Perform action\n+            this.visitScoped(false, action);\n+        } finally {\n+            Assert.check(depth == -1);\n+            methodClass = null;\n+            targetClass = null;\n+            refs = null;\n+        }\n+    }\n+\n+    \/\/ Recurse through indirect code that might get executed later, e.g., a lambda.\n+    \/\/ We stash any pending warning and the current RefSet, then recurse into the deferred\n+    \/\/ code (still using the current RefSet) to see if it would leak. Then we restore the\n+    \/\/ pending warning and the current RefSet. Finally, if the deferred code would have\n+    \/\/ leaked, we create an indirect ExprRef because it must be holding a 'this' reference.\n+    \/\/ If the deferred code would not leak, then obviously no leak is possible, period.\n+    private <T extends JCTree> void visitDeferred(Runnable recurse) {\n+        DiagnosticPosition[] pendingWarningPrev = pendingWarning;\n+        pendingWarning = null;\n+        RefSet<Ref> refsPrev = refs.clone();\n+        boolean deferredCodeLeaks;\n+        try {\n+            recurse.run();\n+            deferredCodeLeaks = pendingWarning != null;\n+        } finally {\n+            refs = refsPrev;\n+            pendingWarning = pendingWarningPrev;\n+        }\n+        if (deferredCodeLeaks)\n+            refs.add(ExprRef.indirect(depth));\n+    }\n+\n+    \/\/ Repeat loop as needed until the current set of references converges\n+    private <T extends JCTree> void visitLooped(T tree, Consumer<T> visitor) {\n+        visitScoped(false, () -> {\n+            while (true) {\n+                RefSet<Ref> prevRefs = refs.clone();\n+                visitor.accept(tree);\n+                if (refs.equals(prevRefs))\n+                    break;\n+            }\n+        });\n+    }\n+\n+    \/\/ Perform the given action within a new scope\n+    private void visitScoped(boolean promote, Runnable action) {\n+        pushScope();\n+        try {\n+\n+            \/\/ Perform action\n+            Assert.check(checkInvariants(true, false));\n+            action.run();\n+            Assert.check(checkInvariants(true, promote));\n+\n+            \/\/ \"Promote\" ExprRef's to the enclosing lexical scope, if requested\n+            if (promote) {\n+                Assert.check(depth > 0);\n+                refs.removeExprs(depth, direct -> refs.add(new ExprRef(depth - 1, direct)));\n+            }\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private void pushScope() {\n+        depth++;\n+    }\n+\n+    private void popScope() {\n+        Assert.check(depth >= 0);\n+        depth--;\n+        refs.removeIf(ref -> ref.getDepth() > depth);\n+    }\n+\n+    \/\/ Note a possible 'this' reference leak at the specified location\n+    private void leakAt(JCTree tree) {\n+\n+        \/\/ Generate at most one warning per statement\n+        if (pendingWarning != null)\n+            return;\n+\n+        \/\/ Snapshot the current stack trace\n+        callStack.push(tree.pos());\n+        pendingWarning = callStack.toArray(new DiagnosticPosition[0]);\n+        callStack.pop();\n+    }\n+\n+    \/\/ Copy pending warning, if any, to the warning list and reset\n+    private boolean copyPendingWarning() {\n+        if (pendingWarning == null)\n+            return false;\n+        warningList.add(pendingWarning);\n+        pendingWarning = null;\n+        return true;\n+    }\n+\n+    \/\/ Does the symbol correspond to a parameter or local variable (not a field)?\n+    private boolean isParamOrVar(Symbol sym) {\n+        return sym != null &&\n+            sym.kind == VAR &&\n+            (sym.owner.kind == MTH || sym.owner.kind == VAR);\n+    }\n+\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n+            case IDENT:\n+            {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this;\n+            }\n+            case SELECT:\n+            {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(CLASS))\n+                    return false;\n+                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this &&\n+                            (currentClassSym == selectedClassSym ||\n+                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    \/\/ When scanning nodes we can be in one of two modes:\n+    \/\/  (a) Looking for constructors - we do not recurse into any code blocks\n+    \/\/  (b) Analyzing a constructor - we are tracing its possible execution paths\n+    private boolean isAnalyzing() {\n+        return targetClass != null;\n+    }\n+\n+\/\/ Debugging\n+\n+    \/\/ Invariant checks\n+    private boolean checkInvariants(boolean analyzing, boolean allowExpr) {\n+        Assert.check(analyzing == isAnalyzing());\n+        if (isAnalyzing()) {\n+            Assert.check(methodClass != null);\n+            Assert.check(targetClass != null);\n+            Assert.check(refs != null);\n+            Assert.check(depth >= 0);\n+            Assert.check(refs.stream().noneMatch(ref -> ref.getDepth() > depth));\n+            Assert.check(allowExpr || !refs.contains(ExprRef.direct(depth)));\n+            Assert.check(allowExpr || !refs.contains(ExprRef.indirect(depth)));\n+        } else {\n+            Assert.check(targetClass == null);\n+            Assert.check(refs == null);\n+            Assert.check(depth == -1);\n+            Assert.check(callStack.isEmpty());\n+            Assert.check(pendingWarning == null);\n+            Assert.check(invocations.isEmpty());\n+        }\n+        return true;\n+    }\n+\n+\/\/ Ref's\n+\n+    \/** Represents a location that could possibly hold a 'this' reference.\n+     *\n+     *  <p>\n+     *  If not \"direct\", the reference is found through at least one indirection.\n+     *\/\n+    private abstract static class Ref {\n+\n+        private final int depth;\n+        private final boolean direct;\n+\n+        Ref(int depth, boolean direct) {\n+            this.depth = depth;\n+            this.direct = direct;\n+        }\n+\n+        public int getDepth() {\n+            return depth;\n+        }\n+\n+        public boolean isDirect() {\n+            return direct;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return getClass().hashCode()\n+                ^ Integer.hashCode(depth)\n+                ^ Boolean.hashCode(direct);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (obj == null || obj.getClass() != getClass())\n+                return false;\n+            Ref that = (Ref)obj;\n+            return depth == that.depth\n+              && direct == that.direct;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            ArrayList<String> properties = new ArrayList<>();\n+            addProperties(properties);\n+            return getClass().getSimpleName()\n+              + \"[\" + properties.stream().collect(Collectors.joining(\",\")) + \"]\";\n+        }\n+\n+        protected void addProperties(ArrayList<String> properties) {\n+            properties.add(\"depth=\" + depth);\n+            properties.add(direct ? \"direct\" : \"indirect\");\n+        }\n+    }\n+\n+    \/** A reference from the current 'this' instance.\n+     *\/\n+    private static class ThisRef extends Ref {\n+\n+        ThisRef(boolean direct) {\n+            super(0, direct);\n+        }\n+\n+        public static ThisRef direct() {\n+            return new ThisRef(true);\n+        }\n+\n+        public static ThisRef indirect() {\n+            return new ThisRef(false);\n+        }\n+    }\n+\n+    \/** A reference from the current outer 'this' instance.\n+     *\/\n+    private static class OuterRef extends Ref {\n+\n+        OuterRef(boolean direct) {\n+            super(0, direct);\n+        }\n+    }\n+\n+    \/** A reference from the expression that was just evaluated.\n+     *  In other words, a reference that's sitting on top of the stack.\n+     *\/\n+    private static class ExprRef extends Ref {\n+\n+        ExprRef(int depth, boolean direct) {\n+            super(depth, direct);\n+        }\n+\n+        public static ExprRef direct(int depth) {\n+            return new ExprRef(depth, true);\n+        }\n+\n+        public static ExprRef indirect(int depth) {\n+            return new ExprRef(depth, false);\n+        }\n+    }\n+\n+    \/** A reference from the return value of the current method being \"invoked\".\n+     *\/\n+    private static class ReturnRef extends Ref {\n+\n+        ReturnRef(boolean direct) {\n+            super(0, direct);\n+        }\n+    }\n+\n+    \/** A reference from the yield value of the current switch expression.\n+     *\/\n+    private static class YieldRef extends Ref {\n+\n+        YieldRef(boolean direct) {\n+            super(0, direct);\n+        }\n+    }\n+\n+    \/** A reference from a variable.\n+     *\/\n+    private static class VarRef extends Ref {\n+\n+        private final VarSymbol sym;\n+\n+        VarRef(VarSymbol sym, boolean direct) {\n+            super(0, direct);\n+            this.sym = sym;\n+        }\n+\n+        public VarSymbol getSymbol() {\n+            return sym;\n+        }\n+\n+        public static VarRef direct(VarSymbol sym) {\n+            return new VarRef(sym, true);\n+        }\n+\n+        public static VarRef indirect(VarSymbol sym) {\n+            return new VarRef(sym, false);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode()\n+                ^ Objects.hashCode(sym);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!super.equals(obj))\n+                return false;\n+            VarRef that = (VarRef)obj;\n+            return Objects.equals(sym, that.sym);\n+        }\n+\n+        @Override\n+        protected void addProperties(ArrayList<String> properties) {\n+            super.addProperties(properties);\n+            properties.add(\"sym=\" + sym);\n+        }\n+    }\n+\n+\/\/ RefSet\n+\n+    \/** Contains locations currently known to hold a possible 'this' reference.\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    private static class RefSet<T extends Ref> extends HashSet<T> {\n+\n+        public static <T extends Ref> RefSet<T> newEmpty() {\n+            return new RefSet<>();\n+        }\n+\n+        \/**\n+         * Discard any {@link ExprRef}'s at the specified depth.\n+         * Do this when discarding whatever is on top of the stack.\n+         *\/\n+        public boolean discardExprs(int depth) {\n+            return remove(ExprRef.direct(depth)) | remove(ExprRef.indirect(depth));\n+        }\n+\n+        \/**\n+         * Extract any {@link ExprRef}'s at the specified depth.\n+         *\/\n+        public RefSet<ExprRef> removeExprs(int depth) {\n+            return Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n+              .filter(this::remove)\n+              .collect(Collectors.toCollection(RefSet::new));\n+        }\n+\n+        \/**\n+         * Extract any {@link ExprRef}'s at the specified depth and do something with them.\n+         *\/\n+        public void removeExprs(int depth, Consumer<? super Boolean> handler) {\n+            Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n+              .filter(this::remove)\n+              .map(ExprRef::isDirect)\n+              .forEach(handler);\n+        }\n+\n+        \/**\n+         * Replace any references of the given type.\n+         *\/\n+        public void replace(Class<? extends Ref> type, Function<Boolean, ? extends T> mapper) {\n+            final List<Ref> oldRefs = this.stream()\n+              .filter(type::isInstance)\n+              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n+            this.removeAll(oldRefs);\n+            oldRefs.stream()\n+              .map(Ref::isDirect)\n+              .map(mapper)\n+              .forEach(this::add);\n+        }\n+\n+        \/**\n+         * Replace any {@link ExprRef}'s at the specified depth.\n+         *\/\n+        public void replaceExprs(int depth, Function<Boolean, ? extends T> mapper) {\n+            removeExprs(depth, direct -> add(mapper.apply(direct)));\n+        }\n+\n+        \/**\n+         * Find references of the given type, map them, and add them to {@code dest}.\n+         *\/\n+        public <S extends Ref> void mapInto(RefSet<S> dest, Class<? extends Ref> type,\n+                Function<Boolean, ? extends S> mapper) {\n+            final List<S> newRefs = this.stream()\n+              .filter(type::isInstance)\n+              .map(Ref::isDirect)\n+              .map(mapper)\n+              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n+            dest.addAll(newRefs);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public RefSet<T> clone() {\n+            return (RefSet<T>)super.clone();\n+        }\n+    }\n+\n+\/\/ MethodInfo\n+\n+    \/\/ Information about a constructor or method in the compilation unit\n+    private record MethodInfo(\n+        JCClassDecl declaringClass,     \/\/ the class declaring \"declaration\"\n+        JCMethodDecl declaration,       \/\/ the method or constructor itself\n+        boolean analyzable,             \/\/ it's a constructor that we should analyze\n+        boolean invokable) {            \/\/ it may be safely \"invoked\" during analysis\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1468,"deletions":0,"binary":false,"changes":1468,"status":"added"},{"patch":"@@ -656,0 +656,6 @@\n+compiler.warn.possible.this.escape=\\\n+    possible ''this'' escape before subclass is fully initialized\n+\n+compiler.warn.possible.this.escape.location=\\\n+    previous possible ''this'' escape happens here via invocation\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+javac.opt.Xlint.desc.this-escape=\\\n+    Warn when a constructor invokes a method that could be overriden in an external subclass.\\n\\\n+\\                         Such a method would execute before the subclass constructor completes its initialization.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+ * <tr><th scope=\"row\">{@code this-escape}          <td>superclass constructor leaking {@code this} before subclass initialized\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -775,0 +775,3 @@\n+\\f[V]this-escape\\f[R]: Warns about superclass constructors leaking\n+\\f[V]this\\f[R] prior to subclass initialization.\n+.IP \\[bu] 2\n@@ -2212,0 +2215,41 @@\n+\\f[V]this\\-escape\\f[R]\n+Warns about superclass constructors leaking \\f[V]this\\f[R] prior\n+to subclass initialization.\n+For example:\n+.RS\n+.IP\n+.nf\n+\\f[CB]\n+public class MyClass {\n+\n+   public MyClass() {\n+       System.out.println(\"Hash = \" + this.hashCode());\n+   }\n+}\n+\\f[R]\n+.fi\n+.PP\n+The compiler generates the following warning:\n+.IP\n+.nf\n+\\f[CB]\n+MyClass.java:4: warning: [this-escape] possible 'this' escape\n+                         before subclass is fully initialized\n+     System.out.println(\"Hash = \" + this.hashCode());\n+                                                 ^\n+\\f[R]\n+.fi\n+.PP\n+Because calls to \\f[V]super()\\f[R] must precede other initialization,\n+subclass fields are unintialized when the superclass constructor executes.\n+If the superclass constructor uses the instance in a way that could\n+possibly result a subclass method being invoked, that method would be\n+operating on a partially initialized instance. In the above example,\n+a subclass that overrides \\f[V]hashCode()\\f[R] in order to incorporate\n+some of its own fields would generate an incorrect result.\n+.PP\n+Warnings are only generated when a potential subclass could exist\n+outside of the current source file being compiled.\n+For example, final and private classes never generate warnings.\n+.RE\n+.TP\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.possible.this.escape\n+\/\/ key: compiler.warn.possible.this.escape.location\n+\/\/ options: -Xlint:this-escape\n+\n+public class ThisEscape {\n+\n+    public ThisEscape() {\n+        this.method();\n+    }\n+\n+    public final void method() {\n+        this.hashCode();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ThisEscape.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscape.out -Xlint:this-escape -XDrawDiagnostics ThisEscape.java\n+ * @summary Verify 'this' escape detection\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ThisEscape {\n+\n+    \/\/ Verify 'this' escape detection can follow references embedded as array elements\n+    public static class ThisEscapeArrayElement {\n+\n+        public ThisEscapeArrayElement() {\n+            final Object[][] array = new Object[][] { { this } };\n+            ((ThisEscapeArrayElement)array[0][0]).mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify basic 'this' escape detection\n+    public static class ThisEscapeBasic {\n+\n+        public ThisEscapeBasic() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection can follow references through various Java code structures\n+    public static class ThisEscapeComplex {\n+\n+        public ThisEscapeComplex() {\n+            this.method1().mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        private ThisEscapeComplex method1() {\n+            while (true) {\n+                do {\n+                    for (ThisEscapeComplex x = this.method2(); new Object().hashCode() < 10; ) {\n+                        for (int y : new int[] { 123, 456 }) {\n+                            return x;\n+                        }\n+                    }\n+                } while (true);\n+            }\n+        }\n+\n+        private ThisEscapeComplex method2() {\n+            switch (new Object().hashCode()) {\n+            case 1:\n+            case 2:\n+            case 3:\n+                return null;\n+            default:\n+                return this.method3();\n+            }\n+        }\n+\n+        private ThisEscapeComplex method3() {\n+            return switch (new Object().hashCode()) {\n+                case 1, 2, 3 -> this.method4();\n+                default -> null;\n+            };\n+        }\n+\n+        private ThisEscapeComplex method4() {\n+            return ThisEscapeComplex.this.method5();\n+        }\n+\n+        private ThisEscapeComplex method5() {\n+            final ThisEscapeComplex foo = this.method6();\n+            return foo;\n+        }\n+\n+        private ThisEscapeComplex method6() {\n+            synchronized (new Object()) {\n+                return this.method7();\n+            }\n+        }\n+\n+        private ThisEscapeComplex method7() {\n+            ThisEscapeComplex x = null;\n+            ThisEscapeComplex y = this.method8();\n+            if (new Object().hashCode() == 3)\n+                return x;\n+            else\n+                return y;\n+        }\n+\n+        private ThisEscapeComplex method8() {\n+            return (ThisEscapeComplex)(Object)this.method9();\n+        }\n+\n+        private ThisEscapeComplex method9() {\n+            return new Object().hashCode() == 3 ? this : null;\n+        }\n+    }\n+\n+    \/\/ Verify pruning of 'this' escape warnings for various constructors\n+    public static class ThisEscapeCtors {\n+\n+        \/\/ This constructor should NOT generate a warning because it would be a\n+        \/\/ duplicate of the warning already generated for ThisEscapeCtors(short).\n+        public ThisEscapeCtors(char x) {\n+            this((short)x);\n+        }\n+\n+        \/\/ This constructor should generate a warning because it invokes leaky this()\n+        \/\/ and is accessible to subclasses.\n+        public ThisEscapeCtors(short x) {\n+            this();\n+        }\n+\n+        \/\/ This constructor should generate a warning because it invokes leaky this()\n+        \/\/ and is accessible to subclasses.\n+        public ThisEscapeCtors(int x) {\n+            this();\n+        }\n+\n+        \/\/ This constructor should NOT generate a warning because it is not accessbile\n+        \/\/ to subclasses. However, other constructors do invoke it, and that should cause\n+        \/\/ them to generate an indirect warning.\n+        private ThisEscapeCtors() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection in field initializers\n+    public static class ThisEscapeFields {\n+\n+        private final int field1 = this.mightLeak1();\n+\n+        private final int field2 = this.mightLeak2();\n+\n+        public int mightLeak1() {\n+            return 123;\n+        }\n+\n+        public int mightLeak2() {\n+            return 456;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles lambdas\n+    public static class ThisEscapeLambda {\n+\n+        public ThisEscapeLambda() {\n+            Runnable r = () -> {\n+                this.mightLeak();\n+            };\n+            System.out.println(r);\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles loop convergence\n+    public static class ThisEscapeLoop {\n+\n+        public ThisEscapeLoop() {\n+            ThisEscapeLoop ref1 = this;\n+            ThisEscapeLoop ref2 = null;\n+            ThisEscapeLoop ref3 = null;\n+            ThisEscapeLoop ref4 = null;\n+            for (int i = 0; i < 100; i++) {\n+                ref4 = ref3;\n+                ref3 = ref2;\n+                ref2 = ref1;\n+                if (ref4 != null)\n+                    ref4.mightLeak();\n+            }\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via outer 'this'\n+    public static class ThisEscapeOuterThis {\n+\n+        public ThisEscapeOuterThis() {\n+            new InnerClass();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        public class InnerClass {\n+\n+            InnerClass() {\n+                ThisEscapeOuterThis.this.mightLeak();\n+            }\n+        }\n+\n+        \/\/ No leak here because class 'Local' cannot be externally extended\n+        public static void method1() {\n+            class Local {\n+                Local() {\n+                    this.wontLeak();\n+                }\n+                void wontLeak() {\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via passing 'this' as a parameter\n+    public static class ThisEscapeParameter {\n+\n+        public ThisEscapeParameter() {\n+            ThisEscapeParameter.method(this);\n+        }\n+\n+        public static void method(Object obj) {\n+            obj.hashCode();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles leaks via recursive methods\n+    public static class ThisEscapeRecursion {\n+\n+        public ThisEscapeRecursion() {\n+            this.noLeak(0);         \/\/ no leak here\n+            this.mightLeak();       \/\/ possible leak here\n+        }\n+\n+        public final void noLeak(int depth) {\n+            if (depth < 10)\n+                this.noLeak(depth - 1);\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify proper handling of 'this' escape warnings from method references\n+    public static class ThisEscapeReference {\n+\n+    \/\/ Test 1 - ReferenceKind.SUPER\n+\n+        public static class Test1 {\n+            public void mightLeak() {\n+            }\n+        }\n+\n+        public static class Test1b extends Test1 {\n+            public Test1b() {\n+                new Thread(super::mightLeak);   \/\/ this is a leak\n+            }\n+        }\n+\n+        public static class Test1c extends Test1 {\n+            public Test1c() {\n+                new Thread(super::notify);      \/\/ this is not a leak\n+            }\n+        }\n+\n+    \/\/ Test 2 - ReferenceKind.BOUND\n+\n+        public static class Test2 {\n+\n+            public Test2() {\n+                new Thread(this::mightLeak);    \/\/ this is a leak\n+            }\n+\n+            public Test2(int x) {\n+                final Test2 foo = new Test2();\n+                new Thread(foo::mightLeak);     \/\/ this is not a leak\n+            }\n+\n+            public Test2(char x) {\n+                new Thread(this::noLeak);       \/\/ this is not a leak\n+            }\n+\n+            public void mightLeak() {\n+            }\n+\n+            private void noLeak() {\n+            }\n+        }\n+\n+    \/\/ Test 3 - ReferenceKind.IMPLICIT_INNER\n+\n+        public static class Test3 {\n+\n+            public Test3() {\n+                new Thread(Inner1::new);        \/\/ this is a leak\n+            }\n+\n+            public Test3(int x) {\n+                new Thread(Inner2::new);        \/\/ this is not a leak\n+            }\n+\n+            public void mightLeak() {\n+            }\n+\n+            public class Inner1 {\n+                public Inner1() {\n+                    Test3.this.mightLeak();\n+                }\n+            }\n+\n+            public class Inner2 {\n+                public Inner2() {\n+                    new Test3().mightLeak();\n+                }\n+            }\n+        }\n+\n+    \/\/ Test 4 - ReferenceKind.UNBOUND, STATIC, TOPLEVEL, ARRAY_CTOR\n+\n+        public static class Test4 {\n+\n+            \/\/ ReferenceKind.UNBOUND\n+            public Test4() {\n+                Test4.bar(Test4::sameHashCode);\n+            }\n+\n+            \/\/ ReferenceKind.STATIC\n+            public Test4(int x) {\n+                new Thread(Test4::noLeak);      \/\/ this is not a leak\n+            }\n+\n+            \/\/ ReferenceKind.ARRAY_CTOR\n+            public Test4(char x) {\n+                Test4.foo(String[]::new);       \/\/ this is not a leak\n+            }\n+\n+            \/\/ ReferenceKind.TOPLEVEL\n+            public Test4(short x) {\n+                Test4.foo(Test4::new);          \/\/ this is not a leak\n+            }\n+\n+            public static void noLeak() {\n+            }\n+\n+            public static void foo(IntFunction<?> x) {\n+                x.hashCode();\n+            }\n+\n+            public static void bar(BiPredicate<Test4, Object> x) {\n+                x.hashCode();\n+            }\n+\n+            public boolean sameHashCode(Object obj) {\n+                return obj.hashCode() == this.hashCode();\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection properly handles leaks via method return values\n+    public static class ThisEscapeReturnValue {\n+\n+        public ThisEscapeReturnValue() {\n+            final Object rval = ThisEscapeReturnValue.method(this);\n+            ((ThisEscapeReturnValue)rval).mightLeak();\n+        }\n+\n+        public static Object method(Object obj) {\n+            return obj;\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection from a thrown 'this'\n+    public static class ThisEscapeThrown extends RuntimeException {\n+\n+        public ThisEscapeThrown(Object obj) {\n+            if (obj == null)\n+                throw this;\n+        }\n+    }\n+\n+    \/\/ Verify proper 'this' escape interpretation of unqualified non-static method invocations\n+    public static class ThisEscapeUnqualified {\n+\n+        \/\/ This class has a leak\n+        public static class Example1 {\n+\n+            public Example1() {\n+                new Inner();\n+            }\n+\n+            public final class Inner {\n+                public Inner() {\n+                    mightLeak();    \/\/ refers to Example1.mightLeak()\n+                }\n+            }\n+\n+            public void mightLeak() {\n+            }\n+        }\n+\n+        \/\/ This class does NOT have a leak\n+        public static class Example2 {\n+\n+            public Example2() {\n+                new Inner();\n+            }\n+\n+            public final class Inner {\n+                public Inner() {\n+                    mightLeak();    \/\/ refers to Inner.mightLeak()\n+                }\n+\n+                public void mightLeak() {\n+                }\n+            }\n+\n+            public void mightLeak() {\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection handles leaks via switch expression yields\n+    public static class ThisEscapeYield {\n+\n+        public ThisEscapeYield(int x) {\n+            ThisEscapeYield y = switch (x) {\n+                case 3:\n+                    if (x > 17)\n+                        yield this;\n+                    else\n+                        yield null;\n+                default:\n+                    yield null;\n+            };\n+            if (y != null)\n+                y.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on constructors\n+    public static class ThisEscapeSuppressCtor {\n+\n+        private final int x = this.mightLeak();\n+\n+        @SuppressWarnings(\"this-escape\")\n+        public ThisEscapeSuppressCtor() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on fields\n+    public static class ThisEscapeSuppressField {\n+\n+        @SuppressWarnings(\"this-escape\")\n+        private final int x = this.mightLeak();\n+\n+        public ThisEscapeSuppressField() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape warnings can be properly suppressed on classes\n+    public static class ThisEscapeSuppressClass {\n+\n+        @SuppressWarnings(\"this-escape\")\n+        private final int x = this.mightLeak();\n+\n+        @SuppressWarnings(\"this-escape\")\n+        public ThisEscapeSuppressClass() {\n+            this.mightLeak();\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection doesn't generate certain false positives\n+    public static class ThisEscapeNoEscapes {\n+\n+        public ThisEscapeNoEscapes() {\n+            this.noLeak1();                             \/\/ invoked method is private\n+            this.noLeak2();                             \/\/ invoked method is final\n+            ThisEscapeNoEscapes.noLeak3();              \/\/ invoked method is static\n+            this.noLeak4(this);                         \/\/ parameter is 'this' but it's not leaked\n+            this.noLeak5(new ThisEscapeNoEscapes(0));   \/\/ parameter is not 'this', so no leak\n+            this.noLeak6(null, this, null);             \/\/ method leaks 1st and 3rd parameters only\n+            this.noLeak7();                             \/\/ method does complicated stuff but doesn't leak\n+            Runnable r1 = () -> {                       \/\/ lambda does not leak 'this'\n+                if (System.out == System.err)\n+                    throw new RuntimeException();\n+            };\n+            System.out.println(r1);                     \/\/ lambda does not leak 'this'\n+            Runnable r2 = () -> {                       \/\/ lambda leaks 'this' but is never used\n+                this.mightLeak1();\n+            };\n+            Runnable r3 = this::mightLeak1;             \/\/ reference leaks 'this' but is never used\n+        }\n+\n+        public ThisEscapeNoEscapes(int x) {\n+        }\n+\n+        public void mightLeak1() {\n+        }\n+\n+        private void noLeak1() {\n+        }\n+\n+        public final void noLeak2() {\n+        }\n+\n+        public static void noLeak3() {\n+        }\n+\n+        public static void noLeak4(ThisEscapeNoEscapes param) {\n+            param.noLeak1();\n+            param.noLeak2();\n+        }\n+\n+        public final void noLeak5(ThisEscapeNoEscapes param) {\n+            param.mightLeak1();\n+        }\n+\n+        public final void noLeak6(ThisEscapeNoEscapes param1,\n+            ThisEscapeNoEscapes param2, ThisEscapeNoEscapes param3) {\n+            if (param1 != null)\n+                param1.mightLeak1();\n+            if (param2 != null)\n+                param2.noLeak2();\n+            if (param3 != null)\n+                param3.mightLeak1();\n+        }\n+\n+        public final void noLeak7() {\n+            ((ThisEscapeNoEscapes)(Object)this).noLeak2();\n+            final ThisEscapeNoEscapes obj1 = switch (new Object().hashCode()) {\n+                case 1, 2, 3 -> null;\n+                default -> new ThisEscapeNoEscapes(0);\n+            };\n+            obj1.mightLeak1();\n+        }\n+\n+    \/\/ PrivateClass\n+\n+        private static class PrivateClass {\n+\n+            PrivateClass() {\n+                this.cantLeak();                    \/\/ method is inside a private class\n+            }\n+\n+            public void cantLeak() {\n+            }\n+        }\n+\n+    \/\/ FinalClass\n+\n+        public static final class FinalClass extends ThisEscapeNoEscapes {\n+\n+            public FinalClass() {\n+                this.mightLeak1();                  \/\/ class and therefore method is final\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            new ThisEscapeNoEscapes();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape detection doesn't warn for sealed classes with local permits\n+    public static sealed class ThisEscapeSealed permits ThisEscapeSealed.Sub1, ThisEscapeSealed.Sub2 {\n+\n+        public ThisEscapeSealed() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        public static final class Sub1 extends ThisEscapeSealed {\n+        }\n+\n+        public static final class Sub2 extends ThisEscapeSealed {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+ThisEscape.java:17:60: compiler.warn.possible.this.escape\n+ThisEscape.java:28:27: compiler.warn.possible.this.escape\n+ThisEscape.java:39:37: compiler.warn.possible.this.escape\n+ThisEscape.java:120:17: compiler.warn.possible.this.escape\n+ThisEscape.java:133:27: compiler.warn.possible.this.escape.location\n+ThisEscape.java:126:17: compiler.warn.possible.this.escape\n+ThisEscape.java:133:27: compiler.warn.possible.this.escape.location\n+ThisEscape.java:143:51: compiler.warn.possible.this.escape\n+ThisEscape.java:145:51: compiler.warn.possible.this.escape\n+ThisEscape.java:163:32: compiler.warn.possible.this.escape\n+ThisEscape.java:183:35: compiler.warn.possible.this.escape\n+ThisEscape.java:195:13: compiler.warn.possible.this.escape\n+ThisEscape.java:204:51: compiler.warn.possible.this.escape.location\n+ThisEscape.java:224:39: compiler.warn.possible.this.escape\n+ThisEscape.java:228:25: compiler.warn.possible.this.escape.location\n+ThisEscape.java:237:27: compiler.warn.possible.this.escape\n+ThisEscape.java:261:28: compiler.warn.possible.this.escape\n+ThisEscape.java:276:28: compiler.warn.possible.this.escape\n+ThisEscape.java:300:28: compiler.warn.possible.this.escape\n+ThisEscape.java:369:52: compiler.warn.possible.this.escape\n+ThisEscape.java:385:17: compiler.warn.possible.this.escape\n+ThisEscape.java:396:17: compiler.warn.possible.this.escape\n+ThisEscape.java:401:30: compiler.warn.possible.this.escape.location\n+ThisEscape.java:444:28: compiler.warn.possible.this.escape\n+ThisEscape.java:473:27: compiler.warn.possible.this.escape\n+25 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"}]}