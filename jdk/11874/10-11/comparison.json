{"files":[{"patch":"@@ -207,0 +207,1 @@\n+        Assert.check(methodMap.isEmpty());      \/\/ we are not prepared to be used more than once\n@@ -212,0 +213,10 @@\n+        \/\/ Build a set of symbols for classes declared in this file\n+        final Set<Symbol> classSyms = new HashSet<>();\n+        new TreeScanner() {\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                classSyms.add(tree.sym);\n+                super.visitClassDef(tree);\n+            }\n+        }.scan(env.tree);\n+\n@@ -292,2 +303,5 @@\n-                  !(currentClass.sym.isSealed() && currentClass.permitting.isEmpty()) &&\n-                  !(currentClass.sym.owner.kind == MTH) &&\n+                  !(currentClass.sym.isSealed() &&\n+                      currentClass.permitting.stream()\n+                        .map(TreeInfo::symbolFor)\n+                        .allMatch(classSyms::contains)) &&\n+                  !currentClass.sym.isDirectlyOrIndirectlyLocal() &&\n@@ -298,2 +312,0 @@\n-        \/\/ TODO: eliminate sealed classes where all permitted subclasses are in this compilation unit\n-\n@@ -303,2 +315,2 @@\n-                .filter(MethodInfo::isAnalyzable)\n-                .map(MethodInfo::getDeclaringClass)\n+                .filter(MethodInfo::analyzable)\n+                .map(MethodInfo::declaringClass)\n@@ -314,2 +326,1 @@\n-                if (defs.head.hasTag(VARDEF)) {\n-                    JCVariableDecl vardef = (JCVariableDecl)defs.head;\n+                if (defs.head instanceof JCVariableDecl vardef) {\n@@ -324,2 +335,1 @@\n-                if (defs.head.hasTag(BLOCK)) {\n-                    JCBlock block = (JCBlock)defs.head;\n+                if (defs.head instanceof JCBlock block) {\n@@ -334,1 +344,1 @@\n-                .filter(MethodInfo::isAnalyzable)\n+                .filter(MethodInfo::analyzable)\n@@ -336,2 +346,2 @@\n-            visitTopLevel(methodInfo.getDeclaringClass(),\n-                () -> analyzeStatements(methodInfo.getDeclaration().body.stats));\n+            visitTopLevel(methodInfo.declaringClass(),\n+                () -> analyzeStatements(methodInfo.declaration().body.stats));\n@@ -417,21 +427,21 @@\n-        case SWITCH_EXPRESSION:\n-        case CONDEXPR:\n-        case YIELD:\n-        case APPLY:\n-        case NEWCLASS:\n-        case NEWARRAY:\n-        case LAMBDA:\n-        case PARENS:\n-        case ASSIGN:\n-        case TYPECAST:\n-        case INDEXED:\n-        case SELECT:\n-        case REFERENCE:\n-        case IDENT:\n-        case NULLCHK:\n-        case LETEXPR:\n-            referenceExpressionNode = true;\n-            break;\n-        default:\n-            referenceExpressionNode = false;\n-            break;\n+            case SWITCH_EXPRESSION:\n+            case CONDEXPR:\n+            case YIELD:\n+            case APPLY:\n+            case NEWCLASS:\n+            case NEWARRAY:\n+            case LAMBDA:\n+            case PARENS:\n+            case ASSIGN:\n+            case TYPECAST:\n+            case INDEXED:\n+            case SELECT:\n+            case REFERENCE:\n+            case IDENT:\n+            case NULLCHK:\n+            case LETEXPR:\n+                referenceExpressionNode = true;\n+                break;\n+            default:\n+                referenceExpressionNode = false;\n+                break;\n@@ -528,1 +538,1 @@\n-        if (methodInfo != null && methodInfo.isInvokable())\n+        if (methodInfo != null && methodInfo.invokable())\n@@ -537,1 +547,1 @@\n-        Assert.check(methodInfo.isInvokable());\n+        Assert.check(methodInfo.invokable());\n@@ -540,1 +550,1 @@\n-        JCMethodDecl method = methodInfo.getDeclaration();\n+        JCMethodDecl method = methodInfo.declaration();\n@@ -553,1 +563,1 @@\n-        methodClass = methodInfo.getDeclaringClass();\n+        methodClass = methodInfo.declaringClass();\n@@ -615,1 +625,1 @@\n-        if (methodInfo != null && methodInfo.isInvokable())\n+        if (methodInfo != null && methodInfo.invokable())\n@@ -909,0 +919,2 @@\n+        scan(tree.detail);\n+        refs.discardExprs(depth);\n@@ -1450,39 +1462,5 @@\n-    private static class MethodInfo {\n-\n-        private final JCClassDecl declaringClass;\n-        private final JCMethodDecl declaration;\n-        private final boolean analyzable;           \/\/ it's a constructor we should analyze\n-        private final boolean invokable;            \/\/ it may be \"invoked\" during analysis\n-\n-        MethodInfo(JCClassDecl declaringClass, JCMethodDecl declaration,\n-            boolean analyzable, boolean invokable) {\n-            this.declaringClass = declaringClass;\n-            this.declaration = declaration;\n-            this.analyzable = analyzable;\n-            this.invokable = invokable;\n-        }\n-\n-        public JCClassDecl getDeclaringClass() {\n-            return declaringClass;\n-        }\n-\n-        public JCMethodDecl getDeclaration() {\n-            return declaration;\n-        }\n-\n-        public boolean isAnalyzable() {\n-            return analyzable;\n-        }\n-\n-        public boolean isInvokable() {\n-            return invokable;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return getClass().getSimpleName()\n-              + \"[meth=\" + declaringClass.name + \".\" + declaration.name + \"()\"\n-              + (analyzable ? \",analyzable\" : \"\")\n-              + (invokable ? \",invokable\" : \"\")\n-              + \"]\";\n-        }\n+    private record MethodInfo(\n+        JCClassDecl declaringClass,     \/\/ the class declaring \"declaration\"\n+        JCMethodDecl declaration,       \/\/ the method or constructor itself\n+        boolean analyzable,             \/\/ it's a constructor that we should analyze\n+        boolean invokable) {            \/\/ it may be safely \"invoked\" during analysis\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":56,"deletions":78,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -587,0 +587,17 @@\n+\n+    \/\/ Verify 'this' escape detection doesn't warn for sealed classes with local permits\n+    public static sealed class ThisEscapeSealed permits ThisEscapeSealed.Sub1, ThisEscapeSealed.Sub2 {\n+\n+        public ThisEscapeSealed() {\n+            this.mightLeak();\n+        }\n+\n+        public void mightLeak() {\n+        }\n+\n+        public static final class Sub1 extends ThisEscapeSealed {\n+        }\n+\n+        public static final class Sub2 extends ThisEscapeSealed {\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}