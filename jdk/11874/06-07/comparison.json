{"files":[{"patch":"@@ -79,1 +79,1 @@\n-    DISABLED_WARNINGS := rawtypes serial options, \\\n+    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n+    DISABLED_WARNINGS := this-escape processing rawtypes cast serial preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2340,17 +2340,0 @@\n-    \/** Determine whether the given outer class strictly encloses the inner one.\n-     *\/\n-    public boolean hasOuterClass(Type innerType, Type outerType) {\n-        if (!innerType.hasTag(CLASS) || !outerType.hasTag(CLASS))\n-            return false;\n-        innerType = erasure(innerType);\n-        outerType = erasure(outerType);\n-        for (Type type = innerType.getEnclosingType();\n-                type != null && type.hasTag(CLASS);\n-                type = type.getEnclosingType()) {\n-            if (isSameType(type, outerType)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-\/\/ These fields are scoped to the entire COMPILATION UNIT\n+\/\/ These fields are scoped to the entire compilation unit\n@@ -140,1 +140,1 @@\n-    \/** Contains symbols of fields and methods that have warnings suppressed.\n+    \/** Contains symbols of fields and constructors that have warnings suppressed.\n@@ -151,1 +151,1 @@\n-    private ArrayList<DiagnosticPosition[]> warningList = new ArrayList<>();\n+    private final ArrayList<DiagnosticPosition[]> warningList = new ArrayList<>();\n@@ -153,1 +153,1 @@\n-\/\/ These fields are scoped to the CONSTRUCTOR BEING ANALYZED\n+\/\/ These fields are scoped to the constructor being analyzed\n@@ -175,1 +175,1 @@\n-\/\/ These fields are scoped to the CONSTRUCTOR OR INVOKED METHOD BEING ANALYZED\n+\/\/ These fields are scoped to the constructor or invoked method being analyzed\n@@ -201,4 +201,0 @@\n-        this.analyzeTree(env, env.tree);\n-    }\n-\n-    public void analyzeTree(Env<AttrContext> env, JCTree tree) {\n@@ -207,1 +203,1 @@\n-        Assert.check(this.checkInvariants(false, false));\n+        Assert.check(checkInvariants(false, false));\n@@ -210,1 +206,1 @@\n-        if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+        if (!lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n@@ -215,1 +211,1 @@\n-        \/\/ Track which methods and variables have warnings are suppressed.\n+        \/\/ Track which constructors and fields have warnings suppressed.\n@@ -224,4 +220,4 @@\n-                final JCClassDecl currentClassPrev = this.currentClass;\n-                final boolean privateOuterPrev = this.privateOuter;\n-                final Lint lintPrev = this.lint;\n-                this.lint = this.lint.augment(tree.sym);\n+                JCClassDecl currentClassPrev = currentClass;\n+                boolean privateOuterPrev = privateOuter;\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n@@ -229,3 +225,3 @@\n-                    this.currentClass = tree;\n-                    this.privateOuter |= tree.sym.isAnonymous();\n-                    this.privateOuter |= (tree.mods.flags & Flags.PRIVATE) != 0;\n+                    currentClass = tree;\n+                    privateOuter |= tree.sym.isAnonymous();\n+                    privateOuter |= (tree.mods.flags & Flags.PRIVATE) != 0;\n@@ -236,3 +232,3 @@\n-                    this.currentClass = currentClassPrev;\n-                    this.privateOuter = privateOuterPrev;\n-                    this.lint = lintPrev;\n+                    currentClass = currentClassPrev;\n+                    privateOuter = privateOuterPrev;\n+                    lint = lintPrev;\n@@ -244,2 +240,2 @@\n-                final Lint lintPrev = this.lint;\n-                this.lint = this.lint.augment(tree.sym);\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n@@ -247,3 +243,4 @@\n-                    \/\/ Track warning suppression\n-                    if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n-                        ThisEscapeAnalyzer.this.suppressed.add(tree.sym);\n+\n+                    \/\/ Track warning suppression of fields\n+                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        suppressed.add(tree.sym);\n@@ -254,1 +251,1 @@\n-                    this.lint = lintPrev;\n+                    lint = lintPrev;\n@@ -260,2 +257,2 @@\n-                final Lint lintPrev = this.lint;\n-                this.lint = this.lint.augment(tree.sym);\n+                Lint lintPrev = lint;\n+                lint = lint.augment(tree.sym);\n@@ -263,3 +260,4 @@\n-                    \/\/ Track warning suppression\n-                    if (!this.lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n-                        ThisEscapeAnalyzer.this.suppressed.add(tree.sym);\n+\n+                    \/\/ Track warning suppression of constructors\n+                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                        suppressed.add(tree.sym);\n@@ -268,1 +266,1 @@\n-                    final boolean analyzable = this.currentClassIsExternallyExtendable() &&\n+                    boolean analyzable = currentClassIsExternallyExtendable() &&\n@@ -271,1 +269,1 @@\n-                        !ThisEscapeAnalyzer.this.suppressed.contains(tree.sym);\n+                        !suppressed.contains(tree.sym);\n@@ -274,1 +272,1 @@\n-                    final boolean invokable = !this.currentClassIsExternallyExtendable() ||\n+                    boolean invokable = !currentClassIsExternallyExtendable() ||\n@@ -279,2 +277,1 @@\n-                    final MethodInfo info = new MethodInfo(this.currentClass, tree, analyzable, invokable);\n-                    ThisEscapeAnalyzer.this.methodMap.put(tree.sym, info);\n+                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, analyzable, invokable));\n@@ -285,1 +282,1 @@\n-                    this.lint = lintPrev;\n+                    lint = lintPrev;\n@@ -291,4 +288,4 @@\n-                return !this.currentClass.sym.isFinal() &&\n-                  !(this.currentClass.sym.isSealed() && this.currentClass.permitting.isEmpty()) &&\n-                  !(this.currentClass.sym.owner.kind == MTH) &&\n-                  !this.privateOuter;\n+                return !currentClass.sym.isFinal() &&\n+                  !(currentClass.sym.isSealed() && currentClass.permitting.isEmpty()) &&\n+                  !(currentClass.sym.owner.kind == MTH) &&\n+                  !privateOuter;\n@@ -296,1 +293,1 @@\n-        }.scan(tree);\n+        }.scan(env.tree);\n@@ -301,1 +298,1 @@\n-        for (Map.Entry<Symbol, MethodInfo> entry : this.methodMap.entrySet()) {\n+        for (MethodInfo methodInfo : methodMap.values()) {\n@@ -304,2 +301,0 @@\n-            final Symbol sym = entry.getKey();\n-            final MethodInfo methodInfo = entry.getValue();\n@@ -310,5 +305,5 @@\n-            this.targetClass = methodInfo.getDeclaringClass();\n-            this.methodClass = this.targetClass;\n-            Assert.check(this.depth == -1);\n-            Assert.check(this.refs == null);\n-            this.pushScope();\n+            targetClass = methodInfo.getDeclaringClass();\n+            methodClass = targetClass;\n+            Assert.check(depth == -1);\n+            Assert.check(refs == null);\n+            pushScope();\n@@ -318,2 +313,2 @@\n-                this.refs = RefSet.newEmpty();\n-                this.refs.add(ThisRef.direct());\n+                refs = RefSet.newEmpty();\n+                refs.add(ThisRef.direct());\n@@ -322,1 +317,1 @@\n-                this.analyzeStatements(methodInfo.getDeclaration().body.stats);\n+                analyzeStatements(methodInfo.getDeclaration().body.stats);\n@@ -324,4 +319,4 @@\n-                this.popScope();\n-                this.methodClass = null;\n-                this.targetClass = null;\n-                this.refs = null;\n+                popScope();\n+                methodClass = null;\n+                targetClass = null;\n+                refs = null;\n@@ -334,1 +329,1 @@\n-        final BiPredicate<DiagnosticPosition[], DiagnosticPosition[]> extendsAsPrefix = (warning1, warning2) -> {\n+        BiPredicate<DiagnosticPosition[], DiagnosticPosition[]> extendsAsPrefix = (warning1, warning2) -> {\n@@ -346,1 +341,1 @@\n-        final Comparator<DiagnosticPosition[]> ordering = (warning1, warning2) -> {\n+        Comparator<DiagnosticPosition[]> ordering = (warning1, warning2) -> {\n@@ -348,2 +343,2 @@\n-                final boolean end1 = index1 >= warning1.length;\n-                final boolean end2 = index2 >= warning2.length;\n+                boolean end1 = index1 >= warning1.length;\n+                boolean end2 = index2 >= warning2.length;\n@@ -356,3 +351,3 @@\n-                final int posn1 = warning1[index1].getPreferredPosition();\n-                final int posn2 = warning2[index2].getPreferredPosition();\n-                final int diff = Integer.compare(posn1, posn2);\n+                int posn1 = warning1[index1].getPreferredPosition();\n+                int posn2 = warning2[index2].getPreferredPosition();\n+                int diff = Integer.compare(posn1, posn2);\n@@ -363,1 +358,1 @@\n-        this.warningList.sort(ordering);\n+        warningList.sort(ordering);\n@@ -367,1 +362,1 @@\n-        for (DiagnosticPosition[] warning : this.warningList) {\n+        for (DiagnosticPosition[] warning : warningList) {\n@@ -378,2 +373,2 @@\n-                final DiagnosticPosition pos = warning[--remain];\n-                this.log.warning(Lint.LintCategory.THIS_ESCAPE, pos, key);\n+                DiagnosticPosition pos = warning[--remain];\n+                log.warning(Lint.LintCategory.THIS_ESCAPE, pos, key);\n@@ -383,1 +378,1 @@\n-        this.warningList.clear();\n+        warningList.clear();\n@@ -390,1 +385,1 @@\n-            this.scan(stat);\n+            scan(stat);\n@@ -393,1 +388,1 @@\n-            if (this.copyPendingWarning())\n+            if (copyPendingWarning())\n@@ -406,1 +401,1 @@\n-        Assert.check(this.checkInvariants(true, false));\n+        Assert.check(checkInvariants(true, false));\n@@ -409,1 +404,1 @@\n-        final boolean referenceExpressionNode;\n+        boolean referenceExpressionNode;\n@@ -411,1 +406,0 @@\n-        case CASE:\n@@ -439,1 +433,1 @@\n-        Assert.check(this.checkInvariants(true, referenceExpressionNode));\n+        Assert.check(checkInvariants(true, referenceExpressionNode));\n@@ -441,1 +435,3 @@\n-        \/\/ Discard any direct 'this' reference that's incompatible with the target type\n+        \/\/ Discard any direct 'this' reference that can't be valid because its\n+        \/\/ type is not compatible with the target class we're analyzing for.\n+        \/\/ Note, tricky code could cast away and then cast back to evade this.\n@@ -446,1 +442,1 @@\n-            final Symbol sym = TreeInfo.symbolFor(tree);\n+            Symbol sym = TreeInfo.symbolFor(tree);\n@@ -454,2 +450,2 @@\n-            if (type != null && !this.isSubtype(this.targetClass.sym.type, type))\n-                this.refs.remove(ExprRef.direct(this.depth));\n+            if (type != null && !targetClass.sym.isSubClass(type.tsym, types))\n+                refs.remove(ExprRef.direct(depth));\n@@ -475,2 +471,2 @@\n-        \/\/ Skip if ignoring warnings for this variable\n-        if (this.suppressed.contains(tree.sym))\n+        \/\/ Skip if ignoring warnings for this field\n+        if (suppressed.contains(tree.sym))\n@@ -480,3 +476,3 @@\n-        this.scan(tree.init);\n-        if (this.isParamOrVar(tree.sym))\n-            this.refs.replaceExprs(this.depth, direct -> new VarRef(tree.sym, direct));\n+        scan(tree.init);\n+        if (isParamOrVar(tree.sym))\n+            refs.replaceExprs(depth, direct -> new VarRef(tree.sym, direct));\n@@ -484,1 +480,1 @@\n-            this.refs.discardExprs(this.depth);         \/\/ we don't track fields yet\n+            refs.discardExprs(depth);           \/\/ we don't track fields yet\n@@ -500,1 +496,1 @@\n-        final MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n+        MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n@@ -503,3 +499,3 @@\n-        this.scan(invoke.meth);\n-        final boolean direct = this.refs.remove(ExprRef.direct(this.depth));\n-        final boolean indirect = this.refs.remove(ExprRef.indirect(this.depth));\n+        scan(invoke.meth);\n+        boolean direct = refs.remove(ExprRef.direct(depth));\n+        boolean indirect = refs.remove(ExprRef.indirect(depth));\n@@ -508,1 +504,1 @@\n-        final RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n+        RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n@@ -518,3 +514,3 @@\n-        final Name name = TreeInfo.name(invoke.meth);\n-        if (name == this.names._super) {\n-            this.scanInitializers();\n+        Name name = TreeInfo.name(invoke.meth);\n+        if (name == names._super) {\n+            scanInitializers();\n@@ -525,1 +521,1 @@\n-        this.invoke(invoke, sym, invoke.args, receiverRefs);\n+        invoke(invoke, sym, invoke.args, receiverRefs);\n@@ -530,2 +526,2 @@\n-        \/\/ Skip if ignoring warnings for the invoked method\n-        if (this.suppressed.contains(sym))\n+        \/\/ Skip if ignoring warnings for a constructor invoked via 'this()'\n+        if (suppressed.contains(sym))\n@@ -537,1 +533,1 @@\n-            ((ClassSymbol)sym.owner).fullname == this.names.java_lang_Object &&\n+            ((ClassSymbol)sym.owner).fullname == names.java_lang_Object &&\n@@ -543,1 +539,1 @@\n-        final MethodInfo methodInfo = this.methodMap.get(sym);\n+        MethodInfo methodInfo = methodMap.get(sym);\n@@ -545,1 +541,1 @@\n-            this.invokeInvokable(site, args, receiverRefs, methodInfo);\n+            invokeInvokable(site, args, receiverRefs, methodInfo);\n@@ -547,1 +543,1 @@\n-            this.invokeUnknown(site, args, receiverRefs);\n+            invokeUnknown(site, args, receiverRefs);\n@@ -552,2 +548,2 @@\n-        final DiagnosticPosition[] pendingWarningPrev = this.pendingWarning;\n-        this.pendingWarning = null;\n+        DiagnosticPosition[] pendingWarningPrev = pendingWarning;\n+        pendingWarning = null;\n@@ -555,1 +551,1 @@\n-            for (List<JCTree> defs = this.methodClass.defs; defs.nonEmpty(); defs = defs.tail) {\n+            for (List<JCTree> defs = methodClass.defs; defs.nonEmpty(); defs = defs.tail) {\n@@ -563,2 +559,2 @@\n-                    this.scan((JCVariableDecl)defs.head);\n-                    this.copyPendingWarning();\n+                    scan((JCVariableDecl)defs.head);\n+                    copyPendingWarning();\n@@ -570,1 +566,1 @@\n-                    this.visitScoped((JCBlock)defs.head, false, block -> this.analyzeStatements(block.stats));\n+                    visitScoped((JCBlock)defs.head, false, block -> analyzeStatements(block.stats));\n@@ -575,1 +571,1 @@\n-            this.pendingWarning = pendingWarningPrev;\n+            pendingWarning = pendingWarningPrev;\n@@ -585,2 +581,2 @@\n-        final JCMethodDecl method = methodInfo.getDeclaration();\n-        final RefSet<VarRef> paramRefs = RefSet.newEmpty();\n+        JCMethodDecl method = methodInfo.getDeclaration();\n+        RefSet<VarRef> paramRefs = RefSet.newEmpty();\n@@ -589,3 +585,3 @@\n-            final VarSymbol sym = params.head.sym;\n-            this.scan(args.head);\n-            this.refs.removeExprs(this.depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n+            VarSymbol sym = params.head.sym;\n+            scan(args.head);\n+            refs.removeExprs(depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n@@ -597,7 +593,7 @@\n-        final JCClassDecl methodClassPrev = this.methodClass;\n-        this.methodClass = methodInfo.getDeclaringClass();\n-        final RefSet<Ref> refsPrev = this.refs;\n-        this.refs = RefSet.newEmpty();\n-        final int depthPrev = this.depth;\n-        this.depth = 0;\n-        this.callStack.push(site);\n+        JCClassDecl methodClassPrev = methodClass;\n+        methodClass = methodInfo.getDeclaringClass();\n+        RefSet<Ref> refsPrev = refs;\n+        refs = RefSet.newEmpty();\n+        int depthPrev = depth;\n+        depth = 0;\n+        callStack.push(site);\n@@ -607,1 +603,1 @@\n-            this.refs.addAll(receiverRefs);\n+            refs.addAll(receiverRefs);\n@@ -610,1 +606,1 @@\n-            this.refs.addAll(paramRefs);\n+            refs.addAll(paramRefs);\n@@ -613,1 +609,1 @@\n-            if (this.refs.isEmpty())\n+            if (refs.isEmpty())\n@@ -617,2 +613,2 @@\n-            final Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, this.refs.clone());\n-            if (!this.invocations.add(invocation))\n+            Pair<JCTree, RefSet<Ref>> invocation = Pair.of(site, refs.clone());\n+            if (!invocations.add(invocation))\n@@ -623,1 +619,1 @@\n-                this.scan(method.body);\n+                scan(method.body);\n@@ -625,1 +621,1 @@\n-                this.invocations.remove(invocation);\n+                invocations.remove(invocation);\n@@ -629,4 +625,1 @@\n-            if (this.refs.remove(ReturnRef.direct()))\n-                refsPrev.add(ExprRef.direct(depthPrev));\n-            if (this.refs.remove(ReturnRef.indirect()))\n-                refsPrev.add(ExprRef.indirect(depthPrev));\n+            refs.mapInto(refsPrev, ReturnRef.class, direct -> new ExprRef(depthPrev, direct));\n@@ -634,4 +627,4 @@\n-            this.callStack.pop();\n-            this.depth = depthPrev;\n-            this.refs = refsPrev;\n-            this.methodClass = methodClassPrev;\n+            callStack.pop();\n+            depth = depthPrev;\n+            refs = refsPrev;\n+            methodClass = methodClassPrev;\n@@ -646,1 +639,1 @@\n-            this.leakAt(invoke);\n+            leakAt(invoke);\n@@ -650,3 +643,3 @@\n-            this.scan(arg);\n-            if (this.refs.discardExprs(this.depth))\n-                this.leakAt(arg);\n+            scan(arg);\n+            if (refs.discardExprs(depth))\n+                leakAt(arg);\n@@ -662,1 +655,1 @@\n-        final MethodInfo methodInfo = this.methodMap.get(tree.constructor);\n+        MethodInfo methodInfo = methodMap.get(tree.constructor);\n@@ -664,1 +657,1 @@\n-            this.invokeInvokable(tree, tree.args, this.outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n+            invokeInvokable(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n@@ -666,1 +659,1 @@\n-            this.invokeUnknown(tree, tree.args, this.outerThisRefs(tree.encl, tree.clazz.type));\n+            invokeUnknown(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type));\n@@ -671,1 +664,1 @@\n-        final RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n+        RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n@@ -673,7 +666,4 @@\n-            this.scan(explicitOuterThis);\n-            this.refs.removeExprs(this.depth, direct -> outerRefs.add(new OuterRef(direct)));\n-        } else if (this.types.hasOuterClass(type, this.methodClass.type)) {\n-            if (this.refs.contains(ThisRef.direct()))\n-                outerRefs.add(OuterRef.direct());\n-            if (this.refs.contains(ThisRef.indirect()))\n-                outerRefs.add(OuterRef.indirect());\n+            scan(explicitOuterThis);\n+            refs.removeExprs(depth, direct -> outerRefs.add(new OuterRef(direct)));\n+        } else if (type.tsym != methodClass.sym && type.tsym.isEnclosedBy(methodClass.sym)) {\n+            refs.mapInto(outerRefs, ThisRef.class, OuterRef::new);\n@@ -690,2 +680,2 @@\n-        this.visitScoped(tree, false, super::visitBlock);\n-        Assert.check(this.checkInvariants(true, false));\n+        visitScoped(tree, false, super::visitBlock);\n+        Assert.check(checkInvariants(true, false));\n@@ -696,1 +686,1 @@\n-        this.visitLooped(tree, super::visitDoLoop);\n+        visitLooped(tree, super::visitDoLoop);\n@@ -701,1 +691,1 @@\n-        this.visitLooped(tree, super::visitWhileLoop);\n+        visitLooped(tree, super::visitWhileLoop);\n@@ -706,1 +696,1 @@\n-        this.visitLooped(tree, super::visitForLoop);\n+        visitLooped(tree, super::visitForLoop);\n@@ -711,1 +701,1 @@\n-        this.visitLooped(tree, super::visitForeachLoop);\n+        visitLooped(tree, super::visitForeachLoop);\n@@ -716,4 +706,4 @@\n-        this.visitScoped(tree, false, t -> {\n-            this.scan(t.selector);\n-            this.refs.discardExprs(this.depth);\n-            this.scan(t.cases);\n+        visitScoped(tree, false, t -> {\n+            scan(t.selector);\n+            refs.discardExprs(depth);\n+            scan(t.cases);\n@@ -725,4 +715,4 @@\n-        this.visitScoped(tree, true, t -> {\n-            this.scan(t.selector);\n-            this.refs.discardExprs(this.depth);\n-            final RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        visitScoped(tree, true, t -> {\n+            scan(t.selector);\n+            refs.discardExprs(depth);\n+            RefSet<ExprRef> combinedRefs = new RefSet<>();\n@@ -730,2 +720,3 @@\n-                this.scan(cases.head);\n-                combinedRefs.addAll(this.refs.removeExprs(this.depth));\n+                scan(cases.head.stats);\n+                refs.replace(YieldRef.class, direct -> new ExprRef(depth, direct));\n+                combinedRefs.addAll(refs.removeExprs(depth));\n@@ -733,1 +724,1 @@\n-            this.refs.addAll(combinedRefs);\n+            refs.addAll(combinedRefs);\n@@ -739,1 +730,7 @@\n-        this.scan(tree.stats);          \/\/ no need to scan labels\n+        scan(tree.stats);          \/\/ no need to scan labels\n+    }\n+\n+    @Override\n+    public void visitYield(JCYield tree) {\n+        scan(tree.value);\n+        refs.replaceExprs(depth, YieldRef::new);\n@@ -744,1 +741,1 @@\n-        this.visitScoped(tree, true, super::visitLetExpr);\n+        visitScoped(tree, true, super::visitLetExpr);\n@@ -749,2 +746,2 @@\n-        this.scan(tree.expr);\n-        this.refs.replaceExprs(this.depth, ReturnRef::new);\n+        scan(tree.expr);\n+        refs.replaceExprs(depth, ReturnRef::new);\n@@ -755,1 +752,1 @@\n-        this.visitDeferred(() -> this.visitScoped(lambda, false, super::visitLambda));\n+        visitDeferred(() -> visitScoped(lambda, false, super::visitLambda));\n@@ -760,6 +757,6 @@\n-        this.scan(tree.lhs);\n-        this.refs.discardExprs(this.depth);\n-        this.scan(tree.rhs);\n-        final VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n-        if (this.isParamOrVar(sym))\n-            this.refs.replaceExprs(this.depth, direct -> new VarRef(sym, direct));\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n+        if (isParamOrVar(sym))\n+            refs.replaceExprs(depth, direct -> new VarRef(sym, direct));\n@@ -767,1 +764,1 @@\n-            this.refs.discardExprs(this.depth);         \/\/ we don't track fields yet\n+            refs.discardExprs(depth);         \/\/ we don't track fields yet\n@@ -772,5 +769,5 @@\n-        this.scan(tree.indexed);\n-        this.refs.remove(ExprRef.direct(this.depth));\n-        final boolean indirectRef = this.refs.remove(ExprRef.indirect(this.depth));\n-        this.scan(tree.index);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.indexed);\n+        refs.remove(ExprRef.direct(depth));\n+        boolean indirectRef = refs.remove(ExprRef.indirect(depth));\n+        scan(tree.index);\n+        refs.discardExprs(depth);\n@@ -778,2 +775,2 @@\n-            this.refs.add(ExprRef.direct(this.depth));\n-            this.refs.add(ExprRef.indirect(this.depth));\n+            refs.add(ExprRef.direct(depth));\n+            refs.add(ExprRef.indirect(depth));\n@@ -787,3 +784,3 @@\n-        this.scan(tree.selected);\n-        final boolean selectedDirectRef = this.refs.remove(ExprRef.direct(this.depth));\n-        final boolean selectedIndirectRef = this.refs.remove(ExprRef.indirect(this.depth));\n+        scan(tree.selected);\n+        boolean selectedDirectRef = refs.remove(ExprRef.direct(depth));\n+        boolean selectedIndirectRef = refs.remove(ExprRef.indirect(depth));\n@@ -792,6 +789,3 @@\n-        final Type.ClassType currentClassType = (Type.ClassType)this.methodClass.sym.type;\n-        if (TreeInfo.isExplicitThisReference(this.types, currentClassType, tree)) {\n-            if (this.refs.contains(ThisRef.direct()))\n-                this.refs.add(ExprRef.direct(this.depth));\n-            if (this.refs.contains(ThisRef.indirect()))\n-                this.refs.add(ExprRef.indirect(this.depth));\n+        Type.ClassType currentClassType = (Type.ClassType)methodClass.sym.type;\n+        if (isExplicitThisReference(types, currentClassType, tree)) {\n+            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n@@ -802,1 +796,1 @@\n-        final Type selectedType = this.types.erasure(tree.selected.type);\n+        Type selectedType = types.erasure(tree.selected.type);\n@@ -804,7 +798,6 @@\n-            final Type.ClassType selectedClassType = (Type.ClassType)selectedType;\n-            if (tree.name == this.names._this &&\n-                this.types.hasOuterClass(currentClassType, selectedClassType)) {\n-                if (this.refs.contains(OuterRef.direct()))\n-                    this.refs.add(ExprRef.direct(this.depth));\n-                if (this.refs.contains(OuterRef.indirect()))\n-                    this.refs.add(ExprRef.indirect(this.depth));\n+            ClassSymbol currentClassSym = (ClassSymbol)currentClassType.tsym;\n+            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n+            if (tree.name == names._this &&\n+                    selectedTypeSym != currentClassSym &&\n+                    currentClassSym.isEnclosedBy(selectedTypeSym)) {\n+                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n@@ -816,1 +809,1 @@\n-        final Symbol sym = tree.sym;\n+        Symbol sym = tree.sym;\n@@ -820,1 +813,1 @@\n-                    this.refs.add(ExprRef.direct(this.depth));\n+                    refs.add(ExprRef.direct(depth));\n@@ -822,1 +815,1 @@\n-                    this.refs.add(ExprRef.indirect(this.depth));\n+                    refs.add(ExprRef.indirect(depth));\n@@ -835,3 +828,3 @@\n-        this.scan(tree.expr);\n-        final boolean direct = this.refs.remove(ExprRef.direct(this.depth));\n-        final boolean indirect = this.refs.remove(ExprRef.indirect(this.depth));\n+        scan(tree.expr);\n+        boolean direct = refs.remove(ExprRef.direct(depth));\n+        boolean indirect = refs.remove(ExprRef.indirect(depth));\n@@ -840,1 +833,1 @@\n-        final RefSet<Ref> receiverRefs = RefSet.newEmpty();\n+        RefSet<Ref> receiverRefs = RefSet.newEmpty();\n@@ -848,4 +841,1 @@\n-            if (this.refs.contains(ThisRef.direct()))\n-                receiverRefs.add(ThisRef.direct());\n-            if (this.refs.contains(ThisRef.indirect()))\n-                receiverRefs.add(ThisRef.indirect());\n+            refs.mapInto(receiverRefs, ThisRef.class, ThisRef::new);\n@@ -860,1 +850,1 @@\n-            receiverRefs.addAll(this.outerThisRefs(null, tree.expr.type));\n+            receiverRefs.addAll(outerThisRefs(null, tree.expr.type));\n@@ -867,1 +857,1 @@\n-        this.visitDeferred(() -> this.invoke(tree, (MethodSymbol)tree.sym, List.nil(), receiverRefs));\n+        visitDeferred(() -> invoke(tree, (MethodSymbol)tree.sym, List.nil(), receiverRefs));\n@@ -875,4 +865,1 @@\n-            if (this.refs.contains(ThisRef.direct()))\n-                this.refs.add(ExprRef.direct(this.depth));\n-            if (this.refs.contains(ThisRef.indirect()))\n-                this.refs.add(ExprRef.indirect(this.depth));\n+            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n@@ -883,6 +870,6 @@\n-        if (this.isParamOrVar(tree.sym)) {\n-            final VarSymbol sym = (VarSymbol)tree.sym;\n-            if (this.refs.contains(VarRef.direct(sym)))\n-                this.refs.add(ExprRef.direct(this.depth));\n-            if (this.refs.contains(VarRef.indirect(sym)))\n-                this.refs.add(ExprRef.indirect(this.depth));\n+        if (isParamOrVar(tree.sym)) {\n+            VarSymbol sym = (VarSymbol)tree.sym;\n+            if (refs.contains(VarRef.direct(sym)))\n+                refs.add(ExprRef.direct(depth));\n+            if (refs.contains(VarRef.indirect(sym)))\n+                refs.add(ExprRef.indirect(depth));\n@@ -895,1 +882,1 @@\n-            final MethodSymbol sym = (MethodSymbol)tree.sym;\n+            MethodSymbol sym = (MethodSymbol)tree.sym;\n@@ -898,7 +885,3 @@\n-            final Type.ClassType currentClassType = (Type.ClassType)this.methodClass.sym.type;\n-            final Type methodOwnerType = sym.owner.type;\n-            if (this.isSubtype(currentClassType, methodOwnerType)) {\n-                if (this.refs.contains(ThisRef.direct()))\n-                    this.refs.add(ExprRef.direct(this.depth));\n-                if (this.refs.contains(ThisRef.indirect()))\n-                    this.refs.add(ExprRef.indirect(this.depth));\n+            ClassSymbol methodClassSym = methodClass.sym;\n+            if (methodClassSym.isSubClass(sym.owner, types)) {\n+                refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n@@ -909,5 +892,2 @@\n-            if (this.types.hasOuterClass(currentClassType, methodOwnerType)) {\n-                if (this.refs.contains(OuterRef.direct()))\n-                    this.refs.add(ExprRef.direct(this.depth));\n-                if (this.refs.contains(OuterRef.indirect()))\n-                    this.refs.add(ExprRef.indirect(this.depth));\n+            if (methodClassSym.isEnclosedBy((ClassSymbol)sym.owner)) {\n+                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n@@ -928,3 +908,3 @@\n-        this.scan(tree.lock);\n-        this.refs.discardExprs(this.depth);\n-        this.scan(tree.body);\n+        scan(tree.lock);\n+        refs.discardExprs(depth);\n+        scan(tree.body);\n@@ -935,8 +915,8 @@\n-        this.scan(tree.cond);\n-        this.refs.discardExprs(this.depth);\n-        final RefSet<ExprRef> combinedRefs = new RefSet<>();\n-        this.scan(tree.truepart);\n-        combinedRefs.addAll(this.refs.removeExprs(this.depth));\n-        this.scan(tree.falsepart);\n-        combinedRefs.addAll(this.refs.removeExprs(this.depth));\n-        this.refs.addAll(combinedRefs);\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n+        RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        scan(tree.truepart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        scan(tree.falsepart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.addAll(combinedRefs);\n@@ -947,4 +927,8 @@\n-        this.scan(tree.cond);\n-        this.refs.discardExprs(this.depth);\n-        this.scan(tree.thenpart);\n-        this.scan(tree.elsepart);\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n+        RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        scan(tree.thenpart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        scan(tree.elsepart);\n+        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.addAll(combinedRefs);\n@@ -955,2 +939,2 @@\n-        this.scan(tree.expr);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.expr);\n+        refs.discardExprs(depth);\n@@ -961,2 +945,3 @@\n-        this.scan(tree.expr);\n-        this.refs.discardExprs(this.depth);      \/\/ we don't try to follow refs from thrown exceptions\n+        scan(tree.expr);\n+        if (refs.discardExprs(depth))     \/\/ we don't try to \"catch\" refs from thrown exceptions\n+            leakAt(tree);\n@@ -967,2 +952,2 @@\n-        this.scan(tree.cond);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.cond);\n+        refs.discardExprs(depth);\n@@ -976,2 +961,2 @@\n-                this.scan(elems.head);\n-                ref |= this.refs.discardExprs(this.depth);\n+                scan(elems.head);\n+                ref |= refs.discardExprs(depth);\n@@ -981,1 +966,1 @@\n-            this.refs.add(ExprRef.indirect(this.depth));\n+            refs.add(ExprRef.indirect(depth));\n@@ -986,1 +971,1 @@\n-        this.scan(tree.expr);\n+        scan(tree.expr);\n@@ -1007,2 +992,2 @@\n-        this.scan(tree.expr);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.expr);\n+        refs.discardExprs(depth);\n@@ -1057,4 +1042,4 @@\n-        this.scan(tree.lhs);\n-        this.refs.discardExprs(this.depth);\n-        this.scan(tree.rhs);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        refs.discardExprs(depth);\n@@ -1065,2 +1050,2 @@\n-        this.scan(tree.arg);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.arg);\n+        refs.discardExprs(depth);\n@@ -1071,4 +1056,4 @@\n-        this.scan(tree.lhs);\n-        this.refs.discardExprs(this.depth);\n-        this.scan(tree.rhs);\n-        this.refs.discardExprs(this.depth);\n+        scan(tree.lhs);\n+        refs.discardExprs(depth);\n+        scan(tree.rhs);\n+        refs.discardExprs(depth);\n@@ -1086,4 +1071,4 @@\n-        final DiagnosticPosition[] pendingWarningPrev = this.pendingWarning;\n-        this.pendingWarning = null;\n-        final RefSet<Ref> refsPrev = this.refs.clone();\n-        final boolean deferredCodeLeaks;\n+        DiagnosticPosition[] pendingWarningPrev = pendingWarning;\n+        pendingWarning = null;\n+        RefSet<Ref> refsPrev = refs.clone();\n+        boolean deferredCodeLeaks;\n@@ -1092,1 +1077,1 @@\n-            deferredCodeLeaks = this.pendingWarning != null;\n+            deferredCodeLeaks = pendingWarning != null;\n@@ -1094,2 +1079,2 @@\n-            this.refs = refsPrev;\n-            this.pendingWarning = pendingWarningPrev;\n+            refs = refsPrev;\n+            pendingWarning = pendingWarningPrev;\n@@ -1098,1 +1083,1 @@\n-            this.refs.add(ExprRef.indirect(this.depth));\n+            refs.add(ExprRef.indirect(depth));\n@@ -1103,1 +1088,1 @@\n-        this.visitScoped(tree, false, t -> {\n+        visitScoped(tree, false, t -> {\n@@ -1105,1 +1090,1 @@\n-                final RefSet<Ref> prevRefs = this.refs.clone();\n+                RefSet<Ref> prevRefs = refs.clone();\n@@ -1107,1 +1092,1 @@\n-                if (this.refs.equals(prevRefs))\n+                if (refs.equals(prevRefs))\n@@ -1115,1 +1100,1 @@\n-        this.pushScope();\n+        pushScope();\n@@ -1119,1 +1104,1 @@\n-            Assert.check(this.checkInvariants(true, false));\n+            Assert.check(checkInvariants(true, false));\n@@ -1121,1 +1106,1 @@\n-            Assert.check(this.checkInvariants(true, promote));\n+            Assert.check(checkInvariants(true, promote));\n@@ -1125,2 +1110,1 @@\n-                this.refs.removeExprs(this.depth,\n-                    direct -> this.refs.add(new ExprRef(this.depth - 1, direct)));\n+                refs.removeExprs(depth, direct -> refs.add(new ExprRef(depth - 1, direct)));\n@@ -1129,1 +1113,1 @@\n-            this.popScope();\n+            popScope();\n@@ -1134,1 +1118,1 @@\n-        this.depth++;\n+        depth++;\n@@ -1138,3 +1122,3 @@\n-        Assert.check(this.depth >= 0);\n-        this.depth--;\n-        this.refs.removeIf(ref -> ref.getDepth() > this.depth);\n+        Assert.check(depth >= 0);\n+        depth--;\n+        refs.removeIf(ref -> ref.getDepth() > depth);\n@@ -1147,1 +1131,1 @@\n-        if (this.pendingWarning != null)\n+        if (pendingWarning != null)\n@@ -1151,3 +1135,3 @@\n-        this.callStack.push(tree.pos());\n-        this.pendingWarning = this.callStack.toArray(new DiagnosticPosition[0]);\n-        this.callStack.pop();\n+        callStack.push(tree.pos());\n+        pendingWarning = callStack.toArray(new DiagnosticPosition[0]);\n+        callStack.pop();\n@@ -1158,1 +1142,1 @@\n-        if (this.pendingWarning == null)\n+        if (pendingWarning == null)\n@@ -1160,2 +1144,2 @@\n-        this.warningList.add(this.pendingWarning);\n-        this.pendingWarning = null;\n+        warningList.add(pendingWarning);\n+        pendingWarning = null;\n@@ -1172,3 +1156,35 @@\n-    \/\/ Is type A a subtype of B when both types are erased?\n-    private boolean isSubtype(Type a, Type b) {\n-        return this.types.isSubtypeUnchecked(this.types.erasure(a), this.types.erasure(b));\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n+            case IDENT:\n+            {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this;\n+            }\n+            case SELECT:\n+            {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(CLASS))\n+                    return false;\n+                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this &&\n+                            (currentClassSym == selectedClassSym ||\n+                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n@@ -1181,1 +1197,1 @@\n-        return this.targetClass != null;\n+        return targetClass != null;\n@@ -1188,9 +1204,9 @@\n-        Assert.check(analyzing == this.isAnalyzing());\n-        if (this.isAnalyzing()) {\n-            Assert.check(this.methodClass != null);\n-            Assert.check(this.targetClass != null);\n-            Assert.check(this.refs != null);\n-            Assert.check(this.depth >= 0);\n-            Assert.check(this.refs.stream().noneMatch(ref -> ref.getDepth() > this.depth));\n-            Assert.check(allowExpr || !this.refs.contains(ExprRef.direct(this.depth)));\n-            Assert.check(allowExpr || !this.refs.contains(ExprRef.indirect(this.depth)));\n+        Assert.check(analyzing == isAnalyzing());\n+        if (isAnalyzing()) {\n+            Assert.check(methodClass != null);\n+            Assert.check(targetClass != null);\n+            Assert.check(refs != null);\n+            Assert.check(depth >= 0);\n+            Assert.check(refs.stream().noneMatch(ref -> ref.getDepth() > depth));\n+            Assert.check(allowExpr || !refs.contains(ExprRef.direct(depth)));\n+            Assert.check(allowExpr || !refs.contains(ExprRef.indirect(depth)));\n@@ -1198,6 +1214,6 @@\n-            Assert.check(this.targetClass == null);\n-            Assert.check(this.refs == null);\n-            Assert.check(this.depth == -1);\n-            Assert.check(this.callStack.isEmpty());\n-            Assert.check(this.pendingWarning == null);\n-            Assert.check(this.invocations.isEmpty());\n+            Assert.check(targetClass == null);\n+            Assert.check(refs == null);\n+            Assert.check(depth == -1);\n+            Assert.check(callStack.isEmpty());\n+            Assert.check(pendingWarning == null);\n+            Assert.check(invocations.isEmpty());\n@@ -1226,1 +1242,1 @@\n-            return this.depth;\n+            return depth;\n@@ -1230,1 +1246,1 @@\n-            return this.direct;\n+            return direct;\n@@ -1235,3 +1251,3 @@\n-            return this.getClass().hashCode()\n-                ^ Integer.hashCode(this.depth)\n-                ^ Boolean.hashCode(this.direct);\n+            return getClass().hashCode()\n+                ^ Integer.hashCode(depth)\n+                ^ Boolean.hashCode(direct);\n@@ -1244,1 +1260,1 @@\n-            if (obj == null || obj.getClass() != this.getClass())\n+            if (obj == null || obj.getClass() != getClass())\n@@ -1246,3 +1262,3 @@\n-            final Ref that = (Ref)obj;\n-            return this.depth == that.depth\n-              && this.direct == that.direct;\n+            Ref that = (Ref)obj;\n+            return depth == that.depth\n+              && direct == that.direct;\n@@ -1253,3 +1269,3 @@\n-            final ArrayList<String> properties = new ArrayList<>();\n-            this.addProperties(properties);\n-            return this.getClass().getSimpleName()\n+            ArrayList<String> properties = new ArrayList<>();\n+            addProperties(properties);\n+            return getClass().getSimpleName()\n@@ -1260,2 +1276,2 @@\n-            properties.add(\"depth=\" + this.depth);\n-            properties.add(this.direct ? \"direct\" : \"indirect\");\n+            properties.add(\"depth=\" + depth);\n+            properties.add(direct ? \"direct\" : \"indirect\");\n@@ -1289,8 +1305,0 @@\n-\n-        public static OuterRef direct() {\n-            return new OuterRef(true);\n-        }\n-\n-        public static OuterRef indirect() {\n-            return new OuterRef(false);\n-        }\n@@ -1324,0 +1332,1 @@\n+    }\n@@ -1325,3 +1334,3 @@\n-        public static ReturnRef direct() {\n-            return new ReturnRef(true);\n-        }\n+    \/** A reference from the yield value of the current switch expression.\n+     *\/\n+    private static class YieldRef extends Ref {\n@@ -1329,2 +1338,2 @@\n-        public static ReturnRef indirect() {\n-            return new ReturnRef(false);\n+        YieldRef(boolean direct) {\n+            super(0, direct);\n@@ -1346,1 +1355,1 @@\n-            return this.sym;\n+            return sym;\n@@ -1360,1 +1369,1 @@\n-                ^ Objects.hashCode(this.sym);\n+                ^ Objects.hashCode(sym);\n@@ -1369,2 +1378,2 @@\n-            final VarRef that = (VarRef)obj;\n-            return Objects.equals(this.sym, that.sym);\n+            VarRef that = (VarRef)obj;\n+            return Objects.equals(sym, that.sym);\n@@ -1376,1 +1385,1 @@\n-            properties.add(\"sym=\" + this.sym);\n+            properties.add(\"sym=\" + sym);\n@@ -1396,1 +1405,1 @@\n-            return this.remove(ExprRef.direct(depth)) | this.remove(ExprRef.indirect(depth));\n+            return remove(ExprRef.direct(depth)) | remove(ExprRef.indirect(depth));\n@@ -1418,0 +1427,14 @@\n+        \/**\n+         * Replace any references of the given type.\n+         *\/\n+        public void replace(Class<? extends Ref> type, Function<Boolean, ? extends T> mapper) {\n+            final List<Ref> oldRefs = this.stream()\n+              .filter(type::isInstance)\n+              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n+            this.removeAll(oldRefs);\n+            oldRefs.stream()\n+              .map(Ref::isDirect)\n+              .map(mapper)\n+              .forEach(this::add);\n+        }\n+\n@@ -1422,1 +1445,14 @@\n-            this.removeExprs(depth, direct -> this.add(mapper.apply(direct)));\n+            removeExprs(depth, direct -> add(mapper.apply(direct)));\n+        }\n+\n+        \/**\n+         * Find references of the given type, map them, and add them to {@code dest}.\n+         *\/\n+        public <S extends Ref> void mapInto(RefSet<S> dest, Class<? extends Ref> type,\n+                Function<Boolean, ? extends S> mapper) {\n+            final List<S> newRefs = this.stream()\n+              .filter(type::isInstance)\n+              .map(Ref::isDirect)\n+              .map(mapper)\n+              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n+            dest.addAll(newRefs);\n@@ -1451,1 +1487,1 @@\n-            return this.declaringClass;\n+            return declaringClass;\n@@ -1455,1 +1491,1 @@\n-            return this.declaration;\n+            return declaration;\n@@ -1459,1 +1495,1 @@\n-            return this.analyzable;\n+            return analyzable;\n@@ -1463,1 +1499,1 @@\n-            return this.invokable;\n+            return invokable;\n@@ -1468,4 +1504,4 @@\n-            return this.getClass().getSimpleName()\n-              + \"[meth=\" + this.declaringClass.name + \".\" + this.declaration.name + \"()\"\n-              + (this.analyzable ? \",analyzable\" : \"\")\n-              + (this.invokable ? \",invokable\" : \"\")\n+            return getClass().getSimpleName()\n+              + \"[meth=\" + declaringClass.name + \".\" + declaration.name + \"()\"\n+              + (analyzable ? \",analyzable\" : \"\")\n+              + (invokable ? \",invokable\" : \"\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":402,"deletions":366,"binary":false,"changes":768,"status":"modified"},{"patch":"@@ -216,35 +216,0 @@\n-    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n-     *  class currently being compiled. This is true if tree is:\n-     *  - An unqualified 'this' identifier\n-     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *    but also NOT an enclosing outer class of 'currentClass'.\n-     *\/\n-    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isExplicitThisReference(types, currentClass, skipParens(tree));\n-            case IDENT:\n-            {\n-                JCIdent ident = (JCIdent)tree;\n-                Names names = ident.name.table.names;\n-                return ident.name == names._this;\n-            }\n-            case SELECT:\n-            {\n-                JCFieldAccess select = (JCFieldAccess)tree;\n-                Type selectedType = types.erasure(select.selected.type);\n-                if (!selectedType.hasTag(CLASS))\n-                    return false;\n-                Type.ClassType selectedClassType = (Type.ClassType)selectedType;\n-                currentClass = (Type.ClassType)types.erasure(currentClass);\n-                Names names = select.name.table.names;\n-                return types.isSubtype(currentClass, selectedClassType) &&\n-                        (select.name == names._super ||\n-                        (select.name == names._this && !types.hasOuterClass(currentClass, selectedClassType)));\n-            }\n-            default:\n-                return false;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeThrown.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeThrown.java\n+ * @summary Verify 'this' escape detection from a thrown 'this'\n+ *\/\n+\n+public class ThisEscapeThrown extends RuntimeException {\n+\n+    public ThisEscapeThrown(Object obj) {\n+        if (obj == null)\n+            throw this;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeThrown.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeThrown.java:12:13: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeThrown.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8015831\n+ * @compile\/ref=ThisEscapeYield.out -Xlint:this-escape -XDrawDiagnostics ThisEscapeYield.java\n+ * @summary Verify 'this' escape detection handles leaks via switch expression yields\n+ *\/\n+\n+public class ThisEscapeYield {\n+\n+    public ThisEscapeYield(int x) {\n+        ThisEscapeYield y = switch (x) {\n+            case 3:\n+                if (x > 17)\n+                    yield this;\n+                else\n+                    yield null;\n+            default:\n+                yield null;\n+        };\n+        if (y != null)\n+            y.mightLeak();\n+    }\n+\n+    public void mightLeak() {\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeYield.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ThisEscapeYield.java:21:24: compiler.warn.possible.this.escape\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape\/ThisEscapeYield.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}