{"files":[{"patch":"@@ -162,1 +162,1 @@\n-JVM_LogTraceResolve\n+JVM_LogLambdaFormInvoker\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,3 +62,3 @@\n-  Symbol* helper_name  = vmSymbols::java_lang_invoke_GenerateJLIClassesHelper();\n-  Klass*  helper_klass = SystemDictionary::resolve_or_null(helper_name, THREAD);\n-  guarantee(helper_klass != NULL, \"java\/lang\/invoke\/GenerateJLIClassesHelper must exist!\");\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_null(cds_name, THREAD);\n+  guarantee(cds_klass != NULL, \"jdk\/internal\/misc\/CDS must exist!\");\n@@ -76,1 +76,1 @@\n-  \/\/ Object[] GenerateJLIClassesHelper.cdsGenerateHolderClasses(String[] lines)\n+  \/\/ Object[] CDS.generateLambdaFormHolderClasses(String[] lines)\n@@ -79,2 +79,2 @@\n-  Symbol* method = vmSymbols::cdsGenerateHolderClasses();\n-  Symbol* signrs = vmSymbols::cdsGenerateHolderClasses_signature();\n+  Symbol* method = vmSymbols::generateLambdaFormHolderClasses();\n+  Symbol* signrs = vmSymbols::generateLambdaFormHolderClasses_signature();\n@@ -83,1 +83,1 @@\n-  JavaCalls::call_static(&result, helper_klass, method, signrs, list_lines, THREAD);\n+  JavaCalls::call_static(&result, cds_klass, method, signrs, list_lines, THREAD);\n@@ -87,1 +87,1 @@\n-      log_info(cds)(\"Failed call to %s.%s\", helper_name->as_C_string(), method->as_C_string());\n+      log_info(cds)(\"Failed call to %s.%s\", cds_name->as_C_string(), method->as_C_string());\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -285,0 +285,4 @@\n+  \/* used by CDS *\/                                                                               \\\n+  template(jdk_internal_misc_CDS, \"jdk\/internal\/misc\/CDS\")                                        \\\n+  template(generateLambdaFormHolderClasses, \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n@@ -292,4 +296,0 @@\n-  \/* used by CDS *\/                                                                               \\\n-  template(java_lang_invoke_GenerateJLIClassesHelper, \"java\/lang\/invoke\/GenerateJLIClassesHelper\") \\\n-  template(cdsGenerateHolderClasses, \"cdsGenerateHolderClasses\")                                  \\\n-  template(cdsGenerateHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-JVM_LogTraceResolve(JNIEnv* env, jstring line);\n+JVM_LogLambdaFormInvoker(JNIEnv* env, jstring line);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3875,2 +3875,2 @@\n-JVM_ENTRY(void, JVM_LogTraceResolve(JNIEnv *env, jstring line))\n-  JVMWrapper(\"JVM_LogTraceResolve\");\n+JVM_ENTRY(void, JVM_LogLambdaFormInvoker(JNIEnv *env, jstring line))\n+  JVMWrapper(\"JVM_LogLambdaFormInvoker\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-                    shortenSignature(basicTypeSignature(type)) +\n-                    (TRACE_RESOLVE ? (resolvedMember != null ? \" (success)\" : \" (fail)\") : \"\");\n+                    shortenSignature(basicTypeSignature(type));\n@@ -65,1 +64,1 @@\n-                System.out.println(traceLF);\n+                System.out.println(traceLF + (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n@@ -67,1 +66,1 @@\n-            CDS.logTraceResolve(traceLF);\n+            CDS.traceLambdaFormInvoker(traceLF);\n@@ -73,2 +72,1 @@\n-            String traceSP = SPECIES_RESOLVE + \" \" + cn +\n-                    (TRACE_RESOLVE ? (salvage != null ? \" (salvaged)\" : \" (generated)\") : \"\");\n+            String traceSP = SPECIES_RESOLVE + \" \" + cn;\n@@ -76,1 +74,1 @@\n-                System.out.println(traceSP);\n+                System.out.println(traceSP + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n@@ -78,1 +76,1 @@\n-            CDS.logTraceResolve(traceSP);\n+            CDS.traceLambdaFormInvoker(traceSP);\n@@ -328,1 +326,1 @@\n-    static Map<String, byte[]> generateHolderClasses(Stream<String> traces, boolean isFromCDS)  {\n+    static Map<String, byte[]> generateHolderClasses(Stream<String> traces)  {\n@@ -336,5 +334,1 @@\n-                            if (isFromCDS) {\n-                                assert parts.length == 2;\n-                            } else {\n-                                assert parts.length == 3;\n-                            }\n+                            assert parts.length >= 2;\n@@ -374,83 +368,0 @@\n-    private static boolean isValidHolderName(String name) {\n-        return name.equals(DIRECT_HOLDER_CLASS_NAME)      ||\n-               name.equals(DELEGATING_HOLDER_CLASS_NAME)  ||\n-               name.equals(BASIC_FORMS_HOLDER_CLASS_NAME) ||\n-               name.equals(INVOKERS_HOLDER_CLASS_NAME);\n-    }\n-\n-    private static String[] END_WORDS = {\"(success)\", \"(fail)\", \"(generated)\", \"(salvaged)\"};\n-    \/\/ The line could ended with END_WORDS.\n-    private static String cdsGetString(String str) {\n-        for (String s : END_WORDS) {\n-            if (str.contains(s)) {\n-                return str.replace(s, \"\").trim();\n-            }\n-        }\n-        return str.trim();\n-    }\n-\n-    \/\/ return the valid lines, called from cdsGenerateHolderClasses which is called only from vm.\n-    \/\/ return null for invalid input\n-    private static Stream<String>  validateInputLines(String[] lines) {\n-        ArrayList<String> list = new ArrayList<String>(lines.length);\n-        for (String s: lines) {\n-            System.out.println(\"1X: \" + s);\n-            String line = cdsGetString(s);\n-            System.out.println(\"1Y: \" + line);\n-            if (!line.startsWith(\"[LF_RESOLVE]\") && !line.startsWith(\"[SPECIES_RESOLVE]\")) {\n-                System.out.println(\"Wrong prefix: \" + line);\n-                return null;\n-            }\n-\n-            String[] parts = line.split(\" \");\n-            boolean isLF = line.startsWith(\"[LF_RESOLVE]\");\n-\n-            if (isLF) {\n-                if (parts.length != 4) {\n-                    System.out.println(\"Incorrecct number of items in the line: \" + parts.length);\n-                    System.out.println(\"line: \" + line);\n-                    return null;\n-                }\n-                if (!isValidHolderName(parts[1])) {\n-                    System.out.println(\"Invalid holder class name: \" + parts[1]);\n-                    return null;\n-                }\n-            } else {\n-                if (parts.length != 2) {\n-                   System.out.println(\"Incorrect number of items in the line: \" + parts.length);\n-                   return null;\n-                }\n-           }\n-           list.add(line);\n-      }\n-      return list.stream();\n-    }\n-\n-    \/**\n-     * called from vm to generate MethodHandle holder classes\n-     * @return @code { Object[] } if holder classes can be generated.\n-     * @param lines in format of LF_RESOLVE or SPECIES_RESOLVE output\n-     *\/\n-    private static Object[] cdsGenerateHolderClasses(String[] lines) {\n-        Objects.requireNonNull(lines);\n-        try {\n-            Stream<String> validLines = validateInputLines(lines);\n-            if (validLines == null) {\n-                \/\/ invalid input, quit regeneration of holder classes\n-                return null;\n-            }\n-            Map<String, byte[]> result = generateHolderClasses(validLines, true);\n-            int size = result.size();\n-            Object[] retArray = new Object[size * 2];\n-            int index = 0;\n-            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n-                retArray[index++] = entry.getKey();\n-                retArray[index++] = entry.getValue();\n-            };\n-            return retArray;\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":8,"deletions":97,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1768,1 +1768,1 @@\n-                return GenerateJLIClassesHelper.generateHolderClasses(traces, false\/*not from cds*\/);\n+                return GenerateJLIClassesHelper.generateHolderClasses(traces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -36,1 +44,1 @@\n-    private static native void logTraceResolve0(String line);\n+    private static native void logLambdaFormInvoker(String line);\n@@ -82,1 +90,1 @@\n-    public static void logTraceResolve(String line) {\n+    public static void traceLambdaFormInvoker(String line) {\n@@ -84,1 +92,104 @@\n-            logTraceResolve0(line);\n+            logLambdaFormInvoker(line);\n+        }\n+    }\n+\n+    static final String DIRECT_HOLDER_CLASS_NAME  = \"java.lang.invoke.DirectMethodHandle$Holder\";\n+    static final String DELEGATING_HOLDER_CLASS_NAME = \"java.lang.invoke.DelegatingMethodHandle$Holder\";\n+    static final String BASIC_FORMS_HOLDER_CLASS_NAME = \"java.lang.invoke.LambdaForm$Holder\";\n+    static final String INVOKERS_HOLDER_CLASS_NAME = \"java.lang.invoke.Invokers$Holder\";\n+\n+    private static boolean isValidHolderName(String name) {\n+        return name.equals(DIRECT_HOLDER_CLASS_NAME)      ||\n+               name.equals(DELEGATING_HOLDER_CLASS_NAME)  ||\n+               name.equals(BASIC_FORMS_HOLDER_CLASS_NAME) ||\n+               name.equals(INVOKERS_HOLDER_CLASS_NAME);\n+    }\n+\n+    private static boolean isBasicTypeChar(char c) {\n+         return \"LIJFDV\".indexOf(c) >= 0;\n+    }\n+\n+    private static boolean isValidMethodType(String type) {\n+        String[] typeParts = type.split(\"_\");\n+        \/\/ check return type (second part)\n+        if (typeParts.length != 2 || typeParts[1].length() != 1\n+                || !isBasicTypeChar(typeParts[1].charAt(0))) {\n+            return false;\n+        }\n+        \/\/ first part\n+        if (!isBasicTypeChar(typeParts[0].charAt(0))) {\n+            return false;\n+        }\n+        for (int i = 1; i < typeParts[0].length(); i++) {\n+            char c = typeParts[0].charAt(i);\n+            if (!isBasicTypeChar(c)) {\n+                if (!(c >= '0' && c <= '9')) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ return null for invalid input\n+    private static Stream<String>  validateInputLines(String[] lines) {\n+        ArrayList<String> list = new ArrayList<String>(lines.length);\n+        for (String s: lines) {\n+            String line = s.trim();\n+            if (!line.startsWith(\"[LF_RESOLVE]\") && !line.startsWith(\"[SPECIES_RESOLVE]\")) {\n+                System.out.println(\"Wrong prefix: \" + line);\n+                return null;\n+            }\n+\n+            String[] parts = line.split(\" \");\n+            boolean isLF = line.startsWith(\"[LF_RESOLVE]\");\n+\n+            if (isLF) {\n+                if (parts.length != 4) {\n+                    System.out.println(\"Incorrecct number of items in the line: \" + parts.length);\n+                    System.out.println(\"line: \" + line);\n+                    return null;\n+                }\n+                if (!isValidHolderName(parts[1])) {\n+                    System.out.println(\"Invalid holder class name: \" + parts[1]);\n+                    return null;\n+                }\n+                if (!isValidMethodType(parts[3])) {\n+                    System.out.println(\"Invalid method type: \" + parts[3]);\n+                    return null;\n+                }\n+            } else {\n+                if (parts.length != 2) {\n+                   System.out.println(\"Incorrect number of items in the line: \" + parts.length);\n+                   return null;\n+                }\n+           }\n+           list.add(line);\n+      }\n+      return list.stream();\n+    }\n+\n+    \/**\n+     * called from vm to generate MethodHandle holder classes\n+     * @return @code { Object[] } if holder classes can be generated.\n+     * @param lines in format of LF_RESOLVE or SPECIES_RESOLVE output\n+     *\/\n+    private static Object[] generateLambdaFormHolderClasses(String[] lines) {\n+        Objects.requireNonNull(lines);\n+        try {\n+            Stream<String> lineStream = validateInputLines(lines);\n+            if (lineStream == null) {\n+                return null;\n+            }\n+            Map<String, byte[]> result = SharedSecrets.getJavaLangInvokeAccess().generateHolderClasses(lineStream);\n+            int size = result.size();\n+            Object[] retArray = new Object[size * 2];\n+            int index = 0;\n+            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n+                retArray[index++] = entry.getKey();\n+                retArray[index++] = entry.getValue();\n+            };\n+            return retArray;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw e;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":114,"deletions":3,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-Java_jdk_internal_misc_CDS_logTraceResolve0(JNIEnv *env, jclass jcls, jstring line) {\n-    JVM_LogTraceResolve(env, line);\n+Java_jdk_internal_misc_CDS_logLambdaFormInvoker(JNIEnv *env, jclass jcls, jstring line) {\n+    JVM_LogLambdaFormInvoker(env, line);\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    static final String MESSAGE_OK = \"Replaced class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n-    static final String MESSAGE_NOT_OK = \"Failed call to java\/lang\/invoke\/GenerateJLIClassesHelper.cdsGenerateHolderClasses\";\n+    static final String REPLACE_OK = \"Replaced class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String REPLACE_NOT_OK = \"Failed call to jdk\/internal\/misc\/CDS.generateLambdaFormHolderClasses\";\n@@ -40,1 +40,0 @@\n-\n@@ -46,2 +45,1 @@\n-        \/\/ 1. The two lines are copied from build default_jli.txt which will be add to class generating list as additional (besides the default)\n-        \/\/  classlist), but will be ignored since they will be added to the (methodType) set which already contain them.\n+        \/\/ 1. With correct line format.\n@@ -49,1 +47,1 @@\n-            \"TESTCASE 1: With correct output format\",\n+            \"TESTCASE 1: With correct line format\",\n@@ -52,1 +50,0 @@\n-                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L7_L\",\n@@ -54,1 +51,1 @@\n-                MESSAGE_OK);\n+                REPLACE_OK);\n@@ -56,1 +53,29 @@\n-        \/\/ 2. The two lines with incorrect format of function signitures lead regeneration of holder class failed.\n+        \/\/ 2. The line with incorrect (less) number of items.\n+        dumpShouldPass(\n+            \"TESTCASE 2: With incorrect (less) number of items\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic\"),\n+                \"Incorrecct number of items in the line: 3\");\n+        \/\/ 3. The two lines with non existed class name, since only 4 holder classes recognizable, all other names will be rejected.\n+        dumpShouldPass(\n+            \"TESTCASE 3: With incorrect class name will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic LL_I\"),\n+                \"Invalid holder class name: my.nonexist.package.MyNonExistClassName$holder\" );\n+        \/\/ 4. The two lines with arbitrary invoke names is OK. The method type will not be added.\n+        dumpShouldPass(\n+            \"TESTCASE 4: With incorrect invoke names is OK\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing LL_I\"),\n+                REPLACE_OK);\n+        \/\/ 5. The line with worng signature format of return type, will be rejected\n+        dumpShouldPass(\n+            \"TESTCASE 5: With incorrect signature format of return type will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_G\"),\n+                REPLACE_NOT_OK);\n+        \/\/ 6. The line with worng signature format of arg types, will be rejected\n@@ -58,1 +83,1 @@\n-            \"TESTCASE 2: With incorrect signature\",\n+            \"TESTCASE 6: With incorrect signature format of arg types will be rejected\",\n@@ -61,4 +86,3 @@\n-                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L7_L-XXX\",\n-                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I-YYY\"),\n-                MESSAGE_NOT_OK);\n-        \/\/ 3. The two lines with arbitrary invoke names is OK, also ending with any word is OK.\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic MGLL_I\"),\n+                REPLACE_NOT_OK);\n+        \/\/ 7. The line with worng prefix will ge rejected\n@@ -66,1 +90,1 @@\n-            \"TESTCASE 3: With incorrect invoke names is OK\",\n+            \"TESTCASE 7: With incorrect LF format, the line will be rejected\",\n@@ -69,4 +93,3 @@\n-                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing  L7_L (anyword)\",\n-                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing  LL_I anyword\"),\n-                MESSAGE_OK);\n-        \/\/ 4. The two lines with non existed class name, since only 4 holder classes recognizable, all other names will be ignored.\n+                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I\"),\n+                \"Wrong prefix: [LF_XYRESOLVE]\");\n+        \/\/ 8. The line with correct species format\n@@ -74,1 +97,1 @@\n-            \"TESTCASE 4: With incorrect class name will be ignored\",\n+            \"TESTCASE 8: With correct correct species format\",\n@@ -77,4 +100,3 @@\n-                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic  L7_L\",\n-                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic  LL_I\"),\n-                MESSAGE_OK);\n-        \/\/ 5. The two lines with worng LF format\n+                \"@lambda-form-invoker [SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_L\"),\n+                REPLACE_OK);\n+       \/\/ 9. The line with incorrect species length is not OK\n@@ -82,1 +104,1 @@\n-            \"TESTCASE 5: With incorrect LF format, the line will be ignored\",\n+            \"TESTCASE 9: With incorrect species length is not OK\",\n@@ -85,3 +107,2 @@\n-                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic  L7_L (any)\",\n-                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic  LL_I (any)\"),\n-                MESSAGE_OK);\n+                \"@lambda-form-invoker [SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_L L\"),\n+                \"Incorrect number of items in the line: 3\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpClassListWithLF.java","additions":49,"deletions":28,"binary":false,"changes":77,"status":"modified"}]}