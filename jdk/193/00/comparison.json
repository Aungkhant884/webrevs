{"files":[{"patch":"@@ -129,0 +129,1 @@\n+      lambdaFormInvokers.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+JVM_IsDumpLoadedClassListSetAndOpen\n@@ -161,0 +162,1 @@\n+JVM_CDSTraceResolve\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6059,1 +6059,12 @@\n-  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  if (DumpSharedSpaces) {\n+    \/\/ We want stable names for the archived hidden classes (only for static\n+    \/\/ archive for now). Spaces under default_SharedBaseAddress() will be\n+    \/\/ occupied by the archive at run time, so we know that no dynamically\n+    \/\/ loaded InstanceKlass will be placed under there.\n+    static volatile size_t counter = 0;\n+    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    jio_snprintf(addr_buf, 20, SIZE_FORMAT_HEX, new_id);\n+  } else {\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -89,0 +90,6 @@\n+    \/\/ The line is output TRACE_RESOLVE\n+    if (strncmp(_line, LambdaFormInvokers::lambda_form_invoker_tag(),\n+                strlen(LambdaFormInvokers::lambda_form_invoker_tag())) == 0) {\n+      LambdaFormInvokers::append(os::strdup((const char*)_line, mtInternal));\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-template <typename>\n-class GrowableArray;\n-class Klass;\n@@ -38,1 +35,0 @@\n-class TempNewSymbol;\n@@ -66,6 +62,1 @@\n-  \/\/ approved clients\n-  friend class ClassLoader;\n-  friend class ClassLoaderExt;\n-  friend class SystemDictionary;\n-\n- private:\n+ public:\n@@ -77,1 +68,0 @@\n- public:\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/typeArrayKlass.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/signature.hpp\"\n+\n+GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+\n+void LambdaFormInvokers::append(char* line) {\n+  if (_lambdaform_lines == NULL) {\n+    _lambdaform_lines = new GrowableArray<char*>(100);\n+  }\n+  _lambdaform_lines->append(line);\n+}\n+\n+void LambdaFormInvokers::regenerate_holder_classes(TRAPS) {\n+  assert(_lambdaform_lines != NULL, \"Bad List\");\n+  ResourceMark rm(THREAD);\n+\n+  Symbol* helper_name  = vmSymbols::java_lang_invoke_GenerateJLIClassesHelper();\n+  Klass*  helper_klass = SystemDictionary::resolve_or_null(helper_name, THREAD);\n+  guarantee(helper_klass != NULL, \"java\/lang\/invoke\/GenerateJLIClassesHelper must exist!\");\n+\n+  int len = _lambdaform_lines->length();\n+  objArrayHandle list_lines = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), len, CHECK);\n+  for (int i = 0; i < len; i++) {\n+    char* record = _lambdaform_lines->at(i);\n+    record += strlen(lambda_form_invoker_tag()) + 1; \/\/ skip the @lambda_form_invoker prefix\n+    Handle h_line = java_lang_String::create_from_str(record, CHECK);\n+    list_lines->obj_at_put(i, h_line());\n+  }\n+\n+  \/\/\n+  \/\/ Object[] GenerateJLIClassesHelper.cdsGenerateHolderClasses(String[] lines)\n+  \/\/ the returned Object[] layout:\n+  \/\/   name, byte[], name, byte[] ....\n+  Symbol* method = vmSymbols::cdsGenerateHolderClasses();\n+  Symbol* signrs = vmSymbols::cdsGenerateHolderClasses_signature();\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result, helper_klass, method, signrs, list_lines, THREAD);\n+  objArrayHandle h_array(THREAD, (objArrayOop)result.get_jobject());\n+  if (!HAS_PENDING_EXCEPTION) {\n+    if (h_array() == NULL) {\n+      log_info(cds)(\"Failed call to %s.%s\", helper_name->as_C_string(), method->as_C_string());\n+      return;\n+    }\n+  } else {\n+    log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  int sz = h_array->length();\n+  assert(sz % 2 == 0 && sz >= 2, \"Must be even size of length\");\n+  for (int i = 0; i < sz; i+= 2) {\n+    Handle h_name(THREAD, h_array->obj_at(i));\n+    typeArrayHandle h_bytes(THREAD, (typeArrayOop)h_array->obj_at(i+1));\n+    assert(h_name != NULL, \"Class name is NULL\");\n+    assert(h_bytes != NULL, \"Class bytes is NULL\");\n+    reload_class(h_name, h_bytes, THREAD);\n+  }\n+\n+}\n+\n+\/\/ class_handle - the class name, bytes_handle - the class bytes\n+void LambdaFormInvokers::reload_class(Handle name_handle, typeArrayHandle bytes_handle, TRAPS) {\n+  char* name = java_lang_String::as_utf8_string(name_handle());\n+  Symbol* class_name = SymbolTable::probe((const char*)name, (int)strlen(name));\n+  assert(class_name != NULL, \"The class should be loaded already\");\n+  \/\/ the class must exist\n+  Klass* klass = SystemDictionary::resolve_or_null(class_name, THREAD);\n+  if (klass == NULL) {\n+    log_info(cds)(\"Class %s not present, skip\", name);\n+    return;\n+  }\n+\n+  int len = bytes_handle->length();\n+  \/\/ make a copy of class bytes so GC will not affect us.\n+  char *buf = resource_allocate_bytes(THREAD, len);\n+  memcpy(buf, (char*)bytes_handle->byte_at_addr(0), len);\n+  ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Handle protection_domain;\n+  ClassLoadInfo cl_info(protection_domain);\n+\n+  InstanceKlass* result = KlassFactory::create_from_stream(&st,\n+                                                   class_name,\n+                                                   cld,\n+                                                   cl_info,\n+                                                   CHECK);\n+\n+  \/\/ free buf\n+  resource_free_bytes(buf, len);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    log_info(cds)(\"Could not create InstanceKlass for class %s\", name);\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  {\n+    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n+    SystemDictionary::add_to_hierarchy(result, THREAD);\n+  }\n+  \/\/ new class not linked yet.\n+  MetaspaceShared::try_link_class(result, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Invariant\");\n+\n+  \/\/ exclude the existing class from dump\n+  \/\/ find_class assert on SystemDictionary_lock or safepoint\n+  MutexLocker lock(SystemDictionary_lock);\n+  InstanceKlass* old = SystemDictionary::find_class(class_name, cld);\n+  assert(old != NULL, \"Should exist\");\n+  SystemDictionaryShared::set_excluded(old);\n+  log_info(cds)(\"Replace class %s, old: %p  new: %p\", name, old, result);\n+}\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#define SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+template <class T>\n+class GrowableArray;\n+\n+class LambdaFormInvokers : public AllStatic {\n+ private:\n+  static GrowableArray<char*>* _lambdaform_lines;\n+  static void reload_class(Handle name, typeArrayHandle bytes, TRAPS);\n+ public:\n+\n+  static void append(char* line);\n+  static void regenerate_holder_classes(TRAPS);\n+  static GrowableArray<char*>* lambdaform_lines() {\n+    return _lambdaform_lines;\n+  }\n+\n+  static const char* lambda_form_invoker_tag() {\n+    return \"@lambda-form-invoker\";\n+  }\n+};\n+#endif \/\/ SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1863,1 +1863,2 @@\n-\/\/ Used for assertions and verification only\n+\/\/ Used for assertions and verification, also used from LambdaFormInvokers::reload_class\n+\/\/ to get original class which has already been loaded.\n@@ -1873,1 +1874,2 @@\n-            VerifyAfterGC, \"too expensive\");\n+            VerifyAfterGC       ||\n+            DumpSharedSpaces, \"too expensive\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -626,1 +626,2 @@\n-protected:\n+  \/\/ Find class based on name and class loader data.\n+  static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);\n@@ -629,0 +630,1 @@\n+protected:\n@@ -633,1 +635,0 @@\n-  static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1410,0 +1410,8 @@\n+void SystemDictionaryShared::set_excluded(InstanceKlass* k) {\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  static void set_excluded(InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -291,1 +291,4 @@\n-                                                                                                  \\\n+  \/* used by CDS *\/                                                                               \\\n+  template(java_lang_invoke_GenerateJLIClassesHelper, \"java\/lang\/invoke\/GenerateJLIClassesHelper\") \\\n+  template(cdsGenerateHolderClasses, \"cdsGenerateHolderClasses\")                                  \\\n+  template(cdsGenerateHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -206,0 +206,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsDumpLoadedClassListSetAndOpen(JNIEnv* env);\n+\n@@ -209,0 +212,3 @@\n+JNIEXPORT void JNICALL\n+JVM_CDSTraceResolve(JNIEnv* env, jclass ignored, jstring line);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/loaderConstraints.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/loaderConstraints.hpp\"\n@@ -1087,0 +1088,7 @@\n+      log_info(cds)(\"Reading extra data: done.\");\n+    }\n+\n+    if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+      LambdaFormInvokers::regenerate_holder_classes(THREAD);\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n@@ -1088,1 +1096,0 @@\n-    log_info(cds)(\"Reading extra data: done.\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -3835,0 +3836,13 @@\n+JVM_ENTRY(void, JVM_CDSTraceResolve(JNIEnv* env, jclass ignored, jstring line))\n+  JVMWrapper(\"JVM_CDSTraceResolve\");\n+#if INCLUDE_CDS\n+  assert(DumpLoadedClassList != NULL && classlist_file->is_open(), \"Should be set and open\");\n+  if (line != NULL) {\n+    ResourceMark rm(THREAD);\n+    Handle h_line(THREAD, JNIHandles::resolve_non_null(line));\n+    char* c_line = java_lang_String::as_utf8_string(h_line());\n+    classlist_file->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n@@ -3845,0 +3859,5 @@\n+JVM_ENTRY(jboolean, JVM_IsDumpLoadedClassListSetAndOpen(JNIEnv* env))\n+    JVMWrapper(\"JVM_IsDumpLoadedClassListSetAndOpen\");\n+    return DumpLoadedClassList != NULL && classlist_file->is_open();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.VM;\n@@ -33,0 +34,1 @@\n+import java.util.Arrays;\n@@ -56,2 +58,2 @@\n-        if (TRACE_RESOLVE) {\n-            System.out.println(LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n+        if (TRACE_RESOLVE || VM.isDumpLoadedClassListSetAndOpen) {\n+            String traceLF = LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n@@ -59,1 +61,7 @@\n-                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+                    (resolvedMember != null ? \" (success)\" : \" (fail)\");\n+            if (TRACE_RESOLVE) {\n+                System.out.println(traceLF);\n+            }\n+            if (VM.isDumpLoadedClassListSetAndOpen) {\n+                VM.cdsTraceResolve(traceLF);\n+            }\n@@ -64,2 +72,8 @@\n-        if (TRACE_RESOLVE) {\n-            System.out.println(SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n+        if (TRACE_RESOLVE || VM.isDumpLoadedClassListSetAndOpen) {\n+            String traceSP = SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\");\n+            if (TRACE_RESOLVE) {\n+                System.out.println(traceSP);\n+            }\n+            if (VM.isDumpLoadedClassListSetAndOpen) {\n+                VM.cdsTraceResolve(traceSP);\n+            }\n@@ -353,0 +367,24 @@\n+    \/**\n+     * called from vm to generate MethodHandle holder classes\n+     * @return @code { Object[] } if holder classes can be generated.\n+     * @param lines the output lines from @code { VM.cdsTraceResolve }\n+     *\/\n+    static Object[] cdsGenerateHolderClasses(String[] lines) {\n+        try {\n+            Map<String, byte[]> result = generateHolderClasses(Arrays.stream(lines));\n+            if (result == null) {\n+                return null;\n+            }\n+            int size = result.size();\n+            Object[] ret_array = new Object[size * 2];\n+            int index = 0;\n+            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n+                ret_array[index++] = entry.getKey();\n+                ret_array[index++] = entry.getValue();\n+            };\n+            return ret_array;\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -457,0 +457,1 @@\n+        isDumpLoadedClassListSetAndOpen = isDumpLoadedClassListSetAndOpen0();\n@@ -485,0 +486,13 @@\n+    \/**\n+     * Check if DumpLoadedClassList is set and the file is open.\n+     *\/\n+    public static boolean isDumpLoadedClassListSetAndOpen;\n+    private static native boolean isDumpLoadedClassListSetAndOpen0();\n+\n+    \/**\n+     * Output to DumpLoadedClassList, format is simimar to LF_RESOLVE\n+     * @see InvokerBytecodeGenerator\n+     * @param line the line to output.\n+     *\/\n+    public static native void cdsTraceResolve(String line);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,0 +86,10 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_misc_VM_isDumpLoadedClassListSetAndOpen0(JNIEnv *env, jclass jcls) {\n+    return JVM_IsDumpLoadedClassListSetAndOpen(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_VM_cdsTraceResolve(JNIEnv *env, jclass ignore, jstring line) {\n+    JVM_CDSTraceResolve(env, ignore, line);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/VM.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}