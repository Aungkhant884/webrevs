{"files":[{"patch":"@@ -129,0 +129,1 @@\n+      lambdaFormInvokers.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+JVM_IsDumpLoadedClassListSetAndOpen\n@@ -161,0 +162,1 @@\n+JVM_LogTraceResolve\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6059,1 +6059,12 @@\n-  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  if (DumpSharedSpaces) {\n+    \/\/ We want stable names for the archived hidden classes (only for static\n+    \/\/ archive for now). Spaces under default_SharedBaseAddress() will be\n+    \/\/ occupied by the archive at run time, so we know that no dynamically\n+    \/\/ loaded InstanceKlass will be placed under there.\n+    static volatile size_t counter = 0;\n+    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    jio_snprintf(addr_buf, 20, SIZE_FORMAT_HEX, new_id);\n+  } else {\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -89,0 +90,6 @@\n+    \/\/ The line is output TRACE_RESOLVE\n+    if (strncmp(_line, LambdaFormInvokers::lambda_form_invoker_tag(),\n+                strlen(LambdaFormInvokers::lambda_form_invoker_tag())) == 0) {\n+      LambdaFormInvokers::append(os::strdup((const char*)_line, mtInternal));\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-template <typename>\n-class GrowableArray;\n-class Klass;\n@@ -38,1 +35,0 @@\n-class TempNewSymbol;\n@@ -66,6 +62,1 @@\n-  \/\/ approved clients\n-  friend class ClassLoader;\n-  friend class ClassLoaderExt;\n-  friend class SystemDictionary;\n-\n- private:\n+ public:\n@@ -77,1 +68,0 @@\n- public:\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/typeArrayKlass.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+\n+void LambdaFormInvokers::append(char* line) {\n+  if (_lambdaform_lines == NULL) {\n+    _lambdaform_lines = new GrowableArray<char*>(100);\n+  }\n+  _lambdaform_lines->append(line);\n+}\n+\n+void LambdaFormInvokers::regenerate_holder_classes(TRAPS) {\n+  assert(_lambdaform_lines != NULL, \"Bad List\");\n+  ResourceMark rm(THREAD);\n+\n+  Symbol* helper_name  = vmSymbols::java_lang_invoke_GenerateJLIClassesHelper();\n+  Klass*  helper_klass = SystemDictionary::resolve_or_null(helper_name, THREAD);\n+  guarantee(helper_klass != NULL, \"java\/lang\/invoke\/GenerateJLIClassesHelper must exist!\");\n+\n+  int len = _lambdaform_lines->length();\n+  objArrayHandle list_lines = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), len, CHECK);\n+  for (int i = 0; i < len; i++) {\n+    char* record = _lambdaform_lines->at(i);\n+    record += strlen(lambda_form_invoker_tag()) + 1; \/\/ skip the @lambda_form_invoker prefix\n+    Handle h_line = java_lang_String::create_from_str(record, CHECK);\n+    list_lines->obj_at_put(i, h_line());\n+  }\n+\n+  \/\/\n+  \/\/ Object[] GenerateJLIClassesHelper.cdsGenerateHolderClasses(String[] lines)\n+  \/\/ the returned Object[] layout:\n+  \/\/   name, byte[], name, byte[] ....\n+  Symbol* method = vmSymbols::cdsGenerateHolderClasses();\n+  Symbol* signrs = vmSymbols::cdsGenerateHolderClasses_signature();\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result, helper_klass, method, signrs, list_lines, THREAD);\n+  objArrayHandle h_array(THREAD, (objArrayOop)result.get_jobject());\n+  if (!HAS_PENDING_EXCEPTION) {\n+    if (h_array() == NULL) {\n+      log_info(cds)(\"Failed call to %s.%s\", helper_name->as_C_string(), method->as_C_string());\n+      return;\n+    }\n+  } else {\n+    log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  int sz = h_array->length();\n+  assert(sz % 2 == 0 && sz >= 2, \"Must be even size of length\");\n+  for (int i = 0; i < sz; i+= 2) {\n+    Handle h_name(THREAD, h_array->obj_at(i));\n+    typeArrayHandle h_bytes(THREAD, (typeArrayOop)h_array->obj_at(i+1));\n+    assert(h_name != NULL, \"Class name is NULL\");\n+    assert(h_bytes != NULL, \"Class bytes is NULL\");\n+    reload_class(h_name, h_bytes, THREAD);\n+  }\n+\n+}\n+\n+\/\/ class_handle - the class name, bytes_handle - the class bytes\n+void LambdaFormInvokers::reload_class(Handle name_handle, typeArrayHandle bytes_handle, TRAPS) {\n+  char* name = java_lang_String::as_utf8_string(name_handle());\n+  Symbol* class_name = SymbolTable::new_symbol((const char*)name);\n+  \/\/ the class must exist\n+  Klass* klass = SystemDictionary::resolve_or_null(class_name, THREAD);\n+  assert(klass->is_instance_klass(), \"Should be\");\n+  if (klass == NULL) {\n+    log_info(cds)(\"Class %s not present, skip\", name);\n+    return;\n+  }\n+\n+  int len = bytes_handle->length();\n+  \/\/ make a copy of class bytes so GC will not affect us.\n+  char *buf = resource_allocate_bytes(THREAD, len);\n+  memcpy(buf, (char*)bytes_handle->byte_at_addr(0), len);\n+  ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Handle protection_domain;\n+  ClassLoadInfo cl_info(protection_domain);\n+\n+  InstanceKlass* result = KlassFactory::create_from_stream(&st,\n+                                                   class_name,\n+                                                   cld,\n+                                                   cl_info,\n+                                                   CHECK);\n+\n+  \/\/ free buf\n+  resource_free_bytes(buf, len);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    log_info(cds)(\"Could not create InstanceKlass for class %s\", name);\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  {\n+    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n+    SystemDictionary::add_to_hierarchy(result, THREAD);\n+  }\n+  \/\/ new class not linked yet.\n+  MetaspaceShared::try_link_class(result, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Invariant\");\n+\n+  \/\/ exclude the existing class from dump\n+  SystemDictionaryShared::set_excluded(InstanceKlass::cast(klass));\n+  log_info(cds)(\"Replaced class %s, old: %p  new: %p\", name, klass, result);\n+}\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#define SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+\n+template <class T>\n+class GrowableArray;\n+\n+class LambdaFormInvokers : public AllStatic {\n+ private:\n+  static GrowableArray<char*>* _lambdaform_lines;\n+  static void reload_class(Handle name, typeArrayHandle bytes, TRAPS);\n+ public:\n+\n+  static void append(char* line);\n+  static void regenerate_holder_classes(TRAPS);\n+  static GrowableArray<char*>* lambdaform_lines() {\n+    return _lambdaform_lines;\n+  }\n+\n+  static const char* lambda_form_invoker_tag() {\n+    return \"@lambda-form-invoker\";\n+  }\n+};\n+#endif \/\/ SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1863,1 +1863,2 @@\n-\/\/ Used for assertions and verification only\n+\/\/ Used for assertions and verification, also used from LambdaFormInvokers::reload_class\n+\/\/ to get original class which has already been loaded.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -627,1 +627,0 @@\n-protected:\n@@ -630,0 +629,1 @@\n+protected:\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1410,0 +1410,8 @@\n+void SystemDictionaryShared::set_excluded(InstanceKlass* k) {\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  static void set_excluded(InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -292,1 +292,4 @@\n-                                                                                                  \\\n+  \/* used by CDS *\/                                                                               \\\n+  template(java_lang_invoke_GenerateJLIClassesHelper, \"java\/lang\/invoke\/GenerateJLIClassesHelper\") \\\n+  template(cdsGenerateHolderClasses, \"cdsGenerateHolderClasses\")                                  \\\n+  template(cdsGenerateHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -206,0 +206,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsDumpLoadedClassListSetAndOpen(JNIEnv* env);\n+\n@@ -209,0 +212,3 @@\n+JNIEXPORT void JNICALL\n+JVM_LogTraceResolve(JNIEnv* env, jstring line);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/loaderConstraints.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/loaderConstraints.hpp\"\n@@ -1043,0 +1044,7 @@\n+      log_info(cds)(\"Reading extra data: done.\");\n+    }\n+\n+    if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+      LambdaFormInvokers::regenerate_holder_classes(THREAD);\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n@@ -1044,1 +1052,0 @@\n-    log_info(cds)(\"Reading extra data: done.\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -3869,0 +3870,18 @@\n+JVM_ENTRY(jboolean, JVM_IsDumpLoadedClassListSetAndOpen(JNIEnv *env))\n+  JVMWrapper(\"JVM_IsDumpLoadedClassListSetAndOpen\");\n+  return DumpLoadedClassList != NULL && classlist_file->is_open();\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_LogTraceResolve(JNIEnv *env, jstring line))\n+  JVMWrapper(\"JVM_LogTraceResolve\");\n+#if INCLUDE_CDS\n+  assert(DumpLoadedClassList != NULL && classlist_file->is_open(), \"Should be set and open\");\n+  if (line != NULL) {\n+    ResourceMark rm(THREAD);\n+    Handle h_line (THREAD, JNIHandles::resolve_non_null(line));\n+    char* c_line = java_lang_String::as_utf8_string(h_line());\n+    classlist_file->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.misc.CDS;\n+import jdk.internal.misc.VM;\n@@ -33,0 +35,1 @@\n+import java.util.Arrays;\n@@ -56,2 +59,2 @@\n-        if (TRACE_RESOLVE) {\n-            System.out.println(LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n+        if (TRACE_RESOLVE || CDS.isDumpLoadedClassList()) {\n+            String traceLF = LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n@@ -59,1 +62,5 @@\n-                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+                    (resolvedMember != null ? \" (success)\" : \" (fail)\");\n+            if (TRACE_RESOLVE) {\n+                System.out.println(traceLF);\n+            }\n+            CDS.logTraceResolve(traceLF);\n@@ -64,2 +71,6 @@\n-        if (TRACE_RESOLVE) {\n-            System.out.println(SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n+        if (TRACE_RESOLVE || CDS.isDumpLoadedClassList()) {\n+            String traceSP = SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\");\n+            if (TRACE_RESOLVE) {\n+                System.out.println(traceSP);\n+            }\n+            CDS.logTraceResolve(traceSP);\n@@ -353,0 +364,24 @@\n+    \/**\n+     * called from vm to generate MethodHandle holder classes\n+     * @return @code { Object[] } if holder classes can be generated.\n+     * @param lines the output lines from @code { VM.cdsTraceResolve }\n+     *\/\n+    static Object[] cdsGenerateHolderClasses(String[] lines) {\n+        try {\n+            Map<String, byte[]> result = generateHolderClasses(Arrays.stream(lines));\n+            if (result == null) {\n+                return null;\n+            }\n+            int size = result.size();\n+            Object[] ret_array = new Object[size * 2];\n+            int index = 0;\n+            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n+                ret_array[index++] = entry.getKey();\n+                ret_array[index++] = entry.getValue();\n+            };\n+            return ret_array;\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,9 @@\n+    \/\/ cache the result\n+    static private boolean isDumpLoadedClassList;\n+    static {\n+        isDumpLoadedClassList = isDumpLoadedClassListSetAndOpen();\n+    }\n+\n+    private static native boolean isDumpLoadedClassListSetAndOpen();\n+    private static native void logTraceResolve0(String line);\n+\n@@ -62,0 +71,16 @@\n+\n+    \/**\n+     * check if -XX:+DumpLoadedClassList and given file is open\n+     *\/\n+    public static boolean isDumpLoadedClassList() {\n+        return isDumpLoadedClassList;\n+    }\n+\n+    \/**\n+     * log output to DumpLoadedClassList\n+     *\/\n+    public static void logTraceResolve(String line) {\n+        if (isDumpLoadedClassList) {\n+            logTraceResolve0(line);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_misc_CDS_isDumpLoadedClassListSetAndOpen(JNIEnv *env, jclass jcls) {\n+    return JVM_IsDumpLoadedClassListSetAndOpen(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_logTraceResolve0(JNIEnv *env, jclass jcls, jstring line) {\n+    JVM_LogTraceResolve(env, line);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -333,0 +333,1 @@\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * Base class for ClassListFormat[A,B,C...].java\n+ * Base class for DumpClassListWithLF, customerLoader\/ClassListFormat[A,B,C...].java\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ClassListFormatBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatBase.java","status":"renamed"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests the format checking of LF_RESOLVE in classlist.\n+ *\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile ClassListFormatBase.java test-classes\/Hello.java\n+ * @run driver DumpClassListWithLF\n+ *\/\n+\n+public class DumpClassListWithLF extends ClassListFormatBase {\n+    static final String MESSAGE_OK = \"Replaced class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String MESSAGE_NOT_OK = \"Failed call to java\/lang\/invoke\/GenerateJLIClassesHelper.cdsGenerateHolderClasses\";\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        \/\/\n+        \/\/ Note the class regeneration via java\/lang\/invoke\/GenerateJLIClassesHelper.cdsGenerateHolderClasses(String[] lines)\n+        \/\/ Whether the regeneration successes or fails, the dump should pass. Only the message can be checked for result.\n+        \/\/\n+        \/\/ 1. The two lines are copied from build default_jli.txt which will be add to class generating list as additional (besides the default)\n+        \/\/  classlist), but will be ignored since they will be added to the (methodType) set which already contain them.\n+        dumpShouldPass(\n+            \"TESTCASE 1: With correct output format\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L7_L (success)\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I (success)\"),\n+                MESSAGE_OK);\n+\n+        \/\/ 2. The two lines with incorrect format of function signitures lead regeneration of holder class failed.\n+        dumpShouldPass(\n+            \"TESTCASE 2: With incorrect signature\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L7_L-XXX (success)\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I-YYY (success)\"),\n+                MESSAGE_NOT_OK);\n+        \/\/ 3. The two lines with arbitrary invoke names is OK.\n+        dumpShouldPass(\n+            \"TESTCASE 3: With incorrect invoke names is OK\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing  L7_L (success)\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing  LL_I (success)\"),\n+                MESSAGE_OK);\n+        \/\/ 4. The two lines with non existed class name, since only 4 holder classes recognizable, all other names will be ignored.\n+        dumpShouldPass(\n+            \"TESTCASE 4: With incorrect class name will be ignored\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic  L7_L (success)\",\n+                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic  LL_I (success)\"),\n+                MESSAGE_OK);\n+        \/\/ 5. The two lines with worng LF format\n+        dumpShouldPass(\n+            \"TESTCASE 5: With incorrect LF format, the line will be ignored\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic  L7_L (success)\",\n+                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic  LL_I (success)\"),\n+                MESSAGE_OK);\n+        \/\/ 6. The line with manually setup signature\n+        dumpShouldPass(\n+            \"TESTCASE 6: With manually setup for signature\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker java.lang.invoke.DirectMethodHandle$Holder newInvokeSpecial LLLL_L (success)\"),\n+                MESSAGE_OK);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpClassListWithLF.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @compile ClassListFormatBase.java ..\/test-classes\/Hello.java test-classes\/InProhibitedPkg.java\n+ * @compile ..\/ClassListFormatBase.java ..\/test-classes\/Hello.java test-classes\/InProhibitedPkg.java\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ProhibitedPackageNamesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}