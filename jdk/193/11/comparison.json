{"files":[{"patch":"@@ -129,0 +129,1 @@\n+      lambdaFormInvokers.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+JVM_IsDumpingClassList\n@@ -161,0 +162,1 @@\n+JVM_LogLambdaFormInvoker\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6059,1 +6059,12 @@\n-  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  if (DumpSharedSpaces) {\n+    \/\/ We want stable names for the archived hidden classes (only for static\n+    \/\/ archive for now). Spaces under default_SharedBaseAddress() will be\n+    \/\/ occupied by the archive at run time, so we know that no dynamically\n+    \/\/ loaded InstanceKlass will be placed under there.\n+    static volatile size_t counter = 0;\n+    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    jio_snprintf(addr_buf, 20, SIZE_FORMAT_HEX, new_id);\n+  } else {\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -89,0 +90,6 @@\n+    \/\/ The line is output TRACE_RESOLVE\n+    if (strncmp(_line, LambdaFormInvokers::lambda_form_invoker_tag(),\n+                strlen(LambdaFormInvokers::lambda_form_invoker_tag())) == 0) {\n+      LambdaFormInvokers::append(os::strdup((const char*)_line, mtInternal));\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-template <typename>\n-class GrowableArray;\n-class Klass;\n@@ -38,1 +35,0 @@\n-class TempNewSymbol;\n@@ -66,6 +62,1 @@\n-  \/\/ approved clients\n-  friend class ClassLoader;\n-  friend class ClassLoaderExt;\n-  friend class SystemDictionary;\n-\n- private:\n+ public:\n@@ -77,1 +68,0 @@\n- public:\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+\n+void LambdaFormInvokers::append(char* line) {\n+  if (_lambdaform_lines == NULL) {\n+    _lambdaform_lines = new GrowableArray<char*>(100);\n+  }\n+  _lambdaform_lines->append(line);\n+}\n+\n+void LambdaFormInvokers::regenerate_holder_classes(TRAPS) {\n+  assert(_lambdaform_lines != NULL, \"Bad List\");\n+  ResourceMark rm(THREAD);\n+\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_null(cds_name, THREAD);\n+  guarantee(cds_klass != NULL, \"jdk\/internal\/misc\/CDS must exist!\");\n+\n+  int len = _lambdaform_lines->length();\n+  objArrayHandle list_lines = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), len, CHECK);\n+  for (int i = 0; i < len; i++) {\n+    char* record = _lambdaform_lines->at(i);\n+    record += strlen(lambda_form_invoker_tag()) + 1; \/\/ skip the @lambda_form_invoker prefix\n+    Handle h_line = java_lang_String::create_from_str(record, CHECK);\n+    list_lines->obj_at_put(i, h_line());\n+  }\n+\n+  \/\/\n+  \/\/ Object[] CDS.generateLambdaFormHolderClasses(String[] lines)\n+  \/\/ the returned Object[] layout:\n+  \/\/   name, byte[], name, byte[] ....\n+  Symbol* method = vmSymbols::generateLambdaFormHolderClasses();\n+  Symbol* signrs = vmSymbols::generateLambdaFormHolderClasses_signature();\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result, cds_klass, method, signrs, list_lines, THREAD);\n+  objArrayHandle h_array(THREAD, (objArrayOop)result.get_jobject());\n+  if (!HAS_PENDING_EXCEPTION) {\n+    if (h_array() == NULL) {\n+      log_info(cds)(\"Failed call to %s.%s\", cds_name->as_C_string(), method->as_C_string());\n+      return;\n+    }\n+  } else {\n+    log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  int sz = h_array->length();\n+  assert(sz % 2 == 0 && sz >= 2, \"Must be even size of length\");\n+  for (int i = 0; i < sz; i+= 2) {\n+    Handle h_name(THREAD, h_array->obj_at(i));\n+    typeArrayHandle h_bytes(THREAD, (typeArrayOop)h_array->obj_at(i+1));\n+    assert(h_name != NULL, \"Class name is NULL\");\n+    assert(h_bytes != NULL, \"Class bytes is NULL\");\n+\n+    char *class_name = java_lang_String::as_utf8_string(h_name());\n+    int len = h_bytes->length();\n+    \/\/ make a copy of class bytes so GC will not affect us.\n+    char *buf = resource_allocate_bytes(THREAD, len);\n+    memcpy(buf, (char*)h_bytes->byte_at_addr(0), len);\n+    ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+\n+    reload_class(class_name, st, THREAD);\n+    \/\/ free buf\n+    resource_free_bytes(buf, len);\n+\n+    if (HAS_PENDING_EXCEPTION) {\n+      log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n+      log_info(cds)(\"Could not create InstanceKlass for class %s\", class_name);\n+      CLEAR_PENDING_EXCEPTION;\n+      return;\n+    }\n+  }\n+}\n+\n+\/\/ class_handle - the class name, bytes_handle - the class bytes\n+void LambdaFormInvokers::reload_class(char* name, ClassFileStream& st, TRAPS) {\n+  Symbol* class_name = SymbolTable::new_symbol((const char*)name);\n+  \/\/ the class must exist\n+  Klass* klass = SystemDictionary::resolve_or_null(class_name, THREAD);\n+  assert(klass->is_instance_klass(), \"Should be\");\n+  if (klass == NULL) {\n+    log_info(cds)(\"Class %s not present, skip\", name);\n+    return;\n+  }\n+\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Handle protection_domain;\n+  ClassLoadInfo cl_info(protection_domain);\n+\n+  InstanceKlass* result = KlassFactory::create_from_stream(&st,\n+                                                   class_name,\n+                                                   cld,\n+                                                   cl_info,\n+                                                   CHECK);\n+\n+  {\n+    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n+    SystemDictionary::add_to_hierarchy(result, THREAD);\n+  }\n+  \/\/ new class not linked yet.\n+  MetaspaceShared::try_link_class(result, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Invariant\");\n+\n+  \/\/ exclude the existing class from dump\n+  SystemDictionaryShared::set_excluded(InstanceKlass::cast(klass));\n+  log_info(cds)(\"Replaced class %s, old: %p  new: %p\", name, klass, result);\n+}\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#define SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+\n+template <class T>\n+class GrowableArray;\n+class ClassFileStream;\n+\n+class LambdaFormInvokers : public AllStatic {\n+ private:\n+  static GrowableArray<char*>* _lambdaform_lines;\n+  static void reload_class(char* name, ClassFileStream& st, TRAPS);\n+ public:\n+\n+  static void append(char* line);\n+  static void regenerate_holder_classes(TRAPS);\n+  static GrowableArray<char*>* lambdaform_lines() {\n+    return _lambdaform_lines;\n+  }\n+\n+  static const char* lambda_form_invoker_tag() {\n+    return \"@lambda-form-invoker\";\n+  }\n+};\n+#endif \/\/ SHARE_MEMORY_LAMBDAFORMINVOKERS_HPP\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -627,1 +627,0 @@\n-protected:\n@@ -630,0 +629,1 @@\n+protected:\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1410,0 +1410,8 @@\n+void SystemDictionaryShared::set_excluded(InstanceKlass* k) {\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  static void set_excluded(InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -285,0 +285,4 @@\n+  \/* used by CDS *\/                                                                               \\\n+  template(jdk_internal_misc_CDS, \"jdk\/internal\/misc\/CDS\")                                        \\\n+  template(generateLambdaFormHolderClasses, \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n@@ -292,1 +296,0 @@\n-                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -206,0 +206,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsDumpingClassList(JNIEnv* env);\n+\n@@ -209,0 +212,3 @@\n+JNIEXPORT void JNICALL\n+JVM_LogLambdaFormInvoker(JNIEnv* env, jstring line);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/loaderConstraints.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/loaderConstraints.hpp\"\n@@ -1043,0 +1044,7 @@\n+      log_info(cds)(\"Reading extra data: done.\");\n+    }\n+\n+    if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+      LambdaFormInvokers::regenerate_holder_classes(THREAD);\n+      log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n@@ -1044,1 +1052,0 @@\n-    log_info(cds)(\"Reading extra data: done.\");\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -3869,0 +3870,18 @@\n+JVM_ENTRY(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n+  JVMWrapper(\"JVM_IsDumpingClassList\");\n+  return DumpLoadedClassList != NULL && classlist_file->is_open();\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_LogLambdaFormInvoker(JNIEnv *env, jstring line))\n+  JVMWrapper(\"JVM_LogLambdaFormInvoker\");\n+#if INCLUDE_CDS\n+  assert(DumpLoadedClassList != NULL && classlist_file->is_open(), \"Should be set and open\");\n+  if (line != NULL) {\n+    ResourceMark rm(THREAD);\n+    Handle h_line (THREAD, JNIHandles::resolve_non_null(line));\n+    char* c_line = java_lang_String::as_utf8_string(h_line());\n+    classlist_file->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -35,0 +36,1 @@\n+import java.util.Objects;\n@@ -58,2 +60,5 @@\n-                    shortenSignature(basicTypeSignature(type)) +\n-                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+                     shortenSignature(basicTypeSignature(type)) +\n+                     (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+        }\n+        if (CDS.isDumpingClassList) {\n+            CDS.traceLambdaFormInvoker(LF_RESOLVE, holder.getName(), name, shortenSignature(basicTypeSignature(type)));\n@@ -67,0 +72,3 @@\n+        if (CDS.isDumpingClassList) {\n+            CDS.traceSpeciesType(SPECIES_RESOLVE, cn);\n+        }\n@@ -313,0 +321,1 @@\n+        Objects.requireNonNull(traces);\n@@ -319,1 +328,1 @@\n-                            assert parts.length == 3;\n+                            assert parts.length >= 2;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -29,0 +37,11 @@\n+    \/**\n+      * indicator for dumping class list.\n+      *\/\n+    static public final boolean isDumpingClassList;\n+    static {\n+        isDumpingClassList = isDumpingClassList0();\n+    }\n+\n+    private static native boolean isDumpingClassList0();\n+    private static native void logLambdaFormInvoker(String line);\n+\n@@ -62,0 +81,121 @@\n+\n+    \/**\n+     * log lambda form invoker holder, name and method type\n+     *\/\n+    public static void traceLambdaFormInvoker(String prefix, String holder, String name, String type) {\n+        if (isDumpingClassList) {\n+            logLambdaFormInvoker(prefix + \" \" + holder + \" \" + name + \" \" + type);\n+        }\n+    }\n+\n+    \/**\n+      * log species\n+      *\/\n+    public static void traceSpeciesType(String prefix, String cn) {\n+        if (isDumpingClassList) {\n+            logLambdaFormInvoker(prefix + \" \" + cn);\n+        }\n+    }\n+\n+    static final String DIRECT_HOLDER_CLASS_NAME  = \"java.lang.invoke.DirectMethodHandle$Holder\";\n+    static final String DELEGATING_HOLDER_CLASS_NAME = \"java.lang.invoke.DelegatingMethodHandle$Holder\";\n+    static final String BASIC_FORMS_HOLDER_CLASS_NAME = \"java.lang.invoke.LambdaForm$Holder\";\n+    static final String INVOKERS_HOLDER_CLASS_NAME = \"java.lang.invoke.Invokers$Holder\";\n+\n+    private static boolean isValidHolderName(String name) {\n+        return name.equals(DIRECT_HOLDER_CLASS_NAME)      ||\n+               name.equals(DELEGATING_HOLDER_CLASS_NAME)  ||\n+               name.equals(BASIC_FORMS_HOLDER_CLASS_NAME) ||\n+               name.equals(INVOKERS_HOLDER_CLASS_NAME);\n+    }\n+\n+    private static boolean isBasicTypeChar(char c) {\n+         return \"LIJFDV\".indexOf(c) >= 0;\n+    }\n+\n+    private static boolean isValidMethodType(String type) {\n+        String[] typeParts = type.split(\"_\");\n+        \/\/ check return type (second part)\n+        if (typeParts.length != 2 || typeParts[1].length() != 1\n+                || !isBasicTypeChar(typeParts[1].charAt(0))) {\n+            return false;\n+        }\n+        \/\/ first part\n+        if (!isBasicTypeChar(typeParts[0].charAt(0))) {\n+            return false;\n+        }\n+        for (int i = 1; i < typeParts[0].length(); i++) {\n+            char c = typeParts[0].charAt(i);\n+            if (!isBasicTypeChar(c)) {\n+                if (!(c >= '0' && c <= '9')) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ return null for invalid input\n+    private static Stream<String>  validateInputLines(String[] lines) {\n+        ArrayList<String> list = new ArrayList<String>(lines.length);\n+        for (String s: lines) {\n+            String line = s.trim();\n+            if (!line.startsWith(\"[LF_RESOLVE]\") && !line.startsWith(\"[SPECIES_RESOLVE]\")) {\n+                System.out.println(\"Wrong prefix: \" + line);\n+                return null;\n+            }\n+\n+            String[] parts = line.split(\" \");\n+            boolean isLF = line.startsWith(\"[LF_RESOLVE]\");\n+\n+            if (isLF) {\n+                if (parts.length != 4) {\n+                    System.out.println(\"Incorrecct number of items in the line: \" + parts.length);\n+                    System.out.println(\"line: \" + line);\n+                    return null;\n+                }\n+                if (!isValidHolderName(parts[1])) {\n+                    System.out.println(\"Invalid holder class name: \" + parts[1]);\n+                    return null;\n+                }\n+                if (!isValidMethodType(parts[3])) {\n+                    System.out.println(\"Invalid method type: \" + parts[3]);\n+                    return null;\n+                }\n+            } else {\n+                if (parts.length != 2) {\n+                   System.out.println(\"Incorrect number of items in the line: \" + parts.length);\n+                   return null;\n+                }\n+           }\n+           list.add(line);\n+      }\n+      return list.stream();\n+    }\n+\n+    \/**\n+     * called from vm to generate MethodHandle holder classes\n+     * @return @code { Object[] } if holder classes can be generated.\n+     * @param lines in format of LF_RESOLVE or SPECIES_RESOLVE output\n+     *\/\n+    private static Object[] generateLambdaFormHolderClasses(String[] lines) {\n+        Objects.requireNonNull(lines);\n+        try {\n+            Stream<String> lineStream = validateInputLines(lines);\n+            if (lineStream == null) {\n+                return null;\n+            }\n+            Map<String, byte[]> result = SharedSecrets.getJavaLangInvokeAccess().generateHolderClasses(lineStream);\n+            int size = result.size();\n+            Object[] retArray = new Object[size * 2];\n+            int index = 0;\n+            for (Map.Entry<String, byte[]> entry : result.entrySet()) {\n+                retArray[index++] = entry.getKey();\n+                retArray[index++] = entry.getValue();\n+            };\n+            return retArray;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_misc_CDS_isDumpingClassList0(JNIEnv *env, jclass jcls) {\n+    return JVM_IsDumpingClassList(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_logLambdaFormInvoker(JNIEnv *env, jclass jcls, jstring line) {\n+    JVM_LogLambdaFormInvoker(env, line);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -333,0 +333,1 @@\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * Base class for ClassListFormat[A,B,C...].java\n+ * Base class for DumpClassListWithLF, customerLoader\/ClassListFormat[A,B,C...].java\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ClassListFormatBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatBase.java","status":"renamed"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests the format checking of LF_RESOLVE in classlist.\n+ *\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @run driver DumpClassListWithLF\n+ *\/\n+\n+public class DumpClassListWithLF extends ClassListFormatBase {\n+    static final String REPLACE_OK = \"Replaced class java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String REPLACE_NOT_OK = \"Failed call to jdk\/internal\/misc\/CDS.generateLambdaFormHolderClasses\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        \/\/\n+        \/\/ Note the class regeneration via jdk\/internal\/misc\/CDS.generateLambdaFormHolderClasses(String[] lines)\n+        \/\/ Whether the regeneration successes or fails, the dump should pass. Only the message can be checked for result.\n+        \/\/\n+        \/\/ 1. With correct line format.\n+        dumpShouldPass(\n+            \"TESTCASE 1: With correct line format\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I\"),\n+                REPLACE_OK);\n+\n+        \/\/ 2. The line with incorrect (less) number of items.\n+        dumpShouldPass(\n+            \"TESTCASE 2: With incorrect (less) number of items\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic\"),\n+                \"Incorrecct number of items in the line: 3\");\n+        \/\/ 3. The two lines with non existed class name, since only 4 holder classes recognizable, all other names will be rejected.\n+        dumpShouldPass(\n+            \"TESTCASE 3: With incorrect class name will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] my.nonexist.package.MyNonExistClassName$holder invokeStatic LL_I\"),\n+                \"Invalid holder class name: my.nonexist.package.MyNonExistClassName$holder\" );\n+        \/\/ 4. The two lines with arbitrary invoke names is OK. The method type will not be added.\n+        dumpShouldPass(\n+            \"TESTCASE 4: With incorrect invoke names is OK\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeNothing LL_I\"),\n+                REPLACE_OK);\n+        \/\/ 5. The line with worng signature format of return type, will be rejected\n+        dumpShouldPass(\n+            \"TESTCASE 5: With incorrect signature format of return type will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_G\"),\n+                REPLACE_NOT_OK);\n+        \/\/ 6. The line with worng signature format of arg types, will be rejected\n+        dumpShouldPass(\n+            \"TESTCASE 6: With incorrect signature format of arg types will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic MGLL_I\"),\n+                REPLACE_NOT_OK);\n+        \/\/ 7. The line with worng prefix will ge rejected\n+        dumpShouldPass(\n+            \"TESTCASE 7: With incorrect LF format, the line will be rejected\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [LF_XYRESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic LL_I\"),\n+                \"Wrong prefix: [LF_XYRESOLVE]\");\n+        \/\/ 8. The line with correct species format\n+        dumpShouldPass(\n+            \"TESTCASE 8: With correct correct species format\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_L\"),\n+                REPLACE_OK);\n+       \/\/ 9. The line with incorrect species length is not OK\n+        dumpShouldPass(\n+            \"TESTCASE 9: With incorrect species length is not OK\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"@lambda-form-invoker [SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_L L\"),\n+                \"Incorrect number of items in the line: 3\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpClassListWithLF.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @compile ClassListFormatBase.java ..\/test-classes\/Hello.java test-classes\/InProhibitedPkg.java\n+ * @compile ..\/ClassListFormatBase.java ..\/test-classes\/Hello.java test-classes\/InProhibitedPkg.java\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ProhibitedPackageNamesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}