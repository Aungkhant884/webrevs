{"files":[{"patch":"@@ -3223,7 +3223,0 @@\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset) {\n-    ShouldNotCallThis();\n-    return RegisterOrConstant();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -937,17 +937,0 @@\n-\n-RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                      Register tmp,\n-                                                      int offset) {\n-  intptr_t value = *delayed_value_addr;\n-  if (value != 0)\n-    return RegisterOrConstant(value + offset);\n-\n-  \/\/ load indirectly to solve generation ordering problem\n-  ldr(tmp, ExternalAddress((address) delayed_value_addr));\n-\n-  if (offset != 0)\n-    add(tmp, tmp, offset);\n-\n-  return RegisterOrConstant(tmp);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1016,4 +1016,0 @@\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,14 +88,0 @@\n-\/\/ Initially added to the Assembler interface as a pure virtual:\n-\/\/   RegisterConstant delayed_value(..)\n-\/\/ for:\n-\/\/   6812678 macro assembler needs delayed binding of a few constants (for 6655638)\n-\/\/ this was subsequently modified to its present name and return type\n-RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                      Register tmp,\n-                                                      int offset) {\n-  ShouldNotReachHere();\n-  return RegisterOrConstant(-1);\n-}\n-\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -225,8 +225,0 @@\n-  \/\/ Initially added to the Assembler interface as a pure virtual:\n-  \/\/   RegisterConstant delayed_value(..)\n-  \/\/ for:\n-  \/\/   6812678 macro assembler needs delayed binding of a few constants (for 6655638)\n-  \/\/ this was subsequently modified to its present name and return type\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr, Register tmp, int offset);\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -385,19 +385,0 @@\n-RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                      Register tmp, int offset) {\n-  intptr_t value = *delayed_value_addr;\n-  if (value != 0) {\n-    return RegisterOrConstant(value + offset);\n-  }\n-\n-  \/\/ Load indirectly to solve generation ordering problem.\n-  \/\/ static address, no relocation\n-  int simm16_offset = load_const_optimized(tmp, delayed_value_addr, noreg, true);\n-  ld(tmp, simm16_offset, tmp); \/\/ must be aligned ((xa & 3) == 0)\n-\n-  if (offset != 0) {\n-    addi(tmp, tmp, offset);\n-  }\n-\n-  return RegisterOrConstant(tmp);\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -155,6 +155,0 @@\n-  \/\/ Read runtime constant:  Issue load if constant not yet established,\n-  \/\/ else use real constant.\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1813,28 +1813,0 @@\n-RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                      Register tmp,\n-                                                      int offset) {\n-  intptr_t value = *delayed_value_addr;\n-  if (value != 0) {\n-    return RegisterOrConstant(value + offset);\n-  }\n-\n-  BLOCK_COMMENT(\"delayed_value {\");\n-  \/\/ Load indirectly to solve generation ordering problem.\n-  load_absolute_address(tmp, (address) delayed_value_addr); \/\/ tmp = a;\n-  z_lg(tmp, 0, tmp);                   \/\/ tmp = *tmp;\n-\n-#ifdef ASSERT\n-  NearLabel L;\n-  compare64_and_branch(tmp, (intptr_t)0L, Assembler::bcondNotEqual, L);\n-  z_illtrap();\n-  bind(L);\n-#endif\n-\n-  if (offset != 0) {\n-    z_agfi(tmp, offset);               \/\/ tmp = tmp + offset;\n-  }\n-\n-  BLOCK_COMMENT(\"} delayed_value\");\n-  return RegisterOrConstant(tmp);\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -353,3 +353,0 @@\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3932,38 +3932,0 @@\n-RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                      Register tmp,\n-                                                      int offset) {\n-  intptr_t value = *delayed_value_addr;\n-  if (value != 0)\n-    return RegisterOrConstant(value + offset);\n-\n-  \/\/ load indirectly to solve generation ordering problem\n-  movptr(tmp, ExternalAddress((address) delayed_value_addr));\n-\n-#ifdef ASSERT\n-  { Label L;\n-    testptr(tmp, tmp);\n-    if (WizardMode) {\n-      const char* buf = NULL;\n-      {\n-        ResourceMark rm;\n-        stringStream ss;\n-        ss.print(\"DelayedValue=\" INTPTR_FORMAT, delayed_value_addr[1]);\n-        buf = code_string(ss.as_string());\n-      }\n-      jcc(Assembler::notZero, L);\n-      STOP(buf);\n-    } else {\n-      jccb(Assembler::notZero, L);\n-      hlt();\n-    }\n-    bind(L);\n-  }\n-#endif\n-\n-  if (offset != 0)\n-    addptr(tmp, offset);\n-\n-  return RegisterOrConstant(tmp);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -654,4 +654,0 @@\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,6 +69,0 @@\n-RegisterOrConstant MacroAssembler::delayed_value_impl(\n-  intptr_t* delayed_value_addr, Register tmpl, int offset) {\n-  ShouldNotCallThis();\n-  return RegisterOrConstant();\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-  RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                        Register tmp, int offset);\n- public:\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,8 +38,0 @@\n-\n- public:\n-  RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                        Register  tmp,\n-                                        int       offset) {\n-    ShouldNotCallThis();\n-    return RegisterOrConstant();\n-  }\n","filename":"src\/hotspot\/cpu\/zero\/interp_masm_zero.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -434,16 +434,0 @@\n-  \/\/ Bootstrapping aid to cope with delayed determination of constants.\n-  \/\/ Returns a static address which will eventually contain the constant.\n-  \/\/ The value zero (NULL) stands instead of a constant which is still uncomputed.\n-  \/\/ Thus, the eventual value of the constant must not be zero.\n-  \/\/ This is fine, since this is designed for embedding object field\n-  \/\/ offsets in code which must be generated before the object class is loaded.\n-  \/\/ Field offsets are never zero, since an object's header (mark word)\n-  \/\/ is located at offset zero.\n-  RegisterOrConstant delayed_value(int(*value_fn)(), Register tmp, int offset = 0);\n-  RegisterOrConstant delayed_value(address(*value_fn)(), Register tmp, int offset = 0);\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr, Register tmp, int offset) = 0;\n-  \/\/ Last overloading is platform-dependent; look in assembler_<arch>.cpp.\n-  static intptr_t* delayed_value_addr(int(*constant_fn)());\n-  static intptr_t* delayed_value_addr(address(*constant_fn)());\n-  static void update_delayed_values();\n-\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}