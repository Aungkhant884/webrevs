{"files":[{"patch":"@@ -5763,1 +5763,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5766,3 +5766,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5774,3 +5774,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -5781,1 +5780,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pRegGov src1, pRegGov src2) %{\n@@ -5784,3 +5783,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -5790,1 +5788,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -5797,1 +5794,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -5800,3 +5797,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -5808,3 +5805,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -5815,1 +5811,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pRegGov src1, pRegGov src2, pReg ptmp) %{\n@@ -5818,3 +5814,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -5823,1 +5819,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4125,1 +4125,1 @@\n-instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_anytrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4128,3 +4128,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_anytrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4136,3 +4136,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, zr);\n@@ -4143,1 +4142,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(rFlagsReg cr, pRegGov src1, pRegGov src2) %{\n@@ -4146,3 +4145,2 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vtest_anytrue_sve $src1\" %}\n@@ -4152,1 +4150,0 @@\n-    __ csetw($dst$$Register, Assembler::NE);\n@@ -4159,1 +4156,1 @@\n-instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_neon(rFlagsReg cr, vReg src1, vReg src2, vReg tmp) %{\n@@ -4162,3 +4159,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"vtest_alltrue_neon $src1\\t# KILL $tmp\" %}\n@@ -4170,3 +4167,2 @@\n-    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n+    __ umov(rscratch1, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw(rscratch1, 0xff);\n@@ -4177,1 +4173,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(rFlagsReg cr, pRegGov src1, pRegGov src2, pReg ptmp) %{\n@@ -4180,3 +4176,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ptmp);\n+  format %{ \"vtest_alltrue_sve $src1, $src2\\t# KILL $ptmp\" %}\n@@ -4185,1 +4181,0 @@\n-    __ csetw($dst$$Register, Assembler::EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -166,0 +166,10 @@\n+  \/\/ An all-set mask is used for the alltrue vector test with SVE\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_predicate && is_alltrue;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return is_alltrue ? BoolTest::eq : BoolTest::ne;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -158,0 +158,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -164,0 +164,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -156,0 +156,10 @@\n+  \/\/ Some architecture needs a helper to check for alltrue vector\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return false;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    return BoolTest::illegal;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5321,2 +5321,2 @@\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  \/\/ Encoding: EVEX.NDS.XXX.66.0F.W0 DB \/r\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : VM_Version::supports_avx512vlbw(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n@@ -5329,0 +5329,18 @@\n+void Assembler::evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.66.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x27, (0xC0 | encode));\n+}\n+\n+void Assembler::evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx512vl(), \"\");\n+  \/\/ Encoding: EVEX.NDS.XXX.F3.0F38.W0 DB \/r\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x27, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1972,0 +1972,2 @@\n+  void evptestmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evptestnmd(KRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2449,3 +2449,2 @@\n-void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                                   XMMRegister vtmp1, XMMRegister vtmp2, KRegister mask) {\n-  switch(vlen) {\n+void C2_MacroAssembler::vectortest(XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes) {\n+  switch(vlen_in_bytes) {\n@@ -2453,1 +2452,1 @@\n-      assert(vtmp1 != xnoreg, \"required.\");\n+      assert(vtmp != xnoreg, \"required.\");\n@@ -2455,4 +2454,3 @@\n-      pshufd(vtmp1, src1, 0x0);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x0);\n+      pshufd(vtmp, src1, 0x0);\n+      if (src1 != src2) {\n+        ptest(vtmp, src2);\n@@ -2460,2 +2458,1 @@\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n+        ptest(vtmp, vtmp);\n@@ -2463,1 +2460,0 @@\n-      ptest(vtmp1, vtmp2);\n@@ -2466,1 +2462,1 @@\n-      assert(vtmp1 != xnoreg, \"required.\");\n+      assert(vtmp != xnoreg, \"required.\");\n@@ -2468,4 +2464,3 @@\n-      pshufd(vtmp1, src1, 0x4);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x4);\n+      pshufd(vtmp, src1, 0x4);\n+      if (src1 != src2) {\n+        ptest(vtmp, src2);\n@@ -2473,2 +2468,1 @@\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n+        ptest(vtmp, vtmp);\n@@ -2476,1 +2470,0 @@\n-      ptest(vtmp1, vtmp2);\n@@ -2479,1 +2472,1 @@\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n+      assert(vtmp == xnoreg, \"required.\");\n@@ -2483,1 +2476,1 @@\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n+      assert(vtmp == xnoreg, \"required.\");\n@@ -2486,12 +2479,0 @@\n-    case 64:\n-      {\n-        assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-        evpcmpeqb(mask, src1, src2, Assembler::AVX_512bit);\n-        if (bt == BoolTest::ne) {\n-          ktestql(mask, mask);\n-        } else {\n-          assert(bt == BoolTest::overflow, \"required\");\n-          kortestql(mask, mask);\n-        }\n-      }\n-      break;\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -143,2 +143,1 @@\n-  void vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                  XMMRegister vtmp1 = xnoreg, XMMRegister vtmp2 = xnoreg, KRegister mask = knoreg);\n+  void vectortest(XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8837,20 +8837,0 @@\n-void MacroAssembler::anytrue(Register dst, uint masklen, KRegister src1, KRegister src2) {\n-   masklen = masklen < 8 ? 8 : masklen;\n-   ktest(masklen, src1, src2);\n-   setb(Assembler::notZero, dst);\n-   movzbl(dst, dst);\n-}\n-\n-void MacroAssembler::alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch) {\n-  if (masklen < 8) {\n-    knotbl(kscratch, src2);\n-    kortestbl(src1, kscratch);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  } else {\n-    ktest(masklen, src1, src2);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1798,3 +1798,0 @@\n-  void alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch);\n-  void anytrue(Register dst, uint masklen, KRegister src, KRegister kscratch);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,0 +186,19 @@\n+  \/\/ Without predicated input, an all-one vector is needed for the alltrue vector test\n+  static constexpr bool vectortest_needs_second_argument(bool is_alltrue, bool is_predicate) {\n+    return is_alltrue && !is_predicate;\n+  }\n+\n+  \/\/ BoolTest mask for vector test intrinsics\n+  static constexpr BoolTest::mask vectortest_mask(bool is_alltrue, bool is_predicate, int vlen) {\n+    if (!is_alltrue) {\n+      return BoolTest::ne;\n+    }\n+    if (!is_predicate) {\n+      return BoolTest::lt;\n+    }\n+    if ((vlen == 8 && !VM_Version::supports_avx512dq()) || vlen < 8) {\n+      return BoolTest::eq;\n+    }\n+    return BoolTest::lt;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1841,2 +1841,0 @@\n-      } else if (size_in_bits == 512 && (VM_Version::supports_avx512bw() == false)) {\n-        return false; \/\/ Implementation limitation\n@@ -8038,3 +8036,2 @@\n-instruct vptest_alltrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp1, legVec vtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n+instruct vptest_alltrue_lt16(rFlagsRegU cr, legVec src1, legVec src2, legVec vtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n@@ -8043,3 +8040,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp1, TEMP vtmp2, KILL cr);\n-  format %{ \"vptest_alltrue_lt16 $dst,$src1, $src2\\t! using $vtmp1, $vtmp2 and $cr as TEMP\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP vtmp);\n+  format %{ \"vptest_alltrue_lt16 $src1, $src2\\t! using $vtmp as TEMP\" %}\n@@ -8048,3 +8045,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest($src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister, vlen);\n@@ -8055,8 +8050,7 @@\n-instruct vptest_alltrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge16  $dst,$src1, $src2\\t! using $cr as TEMP\" %}\n+instruct vptest_anytrue_lt16(rFlagsRegU cr, legVec src1, legVec src2, legVec vtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP vtmp);\n+  format %{ \"vptest_anytrue_lt16 $src1, $src2\\t! using $vtmp as TEMP\" %}\n@@ -8065,3 +8059,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest($src1$$XMMRegister, $src1$$XMMRegister, $vtmp$$XMMRegister, vlen);\n@@ -8072,46 +8064,5 @@\n-instruct vptest_alltrue_lt8_evex(rRegI dst, kReg src1, kReg src2, kReg kscratch, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr, TEMP kscratch);\n-  format %{ \"vptest_alltrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint masklen = Matcher::vector_length(this, $src1);\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, $kscratch$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_alltrue_ge8_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) >= 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint masklen = Matcher::vector_length(this, $src1);\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_anytrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp, KILL cr);\n-  format %{ \"vptest_anytrue_lt16 $dst,$src1,$src2\\t! using $vtmp, $cr as TEMP\" %}\n+instruct vptest_ge16(rFlagsRegU cr, legVec src1, legVec src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <  64);\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vptest_ge16  $src1, $src2\\n\\t\" %}\n@@ -8120,3 +8071,1 @@\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest($src1$$XMMRegister, $src2$$XMMRegister, xnoreg, vlen);\n@@ -8127,8 +8076,6 @@\n-instruct vptest_anytrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 64  &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_ge16 $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+instruct vptest_alltrue_64(rFlagsRegU cr, vec src1, vec src2, kReg ktmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) == 64 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"vptest_alltrue_64  $src1, $src2\\t! using $ktmp as TEMP\" %}\n@@ -8137,3 +8084,2 @@\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ evptestnmd($ktmp$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::AVX_512bit);\n+    __ kortestwl($ktmp$$KRegister, $ktmp$$KRegister);\n@@ -8144,2 +8090,2 @@\n-instruct vptest_anytrue_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n+instruct vptest_anytrue_64(rFlagsRegU cr, vec src1, vec src2, kReg ktmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) == 64 &&\n@@ -8147,3 +8093,3 @@\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"vptest_anytrue_64  $src1, $src2\\t! using $ktmp as TEMP\" %}\n@@ -8151,5 +8097,2 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint  masklen = Matcher::vector_length(this, $src1);\n-    __ anytrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister);\n+    __ evptestmd($ktmp$$KRegister, $src1$$XMMRegister, $src1$$XMMRegister, Assembler::AVX_512bit);\n+    __ kortestwl($ktmp$$KRegister, $ktmp$$KRegister);\n@@ -8160,8 +8103,7 @@\n-instruct cmpvptest_anytrue_lt16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero, legVec vtmp) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  effect(TEMP vtmp);\n-  format %{ \"cmpvptest_anytrue_lt16 $src1,$src2\\t! using $vtmp as TEMP\" %}\n+instruct ktest_alltrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_alltrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8169,2 +8111,4 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n+    uint masklen = Matcher::vector_length(this, $src1);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n+    __ cmpl($tmp$$Register, (1 << masklen) - 1);\n@@ -8175,7 +8119,7 @@\n-instruct cmpvptest_anytrue_ge16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_ge16 $src1,$src2\\t!\" %}\n+instruct ktest_anytrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_anytrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8183,2 +8127,4 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    uint masklen = Matcher::vector_length(this, $src1);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n+    __ testl($tmp$$Register, $tmp$$Register);\n@@ -8189,5 +8135,5 @@\n-instruct cmpvptest_anytrue_evex(rFlagsReg cr, kReg src1, kReg src2, immI_0 zero) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_evex $src1,$src2\\t!\" %}\n+instruct ktest_ge8(rFlagsRegU cr, kReg src1, kReg src2) %{\n+  predicate(Matcher::vector_length(n->in(1)) >= 16 ||\n+            (Matcher::vector_length(n->in(1)) == 8 && VM_Version::supports_avx512dq()));\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"ktest_ge8  $src1, $src2\\n\\t\" %}\n@@ -8196,5 +8142,1 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    masklen = masklen < 8 ? 8 : masklen;\n-    __ ktest(masklen, $src1$$KRegister, $src2$$KRegister);\n+    __ kortest(masklen, $src1$$KRegister, $src1$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":63,"deletions":121,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/subnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1251,0 +1251,5 @@\n+  \/\/ Allow Bool -> Cmp idealisation in late inlining intrinsics that return a bool\n+  if (n->is_Cmp()) {\n+    add_users_to_worklist(n);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1470,1 +1470,4 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+    return NULL;\n+  }\n@@ -1502,0 +1505,14 @@\n+  \/\/ Change \"bool eq\/ne (cmp (cmove (bool tst (cmp2)) 1 0) 0)\" into \"bool tst\/~tst (cmp2)\"\n+  if (cop == Op_CmpI &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_CMoveI && cmp2->find_int_con(1) == 0) {\n+    \/\/ 0 should be on the true branch\n+    if (cmp1->in(CMoveNode::IfTrue)->find_int_con(1) == 0 &&\n+        cmp1->in(CMoveNode::IfFalse)->find_int_con(0) != 0) {\n+      BoolNode* target = cmp1->in(CMoveNode::Condition)->as_Bool();\n+      return new BoolNode(target->in(1),\n+                          (_test._test == BoolTest::eq) ? target->_test._test :\n+                                                          target->_test.negate());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1802,1 +1802,7 @@\n-  Node* opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd2;\n+  if (Matcher::vectortest_needs_second_argument(booltest == BoolTest::overflow,\n+                                                opd1->bottom_type()->isa_vectmask())) {\n+    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  } else {\n+    opd2 = opd1;\n+  }\n@@ -1806,2 +1812,0 @@\n-  Node* test = new VectorTestNode(opd1, opd2, booltest);\n-  test = gvn().transform(test);\n@@ -1809,1 +1813,7 @@\n-  set_result(test);\n+  Node* cmp = gvn().transform(new VectorTestNode(opd1, opd2, booltest));\n+  BoolTest::mask test = Matcher::vectortest_mask(booltest == BoolTest::overflow,\n+                                                 opd1->bottom_type()->isa_vectmask(), num_elem);\n+  Node* bol = gvn().transform(new BoolNode(cmp, test));\n+  Node* res = gvn().transform(new CMoveINode(bol, gvn().intcon(0), gvn().intcon(1), TypeInt::BOOL));\n+\n+  set_result(res);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1423,1 +1423,1 @@\n-class VectorTestNode : public Node {\n+class VectorTestNode : public CmpNode {\n@@ -1431,1 +1431,1 @@\n-  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n+  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : CmpNode(in1, in2), _predicate(predicate) {\n@@ -1436,0 +1436,4 @@\n+  virtual const Type* Value(PhaseGVN* phase) const { return TypeInt::CC; }\n+  virtual const Type* sub(const Type*, const Type*) const { return TypeInt::CC; }\n+  BoolTest::mask get_predicate() const { return _predicate; }\n+\n@@ -1439,4 +1443,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::BOOL; }\n-  virtual uint ideal_reg() const { return Op_RegI; }  \/\/ TODO Should be RegFlags but due to missing comparison flags for BoolTest\n-                                                      \/\/ in middle-end, we make it boolean result directly.\n-  BoolTest::mask get_predicate() const { return _predicate; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1883,1 +1883,1 @@\n-  declare_c2_type(VectorTestNode, Node)                                   \\\n+  declare_c2_type(VectorTestNode, CmpNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    public static final String CMP_I = START + \"CmpI\" + MID + END;\n@@ -213,0 +214,1 @@\n+    public static final String VECTOR_TEST = START + \"VectorTest\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+\n+\/*\n+ * @test\n+ * @bug 8278471\n+ * @summary Test idealization of VectorTest intrinsics to eliminate\n+ *          the materialization of the result as an int\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*sse4.*\" & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 3))\n+ *           | os.arch == \"aarch64\"\n+ * @run driver compiler.vectorapi.TestVectorTest\n+ *\/\n+public class TestVectorTest {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @DontInline\n+    public int call() { return 1; }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I, IRNode.CMOVEI})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\"})\n+    public int branch(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? call() : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CMP_I})\n+    @IR(counts = {IRNode.VECTOR_TEST, \"1\", IRNode.CMOVEI, \"1\"})\n+    public int cmove(long maskLong) {\n+        var mask = VectorMask.fromLong(ByteVector.SPECIES_PREFERRED, maskLong);\n+        return mask.allTrue() ? 1 : 0;\n+    }\n+\n+    @Run(test = {\"branch\", \"cmove\"})\n+    public void run() {\n+        branch(-1);\n+        branch(100);\n+        cmove(-1);\n+        cmove(100);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}