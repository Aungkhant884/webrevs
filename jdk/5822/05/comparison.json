{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,0 +381,10 @@\n+ * <tr>\n+ *   <th scope=\"row\">inetAddressResolverProvider<\/th>\n+ *   <td>This {@code RuntimePermission} is required to be granted to\n+ *   classes which subclass and implement {@code java.net.spi.InetAddressResolverProvider}.\n+ *   The permission is checked during invocation of the abstract base class constructor.\n+ *   This permission ensures trust in classes which provide resolvers used by\n+ *   {@link java.net.InetAddress} hostname and address resolution methods.<\/td>\n+ *   <td>See {@link java.net.spi.InetAddressResolverProvider} for more information.<\/td>\n+ * <\/tr>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/RuntimePermission.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n@@ -35,2 +38,8 @@\n-    public native InetAddress[]\n-        lookupAllHostAddr(String hostname) throws UnknownHostException;\n+    public InetAddress[] lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        if ((lookupPolicy.characteristics() & IPV4) == 0) {\n+            throw new UnknownHostException(hostname);\n+        }\n+        return lookupAllHostAddr(hostname);\n+    }\n+    private native InetAddress[] lookupAllHostAddr(String hostname) throws UnknownHostException;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4AddressImpl.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n@@ -29,3 +30,1 @@\n-import static java.net.InetAddress.IPv6;\n-import static java.net.InetAddress.PREFER_IPV6_VALUE;\n-import static java.net.InetAddress.PREFER_SYSTEM_VALUE;\n+import static java.net.InetAddress.PLATFORM_LOOKUP_POLICY;\n@@ -51,2 +50,7 @@\n-    public native InetAddress[] lookupAllHostAddr(String hostname)\n-        throws UnknownHostException;\n+    public InetAddress[] lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        return lookupAllHostAddr(hostname, lookupPolicy.characteristics());\n+    }\n+\n+    private native InetAddress[] lookupAllHostAddr(String hostname, int characteristics)\n+            throws UnknownHostException;\n@@ -99,2 +103,3 @@\n-            if (InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||\n-                InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE) {\n+            int flags = PLATFORM_LOOKUP_POLICY.characteristics();\n+            if (InetAddress.ipv6AddressesFirst(flags) ||\n+                InetAddress.systemAddressesOrder(flags)) {\n@@ -112,3 +117,3 @@\n-            boolean preferIPv6Address =\n-                InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||\n-                InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE;\n+            int flags = PLATFORM_LOOKUP_POLICY.characteristics();\n+            boolean preferIPv6Address = InetAddress.ipv6AddressesFirst(flags) ||\n+                    InetAddress.systemAddressesOrder(flags);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6AddressImpl.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -43,0 +48,1 @@\n+import java.util.ServiceLoader;\n@@ -48,0 +54,4 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.misc.VM;\n@@ -51,0 +61,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+import sun.net.ResolverProviderConfiguration;\n@@ -56,0 +68,5 @@\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n@@ -135,7 +152,14 @@\n- *\n- * Host name-to-IP address <i>resolution<\/i> is accomplished through\n- * the use of a combination of local machine configuration information\n- * and network naming services such as the Domain Name System (DNS)\n- * and Network Information Service(NIS). The particular naming\n- * services(s) being used is by default the local machine configured\n- * one. For any host name, its corresponding IP address is returned.\n+ * Host name-to-IP address <i>resolution<\/i> is accomplished through the use\n+ * of an {@linkplain InetAddressResolver InetAddress resolver}. Lookup operations\n+ * performed by this class use the\n+ * <a href=\"spi\/InetAddressResolverProvider.html#system-wide-resolver\">\n+ * system-wide resolver<\/a>. The <i>system-wide resolver<\/i> can be customized\n+ * by <a href=\"spi\/InetAddressResolverProvider.html#system-wide-resolver\">\n+ * deploying<\/a> an {@link InetAddressResolverProvider}.\n+ * <p id=\"built-in-resolver\">The built-in resolver implementation is used by\n+ * default and accomplishes host name-to-IP address <i>resolution<\/i> through the\n+ * use of a combination of local machine configuration information and network\n+ * naming services such as the Domain Name System (DNS) and Network Information\n+ * Service(NIS). The particular naming services(s) being used is by default the\n+ * local machine configured one. For any host name, its corresponding IP address\n+ * is returned.\n@@ -201,4 +225,0 @@\n-    @Native static final int PREFER_IPV4_VALUE = 0;\n-    @Native static final int PREFER_IPV6_VALUE = 1;\n-    @Native static final int PREFER_SYSTEM_VALUE = 2;\n-\n@@ -217,3 +237,0 @@\n-    \/* Specify address family preference *\/\n-    static transient final int preferIPv6Address;\n-\n@@ -291,2 +308,5 @@\n-    \/* Used to store the name service provider *\/\n-    private static transient NameService nameService;\n+    \/* Used to store the system-wide resolver *\/\n+    @Stable\n+    private static volatile InetAddressResolver resolver;\n+\n+    private static final InetAddressResolver BUILTIN_RESOLVER;\n@@ -304,0 +324,9 @@\n+    \/\/ \"java.net.preferIPv4Stack\" system property value\n+    private static final String PREFER_IPV4_STACK_VALUE;\n+\n+    \/\/ \"java.net.preferIPv6Addresses\" system property value\n+    private static final String PREFER_IPV6_ADDRESSES_VALUE;\n+\n+    \/\/ \"jdk.net.hosts.file\" system property value\n+    private static final String HOSTS_FILE_NAME;\n+\n@@ -308,12 +337,6 @@\n-        String str = GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n-        if (str == null) {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        } else if (str.equalsIgnoreCase(\"true\")) {\n-            preferIPv6Address = PREFER_IPV6_VALUE;\n-        } else if (str.equalsIgnoreCase(\"false\")) {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        } else if (str.equalsIgnoreCase(\"system\")) {\n-            preferIPv6Address = PREFER_SYSTEM_VALUE;\n-        } else {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        }\n+        PREFER_IPV4_STACK_VALUE =\n+                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\");\n+        PREFER_IPV6_ADDRESSES_VALUE =\n+                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n+        HOSTS_FILE_NAME =\n+                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n@@ -327,7 +350,0 @@\n-                    public InetAddress getByName(String hostName,\n-                                                 InetAddress hostAddress)\n-                        throws UnknownHostException\n-                    {\n-                        return InetAddress.getByName(hostName, hostAddress);\n-                    }\n-\n@@ -346,0 +362,125 @@\n+    \/**\n+     * Creates an address lookup policy from {@code \"java.net.preferIPv4Stack\"},\n+     * {@code \"java.net.preferIPv6Addresses\"} system property values, and O\/S configuration.\n+     *\/\n+    private static final LookupPolicy initializePlatformLookupPolicy() {\n+        \/\/ Calculate AddressFamily value first\n+        boolean ipv4Available = isIPv4Available();\n+        if (\"true\".equals(PREFER_IPV4_STACK_VALUE) && ipv4Available) {\n+            return LookupPolicy.of(IPV4);\n+        }\n+        \/\/ Check if IPv6 is not supported\n+        if (InetAddress.impl instanceof Inet4AddressImpl) {\n+            return LookupPolicy.of(IPV4);\n+        }\n+        \/\/ Check if system supports IPv4, if not use IPv6\n+        if (!ipv4Available) {\n+            return LookupPolicy.of(IPV6);\n+        }\n+        \/\/ If both address families are needed - check preferIPv6Addresses value\n+        if (PREFER_IPV6_ADDRESSES_VALUE != null) {\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"true\")) {\n+                return LookupPolicy.of(IPV4 | IPV6 | IPV6_FIRST);\n+            }\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"false\")) {\n+                return LookupPolicy.of(IPV4 | IPV6 | IPV4_FIRST);\n+            }\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"system\")) {\n+                return LookupPolicy.of(IPV4 | IPV6);\n+            }\n+        }\n+        \/\/ Default value with both address families needed - IPv4 addresses come first\n+        return LookupPolicy.of(IPV4 | IPV6 | IPV4_FIRST);\n+    }\n+\n+    static boolean systemAddressesOrder(int lookupCharacteristics) {\n+        return (lookupCharacteristics & (IPV4_FIRST | IPV6_FIRST)) == 0;\n+    }\n+\n+    static boolean ipv4AddressesFirst(int lookupCharacteristics) {\n+        return (lookupCharacteristics & IPV4_FIRST) != 0;\n+    }\n+\n+    static boolean ipv6AddressesFirst(int lookupCharacteristics) {\n+        return (lookupCharacteristics & IPV6_FIRST) != 0;\n+    }\n+\n+    \/\/ Native method to check if IPv4 is available\n+    private static native boolean isIPv4Available();\n+\n+    \/**\n+     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n+     * necessary to subclass and instantiate the {@code InetAddressResolverProvider}\n+     * class, as well as to obtain resolver from an instance of that class,\n+     * and it is also required to obtain the operating system name resolution configurations.\n+     *\/\n+    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n+            new RuntimePermission(\"inetAddressResolverProvider\");\n+\n+    private static final ReentrantLock RESOLVER_LOCK = new ReentrantLock();\n+    private static volatile InetAddressResolver bootstrapResolver;\n+\n+    @SuppressWarnings(\"removal\")\n+    private static InetAddressResolver resolver() {\n+        InetAddressResolver cns = resolver;\n+        if (cns != null) {\n+            return cns;\n+        }\n+        if (VM.isBooted()) {\n+            RESOLVER_LOCK.lock();\n+            boolean bootstrapSet = false;\n+            try {\n+                cns = resolver;\n+                if (cns != null) {\n+                    return cns;\n+                }\n+                \/\/ Protection against provider calling InetAddress APIs during initialization\n+                if (bootstrapResolver != null) {\n+                    return bootstrapResolver;\n+                }\n+                bootstrapResolver = BUILTIN_RESOLVER;\n+                bootstrapSet = true;\n+\n+                if (HOSTS_FILE_NAME != null) {\n+                    \/\/ The default resolver service is already host file resolver\n+                    cns = BUILTIN_RESOLVER;\n+                } else if (System.getSecurityManager() != null) {\n+                    PrivilegedAction<InetAddressResolver> pa = InetAddress::loadResolver;\n+                    cns = AccessController.doPrivileged(\n+                            pa, null, INET_ADDRESS_RESOLVER_PERMISSION);\n+                } else {\n+                    cns = loadResolver();\n+                }\n+\n+                InetAddress.resolver = cns;\n+                return cns;\n+            } finally {\n+                \/\/ We want to clear bootstrap resolver reference only after an attempt to\n+                \/\/ instantiate a resolver has been completed.\n+                if (bootstrapSet) {\n+                    bootstrapResolver = null;\n+                }\n+                RESOLVER_LOCK.unlock();\n+            }\n+        } else {\n+            return BUILTIN_RESOLVER;\n+        }\n+    }\n+\n+    private static InetAddressResolver loadResolver() {\n+        return ServiceLoader.load(InetAddressResolverProvider.class)\n+                .findFirst()\n+                .map(nsp -> nsp.get(builtinConfiguration()))\n+                .orElse(BUILTIN_RESOLVER);\n+    }\n+\n+    private static InetAddressResolverProvider.Configuration builtinConfiguration() {\n+        return new ResolverProviderConfiguration(BUILTIN_RESOLVER, () -> {\n+            try {\n+                return impl.getLocalHostName();\n+            } catch (UnknownHostException unknownHostException) {\n+                return \"localhost\";\n+            }\n+        });\n+    }\n+\n@@ -558,1 +699,1 @@\n-     * configured name lookup service. If a lookup of the name service\n+     * configured resolver. If a lookup of the name service\n@@ -659,1 +800,2 @@\n-        String host = null;\n+        String host;\n+        var resolver = resolver();\n@@ -662,1 +804,1 @@\n-            host = nameService.getHostByAddr(addr.getAddress());\n+            host = resolver.lookupByAddress(addr.getAddress());\n@@ -694,1 +836,4 @@\n-        } catch (SecurityException e) {\n+        \/\/ 'resolver.lookupByAddress' and 'InetAddress.getAllByName0' delegate to the system-wide resolver,\n+        \/\/ which could be a custom one. At that point we treat any unexpected RuntimeException thrown by\n+        \/\/ the resolver as we would treat an UnknownHostException or an unmatched host name.\n+        } catch (RuntimeException | UnknownHostException e) {\n@@ -696,3 +841,0 @@\n-        } catch (UnknownHostException e) {\n-            host = addr.getHostAddress();\n-            \/\/ let next provider resolve the hostname\n@@ -758,2 +900,3 @@\n-     * If the host name is unresolved, no reverse name service lookup\n-     * is performed. The hostname part will be represented by an empty string.\n+     * If the host name is unresolved, no reverse lookup\n+     * is performed. The hostname part will be represented\n+     * by an empty string.\n@@ -824,1 +967,0 @@\n-        private final InetAddress reqAddr;\n@@ -826,1 +968,1 @@\n-        NameServiceAddresses(String host, InetAddress reqAddr) {\n+        NameServiceAddresses(String host) {\n@@ -828,1 +970,0 @@\n-            this.reqAddr = reqAddr;\n@@ -852,1 +993,1 @@\n-                        inetAddresses = getAddressesFromNameService(host, reqAddr);\n+                        inetAddresses = getAddressesFromNameService(host);\n@@ -878,1 +1019,1 @@\n-                    if (inetAddresses == null) {\n+                    if (inetAddresses == null || inetAddresses.length == 0) {\n@@ -892,32 +1033,1 @@\n-     * NameService provides host and address lookup service\n-     *\n-     * @since 9\n-     *\/\n-    private interface NameService {\n-\n-        \/**\n-         * Lookup a host mapping by name. Retrieve the IP addresses\n-         * associated with a host\n-         *\n-         * @param host the specified hostname\n-         * @return array of IP addresses for the requested host\n-         * @throws UnknownHostException\n-         *             if no IP address for the {@code host} could be found\n-         *\/\n-        InetAddress[] lookupAllHostAddr(String host)\n-                throws UnknownHostException;\n-\n-        \/**\n-         * Lookup the host corresponding to the IP address provided\n-         *\n-         * @param addr byte array representing an IP address\n-         * @return {@code String} representing the host name mapping\n-         * @throws UnknownHostException\n-         *             if no host found for the specified IP address\n-         *\/\n-        String getHostByAddr(byte[] addr) throws UnknownHostException;\n-\n-    }\n-\n-    \/**\n-     * The default NameService implementation, which delegates to the underlying\n+     * The default InetAddressResolver implementation, which delegates to the underlying\n@@ -928,1 +1038,1 @@\n-    private static final class PlatformNameService implements NameService {\n+    private static final class PlatformResolver implements InetAddressResolver {\n@@ -930,4 +1040,5 @@\n-        public InetAddress[] lookupAllHostAddr(String host)\n-            throws UnknownHostException\n-        {\n-            return impl.lookupAllHostAddr(host);\n+        public Stream<InetAddress> lookupByName(String host, LookupPolicy policy)\n+                throws UnknownHostException {\n+            Objects.requireNonNull(host);\n+            Objects.requireNonNull(policy);\n+            return Arrays.stream(impl.lookupAllHostAddr(host, policy));\n@@ -936,3 +1047,5 @@\n-        public String getHostByAddr(byte[] addr)\n-            throws UnknownHostException\n-        {\n+        public String lookupByAddress(byte[] addr)\n+                throws UnknownHostException {\n+            if (addr.length != Inet4Address.INADDRSZ && addr.length != Inet6Address.INADDRSZ) {\n+                throw new IllegalArgumentException(\"Invalid address length\");\n+            }\n@@ -944,1 +1057,1 @@\n-     * The HostsFileNameService provides host address mapping\n+     * The HostsFileResolver provides host address mapping\n@@ -951,1 +1064,1 @@\n-     * <p>When the file lookup is enabled it replaces the default NameService\n+     * <p>When the file lookup is enabled it replaces the default InetAddressResolver\n@@ -956,7 +1069,1 @@\n-    private static final class HostsFileNameService implements NameService {\n-\n-        private static final InetAddress[] EMPTY_ARRAY = new InetAddress[0];\n-\n-        \/\/ Specify if only IPv4 addresses should be returned by HostsFileService implementation\n-        private static final boolean preferIPv4Stack = Boolean.parseBoolean(\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\"));\n+    private static final class HostsFileResolver implements InetAddressResolver {\n@@ -966,1 +1073,1 @@\n-        public HostsFileNameService(String hostsFileName) {\n+        public HostsFileResolver(String hostsFileName) {\n@@ -977,2 +1084,2 @@\n-         * @throws UnknownHostException\n-         *             if no host found for the specified IP address\n+         * @throws UnknownHostException if no host found for the specified IP address\n+         * @throws IllegalArgumentException if IP address is of illegal length\n@@ -981,1 +1088,1 @@\n-        public String getHostByAddr(byte[] addr) throws UnknownHostException {\n+        public String lookupByAddress(byte[] addr) throws UnknownHostException {\n@@ -985,0 +1092,5 @@\n+            \/\/ Check the length of the address array\n+            if (addr.length != Inet4Address.INADDRSZ && addr.length != Inet6Address.INADDRSZ) {\n+                throw new IllegalArgumentException(\"Invalid address length\");\n+            }\n+\n@@ -986,2 +1098,1 @@\n-                                                        UTF_8.INSTANCE))\n-            {\n+                                                        UTF_8.INSTANCE)) {\n@@ -1023,1 +1134,3 @@\n-         * @return array of IP addresses for the requested host\n+         * @param lookupPolicy IP addresses lookup policy which specifies addresses\n+         *                     family and their order\n+         * @return stream of IP addresses for the requested host\n@@ -1027,1 +1140,1 @@\n-        public InetAddress[] lookupAllHostAddr(String host)\n+        public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n@@ -1035,0 +1148,5 @@\n+            int flags = lookupPolicy.characteristics();\n+            boolean needIPv4 = (flags & IPv4) != 0;\n+            boolean needIPv6 = (flags & IPv6) != 0;\n+\n+            Objects.requireNonNull(host);\n@@ -1038,1 +1156,1 @@\n-                                                        UTF_8.INSTANCE)) {\n+                    UTF_8.INSTANCE)) {\n@@ -1050,1 +1168,1 @@\n-                                    if (address instanceof Inet4Address) {\n+                                    if (address instanceof Inet4Address && needIPv4) {\n@@ -1053,1 +1171,1 @@\n-                                    if (address instanceof Inet6Address) {\n+                                    if (address instanceof Inet6Address && needIPv6) {\n@@ -1065,13 +1183,4 @@\n-\n-            List<InetAddress> res;\n-            \/\/ If \"preferIPv4Stack\" system property is set to \"true\" then return\n-            \/\/ only IPv4 addresses\n-            if (preferIPv4Stack) {\n-                res = inet4Addresses;\n-            } else {\n-                \/\/ Otherwise, analyse \"preferIPv6Addresses\" value\n-                res = switch (preferIPv6Address) {\n-                    case PREFER_IPV4_VALUE -> concatAddresses(inet4Addresses, inet6Addresses);\n-                    case PREFER_IPV6_VALUE -> concatAddresses(inet6Addresses, inet4Addresses);\n-                    default -> inetAddresses;\n-                };\n+            \/\/ Check if only IPv4 addresses are requested\n+            if (needIPv4 && !needIPv6) {\n+                checkResultsList(inet4Addresses, host);\n+                return inet4Addresses.stream();\n@@ -1079,4 +1188,13 @@\n-\n-            if (res.isEmpty()) {\n-                throw new UnknownHostException(\"Unable to resolve host \" + host\n-                        + \" in hosts file \" + hostsFile);\n+            \/\/ Check if only IPv6 addresses are requested\n+            if (!needIPv4 && needIPv6) {\n+                checkResultsList(inet6Addresses, host);\n+                return inet6Addresses.stream();\n+            }\n+            \/\/ If both type of addresses are requested:\n+            \/\/ First, check if there is any results. Then arrange\n+            \/\/ addresses according to LookupPolicy value.\n+            checkResultsList(inetAddresses, host);\n+            if (ipv6AddressesFirst(flags)) {\n+                return Stream.concat(inet6Addresses.stream(), inet4Addresses.stream());\n+            } else if (ipv4AddressesFirst(flags)) {\n+                return Stream.concat(inet4Addresses.stream(), inet6Addresses.stream());\n@@ -1084,1 +1202,3 @@\n-            return res.toArray(EMPTY_ARRAY);\n+            \/\/ Only \"system\" addresses order is possible at this stage\n+            assert systemAddressesOrder(flags);\n+            return inetAddresses.stream();\n@@ -1087,5 +1207,8 @@\n-        private static List<InetAddress> concatAddresses(List<InetAddress> firstPart,\n-                                                         List<InetAddress> secondPart) {\n-            List<InetAddress> result = new ArrayList<>(firstPart);\n-            result.addAll(secondPart);\n-            return result;\n+        \/\/ Checks if result list with addresses is not empty.\n+        \/\/ If it is empty throw an UnknownHostException.\n+        private void checkResultsList(List<InetAddress> addressesList, String hostName)\n+                throws UnknownHostException {\n+            if (addressesList.isEmpty()) {\n+                throw new UnknownHostException(\"Unable to resolve host \" + hostName\n+                        + \" in hosts file \" + hostsFile);\n+            }\n@@ -1133,0 +1256,6 @@\n+    \/**\n+     * Platform-wide {@code LookupPolicy} initialized from {@code \"java.net.preferIPv4Stack\"},\n+     * {@code \"java.net.preferIPv6Addresses\"} system properties.\n+     *\/\n+    static final LookupPolicy PLATFORM_LOOKUP_POLICY;\n+\n@@ -1137,2 +1266,5 @@\n-        \/\/ create name service\n-        nameService = createNameService();\n+        \/\/ impl must be initialized before calling this method\n+        PLATFORM_LOOKUP_POLICY = initializePlatformLookupPolicy();\n+\n+        \/\/ create built-in resolver\n+        BUILTIN_RESOLVER = createBuiltinInetAddressResolver();\n@@ -1142,1 +1274,1 @@\n-     * Create an instance of the NameService interface based on\n+     * Create an instance of the InetAddressResolver interface based on\n@@ -1145,1 +1277,1 @@\n-     * <p>The default NameService is the PlatformNameService, which typically\n+     * <p>The default InetAddressResolver is the PlatformResolver, which typically\n@@ -1149,1 +1281,1 @@\n-     * <p> A HostsFileNameService is created if the {@code jdk.net.hosts.file}\n+     * <p> A HostsFileResolver is created if the {@code jdk.net.hosts.file}\n@@ -1154,1 +1286,1 @@\n-     * @return a NameService\n+     * @return an InetAddressResolver\n@@ -1156,7 +1288,4 @@\n-    private static NameService createNameService() {\n-\n-        String hostsFileName =\n-                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n-        NameService theNameService;\n-        if (hostsFileName != null) {\n-            theNameService = new HostsFileNameService(hostsFileName);\n+    private static InetAddressResolver createBuiltinInetAddressResolver() {\n+        InetAddressResolver theResolver;\n+        if (HOSTS_FILE_NAME != null) {\n+            theResolver = new HostsFileResolver(HOSTS_FILE_NAME);\n@@ -1164,1 +1293,1 @@\n-            theNameService = new PlatformNameService();\n+            theResolver = new PlatformResolver();\n@@ -1166,1 +1295,1 @@\n-        return theNameService;\n+        return theResolver;\n@@ -1171,1 +1300,2 @@\n-     * No name service is checked for the validity of the address.\n+     * System {@linkplain InetAddressResolver resolver} is not used to check\n+     * the validity of the address.\n@@ -1254,6 +1384,0 @@\n-    \/\/ called from deployment cache manager\n-    private static InetAddress getByName(String host, InetAddress reqAddr)\n-        throws UnknownHostException {\n-        return InetAddress.getAllByName(host, reqAddr)[0];\n-    }\n-\n@@ -1262,1 +1386,1 @@\n-     * based on the configured name service on the system.\n+     * based on the configured system {@linkplain InetAddressResolver resolver}.\n@@ -1301,5 +1425,0 @@\n-        return getAllByName(host, null);\n-    }\n-\n-    private static InetAddress[] getAllByName(String host, InetAddress reqAddr)\n-        throws UnknownHostException {\n@@ -1367,1 +1486,1 @@\n-        return getAllByName0(host, reqAddr, true, true);\n+        return getAllByName0(host, true, true);\n@@ -1417,6 +1536,0 @@\n-    private static InetAddress[] getAllByName0 (String host)\n-        throws UnknownHostException\n-    {\n-        return getAllByName0(host, true);\n-    }\n-\n@@ -1428,1 +1541,1 @@\n-        return getAllByName0 (host, null, check, true);\n+        return getAllByName0(host, check, true);\n@@ -1435,1 +1548,0 @@\n-     * @param reqAddr requested address to be the 1st in returned array\n@@ -1443,1 +1555,0 @@\n-                                               InetAddress reqAddr,\n@@ -1501,1 +1612,1 @@\n-                addrs = new NameServiceAddresses(host, reqAddr)\n+                    addrs = new NameServiceAddresses(host)\n@@ -1512,1 +1623,1 @@\n-    static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)\n+    static InetAddress[] getAddressesFromNameService(String host)\n@@ -1514,1 +1625,1 @@\n-        InetAddress[] addresses = null;\n+        Stream<InetAddress> addresses = null;\n@@ -1517,0 +1628,1 @@\n+        var resolver = resolver();\n@@ -1518,2 +1630,2 @@\n-            addresses = nameService.lookupAllHostAddr(host);\n-        } catch (UnknownHostException uhe) {\n+            addresses = resolver.lookupByName(host, PLATFORM_LOOKUP_POLICY);\n+        } catch (RuntimeException | UnknownHostException x) {\n@@ -1521,2 +1633,2 @@\n-                addresses = new InetAddress[]{impl.loopbackAddress()};\n-            } else {\n+                addresses = Stream.of(impl.loopbackAddress());\n+            } else if (x instanceof UnknownHostException uhe) {\n@@ -1524,0 +1636,3 @@\n+            } else {\n+                ex = new UnknownHostException();\n+                ex.initCause(x);\n@@ -1526,2 +1641,3 @@\n-\n-        if (addresses == null) {\n+        InetAddress[] result = addresses == null ? null\n+                : addresses.toArray(InetAddress[]::new);\n+        if (result == null || result.length == 0) {\n@@ -1530,23 +1646,1 @@\n-\n-        \/\/ More to do?\n-        if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {\n-            \/\/ Find it?\n-            int i = 1;\n-            for (; i < addresses.length; i++) {\n-                if (addresses[i].equals(reqAddr)) {\n-                    break;\n-                }\n-            }\n-            \/\/ Rotate\n-            if (i < addresses.length) {\n-                InetAddress tmp, tmp2 = reqAddr;\n-                for (int j = 0; j < i; j++) {\n-                    tmp = addresses[j];\n-                    addresses[j] = tmp2;\n-                    tmp2 = tmp;\n-                }\n-                addresses[i] = tmp2;\n-            }\n-        }\n-\n-        return addresses;\n+        return result;\n@@ -1560,2 +1654,1 @@\n-     * <p> This method doesn't block, i.e. no reverse name service lookup\n-     * is performed.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n@@ -1640,1 +1733,1 @@\n-                    localAddr = getAllByName0(local, null, false, false)[0];\n+                    localAddr = getAllByName0(local, false, false)[0];\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":298,"deletions":205,"binary":false,"changes":503,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -28,0 +29,2 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+\n@@ -41,1 +44,1 @@\n-        lookupAllHostAddr(String hostname) throws UnknownHostException;\n+        lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy) throws UnknownHostException;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddressImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    returned by the operating system.<\/P>\n+    returned by the system-wide {@linkplain java.net.spi.InetAddressResolver resolver}.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net.spi;\n+\n+import java.lang.annotation.Native;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This interface defines operations for looking-up host names and IP addresses.\n+ * An instance of {@code InetAddressResolver} is\n+ * <a href=\"InetAddressResolverProvider.html#system-wide-resolver\">installed<\/a> as a\n+ * <i>system-wide resolver<\/i>. {@link InetAddress} delegates all lookup requests to\n+ * the installed <i>system-wide resolver<\/i> instance.\n+ * <p>\n+ * The <i>system-wide resolver<\/i> can be customized by\n+ * <a href=\"InetAddressResolverProvider.html#system-wide-resolver\">\n+ * deploying an implementation<\/a> of {@link InetAddressResolverProvider}.\n+ *\n+ * @since 18\n+ *\/\n+public interface InetAddressResolver {\n+\n+    \/**\n+     * Given the name of a host, returns a stream of IP addresses of the requested\n+     * address family associated with a provided hostname.\n+     * <p>\n+     * {@code host} should be a machine name, such as \"{@code www.example.com}\",\n+     * not a textual representation of its IP address. No validation is performed on\n+     * the given {@code host} name: if a textual representation is supplied, the name\n+     * resolution is likely to fail and {@link UnknownHostException} may be thrown.\n+     * <p>\n+     * The address family type and addresses order are specified by the {@code LookupPolicy} instance.\n+     * Lookup operation characteristics could be acquired with {@link LookupPolicy#characteristics()}. If\n+     * {@link InetAddressResolver.LookupPolicy#IPV4} and {@link InetAddressResolver.LookupPolicy#IPV6}\n+     * characteristics provided then this method returns addresses of both IPV4 and IPV6 families.\n+     *\n+     * @param host         the specified hostname\n+     * @param lookupPolicy the address lookup policy\n+     * @return a stream of IP addresses for the requested host\n+     * @throws NullPointerException if {@code host} is {@code null}\n+     * @throws UnknownHostException if no IP address for the {@code host} could be found\n+     * @see LookupPolicy\n+     *\/\n+    Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException;\n+\n+    \/**\n+     * Lookup the host name corresponding to the raw IP address provided.\n+     *\n+     * <p>{@code addr} argument is in network byte order: the highest order byte of the address\n+     * is in {@code addr[0]}.\n+     *\n+     * <p> IPv4 address byte array must be 4 bytes long and IPv6 byte array\n+     * must be 16 bytes long.\n+     *\n+     * @param addr byte array representing a raw IP address\n+     * @return {@code String} representing the host name mapping\n+     * @throws UnknownHostException     if no host found for the specified IP address\n+     * @throws IllegalArgumentException if IP address is of illegal length\n+     *\/\n+    String lookupByAddress(byte[] addr) throws UnknownHostException;\n+\n+    \/**\n+     * A {@code LookupPolicy} object describes characteristics that can be applied to a lookup operation.\n+     * In particular, it is used to specify which ordering and filtering should be performed when\n+     * {@linkplain InetAddressResolver#lookupByName(String, LookupPolicy) looking up a host addresses}.\n+     * <p>\n+     * The default platform-wide lookup policy is constructed by consulting\n+     * <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">System Properties<\/a> which affect\n+     * how IPv4 and IPv6 addresses are returned.\n+     *\n+     * @since 18\n+     *\/\n+    final class LookupPolicy {\n+\n+        \/**\n+         * Characteristic value signifying if IPv4 addresses need to be queried during lookup.\n+         *\/\n+        @Native\n+        public static final int IPV4 = 1 << 0;\n+\n+        \/**\n+         * Characteristic value signifying if IPv6 addresses need to be queried during lookup.\n+         *\/\n+        @Native\n+        public static final int IPV6 = 1 << 1;\n+\n+        \/**\n+         * Characteristic value signifying if IPv4 addresses should be returned\n+         * first by {@code InetAddressResolver}.\n+         *\/\n+        @Native\n+        public static final int IPV4_FIRST = 1 << 2;\n+\n+        \/**\n+         * Characteristic value signifying if IPv6 addresses should be returned\n+         * first by {@code InetAddressResolver}.\n+         *\/\n+        @Native\n+        public static final int IPV6_FIRST = 1 << 3;\n+\n+        private final int characteristics;\n+\n+        private LookupPolicy(int characteristics) {\n+            this.characteristics = characteristics;\n+        }\n+\n+        \/**\n+         * This factory method creates {@link LookupPolicy LookupPolicy} instance with the provided\n+         * {@code characteristics} value.\n+         * <p> The {@code characteristics} value is an integer bit mask which defines\n+         * parameters of a forward lookup operation. These parameters define at least:\n+         * <ul>\n+         *     <li>the family type of the returned addresses<\/li>\n+         *     <li>the order in which a {@linkplain InetAddressResolver resolver}\n+         *         implementation should return its results<\/li>\n+         * <\/ul>\n+         * <p> To request addresses of specific family types the following bit masks can be combined:\n+         * <ul>\n+         *     <li>{@link LookupPolicy#IPV4}: to request IPv4 addresses<\/li>\n+         *     <li>{@link LookupPolicy#IPV6}: to request IPv6 addresses<\/li>\n+         * <\/ul>\n+         * <br>It is an error if neither {@link LookupPolicy#IPV4} or {@link LookupPolicy#IPV6} are set.\n+         * <p> To request a specific ordering of the results:\n+         * <ul>\n+         *     <li>{@link LookupPolicy#IPV4_FIRST}: return IPv4 addresses before any IPv6 address<\/li>\n+         *     <li>{@link LookupPolicy#IPV6_FIRST}: return IPv6 addresses before any IPv4 address<\/li>\n+         * <\/ul>\n+         * <br>If neither {@link LookupPolicy#IPV4_FIRST} or {@link LookupPolicy#IPV6_FIRST} are set it\n+         * implies <a href=\"{@docRoot}\/java.base\/java\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\"system\"<\/a>\n+         * order of addresses.\n+         * It is an error to request both {@link LookupPolicy#IPV4_FIRST} and {@link LookupPolicy#IPV6_FIRST}.\n+         *\n+         * @param characteristics value which represents the set of lookup characteristics\n+         * @return an instance of {@code InetAddressResolver.LookupPolicy}\n+         * @throws IllegalArgumentException if illegal characteristic bit mask is provided\n+         * @see InetAddressResolver#lookupByName(String, LookupPolicy)\n+         *\/\n+        public static final LookupPolicy of(int characteristics) {\n+            \/\/ At least one type of addresses should be requested\n+            if ((characteristics & IPV4) == 0 && (characteristics & IPV6) == 0) {\n+                throw new IllegalArgumentException(\"No address type specified\");\n+            }\n+\n+            \/\/ Requested order of addresses couldn't be determined\n+            if ((characteristics & IPV4_FIRST) != 0 && (characteristics & IPV6_FIRST) != 0) {\n+                throw new IllegalArgumentException(\"Addresses order cannot be determined\");\n+            }\n+\n+            \/\/ If IPv4 addresses requested to be returned first then they should be requested too\n+            if ((characteristics & IPV4_FIRST) != 0 && (characteristics & IPV4) == 0) {\n+                throw new IllegalArgumentException(\"Addresses order and type do not match\");\n+            }\n+\n+            \/\/ If IPv6 addresses requested to be returned first then they should be requested too\n+            if ((characteristics & IPV6_FIRST) != 0 && (characteristics & IPV6) == 0) {\n+                throw new IllegalArgumentException(\"Addresses order and type do not match\");\n+            }\n+            return new LookupPolicy(characteristics);\n+        }\n+\n+        \/**\n+         * Returns a set of characteristics of this lookup policy.\n+         * Type and order of address families queried during resolution of host IP addresses.\n+         *\n+         * @return a characteristics value\n+         * @see InetAddressResolver#lookupByName(String, LookupPolicy)\n+         *\/\n+        public final int characteristics() {\n+            return characteristics;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolver.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net.spi;\n+\n+import sun.net.ResolverProviderConfiguration;\n+\n+import java.net.InetAddress;\n+import java.util.ServiceLoader;\n+\n+\/**\n+ * Service-provider class for {@linkplain InetAddressResolver InetAddress resolvers}.\n+ *\n+ * <p>A resolver provider is a factory for custom implementations of {@linkplain\n+ * InetAddressResolver resolvers}. A resolver define operations for looking up\n+ * (resolving) host names and IP addresses.\n+ * <p>A resolver provider is a concrete subclass of this class that has a\n+ * zero-argument constructor and implements the abstract methods specified below.\n+ *\n+ * <h2 id=\"system-wide-resolver\"> Installing the system-wide resolver <\/h2>\n+ * <p> Resolver providers are discovered by {@link InetAddress} to instantiate and\n+ * install a <i>system-wide resolver<\/i>. Resolver providers are located by\n+ * {@link InetAddress} using the {@link ServiceLoader} facility.\n+ *\n+ * <p>Host name resolution and reverse name resolution operations performed by\n+ * {@link InetAddress} use the <i>system-wide<\/i> {@linkplain InetAddressResolver\n+ * resolver}. The system-wide resolver is set once, lazily, after the VM is fully\n+ * initialized and when an invocation of a method in {@link InetAddress} class\n+ * triggers the first lookup operation.\n+ *\n+ * <p> A <i>custom resolver<\/i> can be installed as the system-wide resolver\n+ * by deploying an {@code InetAddressResolverProvider}. If no resolver provider\n+ * is found, then the <a href=\"..\/InetAddress.html#built-in-resolver\">built-in\n+ * resolver<\/a> will be set as the system-wide resolver.\n+ *\n+ * <p> A custom resolver is found and installed as the system-wide resolver\n+ * as follows:\n+ * <ol>\n+ *  <li>The {@link ServiceLoader} mechanism is used to locate an\n+ *      {@code InetAddressResolverProvider} using the\n+ *      system class loader. The order in which providers are located is\n+ *      {@linkplain ServiceLoader#load(java.lang.Class, java.lang.ClassLoader)\n+ *      implementation specific}.\n+ *      The first provider found will be used to instantiate the\n+ *      {@link InetAddressResolver InetAddressResolver} by invoking the\n+ *      {@link InetAddressResolverProvider#get(InetAddressResolverProvider.Configuration)}\n+ *      method. The returned {@code InetAddressResolver} will be installed as the\n+ *      system-wide resolver.\n+ *  <li>If the previous step fails to find any resolver provider the\n+ *      built-in resolver will be set as the system-wide resolver.\n+ * <\/ol>\n+ *\n+ * <p> If instantiating a custom resolver from a provider discovered in\n+ * step 1 throws an error or exception, the system-wide resolver will not be\n+ * installed and the error or exception will be propagated to the calling thread.\n+ * Otherwise, any lookup operation will be performed through the installed\n+ * <i>system-wide resolver<\/i>.\n+ *\n+ * @implNote {@link InetAddress} will use the <i>built-in resolver<\/i> for any lookup operation\n+ * that might occur before the VM is fully booted.\n+ *\n+ * @since 18\n+ *\/\n+public abstract class InetAddressResolverProvider {\n+\n+    \/**\n+     * Initialise and return an {@link InetAddressResolver} provided by\n+     * this provider. This method is called by {@link InetAddress} when\n+     * <a href=\"#system-wide-resolver\">installing<\/a>\n+     * the system-wide resolver implementation.\n+     * <p>\n+     * Any error or exception thrown by this method is considered as\n+     * a failure of {@code InetAddressResolver} instantiation and will be propagated to\n+     * the calling thread.\n+     * @param configuration a {@link Configuration} instance containing platform built-in address\n+     *                     resolution configuration.\n+     * @return the resolver provided by this provider\n+     *\/\n+    public abstract InetAddressResolver get(Configuration configuration);\n+\n+    \/**\n+     * Returns the name of this provider.\n+     *\n+     * @return the resolver provider name\n+     *\/\n+    public abstract String name();\n+\n+    \/**\n+     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n+     * necessary to subclass and instantiate the {@code InetAddressResolverProvider} class,\n+     * as well as to obtain resolver from an instance of that class,\n+     * and it is also required to obtain the operating system name resolution configurations.\n+     *\/\n+    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n+            new RuntimePermission(\"inetAddressResolverProvider\");\n+\n+    \/**\n+     * Creates a new instance of {@code InetAddressResolverProvider}.\n+     *\n+     * @throws SecurityException if a security manager is present and its\n+     *                           {@code checkPermission} method doesn't allow the\n+     *                           {@code RuntimePermission(\"inetAddressResolverProvider\")}.\n+     * @implNote It is recommended that an {@code InetAddressResolverProvider} service\n+     * implementation initialization should be as simple as possible, in order to avoid\n+     * possible risks of deadlock or class loading cycles during the instantiation of the\n+     * service provider.\n+     *\/\n+    protected InetAddressResolverProvider() {\n+        this(checkPermission());\n+    }\n+\n+    private InetAddressResolverProvider(Void unused) {\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Void checkPermission() {\n+        final SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(INET_ADDRESS_RESOLVER_PERMISSION);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * A {@code Configuration} object is supplied to the\n+     * {@link InetAddressResolverProvider#get(Configuration)} method when installing a\n+     * system-wide custom resolver implementation.\n+     * The custom resolver implementation can then delegate to the built-in resolver\n+     * provided by this interface if it needs to.\n+     *\n+     * @since 18\n+     *\/\n+    public sealed interface Configuration permits ResolverProviderConfiguration {\n+        \/**\n+         * Returns platform built-in {@linkplain InetAddressResolver resolver}.\n+         *\n+         * @return the JDK built-in resolver.\n+         *\/\n+        InetAddressResolver builtinResolver();\n+\n+        \/**\n+         * Reads the localhost name from the system configuration.\n+         *\n+         * @return the localhost name.\n+         *\/\n+        String lookupLocalHostName();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolverProvider.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * <p> Only developers who are defining new URL stream handler providers\n- * should need to make direct use of this package.\n+ * <p> Only developers who are defining new URL stream handler providers or implementing\n+ * a custom resolver provider should need to make direct use of this package.\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.net.UnknownHostException;\n@@ -40,9 +39,0 @@\n-    \/**\n-     * Get the InetAddress of the provided host. If an InetAddress is provided\n-     * then it will be the default address returned for all calls to either\n-     * form of getByName. This is required to maintain consistency when\n-     * caching addresses and hostnames.\n-     *\/\n-    InetAddress getByName(String hostName, InetAddress hostAddress)\n-            throws UnknownHostException;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNetInetAddressAccess.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+    uses java.net.spi.InetAddressResolverProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net;\n+\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.function.Supplier;\n+\n+public final class ResolverProviderConfiguration implements\n+        InetAddressResolverProvider.Configuration {\n+\n+    private final InetAddressResolver builtinResolver;\n+    private final Supplier<String> localHostNameSupplier;\n+\n+    public ResolverProviderConfiguration(InetAddressResolver builtinResolver,\n+                                         Supplier<String> localHostNameSupplier) {\n+        this.builtinResolver = builtinResolver;\n+        this.localHostNameSupplier = localHostNameSupplier;\n+    }\n+\n+    @Override\n+    public InetAddressResolver builtinResolver() {\n+        return builtinResolver;\n+    }\n+\n+    @Override\n+    public String lookupLocalHostName() {\n+        return localHostNameSupplier.get();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ResolverProviderConfiguration.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-jfieldID ia_preferIPv6AddressID;\n@@ -64,2 +63,0 @@\n-        ia_preferIPv6AddressID = (*env)->GetStaticFieldID(env, ia_class, \"preferIPv6Address\", \"I\");\n-        CHECK_NULL(ia_preferIPv6AddressID);\n@@ -78,0 +75,9 @@\n+\n+\/*\n+ * Class:     java_net_InetAddress\n+ * Method:    isIPv4Available\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_java_net_InetAddress_isIPv4Available(JNIEnv *env, jclass clazz) {\n+    return ipv4_available();\n+}\n","filename":"src\/java.base\/share\/native\/libnet\/InetAddress.c","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -335,0 +336,20 @@\n+\n+int lookupCharacteristicsToAddressFamily(int characteristics) {\n+    int ipv4 = characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4;\n+    int ipv6 = characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6;\n+\n+    if (ipv4 != 0 && ipv6 == 0) {\n+        return AF_INET;\n+    }\n+\n+    if (ipv4 == 0 && ipv6 != 0) {\n+        return AF_INET6;\n+    }\n+    return AF_UNSPEC;\n+}\n+\n+int addressesInSystemOrder(int characteristics) {\n+    return (characteristics &\n+           (java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST |\n+            java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST)) == 0;\n+}\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-extern jfieldID ia_preferIPv6AddressID;\n@@ -195,0 +194,4 @@\n+int lookupCharacteristicsToAddressFamily(int characteristics);\n+\n+int addressesInSystemOrder(int characteristics);\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -41,1 +42,2 @@\n-extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6);\n+extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6,\n+                                      int addressesOrder);\n@@ -114,1 +116,3 @@\n-        ret = lookupIfLocalhost(env, hostname, JNI_FALSE);\n+        \/\/ java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST and no ordering is ok\n+        \/\/ here since only AF_INET addresses will be returned.\n+        ret = lookupIfLocalhost(env, hostname, JNI_FALSE, java_net_spi_InetAddressResolver_LookupPolicy_IPV4);\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n+\n@@ -77,1 +79,1 @@\n-lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6)\n+lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6, int characteristics)\n@@ -154,1 +156,1 @@\n-    if ((*env)->GetStaticBooleanField(env, ia_class, ia_preferIPv6AddressID)) {\n+    if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -207,1 +209,1 @@\n-                                                 jstring host) {\n+                                                 jstring host, jint characteristics) {\n@@ -227,1 +229,1 @@\n-    hints.ai_family = AF_UNSPEC;\n+    hints.ai_family = lookupCharacteristicsToAddressFamily(characteristics);\n@@ -234,1 +236,1 @@\n-        ret = lookupIfLocalhost(env, hostname, JNI_TRUE);\n+        ret = lookupIfLocalhost(env, hostname, JNI_TRUE, characteristics);\n@@ -245,2 +247,0 @@\n-        int addressPreference =\n-            (*env)->GetStaticIntField(env, ia_class, ia_preferIPv6AddressID);;\n@@ -325,1 +325,1 @@\n-        if (addressPreference == java_net_InetAddress_PREFER_IPV6_VALUE) {\n+        if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -328,1 +328,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_IPV4_VALUE) {\n+        } else if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST) != 0) {\n@@ -331,1 +331,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+        } else {\n@@ -374,1 +374,2 @@\n-            if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+            \/\/ Check if addresses are requested to be returned in SYSTEM order\n+            if (addressesInSystemOrder(characteristics)) {\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -59,1 +60,1 @@\n-                                                 jstring host) {\n+                                                 jstring host, jint characteristics) {\n@@ -79,1 +80,1 @@\n-    hints.ai_family = AF_UNSPEC;\n+    hints.ai_family = lookupCharacteristicsToAddressFamily(characteristics);\n@@ -91,2 +92,0 @@\n-        int addressPreference =\n-            (*env)->GetStaticIntField(env, ia_class, ia_preferIPv6AddressID);\n@@ -171,1 +170,1 @@\n-        if (addressPreference == java_net_InetAddress_PREFER_IPV6_VALUE) {\n+        if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -174,1 +173,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_IPV4_VALUE) {\n+        } else if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST) != 0) {\n@@ -177,1 +176,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+        } else {\n@@ -220,1 +219,2 @@\n-            if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+            \/\/ Check if addresses are requested to be returned in SYSTEM order\n+            if (addressesInSystemOrder(characteristics)) {\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet6AddressImpl.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import impl.SimpleResolverProviderImpl;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddress caching security properties work as expected\n+ *  when a custom resolver is installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry\n+ *  simple.provider\/impl.SimpleResolverProviderImpl AddressesCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/NeverCache.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/ForeverCache.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ *\/\n+public class AddressesCachingTest {\n+\n+    @Test\n+    public void testPositiveCaching() {\n+        boolean observedTwoLookups = performLookups(false);\n+        if (CACHING_DISABLED) {\n+            Assert.assertTrue(observedTwoLookups,\n+                    \"Two positive lookups are expected with caching disabled\");\n+        } else {\n+            Assert.assertFalse(observedTwoLookups,\n+                    \"Only one positive lookup is expected with caching enabled\");\n+        }\n+    }\n+\n+    @Test\n+    public void testNegativeCaching() {\n+        boolean observedTwoLookups = performLookups(true);\n+        if (CACHING_DISABLED) {\n+            Assert.assertTrue(observedTwoLookups,\n+                    \"Two negative lookups are expected with caching disabled\");\n+        } else {\n+            Assert.assertFalse(observedTwoLookups,\n+                    \"Only one negative lookup is expected with caching enabled\");\n+        }\n+    }\n+\n+    \/*\n+     * Performs two subsequent positive or negative lookups.\n+     * Returns true if the timestamp of this lookups differs,\n+     * false otherwise.\n+     *\/\n+    private static boolean performLookups(boolean performNegativeLookup) {\n+        doLookup(performNegativeLookup);\n+        long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+        doLookup(performNegativeLookup);\n+        long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+        return firstTimestamp != secondTimestamp;\n+    }\n+\n+    \/\/ Performs negative or positive lookup.\n+    \/\/ It is a test error if UnknownHostException is thrown during positive lookup.\n+    \/\/ It is a test error if UnknownHostException is NOT thrown during negative lookup.\n+    private static void doLookup(boolean performNegativeLookup) {\n+        String hostName = performNegativeLookup ? \"notKnowHost.org\" : \"javaTest.org\";\n+        try {\n+            InetAddress.getByName(hostName);\n+            if (performNegativeLookup) {\n+                Assert.fail(\"Host name is expected to get unresolved\");\n+            }\n+        } catch (UnknownHostException uhe) {\n+            if (!performNegativeLookup) {\n+                Assert.fail(\"Host name is expected to get resolved\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Helper system property that signals to the test if both negative and positive\n+    \/\/ caches are disabled.\n+    private static final boolean CACHING_DISABLED = Boolean.getBoolean(\"test.cachingDisabled\");\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesCachingTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static impl.WithBootstrapResolverUsageProvider.numberOfGetCalls;\n+\n+\/**\n+ * @test\n+ * @summary Test that InetAddress class properly avoids stack-overflow by\n+ * correctly tracking the bootstrap resolver instance when\n+ * InetAddressResolverProvider.get method uses InetAddress lookup API.\n+ * @library providers\/bootstrapUsage\n+ * @build bootstrap.usage.provider\/impl.WithBootstrapResolverUsageProvider\n+ * @run testng\/othervm BootstrapResolverUsageTest\n+ *\/\n+\n+public class BootstrapResolverUsageTest {\n+\n+    @Test\n+    public void testSuccessfulProviderInstantiationTest() throws Exception {\n+        System.err.println(InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()));\n+        Assert.assertEquals(numberOfGetCalls, 1,\n+                \"InetAddressResolverProvider.get was called more than once\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/BootstrapResolverUsageTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary white-box test to check that the built-in resolver\n+ *  is used by default.\n+ * @modules java.base\/java.net:open\n+ * @run testng\/othervm BuiltInResolverTest\n+ *\/\n+\n+public class BuiltInResolverTest {\n+\n+    private Field builtInResolverField, resolverField;\n+\n+    @BeforeTest\n+    public void beforeTest() throws NoSuchFieldException {\n+        Class<InetAddress> inetAddressClass = InetAddress.class;\n+        \/\/ Needs to happen for InetAddress.resolver to be initialized\n+        try {\n+            InetAddress.getByName(\"test\");\n+        } catch (UnknownHostException e) {\n+            \/\/ Do nothing, only want to assign resolver\n+        }\n+        builtInResolverField = inetAddressClass.getDeclaredField(\"BUILTIN_RESOLVER\");\n+        builtInResolverField.setAccessible(true);\n+        resolverField = inetAddressClass.getDeclaredField(\"resolver\");\n+        resolverField.setAccessible(true);\n+    }\n+\n+    @Test\n+    public void testDefaultNSContext() throws IllegalAccessException {\n+        \/\/ Test that the resolver used by default is the BUILTIN_RESOLVER\n+        Object defaultResolverObject = builtInResolverField.get(InetAddressResolver.class);\n+        Object usedResolverObject = resolverField.get(InetAddressResolver.class);\n+\n+        assertTrue(defaultResolverObject == usedResolverObject);\n+\n+        String defaultClassName = defaultResolverObject.getClass().getCanonicalName();\n+        String currentClassName = usedResolverObject.getClass().getCanonicalName();\n+\n+        assertNotNull(defaultClassName, \"defaultClassName not set\");\n+        assertNotNull(currentClassName, \"currentClassName name not set\");\n+\n+        assertEquals(currentClassName, defaultClassName,\n+                \"BUILTIN_RESOLVER resolver was not used.\");\n+        System.err.println(\"Resolver used by default is the built-in resolver\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/BuiltInResolverTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @summary checks that InetAddress forward lookup API throw UnknownHostException\n+ *   when resolver returns empty address stream.\n+ * @library providers\/empty\n+ * @build empty.results.provider\/impl.EmptyResultsProviderImpl\n+ * @run testng\/othervm EmptyResultsStreamTest\n+ *\/\n+public class EmptyResultsStreamTest {\n+\n+    @Test(expectedExceptions = UnknownHostException.class)\n+    public void getAllByNameTest() throws UnknownHostException {\n+        System.err.println(\"getAllByName unexpectedly completed: \" +\n+                Arrays.deepToString(InetAddress.getAllByName(\"test1.org\")));\n+    }\n+\n+    @Test(expectedExceptions = UnknownHostException.class)\n+    public void getByNameTest() throws UnknownHostException {\n+        System.err.println(\"getByName unexpectedly completed: \" +\n+                InetAddress.getByName(\"test2.org\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/EmptyResultsStreamTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ForeverCache.props","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+\n+\/**\n+ * @test\n+ * @summary Test that provider which uses InetAddress APIs during its initialization\n+ * wouldn't cause stack overflow and will be successfully installed.\n+ * @library providers\/recursive\n+ * @build recursive.init.provider\/impl.InetAddressUsageInGetProviderImpl\n+ * @run testng\/othervm InetAddressUsageInGetProviderTest\n+ *\/\n+\n+public class InetAddressUsageInGetProviderTest {\n+\n+    @Test\n+    public void testSuccessfulProviderInstantiationTest() throws Exception {\n+        System.err.println(InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/InetAddressUsageInGetProviderTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.NetworkConfiguration;\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+import org.testng.SkipException;\n+\n+\/*\n+ * @test\n+ * @summary Test that platform lookup characteristic value is correctly initialized from\n+ *  system properties affecting order and type of queried addresses.\n+ * @library lib providers\/simple \/test\/lib\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        jdk.test.lib.net.IPSupport LookupPolicyMappingTest\n+ * @run testng\/othervm LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ *\/\n+\n+public class LookupPolicyMappingTest {\n+\n+    @Test\n+    public void testSystemProperties() throws Exception {\n+\n+        \/\/ Check if platform network configuration matches the test requirements,\n+        \/\/ if not throw a SkipException\n+        checkPlatformNetworkConfiguration();\n+\n+        System.err.println(\"javaTest.org resolved to:\" + Arrays.deepToString(\n+                InetAddress.getAllByName(\"javaTest.org\")));\n+\n+        \/\/ Acquire runtime characteristics from the test NSP\n+        int runtimeCharacteristics = impl.SimpleResolverProviderImpl.lastLookupPolicy().characteristics();\n+\n+        \/\/ Calculate expected lookup policy characteristic\n+        String preferIPv4Stack = System.getProperty(\"java.net.preferIPv4Stack\");\n+        String preferIPv6Addresses = System.getProperty(\"java.net.preferIPv6Addresses\");\n+        String expectedResultsKey = calculateMapKey(preferIPv4Stack, preferIPv6Addresses);\n+        int expectedCharacteristics = EXPECTED_RESULTS_MAP.get(expectedResultsKey);\n+\n+        Assert.assertTrue(characteristicsMatch(\n+                runtimeCharacteristics, expectedCharacteristics), \"Unexpected LookupPolicy observed\");\n+    }\n+\n+    \/\/ Throws SkipException if platform doesn't support required IP address types\n+    static void checkPlatformNetworkConfiguration() {\n+        IPSupport.throwSkippedExceptionIfNonOperational();\n+        IPSupport.printPlatformSupport(System.err);\n+        NetworkConfiguration.printSystemConfiguration(System.err);\n+        \/\/ If preferIPv4=true and no IPv4 - skip\n+        if (IPSupport.preferIPv4Stack()) {\n+            if (!IPSupport.hasIPv4()) {\n+                throw new SkipException(\"Skip tests - IPv4 support required\");\n+            }\n+            return;\n+        }\n+    }\n+\n+    record ExpectedResult(String ipv4stack, String ipv6addresses, int characteristics) {\n+        ExpectedResult {\n+            if (!IPSupport.hasIPv4()) {\n+                characteristics = IPV6;\n+            } else if (!IPSupport.hasIPv6()) {\n+                characteristics = IPV4;\n+            }\n+        }\n+\n+        public String key() {\n+            return calculateMapKey(ipv4stack, ipv6addresses);\n+        }\n+    }\n+\n+    \/*\n+     *  Each row describes a combination of 'preferIPv4Stack', 'preferIPv6Addresses'\n+     *  values and the expected characteristic value\n+     *\/\n+    private static List<ExpectedResult> EXPECTED_RESULTS_TABLE = List.of(\n+            new ExpectedResult(\"true\", \"true\", IPV4),\n+            new ExpectedResult(\"true\", \"false\", IPV4),\n+            new ExpectedResult(\"true\", \"system\", IPV4),\n+            new ExpectedResult(\"true\", \"\", IPV4),\n+            new ExpectedResult(\"true\", null, IPV4),\n+\n+            new ExpectedResult(\"false\", \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(\"false\", \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"false\", \"system\", IPV4 | IPV6),\n+            new ExpectedResult(\"false\", \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"false\", null, IPV4 | IPV6 | IPV4_FIRST),\n+\n+            new ExpectedResult(\"\", \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(\"\", \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"\", \"system\", IPV4 | IPV6),\n+            new ExpectedResult(\"\", \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"\", null, IPV4 | IPV6 | IPV4_FIRST),\n+\n+            new ExpectedResult(null, \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(null, \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(null, \"system\", IPV4 | IPV6),\n+            new ExpectedResult(null, \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(null, null, IPV4 | IPV6 | IPV4_FIRST));\n+\n+    private static final Map<String, Integer> EXPECTED_RESULTS_MAP = calculateExpectedCharacteristics();\n+\n+    private static Map<String, Integer> calculateExpectedCharacteristics() {\n+        return EXPECTED_RESULTS_TABLE.stream()\n+                .collect(Collectors.toUnmodifiableMap(\n+                        ExpectedResult::key,\n+                        ExpectedResult::characteristics)\n+                );\n+    }\n+\n+    private static String calculateMapKey(String ipv4stack, String ipv6addresses) {\n+        return ipv4stack + \"_\" + ipv6addresses;\n+    }\n+\n+    private static boolean characteristicsMatch(int actual, int expected) {\n+        System.err.printf(\"Comparing characteristics:%n\\tActual: %s%n\\tExpected: %s%n\",\n+                Integer.toBinaryString(actual),\n+                Integer.toBinaryString(expected));\n+        return (actual & (IPV4 | IPV6 | IPV4_FIRST | IPV6_FIRST)) == expected;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/LookupPolicyMappingTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary check if LookupPolicy.of correctly handles valid and illegal\n+ * combinations of characteristics bit mask flags.\n+ * @run testng LookupPolicyOfTest\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.util.List;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n+public class LookupPolicyOfTest {\n+\n+    @Test(dataProvider = \"validCharacteristics\")\n+    public void testValidCharacteristicCombinations(List<Integer> validCombination) {\n+        LookupPolicy.of(bitFlagsToCharacteristicsValue(validCombination));\n+    }\n+\n+    @Test(dataProvider = \"invalidCharacteristics\", expectedExceptions = IllegalArgumentException.class)\n+    public void testInvalidCharacteristicCombinations(List<Integer> invalidCombination) {\n+        LookupPolicy.of(bitFlagsToCharacteristicsValue(invalidCombination));\n+    }\n+\n+    @DataProvider(name = \"validCharacteristics\")\n+    public Object[][] validCharacteristicValue() {\n+        return new Object[][]{\n+                {List.of(IPV4)},\n+                {List.of(IPV4, IPV4_FIRST)},\n+                {List.of(IPV6)},\n+                {List.of(IPV6, IPV6_FIRST)},\n+                {List.of(IPV4, IPV6)},\n+                {List.of(IPV4, IPV6, IPV4_FIRST)},\n+                {List.of(IPV4, IPV6, IPV6_FIRST)},\n+                \/\/ Custom flag values alongside to address type flags\n+                \/\/ that could be used by custom providers\n+                {List.of(IPV4, IPV6, 0x10)},\n+                {List.of(IPV4, IPV6, 0x20)},\n+        };\n+    }\n+\n+    @DataProvider(name = \"invalidCharacteristics\")\n+    public Object[][] illegalCharacteristicValue() {\n+        return new Object[][]{\n+                {List.of()},\n+                {List.of(IPV4_FIRST)},\n+                {List.of(IPV6_FIRST)},\n+                {List.of(IPV4_FIRST, IPV6_FIRST)},\n+                {List.of(IPV4, IPV6_FIRST)},\n+                {List.of(IPV6, IPV4_FIRST)},\n+                {List.of(IPV4, IPV6, IPV4_FIRST, IPV6_FIRST)},\n+        };\n+    }\n+\n+    private static int bitFlagsToCharacteristicsValue(List<Integer> bitFlagsList) {\n+        return bitFlagsList.stream()\n+                .reduce(0, (flag1, flag2) -> flag1 | flag2);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/LookupPolicyOfTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/NeverCache.props","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static impl.FaultyResolverProviderGetImpl.EXCEPTION_MESSAGE;\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddress fast-fails if custom provider fails to\n+ *  instantiate a resolver.\n+ * @library providers\/faulty\n+ * @build faulty.provider\/impl.FaultyResolverProviderGetImpl\n+ * @run testng\/othervm ProviderGetExceptionTest\n+ *\/\n+\n+public class ProviderGetExceptionTest {\n+\n+    @Test\n+    public void getByNameExceptionTest() {\n+        String hostName = \"test.host\";\n+        System.out.println(\"Looking up address for the following host name:\" + hostName);\n+        callInetAddressAndCheckException(() -> InetAddress.getByName(hostName));\n+    }\n+\n+    @Test\n+    public void getByAddressExceptionTest() {\n+        byte[] address = new byte[]{1, 2, 3, 4};\n+        System.out.println(\"Looking up host name for the following address:\" + Arrays.toString(address));\n+        callInetAddressAndCheckException(() -> InetAddress.getByAddress(address).getHostName());\n+    }\n+\n+    private void callInetAddressAndCheckException(Assert.ThrowingRunnable apiCall) {\n+        IllegalArgumentException iae = Assert.expectThrows(IllegalArgumentException.class, apiCall);\n+        System.out.println(\"Got exception of expected type:\" + iae);\n+        Assert.assertNull(iae.getCause(), \"cause is not null\");\n+        Assert.assertEquals(iae.getMessage(), EXCEPTION_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ProviderGetExceptionTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import impl.ThrowingLookupsProviderImpl;\n+\n+import static impl.ThrowingLookupsProviderImpl.RUNTIME_EXCEPTION_MESSAGE;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that only UnknownHostException is thrown if resolver\n+ * implementation throws RuntimeException during forward or reverse lookup.\n+ * @library providers\/throwing\n+ * @build throwing.lookups.provider\/impl.ThrowingLookupsProviderImpl\n+ * @run testng\/othervm ResolutionWithExceptionTest\n+ *\/\n+\n+public class ResolutionWithExceptionTest {\n+\n+    @Test\n+    public void getByNameUnknownHostException() {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = false;\n+        runGetByNameTest();\n+    }\n+\n+    @Test\n+    public void getByNameRuntimeException() {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = true;\n+        runGetByNameTest();\n+    }\n+\n+    @Test\n+    public void getByAddressUnknownHostException() throws UnknownHostException {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = false;\n+        runGetByAddressTest();\n+    }\n+\n+    @Test\n+    public void getByAddressRuntimeException() throws UnknownHostException {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = true;\n+        runGetByAddressTest();\n+    }\n+\n+    private void runGetByNameTest() {\n+        \/\/ InetAddress.getByName() is expected to throw UnknownHostException in all cases\n+        UnknownHostException uhe = Assert.expectThrows(UnknownHostException.class,\n+                () -> InetAddress.getByName(\"doesnt.matter.com\"));\n+        \/\/ If provider is expected to throw RuntimeException - check that UnknownHostException\n+        \/\/ is set as its cause\n+        if (ThrowingLookupsProviderImpl.throwRuntimeException) {\n+            Throwable cause = uhe.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                \/\/ Check RuntimeException message\n+                Assert.assertEquals(re.getMessage(), RUNTIME_EXCEPTION_MESSAGE,\n+                        \"incorrect exception message\");\n+            } else {\n+                Assert.fail(\"UnknownHostException cause is not RuntimeException\");\n+            }\n+        }\n+    }\n+\n+    private void runGetByAddressTest() throws UnknownHostException {\n+        \/\/ getCanonicalHostName is not expected to throw an exception:\n+        \/\/ if there is an error during reverse lookup operation the literal IP\n+        \/\/ address String will be returned.\n+        String literalIP = InetAddress.getByAddress(new byte[]{1, 2, 3, 4}).getCanonicalHostName();\n+        Assert.assertEquals(literalIP, \"1.2.3.4\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ResolutionWithExceptionTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.SocketPermission;\n+import java.net.UnknownHostException;\n+import java.security.Permission;\n+import java.util.logging.Logger;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that resolution of host name requires SocketPermission(\"resolve\", <host name>)\n+ * permission when running with security manager and custom resolver provider installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        ResolvePermissionTest\n+ * @run testng\/othervm -Dtest.dataFileName=nonExistentFile ResolvePermissionTest\n+ *\/\n+\n+public class ResolvePermissionTest {\n+\n+    @Test\n+    public void withResolvePermission() throws Exception {\n+        testResolvePermission(true);\n+    }\n+\n+    @Test\n+    public void noResolvePermission() throws Exception {\n+        testResolvePermission(false);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void testResolvePermission(boolean grantResolvePermission) throws Exception {\n+        \/\/ Set security manager which grants or denies permission to resolve 'javaTest.org' host\n+        var securityManager = new ResolvePermissionTest.TestSecurityManager(grantResolvePermission);\n+        try {\n+            System.setSecurityManager(securityManager);\n+            Class expectedExceptionClass = grantResolvePermission ?\n+                    UnknownHostException.class : SecurityException.class;\n+            var exception = Assert.expectThrows(expectedExceptionClass, () -> InetAddress.getByName(\"javaTest.org\"));\n+            LOGGER.info(\"Got expected exception: \" + exception);\n+        } finally {\n+            System.setSecurityManager(null);\n+        }\n+    }\n+\n+    static class TestSecurityManager extends SecurityManager {\n+        final boolean allowJavaTestOrgResolve;\n+\n+        public TestSecurityManager(boolean allowJavaTestOrgResolve) {\n+            this.allowJavaTestOrgResolve = allowJavaTestOrgResolve;\n+        }\n+\n+        @Override\n+        public void checkPermission(Permission permission) {\n+            if (permission instanceof java.net.SocketPermission) {\n+                SocketPermission sockPerm = (SocketPermission) permission;\n+                if (\"resolve\".equals(sockPerm.getActions())) {\n+                    String host = sockPerm.getName();\n+                    LOGGER.info(\"Checking 'resolve' SocketPermission: \" + permission);\n+                    if (\"javaTest.org\".equals(host) && !allowJavaTestOrgResolve) {\n+                        LOGGER.info(\"Denying 'resolve' permission for 'javaTest.org'\");\n+                        throw new SecurityException(\"Access Denied\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final Logger LOGGER = Logger.getLogger(ResolvePermissionTest.class.getName());\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ResolvePermissionTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import impl.DelegatingProviderImpl;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import static impl.DelegatingProviderImpl.changeReverseLookupAddress;\n+import static impl.DelegatingProviderImpl.lastReverseLookupThrowable;\n+\n+\/*\n+ * @test\n+ * @summary checks delegation of illegal reverse lookup request to the built-in\n+ *  InetAddressResolver.\n+ * @library providers\/delegating\n+ * @build delegating.provider\/impl.DelegatingProviderImpl\n+ * @run testng\/othervm ReverseLookupDelegationTest\n+ *\/\n+public class ReverseLookupDelegationTest {\n+\n+    @Test\n+    public void delegateHostNameLookupWithWrongByteArray() throws UnknownHostException {\n+        \/\/ The underlying resolver implementation will ignore the supplied\n+        \/\/ byte array and will replace it with byte array of incorrect size.\n+        changeReverseLookupAddress = true;\n+        String canonicalHostName = InetAddress.getByAddress(new byte[]{1, 2, 3, 4}).getCanonicalHostName();\n+        \/\/ Output canonical host name and the exception thrown by the built-in resolver\n+        System.err.println(\"Canonical host name:\" + canonicalHostName);\n+        System.err.println(\"Exception thrown by the built-in resolver:\" + lastReverseLookupThrowable);\n+\n+        \/\/ Check that originally supplied byte array was used to construct canonical host name after\n+        \/\/ failed reverse lookup.\n+        Assert.assertEquals(\"1.2.3.4\", canonicalHostName, \"unexpected canonical hostname\");\n+\n+        \/\/ Check that on a provider side the IllegalArgumentException has been thrown by the built-in resolver\n+        Assert.assertTrue(lastReverseLookupThrowable instanceof IllegalArgumentException,\n+                \"wrong exception type is thrown by the built-in resolver\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ReverseLookupDelegationTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.security.Permission;\n+import java.util.ServiceConfigurationError;\n+import java.util.logging.Logger;\n+\n+\/*\n+ * @test\n+ * @summary Test that instantiation of InetAddressResolverProvider requires \"inetAddressResolverProvider\"\n+ *          RuntimePermission when running with security manager.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        RuntimePermissionTest\n+ * @run testng\/othervm RuntimePermissionTest\n+ *\/\n+\n+public class RuntimePermissionTest {\n+\n+    @Test\n+    public void withRuntimePermission() throws Exception {\n+        testRuntimePermission(true);\n+    }\n+\n+    @Test\n+    public void noRuntimePermission() throws Exception {\n+        testRuntimePermission(false);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void testRuntimePermission(boolean permitInetAddressResolver) throws Exception {\n+        \/\/ Set security manager which grants all permissions + RuntimePermission(\"inetAddressResolverProvider\")\n+        var securityManager = new TestSecurityManager(permitInetAddressResolver);\n+        try {\n+            System.setSecurityManager(securityManager);\n+            if (permitInetAddressResolver) {\n+                InetAddress.getByName(\"javaTest.org\");\n+            } else {\n+                ServiceConfigurationError sce =\n+                        Assert.expectThrows(ServiceConfigurationError.class,\n+                                            () -> InetAddress.getByName(\"javaTest.org\"));\n+                LOGGER.info(\"Got ServiceConfigurationError: \" + sce);\n+                Throwable cause = sce.getCause();\n+                Assert.assertTrue(cause instanceof SecurityException);\n+                Assert.assertTrue(cause.getMessage().contains(RUNTIME_PERMISSION_NAME));\n+            }\n+        } finally {\n+            System.setSecurityManager(null);\n+        }\n+    }\n+\n+    static class TestSecurityManager extends SecurityManager {\n+        final boolean permitInetAddressResolver;\n+\n+        public TestSecurityManager(boolean permitInetAddressResolver) {\n+            this.permitInetAddressResolver = permitInetAddressResolver;\n+            LOGGER.info(\"inetAddressResolverProvider permission is \" +\n+                        (permitInetAddressResolver ? \"granted\" : \"not granted\"));\n+        }\n+\n+        @Override\n+        public void checkPermission(Permission permission) {\n+            if (permission instanceof RuntimePermission) {\n+                LOGGER.info(\"Checking RuntimePermission: \" + permission);\n+                if (RUNTIME_PERMISSION_NAME.equals(permission.getName()) && !permitInetAddressResolver) {\n+                    LOGGER.info(\"Denying '\" + RUNTIME_PERMISSION_NAME + \"' permission\");\n+                    throw new SecurityException(\"Access Denied: \" + RUNTIME_PERMISSION_NAME);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final String RUNTIME_PERMISSION_NAME = \"inetAddressResolverProvider\";\n+    private static final Logger LOGGER = Logger.getLogger(RuntimePermissionTest.class.getName());\n+\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/RuntimePermissionTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for InetAddressResolverProvider SPI tests\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    javaTest.org\n+[ca:fe:ba:be::1] javaTest.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module test.library {\n+    exports testlib;\n+    requires java.logging;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/lib\/test.library\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package testlib;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.Comparator;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.*;\n+\n+public class ResolutionRegistry {\n+\n+    \/\/ Map to store hostName -> InetAddress mappings\n+    private final Map<String, List<byte[]>> registry;\n+    private static final int IPV4_RAW_LEN = 4;\n+    private static final int IPV6_RAW_LEN = 16;\n+\n+    private static final Logger LOGGER = Logger.getLogger(ResolutionRegistry.class.getName());\n+\n+    public ResolutionRegistry() {\n+\n+        \/\/ Populate registry from test data file\n+        String fileName = System.getProperty(\"test.dataFileName\", \"addresses.txt\");\n+        Path addressesFile = Paths.get(System.getProperty(\"test.src\", \".\")).resolve(fileName);\n+        LOGGER.info(\"Creating ResolutionRegistry instance from file:\" + addressesFile);\n+        registry = parseDataFile(addressesFile);\n+    }\n+\n+    private Map<String, List<byte[]>> parseDataFile(Path addressesFile) {\n+        try {\n+            if (addressesFile.toFile().isFile()) {\n+                Map<String, List<byte[]>> resReg = new ConcurrentHashMap<>();\n+                \/\/ Prepare list of hostname\/address entries\n+                List<String[]> entriesList = Files.readAllLines(addressesFile).stream()\n+                        .map(String::trim)\n+                        .filter(Predicate.not(String::isBlank))\n+                        .filter(s -> !s.startsWith(\"#\"))\n+                        .map(s -> s.split(\"\\\\s+\"))\n+                        .filter(sarray -> sarray.length == 2)\n+                        .filter(ResolutionRegistry::hasLiteralAddress)\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                \/\/ Convert list of entries into registry Map\n+                for (var entry : entriesList) {\n+                    String ipAddress = entry[0].trim();\n+                    String hostName = entry[1].trim();\n+                    byte[] addrBytes = toByteArray(ipAddress);\n+                    if (addrBytes != null) {\n+                        var list = resReg.containsKey(hostName) ? resReg.get(hostName) : new ArrayList();\n+                        list.add(addrBytes);\n+                        if (!resReg.containsKey(hostName)) {\n+                            resReg.put(hostName, list);\n+                        }\n+                    }\n+                }\n+                resReg.replaceAll((k, v) -> Collections.unmodifiableList(v));\n+                \/\/ Print constructed registry\n+                StringBuilder sb = new StringBuilder(\"Constructed addresses registry:\" + System.lineSeparator());\n+                for (var entry : resReg.entrySet()) {\n+                    sb.append(\"\\t\" + entry.getKey() + \": \");\n+                    for (byte[] addr : entry.getValue()) {\n+                        sb.append(addressBytesToString(addr) + \" \");\n+                    }\n+                    sb.append(System.lineSeparator());\n+                }\n+                LOGGER.info(sb.toString());\n+                return resReg;\n+            } else {\n+                \/\/ If file doesn't exist - return empty map\n+                return Collections.emptyMap();\n+            }\n+        } catch (IOException ioException) {\n+            \/\/ If any problems parsing the file - log a warning and return an empty map\n+            LOGGER.log(Level.WARNING, \"Error reading data file\", ioException);\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    \/\/ Line is not a blank and not a comment\n+    private static boolean hasLiteralAddress(String[] lineFields) {\n+        String addressString = lineFields[0].trim();\n+        return addressString.charAt(0) == '[' ||\n+                Character.digit(addressString.charAt(0), 16) != -1 ||\n+                (addressString.charAt(0) == ':');\n+    }\n+\n+    \/\/ Line is not blank and not comment\n+    private static byte[] toByteArray(String addressString) {\n+        InetAddress address;\n+        \/\/ Will reuse InetAddress functionality to parse literal IP address\n+        \/\/ strings. This call is guarded by 'hasLiteralAddress' method.\n+        try {\n+            address = InetAddress.getByName(addressString);\n+        } catch (UnknownHostException unknownHostException) {\n+            LOGGER.warning(\"Can't parse address string:'\" + addressString + \"'\");\n+            return null;\n+        }\n+        return address.getAddress();\n+    }\n+\n+    public Stream<InetAddress> lookupHost(String host, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        LOGGER.info(\"Looking-up '\" + host + \"' address\");\n+        if (!registry.containsKey(host)) {\n+            LOGGER.info(\"Registry doesn't contain addresses for '\" + host + \"'\");\n+            throw new UnknownHostException(host);\n+        }\n+\n+        int characteristics = lookupPolicy.characteristics();\n+        \/\/ Filter IPV4 or IPV6 as needed. Then sort with\n+        \/\/ comparator for IPV4_FIRST or IPV6_FIRST.\n+        return registry.get(host)\n+                .stream()\n+                .filter(ba -> filterAddressByLookupPolicy(ba, characteristics))\n+                .sorted(new AddressOrderPref(characteristics))\n+                .map(ba -> constructInetAddress(host, ba))\n+                .filter(Objects::nonNull);\n+    }\n+\n+    private static boolean filterAddressByLookupPolicy(byte[] ba, int ch) {\n+        \/\/ If 0011, return both. If 0001, IPv4. If 0010, IPv6\n+        boolean ipv4Flag = (ch & IPV4) == IPV4;\n+        boolean ipv6Flag = (ch & IPV6) == IPV6;\n+\n+        if (ipv4Flag && ipv6Flag)\n+            return true; \/\/ Return regardless of length\n+        else if (ipv4Flag)\n+            return (ba.length == IPV4_RAW_LEN);\n+        else if (ipv6Flag)\n+            return (ba.length == IPV6_RAW_LEN);\n+\n+        throw new RuntimeException(\"Lookup policy characteristics were improperly set. \" +\n+                \"Characteristics: \" + Integer.toString(ch, 2));\n+    }\n+\n+    private static InetAddress constructInetAddress(String host, byte[] address) {\n+        try {\n+            return InetAddress.getByAddress(host, address);\n+        } catch (UnknownHostException unknownHostException) {\n+            return null;\n+        }\n+    }\n+\n+    public String lookupAddress(byte[] addressBytes) {\n+        for (var entry : registry.entrySet()) {\n+            if (entry.getValue()\n+                    .stream()\n+                    .filter(ba -> Arrays.equals(ba, addressBytes))\n+                    .findAny()\n+                    .isPresent()) {\n+                return entry.getKey();\n+            }\n+        }\n+        try {\n+            return InetAddress.getByAddress(addressBytes).getHostAddress();\n+        } catch (UnknownHostException unknownHostException) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public boolean containsAddressMapping(InetAddress address) {\n+        String hostName = address.getHostName();\n+        if (registry.containsKey(hostName)) {\n+            var mappedBytes = registry.get(address.getHostName());\n+            for (byte[] mappedAddr : mappedBytes) {\n+                if (Arrays.equals(mappedAddr, address.getAddress())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static String addressBytesToString(byte[] bytes) {\n+        try {\n+            return InetAddress.getByAddress(bytes).toString();\n+        } catch (UnknownHostException unknownHostException) {\n+            return Arrays.toString(bytes);\n+        }\n+    }\n+\n+    private class AddressOrderPref implements Comparator<byte[]> {\n+\n+        private final int ch;\n+\n+        AddressOrderPref(int ch) {\n+            this.ch = ch;\n+        }\n+\n+        @Override\n+        public int compare(byte[] o1, byte[] o2) {\n+            \/\/ Compares based on address length, 4 bytes for IPv4,\n+            \/\/ 16 bytes for IPv6.\n+            return ((ch & IPV4_FIRST) == IPV4_FIRST) ?\n+                    Integer.compare(o1.length, o2.length) :\n+                    Integer.compare(o2.length, o1.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/lib\/test.library\/testlib\/ResolutionRegistry.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class WithBootstrapResolverUsageProvider extends InetAddressResolverProvider {\n+\n+    public static volatile long numberOfGetCalls;\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        numberOfGetCalls++;\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+        System.out.println(\"InetAddressResolverProvider::get() called \" + numberOfGetCalls + \" times\");\n+\n+        \/\/ We use different names to avoid InetAddress-level caching\n+        doLookup(\"foo\" + numberOfGetCalls + \".A.org\");\n+\n+        \/\/ We need second call to test how InetAddress internals maintain reference to a bootstrap resolver\n+        doLookup(\"foo\" + numberOfGetCalls + \".B.org\");\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                return Stream.of(InetAddress.getByAddress(host, new byte[]{127, 0, 2, 1}));\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    \/\/ Perform an InetAddress resolution lookup operation\n+    private static void doLookup(String hostName) {\n+        try {\n+            InetAddress.getByName(hostName);\n+        } catch (UnknownHostException e) {\n+            \/\/ Ignore UHE since the bootstrap resolver is used here\n+        }\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"WithBootstrapResolverUsageProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/impl\/WithBootstrapResolverUsageProvider.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module bootstrap.usage.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.WithBootstrapResolverUsageProvider;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class DelegatingProviderImpl extends InetAddressResolverProvider {\n+\n+    public static volatile boolean changeReverseLookupAddress;\n+    public static volatile Throwable lastReverseLookupThrowable;\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByName(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                try {\n+                    if (!changeReverseLookupAddress) {\n+                        return configuration.builtinResolver().lookupByAddress(addr);\n+                    } else {\n+                        \/\/ Deliberately supply address bytes array with wrong size\n+                        return configuration.builtinResolver().lookupByAddress(new byte[]{1, 2, 3});\n+                    }\n+                } catch (Throwable t) {\n+                    lastReverseLookupThrowable = t;\n+                    throw t;\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"DelegatingProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/delegating\/delegating.provider\/impl\/DelegatingProviderImpl.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module delegating.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.DelegatingProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/delegating\/delegating.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class EmptyResultsProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                return Stream.empty();\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"EmptyForwardLookupResultsProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/empty\/empty.results.provider\/impl\/EmptyResultsProviderImpl.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module empty.results.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.EmptyResultsProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/empty\/empty.results.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver;\n+\n+public class FaultyResolverProviderGetImpl extends InetAddressResolverProvider {\n+    public static final String EXCEPTION_MESSAGE = \"This provider provides nothing\";\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        throw new IllegalArgumentException(EXCEPTION_MESSAGE);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"faultyInetAddressResolverGet\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/faulty\/faulty.provider\/impl\/FaultyResolverProviderGetImpl.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module faulty.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.FaultyResolverProviderGetImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/faulty\/faulty.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class InetAddressUsageInGetProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        String localHostName;\n+        try {\n+            localHostName = InetAddress.getLocalHost().getHostName();\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(\"Provider failed to initialize\");\n+        }\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                if (host.equals(localHostName)) {\n+                    return configuration.builtinResolver().lookupByName(host, lookupPolicy);\n+                } else {\n+                    throw new UnknownHostException(host);\n+                }\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"ProviderWithInetAddressUsageInGet\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/recursive\/recursive.init.provider\/impl\/InetAddressUsageInGetProviderImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module recursive.init.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.InetAddressUsageInGetProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/recursive\/recursive.init.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import testlib.ResolutionRegistry;\n+\n+public class SimpleResolverProviderImpl extends InetAddressResolverProvider {\n+\n+    public static ResolutionRegistry registry = new ResolutionRegistry();\n+    private static List<LookupPolicy> LOOKUP_HISTORY = Collections.synchronizedList(new ArrayList<>());\n+    private static volatile long LAST_LOOKUP_TIMESTAMP;\n+    private static Logger LOGGER = Logger.getLogger(SimpleResolverProviderImpl.class.getName());\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                LOGGER.info(\"Looking-up addresses for '\" + host + \"'. Lookup characteristics:\" +\n+                        Integer.toString(lookupPolicy.characteristics(), 2));\n+                LOOKUP_HISTORY.add(lookupPolicy);\n+                LAST_LOOKUP_TIMESTAMP = System.nanoTime();\n+                return registry.lookupHost(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                LOGGER.info(\"Looking host name for the following address:\" + ResolutionRegistry.addressBytesToString(addr));\n+                return registry.lookupAddress(addr);\n+            }\n+        };\n+    }\n+\n+    \/\/ Utility methods\n+    public static LookupPolicy lastLookupPolicy() {\n+        return lookupPolicyHistory(0);\n+    }\n+\n+    public static long getLastLookupTimestamp() {\n+        return LAST_LOOKUP_TIMESTAMP;\n+    }\n+\n+    public static LookupPolicy lookupPolicyHistory(int position) {\n+        if (LOOKUP_HISTORY.isEmpty()) {\n+            throw new RuntimeException(\"No registered lookup policies\");\n+        }\n+        if (position >= LOOKUP_HISTORY.size()) {\n+            throw new IllegalArgumentException(\"No element available with provided position\");\n+        }\n+        return LOOKUP_HISTORY.get(LOOKUP_HISTORY.size() - position - 1);\n+    }\n+\n+\n+    @Override\n+    public String name() {\n+        return \"simpleInetAddressResolver\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/impl\/SimpleResolverProviderImpl.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module simple.provider {\n+    exports impl;\n+    requires java.logging;\n+    requires test.library;\n+    provides InetAddressResolverProvider with impl.SimpleResolverProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/module-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class ThrowingLookupsProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                if (throwRuntimeException) {\n+                    System.err.println(name()+\" forward lookup: throwing RuntimeException\");\n+                    throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+                } else {\n+                    System.err.println(name()+\" forward lookup: throwing UnknownHostException\");\n+                    throw new UnknownHostException();\n+                }\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                if (throwRuntimeException) {\n+                    System.err.println(name()+\" reverse lookup: throwing RuntimeException\");\n+                    throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+                } else {\n+                    System.err.println(name()+\" reverse lookup: throwing UnknownHostException\");\n+                    throw new UnknownHostException();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"ThrowingLookupsProvider\";\n+    }\n+\n+    \/\/ Indicates if provider need to throw RuntimeException for forward and reverse lookup operations.\n+    \/\/ If it is set to 'false' then UnknownHostException will thrown for each operation.\n+    public static volatile boolean throwRuntimeException;\n+    public static final String RUNTIME_EXCEPTION_MESSAGE = \"This provider only throws exceptions\";\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/throwing\/throwing.lookups.provider\/impl\/ThrowingLookupsProviderImpl.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module throwing.lookups.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.ThrowingLookupsProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/throwing\/throwing.lookups.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddressResolverProvider implementation can be installed to a class path.\n+ * @library ..\/..\/lib\n+ * @build test.library\/testlib.ResolutionRegistry ClasspathResolverProviderImpl\n+ * @run testng\/othervm ClasspathProviderTest\n+ *\/\n+\n+public class ClasspathProviderTest {\n+\n+    @Test\n+    public void testResolution() throws Exception {\n+        InetAddress inetAddress = InetAddress.getByName(\"classpath-provider-test.org\");\n+        System.err.println(\"Resolved address:\" + inetAddress);\n+\n+        if (!ClasspathResolverProviderImpl.registry.containsAddressMapping(inetAddress)) {\n+            throw new RuntimeException(\"InetAddressResolverProvider was not properly installed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/ClasspathProviderTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import testlib.ResolutionRegistry;\n+\n+public class ClasspathResolverProviderImpl extends InetAddressResolverProvider {\n+\n+    public static ResolutionRegistry registry = new ResolutionRegistry();\n+    private static List<LookupPolicy> LOOKUP_HISTORY = Collections.synchronizedList(new ArrayList<>());\n+    private static Logger LOGGER = Logger.getLogger(ClasspathResolverProviderImpl.class.getName());\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                LOGGER.info(\"Looking-up addresses for '\" + host + \"'. Lookup characteristics:\" +\n+                        Integer.toString(lookupPolicy.characteristics(), 2));\n+                LOOKUP_HISTORY.add(lookupPolicy);\n+                return registry.lookupHost(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                LOGGER.info(\"Looking host name for the following address:\" + ResolutionRegistry.addressBytesToString(addr));\n+                return registry.lookupAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"classpathINSP\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/ClasspathResolverProviderImpl.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+ClasspathResolverProviderImpl\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/META-INF\/services\/java.net.spi.InetAddressResolverProvider","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for classpath origin type tests.\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    classpath-provider-test.org\n+[ca:fe:ba:be::1] classpath-provider-test.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that implementation of InetAddressResolverProvider can be installed to a module path.\n+ * @library ..\/..\/lib ..\/..\/providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        ModularProviderTest\n+ * @run testng\/othervm ModularProviderTest\n+ *\/\n+\n+\n+public class ModularProviderTest {\n+\n+    @Test\n+    public void testResolution() throws Exception {\n+        InetAddress inetAddress = InetAddress.getByName(\"modular-provider-test.org\");\n+        System.err.println(\"Resolved address:\" + inetAddress);\n+\n+        if (!impl.SimpleResolverProviderImpl.registry.containsAddressMapping(inetAddress)) {\n+            throw new RuntimeException(\"InetAddressResolverProvider was not properly installed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/module\/ModularProviderTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for tests in modularTests directory\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    modular-provider-test.org\n+[ca:fe:ba:be::1] modular-provider-test.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/module\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n@@ -31,4 +33,3 @@\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n+import java.net.ProtocolFamily;\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.SocketChannel;\n@@ -52,13 +53,2 @@\n-        try {\n-            InetAddress loopbackIPv4 = InetAddress.getByAddress(\n-                    new byte[] {0x7F, 0x00, 0x00, 0x01});\n-\n-            InetAddress loopbackIPv6 = InetAddress.getByAddress(\n-                    new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01});\n-\n-            hasIPv4 = runPrivilegedAction(() -> hasAddress(loopbackIPv4));\n-            hasIPv6 = runPrivilegedAction(() -> hasAddress(loopbackIPv6));\n-        } catch (UnknownHostException e) {\n-            throw new AssertionError(e);\n-        }\n+        hasIPv4 = runPrivilegedAction(() -> isSupported(Inet4Address.class));\n+        hasIPv6 = runPrivilegedAction(() -> isSupported(Inet6Address.class));\n@@ -74,3 +64,4 @@\n-    private static boolean hasAddress(InetAddress address) {\n-        try (Socket socket = new Socket()) {\n-            socket.bind(new InetSocketAddress(address, 0));\n+    private static boolean isSupported(Class<? extends InetAddress> addressType) {\n+        ProtocolFamily family = addressType == Inet4Address.class ?\n+                StandardProtocolFamily.INET : StandardProtocolFamily.INET6;\n+        try (var sc = SocketChannel.open(family)) {\n@@ -78,1 +69,1 @@\n-        } catch (SocketException se) {\n+        } catch (IOException | UnsupportedOperationException ex) {\n@@ -80,2 +71,0 @@\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n","filename":"test\/lib\/jdk\/test\/lib\/net\/IPSupport.java","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"}]}