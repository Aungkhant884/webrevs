{"files":[{"patch":"@@ -231,1 +231,1 @@\n- *      method. The instantiated {@code InetAddressResolver} will be installed as the system-wide\n+ *      method. The returned {@code InetAddressResolver} will be installed as the system-wide\n@@ -461,0 +461,1 @@\n+            boolean bootstrapSet = false;\n@@ -469,2 +470,0 @@\n-                } else {\n-                    bootstrapResolver = BUILTIN_RESOLVER;\n@@ -472,0 +471,3 @@\n+                bootstrapResolver = BUILTIN_RESOLVER;\n+                bootstrapSet = true;\n+\n@@ -486,1 +488,5 @@\n-                bootstrapResolver = null;\n+                \/\/ We want to clear bootstrap resolver reference only after an attempt to\n+                \/\/ instantiate a resolver has been completed.\n+                if (bootstrapSet) {\n+                    bootstrapResolver = null;\n+                }\n@@ -860,0 +866,3 @@\n+        \/\/ 'resolver.lookUpHostName' and 'InetAddress.getAllByName0' delegate to the system-wide resolver,\n+        \/\/ which could be a custom one. At that point we treat any unexpected RuntimeException thrown by\n+        \/\/ the resolver as we would treat an UnknownHostException or an unmatched host name.\n@@ -1064,0 +1073,1 @@\n+            Objects.requireNonNull(policy);\n@@ -1203,10 +1213,4 @@\n-            \/\/ Check number of found addresses:\n-            \/\/ If none found - throw an exception\n-            boolean noAddressFound = inetAddresses.isEmpty();\n-            \/\/ needIPv4 == false and needIPv6 is not a valid combination. See LookupPolicy.of.\n-            if (needIPv4 != needIPv6) {\n-                if (needIPv4) {\n-                    noAddressFound = inet4Addresses.isEmpty();\n-                } else {\n-                    noAddressFound = inet6Addresses.isEmpty();\n-                }\n+            \/\/ Check if only IPv4 addresses are requested\n+            if (needIPv4 && !needIPv6) {\n+                checkResultsList(inet4Addresses, host);\n+                return inet4Addresses.stream();\n@@ -1214,3 +1218,4 @@\n-            if (noAddressFound) {\n-                throw new UnknownHostException(\"Unable to resolve host \" + host\n-                        + \" in hosts file \" + hostsFile);\n+            \/\/ Check if only IPv6 addresses are requested\n+            if (!needIPv4 && needIPv6) {\n+                checkResultsList(inet6Addresses, host);\n+                return inet6Addresses.stream();\n@@ -1218,10 +1223,8 @@\n-\n-            \/\/ If both address types are requested\n-            if (needIPv4 == needIPv6) {\n-                if (systemAddressesOrder(flags)) {\n-                    return inetAddresses.stream();\n-                } else if (ipv6AddressesFirst(flags)) {\n-                    return Stream.concat(inet6Addresses.stream(), inet4Addresses.stream());\n-                } else if (ipv4AddressesFirst(flags)) {\n-                    return Stream.concat(inet4Addresses.stream(), inet6Addresses.stream());\n-                }\n+            \/\/ If both type of addresses are requested:\n+            \/\/ First, check if there is any results. Then arrange\n+            \/\/ addresses according to LookupPolicy value.\n+            checkResultsList(inetAddresses, host);\n+            if (ipv6AddressesFirst(flags)) {\n+                return Stream.concat(inet6Addresses.stream(), inet4Addresses.stream());\n+            } else if (ipv4AddressesFirst(flags)) {\n+                return Stream.concat(inet4Addresses.stream(), inet6Addresses.stream());\n@@ -1229,3 +1232,12 @@\n-            \/\/ Only IPv4 addresses are requested\n-            if (needIPv4) {\n-                return inet4Addresses.stream();\n+            \/\/ Only \"system\" addresses order is possible at this stage\n+            assert systemAddressesOrder(flags);\n+            return inetAddresses.stream();\n+        }\n+\n+        \/\/ Checks if result list with addresses is not empty.\n+        \/\/ If it is empty throw an UnknownHostException.\n+        private void checkResultsList(List<InetAddress> addressesList, String hostName)\n+                throws UnknownHostException {\n+            if (addressesList.isEmpty()) {\n+                throw new UnknownHostException(\"Unable to resolve host \" + hostName\n+                        + \" in hosts file \" + hostsFile);\n@@ -1233,2 +1245,0 @@\n-            \/\/ Only IPv6 addresses are requested\n-            return inet6Addresses.stream();\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static impl.WithBootstrapResolverUsageProvider.numberOfGetCalls;\n+\n+\/**\n+ * @test\n+ * @summary Test that InetAddress class properly avoids stack-overflow by\n+ * correctly tracking the bootstrap resolver instance when\n+ * InetAddressResolverProvider.get method uses InetAddress lookup API.\n+ * @library providers\/bootstrapUsage\n+ * @build bootstrap.usage.provider\/impl.WithBootstrapResolverUsageProvider\n+ * @run testng\/othervm BootstrapResolverUsageTest\n+ *\/\n+\n+public class BootstrapResolverUsageTest {\n+\n+    @Test\n+    public void testSuccessfulProviderInstantiationTest() throws Exception {\n+        System.err.println(InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()));\n+        Assert.assertEquals(numberOfGetCalls, 1,\n+                \"InetAddressResolverProvider.get was called more than once\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/BootstrapResolverUsageTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class WithBootstrapResolverUsageProvider extends InetAddressResolverProvider {\n+\n+    public static volatile long numberOfGetCalls;\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        numberOfGetCalls++;\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+        System.out.println(\"InetAddressResolverProvider::get() called \" + numberOfGetCalls + \" times\");\n+\n+        \/\/ We use different names to avoid InetAddress-level caching\n+        doLookup(\"foo\" + numberOfGetCalls + \".A.org\");\n+\n+        \/\/ We need second call to test how InetAddress internals maintain reference to a bootstrap resolver\n+        doLookup(\"foo\" + numberOfGetCalls + \".B.org\");\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupAddresses(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                return Stream.of(InetAddress.getByAddress(host, new byte[]{127, 0, 2, 1}));\n+            }\n+\n+            @Override\n+            public String lookupHostName(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupHostName(addr);\n+            }\n+        };\n+    }\n+\n+    \/\/ Perform an InetAddress resolution lookup operation\n+    private static void doLookup(String hostName) {\n+        try {\n+            InetAddress.getByName(hostName);\n+        } catch (UnknownHostException e) {\n+            \/\/ Ignore UHE since the bootstrap resolver is used here\n+        }\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"WithBootstrapResolverUsageProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/impl\/WithBootstrapResolverUsageProvider.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module bootstrap.usage.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.WithBootstrapResolverUsageProvider;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n@@ -31,5 +33,3 @@\n-import java.net.InetSocketAddress;\n-import java.net.NetworkInterface;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n+import java.net.ProtocolFamily;\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.SocketChannel;\n@@ -53,13 +53,2 @@\n-        try {\n-            InetAddress loopbackIPv4 = InetAddress.getByAddress(\n-                    new byte[] {0x7F, 0x00, 0x00, 0x01});\n-\n-            InetAddress loopbackIPv6 = InetAddress.getByAddress(\n-                    new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01});\n-\n-            hasIPv4 = runPrivilegedAction(() -> hasAddress(loopbackIPv4));\n-            hasIPv6 = runPrivilegedAction(() -> hasAddress(loopbackIPv6));\n-        } catch (UnknownHostException e) {\n-            throw new AssertionError(e);\n-        }\n+        hasIPv4 = runPrivilegedAction(() -> isSupported(Inet4Address.class));\n+        hasIPv6 = runPrivilegedAction(() -> isSupported(Inet6Address.class));\n@@ -75,3 +64,4 @@\n-    private static boolean hasAddress(InetAddress address) {\n-        try (Socket socket = new Socket()) {\n-            socket.bind(new InetSocketAddress(address, 0));\n+    private static boolean isSupported(Class<? extends InetAddress> addressType) {\n+        ProtocolFamily family = addressType == Inet4Address.class ?\n+                StandardProtocolFamily.INET : StandardProtocolFamily.INET6;\n+        try (var sc = SocketChannel.open(family)) {\n@@ -79,12 +69,2 @@\n-        } catch (SocketException se) {\n-            try {\n-                return NetworkInterface.networkInterfaces()\n-                        .flatMap(NetworkInterface::inetAddresses)\n-                        .map(InetAddress::getClass)\n-                        .filter(clz -> clz.equals(address.getClass()))\n-                        .findAny().isPresent();\n-            } catch (SocketException se2) {\n-                return false;\n-            }\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+        } catch (IOException | UnsupportedOperationException ex) {\n+            return false;\n","filename":"test\/lib\/jdk\/test\/lib\/net\/IPSupport.java","additions":13,"deletions":33,"binary":false,"changes":46,"status":"modified"}]}