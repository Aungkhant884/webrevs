{"files":[{"patch":"@@ -3041,0 +3041,54 @@\n+void Assembler::vpmaskmovd(XMMRegister dst, XMMRegister mask, Address src, int vector_len) {\n+  assert((VM_Version::supports_avx2() && vector_len == AVX_256bit), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8C);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::vpmaskmovq(XMMRegister dst, XMMRegister mask, Address src, int vector_len) {\n+  assert((VM_Version::supports_avx2() && vector_len == AVX_256bit), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ false, \/* uses_vl *\/ false);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8C);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::vmaskmovps(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x2C);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::vmaskmovpd(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x2D);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::vmaskmovps(Address dst, XMMRegister src, XMMRegister mask, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(dst, mask->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x2E);\n+  emit_operand(src, dst);\n+}\n+\n+void Assembler::vmaskmovpd(Address dst, XMMRegister src, XMMRegister mask, int vector_len) {\n+  assert(UseAVX > 0, \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(dst, mask->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x2F);\n+  emit_operand(src, dst);\n+}\n+\n@@ -4397,8 +4451,0 @@\n-void Assembler::vpmaskmovd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n-  assert((VM_Version::supports_avx2() && vector_len == AVX_256bit), \"\");\n-  InstructionMark im(this);\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n-  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int8((unsigned char)0x8C);\n-  emit_operand(dst, src);\n-}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":54,"deletions":8,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1807,0 +1807,7 @@\n+  void vpmaskmovq(XMMRegister dst, XMMRegister mask, Address src, int vector_len);\n+\n+\n+  void vmaskmovps(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n+  void vmaskmovpd(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n+  void vmaskmovps(Address dst, XMMRegister src, XMMRegister mask, int vector_len);\n+  void vmaskmovpd(Address dst, XMMRegister src, XMMRegister mask, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1994,0 +1994,33 @@\n+void C2_MacroAssembler::vmovmask(BasicType elem_bt, XMMRegister dst, Address src, XMMRegister mask,\n+                                 int vec_enc) {\n+  switch(elem_bt) {\n+    case T_INT:\n+    case T_FLOAT:\n+      vmaskmovps(dst, src, mask, vec_enc);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmaskmovpd(dst, src, mask, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vmovmask(BasicType elem_bt, Address dst, XMMRegister src, XMMRegister mask,\n+                                 int vec_enc) {\n+  switch(elem_bt) {\n+    case T_INT:\n+    case T_FLOAT:\n+      vmaskmovps(dst, src, mask, vec_enc);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmaskmovpd(dst, src, mask, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -445,0 +445,5 @@\n+\n+  void vmovmask(BasicType elem_bt, XMMRegister dst, Address src, XMMRegister mask, int vec_enc);\n+\n+  void vmovmask(BasicType elem_bt, Address dst, XMMRegister src, XMMRegister mask, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1592,2 +1592,0 @@\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n@@ -1756,2 +1754,0 @@\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n@@ -1765,0 +1761,6 @@\n+    case Op_LoadVectorMasked:\n+    case Op_StoreVectorMasked:\n+      if (!VM_Version::supports_avx512bw() && (is_subword_type(bt) || UseAVX < 1)) {\n+        return false;\n+      }\n+      break;\n@@ -9081,1 +9083,0 @@\n-#ifdef _LP64\n@@ -9083,0 +9084,37 @@\n+instruct vmasked_load_avx_non_subword(vec dst, memory mem, vec mask) %{\n+  predicate(!n->in(3)->bottom_type()->isa_vectmask());\n+  match(Set dst (LoadVectorMasked mem mask));\n+  format %{ \"vector_masked_load $dst, $mem, $mask \\t! vector masked copy\" %}\n+  ins_encode %{\n+    BasicType elmType = this->bottom_type()->is_vect()->element_basic_type();\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vmovmask(elmType, $dst$$XMMRegister, $mem$$Address, $mask$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct vmasked_load_evex(vec dst, memory mem, kReg mask) %{\n+  predicate(n->in(3)->bottom_type()->isa_vectmask());\n+  match(Set dst (LoadVectorMasked mem mask));\n+  format %{ \"vector_masked_load $dst, $mem, $mask \\t! vector masked copy\" %}\n+  ins_encode %{\n+    BasicType elmType =  this->bottom_type()->is_vect()->element_basic_type();\n+    int vector_len = vector_length_encoding(this);\n+    __ evmovdqu(elmType, $mask$$KRegister, $dst$$XMMRegister, $mem$$Address, false, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmasked_store_avx_non_subword(memory mem, vec src, vec mask) %{\n+  predicate(!n->in(3)->in(2)->bottom_type()->isa_vectmask());\n+  match(Set mem (StoreVectorMasked mem (Binary src mask)));\n+  format %{ \"vector_masked_store $mem, $src, $mask \\t! vector masked store\" %}\n+  ins_encode %{\n+    const MachNode* src_node = static_cast<const MachNode*>(this->in(this->operand_index($src)));\n+    int vlen_enc = vector_length_encoding(src_node);\n+    BasicType elmType =  src_node->bottom_type()->is_vect()->element_basic_type();\n+    __ vmovmask(elmType, $mem$$Address, $src$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -9084,0 +9122,14 @@\n+instruct vmasked_store_evex(memory mem, vec src, kReg mask) %{\n+  predicate(n->in(3)->in(2)->bottom_type()->isa_vectmask());\n+  match(Set mem (StoreVectorMasked mem (Binary src mask)));\n+  format %{ \"vector_masked_store $mem, $src, $mask \\t! vector masked store\" %}\n+  ins_encode %{\n+    const MachNode* src_node = static_cast<const MachNode*>(this->in(this->operand_index($src)));\n+    BasicType elmType =  src_node->bottom_type()->is_vect()->element_basic_type();\n+    int vlen_enc = vector_length_encoding(src_node);\n+    __ evmovdqu(elmType, $mask$$KRegister, $mem$$Address, $src$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+#ifdef _LP64\n@@ -9110,11 +9162,0 @@\n-instruct vmasked_load64(vec dst, memory mem, kReg mask) %{\n-  match(Set dst (LoadVectorMasked mem mask));\n-  format %{ \"vector_masked_load $dst, $mem, $mask \\t! vector masked copy\" %}\n-  ins_encode %{\n-    BasicType elmType =  this->bottom_type()->is_vect()->element_basic_type();\n-    int vector_len = vector_length_encoding(this);\n-    __ evmovdqu(elmType, $mask$$KRegister, $dst$$XMMRegister, $mem$$Address, false, vector_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -9142,12 +9183,0 @@\n-instruct vmasked_store64(memory mem, vec src, kReg mask) %{\n-  match(Set mem (StoreVectorMasked mem (Binary src mask)));\n-  format %{ \"vector_masked_store $mem, $src, $mask \\t! vector masked store\" %}\n-  ins_encode %{\n-    const MachNode* src_node = static_cast<const MachNode*>(this->in(this->operand_index($src)));\n-    BasicType elmType =  src_node->bottom_type()->is_vect()->element_basic_type();\n-    int vector_len = vector_length_encoding(src_node);\n-    __ evmovdqu(elmType, $mask$$KRegister, $mem$$Address, $src$$XMMRegister, true, vector_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":57,"deletions":28,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1220,2 +1220,1 @@\n-                                                mem_num_elem, mem_elem_bt,\n-                                                (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred));\n+                                                mem_num_elem, mem_elem_bt, VecMaskUseLoad);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -907,2 +907,1 @@\n-    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n-    init_class_id(Class_StoreVector);\n+    init_class_id(Class_StoreVectorMasked);\n@@ -927,2 +926,1 @@\n-    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n-    init_class_id(Class_LoadVector);\n+    init_class_id(Class_LoadVectorMasked);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":0,"deletions":0,"binary":false,"changes":0,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class StoreMaskedIOOBEBenchmark {\n+    @Param({\"1024\"})\n+    private int inSize;\n+\n+    @Param({\"1022\"})\n+    private int outSize;\n+\n+    private byte[] byteIn;\n+    private byte[] byteOut;\n+    private short[] shortIn;\n+    private short[] shortOut;\n+    private int[] intIn;\n+    private int[] intOut;\n+    private long[] longIn;\n+    private long[] longOut;\n+    private float[] floatIn;\n+    private float[] floatOut;\n+    private double[] doubleIn;\n+    private double[] doubleOut;\n+\n+    private static final VectorSpecies<Byte> bspecies = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> sspecies = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> ispecies = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> lspecies = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> fspecies = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> dspecies = VectorSpecies.ofLargestShape(double.class);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        byteIn = new byte[inSize];\n+        byteOut = new byte[outSize];\n+        shortIn = new short[inSize];\n+        shortOut = new short[outSize];\n+        intIn = new int[inSize];\n+        intOut = new int[outSize];\n+        longIn = new long[inSize];\n+        longOut = new long[outSize];\n+        floatIn = new float[inSize];\n+        floatOut = new float[outSize];\n+        doubleIn = new double[inSize];\n+        doubleOut = new double[outSize];\n+\n+        for (int i = 0; i < inSize; i++) {\n+            byteIn[i] = (byte) i;\n+            shortIn[i] = (short) i;\n+            intIn[i] = i;\n+            longIn[i] = i;\n+            floatIn[i] = (float) i;\n+            doubleIn[i] = (double) i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byteStoreArrayMaskIOOBE() {\n+        VectorMask<Byte> mask = VectorMask.fromLong(bspecies, (1 << (bspecies.length() - 2)) - 1);\n+        for (int i = 0; i < inSize; i += bspecies.length()) {\n+            ByteVector.fromArray(bspecies, byteIn, i, mask).intoArray(byteOut, i, mask);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortStoreArrayMaskIOOBE() {\n+        VectorMask<Short> mask = VectorMask.fromLong(sspecies, (1 << (sspecies.length() - 2)) - 1);\n+        for (int i = 0; i < inSize; i += sspecies.length()) {\n+            ShortVector.fromArray(sspecies, shortIn, i).intoArray(shortOut, i, mask);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intStoreArrayMaskIOOBE() {\n+        VectorMask<Integer> mask = VectorMask.fromLong(ispecies, (1 << (ispecies.length() - 2)) - 1);\n+        for (int i = 0; i < inSize; i += ispecies.length()) {\n+            IntVector.fromArray(ispecies, intIn, i).intoArray(intOut, i, mask);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longStoreArrayMaskIOOBE() {\n+        VectorMask<Long> mask = VectorMask.fromLong(lspecies, (1 << (lspecies.length() - 2)) -1);\n+        for (int i = 0; i < inSize; i += lspecies.length()) {\n+            LongVector.fromArray(lspecies, longIn, i).intoArray(longOut, i, mask);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatStoreArrayMaskIOOBE() {\n+        VectorMask<Float> mask = VectorMask.fromLong(fspecies, (1 << (fspecies.length() - 2)) - 1);\n+        for (int i = 0; i < inSize; i += fspecies.length()) {\n+            FloatVector.fromArray(fspecies, floatIn, i).intoArray(floatOut, i, mask);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleStoreArrayMaskIOOBE() {\n+        VectorMask<Double> mask = VectorMask.fromLong(dspecies, (1 << (dspecies.length() - 2)) - 1);\n+        for (int i = 0; i < inSize; i += dspecies.length()) {\n+            DoubleVector.fromArray(dspecies, doubleIn, i).intoArray(doubleOut, i, mask);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/StoreMaskedIOOBEBenchmark.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}