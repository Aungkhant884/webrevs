{"files":[{"patch":"@@ -1327,0 +1327,7 @@\n+void Assembler::addb(Address dst, Register src) {\n+  InstructionMark im(this);\n+  prefix(dst, src);\n+  emit_int8(0x00);\n+  emit_operand(src, dst, 0);\n+}\n+\n@@ -1342,0 +1349,8 @@\n+void Assembler::addw(Address dst, Register src) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, src);\n+  emit_int8(0x01);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -981,0 +981,1 @@\n+  void addb(Address dst, Register src);\n@@ -983,0 +984,1 @@\n+  void addw(Address dst, Register src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8315,1 +8315,1 @@\n-instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddB_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8319,1 +8319,13 @@\n-  format %{ \"ADDB  [$mem],$add\" %}\n+  format %{ \"addb_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addb($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddB_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddB mem add));\n+  effect(KILL cr);\n+  format %{ \"addb_lock   $mem, $add\" %}\n@@ -8324,1 +8336,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8327,1 +8339,2 @@\n-instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddB(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8330,1 +8343,1 @@\n-  format %{ \"XADDB  [$mem],$newval\" %}\n+  format %{ \"xaddb_lock  $mem, $newval\" %}\n@@ -8335,1 +8348,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8338,1 +8351,1 @@\n-instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddS_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8342,1 +8355,13 @@\n-  format %{ \"ADDW  [$mem],$add\" %}\n+  format %{ \"addw_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addw($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddS_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(UseStoreImmI16 && n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddS mem add));\n+  effect(KILL cr);\n+  format %{ \"addw_lock   $mem, $add\" %}\n@@ -8347,1 +8372,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8350,1 +8375,2 @@\n-instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddS(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8353,1 +8379,1 @@\n-  format %{ \"XADDW  [$mem],$newval\" %}\n+  format %{ \"xaddw_lock  $mem, $newval\" %}\n@@ -8358,1 +8384,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8361,1 +8387,1 @@\n-instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddI_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8365,1 +8391,13 @@\n-  format %{ \"ADDL  [$mem],$add\" %}\n+  format %{ \"addl_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addl($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddI_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem add));\n+  effect(KILL cr);\n+  format %{ \"addl_lock   $mem, $add\" %}\n@@ -8370,1 +8408,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8373,1 +8411,2 @@\n-instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddI(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8376,1 +8415,1 @@\n-  format %{ \"XADDL  [$mem],$newval\" %}\n+  format %{ \"xaddl_lock  $mem, $newval\" %}\n@@ -8381,1 +8420,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8384,1 +8423,1 @@\n-instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{\n+instruct xaddL_reg_no_res(memory mem, Universe dummy, rRegL add, rFlagsReg cr) %{\n@@ -8388,1 +8427,13 @@\n-  format %{ \"ADDQ  [$mem],$add\" %}\n+  format %{ \"addq_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addq($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddL_imm_no_res(memory mem, Universe dummy, immL add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem add));\n+  effect(KILL cr);\n+  format %{ \"addq_lock   $mem, $add\" %}\n@@ -8393,1 +8444,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8396,1 +8447,2 @@\n-instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{\n+instruct xaddL(memory mem, rRegL newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8399,1 +8451,1 @@\n-  format %{ \"XADDQ  [$mem],$newval\" %}\n+  format %{ \"xaddq_lock  $mem, $newval\" %}\n@@ -8404,1 +8456,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":76,"deletions":24,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -3017,1 +3017,1 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n@@ -3019,1 +3019,7 @@\n-    if (x->Opcode() == Op_SCMemProj) continue;\n+    if (x->Opcode() == Op_SCMemProj) {\n+      continue;\n+    }\n+    if (x->bottom_type() == TypeTuple::MEMBAR &&\n+        x->Opcode() != Op_Blackhole) {\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.x86;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+\/*\n+ * @test\n+ * bug 8308444\n+ * @summary verify that the correct node is matched for atomic getAndAdd\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.x86.TestGetAndAdd\n+ *\/\n+public class TestGetAndAdd {\n+    static final VarHandle B;\n+    static final VarHandle S;\n+    static final VarHandle I;\n+    static final VarHandle L;\n+\n+    static {\n+        try {\n+            var lookup = MethodHandles.lookup();\n+            B = lookup.findStaticVarHandle(TestGetAndAdd.class, \"b\", byte.class);\n+            S = lookup.findStaticVarHandle(TestGetAndAdd.class, \"s\", short.class);\n+            I = lookup.findStaticVarHandle(TestGetAndAdd.class, \"i\", int.class);\n+            L = lookup.findStaticVarHandle(TestGetAndAdd.class, \"l\", long.class);\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    static byte b;\n+    static short s;\n+    static int i;\n+    static long l;\n+\n+    static byte b2;\n+    static short s2;\n+    static int i2;\n+    static long l2;\n+\n+    public static void main(String[] args) {\n+        new TestFramework()\n+                .addFlags(\"-XX:+UseStoreImmI16\")\n+                .start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.X86_LOCK_ADDB_REG, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_ADDB_IMM, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_XADDB, \"3\"}, phase = CompilePhase.FINAL_CODE)\n+    public static void addB() {\n+        B.getAndAdd(b2);\n+        B.getAndAdd((byte)1);\n+        b2 = (byte)B.getAndAdd(b2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.X86_LOCK_ADDS_REG, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_ADDS_IMM, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_XADDS, \"3\"}, phase = CompilePhase.FINAL_CODE)\n+    public static void addS() {\n+        S.getAndAdd(s2);\n+        S.getAndAdd((short)1);\n+        s2 = (short)S.getAndAdd(s2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.X86_LOCK_ADDI_REG, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_ADDI_IMM, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_XADDI, \"3\"}, phase = CompilePhase.FINAL_CODE)\n+    public static void addI() {\n+        I.getAndAdd(i2);\n+        I.getAndAdd(1);\n+        i2 = (int)I.getAndAdd(i2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.X86_LOCK_ADDL_REG, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_ADDL_IMM, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_LOCK_XADDL, \"3\"}, phase = CompilePhase.FINAL_CODE)\n+    public static void addL() {\n+        L.getAndAdd(l2);\n+        L.getAndAdd(1L);\n+        l2 = (long)L.getAndAdd(l2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/x86\/TestGetAndAdd.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -1539,0 +1539,60 @@\n+    public static final String X86_LOCK_ADDB_REG = PREFIX + \"X86_LOCK_ADDB_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDB_REG, \"xaddB_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDB_IMM = PREFIX + \"X86_LOCK_ADDB_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDB_IMM, \"xaddB_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDB = PREFIX + \"X86_LOCK_XADDB\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDB, \"xaddB\");\n+    }\n+\n+    public static final String X86_LOCK_ADDS_REG = PREFIX + \"X86_LOCK_ADDS_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDS_REG, \"xaddS_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDS_IMM = PREFIX + \"X86_LOCK_ADDS_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDS_IMM, \"xaddS_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDS = PREFIX + \"X86_LOCK_XADDS\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDS, \"xaddS\");\n+    }\n+\n+    public static final String X86_LOCK_ADDI_REG = PREFIX + \"X86_LOCK_ADDI_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDI_REG, \"xaddI_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDI_IMM = PREFIX + \"X86_LOCK_ADDI_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDI_IMM, \"xaddI_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDI = PREFIX + \"X86_LOCK_XADDI\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDI, \"xaddI\");\n+    }\n+\n+    public static final String X86_LOCK_ADDL_REG = PREFIX + \"X86_LOCK_ADDL_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDL_REG, \"xaddL_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDL_IMM = PREFIX + \"X86_LOCK_ADDL_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDL_IMM, \"xaddL_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDL = PREFIX + \"X86_LOCK_XADDL\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDL, \"xaddL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"}]}