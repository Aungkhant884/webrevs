{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -218,0 +220,8 @@\n+            },\n+            new Option(true, true, OptionType.EXTRACT, \"--dir\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    if (jartool.xdestDir != null) {\n+                        throw new BadArgs(\"error.extract.multiple.dest.dir\").showUsage(true);\n+                    }\n+                    jartool.xdestDir = arg;\n+                }\n@@ -227,1 +237,2 @@\n-        OTHER(\"other\");\n+        OTHER(\"other\"),\n+        EXTRACT(\"extract\");\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,3 @@\n+    \/\/ destination directory for extraction\n+    String xdestDir = null;\n+\n@@ -362,0 +365,9 @@\n+                if (xdestDir != null) {\n+                    final Path destPath = Paths.get(xdestDir);\n+                    try {\n+                        Files.createDirectories(destPath);\n+                    } catch (IOException ioe) {\n+                        throw new IOException(formatMsg(\"error.create.dir\",\n+                                destPath.toString()), ioe);\n+                    }\n+                }\n@@ -602,0 +614,5 @@\n+                        if (xflag && xdestDir != null) {\n+                            \/\/ extract option doesn't allow more than one destination directory\n+                            usageError(getMsg(\"error.extract.multiple.dest.dir\"));\n+                            return false;\n+                        }\n@@ -613,2 +630,6 @@\n-                        pathsMap.get(version).add(dir);\n-                        nameBuf[k++] = dir + args[++i];\n+                        if (xflag) {\n+                            xdestDir = dir;\n+                        } else {\n+                            pathsMap.get(version).add(dir);\n+                            nameBuf[k++] = dir + args[++i];\n+                        }\n@@ -673,0 +694,4 @@\n+        if (xflag && pflag && xdestDir != null) {\n+            usageError(getMsg(\"error.extract.pflag.not.allowed\"));\n+            return false;\n+        }\n@@ -1309,1 +1334,1 @@\n-                    File f = new File(name.replace('\/', File.separatorChar));\n+                    File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n@@ -1323,0 +1348,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1357,0 +1386,4 @@\n+        if (vflag) {\n+            output(formatMsg(\"out.extract.dir\", Path.of(xdestDir == null ? \".\" : xdestDir).normalize()\n+                    .toAbsolutePath().toString()));\n+        }\n@@ -1385,1 +1418,1 @@\n-        \/\/ The spec requres all slashes MUST be forward '\/', it is possible\n+        \/\/ The spec requires all slashes MUST be forward '\/', it is possible\n@@ -1388,1 +1421,1 @@\n-        \/\/ our \"safe\" check for leading slahs and dot-dot. So replace them\n+        \/\/ our \"safe\" check for leading slash and dot-dot. So replace them\n@@ -1394,1 +1427,9 @@\n-        File f = new File(name.replace('\/', File.separatorChar));\n+        \/\/ the xdestDir points to the user specified location where the jar needs to\n+        \/\/ be extracted. By default xdestDir is null and represents current working\n+        \/\/ directory.\n+        \/\/ jar extraction using -P option is only allowed when the destination\n+        \/\/ directory isn't specified (and hence defaults to current working directory).\n+        \/\/ In such cases using this java.io.File constructor which accepts a null parent path\n+        \/\/ allows us to extract entries that may have leading slashes and hence may need\n+        \/\/ to be extracted outside of the current directory.\n+        File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":48,"deletions":7,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,4 @@\n+error.extract.multiple.dest.dir=\\\n+        You may not specify the '-C' or '--dir' option more than once with the '-x' option\n+error.extract.pflag.not.allowed=\\\n+        You may not specify '-Px' with the '-C' or '--dir' options\n@@ -162,0 +166,2 @@\n+out.extract.dir=\\\n+        extracting to directory: {0}\n@@ -183,0 +189,1 @@\n+When used in extract mode, extracts the jar to the specified directory\\n\\\n@@ -242,1 +249,2 @@\n-\\                             following file\n+\\                             following file. When used in extract mode, extracts\\n\\\n+\\                             the jar to the specified directory\n@@ -305,0 +313,4 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.dir=\\\n+\\  --dir                    Directory into which the jar will be extracted\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.JarBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8173970\n+ * @summary jar tool should allow extracting to specific directory\n+ * @library \/test\/lib\n+ * @run testng JarExtractTest\n+ *\/\n+public class JarExtractTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    private static final byte[] FILE_CONTENT = \"Hello world!!!\".getBytes(StandardCharsets.UTF_8);\n+    private static final String LEADING_SLASH_PRESERVED_ENTRY = \"\/tmp\/8173970\/f1.txt\";\n+    \/\/ the jar that will get extracted in the tests\n+    private static Path testJarPath;\n+    private static Collection<Path> filesToDelete = new ArrayList<>();\n+\n+    @BeforeTest\n+    public static void createTestJar() throws Exception {\n+        Files.deleteIfExists(Path.of(LEADING_SLASH_PRESERVED_ENTRY));\n+\n+        final String tmpDir = Files.createTempDirectory(\"8173970-\").toString();\n+        testJarPath = Paths.get(tmpDir, \"8173970-test.jar\");\n+        final JarBuilder builder = new JarBuilder(testJarPath.toString());\n+        \/\/ d1\n+        \/\/  |--- d2\n+        \/\/  |    |--- d3\n+        \/\/  |    |    |--- f2.txt\n+        \/\/  |\n+        \/\/  |--- d4\n+        \/\/  ...\n+        \/\/  f1.txt\n+\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"f1.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/d3\/f2.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d4\/\", new byte[0]);\n+        builder.build();\n+\n+        filesToDelete.add(Path.of(LEADING_SLASH_PRESERVED_ENTRY));\n+    }\n+\n+    @AfterTest\n+    public void cleanup() {\n+        for (final Path p : filesToDelete) {\n+            try {\n+                System.out.println(\"Deleting file\/dir \" + p);\n+                Files.delete(p);\n+            } catch (IOException ioe) {\n+                \/\/ignore\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates and returns various relative paths, to which the jar will be extracted in the tests\n+     *\/\n+    @DataProvider(name = \"relExtractLocations\")\n+    private Object[][] provideRelativeExtractLocations() throws Exception {\n+        \/\/ create some dirs so that they already exist when the jar is being extracted\n+        final String existing1 = \".\" + File.separator + \"8173970-existing-1\";\n+        Files.createDirectories(Paths.get(existing1));\n+        final String existing2 = \".\" + File.separator + \"foo\" + File.separator + \"8173970-existing-2\";\n+        Files.createDirectories(Paths.get(existing2));\n+        final Path dirOutsideScratchDir = Files.createTempDirectory(Paths.get(\"..\"), \"8173970\");\n+        \/\/ we need to explicitly delete this dir after the tests end\n+        filesToDelete.add(dirOutsideScratchDir);\n+        final String existing3 = dirOutsideScratchDir.toString() + File.separator + \"8173970-existing-3\";\n+        Files.createDirectories(Paths.get(existing3));\n+\n+        final String anotherDirOutsideScratchDir = \"..\" + File.separator + \"8173970-non-existent\";\n+        filesToDelete.add(Paths.get(anotherDirOutsideScratchDir));\n+\n+        return new Object[][]{\n+                {\".\"}, \/\/ current dir\n+                {\".\" + File.separator + \"8173970-extract-1\"}, \/\/ (explicitly) relative to current dir\n+                {\"8173970-extract-2\"}, \/\/ (implicitly) relative to current dir\n+                {anotherDirOutsideScratchDir}, \/\/ sibling to current dir\n+                \/\/ some existing dirs\n+                {existing1},\n+                {existing2},\n+                {existing3},\n+                \/\/ a non-existent dir within an existing dir\n+                {existing1 + File.separator + \"non-existing\" + File.separator + \"foo\"}\n+        };\n+    }\n+\n+    \/**\n+     * Creates and returns various absolute paths, to which the jar will be extracted in the tests\n+     *\/\n+    @DataProvider(name = \"absExtractLocations\")\n+    private Object[][] provideAbsoluteExtractLocations() throws Exception {\n+        final Object[][] relative = provideRelativeExtractLocations();\n+        final Object[][] abs = new Object[relative.length][1];\n+        int i = 0;\n+        for (final Object[] p : relative) {\n+            abs[i++][0] = Paths.get((String) p[0]).toAbsolutePath().toString();\n+        }\n+        return abs;\n+    }\n+\n+    \/**\n+     * Creates and returns various normalized paths, to which the jar will be extracted in the tests\n+     *\/\n+    @DataProvider(name = \"absNormalizedExtractLocations\")\n+    private Object[][] provideAbsoluteNormalizedExtractLocations() throws Exception {\n+        final Object[][] relative = provideAbsoluteExtractLocations();\n+        final Object[][] abs = new Object[relative.length][1];\n+        int i = 0;\n+        for (final Object[] p : relative) {\n+            abs[i++][0] = Paths.get((String) p[0]).toAbsolutePath().normalize().toString();\n+        }\n+        return abs;\n+    }\n+\n+    \/**\n+     * Extracts a jar to various relative paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @Test(dataProvider = \"relExtractLocations\")\n+    public void testExtractToRelativeDir(final String dest) throws Exception {\n+        testLongFormExtract(dest);\n+        testExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various absolute paths, using the -C\/--dir option and then\n+     * verifies that the extracted content is at the expected locations with the correct\n+     * content\n+     *\/\n+    @Test(dataProvider = \"absExtractLocations\")\n+    public void testExtractToAbsoluteDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Extracts a jar to various normalized paths (i.e. no {@code .} or @{code ..} in the path components),\n+     * using the -C\/--dir option and then verifies that the extracted content is at the expected locations\n+     * with the correct content\n+     *\/\n+    @Test(dataProvider = \"absNormalizedExtractLocations\")\n+    public void testExtractToAbsoluteNormalizedDir(final String dest) throws Exception {\n+        testExtract(dest);\n+        testLongFormExtract(dest);\n+    }\n+\n+    \/**\n+     * Test that extracting a jar with {@code jar -x -f --dir} works as expected\n+     *\/\n+    @Test\n+    public void testExtractLongFormDir() throws Exception {\n+        final String dest = \"foo-bar\";\n+        System.out.println(\"Extracting \" + testJarPath + \" to \" + dest);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString(),\n+                \"--dir\", dest);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the {@code jar --help} output contains the --dir option\n+     *\/\n+    @Test\n+    public void testHelpOutput() {\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+        final int exitCode = JAR_TOOL.run(new PrintStream(outStream), System.err, \"--help\");\n+        Assert.assertEquals(exitCode, 0, \"jar --help command failed\");\n+        final String output = outStream.toString();\n+        \/\/ this message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedMsg = \"--dir                    Directory into which the jar will be extracted\";\n+        Assert.assertTrue(output.contains(expectedMsg), \"jar --help didn't contain --dir option\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -x -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString());\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar --extract -f} command works fine even when the -C or --dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testLongFormExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"--extract\", \"-f\", testJarPath.toString());\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Tests that extracting a jar using {@code -P} flag and without any explicit destination\n+     * directory works correctly if the jar contains entries with leading slashes and\/or {@code ..}\n+     * parts preserved.\n+     *\/\n+    @Test\n+    public void testExtractNoDestDirWithPFlag() throws Exception {\n+        \/\/ create a jar which has leading slash (\/) and dot-dot (..) preserved in entry names\n+        final Path jarPath = createJarWithPFlagSemantics();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-xvfP\", jarPath.toString()});\n+        cmdArgs.add(new String[]{\"--extract\", \"-v\", \"-P\", \"-f\", jarPath.toString()});\n+        for (final String[] args : cmdArgs) {\n+            printJarCommand(args);\n+            final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+            Assert.assertEquals(exitCode, 0, \"Failed to extract \" + jarPath);\n+            final String dest = \".\";\n+            Assert.assertTrue(Files.isDirectory(Paths.get(dest)), dest + \" is not a directory\");\n+            final Path d1 = Paths.get(dest, \"d1\");\n+            Assert.assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+            final Path d2 = Paths.get(dest, \"d1\", \"d2\");\n+            Assert.assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+            final Path f1 = Paths.get(LEADING_SLASH_PRESERVED_ENTRY);\n+            Assert.assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+            Assert.assertEquals(Files.readAllBytes(f1), FILE_CONTENT, \"Unexpected content in file \" + f1);\n+            final Path f2 = Paths.get(\"d1\/d2\/..\/f2.txt\");\n+            Assert.assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+            Assert.assertEquals(Files.readAllBytes(f2), FILE_CONTENT, \"Unexpected content in file \" + f2);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that the {@code -P} option cannot be used during jar extraction when the {@code -C} and\/or\n+     * {@code --dir} option is used\n+     *\/\n+    @Test\n+    public void testExtractWithDirPFlagNotAllowed() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify '-Px' with the '-C' or '--dir' options\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        cmdArgs.add(new String[]{\"-xvfP\", testJarPath.toString(), \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"-C\", \".\"});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-P\", \"--dir\", \".\"});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            Assert.assertNotEquals(exitCode, 0, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            Assert.assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -xvf <jarname> -C <dir>} works fine too\n+     *\/\n+    @Test\n+    public void testLegacyCompatibilityMode() throws Exception {\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final String[] args = new String[]{\"-xvf\", testJarPath.toString(), \"-C\", tmpDir};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath);\n+        verifyExtractedContent(tmpDir);\n+    }\n+\n+    \/**\n+     * Tests that when multiple directories are specified for extracting the jar, the jar extraction\n+     * fails\n+     *\/\n+    @Test\n+    public void testExtractFailWithMultipleDir() throws Exception {\n+        \/\/ this error message is expected to be the one from the jar --help output which is sourced from\n+        \/\/ jar.properties\n+        final String expectedErrMsg = \"You may not specify the '-C' or '--dir' option more than once with the '-x' option\";\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final List<String[]> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", tmpDir, \"-C\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"--dir\", tmpDir});\n+        cmdArgs.add(new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir, \"-C\", tmpDir});\n+        for (final String[] args : cmdArgs) {\n+            final ByteArrayOutputStream err = new ByteArrayOutputStream();\n+            printJarCommand(args);\n+            int exitCode = JAR_TOOL.run(System.out, new PrintStream(err), args);\n+            Assert.assertNotEquals(exitCode, 0, \"jar extraction was expected to fail but didn't\");\n+            \/\/ verify it did indeed fail due to the right reason\n+            Assert.assertTrue(err.toString(StandardCharsets.UTF_8).contains(expectedErrMsg));\n+        }\n+    }\n+\n+    \/**\n+     * Tests that extracting only specific files from a jar, into a specific destination directory,\n+     * works as expected\n+     *\/\n+    @Test\n+    public void testExtractPartialContent() throws Exception {\n+        String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        String[] cmdArgs = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+        tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        cmdArgs = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"--dir\", tmpDir,\n+                \"f1.txt\", \"d1\/d2\/d3\/f2.txt\"};\n+        testExtractPartialContent(tmpDir, cmdArgs);\n+\n+    }\n+\n+    \/**\n+     * Extract to destDir using the passed command arguments and verify the extracted content\n+     *\/\n+    private void testExtractPartialContent(final String destDir, final String[] extractArgs) throws Exception {\n+        printJarCommand(extractArgs);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, extractArgs);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath);\n+        \/\/ make sure only the specific files were extracted\n+        final Stream<Path> paths = Files.walk(Path.of(destDir));\n+        \/\/ files\/dirs count expected to be found when the location to which the jar was extracted\n+        \/\/ is walked.\n+        \/\/ 1) The top level dir being walked 2) f1.txt file 3) d1 dir 4) d1\/d2 dir\n+        \/\/ 5) d1\/d2\/d3 dir 6) d1\/d2\/d3\/f2.txt file\n+        final int numExpectedFiles = 6;\n+        Assert.assertEquals(paths.count(), numExpectedFiles, \"Unexpected number of files\/dirs in \" + destDir);\n+        final Path f1 = Paths.get(destDir, \"f1.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f1), f1.toString() + \" wasn't extracted from \" + testJarPath);\n+        Assert.assertEquals(Files.readAllBytes(f1), FILE_CONTENT, \"Unexpected content in file \" + f1);\n+        final Path d1 = Paths.get(destDir, \"d1\");\n+        Assert.assertTrue(Files.isDirectory(d1), d1.toString() + \" wasn't extracted from \" + testJarPath);\n+        Assert.assertEquals(Files.walk(d1, 1).count(), 2, \"Unexpected number \" +\n+                \"of files\/dirs in \" + d1);\n+        final Path d2 = Paths.get(d1.toString(), \"d2\");\n+        Assert.assertTrue(Files.isDirectory(d2), d2.toString() + \" wasn't extracted from \" + testJarPath);\n+        Assert.assertEquals(Files.walk(d2, 1).count(), 2, \"Unexpected number \" +\n+                \"of files\/dirs in \" + d2);\n+        final Path d3 = Paths.get(d2.toString(), \"d3\");\n+        Assert.assertTrue(Files.isDirectory(d3), d3.toString() + \" wasn't extracted from \" + testJarPath);\n+        Assert.assertEquals(Files.walk(d3, 1).count(), 2, \"Unexpected number \" +\n+                \"of files\/dirs in \" + d3);\n+        final Path f2 = Paths.get(d3.toString(), \"f2.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f2), f2.toString() + \" wasn't extracted from \" + testJarPath);\n+        Assert.assertEquals(Files.readAllBytes(f2), FILE_CONTENT, \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar -x -f <jarfile> -C <dest>} and verifies the extracted content\n+     *\/\n+    private void testExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"-x\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar --extract -f <jarfile> -C <dest>} and verifies the\n+     * extracted content\n+     *\/\n+    private void testLongFormExtract(final String dest) throws Exception {\n+        final String[] args = new String[]{\"--extract\", \"-f\", testJarPath.toString(), \"-C\", dest};\n+        printJarCommand(args);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, args);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the extracted jar content matches what was present in the original jar\n+     *\/\n+    private void verifyExtractedContent(final String dest) throws IOException {\n+        Assert.assertTrue(Files.isDirectory(Paths.get(dest)), dest + \" is not a directory\");\n+        final Path d1 = Paths.get(dest, \"d1\");\n+        Assert.assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+        final Path d2 = Paths.get(dest, \"d1\", \"d2\");\n+        Assert.assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+        final Path d3 = Paths.get(dest, \"d1\", \"d2\", \"d3\");\n+        Assert.assertTrue(Files.isDirectory(d3), d3 + \" directory is missing or not a directory\");\n+        final Path d4 = Paths.get(dest, \"d1\", \"d4\");\n+        Assert.assertTrue(Files.isDirectory(d4), d4 + \" directory is missing or not a directory\");\n+        \/\/ d1\/d4 is expected to be empty directory\n+        final List<Path> d4Children;\n+        try (final Stream<Path> s = Files.walk(d4, 1)) {\n+            d4Children = s.toList();\n+        }\n+        Assert.assertEquals(d4Children.size(), 1, \"Directory \" + d4\n+                + \" has unexpected files\/dirs: \" + d4Children);\n+        final Path f1 = Paths.get(dest, \"f1.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+        Assert.assertEquals(Files.readAllBytes(f1), FILE_CONTENT, \"Unexpected content in file \" + f1);\n+        final Path f2 = Paths.get(d3.toString(), \"f2.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+        Assert.assertEquals(Files.readAllBytes(f2), FILE_CONTENT, \"Unexpected content in file \" + f2);\n+    }\n+\n+    \/**\n+     * Creates a jar whose entries have a leading slash and the dot-dot character preserved.\n+     * This is the same as creating a jar using {@code jar -cfP somejar.jar <file1> <file2> ...}\n+     *\/\n+    private static Path createJarWithPFlagSemantics() throws IOException {\n+        final String tmpDir = Files.createTempDirectory(Path.of(\".\"), \"8173970-\").toString();\n+        final Path jarPath = Paths.get(tmpDir, \"8173970-test-withpflag.jar\");\n+        final JarBuilder builder = new JarBuilder(jarPath.toString());\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"d1\/d2\/\", new byte[0]);\n+        builder.addEntry(LEADING_SLASH_PRESERVED_ENTRY, FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/..\/f2.txt\", FILE_CONTENT);\n+        builder.build();\n+        return jarPath;\n+    }\n+\n+    private static void printJarCommand(final String[] cmdArgs) {\n+        System.out.println(\"Running 'jar \" + String.join(\" \", cmdArgs) + \"'\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/JarExtractTest.java","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"}]}