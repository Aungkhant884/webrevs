{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,0 +218,5 @@\n+            },\n+            new Option(true, true, OptionType.EXTRACT, \"--output-dir\", \"-o\") {\n+                void process(Main jartool, String opt, String arg) {\n+                    jartool.xdestDir = arg;\n+                }\n@@ -227,1 +232,2 @@\n-        OTHER(\"other\");\n+        OTHER(\"other\"),\n+        EXTRACT(\"extract\");\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,3 @@\n+    \/\/ destination directory for extraction (defaults to current working directory)\n+    String xdestDir = \".\";\n+\n@@ -362,0 +365,9 @@\n+                if (!xdestDir.equals(\".\")) {\n+                    final Path destPath = Paths.get(xdestDir);\n+                    try {\n+                        Files.createDirectories(destPath);\n+                    } catch (IOException ioe) {\n+                        throw new IOException(formatMsg(\"error.create.dir\",\n+                                destPath.toString()), ioe);\n+                    }\n+                }\n@@ -568,0 +580,3 @@\n+                        case 'o':\n+                            xdestDir = args[count++];\n+                            break;\n@@ -1309,1 +1324,1 @@\n-                    File f = new File(name.replace('\/', File.separatorChar));\n+                    File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n@@ -1394,1 +1409,1 @@\n-        File f = new File(name.replace('\/', File.separatorChar));\n+        File f = new File(xdestDir, name.replace('\/', File.separatorChar));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,0 +305,4 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.output-dir=\\\n+\\  -o, --output-dir=DIR        Directory into which the jar will be extracted\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.JarBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8173970\n+ * @summary jar tool should allow extracting to specific directory\n+ * @library \/test\/lib\n+ * @run testng JarExtractTest\n+ *\/\n+public class JarExtractTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    private static final byte[] FILE_CONTENT = \"Hello world!!!\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ the jar that will get extracted in the tests\n+    private static Path testJarPath;\n+    private static Collection<Path> filesToDelete = new ArrayList<>();\n+\n+    @BeforeClass\n+    public static void createTestJar() throws Exception {\n+        testJarPath = Paths.get(\"8173970-test.jar\");\n+        final JarBuilder builder = new JarBuilder(testJarPath.toString());\n+        \/\/ d1\n+        \/\/  |--- d2\n+        \/\/  |    |--- d3\n+        \/\/  |    |    |--- f2.txt\n+        \/\/  |\n+        \/\/  |--- d4\n+        \/\/  ...\n+        \/\/  f1.txt\n+\n+        builder.addEntry(\"d1\/\", new byte[0]);\n+        builder.addEntry(\"f1.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d2\/d3\/f2.txt\", FILE_CONTENT);\n+        builder.addEntry(\"d1\/d4\/\", new byte[0]);\n+        builder.build();\n+    }\n+\n+    @AfterClass\n+    public void cleanup() {\n+        for (final Path p : filesToDelete) {\n+            try {\n+                System.out.println(\"Deleting file\/dir \" + p);\n+                Files.delete(p);\n+            } catch (IOException ioe) {\n+                \/\/ignore\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"relExtractLocations\")\n+    private Object[][] provideRelativeExtractLocations() throws Exception {\n+        \/\/ create some dirs so that they already exist when the jar is being extracted\n+        final String existing1 = \".\" + File.separator + \"8173970-existing-1\";\n+        Files.createDirectories(Paths.get(existing1));\n+        final String existing2 = \".\" + File.separator + \"foo\" + File.separator + \"8173970-existing-2\";\n+        Files.createDirectories(Paths.get(existing2));\n+        final Path dirOutsideScratchDir = Files.createTempDirectory(Paths.get(\"..\"), \"8173970\");\n+        \/\/ we need to explicitly delete this dir after the tests end\n+        filesToDelete.add(dirOutsideScratchDir);\n+        final String existing3 = dirOutsideScratchDir.toString() + File.separator + \"8173970-existing-3\";\n+        Files.createDirectories(Paths.get(existing3));\n+\n+        final String anotherDirOutsideScratchDir = \"..\" + File.separator + \"8173970-non-existent\";\n+        filesToDelete.add(Paths.get(anotherDirOutsideScratchDir));\n+\n+        return new Object[][]{\n+                {\".\"}, \/\/ current dir\n+                {\".\" + File.separator + \"8173970-extract-1\"}, \/\/ (explicitly) relative to current dir\n+                {\"8173970-extract-2\"}, \/\/ (implicitly) relative to current dir\n+                {anotherDirOutsideScratchDir}, \/\/ sibling to current dir\n+                \/\/ some existing dirs\n+                {existing1},\n+                {existing2},\n+                {existing3},\n+                \/\/ a non-existent dir within an existing dir\n+                {existing1 + File.separator + \"non-existing\" + File.separator + \"foo\"}\n+        };\n+    }\n+\n+    @DataProvider(name = \"absExtractLocations\")\n+    private Object[][] provideAbsoluteExtractLocations() throws Exception {\n+        final Object[][] relative = provideRelativeExtractLocations();\n+        final Object[][] abs = new Object[relative.length][1];\n+        int i = 0;\n+        for (final Object[] p : relative) {\n+            abs[i++][0] = Paths.get((String) p[0]).toAbsolutePath().toString();\n+        }\n+        return abs;\n+    }\n+\n+    @DataProvider(name = \"absNormalizedExtractLocations\")\n+    private Object[][] provideAbsoluteNormalizedExtractLocations() throws Exception {\n+        final Object[][] relative = provideAbsoluteExtractLocations();\n+        final Object[][] abs = new Object[relative.length][1];\n+        int i = 0;\n+        for (final Object[] p : relative) {\n+            abs[i++][0] = Paths.get((String) p[0]).toAbsolutePath().normalize().toString();\n+        }\n+        return abs;\n+    }\n+\n+    @Test(dataProvider = \"relExtractLocations\")\n+    public void testExtractToRelativeDir(final String dest) throws Exception {\n+        testExtract(dest);\n+    }\n+\n+    @Test(dataProvider = \"absExtractLocations\")\n+    public void testExtractToAbsoluteDir(final String dest) throws Exception {\n+        testExtract(dest);\n+    }\n+\n+    @Test(dataProvider = \"absNormalizedExtractLocations\")\n+    public void testExtractToAbsoluteNormalizedDir(final String dest) throws Exception {\n+        testExtract(dest);\n+    }\n+\n+    \/**\n+     * Test that {@code jar -x -f --output-dir} works as expected\n+     *\/\n+    @Test\n+    public void testExtractLongForm() throws Exception {\n+        final String dest = \"foo-bar\";\n+        System.out.println(\"Extracting \" + testJarPath + \" to \" + dest);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-x\", \"-f\", testJarPath.toString(),\n+                \"--output-dir\", dest);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the {@code jar --help} output contains the --output-dir and -o option\n+     *\/\n+    @Test\n+    public void testHelpOutput() {\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+        final int exitCode = JAR_TOOL.run(new PrintStream(outStream), System.err, \"--help\");\n+        Assert.assertEquals(exitCode, 0, \"jar --help command failed\");\n+        final String output = outStream.toString();\n+        Assert.assertTrue(output.contains(\"-o, --output-dir=DIR        Directory into which the jar will be extracted\"),\n+                \"jar --help didn't contain -o or --output-dir option\");\n+    }\n+\n+    \/**\n+     * Tests that {@code jar -xf} command works fine even when the -o or --output-dir option\n+     * isn't specified\n+     *\/\n+    @Test\n+    public void testExtractWithoutOutputDir() throws Exception {\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-xf\", testJarPath.toString());\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath);\n+        \/\/ the content would have been extracted to current dir\n+        verifyExtractedContent(\".\");\n+    }\n+\n+    \/**\n+     * Extracts the jar file using {@code jar -xfo <jarfile> <dest>}\n+     *\/\n+    private void testExtract(final String dest) throws Exception {\n+        System.out.println(\"Extracting \" + testJarPath + \" to \" + dest);\n+        final int exitCode = JAR_TOOL.run(System.out, System.err, \"-xfo\", testJarPath.toString(), dest);\n+        Assert.assertEquals(exitCode, 0, \"Failed to extract \" + testJarPath + \" to \" + dest);\n+        verifyExtractedContent(dest);\n+    }\n+\n+    \/**\n+     * Verifies that the extracted jar content matches what was present in the original jar\n+     *\/\n+    private void verifyExtractedContent(final String dest) throws IOException {\n+        Assert.assertTrue(Files.isDirectory(Paths.get(dest)), dest + \" is not a directory\");\n+        final Path d1 = Paths.get(dest, \"d1\");\n+        Assert.assertTrue(Files.isDirectory(d1), d1 + \" directory is missing or not a directory\");\n+        final Path d2 = Paths.get(dest, \"d1\", \"d2\");\n+        Assert.assertTrue(Files.isDirectory(d2), d2 + \" directory is missing or not a directory\");\n+        final Path d3 = Paths.get(dest, \"d1\", \"d2\", \"d3\");\n+        Assert.assertTrue(Files.isDirectory(d3), d3 + \" directory is missing or not a directory\");\n+        final Path d4 = Paths.get(dest, \"d1\", \"d4\");\n+        Assert.assertTrue(Files.isDirectory(d4), d4 + \" directory is missing or not a directory\");\n+        \/\/ d1\/d4 is expected to be empty directory\n+        final List<Path> d4Children;\n+        try (final Stream<Path> s = Files.walk(d4, 1)) {\n+            d4Children = s.toList();\n+        }\n+        Assert.assertEquals(d4Children.size(), 1, \"Directory \" + d4\n+                + \" has unexpected files\/dirs: \" + d4Children);\n+        final Path f1 = Paths.get(dest, \"f1.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f1), f1 + \" is missing or not a file\");\n+        Assert.assertEquals(Files.readAllBytes(f1), FILE_CONTENT, \"Unexpected content in file \" + f1);\n+        final Path f2 = Paths.get(d3.toString(), \"f2.txt\");\n+        Assert.assertTrue(Files.isRegularFile(f2), f2 + \" is missing or not a file\");\n+        Assert.assertEquals(Files.readAllBytes(f2), FILE_CONTENT, \"Unexpected content in file \" + f2);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jar\/JarExtractTest.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"}]}