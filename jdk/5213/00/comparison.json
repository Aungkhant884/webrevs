{"files":[{"patch":"@@ -589,0 +589,28 @@\n+\n+  bool has_aborted() {\n+    if (_cm != NULL) {\n+      _cm->do_yield_check();\n+      return _cm->has_aborted();\n+    }\n+    return false;\n+  }\n+\n+  HeapWord* region_clear_limit(HeapRegion* r) {\n+    \/\/ During a Concurrent Undo Mark cycle, the _next_mark_bitmap is  cleared\n+    \/\/ without swapping with the _prev_mark_bitmap. Therefore, the per region\n+    \/\/ next_top_at_mark_start and live_words data are current wrt\n+    \/\/ _next_mark_bitmap. We use this information to only clear ranges of the\n+    \/\/ bitmap that require clearing.\n+    if (_cm != NULL && _cm->cm_thread()->in_undo_mark()) {\n+      \/\/ No need to clear bitmaps for empty regions.\n+      if (_cm->live_words(r->hrm_index()) == 0) {\n+        assert(_bitmap->get_next_marked_addr(r->bottom(), r->end()) == r->end(), \"Should not have marked bits\");\n+        return r->bottom();\n+      }\n+      \/\/ Otherwise, we only clear up to the next_top_at_mark_start\n+      assert(_bitmap->get_next_marked_addr(r->next_top_at_mark_start(), r->end()) == r->end(), \"Should not have marked bits above ntams\");\n+      return r->next_top_at_mark_start();\n+    }\n+    return r->end();\n+  }\n+\n@@ -594,1 +622,3 @@\n-      size_t const chunk_size_in_words = G1ClearBitMapTask::chunk_size() \/ HeapWordSize;\n+      if (has_aborted()) {\n+        return true;\n+      }\n@@ -597,1 +627,3 @@\n-      HeapWord* const end = r->end();\n+      HeapWord* const end = region_clear_limit(r);\n+\n+      size_t const chunk_size_in_words = G1ClearBitMapTask::chunk_size() \/ HeapWordSize;\n@@ -600,7 +632,0 @@\n-        \/\/ Abort iteration if necessary.\n-        if (_cm != NULL) {\n-          _cm->do_yield_check();\n-          if (_cm->has_aborted()) {\n-            return true;\n-          }\n-        }\n@@ -619,0 +644,5 @@\n+\n+        \/\/ Abort iteration if necessary.\n+        if (has_aborted()) {\n+          return true;\n+        }\n@@ -620,1 +650,1 @@\n-      assert(cur == end, \"Must have completed iteration over the bitmap for region %u.\", r->hrm_index());\n+      assert(cur >= end, \"Must have completed iteration over the bitmap for region %u.\", r->hrm_index());\n@@ -643,0 +673,1 @@\n+\n@@ -648,1 +679,1 @@\n-void G1ConcurrentMark::clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers, bool may_yield) {\n@@ -656,1 +687,1 @@\n-  G1ClearBitMapTask cl(bitmap, this, num_workers, may_yield);\n+  G1ClearBitMapTask cl(_next_mark_bitmap, this, num_workers, may_yield);\n@@ -674,1 +705,1 @@\n-  clear_bitmap(_next_mark_bitmap, _concurrent_workers, true);\n+  clear_next_bitmap(_concurrent_workers, true);\n@@ -688,1 +719,1 @@\n-  clear_bitmap(_next_mark_bitmap, workers, false);\n+  clear_next_bitmap(workers, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  \/\/ Clear the given bitmap in parallel using the given WorkGang. If may_yield is\n+  \/\/ Clear the next marking bitmap in parallel using the given WorkGang. If may_yield is\n@@ -449,1 +449,1 @@\n-  void clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield);\n+  void clear_next_bitmap(WorkGang* workers, bool may_yield);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,0 +327,2 @@\n+  _cm->flush_all_task_caches();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+\n+  bool in_undo_mark() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline bool G1ConcurrentMarkThread::in_undo_mark() const {\n+  return _state == UndoMark;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}