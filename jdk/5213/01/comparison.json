{"files":[{"patch":"@@ -584,1 +584,1 @@\n-  \/\/ Heap region closure used for clearing the given mark bitmap.\n+  \/\/ Heap region closure used for clearing the _next_mark_bitmap.\n@@ -587,1 +587,0 @@\n-    G1CMBitMap* _bitmap;\n@@ -589,2 +588,5 @@\n-  public:\n-    G1ClearBitmapHRClosure(G1CMBitMap* bitmap, G1ConcurrentMark* cm) : HeapRegionClosure(), _bitmap(bitmap), _cm(cm) {\n+    G1CMBitMap* _bitmap;\n+    bool _suspendible; \/\/ If suspendible, do yield checks.\n+\n+    bool suspendible() {\n+      return _suspendible;\n@@ -593,0 +595,37 @@\n+    bool is_clear_concurrent_undo() {\n+      return suspendible() && _cm->cm_thread()->in_undo_mark();\n+    }\n+\n+    bool has_aborted() {\n+      if (suspendible()) {\n+        _cm->do_yield_check();\n+        return _cm->has_aborted();\n+      }\n+      return false;\n+    }\n+\n+    HeapWord* region_clear_limit(HeapRegion* r) {\n+      \/\/ During a Concurrent Undo Mark cycle, the _next_mark_bitmap is  cleared\n+      \/\/ without swapping with the _prev_mark_bitmap. Therefore, the per region\n+      \/\/ next_top_at_mark_start and live_words data are current wrt\n+      \/\/ _next_mark_bitmap. We use this information to only clear ranges of the\n+      \/\/ bitmap that require clearing.\n+      if (is_clear_concurrent_undo()) {\n+        \/\/ No need to clear bitmaps for empty regions.\n+        if (_cm->live_words(r->hrm_index()) == 0) {\n+          assert(_bitmap->get_next_marked_addr(r->bottom(), r->end()) == r->end(), \"Should not have marked bits\");\n+          return r->bottom();\n+        }\n+        assert(_bitmap->get_next_marked_addr(r->next_top_at_mark_start(), r->end()) == r->end(), \"Should not have marked bits above ntams\"); \n+      }\n+      return r->end();\n+    }\n+\n+  public:\n+    G1ClearBitmapHRClosure(G1ConcurrentMark* cm, bool suspendible) :\n+      HeapRegionClosure(),\n+      _cm(cm),\n+      _bitmap(cm->next_mark_bitmap()),\n+      _suspendible(suspendible)\n+    { }\n+\n@@ -594,1 +633,3 @@\n-      size_t const chunk_size_in_words = G1ClearBitMapTask::chunk_size() \/ HeapWordSize;\n+      if (has_aborted()) {\n+        return true;\n+      }\n@@ -597,1 +638,3 @@\n-      HeapWord* const end = r->end();\n+      HeapWord* const end = region_clear_limit(r);\n+\n+      size_t const chunk_size_in_words = G1ClearBitMapTask::chunk_size() \/ HeapWordSize;\n@@ -600,7 +643,0 @@\n-        \/\/ Abort iteration if necessary.\n-        if (_cm != NULL) {\n-          _cm->do_yield_check();\n-          if (_cm->has_aborted()) {\n-            return true;\n-          }\n-        }\n@@ -617,2 +653,7 @@\n-        assert(_cm == NULL || _cm->cm_thread()->in_progress(), \"invariant\");\n-        assert(_cm == NULL || !G1CollectedHeap::heap()->collector_state()->mark_or_rebuild_in_progress(), \"invariant\");\n+        assert(!suspendible() || _cm->cm_thread()->in_progress(), \"invariant\");\n+        assert(!suspendible() || !G1CollectedHeap::heap()->collector_state()->mark_or_rebuild_in_progress(), \"invariant\");\n+\n+        \/\/ Abort iteration if necessary.\n+        if (has_aborted()) {\n+          return true;\n+        }\n@@ -620,1 +661,1 @@\n-      assert(cur == end, \"Must have completed iteration over the bitmap for region %u.\", r->hrm_index());\n+      assert(cur >= end, \"Must have completed iteration over the bitmap for region %u.\", r->hrm_index());\n@@ -631,1 +672,1 @@\n-  G1ClearBitMapTask(G1CMBitMap* bitmap, G1ConcurrentMark* cm, uint n_workers, bool suspendible) :\n+  G1ClearBitMapTask(G1ConcurrentMark* cm, uint n_workers, bool suspendible) :\n@@ -633,1 +674,1 @@\n-    _cl(bitmap, suspendible ? cm : NULL),\n+    _cl(cm, suspendible),\n@@ -648,1 +689,1 @@\n-void G1ConcurrentMark::clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield) {\n+void G1ConcurrentMark::clear_next_bitmap(WorkGang* workers, bool may_yield) {\n@@ -656,1 +697,1 @@\n-  G1ClearBitMapTask cl(bitmap, this, num_workers, may_yield);\n+  G1ClearBitMapTask cl(this, num_workers, may_yield);\n@@ -674,1 +715,1 @@\n-  clear_bitmap(_next_mark_bitmap, _concurrent_workers, true);\n+  clear_next_bitmap(_concurrent_workers, true);\n@@ -688,1 +729,1 @@\n-  clear_bitmap(_next_mark_bitmap, workers, false);\n+  clear_next_bitmap(workers, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":63,"deletions":22,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  \/\/ Clear the given bitmap in parallel using the given WorkGang. If may_yield is\n+  \/\/ Clear the next marking bitmap in parallel using the given WorkGang. If may_yield is\n@@ -449,1 +449,1 @@\n-  void clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield);\n+  void clear_next_bitmap(WorkGang* workers, bool may_yield);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,0 +327,2 @@\n+  _cm->flush_all_task_caches();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+\n+  bool in_undo_mark() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline bool G1ConcurrentMarkThread::in_undo_mark() const {\n+  return _state == UndoMark;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}