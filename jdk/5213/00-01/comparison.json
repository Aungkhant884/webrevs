{"files":[{"patch":"@@ -584,1 +584,1 @@\n-  \/\/ Heap region closure used for clearing the given mark bitmap.\n+  \/\/ Heap region closure used for clearing the _next_mark_bitmap.\n@@ -587,1 +587,0 @@\n-    G1CMBitMap* _bitmap;\n@@ -589,0 +588,2 @@\n+    G1CMBitMap* _bitmap;\n+    bool _suspendible; \/\/ If suspendible, do yield checks.\n@@ -590,4 +591,14 @@\n-  bool has_aborted() {\n-    if (_cm != NULL) {\n-      _cm->do_yield_check();\n-      return _cm->has_aborted();\n+    bool suspendible() {\n+      return _suspendible;\n+    }\n+\n+    bool is_clear_concurrent_undo() {\n+      return suspendible() && _cm->cm_thread()->in_undo_mark();\n+    }\n+\n+    bool has_aborted() {\n+      if (suspendible()) {\n+        _cm->do_yield_check();\n+        return _cm->has_aborted();\n+      }\n+      return false;\n@@ -595,2 +606,0 @@\n-    return false;\n-  }\n@@ -598,11 +607,13 @@\n-  HeapWord* region_clear_limit(HeapRegion* r) {\n-    \/\/ During a Concurrent Undo Mark cycle, the _next_mark_bitmap is  cleared\n-    \/\/ without swapping with the _prev_mark_bitmap. Therefore, the per region\n-    \/\/ next_top_at_mark_start and live_words data are current wrt\n-    \/\/ _next_mark_bitmap. We use this information to only clear ranges of the\n-    \/\/ bitmap that require clearing.\n-    if (_cm != NULL && _cm->cm_thread()->in_undo_mark()) {\n-      \/\/ No need to clear bitmaps for empty regions.\n-      if (_cm->live_words(r->hrm_index()) == 0) {\n-        assert(_bitmap->get_next_marked_addr(r->bottom(), r->end()) == r->end(), \"Should not have marked bits\");\n-        return r->bottom();\n+    HeapWord* region_clear_limit(HeapRegion* r) {\n+      \/\/ During a Concurrent Undo Mark cycle, the _next_mark_bitmap is  cleared\n+      \/\/ without swapping with the _prev_mark_bitmap. Therefore, the per region\n+      \/\/ next_top_at_mark_start and live_words data are current wrt\n+      \/\/ _next_mark_bitmap. We use this information to only clear ranges of the\n+      \/\/ bitmap that require clearing.\n+      if (is_clear_concurrent_undo()) {\n+        \/\/ No need to clear bitmaps for empty regions.\n+        if (_cm->live_words(r->hrm_index()) == 0) {\n+          assert(_bitmap->get_next_marked_addr(r->bottom(), r->end()) == r->end(), \"Should not have marked bits\");\n+          return r->bottom();\n+        }\n+        assert(_bitmap->get_next_marked_addr(r->next_top_at_mark_start(), r->end()) == r->end(), \"Should not have marked bits above ntams\"); \n@@ -610,3 +621,1 @@\n-      \/\/ Otherwise, we only clear up to the next_top_at_mark_start\n-      assert(_bitmap->get_next_marked_addr(r->next_top_at_mark_start(), r->end()) == r->end(), \"Should not have marked bits above ntams\");\n-      return r->next_top_at_mark_start();\n+      return r->end();\n@@ -614,2 +623,0 @@\n-    return r->end();\n-  }\n@@ -618,2 +625,6 @@\n-    G1ClearBitmapHRClosure(G1CMBitMap* bitmap, G1ConcurrentMark* cm) : HeapRegionClosure(), _bitmap(bitmap), _cm(cm) {\n-    }\n+    G1ClearBitmapHRClosure(G1ConcurrentMark* cm, bool suspendible) :\n+      HeapRegionClosure(),\n+      _cm(cm),\n+      _bitmap(cm->next_mark_bitmap()),\n+      _suspendible(suspendible)\n+    { }\n@@ -642,2 +653,2 @@\n-        assert(_cm == NULL || _cm->cm_thread()->in_progress(), \"invariant\");\n-        assert(_cm == NULL || !G1CollectedHeap::heap()->collector_state()->mark_or_rebuild_in_progress(), \"invariant\");\n+        assert(!suspendible() || _cm->cm_thread()->in_progress(), \"invariant\");\n+        assert(!suspendible() || !G1CollectedHeap::heap()->collector_state()->mark_or_rebuild_in_progress(), \"invariant\");\n@@ -661,1 +672,1 @@\n-  G1ClearBitMapTask(G1CMBitMap* bitmap, G1ConcurrentMark* cm, uint n_workers, bool suspendible) :\n+  G1ClearBitMapTask(G1ConcurrentMark* cm, uint n_workers, bool suspendible) :\n@@ -663,1 +674,1 @@\n-    _cl(bitmap, suspendible ? cm : NULL),\n+    _cl(cm, suspendible),\n@@ -673,1 +684,0 @@\n-\n@@ -687,1 +697,1 @@\n-  G1ClearBitMapTask cl(_next_mark_bitmap, this, num_workers, may_yield);\n+  G1ClearBitMapTask cl(this, num_workers, may_yield);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"}]}