{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.util.function.BiConsumer;\n@@ -280,2 +281,1 @@\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())\n-            put(e.getKey(), e.getValue());\n+        m.forEach(new PutConsumer<>(this));\n@@ -877,0 +877,18 @@\n+    \/**\n+     * A biconsumer that puts a key-value pair into a map. Maps are\n+     * used before indy and lambda expressions are ready in initPhase1.\n+     * Regular code can safely use {@code map::put} instead.\n+     *\/\n+    static final class PutConsumer<K, V> implements BiConsumer<K, V> {\n+        private final Map<K, V> map;\n+\n+        PutConsumer(Map<K, V> map) {\n+            this.map = map;\n+        }\n+\n+        @Override\n+        public void accept(K k, V v) {\n+            this.map.put(k, v);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -511,5 +511,7 @@\n-            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n-                K key = e.getKey();\n-                V value = e.getValue();\n-                putVal(hash(key), key, value, false, evict);\n-            }\n+            \/\/ Avoid lambdas before indy is ready in initPhase1\n+            m.forEach(new BiConsumer<K, V>() {\n+                @Override\n+                public void accept(K key, V value) {\n+                    putVal(hash(key), key, value, false, evict);\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -539,2 +539,1 @@\n-        for (Map.Entry<? extends K, ? extends V> e : t.entrySet())\n-            put(e.getKey(), e.getValue());\n+        t.forEach(new AbstractMap.PutConsumer<>(this));\n","filename":"src\/java.base\/share\/classes\/java\/util\/Hashtable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -510,2 +510,1 @@\n-        for (Entry<? extends K, ? extends V> e : m.entrySet())\n-            put(e.getKey(), e.getValue());\n+        m.forEach(new AbstractMap.PutConsumer<>(this));\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -570,2 +570,1 @@\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())\n-            put(e.getKey(), e.getValue());\n+        m.forEach(new AbstractMap.PutConsumer<>(this));\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1088,2 +1088,7 @@\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())\n-            putVal(e.getKey(), e.getValue(), false);\n+        \/\/ Avoid lambdas before indy is ready in initPhase1\n+        m.forEach(new BiConsumer<K, V>() {\n+            @Override\n+            public void accept(K k, V v) {\n+                putVal(k, v, false);\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -153,3 +153,2 @@\n-            for (Map.Entry<K,V> e : m2.entrySet()) {\n-                K k = e.getKey();\n-                V v = Objects.requireNonNull(e.getValue());\n+            m2.forEach((k, v) -> {\n+                Objects.requireNonNull(v);\n@@ -158,1 +157,1 @@\n-            }\n+            });\n@@ -431,2 +430,1 @@\n-            for (Map.Entry<K,V> e : m2.entrySet())\n-                m1.merge(e.getKey(), e.getValue(), mergeFunction);\n+            m2.forEach((k, v) -> m1.merge(k, v, mergeFunction));\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}