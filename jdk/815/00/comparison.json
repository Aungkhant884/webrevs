{"files":[{"patch":"@@ -1048,10 +1048,0 @@\n-\/\/------------------------------policy_align-----------------------------------\n-\/\/ Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the\n-\/\/ expression that does the alignment.  Note that only one array base can be\n-\/\/ aligned in a loop (unless the VM guarantees mutual alignment).  Note that\n-\/\/ if we vectorize short memory ops into longer memory ops, we may want to\n-\/\/ increase alignment.\n-bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {\n-  return false;\n-}\n-\n@@ -3344,3 +3334,2 @@\n-  \/\/ Counted loops may be peeled, may need some iterations run up\n-  \/\/ front for RCE, and may want to align loop refs to a cache\n-  \/\/ line.  Thus we clone a full loop up front whose trip count is\n+  \/\/ Counted loops may be peeled, or may need some iterations run up\n+  \/\/ front for RCE. Thus we clone a full loop up front whose trip count is\n@@ -3358,2 +3347,0 @@\n-  \/\/ TODO: Remove align -- not used.\n-  bool should_align  = policy_align(phase);\n@@ -3361,2 +3348,2 @@\n-  \/\/ If not RCE'ing  (iteration splitting) or Aligning, then we  do not need a\n-  \/\/ pre-loop.  We may still need to peel an initial iteration but we will not\n+  \/\/ If not RCE'ing (iteration splitting), then we do not need a pre-loop.\n+  \/\/ We may still need to peel an initial iteration but we will not\n@@ -3365,3 +3352,3 @@\n-  \/\/ Basically, if may_rce_align reports FALSE first time through, we will not\n-  \/\/ be able to later do RCE or Aligning on this loop.\n-  bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;\n+  \/\/ Basically, if peel_only reports TRUE first time through, we will not\n+  \/\/ be able to later do RCE on this loop.\n+  bool peel_only = policy_peel_only(phase) && !should_rce;\n@@ -3369,1 +3356,1 @@\n-  \/\/ If we have any of these conditions (RCE, alignment, unrolling) met, then\n+  \/\/ If we have any of these conditions (RCE, unrolling) met, then\n@@ -3372,1 +3359,1 @@\n-  if (should_rce || should_align || should_unroll) {\n+  if (should_rce || should_unroll) {\n@@ -3378,1 +3365,1 @@\n-      phase->insert_pre_post_loops(this, old_new, !may_rce_align);\n+      phase->insert_pre_post_loops(this, old_new, peel_only);\n@@ -3409,5 +3396,0 @@\n-\n-    \/\/ Adjust the pre-loop limits to align the main body iterations.\n-    if (should_align) {\n-      Unimplemented();\n-    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -620,7 +620,0 @@\n-  \/\/ Return TRUE or FALSE if the loop should be cache-line aligned.\n-  \/\/ Gather the expression that does the alignment.  Note that only\n-  \/\/ one array base can be aligned in a loop (unless the VM guarantees\n-  \/\/ mutual alignment).  Note that if we vectorize short memory ops\n-  \/\/ into longer memory ops, we may want to increase alignment.\n-  bool policy_align( PhaseIdealLoop *phase ) const;\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}