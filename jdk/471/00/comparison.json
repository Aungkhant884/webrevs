{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import com.sun.tools.javac.file.JavacFileManager;\n@@ -40,0 +39,2 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -41,0 +42,1 @@\n+import java.util.HashSet;\n@@ -42,1 +44,0 @@\n-import java.util.regex.Pattern;\n@@ -45,1 +46,1 @@\n-import static com.sun.tools.javac.util.LayoutCharacters.EOI;\n+import static com.sun.tools.javac.util.LayoutCharacters.*;\n@@ -47,3 +48,2 @@\n-\/**\n- * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode\n- * escape sequences into a token sequence.\n+\/** The lexical analyzer maps an input stream consisting of\n+ *  ASCII characters and Unicode escapes into a token sequence.\n@@ -56,5 +56,1 @@\n-public class JavaTokenizer extends UnicodeReader {\n-    \/**\n-     * If true then prints token information after each nextToken().\n-     *\/\n-    private static final boolean scannerDebug = false;\n+public class JavaTokenizer {\n@@ -62,4 +58,1 @@\n-    \/**\n-     * Sentinal for non-value.\n-     *\/\n-    private int NOT_FOUND = -1;\n+    private static final boolean scannerDebug = false;\n@@ -67,2 +60,1 @@\n-    \/**\n-     * The source language setting. Copied from scanner factory.\n+    \/** The source language setting.\n@@ -72,3 +64,1 @@\n-    \/**\n-     * The preview language setting. Copied from scanner factory.\n-     *\/\n+    \/** The preview language setting. *\/\n@@ -77,2 +67,1 @@\n-    \/**\n-     * The log to be used for error reporting. Copied from scanner factory.\n+    \/** The log to be used for error reporting.\n@@ -82,3 +71,1 @@\n-    \/**\n-     * The token factory. Copied from scanner factory.\n-     *\/\n+    \/** The token factory. *\/\n@@ -87,7 +74,1 @@\n-    \/**\n-     * The names factory. Copied from scanner factory.\n-     *\/\n-    private final Names names;\n-\n-    \/**\n-     * The token kind, set by nextToken().\n+    \/** The token kind, set by nextToken().\n@@ -97,2 +78,1 @@\n-    \/**\n-     * The token's radix, set by nextToken().\n+    \/** The token's radix, set by nextToken().\n@@ -102,2 +82,1 @@\n-    \/**\n-     * The token's name, set by nextToken().\n+    \/** The token's name, set by nextToken().\n@@ -107,2 +86,1 @@\n-    \/**\n-     * The position where a lexical error occurred;\n+    \/** The position where a lexical error occurred;\n@@ -112,2 +90,1 @@\n-    \/**\n-     * true if is a text block, set by nextToken().\n+    \/** The Unicode reader (low-level stream reader).\n@@ -115,1 +92,1 @@\n-    protected boolean isTextBlock;\n+    protected UnicodeReader reader;\n@@ -117,2 +94,1 @@\n-    \/**\n-     * true if contains escape sequences, set by nextToken().\n+    \/** If is a text block\n@@ -120,1 +96,1 @@\n-    protected boolean hasEscapeSequences;\n+    protected boolean isTextBlock;\n@@ -122,2 +98,1 @@\n-    \/**\n-     * Buffer for building literals, used by nextToken().\n+    \/** If contains escape sequences\n@@ -125,1 +100,1 @@\n-    protected StringBuilder sb;\n+    protected boolean hasEscapeSequences;\n@@ -127,3 +102,0 @@\n-    \/**\n-     * Origin scanner factory.\n-     *\/\n@@ -132,5 +104,3 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n+    \/\/ The set of lint options currently in effect. It is initialized\n+    \/\/ from the context, and then is set\/reset as needed by Attr as it\n+    \/\/ visits all the various parts of the trees during attribution.\n@@ -139,8 +109,8 @@\n-    \/**\n-     * Construct a Java token scanner from the input character buffer.\n-     *\n-     * @param fac  the factory which created this Scanner.\n-     * @param cb   the input character buffer.\n-     *\/\n-    protected JavaTokenizer(ScannerFactory fac, CharBuffer cb) {\n-        this(fac, JavacFileManager.toArray(cb), cb.limit());\n+    private static final boolean hexFloatsWork = hexFloatsWork();\n+    private static boolean hexFloatsWork() {\n+        try {\n+            Float.valueOf(\"0x1.0p1\");\n+            return true;\n+        } catch (NumberFormatException ex) {\n+            return false;\n+        }\n@@ -150,1 +120,4 @@\n-     * Construct a Java token scanner from the input character array.\n+     * Create a scanner from the input array.  This method might\n+     * modify the array.  To avoid copying the input array, ensure\n+     * that {@code inputLength < input.length} or\n+     * {@code input[input.length -1]} is a white space character.\n@@ -152,3 +125,3 @@\n-     * @param fac     the factory which created this Scanner\n-     * @param array   the input character array.\n-     * @param length  The length of the meaningful content in the array.\n+     * @param fac the factory which created this Scanner\n+     * @param buf the input, might be modified\n+     * Must be positive and less than or equal to input.length.\n@@ -156,2 +129,9 @@\n-    protected JavaTokenizer(ScannerFactory fac, char[] array, int length) {\n-        super(fac, array, length);\n+    protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {\n+        this(fac, new UnicodeReader(fac, buf));\n+    }\n+\n+    protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {\n+        this(fac, new UnicodeReader(fac, buf, inputLength));\n+    }\n+\n+    protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {\n@@ -160,1 +140,0 @@\n-        this.names = fac.names;\n@@ -164,0 +143,1 @@\n+        this.reader = reader;\n@@ -165,1 +145,0 @@\n-        this.sb = new StringBuilder(256);\n@@ -168,6 +147,0 @@\n-    \/**\n-     * Check the source level for a lexical feature.\n-     *\n-     * @param pos      position in input buffer.\n-     * @param feature  feature to verify.\n-     *\/\n@@ -187,5 +160,1 @@\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param pos  position in input buffer.\n-     * @param key  error key to report.\n+    \/** Report an error at the given position using the provided arguments.\n@@ -199,7 +168,0 @@\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param flags  diagnostic flags.\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n@@ -212,7 +174,0 @@\n-    \/**\n-     * Report an error at the given position using the provided arguments.\n-     *\n-     * @param lc     lint category.\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n@@ -224,4 +179,6 @@\n-    \/**\n-     * Add a character to the literal buffer.\n-     *\n-     * @param ch  character to add.\n+    \/** Read next character in character or string literal and copy into sbuf.\n+     *      pos - start of literal offset\n+     *      translateEscapesNow - true if String::translateEscapes is not available\n+     *                            in the java.base libs. Occurs during bootstrapping.\n+     *      multiline - true if scanning a text block. Allows newlines to be embedded\n+     *                  in the result.\n@@ -229,2 +186,66 @@\n-    protected void put(char ch) {\n-        sb.append(ch);\n+    private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {\n+         if (reader.ch == '\\\\') {\n+            if (reader.peekChar() == '\\\\' && !reader.isUnicode()) {\n+                reader.skipChar();\n+                if (!translateEscapesNow) {\n+                    reader.putChar(false);\n+                }\n+                reader.putChar(true);\n+            } else {\n+                reader.nextChar(translateEscapesNow);\n+                switch (reader.ch) {\n+                case '0': case '1': case '2': case '3':\n+                case '4': case '5': case '6': case '7':\n+                    char leadch = reader.ch;\n+                    int oct = reader.digit(pos, 8);\n+                    reader.nextChar(translateEscapesNow);\n+                    if ('0' <= reader.ch && reader.ch <= '7') {\n+                        oct = oct * 8 + reader.digit(pos, 8);\n+                        reader.nextChar(translateEscapesNow);\n+                        if (leadch <= '3' && '0' <= reader.ch && reader.ch <= '7') {\n+                            oct = oct * 8 + reader.digit(pos, 8);\n+                            reader.nextChar(translateEscapesNow);\n+                        }\n+                    }\n+                    if (translateEscapesNow) {\n+                        reader.putChar((char)oct);\n+                    }\n+                    break;\n+                case 'b':\n+                    reader.putChar(translateEscapesNow ? '\\b' : 'b', true); break;\n+                case 't':\n+                    reader.putChar(translateEscapesNow ? '\\t' : 't', true); break;\n+                case 'n':\n+                    reader.putChar(translateEscapesNow ? '\\n' : 'n', true); break;\n+                case 'f':\n+                    reader.putChar(translateEscapesNow ? '\\f' : 'f', true); break;\n+                case 'r':\n+                    reader.putChar(translateEscapesNow ? '\\r' : 'r', true); break;\n+                case '\\'':\n+                case '\\\"':\n+                case '\\\\':\n+                    reader.putChar(true); break;\n+                case 's':\n+                    checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);\n+                    reader.putChar(translateEscapesNow ? ' ' : 's', true); break;\n+                case '\\n':\n+                case '\\r':\n+                    if (!multiline) {\n+                        lexError(reader.bp, Errors.IllegalEscChar);\n+                    } else {\n+                        checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);\n+                        int start = reader.bp;\n+                        if (reader.ch == '\\r' && reader.peekChar() == '\\n') {\n+                           reader.nextChar(translateEscapesNow);\n+                        }\n+                        reader.nextChar(translateEscapesNow);\n+                        processLineTerminator(start, reader.bp);\n+                    }\n+                    break;\n+                default:\n+                    lexError(reader.bp, Errors.IllegalEscChar);\n+                }\n+            }\n+        } else if (reader.bp != reader.buflen) {\n+            reader.putChar(true);\n+        }\n@@ -233,4 +254,3 @@\n-    \/**\n-     * Add a codepoint to the literal buffer.\n-     *\n-     * @param codePoint  codepoint to add.\n+    \/** Interim access to String methods used to support text blocks.\n+     *  Required to handle bootstrapping with pre-text block jdks.\n+     *  Should be replaced with direct calls in the 'next' jdk.\n@@ -238,3 +258,4 @@\n-    protected void putCodePoint(int codePoint) {\n-        sb.appendCodePoint(codePoint);\n-    }\n+    static class TextBlockSupport {\n+        \/** Reflection method to remove incidental indentation.\n+         *\/\n+        private static final Method stripIndent;\n@@ -242,10 +263,3 @@\n-    \/**\n-     * Add current character or codepoint to the literal buffer.\n-     *\/\n-    protected void put() {\n-        if (isSurrogate()) {\n-            putCodePoint(getCodepoint());\n-        } else {\n-            put(get());\n-        }\n-    }\n+        \/** Reflection method to translate escape sequences.\n+         *\/\n+        private static final Method translateEscapes;\n@@ -253,6 +267,3 @@\n-    \/**\n-     * Add a string to the literal buffer.\n-     *\/\n-    protected void put(String string) {\n-        sb.append(string);\n-    }\n+        \/** true if stripIndent and translateEscapes are available in the bootstrap jdk.\n+         *\/\n+        private static final boolean hasSupport;\n@@ -260,5 +271,10 @@\n-    \/**\n-     * Add current character or codepoint to the literal buffer then return next character.\n-     *\/\n-    protected char putThenNext() {\n-        put();\n+        \/** Get a string method via refection or null if not available.\n+         *\/\n+        private static Method getStringMethodOrNull(String name) {\n+            try {\n+                return String.class.getMethod(name);\n+            } catch (Exception ex) {\n+                \/\/ Method not available, return null.\n+            }\n+            return null;\n+        }\n@@ -266,2 +282,7 @@\n-        return next();\n-    }\n+        static {\n+            \/\/ Get text block string methods.\n+            stripIndent = getStringMethodOrNull(\"stripIndent\");\n+            translateEscapes = getStringMethodOrNull(\"translateEscapes\");\n+            \/\/ true if stripIndent and translateEscapes are available in the bootstrap jdk.\n+            hasSupport = stripIndent != null && translateEscapes != null;\n+        }\n@@ -269,12 +290,5 @@\n-    \/**\n-     * If the specified character ch matches the current character then add current character\n-     * to the literal buffer and then advance.\n-     *\n-     * @param ch  character to match.\n-     *\n-     * @return true if ch matches current character.\n-     *\/\n-    protected boolean acceptThenPut(char ch) {\n-        if (is(ch)) {\n-            put(get());\n-            next();\n+        \/** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.\n+         *\/\n+        static boolean hasSupport() {\n+            return hasSupport;\n+        }\n@@ -282,1 +296,4 @@\n-            return true;\n+        \/** Return the leading whitespace count (indentation) of the line.\n+         *\/\n+        private static int indent(String line) {\n+            return line.length() - line.stripLeading().length();\n@@ -285,2 +302,4 @@\n-        return false;\n-    }\n+        enum WhitespaceChecks {\n+            INCONSISTENT,\n+            TRAILING\n+        };\n@@ -288,13 +307,52 @@\n-    \/**\n-     * If either ch1 or ch2 matches the current character then add current character\n-     * to the literal buffer and then advance.\n-     *\n-     * @param ch1  first character to match.\n-     * @param ch2  second character to match.\n-     *\n-     * @return true if either ch1 or ch2 matches current character.\n-     *\/\n-    protected boolean acceptOneOfThenPut(char ch1, char ch2) {\n-        if (isOneOf(ch1, ch2)) {\n-            put(get());\n-            next();\n+        \/** Check that the use of white space in content is not problematic.\n+         *\/\n+        static Set<WhitespaceChecks> checkWhitespace(String string) {\n+            \/\/ Start with empty result set.\n+            Set<WhitespaceChecks> checks = new HashSet<>();\n+            \/\/ No need to check empty strings.\n+            if (string.isEmpty()) {\n+                return checks;\n+            }\n+            \/\/ Maximum common indentation.\n+            int outdent = 0;\n+            \/\/ No need to check indentation if opting out (last line is empty.)\n+            char lastChar = string.charAt(string.length() - 1);\n+            boolean optOut = lastChar == '\\n' || lastChar == '\\r';\n+            \/\/ Split string based at line terminators.\n+            String[] lines = string.split(\"\\\\R\");\n+            int length = lines.length;\n+            \/\/ Extract last line.\n+            String lastLine = length == 0 ? \"\" : lines[length - 1];\n+             if (!optOut) {\n+                \/\/ Prime with the last line indentation (may be blank.)\n+                outdent = indent(lastLine);\n+                for (String line : lines) {\n+                    \/\/ Blanks lines have no influence (last line accounted for.)\n+                    if (!line.isBlank()) {\n+                        outdent = Integer.min(outdent, indent(line));\n+                        if (outdent == 0) {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            \/\/ Last line is representative.\n+            String start = lastLine.substring(0, outdent);\n+            for (String line : lines) {\n+                \/\/ Fail if a line does not have the same indentation.\n+                if (!line.isBlank() && !line.startsWith(start)) {\n+                    \/\/ Mix of different white space\n+                    checks.add(WhitespaceChecks.INCONSISTENT);\n+                }\n+                \/\/ Line has content even after indent is removed.\n+                if (outdent < line.length()) {\n+                    \/\/ Is the last character a white space.\n+                    lastChar = line.charAt(line.length() - 1);\n+                    if (Character.isWhitespace(lastChar)) {\n+                        \/\/ Has trailing white space.\n+                        checks.add(WhitespaceChecks.TRAILING);\n+                    }\n+                }\n+            }\n+            return checks;\n+        }\n@@ -302,1 +360,9 @@\n-            return true;\n+        \/** Invoke String::stripIndent through reflection.\n+         *\/\n+        static String stripIndent(String string) {\n+            try {\n+                string = (String)stripIndent.invoke(string);\n+            } catch (InvocationTargetException | IllegalAccessException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return string;\n@@ -305,1 +371,10 @@\n-        return false;\n+        \/** Invoke String::translateEscapes through reflection.\n+         *\/\n+        static String translateEscapes(String string) {\n+            try {\n+                string = (String)translateEscapes.invoke(string);\n+            } catch (InvocationTargetException | IllegalAccessException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return string;\n+        }\n@@ -308,4 +383,1 @@\n-    \/**\n-     * Test if the current character is a line terminator.\n-     *\n-     * @return true if current character is a line terminator.\n+    \/** Test for EOLN.\n@@ -314,1 +386,1 @@\n-        return isOneOf('\\n', '\\r');\n+        return reader.ch == LF || reader.ch == CR;\n@@ -317,2 +389,1 @@\n-    \/**\n-     * Skip and process a line terminator sequence.\n+    \/** Test for CRLF.\n@@ -320,5 +391,2 @@\n-    private void skipLineTerminator() {\n-        int start = position();\n-        accept('\\r');\n-        accept('\\n');\n-        processLineTerminator(start, position());\n+    private boolean isCRLF() {\n+        return reader.ch == CR && reader.peekChar() == LF;\n@@ -327,6 +395,1 @@\n-    \/**\n-     * Processes the current character and places in the literal buffer. If the current\n-     * character is a backslash then the next character is validated as a proper\n-     * escape character. Conversion of escape sequences takes place at end of nextToken().\n-     *\n-     * @param pos position of the first character in literal.\n+    \/** Count and skip repeated occurrences of the specified character.\n@@ -334,45 +397,7 @@\n-    private void scanLitChar(int pos) {\n-        if (acceptThenPut('\\\\')) {\n-            hasEscapeSequences = true;\n-\n-            switch (get()) {\n-                case '0': case '1': case '2': case '3':\n-                case '4': case '5': case '6': case '7':\n-                    char leadch = get();\n-                    putThenNext();\n-\n-                    if (inRange('0', '7')) {\n-                        putThenNext();\n-\n-                        if (leadch <= '3' && inRange('0', '7')) {\n-                            putThenNext();\n-                        }\n-                    }\n-                    break;\n-\n-                case 'b':\n-                case 't':\n-                case 'n':\n-                case 'f':\n-                case 'r':\n-                case '\\'':\n-                case '\\\"':\n-                case '\\\\':\n-                    putThenNext();\n-                    break;\n-\n-                case 's':\n-                    checkSourceLevel(position(), Feature.TEXT_BLOCKS);\n-                    putThenNext();\n-                    break;\n-\n-                case '\\n':\n-                case '\\r':\n-                    if (isTextBlock) {\n-                        skipLineTerminator();\n-                        \/\/ Normalize line terminator.\n-                        put('\\n');\n-                    } else {\n-                        lexError(position(), Errors.IllegalEscChar);\n-                    }\n-                    break;\n+    private int countChar(char ch, int max) {\n+        int count = 0;\n+        for ( ; count < max && reader.bp < reader.buflen && reader.ch == ch; count++) {\n+            reader.scanChar();\n+        }\n+        return count;\n+    }\n@@ -380,6 +405,6 @@\n-                default:\n-                    lexError(position(), Errors.IllegalEscChar);\n-                    break;\n-            }\n-        } else {\n-            putThenNext();\n+    \/** Skip and process a line terminator.\n+     *\/\n+    private void skipLineTerminator() {\n+        int start = reader.bp;\n+        if (isCRLF()) {\n+            reader.scanChar();\n@@ -387,0 +412,2 @@\n+        reader.scanChar();\n+        processLineTerminator(start, reader.bp);\n@@ -389,4 +416,1 @@\n-    \/**\n-     * Scan a string literal or text block.\n-     *\n-     * @param pos  position of the first character in literal.\n+    \/** Scan a string literal or text block.\n@@ -395,2 +419,3 @@\n-        \/\/ Assume the best.\n-        tk = Tokens.TokenKind.STRINGLITERAL;\n+        \/\/ Clear flags.\n+        isTextBlock = false;\n+        hasEscapeSequences = false;\n@@ -398,5 +423,10 @@\n-        int firstEOLN = NOT_FOUND;\n-        \/\/ Check for text block delimiter.\n-        isTextBlock = accept(\"\\\"\\\"\\\"\");\n-\n-        if (isTextBlock) {\n+        int firstEOLN = -1;\n+        \/\/ Attempt to scan for up to 3 double quotes.\n+        int openCount = countChar('\\\"', 3);\n+        switch (openCount) {\n+        case 1: \/\/ Starting a string literal.\n+            break;\n+        case 2: \/\/ Starting an empty string literal.\n+            tk = Tokens.TokenKind.STRINGLITERAL;\n+            return;\n+        case 3: \/\/ Starting a text block.\n@@ -405,1 +435,1 @@\n-\n+            isTextBlock = true;\n@@ -407,3 +437,7 @@\n-            \/\/ Error if the open delimiter sequence is not \"\"\"<white space>*<LineTerminator>.\n-            skipWhitespace();\n-\n+            while (reader.bp < reader.buflen) {\n+                char ch = reader.ch;\n+                if (ch != ' ' && ch != '\\t' && ch != FF) {\n+                    break;\n+                }\n+                reader.scanChar();\n+            }\n@@ -413,1 +447,3 @@\n-                lexError(position(), Errors.IllegalTextBlockOpen);\n+                \/\/ Error if the open delimiter sequence is not\n+                \/\/     \"\"\"<white space>*<LineTerminator>.\n+                lexError(reader.bp, Errors.IllegalTextBlockOpen);\n@@ -416,28 +452,11 @@\n-\n-            \/\/ While characters are available.\n-            while (isAvailable()) {\n-                if (accept(\"\\\"\\\"\\\"\")) {\n-                    return;\n-                }\n-\n-                if (isEOLN()) {\n-                    skipLineTerminator();\n-                    \/\/ Add normalized line terminator to literal buffer.\n-                    put('\\n');\n-\n-                    \/\/ Record first line terminator for error recovery.\n-                    if (firstEOLN == NOT_FOUND) {\n-                        firstEOLN = position();\n-                    }\n-                } else {\n-                    \/\/ Add character to string buffer.\n-                    scanLitChar(pos);\n-                }\n-            }\n-        } else {\n-            \/\/ Skip first quote.\n-            next();\n-\n-            \/\/ While characters are available.\n-            while (isAvailable()) {\n-                if (accept('\\\"')) {\n+            break;\n+        }\n+        \/\/ While characters are available.\n+        while (reader.bp < reader.buflen) {\n+            \/\/ If possible close delimiter sequence.\n+            if (reader.ch == '\\\"') {\n+                \/\/ Check to see if enough double quotes are present.\n+                int closeCount = countChar('\\\"', openCount);\n+                if (openCount == closeCount) {\n+                    \/\/ Good result.\n+                    tk = Tokens.TokenKind.STRINGLITERAL;\n@@ -446,4 +465,6 @@\n-\n-                if (isEOLN()) {\n-                    \/\/ Line terminator in string literal is an error.\n-                    \/\/ Fall out to unclosed string literal error.\n+                \/\/ False alarm, add double quotes to string buffer.\n+                reader.repeat('\\\"', closeCount);\n+            } else if (isEOLN()) {\n+                \/\/ Line terminator in string literal is an error.\n+                \/\/ Fall out to unclosed string literal error.\n+                if (openCount == 1) {\n@@ -451,3 +472,0 @@\n-                } else {\n-                    \/\/ Add character to string buffer.\n-                    scanLitChar(pos);\n@@ -455,0 +473,17 @@\n+                skipLineTerminator();\n+                \/\/ Add line terminator to string buffer.\n+                reader.putChar('\\n', false);\n+                \/\/ Record first line terminator for error recovery.\n+                if (firstEOLN == -1) {\n+                    firstEOLN = reader.bp;\n+                }\n+            } else if (reader.ch == '\\\\') {\n+                \/\/ Handle escape sequences.\n+                hasEscapeSequences = true;\n+                \/\/ Translate escapes immediately if TextBlockSupport is not available\n+                \/\/ during bootstrapping.\n+                boolean translateEscapesNow = !TextBlockSupport.hasSupport();\n+                scanLitChar(pos, translateEscapesNow, openCount != 1);\n+            } else {\n+                \/\/ Add character to string buffer.\n+                reader.putChar(true);\n@@ -457,1 +492,0 @@\n-\n@@ -459,5 +493,4 @@\n-        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);\n-\n-        if (firstEOLN  != NOT_FOUND) {\n-            \/\/ Reset recovery position to point after text block open delimiter sequence.\n-            reset(firstEOLN);\n+        lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);\n+        if (firstEOLN  != -1) {\n+            \/\/ Reset recovery position to point after open delimiter sequence.\n+            reader.reset(firstEOLN);\n@@ -467,6 +500,0 @@\n-    \/**\n-     * Scan sequence of digits.\n-     *\n-     * @param pos         position of the first character in literal.\n-     * @param digitRadix  radix of numeric literal.\n-     *\/\n@@ -474,3 +501,2 @@\n-        int leadingUnderscorePos = is('_') ? position() : NOT_FOUND;\n-        int trailingUnderscorePos;\n-\n+        char saveCh;\n+        int savePos;\n@@ -478,5 +504,2 @@\n-            if (!is('_')) {\n-                put();\n-                trailingUnderscorePos = NOT_FOUND;\n-            } else {\n-                trailingUnderscorePos = position();\n+            if (reader.ch != '_') {\n+                reader.putChar(false);\n@@ -484,9 +507,6 @@\n-\n-            next();\n-        } while (digit(pos, digitRadix) >= 0 || is('_'));\n-\n-        if (leadingUnderscorePos != NOT_FOUND) {\n-            lexError(leadingUnderscorePos, Errors.IllegalUnderscore);\n-        } else if (trailingUnderscorePos != NOT_FOUND) {\n-            lexError(trailingUnderscorePos, Errors.IllegalUnderscore);\n-        }\n+            saveCh = reader.ch;\n+            savePos = reader.bp;\n+            reader.scanChar();\n+        } while (reader.digit(pos, digitRadix) >= 0 || reader.ch == '_');\n+        if (saveCh == '_')\n+            lexError(savePos, Errors.IllegalUnderscore);\n@@ -495,4 +515,1 @@\n-    \/**\n-     * Read fractional part of hexadecimal floating point number.\n-     *\n-     * @param pos  position of the first character in literal.\n+    \/** Read fractional part of hexadecimal floating point number.\n@@ -501,1 +518,2 @@\n-        if (acceptOneOfThenPut('p', 'P')) {\n+        if (reader.ch == 'p' || reader.ch == 'P') {\n+            reader.putChar(true);\n@@ -503,1 +521,3 @@\n-            acceptOneOfThenPut('+', '-');\n+            if (reader.ch == '+' || reader.ch == '-') {\n+                reader.putChar(true);\n+            }\n@@ -505,2 +525,1 @@\n-\n-            if (digit(pos, 10) >= 0) {\n+            if (reader.digit(pos, 10) >= 0) {\n@@ -508,1 +527,3 @@\n-            } else {\n+                if (!hexFloatsWork)\n+                    lexError(pos, Errors.UnsupportedCrossFpLit);\n+            } else\n@@ -510,1 +531,0 @@\n-            }\n@@ -514,2 +534,2 @@\n-\n-        if (acceptOneOfThenPut('f', 'F')) {\n+        if (reader.ch == 'f' || reader.ch == 'F') {\n+            reader.putChar(true);\n@@ -519,1 +539,3 @@\n-            acceptOneOfThenPut('d', 'D');\n+            if (reader.ch == 'd' || reader.ch == 'D') {\n+                reader.putChar(true);\n+            }\n@@ -525,4 +547,1 @@\n-    \/**\n-     * Read fractional part of floating point number.\n-     *\n-     * @param pos  position of the first character in literal.\n+    \/** Read fractional part of floating point number.\n@@ -532,2 +551,1 @@\n-\n-        if (digit(pos, 10) >= 0) {\n+        if (reader.digit(pos, 10) >= 0) {\n@@ -536,4 +554,3 @@\n-\n-        int index = sb.length();\n-\n-        if (acceptOneOfThenPut('e', 'E')) {\n+        int sp1 = reader.sp;\n+        if (reader.ch == 'e' || reader.ch == 'E') {\n+            reader.putChar(true);\n@@ -541,1 +558,3 @@\n-            acceptOneOfThenPut('+', '-');\n+            if (reader.ch == '+' || reader.ch == '-') {\n+                reader.putChar(true);\n+            }\n@@ -543,2 +562,1 @@\n-\n-            if (digit(pos, 10) >= 0) {\n+            if (reader.digit(pos, 10) >= 0) {\n@@ -548,1 +566,0 @@\n-\n@@ -550,1 +567,1 @@\n-            sb.setLength(index);\n+            reader.sp = sp1;\n@@ -554,4 +571,1 @@\n-    \/**\n-     * Read fractional part and 'd' or 'f' suffix of floating point number.\n-     *\n-     * @param pos  position of the first character in literal.\n+    \/** Read fractional part and 'd' or 'f' suffix of floating point number.\n@@ -562,3 +576,3 @@\n-\n-        if (acceptOneOfThenPut('f', 'F')) {\n-             tk = TokenKind.FLOATLITERAL;\n+        if (reader.ch == 'f' || reader.ch == 'F') {\n+            reader.putChar(true);\n+            tk = TokenKind.FLOATLITERAL;\n@@ -566,1 +580,3 @@\n-            acceptOneOfThenPut('d', 'D');\n+            if (reader.ch == 'd' || reader.ch == 'D') {\n+                reader.putChar(true);\n+            }\n@@ -571,4 +587,1 @@\n-    \/**\n-     * Read fractional part and 'd' or 'f' suffix of hexadecimal floating point number.\n-     *\n-     * @param pos  position of the first character in literal.\n+    \/** Read fractional part and 'd' or 'f' suffix of floating point number.\n@@ -578,2 +591,2 @@\n-        Assert.check(is('.'));\n-        putThenNext();\n+        Assert.check(reader.ch == '.');\n+        reader.putChar(true);\n@@ -581,2 +594,1 @@\n-\n-        if (digit(pos, 16) >= 0) {\n+        if (reader.digit(pos, 16) >= 0) {\n@@ -586,1 +598,0 @@\n-\n@@ -593,3 +604,0 @@\n-    \/**\n-     * Skip over underscores and report as a error if found.\n-     *\/\n@@ -597,3 +605,4 @@\n-        if (is('_')) {\n-            lexError(position(), Errors.IllegalUnderscore);\n-            skip('_');\n+        if (reader.ch == '_') {\n+            lexError(reader.bp, Errors.IllegalUnderscore);\n+            while (reader.ch == '_')\n+                reader.scanChar();\n@@ -603,5 +612,2 @@\n-    \/**\n-     * Read a number. (Spec. 3.10)\n-     *\n-     * @param pos    position of the first character in literal.\n-     * @param radix  the radix of the number; one of 2, 8, 10, 16.\n+    \/** Read a number.\n+     *  @param radix  The radix of the number; one of 2, 8, 10, 16.\n@@ -613,1 +619,1 @@\n-        int firstDigit = digit(pos, Math.max(10, digitRadix));\n+        int firstDigit = reader.digit(pos, Math.max(10, digitRadix));\n@@ -616,1 +622,0 @@\n-\n@@ -620,2 +625,1 @@\n-\n-        if (radix == 16 && is('.')) {\n+        if (radix == 16 && reader.ch == '.') {\n@@ -623,1 +627,1 @@\n-        } else if (seendigit && radix == 16 && isOneOf('p', 'P')) {\n+        } else if (seendigit && radix == 16 && (reader.ch == 'p' || reader.ch == 'P')) {\n@@ -625,2 +629,2 @@\n-        } else if (digitRadix == 10 && is('.')) {\n-            putThenNext();\n+        } else if (digitRadix == 10 && reader.ch == '.') {\n+            reader.putChar(true);\n@@ -628,1 +632,4 @@\n-        } else if (digitRadix == 10 && isOneOf('e', 'E', 'f', 'F', 'd', 'D')) {\n+        } else if (digitRadix == 10 &&\n+                   (reader.ch == 'e' || reader.ch == 'E' ||\n+                    reader.ch == 'f' || reader.ch == 'F' ||\n+                    reader.ch == 'd' || reader.ch == 'D')) {\n@@ -641,2 +648,2 @@\n-\n-            if (acceptOneOf('l', 'L')) {\n+            if (reader.ch == 'l' || reader.ch == 'L') {\n+                reader.scanChar();\n@@ -650,10 +657,1 @@\n-    \/**\n-     * Determines if the sequence in the literal buffer is a token (keyword, operator.)\n-     *\/\n-    private void checkIdent() {\n-        name = names.fromString(sb.toString());\n-        tk = tokens.lookupKind(name);\n-    }\n-\n-    \/**\n-     * Read an identifier. (Spec. 3.8)\n+    \/** Read an identifier.\n@@ -662,2 +660,3 @@\n-        putThenNext();\n-\n+        boolean isJavaIdentifierPart;\n+        char high;\n+        reader.putChar(true);\n@@ -665,1 +664,1 @@\n-            switch (get()) {\n+            switch (reader.ch) {\n@@ -682,1 +681,0 @@\n-\n@@ -690,1 +688,1 @@\n-                next();\n+                reader.scanChar();\n@@ -692,1 +690,0 @@\n-\n@@ -694,3 +691,4 @@\n-                if (isAvailable()) {\n-                    next();\n-                    continue;\n+                if (reader.bp >= reader.buflen) {\n+                    name = reader.name();\n+                    tk = tokens.lookupKind(name);\n+                    return;\n@@ -698,4 +696,2 @@\n-\n-                checkIdent();\n-                return;\n-\n+                reader.scanChar();\n+                continue;\n@@ -703,3 +699,1 @@\n-                boolean isJavaIdentifierPart;\n-\n-                if (isASCII()) {\n+                if (reader.ch < '\\u0080') {\n@@ -709,2 +703,2 @@\n-                    if (Character.isIdentifierIgnorable(get())) {\n-                        next();\n+                    if (Character.isIdentifierIgnorable(reader.ch)) {\n+                        reader.scanChar();\n@@ -712,0 +706,9 @@\n+                    } else {\n+                        int codePoint = reader.peekSurrogates();\n+                        if (codePoint >= 0) {\n+                            if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {\n+                                reader.putChar(true);\n+                            }\n+                        } else {\n+                            isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);\n+                        }\n@@ -713,4 +716,0 @@\n-\n-                    isJavaIdentifierPart = isSurrogate()\n-                            ? Character.isJavaIdentifierPart(getCodepoint())\n-                            : Character.isJavaIdentifierPart(get());\n@@ -718,1 +717,0 @@\n-\n@@ -720,1 +718,2 @@\n-                    checkIdent();\n+                    name = reader.name();\n+                    tk = tokens.lookupKind(name);\n@@ -724,2 +723,1 @@\n-\n-            putThenNext();\n+            reader.putChar(true);\n@@ -729,6 +727,1 @@\n-    \/**\n-     * Return true if ch can be part of an operator.\n-     *\n-     * @param ch  character to check.\n-     *\n-     * @return true if ch can be part of an operator.\n+    \/** Return true if reader.ch can be part of an operator.\n@@ -743,1 +736,0 @@\n-\n@@ -749,2 +741,2 @@\n-    \/**\n-     * Read longest possible sequence of special characters and convert to token.\n+    \/** Read longest possible sequence of special characters and convert\n+     *  to token.\n@@ -754,12 +746,5 @@\n-            put();\n-            TokenKind newtk = tokens.lookupKind(sb.toString());\n-\n-            if (newtk == TokenKind.IDENTIFIER) {\n-                sb.setLength(sb.length() - 1);\n-                break;\n-            }\n-\n-            tk = newtk;\n-            next();\n-\n-            if (!isSpecial(get())) {\n+            reader.putChar(false);\n+            Name newname = reader.name();\n+            TokenKind tk1 = tokens.lookupKind(newname);\n+            if (tk1 == TokenKind.IDENTIFIER) {\n+                reader.sp--;\n@@ -768,0 +753,3 @@\n+            tk = tk1;\n+            reader.scanChar();\n+            if (!isSpecial(reader.ch)) break;\n@@ -771,2 +759,1 @@\n-    \/**\n-     * Read token (main entrypoint.)\n+    \/** Read token.\n@@ -775,1 +762,2 @@\n-        sb.setLength(0);\n+\n+        reader.sp = 0;\n@@ -778,2 +766,0 @@\n-        isTextBlock = false;\n-        hasEscapeSequences = false;\n@@ -781,1 +767,2 @@\n-        int pos;\n+        int pos = 0;\n+        int endPos = 0;\n@@ -786,4 +773,3 @@\n-                pos = position();\n-\n-                switch (get()) {\n-                case ' ':  \/\/ (Spec 3.6)\n+                pos = reader.bp;\n+                switch (reader.ch) {\n+                case ' ': \/\/ (Spec 3.6)\n@@ -791,3 +777,5 @@\n-                case '\\f': \/\/ (Spec 3.6)\n-                    skipWhitespace();\n-                    processWhiteSpace(pos, position());\n+                case FF: \/\/ (Spec 3.6)\n+                    do {\n+                        reader.scanChar();\n+                    } while (reader.ch == ' ' || reader.ch == '\\t' || reader.ch == FF);\n+                    processWhiteSpace(pos, reader.bp);\n@@ -795,4 +783,3 @@\n-\n-                case '\\n': \/\/ (Spec 3.4)\n-                    next();\n-                    processLineTerminator(pos, position());\n+                case LF: \/\/ (Spec 3.4)\n+                    reader.scanChar();\n+                    processLineTerminator(pos, reader.bp);\n@@ -800,5 +787,6 @@\n-\n-                case '\\r': \/\/ (Spec 3.4)\n-                    next();\n-                    accept('\\n');\n-                    processLineTerminator(pos, position());\n+                case CR: \/\/ (Spec 3.4)\n+                    reader.scanChar();\n+                    if (reader.ch == LF) {\n+                        reader.scanChar();\n+                    }\n+                    processLineTerminator(pos, reader.bp);\n@@ -806,1 +794,0 @@\n-\n@@ -819,1 +806,1 @@\n-                case '$': case '_': \/\/ (Spec. 3.8)\n+                case '$': case '_':\n@@ -822,5 +809,4 @@\n-\n-                case '0': \/\/ (Spec. 3.10)\n-                    next();\n-\n-                    if (acceptOneOf('x', 'X')) {\n+                case '0':\n+                    reader.scanChar();\n+                    if (reader.ch == 'x' || reader.ch == 'X') {\n+                        reader.scanChar();\n@@ -829,1 +815,2 @@\n-                    } else if (acceptOneOf('b', 'B')) {\n+                    } else if (reader.ch == 'b' || reader.ch == 'B') {\n+                        reader.scanChar();\n@@ -833,7 +820,7 @@\n-                        put('0');\n-\n-                        if (is('_')) {\n-                            int savePos = position();\n-                            skip('_');\n-\n-                            if (digit(pos, 10) < 0) {\n+                        reader.putChar('0');\n+                        if (reader.ch == '_') {\n+                            int savePos = reader.bp;\n+                            do {\n+                                reader.scanChar();\n+                            } while (reader.ch == '_');\n+                            if (reader.digit(pos, 10) < 0) {\n@@ -843,1 +830,0 @@\n-\n@@ -847,1 +833,0 @@\n-\n@@ -849,1 +834,1 @@\n-                case '5': case '6': case '7': case '8': case '9':  \/\/ (Spec. 3.10)\n+                case '5': case '6': case '7': case '8': case '9':\n@@ -852,14 +837,12 @@\n-\n-                case '.': \/\/ (Spec. 3.12)\n-                    if (accept(\"...\")) {\n-                        put(\"...\");\n-                        tk = TokenKind.ELLIPSIS;\n-                    } else {\n-                        next();\n-                        int savePos = position();\n-\n-                        if (accept('.')) {\n-                            lexError(savePos, Errors.IllegalDot);\n-                        } else if (digit(pos, 10) >= 0) {\n-                            put('.');\n-                            scanFractionAndSuffix(pos); \/\/ (Spec. 3.10)\n+                case '.':\n+                    reader.scanChar();\n+                    if (reader.digit(pos, 10) >= 0) {\n+                        reader.putChar('.');\n+                        scanFractionAndSuffix(pos);\n+                    } else if (reader.ch == '.') {\n+                        int savePos = reader.bp;\n+                        reader.putChar('.'); reader.putChar('.', true);\n+                        if (reader.ch == '.') {\n+                            reader.scanChar();\n+                            reader.putChar('.');\n+                            tk = TokenKind.ELLIPSIS;\n@@ -867,1 +850,1 @@\n-                            tk = TokenKind.DOT;\n+                            lexError(savePos, Errors.IllegalDot);\n@@ -869,0 +852,2 @@\n+                    } else {\n+                        tk = TokenKind.DOT;\n@@ -871,41 +856,16 @@\n-\n-                case ',': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.COMMA;\n-                    break loop;\n-\n-                case ';': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.SEMI;\n-                    break loop;\n-\n-                case '(': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.LPAREN;\n-                    break loop;\n-\n-                case ')': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.RPAREN;\n-                    break loop;\n-\n-                case '[': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.LBRACKET;\n-                    break loop;\n-\n-                case ']': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.RBRACKET;\n-                    break loop;\n-\n-                case '{': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.LBRACE;\n-                    break loop;\n-\n-                case '}': \/\/ (Spec. 3.12)\n-                    next();\n-                    tk = TokenKind.RBRACE;\n-                    break loop;\n-\n+                case ',':\n+                    reader.scanChar(); tk = TokenKind.COMMA; break loop;\n+                case ';':\n+                    reader.scanChar(); tk = TokenKind.SEMI; break loop;\n+                case '(':\n+                    reader.scanChar(); tk = TokenKind.LPAREN; break loop;\n+                case ')':\n+                    reader.scanChar(); tk = TokenKind.RPAREN; break loop;\n+                case '[':\n+                    reader.scanChar(); tk = TokenKind.LBRACKET; break loop;\n+                case ']':\n+                    reader.scanChar(); tk = TokenKind.RBRACKET; break loop;\n+                case '{':\n+                    reader.scanChar(); tk = TokenKind.LBRACE; break loop;\n+                case '}':\n+                    reader.scanChar(); tk = TokenKind.RBRACE; break loop;\n@@ -913,7 +873,7 @@\n-                    next();\n-\n-                    if (accept('\/')) { \/\/ (Spec. 3.7)\n-                        skipToEOLN();\n-\n-                        if (isAvailable()) {\n-                            comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n+                    reader.scanChar();\n+                    if (reader.ch == '\/') {\n+                        do {\n+                            reader.scanCommentChar();\n+                        } while (reader.ch != CR && reader.ch != LF && reader.bp < reader.buflen);\n+                        if (reader.bp < reader.buflen) {\n+                            comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));\n@@ -922,1 +882,1 @@\n-                    } else if (accept('*')) { \/\/ (Spec. 3.7)\n+                    } else if (reader.ch == '*') {\n@@ -924,0 +884,1 @@\n+                        reader.scanChar();\n@@ -925,2 +886,1 @@\n-\n-                        if (accept('*')) {\n+                        if (reader.ch == '*') {\n@@ -928,2 +888,2 @@\n-\n-                            if (is('\/')) {\n+                            reader.scanCommentChar();\n+                            if (reader.ch == '\/') {\n@@ -935,10 +895,6 @@\n-\n-                        if (!isEmpty) {\n-                            while (isAvailable()) {\n-                                if (accept('*')) {\n-                                    if (is('\/')) {\n-                                        break;\n-                                    }\n-                                } else {\n-                                    next();\n-                                }\n+                        while (!isEmpty && reader.bp < reader.buflen) {\n+                            if (reader.ch == '*') {\n+                                reader.scanChar();\n+                                if (reader.ch == '\/') break;\n+                            } else {\n+                                reader.scanCommentChar();\n@@ -947,4 +903,3 @@\n-\n-                        if (accept('\/')) {\n-                            comments = appendComment(comments, processComment(pos, position(), style));\n-\n+                        if (reader.ch == '\/') {\n+                            reader.scanChar();\n+                            comments = addComment(comments, processComment(pos, reader.bp, style));\n@@ -954,1 +909,0 @@\n-\n@@ -957,2 +911,3 @@\n-                    } else if (accept('=')) {\n-                        tk = TokenKind.SLASHEQ; \/\/ (Spec. 3.12)\n+                    } else if (reader.ch == '=') {\n+                        tk = TokenKind.SLASHEQ;\n+                        reader.scanChar();\n@@ -960,1 +915,1 @@\n-                        tk = TokenKind.SLASH; \/\/ (Spec. 3.12)\n+                        tk = TokenKind.SLASH;\n@@ -963,5 +918,3 @@\n-\n-                case '\\'': \/\/ (Spec. 3.10)\n-                    next();\n-\n-                    if (accept('\\'')) {\n+                case '\\'':\n+                    reader.scanChar();\n+                    if (reader.ch == '\\'') {\n@@ -969,0 +922,1 @@\n+                        reader.scanChar();\n@@ -970,1 +924,1 @@\n-                        if (isEOLN()) {\n+                        if (isEOLN())\n@@ -972,5 +926,3 @@\n-                        }\n-\n-                        scanLitChar(pos);\n-\n-                        if (accept('\\'')) {\n+                        scanLitChar(pos, true, false);\n+                        if (reader.ch == '\\'') {\n+                            reader.scanChar();\n@@ -983,2 +935,1 @@\n-\n-                case '\\\"': \/\/ (Spec. 3.10)\n+                case '\\\"':\n@@ -987,1 +938,0 @@\n-\n@@ -989,1 +939,1 @@\n-                    if (isSpecial(get())) {\n+                    if (isSpecial(reader.ch)) {\n@@ -993,2 +943,2 @@\n-\n-                        if (isASCII()) {\n+                        int codePoint = -1;\n+                        if (reader.ch < '\\u0080') {\n@@ -998,3 +948,8 @@\n-                            isJavaIdentifierStart = isSurrogate()\n-                                    ? Character.isJavaIdentifierStart(getCodepoint())\n-                                    : Character.isJavaIdentifierStart(get());\n+                            codePoint = reader.peekSurrogates();\n+                            if (codePoint >= 0) {\n+                                if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {\n+                                    reader.putChar(true);\n+                                }\n+                            } else {\n+                                isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);\n+                            }\n@@ -1002,1 +957,0 @@\n-\n@@ -1005,1 +959,1 @@\n-                        } else if (digit(pos, 10) >= 0) {\n+                        } else if (reader.digit(pos, 10) >= 0) {\n@@ -1007,1 +961,1 @@\n-                        } else if (is((char)EOI) || !isAvailable()) {\n+                        } else if (reader.bp == reader.buflen || reader.ch == EOI && reader.bp + 1 == reader.buflen) { \/\/ JLS 3.5\n@@ -1009,1 +963,1 @@\n-                            pos = position();\n+                            pos = reader.realLength;\n@@ -1013,5 +967,4 @@\n-                            if (isSurrogate()) {\n-                                int codePoint = getCodepoint();\n-                                char hi = Character.highSurrogate(codePoint);\n-                                char lo = Character.lowSurrogate(codePoint);\n-                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) hi, (int) lo);\n+                            if (codePoint >= 0) {\n+                                char high = reader.ch;\n+                                reader.scanChar();\n+                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) high, (int)reader.ch);\n@@ -1019,3 +972,3 @@\n-                                char ch = get();\n-                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n-                                                              String.format(\"\\\\u%04x\", (int) ch);\n+                                arg = (32 < reader.ch && reader.ch < 127) ?\n+                                                String.format(\"%s\", reader.ch) :\n+                                                String.format(\"\\\\u%04x\", (int)reader.ch);\n@@ -1023,1 +976,0 @@\n-\n@@ -1025,1 +977,1 @@\n-                            next();\n+                            reader.scanChar();\n@@ -1031,20 +983,21 @@\n-\n-            int endPos = position();\n-\n-            if (tk.tag == Token.Tag.DEFAULT) {\n-                return new Token(tk, pos, endPos, comments);\n-            } else  if (tk.tag == Token.Tag.NAMED) {\n-                return new NamedToken(tk, pos, endPos, name, comments);\n-            } else {\n-                \/\/ Get characters from string buffer.\n-                String string = sb.toString();\n-\n-                \/\/ If a text block.\n-                if (isTextBlock) {\n-                    \/\/ Verify that the incidental indentation is consistent.\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                    Warnings.InconsistentWhiteSpaceIndentation);\n+            endPos = reader.bp;\n+            switch (tk.tag) {\n+                case DEFAULT: return new Token(tk, pos, endPos, comments);\n+                case NAMED: return new NamedToken(tk, pos, endPos, name, comments);\n+                case STRING: {\n+                    \/\/ Get characters from string buffer.\n+                    String string = reader.chars();\n+                    \/\/ If a text block.\n+                    if (isTextBlock && TextBlockSupport.hasSupport()) {\n+                        \/\/ Verify that the incidental indentation is consistent.\n+                        if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n+                            Set<TextBlockSupport.WhitespaceChecks> checks =\n+                                    TextBlockSupport.checkWhitespace(string);\n+                            if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                                lexWarning(LintCategory.TEXT_BLOCKS, pos,\n+                                        Warnings.InconsistentWhiteSpaceIndentation);\n+                            }\n+                            if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                                lexWarning(LintCategory.TEXT_BLOCKS, pos,\n+                                        Warnings.TrailingWhiteSpaceWillBeRemoved);\n+                            }\n@@ -1052,3 +1005,5 @@\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                    Warnings.TrailingWhiteSpaceWillBeRemoved);\n+                        \/\/ Remove incidental indentation.\n+                        try {\n+                            string = TextBlockSupport.stripIndent(string);\n+                        } catch (Exception ex) {\n+                            \/\/ Error already reported, just use unstripped string.\n@@ -1057,14 +1012,7 @@\n-                    \/\/ Remove incidental indentation.\n-                    try {\n-                        string = string.stripIndent();\n-                    } catch (Exception ex) {\n-                        \/\/ Error already reported, just use unstripped string.\n-                    }\n-                }\n-\n-                \/\/ Translate escape sequences if present.\n-                if (hasEscapeSequences) {\n-                    try {\n-                        string = string.translateEscapes();\n-                    } catch (Exception ex) {\n-                        \/\/ Error already reported, just use untranslated string.\n+                    \/\/ Translate escape sequences if present.\n+                    if (hasEscapeSequences && TextBlockSupport.hasSupport()) {\n+                        try {\n+                            string = TextBlockSupport.translateEscapes(string);\n+                        } catch (Exception ex) {\n+                            \/\/ Error already reported, just use untranslated string.\n+                        }\n@@ -1072,3 +1020,0 @@\n-                }\n-\n-                if (tk.tag == Token.Tag.STRING) {\n@@ -1077,3 +1022,0 @@\n-                } else {\n-                    \/\/ Build numeric token.\n-                    return new NumericToken(tk, pos, endPos, string, radix, comments);\n@@ -1081,0 +1023,2 @@\n+                case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);\n+                default: throw new AssertionError();\n@@ -1082,3 +1026,2 @@\n-        } finally {\n-            int endPos = position();\n-\n+        }\n+        finally {\n@@ -1088,1 +1031,1 @@\n-                                       new String(getRawCharacters(pos, endPos))\n+                                       new String(reader.getRawCharacters(pos, endPos))\n@@ -1093,0 +1036,6 @@\n+    \/\/where\n+        List<Comment> addComment(List<Comment> comments, Comment comment) {\n+            return comments == null ?\n+                    List.of(comment) :\n+                    comments.prepend(comment);\n+        }\n@@ -1094,18 +1043,1 @@\n-    \/**\n-     * Appends a comment to the list of comments preceding the current token.\n-     *\n-     * @param comments  existing list of comments.\n-     * @param comment   comment to append.\n-     *\n-     * @return new list with comment prepended to the existing list.\n-     *\/\n-    List<Comment> appendComment(List<Comment> comments, Comment comment) {\n-        return comments == null ?\n-                List.of(comment) :\n-                comments.prepend(comment);\n-    }\n-\n-    \/**\n-     * Return the position where a lexical error occurred.\n-     *\n-     * @return position in the input buffer of where the error occurred.\n+    \/** Return the position where a lexical error occurred;\n@@ -1117,4 +1049,1 @@\n-    \/**\n-     * Set the position where a lexical error occurred.\n-     *\n-     * @param pos  position in the input buffer of where the error occurred.\n+    \/** Set the position where a lexical error occurred;\n@@ -1129,6 +1058,0 @@\n-     *\n-     * @param pos     position of the opening \/ in the input buffer.\n-     * @param endPos  position + 1 of the closing \/ in the input buffer.\n-     * @param style   style of comment.\n-     *\n-     * @return the constructed BasicComment.\n@@ -1137,1 +1060,1 @@\n-        if (scannerDebug) {\n+        if (scannerDebug)\n@@ -1139,8 +1062,5 @@\n-                                + \",\" + endPos + \",\" + style + \")=|\"\n-                                + new String(getRawCharacters(pos, endPos))\n-                                + \"|\");\n-        }\n-\n-        char[] buf = getRawCharacters(pos, endPos);\n-\n-        return new BasicComment(style, fac, buf, pos);\n+                               + \",\" + endPos + \",\" + style + \")=|\"\n+                               + new String(reader.getRawCharacters(pos, endPos))\n+                               + \"|\");\n+        char[] buf = reader.getRawCharacters(pos, endPos);\n+        return new BasicComment<>(new UnicodeReader(fac, buf, buf.length), style);\n@@ -1152,5 +1072,0 @@\n-     *\n-     * (Spec 3.6)\n-     *\n-     * @param pos     position in input buffer of first whitespace character.\n-     * @param endPos  position + 1 in input buffer of last whitespace character.\n@@ -1159,1 +1074,1 @@\n-        if (scannerDebug) {\n+        if (scannerDebug)\n@@ -1161,4 +1076,3 @@\n-                                + \",\" + endPos + \")=|\" +\n-                                new String(getRawCharacters(pos, endPos))\n-                                + \"|\");\n-        }\n+                               + \",\" + endPos + \")=|\" +\n+                               new String(reader.getRawCharacters(pos, endPos))\n+                               + \"|\");\n@@ -1169,3 +1083,0 @@\n-     *\n-     * @param pos     position in input buffer of first character in sequence.\n-     * @param endPos  position + 1 in input buffer of last character in sequence.\n@@ -1174,1 +1085,1 @@\n-        if (scannerDebug) {\n+        if (scannerDebug)\n@@ -1176,4 +1087,3 @@\n-                                + \",\" + endPos + \")=|\" +\n-                                new String(getRawCharacters(pos, endPos))\n-                                + \"|\");\n-        }\n+                               + \",\" + endPos + \")=|\" +\n+                               new String(reader.getRawCharacters(pos, endPos))\n+                               + \"|\");\n@@ -1182,2 +1092,2 @@\n-    \/**\n-     * Build a map for translating between line numbers and positions in the input.\n+    \/** Build a map for translating between line numbers and\n+     * positions in the input.\n@@ -1185,2 +1095,1 @@\n-     * @return a LineMap\n-     *\/\n+     * @return a LineMap *\/\n@@ -1188,1 +1097,1 @@\n-        return Position.makeLineMap(getRawCharacters(), length(), false);\n+        return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);\n@@ -1191,0 +1100,1 @@\n+\n@@ -1192,12 +1102,7 @@\n-     * Scan a documentation comment; determine if a deprecated tag is present.\n-     * Called once the initial \/, * have been skipped, positioned at the second *\n-     * (which is treated as the beginning of the first line).\n-     * Stops positioned at the closing '\/'.\n-     *\/\n-    protected static class BasicComment extends PositionTrackingReader implements Comment {\n-        \/**\n-         * Style of comment\n-         *   LINE starting with \/\/\n-         *   BLOCK starting with \/*\n-         *   JAVADOC starting with \/**\n-         *\/\n+    * Scan a documentation comment; determine if a deprecated tag is present.\n+    * Called once the initial \/, * have been skipped, positioned at the second *\n+    * (which is treated as the beginning of the first line).\n+    * Stops positioned at the closing '\/'.\n+    *\/\n+    protected static class BasicComment<U extends UnicodeReader> implements Comment {\n+\n@@ -1205,0 +1110,1 @@\n+        U comment_reader;\n@@ -1206,3 +1112,0 @@\n-        \/**\n-         * true if comment contains @deprecated at beginning of a line.\n-         *\/\n@@ -1210,4 +1113,0 @@\n-\n-        \/**\n-         * true if comment has been fully scanned.\n-         *\/\n@@ -1216,10 +1115,2 @@\n-        \/**\n-         * Constructor.\n-         *\n-         * @param cs      comment style\n-         * @param sf      Scan factory.\n-         * @param array   Array containing contents of source.\n-         * @param offset  Position offset in original source buffer.\n-         *\/\n-        protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n-            super(sf, array, offset);\n+        protected BasicComment(U comment_reader, CommentStyle cs) {\n+            this.comment_reader = comment_reader;\n@@ -1229,5 +1120,0 @@\n-        \/**\n-         * Return comment body text minus comment adornments or null if not scanned.\n-         *\n-         * @return comment body text.\n-         *\/\n@@ -1238,7 +1124,0 @@\n-        \/**\n-         * Return buffer position in original buffer mapped from buffer position in comment.\n-         *\n-         * @param pos  buffer position in comment.\n-         *\n-         * @return buffer position in original buffer.\n-         *\/\n@@ -1249,8 +1128,0 @@\n-        \/**\n-         * Return style of comment.\n-         *   LINE starting with \/\/\n-         *   BLOCK starting with \/*\n-         *   JAVADOC starting with \/**\n-         *\n-         * @return\n-         *\/\n@@ -1261,5 +1132,0 @@\n-        \/**\n-         * true if comment contains @deprecated at beginning of a line.\n-         *\n-         * @return true if comment contains @deprecated.\n-         *\/\n@@ -1270,1 +1136,0 @@\n-\n@@ -1274,3 +1139,1 @@\n-        \/**\n-         * Scan JAVADOC comment for details.\n-         *\/\n+        @SuppressWarnings(\"fallthrough\")\n@@ -1280,1 +1143,3 @@\n-                accept(\"\/**\");\n+\n+                comment_reader.bp += 3; \/\/ '\/**'\n+                comment_reader.ch = comment_reader.buf[comment_reader.bp];\n@@ -1283,1 +1148,2 @@\n-                while (isAvailable()) {\n+                while (comment_reader.bp < comment_reader.buflen) {\n+\n@@ -1285,1 +1151,3 @@\n-                    skipWhitespace();\n+                    while (comment_reader.bp < comment_reader.buflen && (comment_reader.ch == ' ' || comment_reader.ch == '\\t' || comment_reader.ch == FF)) {\n+                        comment_reader.scanCommentChar();\n+                    }\n@@ -1288,2 +1156,3 @@\n-                    while (accept('*')) {\n-                        if (is('\/')) {\n+                    while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '*') {\n+                        comment_reader.scanCommentChar();\n+                        if (comment_reader.ch == '\/') {\n@@ -1295,1 +1164,3 @@\n-                    skipWhitespace();\n+                    while (comment_reader.bp < comment_reader.buflen && (comment_reader.ch == ' ' || comment_reader.ch == '\\t' || comment_reader.ch == FF)) {\n+                        comment_reader.scanCommentChar();\n+                    }\n@@ -1297,0 +1168,1 @@\n+                    deprecatedPrefix = false;\n@@ -1298,1 +1170,12 @@\n-                    deprecatedPrefix = deprecatedFlag || accept(\"@deprecated\");\n+                    if (!deprecatedFlag) {\n+                        String deprecated = \"@deprecated\";\n+                        int i = 0;\n+                        while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == deprecated.charAt(i)) {\n+                            comment_reader.scanCommentChar();\n+                            i++;\n+                            if (i == deprecated.length()) {\n+                                deprecatedPrefix = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n@@ -1300,2 +1183,2 @@\n-                    if (deprecatedPrefix && isAvailable()) {\n-                        if (Character.isWhitespace(get())) {\n+                    if (deprecatedPrefix && comment_reader.bp < comment_reader.buflen) {\n+                        if (Character.isWhitespace(comment_reader.ch)) {\n@@ -1303,2 +1186,3 @@\n-                        } else if (accept('*')) {\n-                            if (is('\/')) {\n+                        } else if (comment_reader.ch == '*') {\n+                            comment_reader.scanCommentChar();\n+                            if (comment_reader.ch == '\/') {\n@@ -1312,2 +1196,2 @@\n-                    while (isAvailable()) {\n-                        switch (get()) {\n+                    while (comment_reader.bp < comment_reader.buflen) {\n+                        switch (comment_reader.ch) {\n@@ -1315,3 +1199,2 @@\n-                                next();\n-\n-                                if (is('\/')) {\n+                                comment_reader.scanCommentChar();\n+                                if (comment_reader.ch == '\/') {\n@@ -1320,1 +1203,0 @@\n-\n@@ -1322,4 +1204,8 @@\n-                            case '\\r': \/\/ (Spec 3.4)\n-                            case '\\n': \/\/ (Spec 3.4)\n-                                accept('\\r');\n-                                accept('\\n');\n+                            case CR: \/\/ (Spec 3.4)\n+                                comment_reader.scanCommentChar();\n+                                if (comment_reader.ch != LF) {\n+                                    continue forEachLine;\n+                                }\n+                            \/* fall through to LF case *\/\n+                            case LF: \/\/ (Spec 3.4)\n+                                comment_reader.scanCommentChar();\n@@ -1327,1 +1213,0 @@\n-\n@@ -1329,2 +1214,1 @@\n-                                next();\n-                                break;\n+                                comment_reader.scanCommentChar();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":668,"deletions":784,"binary":false,"changes":1452,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-import java.nio.CharBuffer;\n-import java.util.Arrays;\n+import java.nio.*;\n@@ -36,5 +35,6 @@\n-\/**\n- * An extension to the base lexical analyzer (JavaTokenizer) that\n- * captures and processes the contents of doc comments. It does\n- * so by stripping the leading whitespace and comment starts from\n- * each line of the Javadoc comment.\n+import static com.sun.tools.javac.util.LayoutCharacters.*;\n+\n+\/** An extension to the base lexical analyzer that captures\n+ *  and processes the contents of doc comments.  It does so by\n+ *  translating Unicode escape sequences and by stripping the\n+ *  leading whitespace and starts from each line of the comment.\n@@ -48,4 +48,0 @@\n-    \/**\n-     * The factory that created this Scanner.\n-     *\/\n-    final ScannerFactory fac;\n@@ -53,7 +49,2 @@\n-    \/**\n-     * Create a tokenizer from the input character buffer. The input buffer\n-     * content would typically be a Javadoc comment extracted by\n-     * JavaTokenizer.\n-     *\n-     * @param fac  the factory which created this Scanner.\n-     * @param cb   the input character buffer.\n+    \/** Create a scanner from the input buffer.  buffer must implement\n+     *  array() and compact(), and remaining() must be less than limit().\n@@ -61,3 +52,2 @@\n-    protected JavadocTokenizer(ScannerFactory fac, CharBuffer cb) {\n-        super(fac, cb);\n-        this.fac = fac;\n+    protected JavadocTokenizer(ScannerFactory fac, CharBuffer buffer) {\n+        super(fac, buffer);\n@@ -66,8 +56,2 @@\n-    \/**\n-     * Create a tokenizer from the input array. The input buffer\n-     * content would typically be a Javadoc comment extracted by\n-     * JavaTokenizer.\n-     *\n-     * @param fac     factory which created this Scanner\n-     * @param array   input character array.\n-     * @param length  length of the meaningful content in the array.\n+    \/** Create a scanner from the input array.  The array must have at\n+     *  least a single character of extra space.\n@@ -75,3 +59,2 @@\n-    protected JavadocTokenizer(ScannerFactory fac, char[] array, int length) {\n-        super(fac, array, length);\n-        this.fac = fac;\n+    protected JavadocTokenizer(ScannerFactory fac, char[] input, int inputLength) {\n+        super(fac, input, inputLength);\n@@ -82,2 +65,2 @@\n-        char[] buf = getRawCharacters(pos, endPos);\n-        return new JavadocComment(style, fac, buf, pos);\n+        char[] buf = reader.getRawCharacters(pos, endPos);\n+        return new JavadocComment(new DocReader(fac, buf, buf.length, pos), style);\n@@ -87,2 +70,4 @@\n-     * An extension of BasicComment used to extract the relevant portion\n-     * of a Javadoc comment.\n+     * This is a specialized version of UnicodeReader that keeps track of the\n+     * column position within a given character stream (used for Javadoc processing),\n+     * and which builds a table for mapping positions in the comment string to\n+     * positions in the source file.\n@@ -90,7 +75,137 @@\n-    protected static class JavadocComment extends BasicComment {\n-        \/**\n-         * Pattern used to detect a well formed @deprecated tag in a JaavDoc\n-         * comment.\n-         *\/\n-        private static final Pattern DEPRECATED_PATTERN =\n-            Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n+    static class DocReader extends UnicodeReader {\n+\n+         int col;\n+         int startPos;\n+\n+         \/**\n+          * A buffer for building a table for mapping positions in {@link #sbuf}\n+          * to positions in the source buffer.\n+          *\n+          * The array is organized as a series of pairs of integers: the first\n+          * number in each pair specifies a position in the comment text,\n+          * the second number in each pair specifies the corresponding position\n+          * in the source buffer. The pairs are sorted in ascending order.\n+          *\n+          * Since the mapping function is generally continuous, with successive\n+          * positions in the string corresponding to successive positions in the\n+          * source buffer, the table only needs to record discontinuities in\n+          * the mapping. The values of intermediate positions can be inferred.\n+          *\n+          * Discontinuities may occur in a number of places: when a newline\n+          * is followed by whitespace and asterisks (which are ignored),\n+          * when a tab is expanded into spaces, and when unicode escapes\n+          * are used in the source buffer.\n+          *\n+          * Thus, to find the source position of any position, p, in the comment\n+          * string, find the index, i, of the pair whose string offset\n+          * ({@code pbuf[i] }) is closest to but not greater than p. Then,\n+          * {@code sourcePos(p) = pbuf[i+1] + (p - pbuf[i]) }.\n+          *\/\n+         int[] pbuf = new int[128];\n+\n+         \/**\n+          * The index of the next empty slot in the pbuf buffer.\n+          *\/\n+         int pp = 0;\n+\n+         \/** The buffer index of the last double backslash sequence\n+          *\/\n+         private int doubleBackslashBp = -1;\n+\n+         DocReader(ScannerFactory fac, char[] input, int inputLength, int startPos) {\n+             super(fac, input, inputLength);\n+             this.startPos = startPos;\n+         }\n+\n+         @Override\n+         protected void convertUnicode() {\n+             if (ch == '\\\\' && unicodeConversionBp != bp) {\n+                 bp++; ch = buf[bp]; col++;\n+                 if (ch == 'u') {\n+                     do {\n+                         bp++; ch = buf[bp]; col++;\n+                     } while (ch == 'u');\n+                     int limit = bp + 3;\n+                     if (limit < buflen) {\n+                         int d = digit(bp, 16);\n+                         int code = d;\n+                         while (bp < limit && d >= 0) {\n+                             bp++; ch = buf[bp]; col++;\n+                             d = digit(bp, 16);\n+                             code = (code << 4) + d;\n+                         }\n+                         if (d >= 0) {\n+                             ch = (char)code;\n+                             unicodeConversionBp = bp;\n+                             return;\n+                         }\n+                     }\n+                     \/\/ \"illegal.Unicode.esc\", reported by base scanner\n+                 } else {\n+                     bp--;\n+                     ch = '\\\\';\n+                     col--;\n+                 }\n+             }\n+         }\n+\n+         @Override\n+         protected void scanCommentChar() {\n+             scanChar();\n+             if (ch == '\\\\') {\n+                 if (peekChar() == '\\\\' && !isUnicode()) {\n+                     bp++; col++;\n+                     doubleBackslashBp = bp;\n+                 } else {\n+                     convertUnicode();\n+                 }\n+             }\n+         }\n+\n+         @Override\n+         protected void scanChar() {\n+             bp++;\n+             ch = buf[bp];\n+             switch (ch) {\n+             case '\\r': \/\/ return\n+                 col = 0;\n+                 break;\n+             case '\\n': \/\/ newline\n+                 if (bp == 0 || buf[bp-1] != '\\r') {\n+                     col = 0;\n+                 }\n+                 break;\n+             case '\\t': \/\/ tab\n+                 col = (col \/ TabInc * TabInc) + TabInc;\n+                 break;\n+             case '\\\\': \/\/ possible Unicode\n+                 col++;\n+                 convertUnicode();\n+                 break;\n+             default:\n+                 col++;\n+                 break;\n+             }\n+         }\n+\n+         @Override\n+         public void putChar(char ch, boolean scan) {\n+             \/\/ At this point, bp is the position of the current character in buf,\n+             \/\/ and sp is the position in sbuf where this character will be put.\n+             \/\/ Record a new entry in pbuf if pbuf is empty or if sp and its\n+             \/\/ corresponding source position are not equidistant from the\n+             \/\/ corresponding values in the latest entry in the pbuf array.\n+             \/\/ (i.e. there is a discontinuity in the map function.)\n+             if ((pp == 0)\n+                     || (sp - pbuf[pp - 2] != (startPos + bp) - pbuf[pp - 1])) {\n+                 if (pp + 1 >= pbuf.length) {\n+                     int[] new_pbuf = new int[pbuf.length * 2];\n+                     System.arraycopy(pbuf, 0, new_pbuf, 0, pbuf.length);\n+                     pbuf = new_pbuf;\n+                 }\n+                 pbuf[pp] = sp;\n+                 pbuf[pp + 1] = startPos + bp;\n+                 pp += 2;\n+             }\n+             super.putChar(ch, scan);\n+         }\n@@ -98,5 +213,4 @@\n-        \/**\n-         * The relevant portion of the comment that is of interest to Javadoc.\n-         * Produced by invoking scanDocComment.\n-         *\/\n-        private String docComment = null;\n+         \/** Whether the ch represents a sequence of two backslashes. *\/\n+         boolean isDoubleBackslash() {\n+             return doubleBackslashBp == bp;\n+         }\n@@ -104,4 +218,0 @@\n-        \/**\n-         * StringBuilder used to extract the relevant portion of the Javadoc comment.\n-         *\/\n-        private StringBuilder sb;\n@@ -109,10 +219,1 @@\n-        \/**\n-         * Map used to map the extracted Javadoc comment's character positions back to\n-         * the original source.\n-         *\/\n-        OffsetMap offsetMap = new OffsetMap();\n-\n-        JavadocComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n-            super( cs, sf, array, offset);\n-            this.sb = new StringBuilder();\n-        }\n+     }\n@@ -120,9 +221,1 @@\n-        \/**\n-         * Add a character to the extraction buffer.\n-         *\n-         * @param ch  character to add.\n-         *\/\n-        protected void put(char ch) {\n-            offsetMap.add(sb.length(), offsetPosition());\n-            sb.append(ch);\n-        }\n+     protected static class JavadocComment extends JavaTokenizer.BasicComment<DocReader> {\n@@ -131,8 +224,4 @@\n-         * Add a code point to the extraction buffer.\n-         *\n-         * @param codePoint  code point to add.\n-         *\/\n-        protected void putCodePoint(int codePoint) {\n-            offsetMap.add(sb.length(), offsetPosition());\n-            sb.appendCodePoint(codePoint);\n-        }\n+        * Translated and stripped contents of doc comment\n+        *\/\n+        private String docComment = null;\n+        private int[] docPosns = null;\n@@ -140,9 +229,2 @@\n-        \/**\n-         * Add current character or code point to the extraction buffer.\n-         *\/\n-        protected void put() {\n-            if (isSurrogate()) {\n-                putCodePoint(getCodepoint());\n-            } else {\n-                put(get());\n-            }\n+        JavadocComment(DocReader reader, CommentStyle cs) {\n+            super(reader, cs);\n@@ -161,1 +243,7 @@\n-            if (pos == Position.NOPOS) {\n+            \/\/ Binary search to find the entry for which the string index is\n+            \/\/ less than pos. Since docPosns is a list of pairs of integers\n+            \/\/ we must make sure the index is always even.\n+            \/\/ If we find an exact match for pos, the other item in the pair\n+            \/\/ gives the source pos; otherwise, compute the source position\n+            \/\/ relative to the best match found in the array.\n+            if (pos == Position.NOPOS)\n@@ -163,3 +251,1 @@\n-            }\n-\n-            if (pos < 0 || pos > docComment.length()) {\n+            if (pos < 0 || pos > docComment.length())\n@@ -167,0 +253,13 @@\n+            if (docPosns == null)\n+                return Position.NOPOS;\n+            int start = 0;\n+            int end = docPosns.length;\n+            while (start < end - 2) {\n+                \/\/ find an even index midway between start and end\n+                int index = ((start  + end) \/ 4) * 2;\n+                if (docPosns[index] < pos)\n+                    start = index;\n+                else if (docPosns[index] == pos)\n+                    return docPosns[index + 1];\n+                else\n+                    end = index;\n@@ -168,2 +267,1 @@\n-\n-            return offsetMap.getSourcePos(pos);\n+            return docPosns[start + 1] + (pos - docPosns[start]);\n@@ -173,0 +271,1 @@\n+        @SuppressWarnings(\"fallthrough\")\n@@ -177,5 +276,4 @@\n-                 \/\/ Skip over \/*\n-                 accept(\"\/*\");\n-\n-                 \/\/ Consume any number of stars\n-                 skip('*');\n+                 \/\/ Skip over first slash\n+                 comment_reader.scanCommentChar();\n+                 \/\/ Skip over first star\n+                 comment_reader.scanCommentChar();\n@@ -183,2 +281,6 @@\n-                 \/\/ Is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n-                 if (is('\/')) {\n+                 \/\/ consume any number of stars\n+                 while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '*') {\n+                     comment_reader.scanCommentChar();\n+                 }\n+                 \/\/ is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n+                 if (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '\/') {\n@@ -189,5 +291,12 @@\n-                 \/\/ Skip line terminator on the first line of the comment.\n-                 if (isOneOf('\\n', '\\r')) {\n-                     accept('\\r');\n-                     accept('\\n');\n-                     firstLine = false;\n+                 \/\/ skip a newline on the first line of the comment.\n+                 if (comment_reader.bp < comment_reader.buflen) {\n+                     if (comment_reader.ch == LF) {\n+                         comment_reader.scanCommentChar();\n+                         firstLine = false;\n+                     } else if (comment_reader.ch == CR) {\n+                         comment_reader.scanCommentChar();\n+                         if (comment_reader.ch == LF) {\n+                             comment_reader.scanCommentChar();\n+                             firstLine = false;\n+                         }\n+                     }\n@@ -197,0 +306,1 @@\n+\n@@ -200,5 +310,42 @@\n-                 \/\/ puts the rest of the line into the extraction buffer.\n-                 while (isAvailable()) {\n-                     int begin_pos = position();\n-                     \/\/ Consume  whitespace from the beginning of each line.\n-                     skipWhitespace();\n+                 \/\/ puts the rest of the line into our buffer.\n+                 while (comment_reader.bp < comment_reader.buflen) {\n+                     int begin_bp = comment_reader.bp;\n+                     char begin_ch = comment_reader.ch;\n+                     \/\/ The wsLoop consumes whitespace from the beginning\n+                     \/\/ of each line.\n+                 wsLoop:\n+\n+                     while (comment_reader.bp < comment_reader.buflen) {\n+                         switch(comment_reader.ch) {\n+                         case ' ':\n+                             comment_reader.scanCommentChar();\n+                             break;\n+                         case '\\t':\n+                             comment_reader.col = ((comment_reader.col - 1) \/ TabInc * TabInc) + TabInc;\n+                             comment_reader.scanCommentChar();\n+                             break;\n+                         case FF:\n+                             comment_reader.col = 0;\n+                             comment_reader.scanCommentChar();\n+                             break;\n+         \/\/ Treat newline at beginning of line (blank line, no star)\n+         \/\/ as comment text.  Old Javadoc compatibility requires this.\n+         \/*---------------------------------*\n+                         case CR: \/\/ (Spec 3.4)\n+                             doc_reader.scanCommentChar();\n+                             if (ch == LF) {\n+                                 col = 0;\n+                                 doc_reader.scanCommentChar();\n+                             }\n+                             break;\n+                         case LF: \/\/ (Spec 3.4)\n+                             doc_reader.scanCommentChar();\n+                             break;\n+         *---------------------------------*\/\n+                         default:\n+                             \/\/ we've seen something that isn't whitespace;\n+                             \/\/ jump out.\n+                             break wsLoop;\n+                         }\n+                     }\n+\n@@ -207,1 +354,1 @@\n-                     if (is('*')) {\n+                     if (comment_reader.ch == '*') {\n@@ -209,1 +356,3 @@\n-                         skip('*');\n+                         do {\n+                             comment_reader.scanCommentChar();\n+                         } while (comment_reader.ch == '*');\n@@ -212,2 +361,3 @@\n-                         if (accept('\/')) {\n-                             \/\/ We're done with the Javadoc comment\n+                         if (comment_reader.ch == '\/') {\n+                             \/\/ We're done with the doc comment\n+                             \/\/ scanChar() and breakout.\n@@ -216,1 +366,1 @@\n-                     } else if (!firstLine) {\n+                     } else if (! firstLine) {\n@@ -219,1 +369,2 @@\n-                         reset(begin_pos);\n+                         comment_reader.bp = begin_bp;\n+                         comment_reader.ch = begin_ch;\n@@ -221,2 +372,0 @@\n-\n-                 textLoop:\n@@ -224,7 +373,42 @@\n-                     \/\/ on the line, adding them to the extraction buffer.\n-                     while (isAvailable()) {\n-                         if (accept(\"*\/\")) {\n-                             \/\/ This is the end of the comment, return\n-                             \/\/ the contents of the extraction buffer.\n-                             break outerLoop;\n-                         } else if (isOneOf('\\n', '\\r')) {\n+                     \/\/ on the line, adding them to our buffer.\n+                 textLoop:\n+                     while (comment_reader.bp < comment_reader.buflen) {\n+                         switch (comment_reader.ch) {\n+                         case '*':\n+                             \/\/ Is this just a star?  Or is this the\n+                             \/\/ end of a comment?\n+                             comment_reader.scanCommentChar();\n+                             if (comment_reader.ch == '\/') {\n+                                 \/\/ This is the end of the comment,\n+                                 \/\/ set ch and return our buffer.\n+                                 break outerLoop;\n+                             }\n+                             \/\/ This is just an ordinary star.  Add it to\n+                             \/\/ the buffer.\n+                             comment_reader.putChar('*', false);\n+                             break;\n+                         case '\\\\':\n+                             comment_reader.putChar('\\\\', false);\n+                             \/\/ If a double backslash was found, write two\n+                             if (comment_reader.isDoubleBackslash()) {\n+                                 comment_reader.putChar('\\\\', false);\n+                             }\n+                             comment_reader.scanCommentChar();\n+                             break;\n+                         case ' ':\n+                         case '\\t':\n+                             comment_reader.putChar(comment_reader.ch, false);\n+                             comment_reader.scanCommentChar();\n+                             break;\n+                         case FF:\n+                             comment_reader.scanCommentChar();\n+                             break textLoop; \/\/ treat as end of line\n+                         case CR: \/\/ (Spec 3.4)\n+                             comment_reader.scanCommentChar();\n+                             if (comment_reader.ch != LF) {\n+                                 \/\/ Canonicalize CR-only line terminator to LF\n+                                 comment_reader.putChar((char)LF, false);\n+                                 break textLoop;\n+                             }\n+                             \/* fall through to LF case *\/\n+                         case LF: \/\/ (Spec 3.4)\n@@ -234,3 +418,2 @@\n-                             put('\\n');\n-                             accept('\\r');\n-                             accept('\\n');\n+                             comment_reader.putChar(comment_reader.ch, false);\n+                             comment_reader.scanCommentChar();\n@@ -238,5 +421,1 @@\n-                         } else if (is('\\f')){\n-                             next();\n-                             break textLoop; \/\/ treat as end of line\n-\n-                         } else {\n+                         default:\n@@ -244,2 +423,2 @@\n-                             put();\n-                             next();\n+                             comment_reader.putChar(comment_reader.ch, false);\n+                             comment_reader.scanCommentChar();\n@@ -251,6 +430,11 @@\n-                 \/\/ If extraction buffer is not empty.\n-                 if (sb.length() > 0) {\n-                     \/\/ Remove trailing asterisks.\n-                     int i = sb.length() - 1;\n-                     while (i > -1 && sb.charAt(i) == '*') {\n-                         i--;\n+                 if (comment_reader.sp > 0) {\n+                     int i = comment_reader.sp - 1;\n+                 trailLoop:\n+                     while (i > -1) {\n+                         switch (comment_reader.sbuf[i]) {\n+                         case '*':\n+                             i--;\n+                             break;\n+                         default:\n+                             break trailLoop;\n+                         }\n@@ -258,1 +442,1 @@\n-                     sb.setLength(i + 1) ;\n+                     comment_reader.sp = i + 1;\n@@ -261,2 +445,4 @@\n-                    docComment = sb.toString();\n-                 } else {\n+                    docComment = comment_reader.chars();\n+                    docPosns = new int[comment_reader.pp];\n+                    System.arraycopy(comment_reader.pbuf, 0, docPosns, 0, docPosns.length);\n+                } else {\n@@ -267,3 +453,3 @@\n-\n-                \/\/ Check if comment contains @deprecated comment.\n-                if (docComment != null && DEPRECATED_PATTERN.matcher(docComment).matches()) {\n+                comment_reader = null;\n+                if (docComment != null &&\n+                        DEPRECATED_PATTERN.matcher(docComment).matches()) {\n@@ -274,0 +460,4 @@\n+        \/\/where:\n+            private static final Pattern DEPRECATED_PATTERN =\n+                    Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n+\n@@ -276,6 +466,0 @@\n-    \/**\n-     * Build a map for translating between line numbers and positions in the input.\n-     * Overridden to expand tabs.\n-     *\n-     * @return a LineMap\n-     *\/\n@@ -284,1 +468,1 @@\n-        char[] buf = getRawCharacters();\n+        char[] buf = reader.getRawCharacters();\n@@ -287,161 +471,0 @@\n-\n-    \/**\n-     * Build an int table to mapping positions in extracted Javadoc comment\n-     * to positions in the JavaTokenizer source buffer.\n-     *\n-     * The array is organized as a series of pairs of integers: the first\n-     * number in each pair specifies a position in the comment text,\n-     * the second number in each pair specifies the corresponding position\n-     * in the source buffer. The pairs are sorted in ascending order.\n-     *\n-     * Since the mapping function is generally continuous, with successive\n-     * positions in the string corresponding to successive positions in the\n-     * source buffer, the table only needs to record discontinuities in\n-     * the mapping. The values of intermediate positions can be inferred.\n-     *\n-     * Discontinuities may occur in a number of places: when a newline\n-     * is followed by whitespace and asterisks (which are ignored),\n-     * when a tab is expanded into spaces, and when unicode escapes\n-     * are used in the source buffer.\n-     *\n-     * Thus, to find the source position of any position, p, in the comment\n-     * string, find the index, i, of the pair whose string offset\n-     * ({@code map[i + SB_OFFSET] }) is closest to but not greater than p. Then,\n-     * {@code sourcePos(p) = map[i + POS_OFFSET] + (p - map[i + SB_OFFSET]) }.\n-     *\/\n-    static class OffsetMap {\n-        \/**\n-         * map entry offset for comment offset member of pair.\n-         *\/\n-        private static final int SB_OFFSET = 0;\n-\n-        \/**\n-         * map entry offset of input offset member of pair.\n-         *\/\n-        private static final int POS_OFFSET = 1;\n-\n-        \/**\n-         * Number of elements in each entry.\n-         *\/\n-        private static final int NOFFSETS = 2;\n-\n-        \/**\n-         * Array storing entries in map.\n-         *\/\n-        private int[] map;\n-\n-        \/**\n-         * Logical size of map (number of valid entries.)\n-         *\/\n-        private int size;\n-\n-        \/**\n-         * Constructor.\n-         *\/\n-        OffsetMap() {\n-            this.map = new int[128];\n-            this.size = 0;\n-        }\n-\n-        \/**\n-         * Returns true if it is worthwhile adding the entry pair to the map. That is\n-         * if there is a change in relative offset.\n-         *\n-         * @param sbOffset  comment offset member of pair.\n-         * @param posOffet  input offset member of pair.\n-         *\n-         * @return true if it is worthwhile adding the entry pair.\n-         *\/\n-        boolean shouldAdd(int sbOffset, int posOffet) {\n-            return sbOffset - lastSBOffset() != posOffet - lastPosOffset();\n-        }\n-\n-        \/**\n-         * Adds entry pair if worthwhile.\n-         *\n-         * @param sbOffset  comment offset member of pair.\n-         * @param posOffet  input offset member of pair.\n-         *\/\n-        void add(int sbOffset, int posOffet) {\n-            if (size == 0 || shouldAdd(sbOffset, posOffet)) {\n-                ensure(NOFFSETS);\n-                map[size + SB_OFFSET] = sbOffset;\n-                map[size + POS_OFFSET] = posOffet;\n-                size += NOFFSETS;\n-            }\n-        }\n-\n-        \/**\n-         * Returns the previous comment offset.\n-         *\n-         * @return the previous comment offset.\n-         *\/\n-        private int lastSBOffset() {\n-            return size == 0 ? 0 : map[size - NOFFSETS + SB_OFFSET];\n-        }\n-\n-        \/**\n-         * Returns the previous input offset.\n-         *\n-         * @return the previous input offset.\n-         *\/\n-        private int lastPosOffset() {\n-            return size == 0 ? 0 : map[size - NOFFSETS + POS_OFFSET];\n-        }\n-\n-        \/**\n-         * Ensures there is enough space for a new entry.\n-         *\n-         * @param need  number of array slots needed.\n-         *\/\n-        private void ensure(int need) {\n-            need += size;\n-            int grow = map.length;\n-\n-            while (need > grow) {\n-                grow <<= 1;\n-            }\n-\n-            \/\/ Handle overflow.\n-            if (grow < map.length) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (grow != map.length) {\n-                map = Arrays.copyOf(map, grow);\n-            }\n-        }\n-\n-        \/**\n-         * Binary search to find the entry for which the string index is less\n-         * than pos. Since the map is a list of pairs of integers we must make\n-         * sure the index is always NOFFSETS scaled. If we find an exact match\n-         * for pos, the other item in the pair gives the source pos; otherwise,\n-         * compute the source position relative to the best match found in the\n-         * array.\n-         *\/\n-        int getSourcePos(int pos) {\n-            if (size == 0) {\n-                return Position.NOPOS;\n-            }\n-\n-            int start = 0;\n-            int end = size \/ NOFFSETS;\n-\n-            while (start < end - NOFFSETS) {\n-                \/\/ find an index midway between start and end\n-                int index = (start + end) \/ 2;\n-                int indexScaled = index * NOFFSETS;\n-\n-                if (map[indexScaled + SB_OFFSET] < pos) {\n-                    start = index;\n-                } else if (map[indexScaled + SB_OFFSET] == pos) {\n-                    return map[indexScaled + POS_OFFSET];\n-                } else {\n-                    end = index;\n-                }\n-            }\n-\n-            int startScaled = start * NOFFSETS;\n-\n-            return map[startScaled + POS_OFFSET] + (pos - map[startScaled + SB_OFFSET]);\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":340,"deletions":317,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.parser;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-\/**\n- * Methods used to support text blocks lint.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-class TextBlockSupport {\n-     enum WhitespaceChecks {\n-        INCONSISTENT,\n-        TRAILING\n-    };\n-\n-    \/** Check that the use of white space in content is not problematic.\n-     *\/\n-    static Set<WhitespaceChecks> checkWhitespace(String string) {\n-        \/\/ Start with empty result set.\n-        Set<WhitespaceChecks> checks = new HashSet<>();\n-        \/\/ No need to check empty strings.\n-        if (string.isEmpty()) {\n-            return checks;\n-        }\n-        \/\/ Maximum common indentation.\n-        int outdent = 0;\n-        \/\/ No need to check indentation if opting out (last line is empty.)\n-        char lastChar = string.charAt(string.length() - 1);\n-        boolean optOut = lastChar == '\\n' || lastChar == '\\r';\n-        \/\/ Split string based at line terminators.\n-        String[] lines = string.split(\"\\\\R\");\n-        int length = lines.length;\n-        \/\/ Extract last line.\n-        String lastLine = length == 0 ? \"\" : lines[length - 1];\n-         if (!optOut) {\n-            \/\/ Prime with the last line indentation (may be blank.)\n-            outdent = indexOfNonWhitespace(lastLine);\n-            for (String line : lines) {\n-                \/\/ Blanks lines have no influence (last line accounted for.)\n-                if (!line.isBlank()) {\n-                    outdent = Integer.min(outdent, indexOfNonWhitespace(line));\n-                    if (outdent == 0) {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Last line is representative.\n-        String start = lastLine.substring(0, outdent);\n-        for (String line : lines) {\n-            \/\/ Fail if a line does not have the same indentation.\n-            if (!line.isBlank() && !line.startsWith(start)) {\n-                \/\/ Mix of different white space\n-                checks.add(WhitespaceChecks.INCONSISTENT);\n-            }\n-            \/\/ Line has content even after indent is removed.\n-            if (outdent < line.length()) {\n-                \/\/ Is the last character a white space.\n-                lastChar = line.charAt(line.length() - 1);\n-                if (Character.isWhitespace(lastChar)) {\n-                    \/\/ Has trailing white space.\n-                    checks.add(WhitespaceChecks.TRAILING);\n-                }\n-            }\n-        }\n-        return checks;\n-    }\n-\n-   private static int indexOfNonWhitespace(String string) {\n-        return string.length() - string.stripLeading().length();\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/TextBlockSupport.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.CharBuffer;\n@@ -30,0 +31,1 @@\n+import com.sun.tools.javac.file.JavacFileManager;\n@@ -31,0 +33,1 @@\n+import com.sun.tools.javac.util.ArrayUtils;\n@@ -32,0 +35,2 @@\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n@@ -33,2 +38,1 @@\n-import static com.sun.tools.javac.util.LayoutCharacters.EOI;\n-import static com.sun.tools.javac.util.LayoutCharacters.tabulate;\n+import static com.sun.tools.javac.util.LayoutCharacters.*;\n@@ -36,3 +40,4 @@\n-\/**\n- * The unicode character reader used by the javac\/javadoc lexer\/tokenizer, returns characters\n- * one by one as contained in the input stream, handling unicode escape sequences accordingly.\n+\/** The char reader used by the javac lexer\/tokenizer. Returns the sequence of\n+ * characters contained in the input stream, handling unicode escape accordingly.\n+ * Additionally, it provides features for saving chars into a buffer and to retrieve\n+ * them at a later stage.\n@@ -43,1 +48,1 @@\n- *  deletion without notice.<\/b><\/p>\n+ *  deletion without notice.<\/b>\n@@ -46,5 +51,0 @@\n-    \/**\n-     * Buffer containing characters from source file. May contain extraneous characters\n-     * beyond this.length.\n-     *\/\n-    private final char[] buffer;\n@@ -52,2 +52,2 @@\n-    \/**\n-     * Length of meaningful content in buffer.\n+    \/** The input buffer, index of next character to be read,\n+     *  index of one past last character in buffer.\n@@ -55,1 +55,3 @@\n-    private final int length;\n+    protected char[] buf;\n+    protected int bp;\n+    protected final int buflen;\n@@ -57,2 +59,1 @@\n-    \/**\n-     * Character buffer index of character currently being observed.\n+    \/** The current character.\n@@ -60,1 +61,1 @@\n-    private int position;\n+    protected char ch;\n@@ -62,4 +63,1 @@\n-    \/**\n-     * Number of characters combined to provide character currently being observed. Typically\n-     * one, but may be more when combinations of surrogate pairs and unicode escape sequences\n-     * are read.\n+    \/** The buffer index of the last converted unicode character\n@@ -67,1 +65,1 @@\n-    private int width;\n+    protected int unicodeConversionBp = -1;\n@@ -69,5 +67,2 @@\n-    \/**\n-     * Character currently being observed. If a surrogate pair is read then will be the high\n-     * member of the pair.\n-     *\/\n-    private char character;\n+    protected Log log;\n+    protected Names names;\n@@ -75,10 +70,1 @@\n-    \/**\n-     * Codepoint of character currently being observed. Typically equivalent to the character\n-     * but will have a value greater that 0xFFFF when a surrogate pair.\n-     *\/\n-    private int codepoint;\n-\n-    \/**\n-     * true if the last character was a backslash. This is used to handle the special case\n-     * when a backslash precedes an unicode escape. In that case, the second backslash\n-     * is treated as a backslash and not part of an unicode escape.\n+    \/** A character buffer for saved chars.\n@@ -86,1 +72,3 @@\n-    private boolean wasBackslash;\n+    protected char[] sbuf = new char[128];\n+    protected int realLength;\n+    protected int sp;\n@@ -89,27 +77,4 @@\n-     * Log for error reporting.\n-     *\/\n-    private final Log log;\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param sf      scan factory.\n-     * @param array   array containing contents of source.\n-     * @param length  length of meaningful content in buffer.\n-     *\/\n-    protected UnicodeReader(ScannerFactory sf, char[] array, int length) {\n-        this.buffer = array;\n-        this.length = length;\n-        this.position = 0;\n-        this.width = 0;\n-        this.character = '\\0';\n-        this.codepoint = 0;\n-        this.wasBackslash = false;\n-        this.log = sf.log;\n-\n-        nextCodePoint();\n-    }\n-\n-    \/**\n-     * Returns the length of the buffer. This is length of meaningful content in buffer and\n-     * not the length of the buffer array.\n+     * Create a scanner from the input array.  This method might\n+     * modify the array.  To avoid copying the input array, ensure\n+     * that {@code inputLength < input.length} or\n+     * {@code input[input.length -1]} is a white space character.\n@@ -117,1 +82,3 @@\n-     * @return length of the buffer.\n+     * @param sf the factory which created this Scanner\n+     * @param buffer the input, might be modified\n+     * Must be positive and less than or equal to input.length.\n@@ -119,2 +86,2 @@\n-    protected int length() {\n-        return length;\n+    protected UnicodeReader(ScannerFactory sf, CharBuffer buffer) {\n+        this(sf, JavacFileManager.toArray(buffer), buffer.limit());\n@@ -123,48 +90,10 @@\n-    \/**\n-     * Return true if current position is within the meaningful part of the buffer.\n-     *\n-     * @return true if current position is within the meaningful part of the buffer.\n-     *\/\n-    protected boolean isAvailable() {\n-        return position < length;\n-    }\n-\n-    \/**\n-     * Fetches the next 16-bit character from the buffer and places it in this.character.\n-     *\/\n-    private void nextCodeUnit() {\n-        \/\/ Index of next character in buffer.\n-        int index = position + width;\n-\n-        \/\/ If past end of buffer.\n-        if (length <= index) {\n-            \/\/ End of file is marked with EOI.\n-            character = EOI;\n-        } else {\n-            \/\/ Next character in buffer.\n-            character = buffer[index];\n-            \/\/ Increment length of codepoint.\n-            width++;\n-        }\n-    }\n-\n-    \/**\n-     * Fetches the next 16-bit character from the buffer. If an unicode escape\n-     * is detected then converts the unicode escape to a character.\n-     *\/\n-    private void nextUnicodeInputCharacter() {\n-        \/\/ Position to next codepoint.\n-        position += width;\n-        \/\/ Codepoint has no characters yet.\n-        width = 0;\n-\n-        \/\/ Fetch next character.\n-        nextCodeUnit();\n-\n-        \/\/ If second backslash is detected.\n-        if (wasBackslash) {\n-            \/\/ Treat like a normal character (not part of unicode escape.)\n-            wasBackslash = false;\n-        } else if (character == '\\\\') {\n-            \/\/ May be an unicode escape.\n-            wasBackslash = !unicodeEscape();\n+    protected UnicodeReader(ScannerFactory sf, char[] input, int inputLength) {\n+        log = sf.log;\n+        names = sf.names;\n+        realLength = inputLength;\n+        if (inputLength == input.length) {\n+            if (input.length > 0 && Character.isWhitespace(input[input.length - 1])) {\n+                inputLength--;\n+            } else {\n+                input = Arrays.copyOf(input, inputLength + 1);\n+            }\n@@ -172,3 +101,5 @@\n-\n-        \/\/ Codepoint and character match if not surrogate.\n-        codepoint = (int)character;\n+        buf = input;\n+        buflen = inputLength;\n+        buf[buflen] = EOI;\n+        bp = -1;\n+        scanChar();\n@@ -177,4 +108,1 @@\n-    \/**\n-     * Fetches the nextcode point from the buffer. If an unicode escape is recognized\n-     * then converts unicode escape to a character. If two characters are a surrogate pair\n-     * then converts to a codepoint.\n+    \/** Read next character.\n@@ -182,31 +110,6 @@\n-    private void nextCodePoint() {\n-        \/\/ Next unicode character.\n-        nextUnicodeInputCharacter();\n-\n-        \/\/ Return early if ASCII or not a surrogate pair.\n-        if (isASCII() || !Character.isHighSurrogate(character)) {\n-            return;\n-        }\n-\n-        \/\/ Capture high surrogate and position.\n-        char hi = character;\n-        int savePosition = position;\n-        int saveWidth = width;\n-\n-        \/\/ Get potential low surrogate.\n-        nextUnicodeInputCharacter();\n-        char lo = character;\n-\n-        if (Character.isLowSurrogate(lo)) {\n-            \/\/ Start codepoint at start of high surrogate.\n-            position = savePosition;\n-            width += saveWidth;\n-            \/\/ Compute codepoint.\n-            codepoint = Character.toCodePoint(hi, lo);\n-        } else {\n-            \/\/ Restore to treat high surrogate as just a character.\n-            position = savePosition;\n-            width = saveWidth;\n-            character = hi;\n-            codepoint = (int)hi;\n-            \/\/ Could potential report an error here (old code did not.)\n+    protected void scanChar() {\n+        if (bp < buflen) {\n+            ch = buf[++bp];\n+            if (ch == '\\\\') {\n+                convertUnicode();\n+            }\n@@ -216,4 +119,1 @@\n-    \/**\n-     * Converts an unicode escape into a character.\n-     *\n-     * @return true if was an unicode escape.\n+    \/** Read next character in comment, skipping over double '\\' characters.\n@@ -221,30 +121,7 @@\n-    private boolean unicodeEscape() {\n-        \/\/ Start of unicode escape (past backslash.)\n-        int start = position + width;\n-        int index;\n-\n-        \/\/ Skip multiple 'u'.\n-        for (index = start; index < length; index++) {\n-            if (buffer[index] != 'u') {\n-                break;\n-            }\n-        }\n-\n-        \/\/ Needs to be at least backslash-u.\n-        if (index != start) {\n-            \/\/ If enough characters available.\n-            if (index + 4 < length) {\n-                \/\/ Convert four hex digits to codepoint. If any digit is invalid then the\n-                \/\/ result is negative.\n-                int code = (Character.digit(buffer[index++], 16) << 12) |\n-                           (Character.digit(buffer[index++], 16) << 8) |\n-                           (Character.digit(buffer[index++], 16) << 4) |\n-                            Character.digit(buffer[index++], 16);\n-\n-                \/\/ If all digits are good.\n-                if (code >= 0) {\n-                    width = index - position;\n-                    character = (char)code;\n-\n-                    return true;\n-                }\n+    protected void scanCommentChar() {\n+        scanChar();\n+        if (ch == '\\\\') {\n+            if (peekChar() == '\\\\' && !isUnicode()) {\n+                skipChar();\n+            } else {\n+                convertUnicode();\n@@ -252,7 +129,0 @@\n-\n-            \/\/ Did not work out.\n-            log.error(position, Errors.IllegalUnicodeEsc);\n-            width = index - position;\n-\n-            \/\/ Return true so that the invalid unicode escape is skipped.\n-            return true;\n@@ -260,6 +130,0 @@\n-\n-        \/\/ Must be just a backslash.\n-        character = '\\\\';\n-        width = 1;\n-\n-        return false;\n@@ -268,4 +132,1 @@\n-    \/**\n-     * Return the current position in the character buffer.\n-     *\n-     * @return  current position in the character buffer.\n+    \/** Append a character to sbuf.\n@@ -273,2 +134,5 @@\n-    protected int position() {\n-        return position;\n+    protected void putChar(char ch, boolean scan) {\n+        sbuf = ArrayUtils.ensureCapacity(sbuf, sp);\n+        sbuf[sp++] = ch;\n+        if (scan)\n+            scanChar();\n@@ -277,11 +141,2 @@\n-\n-    \/**\n-     * Reset the reader to the specified position.\n-     * Warning: Do not use when previous character was an ASCII or unicode backslash.\n-     * @param pos\n-     *\/\n-    protected void reset(int pos) {\n-        position = pos;\n-        width = 0;\n-        wasBackslash = false;\n-        nextCodePoint();\n+    protected void putChar(char ch) {\n+        putChar(ch, false);\n@@ -290,7 +145,2 @@\n-    \/**\n-     * Return the current character in at the current position.\n-     *\n-     * @return current character in at the current position.\n-     *\/\n-    protected char get() {\n-        return character;\n+    protected void putChar(boolean scan) {\n+        putChar(ch, scan);\n@@ -299,8 +149,5 @@\n-    \/**\n-     * Return the current codepoint in at the current position.\n-     *\n-     * @return current codepoint in at the current position.\n-     *\/\n-    protected int getCodepoint() {\n-        return codepoint;\n-    }\n+    protected void nextChar(boolean skip) {\n+        if (!skip) {\n+            sbuf = ArrayUtils.ensureCapacity(sbuf, sp);\n+            sbuf[sp++] = ch;\n+        }\n@@ -308,7 +155,1 @@\n-    \/**\n-     * Returns true if the current codepoint is a surrogate.\n-     *\n-     * @return true if the current codepoint is a surrogate.\n-     *\/\n-    protected boolean isSurrogate() {\n-        return 0xFFFF < codepoint;\n+        scanChar();\n@@ -317,7 +158,2 @@\n-    \/**\n-     * Returns true if the current character is ASCII.\n-     *\n-     * @return true if the current character is ASCII.\n-     *\/\n-    protected boolean isASCII() {\n-        return character <= 0x7F;\n+    Name name() {\n+        return names.fromChars(sbuf, 0, sp);\n@@ -326,9 +162,2 @@\n-    \/**\n-     * Advances the current character to the next character.\n-     *\n-     * @return next character.\n-     *\/\n-    protected char next() {\n-        nextCodePoint();\n-\n-        return character;\n+    String chars() {\n+        return new String(sbuf, 0, sp);\n@@ -337,6 +166,1 @@\n-    \/**\n-     * Compare character. Returns true if a match.\n-     *\n-     * @param ch  character to match.\n-     *\n-     * @return true if a match.\n+    \/** Add 'count' copies of the character 'ch' to the string buffer.\n@@ -344,2 +168,4 @@\n-    protected boolean is(char ch) {\n-        return character == ch;\n+    protected void repeat(char ch, int count) {\n+        for ( ; 0 < count; count--) {\n+            putChar(ch, false);\n+        }\n@@ -348,2 +174,1 @@\n-    \/**\n-     * Match one of the arguments. Returns true if a match.\n+    \/** Reset the scan buffer pointer to 'pos'.\n@@ -351,8 +176,3 @@\n-    protected boolean isOneOf(char ch1, char ch2) {\n-        return is(ch1) || is(ch2);\n-    }\n-    protected boolean isOneOf(char ch1, char ch2, char ch3) {\n-        return is(ch1) || is(ch2) || is(ch3);\n-    }\n-    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {\n-        return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);\n+    protected void reset(int pos) {\n+        bp = pos - 1;\n+        scanChar();\n@@ -361,10 +181,31 @@\n-    \/**\n-     * Tests to see if current character is in the range of lo to hi characters (inclusive).\n-     *\n-     * @param lo  lowest character in range.\n-     * @param hi  highest character in range.\n-     *\n-     * @return true if the current character is in range.\n-     *\/\n-    protected boolean inRange(char lo, char hi) {\n-        return lo <= character && character <= hi;\n+    \/** Convert unicode escape; bp points to initial '\\' character\n+     *  (Spec 3.3).\n+     *\/\n+    protected void convertUnicode() {\n+        if (ch == '\\\\' && unicodeConversionBp != bp ) {\n+            bp++; ch = buf[bp];\n+            if (ch == 'u') {\n+                do {\n+                    bp++; ch = buf[bp];\n+                } while (ch == 'u');\n+                int limit = bp + 3;\n+                if (limit < buflen) {\n+                    int d = digit(bp, 16);\n+                    int code = d;\n+                    while (bp < limit && d >= 0) {\n+                        bp++; ch = buf[bp];\n+                        d = digit(bp, 16);\n+                        code = (code << 4) + d;\n+                    }\n+                    if (d >= 0) {\n+                        ch = (char)code;\n+                        unicodeConversionBp = bp;\n+                        return;\n+                    }\n+                }\n+                log.error(bp, Errors.IllegalUnicodeEsc);\n+            } else {\n+                bp--;\n+                ch = '\\\\';\n+            }\n+        }\n@@ -373,6 +214,1 @@\n-    \/**\n-     * Compare character and advance if a match. Returns true if a match.\n-     *\n-     * @param ch  character to match.\n-     *\n-     * @return true if a match.\n+    \/** Are surrogates supported?\n@@ -380,4 +216,4 @@\n-    protected boolean accept(char ch) {\n-        if (is(ch)) {\n-            next();\n-\n+    final static boolean surrogatesSupported = surrogatesSupported();\n+    private static boolean surrogatesSupported() {\n+        try {\n+            Character.isHighSurrogate('a');\n@@ -385,0 +221,2 @@\n+        } catch (NoSuchMethodError ex) {\n+            return false;\n@@ -386,2 +224,0 @@\n-\n-        return false;\n@@ -390,2 +226,4 @@\n-    \/**\n-     * Match one of the arguments and advance if a match. Returns true if a match.\n+    \/** Scan surrogate pairs.  If 'ch' is a high surrogate and\n+     *  the next character is a low surrogate, returns the code point\n+     *  constructed from these surrogates. Otherwise, returns -1.\n+     *  This method will not consume any of the characters.\n@@ -393,3 +231,4 @@\n-    protected boolean acceptOneOf(char ch1, char ch2) {\n-        if (isOneOf(ch1, ch2)) {\n-            next();\n+    protected int peekSurrogates() {\n+        if (surrogatesSupported && Character.isHighSurrogate(ch)) {\n+            char high = ch;\n+            int prevBP = bp;\n@@ -397,2 +236,1 @@\n-            return true;\n-        }\n+            scanChar();\n@@ -400,2 +238,1 @@\n-        return false;\n-    }\n+            char low = ch;\n@@ -403,3 +240,2 @@\n-    protected boolean acceptOneOf(char ch1, char ch2, char ch3) {\n-        if (isOneOf(ch1, ch2, ch3)) {\n-            next();\n+            ch = high;\n+            bp = prevBP;\n@@ -407,1 +243,3 @@\n-            return true;\n+            if (Character.isLowSurrogate(low)) {\n+                return Character.toCodePoint(high, low);\n+            }\n@@ -410,1 +248,1 @@\n-        return false;\n+        return -1;\n@@ -413,8 +251,14 @@\n-    \/**\n-     * Skip over all occurances of character.\n-     *\n-     * @param ch character to accept.\n-     *\/\n-    protected void skip(char ch) {\n-        while (accept(ch)) {\n-            \/\/ next\n+    \/** Convert an ASCII digit from its base (8, 10, or 16)\n+     *  to its value.\n+     *\/\n+    protected int digit(int pos, int base) {\n+        char c = ch;\n+        if ('0' <= c && c <= '9')\n+            return Character.digit(c, base); \/\/a fast common case\n+        int codePoint = peekSurrogates();\n+        int result = codePoint >= 0 ? Character.digit(codePoint, base) : Character.digit(c, base);\n+        if (result >= 0 && c > 0x7f) {\n+            log.error(pos + 1, Errors.IllegalNonasciiDigit);\n+            if (codePoint >= 0)\n+                scanChar();\n+            ch = \"0123456789abcdef\".charAt(result);\n@@ -422,0 +266,1 @@\n+        return result;\n@@ -424,7 +269,2 @@\n-    \/**\n-     * Skip over ASCII white space characters.\n-     *\/\n-    protected void skipWhitespace() {\n-        while (acceptOneOf(' ', '\\t', '\\f')) {\n-            \/\/ next\n-        }\n+    protected boolean isUnicode() {\n+        return unicodeConversionBp == bp;\n@@ -433,12 +273,2 @@\n-    \/**\n-     * Skip to end of line.\n-     *\/\n-    protected void skipToEOLN() {\n-        while (isAvailable()) {\n-            if (isOneOf('\\r', '\\n')) {\n-                break;\n-            }\n-\n-            next();\n-        }\n-\n+    protected void skipChar() {\n+        bp++;\n@@ -447,65 +277,2 @@\n-    \/**\n-     * Compare string and advance if a match. Returns true if a match.\n-     * Warning: Do not use when previous character was a backslash\n-     * (confuses state of wasBackslash.)\n-     *\n-     * @param string string to match character for character.\n-     *\n-     * @return true if a match.\n-     *\/\n-    protected boolean accept(String string) {\n-        \/\/ Quick test.\n-        if (string.length() == 0 || !is(string.charAt(0))) {\n-            return false;\n-        }\n-\n-        \/\/ Be prepared to retreat if not a match.\n-        int savedPosition = position;\n-\n-        nextCodePoint();\n-\n-        \/\/ Check each character.\n-        for (int i = 1; i < string.length(); i++) {\n-            if (!is(string.charAt(i))) {\n-                \/\/ Restart if not a match.\n-                reset(savedPosition);\n-\n-                return false;\n-            }\n-\n-            nextCodePoint();\n-        }\n-\n-        return true;\n-    }\n-\n-    \/**\n-     * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not\n-     * advance character.\n-     *\n-     * @param pos         starting position.\n-     * @param digitRadix  base of number being converted.\n-     *\n-     * @return value of digit.\n-     *\/\n-    protected int digit(int pos, int digitRadix) {\n-        int result;\n-\n-        \/\/ Just an ASCII digit.\n-        if (inRange('0', '9')) {\n-            \/\/ Fast common case.\n-            result = character - '0';\n-\n-            return result < digitRadix ? result : -1;\n-        }\n-\n-        \/\/ Handle other digits.\n-        result = isSurrogate() ? Character.digit(codepoint, digitRadix) :\n-                                 Character.digit(character, digitRadix);\n-\n-        if (result >= 0 && !isASCII()) {\n-            log.error(position(), Errors.IllegalNonasciiDigit);\n-            character = \"0123456789abcdef\".charAt(result);\n-        }\n-\n-        return result;\n+    protected char peekChar() {\n+        return buf[bp + 1];\n@@ -515,3 +282,2 @@\n-     * Returns the input buffer. Unicode escape sequences are not translated.\n-     *\n-     * @return the input buffer.\n+     * Returns a copy of the input buffer, up to its inputLength.\n+     * Unicode escape sequences are not translated.\n@@ -520,1 +286,3 @@\n-        return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);\n+        char[] chars = new char[buflen];\n+        System.arraycopy(buf, 0, chars, 0, buflen);\n+        return chars;\n@@ -532,3 +300,2 @@\n-     * @param  beginIndex the beginning index, inclusive.\n-     * @param  endIndex the ending index, exclusive.\n-     *\n+     * @param beginIndex the beginning index, inclusive.\n+     * @param endIndex the ending index, exclusive.\n@@ -539,70 +306,4 @@\n-        return Arrays.copyOfRange(buffer, beginIndex, endIndex);\n-    }\n-\n-    \/**\n-     * This is a specialized version of UnicodeReader that keeps track of the\n-     * column position within a given character stream. Used for Javadoc\n-     * processing to build a table for mapping positions in the comment string\n-     * to positions in the source file.\n-     *\/\n-    static class PositionTrackingReader extends UnicodeReader {\n-        \/**\n-         * Offset from the beginning of the original reader buffer.\n-         *\/\n-        private int offset;\n-\n-        \/**\n-         * Current column in the comment.\n-         *\/\n-        private int column;\n-\n-        \/**\n-         * Constructor.\n-         *\n-         * @param sf      Scan factory.\n-         * @param array   Array containing contents of source.\n-         * @param offset  Position offset in original source buffer.\n-         *\/\n-        protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {\n-            super(sf, array, array.length);\n-            this.offset = offset;\n-            this.column = 0;\n-        }\n-\n-        \/**\n-         * Advances the current character to the next character. Tracks column.\n-         *\n-         * @return next character.\n-         *\/\n-        @Override\n-        protected char next() {\n-            super.next();\n-\n-            if (isOneOf('\\n', '\\r', '\\f')) {\n-                column = 0;\n-            } else if (is('\\t')) {\n-                column = tabulate(column);\n-            } else {\n-                column++;\n-            }\n-\n-            return get();\n-        }\n-\n-        \/**\n-         * Returns the current column.\n-         *\n-         * @return  the current column.\n-         *\/\n-        protected int column() {\n-            return column;\n-        }\n-\n-        \/**\n-         * Returns position relative to the original source buffer.\n-         *\n-         * @return\n-         *\/\n-        protected int offsetPosition() {\n-            return position() + offset;\n-        }\n+        int length = endIndex - beginIndex;\n+        char[] chars = new char[length];\n+        System.arraycopy(buf, beginIndex, chars, 0, length);\n+        return chars;\n@@ -610,1 +311,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":181,"deletions":481,"binary":false,"changes":662,"status":"modified"},{"patch":"@@ -1386,0 +1386,3 @@\n+compiler.err.unsupported.cross.fp.lit=\\\n+    hexadecimal floating-point literals are not supported on this VM\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -987,0 +987,2 @@\n+compiler.err.unsupported.cross.fp.lit=16\\u9032\\u6D6E\\u52D5\\u5C0F\\u6570\\u70B9\\u30EA\\u30C6\\u30E9\\u30EB\\u306F\\u3053\\u306EVM\\u3067\\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_ja.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -987,0 +987,2 @@\n+compiler.err.unsupported.cross.fp.lit=\\u8BE5 VM \\u4E0D\\u652F\\u6301\\u5341\\u516D\\u8FDB\\u5236\\u6D6E\\u70B9\\u6587\\u5B57\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_zh_CN.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-                        column = tabulate(column);\n+                        column = (column \/ TabInc * TabInc) + TabInc;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/DiagnosticSource.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2010, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,6 +71,0 @@\n-\n-    \/** Bump column to the next tab.\n-     *\/\n-    static int tabulate(int column) {\n-        return (column \/ TabInc * TabInc) + TabInc;\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/LayoutCharacters.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,1 @@\n-                    column = tabulate(column);\n+                    column = (column \/ TabInc * TabInc) + TabInc;\n@@ -282,1 +282,1 @@\n-                    col = tabulate(col);\n+                    col = (col \/ TabInc * TabInc) + TabInc;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Position.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Digits.java:11:43: compiler.err.illegal.nonascii.digit\n+Digits.java:11:41: compiler.err.illegal.nonascii.digit\n","filename":"test\/langtools\/tools\/javac\/Digits.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+compiler.err.unsupported.cross.fp.lit                   # Scanner: host system dependent\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-NonasciiDigit.java:12:18: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:12:24: compiler.err.illegal.nonascii.digit\n@@ -3,5 +3,5 @@\n-NonasciiDigit.java:14:18: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:16:21: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:17:23: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:18:25: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:19:23: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:14:24: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:16:27: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:17:22: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:18:22: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:19:22: compiler.err.illegal.nonascii.digit\n@@ -9,1 +9,1 @@\n-NonasciiDigit.java:21:21: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:21:27: compiler.err.illegal.nonascii.digit\n","filename":"test\/langtools\/tools\/javac\/unicode\/NonasciiDigit.out","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,3 @@\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- * @build toolbox.ToolBox toolbox.JavacTask\n- * @run main SubChar\n+ * @author gafter\n+ *\n+ * @compile SubChar.java\n@@ -35,8 +33,0 @@\n-import toolbox.JavacTask;\n-import toolbox.JavaTask;\n-import toolbox.Task;\n-import toolbox.ToolBox;\n-\n-\n-public class SubChar {\n-    private static final ToolBox TOOLBOX = new ToolBox();\n@@ -44,17 +34,7 @@\n-    private static final String SOURCE = \"\"\"\n-        \/*\n-        Note: this source file has been crafted very carefully to end with the\n-        unicode escape sequence for the control-Z character without a\n-        following newline.  The scanner is specified to allow control-Z there.\n-        If you edit this source file, please make sure that your editor does\n-        not insert a newline after that trailing line.\n-        *\/\n-\n-        \/** \\\\u001A *\/\n-        class ControlZTest {\n-            public static void main(String args[]) {\n-                return;\n-            }\n-        }\n-        \/* \\\\u001A *\/\\\n-        \"\"\";\n+\/*\n+Note: this source file has been crafted very carefully to end with the\n+unicode escape sequence for the control-Z character without a\n+following newline.  The scanner is specified to allow control-Z there.\n+If you edit this source file, please make sure that your editor does\n+not insert a newline after that trailing line.\n+*\/\n@@ -62,10 +42,5 @@\n-        public static void main(String... args) {\n-            String output = new JavacTask(TOOLBOX)\n-                    .sources(SOURCE)\n-                    .classpath(\".\")\n-                    .options(\"-encoding\", \"utf8\")\n-                    .run()\n-                    .writeAll()\n-                    .getOutput(Task.OutputKind.DIRECT);\n-            System.out.println(output);\n-        }\n+\/** \\u001A *\/\n+class SubChar {\n+    public static void main(String args[]) {\n+        return;\n+    }\n@@ -73,0 +48,1 @@\n+\/* \\u001A *\/\n","filename":"test\/langtools\/tools\/javac\/unicode\/SubChar.java","additions":17,"deletions":41,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-SupplementaryJavaID2.java:12:9: compiler.err.illegal.char: \\ud801\n-SupplementaryJavaID2.java:12:15: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID2.java:12:14: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID2.java:12:20: compiler.err.illegal.char: \\ud801\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID2.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-SupplementaryJavaID3.java:12:12: compiler.err.illegal.char: \\ud801\n-SupplementaryJavaID3.java:12:18: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID3.java:12:17: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID3.java:12:23: compiler.err.illegal.char: \\ud801\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID3.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SupplementaryJavaID4.java:14:9: compiler.err.illegal.char: \\ud834\\udd7b\n+SupplementaryJavaID4.java:14:14: compiler.err.illegal.char: \\ud834\\udd7b\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID4.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SupplementaryJavaID5.java:14:12: compiler.err.illegal.char: \\ud834\\udd00\n+SupplementaryJavaID5.java:14:17: compiler.err.illegal.char: \\ud834\\udd00\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}