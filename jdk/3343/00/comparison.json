{"files":[{"patch":"@@ -1,688 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-\/\/ This program computes the parameters and arrays needed by the modified-ziggurat algorithm\n-\/\/ for sampling from either an exponential distribution with mean 1 or a normal distribution\n-\/\/ with mean 0 and standad deviation 1.  The four arrays needed for either kind of sampler are:\n-\/\/\n-\/\/    X[i] is the horizontal width of ziggurat layer i\n-\/\/    Y[i] is f(X[i]), where f is the function for the exponential or normal curve\n-\/\/    alias_threshold is the table of probability mass thresholds for Walker's alias method,\n-\/\/       with one entry for the tail of the distributon and one entry for each overhang region\n-\/\/    alias_map is the table of forwarding indices used for Walker's alias method\n-\/\/\n-\/\/ The four parameters needed by the exponential sampler are:\n-\/\/\n-\/\/    exponential_number_of_layers   the number of layers in the ziggurat\n-\/\/    exponential_X_0                the width of the box in layer 0 (which is the x-coordinate of the left end of the tail)\n-\/\/    exponential_convex_margin      the maximum discrepancy between the curve and a certain diagonal line above it\n-\/\/\n-\/\/ The five parameters needed by the normal sampler are:\n-\/\/\n-\/\/    normal_number_of_layers        the number of layers in the ziggurat\n-\/\/    normal_X_0                     the width of the box in layer 0 (which is the x-coordinate of the left end of the tail)\n-\/\/    normal_inflection_index        the index of the layer containing the inflection point\n-\/\/    normal_convex_margin           the maximum discrepancy between the curve and a certain diagonal line above it\n-\/\/    normal_concave_margin          the maximum discrepancy between the curve and a certain diagonal line below it\n-\/\/\n-\/\/ After computing the parameters and tables, the program prints (to standard output)\n-\/\/ a complete Java source code file for a class named either FloatZigguratTables or\n-\/\/ DoubleZigguratTables, according to which precision has been requested.\n-\n-\/\/ The only reason this program has been written as C code rather than Java code is that\n-\/\/ most of the calculations need to be performed in long double precision in order to\n-\/\/ be able to calculate double values of sufficient accuracy.  This code relies on\n-\/\/ long double math functions sqrtl, powl, expl, logl, log2l, erfl, ceill, and copysignl.\n-\n-\/\/ The overall modified ziggurat algorithm closely follows the description in:\n-\/\/\n-\/\/     Christopher D. McFarland.  2016 (published online 24 Jun 2015).  A modified ziggurat\n-\/\/     algorithm for generating exponentially and normally distributed pseudorandom numbers.\n-\/\/     Journal of Statistical Computation and Simulation 86 (7), pages 1281-1294.\n-\/\/     https:\/\/www.tandfonline.com\/doi\/abs\/10.1080\/00949655.2015.1060234\n-\/\/     Also at https:\/\/arxiv.org\/abs\/1403.6870 (26 March 2014).\n-\/\/\n-\/\/ This paper in turn refers to code available at https:\/\/bitbucket.org\/cdmcfarland\/fast_prng.\n-\/\/ This includes a file create_layers.py of Python code for constructing the tables.\n-\/\/ The C code here loosely follows the organization of that Python code.  However, the Python\n-\/\/ code appears to contain a number of errors and infelicities that have been corrected here:\n-\/\/\n-\/\/ (1) On line 211, 1 is added to i_inflection, causing the value 205 to be printed when\n-\/\/     table size is 256.  Adding 1 is not correct; the correct value for printing is 204.\n-\/\/\n-\/\/ (2) On line 203, 3 values are dropped from the front of the array E when computing iE_max,\n-\/\/     with no explanation given.  We believe this is incorrect; E[3:] should be simply E.\n-\/\/\n-\/\/ (3) When the table elements are converted to printable strings using \"map(str,data)\",\n-\/\/     precision is lost because the Python str function produces only 12 decimal digits.\n-\/\/     In this C code, we print table entries using 17 decimal digits (format %23.16e),\n-\/\/     because 17 decimal digits suffice to preserve the value of any double precision\n-\/\/     value (and 16 decimal digits do not always suffice).\n-\/\/\n-\/\/ (4) At lines 215-223, the Python code computes only a single E value for the\n-\/\/     rectangle containing the inflection point of the normal distribution curve.\n-\/\/     We believe it is conceptually more correct to compute two such E values,\n-\/\/     one for the concave part of the curve (to the left of the inflection point)\n-\/\/     and one for the convex part of the curve (to the right of the inflection point).\n-\/\/\n-\/\/ We also observe that the McFarland paper asserts that the solver uses Brent's method,\n-\/\/ but the solver in the Python code does not implement Brent's method.  A proper\n-\/\/ implementation of Brent's method (or its predecessor, Dekker's method) alternates\n-\/\/ between use of the Secant Method and use of the Bisection Method according to various\n-\/\/ criteria, but the Python code merely tries the Secant Method for a fixed number of\n-\/\/ iterations and then switches to the Bisection Method for a calculated number of iterations.\n-\/\/ Here we have translated Brent's Method into C from the Algol code in Brent's original paper.\n-\n-#include <float.h>\n-#include <math.h>\n-#include <stdio.h>\n-#include <assert.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-\/\/ The SIZE may be any power of 2 not greater than 2048; 128, 256, 512, and 1024\n-\/\/ are all plausible choices, but 256 probably makes the best space\/time tradeoff.\n-\/\/ The number of layers in the constructed ziggurat will be slightly smaller than this.\n-#ifndef SIZE\n-#define SIZE 256\n-#endif\n-\n-\/\/ Set USE_DOUBLE to 1 for Java routines that compute results of type double, or to 0 for float.\n-#ifndef USE_DOUBLE\n-#define USE_DOUBLE 1\n-#endif\n-\n-\n-#if USE_DOUBLE\n-\n-typedef int64_t int_type;\n-typedef uint64_t uint_type;\n-typedef double float_type;\n-#define int_bits 64\n-#define max_int 0x7fffffffffffffff\n-#define max_uint 0xffffffffffffffff\n-#define java_int_type \"long\"\n-#define java_float_type \"double\"\n-#define java_capitalized_float_type \"Double\"\n-\n-#else\n-\n-typedef int32_t int_type;\n-typedef uint32_t uint_type;\n-typedef float float_type;\n-#define int_bits 32\n-#define max_int 0x7fffffff\n-#define max_uint 0xffffffff\n-#define java_int_type \"int\"\n-#define java_float_type \"float\"\n-#define java_capitalized_float_type \"Float\"\n-\n-#endif\n-\n-\/\/ We set SOLVER_TOLERANCE quite tight\n-#define SOLVER_TOLERANCE 1.0e-19L\n-\n-#define PI (3.1415926535897932384626433832795L)\n-\n-\/\/ Assert that two long double values are equal to within double (not long double) precision\n-#define check_equal(x, y) do assert(((x)>=(y) ? (x)-(y) : (y)-(x)) < DBL_EPSILON); while (0)\n-\n-\/\/ The best way to compute the absolute value of a long double.\n-long double absl(long double x) {\n-  return copysignl(x, 1.0);\n-}\n-\n-\/\/ The type of a function that accepts one long double argument and returns a long double result.\n-typedef long double (*longdoublefn)(long double);\n-\n-\/\/ The functions we will traffic in for solving need an argument but also two\n-\/\/ or three parameters, of which the first is a longdoublefn and the others are\n-\/\/ long double values.  Because vanilla C doesn't have closures, we just arrange\n-\/\/ for the solver to accept three parameters and pass them in each time.\n-typedef long double (*solverfn)(long double, longdoublefn, long double, long double);\n-\n-\n-\/\/ The solver: find a root of function g (which has f, p1, and p2 as parameters).\n-\/\/ Returns a value x within bounds [a, b] such that g(x) is (close to) zero.\n-\/\/ Returns NaN if either a >= b or g(a) and g(b) have the same sign;\n-\/\/ this information can help the caller to adjust the bounds and try again.\n-\/\/\n-\/\/ This solver uses Brent's Method, as it appears in:\n-\/\/\n-\/\/    R. P. Brent.  1971.  An algorithm with guaranteed convergence for finding a zero of a function.\n-\/\/    The Computer Journal, Volume 14, Issue 4, 422â€“425.  https:\/\/doi.org\/10.1093\/comjnl\/14.4.422\n-\/\/\n-\/\/ We assume that LDBL_EPSILON is the correct value to use for \"macheps\" as used in the Algol code.\n-\n-long double fsolve(solverfn g, longdoublefn f, long double p1, long double p2,\n-          long double a, long double b) {\n-  \/\/ Check the required conditions on the arguments.\n-  if (a >= b) return NAN;\n-  long double ga = g(a, f, p1, p2), gb = g(b, f, p1, p2);\n-  if (copysignl(1.0, ga) == copysignl(1.0, gb)) return NAN;\n-  \/\/ Here is Brent's Method, translated from Algol to C.  We have replaced the uses\n-  \/\/ of \"goto\" with \"for\" loops and have scoped the variable declarations more tightly.\n-  for (;;) {   \/\/ label \"int:\" in the Algol code\n-    long double c = a, gc = ga;\n-    long double e = b - a;\n-    long double d = e;\n-    for (;;) {   \/\/ label \"ext:\" in the Algol code\n-      if (absl(gc) < absl(gb)) {\n-   a = b; b = c; c = a;\n-   ga = gb; gb = gc; gc = ga;\n-      }\n-      long double tol = 2 * LDBL_EPSILON * absl(b) + SOLVER_TOLERANCE;\n-      long double m = (c - b)\/2.0L;\n-      if (absl(m) < tol || gb == 0.0L) return b;\n-      \/\/ See if a bisection is forced\n-      if (absl(e) < tol || absl(ga) <= absl(gb)) {\n-   d = e = m;   \/\/ Yes, it is\n-      } else {\n-   long double s = gb\/ga;\n-   long double p, q;\n-   if (a == c) {\n-     \/\/ Linear interpolation\n-     p = 2.0L * m * s;\n-     q = 1.0L - s;\n-   } else {\n-     \/\/ Inverse quadratic interpolation\n-     long double z = ga\/gc, r = gb\/gc;\n-     p = s * (2.0L*m*z*(z-r) - (b - a)*(r - 1.0L));\n-     q = (z - 1.0L) * (r - 1.0L) * (s - 1.0L);\n-   }\n-   if (p > 0.0L) { q = -q; } else { p = -p; }\n-   s = e; e = d;\n-   if ((2.0L*p < 3.0L*m*q - absl(tol*q)) && (p < absl(0.5L*s*q))) {\n-     d = p\/q;\n-   } else {\n-     d = e = m;\n-   }\n-      }\n-      a = b; ga = gb;\n-      b = b + (absl(d) > tol ? d : (m > 0.0L ? tol : -tol));\n-      gb = g(b, f, p1, p2);\n-      if ((gb > 0.0L) == (gc > 0.0L)) break;  \/\/ That is, goto \"int:\"\n-      \/\/ Otherwise, goto \"ext:\"\n-    }\n-  }\n-}\n-\n-\/\/ This routine accepts a discrete probability mass function P (represented as an array),\n-\/\/ a second array A, and an integer N that indicates their common length.\n-\/\/ It computes two outputs: a table of probability thresholds (returned in P) and\n-\/\/ a table of forwarding indices (returned in A).\n-\/\/ These tables are suitable for use with Walker's alias algorithm for sampling from\n-\/\/ the originally specified discrete probability mass function.\n-\/\/ For the original description of Walker's alias method, see:\n-\/\/    Alastair J. Walker.  1977.  An efficient method for generating discrete random\n-\/\/    variables with general distributions. ACM Trans. Math. Software 3, 3\n-\/\/    (September 1977), 253-256. DOI: https:\/\/doi.org\/10.1145\/355744.355749\n-\/\/ However, his original version of the routine for building the tables runs in O(N**2) time.\n-\/\/ Following McFarland, we use a variant technique that is O(N), as described by Smith:\n-\/\/    Warren D. Smith.  2002.  How to sample from a probability distribution.\n-\/\/    Unpublished.  http:\/\/scorevoting.net\/WarrenSmithPages\/homepage\/sampling.ps\n-\n-void build_sampler(long double *P, int *A, int N) {\n-  long double *X = malloc((N+1)*sizeof(long double));\n-  int *B = malloc((N+1)*sizeof(int));\n-  \/\/ First step: normalize the given probability distribution and scale by N.\n-  long double sum = 0.0L;\n-  for (int k = 0; k < N; k++) sum += P[k];\n-  for (int k = 0; k < N; k++) P[k] = (P[k] \/ sum) * N;\n-  \/\/ Copy P into X, and add a sentinel value.\n-  for (int k = 0; k < N; k++) X[k] = P[k];\n-  X[N] = 2.0L;  \/\/ sentinel value\n-  \/\/ A will become the table of forwarding indices.\n-  \/\/ B will eventually describe a permutation on X such that every element less than 1.0\n-  \/\/ has a lower index than any element that is not less than 1.0.\n-  \/\/ Initally each is the identity map (element k contains the value k).\n-  for (int k = 0; k < N; k++) A[k] = k;\n-  for (int k = 0; k < N+1; k++) B[k] = k;\n-  \/\/ This next step is reminiscent of a Quicksort partition: i and j are two fingers\n-  \/\/ moving toward each other from opposite ends of X, and when i lands on an element\n-  \/\/ not less than 1.0 and j lands on an element less than 1.0, they are _logically_\n-  \/\/ swapped, not by updating X, but by updating the permutation in B.\n-  int i = 0;\n-  int j = N;\n-  for (;;) {\n-    while (X[B[i]] < 1.0L) i += 1;\n-    while (X[B[j]] >= 1.0L) j -= 1;\n-    if (i >= j) break;\n-    int temp = B[i]; B[i] = B[j]; B[j] = temp;\n-  }\n-  i = j;\n-  j += 1;\n-  \/\/ At this point, X[B[k]] < 1.0L for all k <= i, and X[B[k]] >= 1.0L for all k >= j == i+1.\n-  \/\/ This invariant will be maintained by the next loop, which moves i back out to the left\n-  \/\/ and j back out to the right.\n-  while (i >= 0) {\n-    while (X[B[j]] <= 1.0L) j += 1;\n-    if (j >= N) break;\n-    \/\/ At this point, X[B[i]] is \"overfunded\" and X[B[j]] is \"underfunded\".\n-    \/\/ During the sampling process, if the randomly chosen value in [0,1) is not\n-    \/\/ less than X[B[i]], it will be construed as a choice of B[j] rather than of j.\n-    \/\/ This is indicated by storing B[j] in A[B[i]].  In addition, X[B[j]] is updated\n-    \/\/ to reflect that fact that X[B[i]] has \"funded\" 1-X[B[i]] of its desired\n-    \/\/ probability mass.\n-    A[B[i]] = B[j];\n-    X[B[j]] -= (1.0L - X[B[i]]);\n-    \/\/ It may be that the \"generosity\" of X[B[i]] has caused X[B[j]] to become overfunded.\n-    \/\/ In that case, the two can be swapped (and j is incremented so that the former X[B[i]],\n-    \/\/ now become X[B[j]], will not be further examined).  Otherwise, i is decremented.\n-    \/\/ In either case, i will then indicate a new overfunded slot to be considered.\n-    if (X[B[j]] < 1.0L) {\n-      int temp = B[i]; B[i] = B[j]; B[j] = temp;\n-      j += 1;\n-    } else {\n-      i -= 1;\n-    }\n-  }\n-  \/\/ All done!  Now a sanity check.\n-  long double *Q = malloc(N*sizeof(long double));\n-  for (int k = 0; k < N; k++) Q[k] = X[k];\n-  for (int k = 0; k < N; k++) Q[A[k]] += (1.0L - X[k]);\n-  for (int k = 0; k < N; k++) check_equal(Q[k], P[k]);\n-  \/\/ Copy the result table in X back out into the argument P.\n-  for (int k = 0; k < N; k++) P[k] = X[k];\n-  free(Q); free(B); free(X);\n-}\n-\n-\/\/ The function that describes the exponential distribution with mean 1.\n-\/\/ See https:\/\/en.wikipedia.org\/wiki\/Exponential_distribution\n-long double exponential_f(long double x) {\n-  return expl(-x);\n-}\n-\n-\/\/ The cumulative distribution function for the exponential distribution with mean 1.\n-long double exponential_cdf(long double x) {\n-  return 1.0L - expl(-x);\n-}\n-\n-\/\/ The function that describes the normal distribution with mean 0 and standard deviation 1, scaled by sqrtl(0.5L*PI).\n-\/\/ See https:\/\/en.wikipedia.org\/wiki\/Normal_distribution\n-long double normal_f(long double x) {\n-  return expl(-0.5L*x*x);\n-}\n-\n-\/\/ The cumulative distribution function for the (right half of the) normal distribution with mean 0 and standard deviation 1.\n-long double normal_cdf(long double x) {\n-  return sqrtl(0.5L*PI) * erfl(sqrtl(0.5L)*x);\n-}\n-\n-\/\/ A function that will be zero at an x such that the new box will have area box_area.\n-long double box_g(long double x, longdoublefn f, long double last_Y_i, long double box_area) {\n-  return x*(f(x) - last_Y_i) - box_area;\n-}\n-\n-\/\/ A function that will be zero at an x such that, if f is normal_f, the tangent at point (x, f(x)) has slope m.\n-long double normal_tangent_g(long double x, longdoublefn f, long double m, long double unused) {\n-  return x*f(x) - m;\n-}\n-\n-\/\/ This routine generates all the parameters and tables for one kind of sampler.\n-void generate_tables(char *kind) {\n-  \/\/ kind may be \"normal\" or \"exponential\"\n-  assert(!strcmp(kind, \"exponential\") || !strcmp(kind, \"normal\"));\n-\n-  \/\/ SIZE must be a power of 2 (the code for Walker's alias method depends on it)\n-  assert((SIZE & -SIZE) == SIZE);\n-  \/\/ We require that SIZE <= 2048 because one place in the algorithm uses the\n-  \/\/ high 53 bits of a randomly chosen 64-bit integer to make a floating-point\n-  \/\/ (double) value after having already used the low bits to choose an integer\n-  \/\/ in the range [0,SIZE), and it is important that these two values be independent.\n-  \/\/ One consequence is that a value less than SIZE will certainly fit in a short\n-  \/\/ (and we will use a byte instead if SIZE <= 256).\n-  assert(SIZE <= 2048);\n-\n-  \/\/ A number of parameters need to be declared and then filled in according to the kind.\n-  \/\/ The total area under the probability curve for x >= 0:\n-  long double total_area_under_curve;\n-  \/\/ The function for the probability curve and also its cumulative distribution function:\n-  longdoublefn f, cdf;\n-  \/\/ Heuristic initial bounds for using the solver to calculate the X values:\n-  long double initial_lower_bound, initial_upper_bound;\n-  if (!strcmp(kind, \"exponential\")) {\n-    printf(\"    \/\/ Implementation support for modified-ziggurat implementation of nextExponential()\\n\\n\");\n-    total_area_under_curve = 1.0L;\n-    f = exponential_f; cdf = exponential_cdf;\n-    initial_lower_bound = 1.0L; initial_upper_bound = 10.0L;\n-  } else if (!strcmp(kind, \"normal\")) {\n-    printf(\"    \/\/ Implementation support for modified-ziggurat implementation of nextGaussian()\\n\\n\");\n-    \/\/ The \"total area under curve\" is for x >= 0 only, so we divide sqrtl(2.0L*PI) by 2.\n-    total_area_under_curve = sqrtl(2.0L*PI)\/2.0L;\n-    f = normal_f; cdf = normal_cdf;\n-    initial_lower_bound = 1.0L; initial_upper_bound = 4.0L;\n-  }\n-  \/\/ Make sure the claimed area under the curve is correct\n-  \/\/ (or think of it as a sanity check on the cdf).\n-  check_equal(total_area_under_curve, cdf(INFINITY) - cdf(0.0L));\n-\n-  \/\/ The first task is to compute the boxes of the modified ziggurat.\n-  \/\/ The X values are found by an iterative solving process; after that the Y values are easy.\n-  long double X[SIZE], Y[SIZE];\n-  long double box_area = total_area_under_curve \/ ((long double)SIZE);\n-  long double lower_bound = initial_lower_bound;\n-  long double upper_bound = initial_upper_bound;\n-  long double last_Y_i = 0.0L;\n-  int i = 0;\n-  while(lower_bound * f(0.0L) > box_area) {\n-    \/\/ There are two solutions for X_i (a tall-skinny box and a long-flat box).\n-    \/\/ We want the latter, so lower_bound is reduced gradually to avoid solving\n-    \/\/ for the tall-skinny box.  The two values of 0.9L are purely heuristic.\n-    X[i] = fsolve(box_g, f, last_Y_i, box_area, lower_bound, upper_bound);\n-    if (isnan(X[i])) {\n-      lower_bound *= 0.9L;\n-    } else {\n-      last_Y_i = f(X[i]);\n-      upper_bound = X[i];\n-      lower_bound = 0.9L*X[i];\n-      ++i;\n-    }\n-  }\n-  int number_of_layers = i;\n-  \/\/ One _could_ think of there being an extra layer at the top with a box of width 0.\n-  \/\/ However, to be consistent with McFarland's description, we will not call that a layer.\n-  \/\/ Also, what McFarland calls an \"overhanging box\", we will call a \"rectangle\";\n-  \/\/ each rectangle contains part of the curve, and the rest of the curve is above the tail.\n-  \/\/ So there are number_of_layers boxes, numbered from 0 through (number_of_layers - 1);\n-  \/\/ number_of_layers rectangles (one of which, the topmost, has no box to its left),\n-  \/\/ numbered from 1 through number_of_layers; and a tail (which is to the right of box 0).\n-  \/\/ For 1 <= k < number_of_layers, rectangle i is to the right of box i.\n-  X[i] = 0.0L;\n-  \/\/ We have all the X values; nocompute the corresponding Y values.\n-  for (int k = 0; k < number_of_layers + 1; k++) Y[k] = f(X[k]);\n-  \/\/ Now we have (number_of_layers + 1) X values and (number_of_layers + 1) Y values.\n-  \/\/ For each i, 0 <= i <= number_of_layers, the point (X[i], Y[i]) lies on the curve.\n-\n-  \/\/ The next step is to compute the differences dX and dY.\n-  long double dX[SIZE], dY[SIZE];\n-  \/\/ Note that dX is calculated one way and dY the other way;\n-  \/\/ that way all the difference values are positive.\n-  for (int k = 0; k < number_of_layers; k++) dX[k] = X[k] - X[k+1];\n-  for (int k = 0; k < number_of_layers; k++) dY[k] = Y[k+1] - Y[k];\n-  \/\/ Sanity check to ensure all the boxes have the correct area\n-  check_equal(X[0]*Y[0], box_area);\n-  for (int k = 0; k < number_of_layers - 1; k++) check_equal(X[k+1]*dY[k], box_area);\n-  \/\/ Now we can say that box i (0 <= i <= (number_of_layers - 1)) has width X[i] and height dY[i],\n-  \/\/ and rectangle i (1 <= i <= number_of_layers) has width dX[i-1] and height dY[i-1].\n-\n-  \/\/ The next step is to construct a discrete probability distribution V\n-  \/\/ that encompasses the tail and all the overhang areas (in the rectangles).\n-  long double V[SIZE];\n-  V[0] = cdf(INFINITY) - cdf(X[0]);\n-  for (int k = 0; k < number_of_layers; k++) {\n-    V[k+1] = (cdf(X[k]) - cdf(X[k+1])) - Y[k]*dX[k];\n-  }\n-  for (int k = number_of_layers + 1; k < SIZE; k++) V[k] = 0.0L;\n-  \/\/ Now V[0] is the area of the tail, and V[i] (1 <= i <= number_of_layers)\n-  \/\/ is the area within rectangle i that lies under the curve.\n-  \/\/ Remaining entries are zero.  (The only reason for this zero padding\n-  \/\/ is to make the length of V be a power of 2, which allows generation\n-  \/\/ of a randomly chosen index into V to be faster, using a masking operation\n-  \/\/ rather than a modulus operator.)\n-\n-  \/\/ Sanity check that all area under the curve is accounted for.\n-  long double V_sum = 0.0L;\n-  for (int k = 0; k < number_of_layers + 1; k++) V_sum += V[k];\n-  check_equal((double long)(SIZE - number_of_layers), V_sum\/box_area);\n-  \/\/ Report some interesting statistics.\n-  printf(\"    \/\/ Fraction of the area under the curve that lies outside the layer boxes: %.4f\\n\", (double)(SIZE - number_of_layers)\/(double)SIZE);\n-  printf(\"    \/\/ Fraction of non-box area that lies in the tail of the distribution: %.4f\\n\", (double)(V[0]\/V_sum));\n-  printf(\"\\n\");\n-\n-  \/\/ Use V to construct tables called \"alias_threshold\" and \"alias_map\" for use with\n-  \/\/ Walker's alias method for sampling a discrete distribution efficiently.\n-  long double alias_threshold[SIZE];\n-  int alias_map[SIZE];\n-  \/\/ Routine build_sampler normalizes V and then turns it into thresholds,\n-  \/\/ and also constructs the alias_map table.\n-  build_sampler(V, alias_map, SIZE);\n-  \/\/ Now produce the alias_threshold table from V by scaling it and converting to integer values.\n-  \/\/ This is a trick that allows direct comparison with randomly chosen integer values,\n-  \/\/ rather than requiring generation of a randomly chosen floating-point value.\n-  for (int k = 0; k < SIZE; k++) {\n-    if (V[k] >= 1.0L) {\n-      \/\/ This \"shouldn't happen\", but rounding errors are possible, so we defend against it\n-      alias_threshold[k] = max_int;\n-    } else {\n-      alias_threshold[k] = (int_type)(V[k] * max_uint - max_int);\n-    }\n-  }\n-\n-  \/\/ Here each m[k] is computed as a positive value, which is therefore the negative of the\n-  \/\/ true slope of the diagonal line (within rectangle k+1) whose endpoints lie on the curve.\n-  long double m[SIZE];\n-  for (int k = 0; k < number_of_layers; k++) m[k] = dY[k]\/dX[k];\n-\n-  \/\/ Now it is time to compute and output all the parameters.\n-  \/\/ It is really important that each parameter be declared \"final\"; it allows\n-  \/\/ a huge speed improvement because the Java compiler can then inline the constants.\n-  printf(\"    static final int %sNumberOfLayers = %d;\\n\", kind, number_of_layers);\n-  printf(\"    static final int %sLayerMask = 0x%x;\\n\", kind, SIZE-1);\n-  printf(\"    static final int %sAliasMask = 0x%x;\\n\", kind, SIZE-1);\n-  printf(\"    static final int %sSignCorrectionMask = 0x%x;\\n\", kind, (SIZE == 256) ? 0xff : 0xffffffff);\n-  printf(\"    static final %s %sX0 = %19.17f;\\n\", java_float_type, kind, (double)(float_type)X[0]);\n-  if (!strcmp(kind, \"exponential\")) {\n-    \/\/ Within each rectangle, we want to find a point on the curve where the tangent\n-    \/\/ is parallel to the diagonal line of the rectangle whose slope is m.\n-\n-    \/\/ The first derivative of the exponential function exp(-x) is -exp(-x), whose value\n-    \/\/ at X[k] is -exp(-X[k]) which is -Y[k].  So we can compare m values and Y values directly.\n-    \/\/ Sanity check: we expect Y[k+1] > m > Y[k].\n-    for (int k = 0; k < number_of_layers; k++) {\n-      assert(m[k] > Y[k]);\n-      assert(Y[k+1] > m[k]);\n-    }\n-    \/\/ Now for some math.  Within rectangle k+1, the point on the curve where the\n-    \/\/ tangent is parallel to that diagonal must have coordinates (-log(m[k]), m[k]).\n-    \/\/ The point on the diagonal directly above it (with the same x-coordinate) is\n-    \/\/ (-log(m[k]), Y[k+1]-m[k]*(-log(m[k])-X[k+1])).  The vertical distance between\n-    \/\/ them is therefore Y[k+1] - m[k]*(-log(m[k])-X[k+1]) - m[k].  We can then divide\n-    \/\/ this by dY[k] to normalize it to a fraction of the height of the rectangle.\n-    \/\/ We could have a table of all these fractions, so that we would have just the\n-    \/\/ right fraction for use with each rectangle; but it saves space (and loses very\n-    \/\/ little time) to just compute the maximum such fraction over all rectangles,\n-    \/\/ and then use that maximum fraction whenever processing any rectangle.\n-    long double convex_margin = -INFINITY;\n-    for (int k = 0; k < number_of_layers; k++) {\n-      long double X_tangent = -logl(m[k]);\n-      long double E = (Y[k+1] - m[k]*(X_tangent - X[k+1]) - m[k]) \/ dY[k];\n-      convex_margin = (convex_margin > E) ? convex_margin : E;\n-    }\n-    int_type scaled_convex_margin = (int_type)(convex_margin * (long double)max_int);\n-    printf(\"    static final %s %sConvexMargin = %lldL;   \/\/ unscaled convex margin = %.4f\\n\",\n-      java_int_type, kind, (long long)scaled_convex_margin, (double)convex_margin);\n-  } else if (!strcmp(kind, \"normal\")) {\n-    \/\/ Within each rectangle, we want to find a point on the curve where the tangent\n-    \/\/ is parallel to the diagonal line of the rectangle whose slope is m.\n-\n-    long double inflection_point_x = 1.0L;\n-    int normal_inflection_index = 0;\n-    for (int k = 0; k < number_of_layers + 1; k++) {\n-      if (X[k] > inflection_point_x) ++normal_inflection_index;\n-    }\n-    \/\/ The inflection point lies within rectangle normal_inflection_index.\n-    \/\/ The x-coordinate of the inflection point lies between\n-    \/\/ X[normal_inflection_index] and X[normal_inflection_index - 1].\n-\n-    \/\/ In principle we could have trouble if the inflection point lies exactly\n-    \/\/ on corner of a box (but it doesn't happen in practice).\n-    assert(X[normal_inflection_index] < inflection_point_x);\n-    printf(\"    static final int normalInflectionIndex = %d;\\n\", normal_inflection_index);\n-\n-    \/\/ Now for some math.  The first derivative of the normal curve function exp(-x*x\/2)\n-    \/\/ at X[k] is -X[k]*exp(-X[k]*X[k]\/2) which is -X[k]*f(X[k]).  We use the function\n-    \/\/ normal_tangent_g with the solver to find the x-coordinate of a point on the\n-    \/\/ curve within rectangle k+1 where the tangent has slope m[k].  The rectangle that\n-    \/\/ contains the inflection point will have two such points, so that rectangle gets\n-    \/\/ special processing.\n-    \/\/ For each such tangent point, the idea is to compute the vertical distance between\n-    \/\/ that point and the diagonal, then divide by the height of the rectangle to normalize.\n-    \/\/ We could have a table of all these fractions, so that we would have just the\n-    \/\/ right fraction(s) for use with each rectangle; but it saves space (and loses very\n-    \/\/ little time) to just compute the maximum such fraction over a set of rectangles,\n-    \/\/ and then conservatively use that maximum fraction whenever processing any rectangle.\n-    \/\/ Instead of taking the maximum fraction over all rectangles (as we do for the\n-    \/\/ exponential function) we compute two separate maxima: one over all tangent points\n-    \/\/ below the diagonal (where the curve is convex) and one over all tangent points\n-    \/\/ above the diagonal (where the curve is concave).  Note that the rectangle containing\n-    \/\/ the inflection point has one of each.\n-    long double convex_margin = -INFINITY, concave_margin = -INFINITY;\n-    for (int k = 0; k < number_of_layers; k++) {\n-      \/\/ Process rectangle k+1\n-      if ((k+1) <= normal_inflection_index) {\n-   \/\/ The rectangle has a convex portion of the curve\n-   long double lower_bound = ((k+1) == normal_inflection_index) ? inflection_point_x : X[k+1];\n-   long double X_tangent = fsolve(normal_tangent_g, f, m[k], 0.0, lower_bound, X[k]);\n-   long double E = (Y[k+1] - m[k]*(X_tangent - X[k+1]) - f(X_tangent)) \/ dY[k];\n-       convex_margin = (convex_margin > E) ? convex_margin : E;\n-      }\n-      if ((k+1) >= normal_inflection_index) {\n-   \/\/ The rectangle has a concave portion of the curve\n-   long double upper_bound = ((k+1) == normal_inflection_index) ? inflection_point_x : X[k];\n-   long double X_tangent = fsolve(normal_tangent_g, f, m[k], 0.0, X[k+1], upper_bound);\n-   long double E = - (Y[k+1] - m[k]*(X_tangent - X[k+1]) - f(X_tangent)) \/ dY[k];\n-       concave_margin = (concave_margin > E) ? concave_margin : E;\n-      }\n-    }\n-    int_type scaled_convex_margin = (int_type)(convex_margin * (long double)max_int);\n-    int_type scaled_concave_margin = (int_type)(concave_margin * (long double)max_int);\n-    printf(\"    static final %s %sConvexMargin = %lldL;   \/\/ unscaled convex margin = %.4f\\n\",\n-      java_int_type, kind, (long long)scaled_convex_margin, (double)convex_margin);\n-    printf(\"    static final %s %sConcaveMargin = %lldL;   \/\/ unscaled concave margin = %.4f\\n\",\n-      java_int_type, kind, (long long)scaled_concave_margin, (double)concave_margin);\n-  }\n-  printf(\"\\n\");\n-\n-  \/\/ Output the X array\n-  printf(\"    \/\/ %s_X[i] = length of ziggurat layer i for %s distribution, scaled by 2**(-%d)\\n\", kind, kind, int_bits-1);\n-  printf(\"    static final %s[] %sX = {      \/\/ %d entries, which is %s_number_of_layers+1\\n\", java_float_type, kind, number_of_layers+1, kind);\n-  for (int k = 0; k < number_of_layers+1; k++) {\n-    if ((k & 0x3) == 0) printf(\"        \");\n-    printf(\"%23.16e\", (float_type)X[k] \/ (float_type)max_int);\n-    if (k < number_of_layers) {\n-      printf(\",\");\n-      if ((k & 0x3) < 3) printf(\" \");\n-      else printf(\"\\n\");\n-    } else {\n-      printf(\" };\\n\");\n-    }\n-  }\n-  printf(\"\\n\");\n-\n-  \/\/ Output the Y array\n-  printf(\"    \/\/ %s_Y[i] = value of the %s distribution function at %s_X[i], scaled by 2**(-%d)\\n\", kind, kind, kind, int_bits-1);\n-  printf(\"    static final %s[] %sY = {      \/\/ %d entries, which is %s_number_of_layers+1\\n\", java_float_type, kind, number_of_layers+1, kind);\n-  for (int k = 0; k < number_of_layers+1; k++) {\n-    if ((k & 0x3) == 0) printf(\"        \");\n-    printf(\"%23.16e\", (float_type)Y[k] \/ (float_type)max_int);\n-    if (k < number_of_layers) {\n-      printf(\",\");\n-      if ((k & 0x3) < 3) printf(\" \");\n-      else printf(\"\\n\");\n-    } else {\n-      printf(\" };\\n\");\n-    }\n-  }\n-  printf(\"\\n\");\n-\n-  \/\/ Output the alias_threshold array\n-  printf(\"    \/\/ alias_threshold[j] is a threshold for the probability mass function that has been\\n\");\n-  printf(\"    \/\/ scaled by (2**%d - 1), translated by -(2**%d), and represented as a %s value;\\n\", int_bits, int_bits-1, java_int_type);\n-  printf(\"    \/\/ in this way it can be directly compared to a randomly chosen %s value.\\n\", java_int_type);\n-  printf(\"    static final long[] %sAliasThreshold = {    \/\/ %d entries\\n\", kind, SIZE);\n-  for (int k = 0; k < SIZE; k++) {\n-    if ((k & 0x3) == 0) printf(\"        \");\n-    printf(\"%20lldL\", (long long)alias_threshold[k]);\n-    if (k < (SIZE - 1)) {\n-      printf(\",\");\n-      if ((k & 0x3) < 3) printf(\" \");\n-      else printf(\"\\n\");\n-    } else {\n-      printf(\" };\\n\");\n-    }\n-  }\n-  printf(\"\\n\");\n-\n-  \/\/ Output the alias_map array\n-  char *small_int_type = (SIZE <= 256) ? \"byte\" : \"short\";\n-  int map_items_per_line = (SIZE == 256) ? 8 : 16;\n-  printf(\"    static final %s[] %sAliasMap = {    \/\/ %d entries\\n\", small_int_type, kind, SIZE);\n-  for (int k = 0; k < SIZE; k++) {\n-    if ((k % map_items_per_line) == 0) printf(\"        \");\n-    if (SIZE == 256) printf(\"(byte)\");\n-    printf(\"%3d\", alias_map[k]);\n-    if (k < (SIZE - 1)) {\n-      printf(\",\");\n-      if ((k % map_items_per_line) < (map_items_per_line - 1)) printf(\" \");\n-      else printf(\"\\n\");\n-    } else {\n-      printf(\" };\\n\");\n-    }\n-  }\n-  printf(\"\\n\");\n-}\n-\n-int main(int argc, char *argv[]) {\n-  printf(\"\/\/ This Java source file is generated automatically by the program `create_ziggurat_tables.c`.\\n\");\n-  printf(\"\\n\");\n-  printf(\"\/*\\n\");\n-  printf(\" * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\\n\");\n-  printf(\" * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\\n\");\n-  printf(\" *\\n\");\n-  printf(\" * This code is free software; you can redistribute it and\/or modify it\\n\");\n-  printf(\" * under the terms of the GNU General Public License version 2 only, as\\n\");\n-  printf(\" * published by the Free Software Foundation.  Oracle designates this\\n\");\n-  printf(\" * particular file as subject to the \\\"Classpath\\\" exception as provided\\n\");\n-  printf(\" * by Oracle in the LICENSE file that accompanied this code.\\n\");\n-  printf(\" *\\n\");\n-  printf(\" * This code is distributed in the hope that it will be useful, but WITHOUT\\n\");\n-  printf(\" * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n\");\n-  printf(\" * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\\n\");\n-  printf(\" * version 2 for more details (a copy is included in the LICENSE file that\\n\");\n-  printf(\" * accompanied this code).\\n\");\n-  printf(\" *\\n\");\n-  printf(\" * You should have received a copy of the GNU General Public License version\\n\");\n-  printf(\" * 2 along with this work; if not, write to the Free Software Foundation,\\n\");\n-  printf(\" * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\\n\");\n-  printf(\" *\\n\");\n-  printf(\" * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\\n\");\n-  printf(\" * or visit www.oracle.com if you need additional information or have any\\n\");\n-  printf(\" * questions.\\n\");\n-  printf(\" *\/\\n\");\n-  printf(\"package java.util;\\n\");\n-  printf(\"\\n\");\n-  printf(\"class %sZigguratTables {\\n\", java_capitalized_float_type);\n-  printf(\"\\n\");\n-  generate_tables(\"exponential\");\n-  generate_tables(\"normal\");\n-  printf(\"}\\n\");\n-}\n","filename":"src\/java.base\/share\/native\/random\/create_ziggurat_tables.c","additions":0,"deletions":688,"binary":false,"changes":688,"status":"deleted"}]}