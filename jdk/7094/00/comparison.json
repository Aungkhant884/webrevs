{"files":[{"patch":"@@ -1977,0 +1977,7 @@\n+void Assembler::cvtss2sil(Register dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = simd_prefix_and_encode(as_XMMRegister(dst->encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2D, (0xC0 | encode));\n+}\n+\n@@ -2070,0 +2077,15 @@\n+void Assembler::vcvtps2dq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx() : VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x5B, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtpd2qq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x7B, (0xC0 | encode));\n+}\n+\n@@ -12206,0 +12228,7 @@\n+void Assembler::cvtsd2siq(Register dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = simd_prefix_and_encode(as_XMMRegister(dst->encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2D, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1159,0 +1159,1 @@\n+  void cvtsd2siq(Register dst, XMMRegister src);\n@@ -1163,0 +1164,1 @@\n+  void cvtss2sil(Register dst, XMMRegister src);\n@@ -1173,0 +1175,1 @@\n+  void vcvtps2dq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1180,0 +1183,1 @@\n+  void evcvtpd2qq(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4086,1 +4086,1 @@\n-                                            Register scratch, int vec_enc) {\n+                                            Register scratch, int vec_enc, bool roundD) {\n@@ -4088,1 +4088,5 @@\n-  evcvttpd2qq(dst, src, vec_enc);\n+  if (roundD) {\n+    evcvtpd2qq(dst, src, vec_enc);\n+  } else {\n+    evcvttpd2qq(dst, src, vec_enc);\n+  }\n@@ -4107,1 +4111,2 @@\n-                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc) {\n+                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc,\n+                                           bool roundF) {\n@@ -4109,1 +4114,5 @@\n-  vcvttps2dq(dst, src, vec_enc);\n+  if (roundF) {\n+    vcvtps2dq(dst, src, vec_enc);\n+  } else {\n+    vcvttps2dq(dst, src, vec_enc);\n+  }\n@@ -4136,1 +4145,1 @@\n-                                            Register scratch, int vec_enc) {\n+                                            Register scratch, int vec_enc, bool roundF) {\n@@ -4138,1 +4147,5 @@\n-  vcvttps2dq(dst, src, vec_enc);\n+  if (roundF) {\n+    vcvtps2dq(dst, src, vec_enc);\n+  } else {\n+    vcvttps2dq(dst, src, vec_enc);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-                          AddressLiteral float_sign_flip, Register scratch, int vec_enc);\n+                          AddressLiteral float_sign_flip, Register scratch, int vec_enc, bool roundF);\n@@ -309,1 +309,1 @@\n-                           Register scratch, int vec_enc);\n+                           Register scratch, int vec_enc, bool roundF);\n@@ -313,1 +313,1 @@\n-                           Register scratch, int vec_enc);\n+                           Register scratch, int vec_enc, bool roundD);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -8887,1 +8887,1 @@\n-void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {\n+void MacroAssembler::convert_f2i(Register dst, XMMRegister src, bool roundF) {\n@@ -8889,1 +8889,5 @@\n-  cvttss2sil(dst, src);\n+  if (roundF) {\n+    cvtss2sil(dst, src);\n+  } else {\n+    cvttss2sil(dst, src);\n+  }\n@@ -8925,1 +8929,1 @@\n-void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {\n+void MacroAssembler::convert_d2l(Register dst, XMMRegister src, bool roundD) {\n@@ -8927,1 +8931,5 @@\n-  cvttsd2siq(dst, src);\n+  if (roundD) {\n+    cvtsd2siq(dst, src);\n+  } else {\n+    cvttsd2siq(dst, src);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1961,1 +1961,1 @@\n-  void convert_f2i(Register dst, XMMRegister src);\n+  void convert_f2i(Register dst, XMMRegister src, bool roundF = false);\n@@ -1964,1 +1964,1 @@\n-  void convert_d2l(Register dst, XMMRegister src);\n+  void convert_d2l(Register dst, XMMRegister src, bool roundD = false);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1453,0 +1453,2 @@\n+    case Op_RoundVF:\n+    case Op_RoundVD:\n@@ -1568,0 +1570,6 @@\n+    case Op_RoundF:\n+    case Op_RoundD:\n+      if (!is_LP64) {\n+        return false;\n+      }\n+      break;\n@@ -1808,0 +1816,5 @@\n+    case Op_RoundVD:\n+      if (!VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n@@ -7197,1 +7210,2 @@\n-instruct vcastFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+\n+instruct vround_or_castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n@@ -7202,0 +7216,1 @@\n+  match(Set dst (RoundVF src));\n@@ -7203,1 +7218,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  format %{ \"vector_round_or_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n@@ -7205,0 +7220,1 @@\n+    bool is_rounding = this->ideal_Opcode() == Op_RoundVF ? true : false;\n@@ -7208,1 +7224,1 @@\n-                          ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+                          ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc, is_rounding);\n@@ -7213,1 +7229,1 @@\n-instruct vcastFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct vround_or_castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n@@ -7218,0 +7234,1 @@\n+  match(Set dst (RoundVF src));\n@@ -7219,1 +7236,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  format %{ \"vector_round_or_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7221,0 +7238,1 @@\n+    bool is_rounding = this->ideal_Opcode() == Op_RoundVF ? true : false;\n@@ -7224,1 +7242,1 @@\n-                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc, is_rounding);\n@@ -7240,1 +7258,1 @@\n-instruct vcastDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct vround_or_castDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n@@ -7243,0 +7261,1 @@\n+  match(Set dst (RoundVD src));\n@@ -7244,1 +7263,1 @@\n-  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  format %{ \"vector_round_or_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7246,0 +7265,1 @@\n+    bool is_rounding = this->ideal_Opcode() == Op_RoundVD ? true : false;\n@@ -7249,1 +7269,1 @@\n-                           ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+                           ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc, is_rounding);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -10662,1 +10662,1 @@\n-instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)\n+instruct round_or_convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)\n@@ -10665,0 +10665,1 @@\n+  match(Set dst (RoundF src));\n@@ -10666,1 +10667,1 @@\n-  format %{ \"convert_f2i $dst,$src\" %}\n+  format %{ \"round_or_convert_f2i $dst,$src\" %}\n@@ -10668,1 +10669,2 @@\n-    __ convert_f2i($dst$$Register, $src$$XMMRegister);\n+  bool is_rounding = this->ideal_Opcode() == Op_RoundF ? true : false;\n+    __ convert_f2i($dst$$Register, $src$$XMMRegister, is_rounding);\n@@ -10695,1 +10697,1 @@\n-instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)\n+instruct round_or_convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)\n@@ -10698,0 +10700,1 @@\n+  match(Set dst (RoundD src));\n@@ -10699,1 +10702,1 @@\n-  format %{ \"convert_d2l $dst,$src\"%}\n+  format %{ \"round_or_convert_d2l $dst,$src\"%}\n@@ -10701,1 +10704,2 @@\n-    __ convert_d2l($dst$$Register, $src$$XMMRegister);\n+  bool is_rounding = this->ideal_Opcode() == Op_RoundD ? true : false;\n+    __ convert_d2l($dst$$Register, $src$$XMMRegister, is_rounding);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4241,0 +4241,1 @@\n+    \"RoundVF\", \"RoundVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,1 @@\n+  do_name(round_name, \"round\")                                                                                          \\\n@@ -188,0 +189,2 @@\n+  do_intrinsic(_roundD,                   java_lang_Math,         round_name,         double_long_signature,     F_S)   \\\n+  do_intrinsic(_roundF,                   java_lang_Math,         round_name,         float_int_signature,       F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -526,0 +526,2 @@\n+  case vmIntrinsics::_roundD:\n+  case vmIntrinsics::_roundF:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,0 +314,2 @@\n+macro(RoundF)\n+macro(RoundD)\n@@ -482,0 +484,2 @@\n+macro(RoundVF)\n+macro(RoundVD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,8 @@\n+class RoundDNode : public Node {\n+  public:\n+  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -108,0 +116,1 @@\n+\n@@ -144,0 +153,8 @@\n+class RoundFNode : public Node {\n+  public:\n+  RoundFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,0 +272,2 @@\n+  case vmIntrinsics::_roundF:\n+  case vmIntrinsics::_roundD:\n@@ -1609,0 +1611,1 @@\n+\/\/ public static double Math.round(double)\n@@ -1620,0 +1623,1 @@\n+  case vmIntrinsics::_roundD: n = new RoundDNode(arg); break;\n@@ -1641,0 +1645,1 @@\n+  case vmIntrinsics::_roundF: n = new RoundFNode(arg); break;\n@@ -1756,0 +1761,1 @@\n+  case vmIntrinsics::_roundD: return Matcher::match_rule_supported(Op_RoundD) ? inline_double_math(id) : false;\n@@ -1759,0 +1765,1 @@\n+\n@@ -1778,0 +1785,1 @@\n+  case vmIntrinsics::_roundF: return Matcher::match_rule_supported(Op_RoundF) ? inline_math(id) : false;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2556,0 +2556,1 @@\n+                 opc == Op_RoundF || opc == Op_RoundD ||\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  case Op_RoundF:\n+    return (bt == T_INT ? Op_RoundVF : 0);\n+  case Op_RoundD:\n+    return (bt == T_LONG ? Op_RoundVD : 0);\n@@ -545,0 +549,3 @@\n+  case Op_RoundVF: return new RoundVFNode(n1, vt);\n+  case Op_RoundVD: return new RoundVDNode(n1, vt);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1525,0 +1525,16 @@\n+class RoundVFNode : public VectorNode {\n+ public:\n+  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class RoundVDNode : public VectorNode {\n+ public:\n+  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -743,0 +743,1 @@\n+    @IntrinsicCandidate\n@@ -792,0 +793,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-      System.err.println(\"FAILED: \" + errn + \" errors\");\n-      System.exit(97);\n+        System.err.println(\"FAILED: \" + errn + \" errors\");\n+        System.exit(97);\n@@ -55,0 +55,2 @@\n+    long  [] l0 = new long[ARRLEN];\n+\n@@ -94,0 +96,1 @@\n+      test_round(l0, a1);\n@@ -358,0 +361,11 @@\n+      test_round(l0, a1);\n+      errn += verify(\"test_round: \", 0, l0[0], 0L);\n+      errn += verify(\"test_round: \", 1, l0[1], Long.MAX_VALUE);\n+      errn += verify(\"test_round: \", 2, l0[2], Long.MIN_VALUE);\n+      errn += verify(\"test_round: \", 3, l0[3], Long.MAX_VALUE);\n+      errn += verify(\"test_round: \", 4, l0[4], 0L);\n+      errn += verify(\"test_round: \", 5, l0[5], 0L);\n+      for (int i=6; i<ARRLEN; i++) {\n+        errn += verify(\"test_round: \", i, l0[i], Math.round((double)(ADD_INIT+i)));\n+      }\n+\n@@ -567,0 +581,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(l0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_round_n: \" + (end - start));\n@@ -694,0 +714,14 @@\n+  static void test_round(long[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  static int verify(String text, int i, long elem, long val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+      return 1;\n+    }\n+    return 0;\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVect.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    int[] i0 = new int[ARRLEN];\n@@ -91,0 +92,1 @@\n+      test_round(i0, a1);\n@@ -92,0 +94,1 @@\n+\n@@ -356,0 +359,11 @@\n+      test_round(i0, a1);\n+      errn += verify(\"test_round: \", 0, i0[0], 0);\n+      errn += verify(\"test_round: \", 1, i0[1], Integer.MAX_VALUE);\n+      errn += verify(\"test_round: \", 2, i0[2], Integer.MIN_VALUE);\n+      errn += verify(\"test_round: \", 3, i0[3], Integer.MAX_VALUE);\n+      errn += verify(\"test_round: \", 4, i0[4], 0);\n+      errn += verify(\"test_round: \", 5, i0[5], 0);\n+      for (int i=6; i<ARRLEN; i++) {\n+        errn += verify(\"test_round: \", i, i0[i], Math.round(((float)(ADD_INIT+i))));\n+      }\n+\n@@ -515,0 +529,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(i0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_round_n: \" + (end - start));\n@@ -612,0 +632,14 @@\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  static int verify(String text, int i, int elem, int val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+      return 1;\n+    }\n+    return 0;\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVect.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279508\n+ * @summary Auto-vectorize Math.round API\n+ * @requires vm.compiler2.enabled\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestRoundVect\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestRoundVect {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static double [] dinp;\n+  private static long   [] lout;\n+  private static float  [] finp;\n+  private static int    [] iout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                  \"-XX:UseAVX=3\",\n+                                  \"-XX:CompileThresholdScaling=0.3\");\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                  \"-XX:UseAVX=1\",\n+                                  \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"RoundVD\" , \" > 0 \"})\n+  public void test_round_double(long[] lout, double[] dinp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Math.round(dinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_double\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round_double() {\n+      dinp = new double[ARRLEN];\n+      lout = new long[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          dinp[i] = (double)i*1.4;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_double(lout , dinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(applyIf = {\"UseAVX\", \" > 0\"}, counts = {\"RoundVF\" , \" > 0 \"})\n+  public void test_round_float(int[] iout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          iout[i] = Math.round(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round() {\n+      finp = new float[ARRLEN];\n+      iout = new int[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          finp[i] = (float)i*1.4f;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_float(iout , finp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVect.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n@@ -35,1 +34,1 @@\n-  @Param({\"1024\"})\n+  @Param({\"1024\", \"2048\"})\n@@ -39,2 +38,3 @@\n-\n-  public double[] Res;\n+  public double[] ResD;\n+  public float[] FargV1;\n+  public float[] ResF;\n@@ -43,1 +43,10 @@\n-      0.0, -0.0, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY};\n+      0.0, -0.0, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+      Double.MAX_VALUE, -Double.MAX_VALUE, Double.MIN_VALUE, -Double.MIN_VALUE,\n+      Double.MIN_NORMAL\n+  };\n+\n+  public final float[] FspecialVals = {\n+      0.0f, -0.0f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,\n+      Float.MAX_VALUE, -Float.MAX_VALUE, Float.MIN_VALUE, -Float.MIN_VALUE,\n+      Float.MIN_NORMAL\n+  };\n@@ -47,12 +56,38 @@\n-    int i = 0;\n-    Random r = new Random(1024);\n-    DargV1 = new double[TESTSIZE];\n-    Res = new double[TESTSIZE];\n-\n-    for (; i < DspecialVals.length; i++) {\n-      DargV1[i] = DspecialVals[i];\n-    }\n-\n-    for (; i < TESTSIZE; i++) {\n-      DargV1[i] = r.nextDouble()*TESTSIZE;\n-    }\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      DargV1 = new double[TESTSIZE];\n+      ResD = new double[TESTSIZE];\n+\n+      for (; i < DspecialVals.length; i++) {\n+          DargV1[i] = DspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          DargV1[i] = r.nextDouble()*TESTSIZE;\n+      }\n+\n+      FargV1 = new float[TESTSIZE];\n+      ResF = new float[TESTSIZE];\n+\n+      for (; i < FspecialVals.length; i++) {\n+          FargV1[i] = FspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          FargV1[i] = r.nextFloat()*TESTSIZE;\n+      }\n+  }\n+\n+  @Benchmark\n+  public void test_ceil() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.ceil(DargV1[i]);\n+      }\n+  }\n+\n+  @Benchmark\n+  public void test_floor() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.floor(DargV1[i]);\n+      }\n@@ -62,3 +97,4 @@\n-  public void testceil(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.ceil(DargV1[i]);\n+  public void test_rint() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.rint(DargV1[i]);\n+      }\n@@ -68,3 +104,4 @@\n-  public void testfloor(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.floor(DargV1[i]);\n+  public void test_round_double() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.round(DargV1[i]);\n+      }\n@@ -74,3 +111,4 @@\n-  public void testrint(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.rint(DargV1[i]);\n+  public void test_round_float() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResF[i] = Math.round(FargV1[i]);\n+      }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/FpRoundingBenchmark.java","additions":65,"deletions":27,"binary":false,"changes":92,"status":"modified"}]}