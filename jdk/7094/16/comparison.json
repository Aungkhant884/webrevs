{"files":[{"patch":"@@ -1977,0 +1977,7 @@\n+void Assembler::cvtss2sil(Register dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = simd_prefix_and_encode(as_XMMRegister(dst->encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2D, (0xC0 | encode));\n+}\n+\n@@ -2070,0 +2077,15 @@\n+void Assembler::vcvtps2dq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx() : VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x5B, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtpd2qq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x7B, (0xC0 | encode));\n+}\n+\n@@ -6453,1 +6475,0 @@\n-\n@@ -12225,0 +12246,7 @@\n+void Assembler::cvtsd2siq(Register dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = simd_prefix_and_encode(as_XMMRegister(dst->encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2D, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1155,0 +1155,1 @@\n+  void cvtsd2siq(Register dst, XMMRegister src);\n@@ -1163,0 +1164,1 @@\n+  void cvtss2sil(Register dst, XMMRegister src);\n@@ -1172,0 +1174,1 @@\n+  void vcvtps2dq(XMMRegister dst, XMMRegister src, int vector_len);\n@@ -1179,0 +1182,1 @@\n+  void evcvtpd2qq(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4017,7 +4017,6 @@\n- * Algorithm for vector D2L and F2I conversions:-\n- * a) Perform vector D2L\/F2I cast.\n- * b) Choose fast path if none of the result vector lane contains 0x80000000 value.\n- *    It signifies that source value could be any of the special floating point\n- *    values(NaN,-Inf,Inf,Max,-Min).\n- * c) Set destination to zero if source is NaN value.\n- * d) Replace 0x80000000 with MaxInt if source lane contains a +ve value.\n+ * Following routine handles special floating point values(NaN\/Inf\/-Inf\/Max\/Min) for casting operation.\n+ * If src is NaN, the result is 0.\n+ * If the src is negative infinity or any value less than or equal to the value of Integer.MIN_VALUE,\n+ * the result is equal to the value of Integer.MIN_VALUE.\n+ * If the src is positive infinity or any value greater than or equal to the value of Integer.MAX_VALUE,\n+ * the result is equal to the value of Integer.MAX_VALUE.\n@@ -4025,25 +4024,4 @@\n-\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                            Register scratch, int vec_enc) {\n-  Label done;\n-  evcvttpd2qq(dst, src, vec_enc);\n-  evmovdqul(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n-  evpcmpeqq(ktmp1, xtmp1, dst, vec_enc);\n-  kortestwl(ktmp1, ktmp1);\n-  jccb(Assembler::equal, done);\n-\n-  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n-  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n-  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n-\n-  kxorwl(ktmp1, ktmp1, ktmp2);\n-  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n-  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n-  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n-  bind(done);\n-}\n-\n-void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                            XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                            Register scratch, AddressLiteral float_sign_flip,\n+                                                            int vec_enc) {\n@@ -4051,1 +4029,0 @@\n-  vcvttps2dq(dst, src, vec_enc);\n@@ -4076,3 +4053,4 @@\n-void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n-                                            Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                             Register scratch, AddressLiteral float_sign_flip,\n+                                                             int vec_enc) {\n@@ -4080,1 +4058,0 @@\n-  vcvttps2dq(dst, src, vec_enc);\n@@ -4097,0 +4074,112 @@\n+\/*\n+ * Following routine handles special floating point values(NaN\/Inf\/-Inf\/Max\/Min) for casting operation.\n+ * If src is NaN, the result is 0.\n+ * If the src is negative infinity or any value less than or equal to the value of Long.MIN_VALUE,\n+ * the result is equal to the value of Long.MIN_VALUE.\n+ * If the src is positive infinity or any value greater than or equal to the value of Long.MAX_VALUE,\n+ * the result is equal to the value of Long.MAX_VALUE.\n+ *\/\n+void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                              XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                              Register scratch, AddressLiteral double_sign_flip,\n+                                                              int vec_enc) {\n+  Label done;\n+  evmovdqul(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  evpcmpeqq(ktmp1, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n+\/*\n+ * Algorithm for vector D2L and F2I conversions:-\n+ * a) Perform vector D2L\/F2I cast.\n+ * b) Choose fast path if none of the result vector lane contains 0x80000000 value.\n+ *    It signifies that source value could be any of the special floating point\n+ *    values(NaN,-Inf,Inf,Max,-Min).\n+ * c) Set destination to zero if source is NaN value.\n+ * d) Replace 0x80000000 with MaxInt if source lane contains a +ve value.\n+ *\/\n+\n+void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  evcvttpd2qq(dst, src, vec_enc);\n+  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc) {\n+  vcvttps2dq(dst, src, vec_enc);\n+  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, scratch, float_sign_flip, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  vcvttps2dq(dst, src, vec_enc);\n+  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, float_sign_flip, vec_enc);\n+}\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::vector_round_double_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                 KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                                 AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+  \/\/ Perform floor(val+0.5) operation under the influence of MXCSR.RC mode roundTowards -inf.\n+  \/\/ and re-instantiate original MXCSR.RC mode after that.\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  ldmxcsr(new_mxcsr);\n+  \/\/ Move raw bits corresponding to double value 0.5 into scratch register.\n+  mov64(scratch, 4602678819172646912L);\n+  evpbroadcastq(xtmp1, scratch, vec_enc);\n+  vaddpd(xtmp1, src , xtmp1, vec_enc);\n+  evcvtpd2qq(dst, xtmp1, vec_enc);\n+  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n+  ldmxcsr(mxcsr_std);\n+}\n+\n+void C2_MacroAssembler::vector_round_float_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                                AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+  \/\/ Perform floor(val+0.5) operation under the influence of MXCSR.RC mode roundTowards -inf.\n+  \/\/ and re-instantiate original MXCSR.RC mode after that.\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  ldmxcsr(new_mxcsr);\n+  \/\/ Move raw bits corresponding to float value 0.5f into scratch register.\n+  movl(scratch, 1056964608);\n+  movq(xtmp1, scratch);\n+  vbroadcastss(xtmp1, xtmp1, vec_enc);\n+  vaddps(xtmp1, src , xtmp1, vec_enc);\n+  vcvtps2dq(dst, xtmp1, vec_enc);\n+  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, float_sign_flip, vec_enc);\n+  ldmxcsr(mxcsr_std);\n+}\n+\n+void C2_MacroAssembler::vector_round_float_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                               XMMRegister xtmp3, XMMRegister xtmp4, AddressLiteral float_sign_flip,\n+                                               AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+  \/\/ Perform floor(val+0.5) operation under the influence of MXCSR.RC mode roundTowards -inf.\n+  \/\/ and re-instantiate original MXCSR.RC mode after that.\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  ldmxcsr(new_mxcsr);\n+  \/\/ Move raw bits corresponding to float value 0.5f into scratch register.\n+  movl(scratch, 1056964608);\n+  movq(xtmp1, scratch);\n+  vbroadcastss(xtmp1, xtmp1, vec_enc);\n+  vaddps(xtmp1, src , xtmp1, vec_enc);\n+  vcvtps2dq(dst, xtmp1, vec_enc);\n+  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, scratch, float_sign_flip, vec_enc);\n+  ldmxcsr(mxcsr_std);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":126,"deletions":37,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+\n@@ -314,0 +315,27 @@\n+  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                             KRegister ktmp1, KRegister ktmp2, Register scratch, AddressLiteral double_sign_flip,\n+                                             int vec_enc);\n+\n+  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, Register scratch, AddressLiteral float_sign_flip,\n+                                            int vec_enc);\n+\n+  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           Register scratch, AddressLiteral float_sign_flip,\n+                                           int vec_enc);\n+\n+#ifdef _LP64\n+  void vector_round_double_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n+\n+  void vector_round_float_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                               KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                               AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n+\n+  void vector_round_float_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                              XMMRegister xtmp3, XMMRegister xtmp4, AddressLiteral float_sign_flip,\n+                              AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -8953,0 +8953,74 @@\n+void MacroAssembler::round_float(Register dst, XMMRegister src, Register rtmp, Register rcx) {\n+  \/\/ Following code is line by line assembly translation rounding algorithm.\n+  \/\/ Please refer to java.lang.Math.round(float) algorithm for details.\n+  const int32_t FloatConsts_EXP_BIT_MASK = 0x7F800000;\n+  const int32_t FloatConsts_SIGNIFICAND_WIDTH = 24;\n+  const int32_t FloatConsts_EXP_BIAS = 127;\n+  const int32_t FloatConsts_SIGNIF_BIT_MASK = 0x007FFFFF;\n+  const int32_t MINUS_32 = 0xFFFFFFE0;\n+  Label L_special_case, L_block1, L_exit;\n+  movl(rtmp, FloatConsts_EXP_BIT_MASK);\n+  movdl(dst, src);\n+  andl(dst, rtmp);\n+  sarl(dst, FloatConsts_SIGNIFICAND_WIDTH - 1);\n+  movl(rtmp, FloatConsts_SIGNIFICAND_WIDTH - 2 + FloatConsts_EXP_BIAS);\n+  subl(rtmp, dst);\n+  movl(rcx, rtmp);\n+  movl(dst, MINUS_32);\n+  testl(rtmp, dst);\n+  jccb(Assembler::notEqual, L_special_case);\n+  movdl(dst, src);\n+  andl(dst, FloatConsts_SIGNIF_BIT_MASK);\n+  orl(dst, FloatConsts_SIGNIF_BIT_MASK + 1);\n+  movdl(rtmp, src);\n+  testl(rtmp, rtmp);\n+  jccb(Assembler::greaterEqual, L_block1);\n+  negl(dst);\n+  bind(L_block1);\n+  sarl(dst);\n+  addl(dst, 0x1);\n+  sarl(dst, 0x1);\n+  jmp(L_exit);\n+  bind(L_special_case);\n+  convert_f2i(dst, src);\n+  bind(L_exit);\n+}\n+\n+void MacroAssembler::round_double(Register dst, XMMRegister src, Register rtmp, Register rcx) {\n+  \/\/ Following code is line by line assembly translation rounding algorithm.\n+  \/\/ Please refer to java.lang.Math.round(double) algorithm for details.\n+  const int64_t DoubleConsts_EXP_BIT_MASK = 0x7FF0000000000000L;\n+  const int64_t DoubleConsts_SIGNIFICAND_WIDTH = 53;\n+  const int64_t DoubleConsts_EXP_BIAS = 1023;\n+  const int64_t DoubleConsts_SIGNIF_BIT_MASK = 0x000FFFFFFFFFFFFFL;\n+  const int64_t MINUS_64 = 0xFFFFFFFFFFFFFFC0L;\n+  Label L_special_case, L_block1, L_exit;\n+  mov64(rtmp, DoubleConsts_EXP_BIT_MASK);\n+  movq(dst, src);\n+  andq(dst, rtmp);\n+  sarq(dst, DoubleConsts_SIGNIFICAND_WIDTH - 1);\n+  mov64(rtmp, DoubleConsts_SIGNIFICAND_WIDTH - 2 + DoubleConsts_EXP_BIAS);\n+  subq(rtmp, dst);\n+  movq(rcx, rtmp);\n+  mov64(dst, MINUS_64);\n+  testq(rtmp, dst);\n+  jccb(Assembler::notEqual, L_special_case);\n+  movq(dst, src);\n+  mov64(rtmp, DoubleConsts_SIGNIF_BIT_MASK);\n+  andq(dst, rtmp);\n+  mov64(rtmp, DoubleConsts_SIGNIF_BIT_MASK + 1);\n+  orq(dst, rtmp);\n+  movq(rtmp, src);\n+  testq(rtmp, rtmp);\n+  jccb(Assembler::greaterEqual, L_block1);\n+  negq(dst);\n+  bind(L_block1);\n+  sarq(dst);\n+  addq(dst, 0x1);\n+  sarq(dst, 0x1);\n+  jmp(L_exit);\n+  bind(L_special_case);\n+  convert_d2l(dst, src);\n+  bind(L_exit);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1971,0 +1971,2 @@\n+  void round_double(Register dst, XMMRegister src, Register rtmp, Register rcx);\n+  void round_float(Register dst, XMMRegister src, Register rtmp, Register rcx);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1467,0 +1467,10 @@\n+    case Op_RoundVF:\n+      if (UseAVX < 2) { \/\/ enabled for AVX2 only\n+        return false;\n+      }\n+      break;\n+    case Op_RoundVD:\n+      if (UseAVX < 3) {\n+        return false;  \/\/ enabled for AVX3 only\n+      }\n+      break;\n@@ -1571,0 +1581,6 @@\n+    case Op_RoundF:\n+    case Op_RoundD:\n+      if (!is_LP64) {\n+        return false;\n+      }\n+      break;\n@@ -1816,0 +1832,5 @@\n+    case Op_RoundVD:\n+      if (!VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n@@ -7160,1 +7181,2 @@\n-instruct vcastFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+\n+instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n@@ -7166,1 +7188,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $scratch as TEMP\" %}\n@@ -7176,1 +7198,1 @@\n-instruct vcastFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n@@ -7182,1 +7204,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n@@ -7203,1 +7225,1 @@\n-instruct vcastDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct castDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n@@ -7207,1 +7229,1 @@\n-  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n@@ -7233,0 +7255,50 @@\n+#ifdef _LP64\n+instruct vround_float_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n) < 64 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (RoundVF src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP scratch, KILL cr);\n+  format %{ \"vector_round_float $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    __ vector_round_float_avx($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                              $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                              ExternalAddress(vector_float_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vround_float_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate((VM_Version::supports_avx512vl() ||\n+             Matcher::vector_length_in_bytes(n) == 64) &&\n+             Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (RoundVF src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_round_float $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    __ vector_round_float_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                               $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                               ExternalAddress(vector_float_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vround_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (RoundVD src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_round_long $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    InternalAddress new_mxcsr = $constantaddress((jint)0x3F80);\n+    __ vector_round_double_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                                ExternalAddress(vector_double_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":78,"deletions":6,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -10706,0 +10706,22 @@\n+instruct round_double_reg(rRegL dst, regD src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n+%{\n+  match(Set dst (RoundD src));\n+  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n+  format %{ \"round_double $dst,$src \\t! using $rtmp and $rcx as TEMP\"%}\n+  ins_encode %{\n+    __ round_double($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct round_float_reg(rRegI dst, regF src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n+%{\n+  match(Set dst (RoundF src));\n+  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n+  format %{ \"round_float $dst,$src\" %}\n+  ins_encode %{\n+    __ round_float($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4242,0 +4242,1 @@\n+    \"RoundVF\", \"RoundVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,1 @@\n+  do_name(round_name, \"round\")                                                                                          \\\n@@ -188,0 +189,2 @@\n+  do_intrinsic(_roundD,                   java_lang_Math,         round_name,         double_long_signature,     F_S)   \\\n+  do_intrinsic(_roundF,                   java_lang_Math,         round_name,         float_int_signature,       F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -526,0 +526,2 @@\n+  case vmIntrinsics::_roundD:\n+  case vmIntrinsics::_roundF:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,0 +314,2 @@\n+macro(RoundF)\n+macro(RoundD)\n@@ -448,0 +450,2 @@\n+macro(RoundVF)\n+macro(RoundVD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,8 @@\n+class RoundDNode : public Node {\n+  public:\n+  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -108,0 +116,1 @@\n+\n@@ -144,0 +153,8 @@\n+class RoundFNode : public Node {\n+  public:\n+  RoundFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,0 +272,2 @@\n+  case vmIntrinsics::_roundF:\n+  case vmIntrinsics::_roundD:\n@@ -1609,0 +1611,1 @@\n+\/\/ public static double Math.round(double)\n@@ -1620,0 +1623,1 @@\n+  case vmIntrinsics::_roundD: n = new RoundDNode(arg); break;\n@@ -1641,0 +1645,1 @@\n+  case vmIntrinsics::_roundF: n = new RoundFNode(arg); break;\n@@ -1756,0 +1761,1 @@\n+  case vmIntrinsics::_roundD: return Matcher::match_rule_supported(Op_RoundD) ? inline_double_math(id) : false;\n@@ -1759,0 +1765,1 @@\n+\n@@ -1778,0 +1785,1 @@\n+  case vmIntrinsics::_roundF: return Matcher::match_rule_supported(Op_RoundF) ? inline_math(id) : false;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -971,0 +971,4 @@\n+      case Op_RoundF: body_size += 30; break;\n+      case Op_RoundD: body_size += 30; break;\n+      case Op_RoundVF: body_size += 30; break;\n+      case Op_RoundVD: body_size += 30; break;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2556,0 +2556,1 @@\n+                 opc == Op_RoundF || opc == Op_RoundD ||\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  case Op_RoundF:\n+    return (bt == T_INT ? Op_RoundVF : 0);\n+  case Op_RoundD:\n+    return (bt == T_LONG ? Op_RoundVD : 0);\n@@ -545,0 +549,3 @@\n+  case Op_RoundVF: return new RoundVFNode(n1, vt);\n+  case Op_RoundVD: return new RoundVDNode(n1, vt);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1525,0 +1525,8 @@\n+class RoundVFNode : public VectorNode {\n+ public:\n+  RoundVFNode(Node* in, const TypeVect* vt) :VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_FLOAT, \"must be float\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -1533,0 +1541,8 @@\n+class RoundVDNode : public VectorNode {\n+ public:\n+  RoundVDNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -743,0 +743,1 @@\n+    @IntrinsicCandidate\n@@ -792,0 +793,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -XX:TieredStopAtLevel=2 -Xmx128m -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestDoubleVect\n@@ -47,2 +48,2 @@\n-      System.err.println(\"FAILED: \" + errn + \" errors\");\n-      System.exit(97);\n+        System.err.println(\"FAILED: \" + errn + \" errors\");\n+        System.exit(97);\n@@ -55,0 +56,2 @@\n+    long  [] l0 = new long[ARRLEN];\n+\n@@ -94,0 +97,1 @@\n+      test_round(l0, a1);\n@@ -358,0 +362,1 @@\n+\n@@ -424,0 +429,29 @@\n+\n+      a1[6] = +0x1.fffffffffffffp-2;\n+      a1[7] = +0x1.0p-1;\n+      a1[8] = +0x1.0000000000001p-1;\n+      a1[9] = -0x1.fffffffffffffp-2;\n+      a1[10] = -0x1.0p-1;\n+      a1[11] = -0x1.0000000000001p-1;\n+      a1[12] = 1.7976931348623157E19;\n+      a1[13] = -1.7976931348623157E19;\n+\n+      test_round(l0, a1);\n+      errn += verify(\"test_round: \", 0, l0[0], 0L);\n+      errn += verify(\"test_round: \", 1, l0[1], Long.MAX_VALUE);\n+      errn += verify(\"test_round: \", 2, l0[2], Long.MIN_VALUE);\n+      errn += verify(\"test_round: \", 3, l0[3], Long.MAX_VALUE);\n+      errn += verify(\"test_round: \", 4, l0[4], 0L);\n+      errn += verify(\"test_round: \", 5, l0[5], 0L);\n+\n+      errn += verify(\"test_round: \", 6, l0[6], 0L);\n+      errn += verify(\"test_round: \", 7, l0[7], 1L);\n+      errn += verify(\"test_round: \", 8, l0[8], 1L);\n+      errn += verify(\"test_round: \", 9, l0[9], 0L);\n+      errn += verify(\"test_round: \", 10, l0[10], 0L);\n+      errn += verify(\"test_round: \", 11, l0[11], -1L);\n+      errn += verify(\"test_round: \", 12, l0[12], Long.MAX_VALUE);\n+      errn += verify(\"test_round: \", 13, l0[13], Long.MIN_VALUE);\n+      for (int i=14; i<ARRLEN; i++) {\n+        errn += verify(\"test_round: \", i, l0[i], Math.round((double)(ADD_INIT+i)));\n+      }\n@@ -567,0 +601,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(l0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_round_n: \" + (end - start));\n@@ -694,0 +734,14 @@\n+  static void test_round(long[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  static int verify(String text, int i, long elem, long val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+      return 1;\n+    }\n+    return 0;\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVect.java","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -XX:TieredStopAtLevel=2 -Xmx128m -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestFloatVect\n@@ -55,0 +56,1 @@\n+    int[] i0 = new int[ARRLEN];\n@@ -91,0 +93,1 @@\n+      test_round(i0, a1);\n@@ -92,0 +95,1 @@\n+\n@@ -372,0 +376,29 @@\n+      a1[6] = +0x1.fffffep-2f;\n+      a1[7] = +0x1.0p-1f;\n+      a1[8] = +0x1.000002p-1f;\n+      a1[9] = -0x1.fffffep-2f;\n+      a1[10] = -0x1.0p-1f;\n+      a1[11] = -0x1.000002p-1f;\n+      a1[12] = 3.4028235E10f;\n+      a1[13] = -3.4028235E10f;\n+\n+      test_round(i0, a1);\n+      errn += verify(\"test_round: \", 0, i0[0], 0);\n+      errn += verify(\"test_round: \", 1, i0[1], Integer.MAX_VALUE);\n+      errn += verify(\"test_round: \", 2, i0[2], Integer.MIN_VALUE);\n+      errn += verify(\"test_round: \", 3, i0[3], Integer.MAX_VALUE);\n+      errn += verify(\"test_round: \", 4, i0[4], 0);\n+      errn += verify(\"test_round: \", 5, i0[5], 0);\n+      errn += verify(\"test_round: \", 6, i0[6], 0);\n+      errn += verify(\"test_round: \", 7, i0[7], 1);\n+      errn += verify(\"test_round: \", 8, i0[8], 1);\n+      errn += verify(\"test_round: \", 9, i0[9], 0);\n+      errn += verify(\"test_round: \", 10, i0[10], 0);\n+      errn += verify(\"test_round: \", 11, i0[11], -1);\n+      errn += verify(\"test_round: \", 12, i0[12], Integer.MAX_VALUE);\n+      errn += verify(\"test_round: \", 13, i0[13], Integer.MIN_VALUE);\n+\n+      for (int i=14; i<ARRLEN; i++) {\n+        errn += verify(\"test_round: \", i, i0[i], Math.round(((float)(ADD_INIT+i))));\n+      }\n+\n@@ -515,0 +548,6 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(i0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_round_n: \" + (end - start));\n@@ -612,0 +651,14 @@\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  static int verify(String text, int i, int elem, int val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+      return 1;\n+    }\n+    return 0;\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVect.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279508\n+ * @summary Auto-vectorize Math.round API\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx512dq.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestRoundVectDouble\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestRoundVectDouble {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static double [] dinp;\n+  private static long   [] lout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                  \"-XX:UseAVX=3\",\n+                                  \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(applyIf = {\"UseAVX\", \"3\"}, counts = {\"RoundVD\" , \" > 0 \"})\n+  public void test_round_double(long[] lout, double[] dinp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Math.round(dinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_double\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round_double() {\n+      dinp = new double[ARRLEN];\n+      lout = new long[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          dinp[i] = (double)i*1.4;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_double(lout , dinp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectDouble.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279508\n+ * @summary Auto-vectorize Math.round API\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestRoundVectFloat\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestRoundVectFloat {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+  private static float  [] finp;\n+  private static int    [] iout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:UseAVX=1\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(applyIf = {\"UseAVX\", \" > 1\"}, counts = {\"RoundVF\" , \" > 0 \"})\n+  public void test_round_float(int[] iout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          iout[i] = Math.round(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round() {\n+      finp = new float[ARRLEN];\n+      iout = new int[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          finp[i] = (float)i*1.4f;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_float(iout , finp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectFloat.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @run main\/othervm -XX:Tier3CompileThreshold=50 -XX:CompileThresholdScaling=0.01 -XX:+TieredCompilation RoundTests\n@@ -32,0 +33,5 @@\n+        for (int i = 0; i < 500; i++) {\n+            failures += testNearFloatHalfCases();\n+            failures += testNearDoubleHalfCases();\n+            failures += testUnityULPCases();\n+            failures += testSpecialCases();\n@@ -33,9 +39,5 @@\n-        failures += testNearFloatHalfCases();\n-        failures += testNearDoubleHalfCases();\n-        failures += testUnityULPCases();\n-        failures += testSpecialCases();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing {Math, StrictMath}.round incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n+            if (failures > 0) {\n+                System.err.println(\"Testing {Math, StrictMath}.round incurred \"\n+                                   + failures + \" failures.\");\n+                throw new RuntimeException();\n+            }\n","filename":"test\/jdk\/java\/lang\/Math\/RoundTests.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n@@ -35,1 +34,1 @@\n-  @Param({\"1024\"})\n+  @Param({\"1024\", \"2048\"})\n@@ -39,2 +38,5 @@\n-\n-  public double[] Res;\n+  public double[] ResD;\n+  public long[] ResL;\n+  public float[] FargV1;\n+  public float[] ResF;\n+  public int[] ResI;\n@@ -43,1 +45,10 @@\n-      0.0, -0.0, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY};\n+      0.0, -0.0, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+      Double.MAX_VALUE, -Double.MAX_VALUE, Double.MIN_VALUE, -Double.MIN_VALUE,\n+      Double.MIN_NORMAL\n+  };\n+\n+  public final float[] FspecialVals = {\n+      0.0f, -0.0f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,\n+      Float.MAX_VALUE, -Float.MAX_VALUE, Float.MIN_VALUE, -Float.MIN_VALUE,\n+      Float.MIN_NORMAL\n+  };\n@@ -47,12 +58,42 @@\n-    int i = 0;\n-    Random r = new Random(1024);\n-    DargV1 = new double[TESTSIZE];\n-    Res = new double[TESTSIZE];\n-\n-    for (; i < DspecialVals.length; i++) {\n-      DargV1[i] = DspecialVals[i];\n-    }\n-\n-    for (; i < TESTSIZE; i++) {\n-      DargV1[i] = r.nextDouble()*TESTSIZE;\n-    }\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      DargV1 = new double[TESTSIZE];\n+      ResD = new double[TESTSIZE];\n+\n+      for (; i < DspecialVals.length; i++) {\n+          DargV1[i] = DspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          DargV1[i] = Double.longBitsToDouble(r.nextLong());;\n+      }\n+\n+      FargV1 = new float[TESTSIZE];\n+      ResF = new float[TESTSIZE];\n+\n+      i = 0;\n+      for (; i < FspecialVals.length; i++) {\n+          FargV1[i] = FspecialVals[i];\n+      }\n+\n+      for (; i < TESTSIZE; i++) {\n+          FargV1[i] = Float.intBitsToFloat(r.nextInt());\n+      }\n+\n+      ResI = new int[TESTSIZE];\n+      ResL = new long[TESTSIZE];\n+  }\n+\n+  @Benchmark\n+  public void test_ceil() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.ceil(DargV1[i]);\n+      }\n+  }\n+\n+  @Benchmark\n+  public void test_floor() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.floor(DargV1[i]);\n+      }\n@@ -62,3 +103,4 @@\n-  public void testceil(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.ceil(DargV1[i]);\n+  public void test_rint() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResD[i] = Math.rint(DargV1[i]);\n+      }\n@@ -68,3 +110,4 @@\n-  public void testfloor(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.floor(DargV1[i]);\n+  public void test_round_double() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResL[i] = Math.round(DargV1[i]);\n+      }\n@@ -74,3 +117,4 @@\n-  public void testrint(Blackhole bh) {\n-    for (int i = 0; i < TESTSIZE; i++)\n-      Res[i] = Math.rint(DargV1[i]);\n+  public void test_round_float() {\n+      for (int i = 0; i < TESTSIZE; i++) {\n+          ResI[i] = Math.round(FargV1[i]);\n+      }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/FpRoundingBenchmark.java","additions":71,"deletions":27,"binary":false,"changes":98,"status":"modified"}]}