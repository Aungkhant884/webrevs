{"files":[{"patch":"@@ -4145,1 +4145,2 @@\n-  vector_castD2L_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, double_sign_flip, scratch, vec_enc);\n+  evcvtpd2qq(dst, xtmp1, vec_enc);\n+  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n@@ -4159,1 +4160,2 @@\n-  vector_castF2I_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, float_sign_flip, scratch, vec_enc);\n+  vcvtps2dq(dst, xtmp1, vec_enc);\n+  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, float_sign_flip, vec_enc);\n@@ -4175,1 +4177,1 @@\n-  vector_castF2I_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, float_sign_flip, scratch, vec_enc);\n+  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, scratch, float_sign_flip, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -8955,1 +8955,7 @@\n-  \/\/ Following code is exactly mimicking the functionality of java.lang.Math.round(float) method.\n+  \/\/ Following code is line by line assembly translation rounding algorithm.\n+  \/\/ Please refer to java.lang.Math.round(float) algorithm for details.\n+  const int FloatConsts_EXP_BIT_MASK = 0x7F800000;\n+  const int FloatConsts_SIGNIFICAND_WIDTH = 24;\n+  const int FloatConsts_EXP_BIAS = 127;\n+  const int FloatConsts_SIGNIF_BIT_MASK = 0x007FFFFF;\n+  const int MINUS_32 = 0xFFFFFFE0;\n@@ -8957,1 +8963,1 @@\n-  movl(rtmp, 0x7f800000);\n+  movl(rtmp, FloatConsts_EXP_BIT_MASK);\n@@ -8960,2 +8966,2 @@\n-  sarl(dst, 0x17);\n-  movl(rtmp, 0x95);\n+  sarl(dst, FloatConsts_SIGNIFICAND_WIDTH - 1);\n+  movl(rtmp, FloatConsts_SIGNIFICAND_WIDTH - 2 + FloatConsts_EXP_BIAS);\n@@ -8964,1 +8970,1 @@\n-  movl(dst, 0xffffffe0);\n+  movl(dst, MINUS_32);\n@@ -8968,2 +8974,2 @@\n-  andl(dst, 0x7fffff);\n-  orl(dst, 0x800000);\n+  andl(dst, FloatConsts_SIGNIF_BIT_MASK);\n+  orl(dst, FloatConsts_SIGNIF_BIT_MASK + 1);\n@@ -8985,1 +8991,7 @@\n-  \/\/ Following code is exactly mimicking the functionality of java.lang.Math.round(double) method.\n+  \/\/ Following code is line by line assembly translation rounding algorithm.\n+  \/\/ Please refer to java.lang.Math.round(double) algorithm for details.\n+  const long DoubleConsts_EXP_BIT_MASK = 0x7FF0000000000000L;\n+  const long DoubleConsts_SIGNIFICAND_WIDTH = 53;\n+  const long DoubleConsts_EXP_BIAS = 1023;\n+  const long DoubleConsts_SIGNIF_BIT_MASK = 0x000FFFFFFFFFFFFFL;\n+  const long MINUS_64 = 0xFFFFFFFFFFFFFFC0L;\n@@ -8987,1 +8999,1 @@\n-  mov64(rtmp, 0x7ff0000000000000L);\n+  mov64(rtmp, DoubleConsts_EXP_BIT_MASK);\n@@ -8990,2 +9002,2 @@\n-  sarq(dst, 0x34);\n-  mov64(rtmp, 0x432);\n+  sarq(dst, DoubleConsts_SIGNIFICAND_WIDTH - 1);\n+  mov64(rtmp, DoubleConsts_SIGNIFICAND_WIDTH - 2 + DoubleConsts_EXP_BIAS);\n@@ -8994,1 +9006,1 @@\n-  mov64(dst, 0xffffffffffffffc0L);\n+  mov64(dst, MINUS_64);\n@@ -8998,1 +9010,1 @@\n-  mov64(rtmp, 0xfffffffffffffL);\n+  mov64(rtmp, DoubleConsts_SIGNIF_BIT_MASK);\n@@ -9000,1 +9012,1 @@\n-  mov64(rtmp, 0x10000000000000L);\n+  mov64(rtmp, DoubleConsts_SIGNIF_BIT_MASK + 1);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"}]}