{"files":[{"patch":"@@ -312,1 +312,1 @@\n-          InterpreterRuntime::slow_signature_handler(JavaThread* thread,\n+          InterpreterRuntime::slow_signature_handler(JavaThread* current,\n@@ -316,1 +316,1 @@\n-  methodHandle m(thread, (Method*)method);\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,2 +367,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))\n-  methodHandle m(thread, (Method*)method);\n+JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaCurrent* current, Method* method, intptr_t* from, intptr_t* to))\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/arm\/interpreterRT_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,2 +150,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n@@ -157,2 +157,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n","filename":"src\/hotspot\/cpu\/ppc\/interpreterRT_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,2 +153,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(address, InterpreterRuntime::get_signature(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n@@ -160,2 +160,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(address, InterpreterRuntime::get_result_handler(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n","filename":"src\/hotspot\/cpu\/s390\/interpreterRT_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,2 +149,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))\n-  methodHandle m(thread, (Method*)method);\n+JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* current, Method* method, intptr_t* from, intptr_t* to))\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-          InterpreterRuntime::slow_signature_handler(JavaThread* thread,\n+          InterpreterRuntime::slow_signature_handler(JavaThread* current,\n@@ -503,1 +503,1 @@\n-  methodHandle m(thread, (Method*)method);\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-          InterpreterRuntime::slow_signature_handler(JavaThread* thread,\n+          InterpreterRuntime::slow_signature_handler(JavaThread* current,\n@@ -160,1 +160,1 @@\n-  ZeroStack *stack = thread->zero_stack();\n+  ZeroStack *stack = current->zero_stack();\n@@ -169,1 +169,1 @@\n-  SlowSignatureHandlerGenerator sshg(methodHandle(thread, method), buf);\n+  SlowSignatureHandlerGenerator sshg(methodHandle(current, method), buf);\n","filename":"src\/hotspot\/cpu\/zero\/interpreterRT_zero.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -169,3 +169,3 @@\n-  JavaThread* thread = JavaThread::current();\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+  JavaThread* current = JavaThread::current();\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -180,3 +180,3 @@\n-    JavaThread* thread = JavaThread::current();\n-    RegisterMap reg_map(thread, false);\n-    frame runtime_frame = thread->last_frame();\n+    JavaThread* current = JavaThread::current();\n+    RegisterMap reg_map(current, false);\n+    frame runtime_frame = current->last_frame();\n@@ -184,1 +184,1 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -357,1 +357,1 @@\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* thread, Klass* klass))\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n@@ -361,1 +361,1 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -368,1 +368,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -372,1 +372,1 @@\n-JRT_ENTRY(void, Runtime1::new_type_array(JavaThread* thread, Klass* klass, jint length))\n+JRT_ENTRY(void, Runtime1::new_type_array(JavaThread* current, Klass* klass, jint length))\n@@ -380,1 +380,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -390,1 +390,1 @@\n-JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))\n+JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* current, Klass* array_klass, jint length))\n@@ -397,1 +397,1 @@\n-  Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, array_klass->klass_holder()); \/\/ keep the klass alive\n@@ -400,1 +400,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -409,1 +409,1 @@\n-JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))\n+JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims))\n@@ -414,1 +414,1 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -416,1 +416,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -420,1 +420,1 @@\n-JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))\n+JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, StubID id))\n@@ -425,2 +425,2 @@\n-JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))\n-  ResourceMark rm(thread);\n+JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* current, oopDesc* obj))\n+  ResourceMark rm(current);\n@@ -428,1 +428,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArrayStoreException(), klass_name);\n@@ -436,1 +436,1 @@\n-static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {\n+static nmethod* counter_overflow_helper(JavaThread* current, int branch_bci, Method* m) {\n@@ -438,1 +438,1 @@\n-  methodHandle method(THREAD, m);\n+  methodHandle method(current, m);\n@@ -440,2 +440,2 @@\n-  RegisterMap map(THREAD, false);\n-  frame fr =  THREAD->last_frame().sender(&map);\n+  RegisterMap map(current, false);\n+  frame fr =  current->last_frame().sender(&map);\n@@ -444,1 +444,1 @@\n-  methodHandle enclosing_method(THREAD, nm->method());\n+  methodHandle enclosing_method(current, nm->method());\n@@ -470,1 +470,1 @@\n-  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n+  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, current);\n@@ -474,1 +474,1 @@\n-JRT_BLOCK_ENTRY(address, Runtime1::counter_overflow(JavaThread* thread, int bci, Method* method))\n+JRT_BLOCK_ENTRY(address, Runtime1::counter_overflow(JavaThread* current, int bci, Method* method))\n@@ -477,1 +477,1 @@\n-    osr_nm = counter_overflow_helper(thread, bci, method);\n+    osr_nm = counter_overflow_helper(current, bci, method);\n@@ -479,3 +479,3 @@\n-      RegisterMap map(thread, false);\n-      frame fr =  thread->last_frame().sender(&map);\n-      Deoptimization::deoptimize_frame(thread, fr.id());\n+      RegisterMap map(current, false);\n+      frame fr =  current->last_frame().sender(&map);\n+      Deoptimization::deoptimize_frame(current, fr.id());\n@@ -505,1 +505,1 @@\n-JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, nmethod*& nm))\n+JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* current, oopDesc* ex, address pc, nmethod*& nm))\n@@ -507,1 +507,1 @@\n-  thread->set_is_method_handle_return(false);\n+  current->set_is_method_handle_return(false);\n@@ -509,1 +509,1 @@\n-  Handle exception(thread, ex);\n+  Handle exception(current, ex);\n@@ -514,1 +514,1 @@\n-  if (thread->last_frame().cb() == Runtime1::blob_for(Runtime1::handle_exception_from_callee_id)) {\n+  if (current->last_frame().cb() == Runtime1::blob_for(Runtime1::handle_exception_from_callee_id)) {\n@@ -518,1 +518,1 @@\n-    StackWatermarkSet::after_unwind(thread);\n+    StackWatermarkSet::after_unwind(current);\n@@ -525,2 +525,2 @@\n-    RegisterMap map(thread, false);\n-    frame exception_frame = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false);\n+    frame exception_frame = current->last_frame().sender(&map);\n@@ -544,1 +544,1 @@\n-                 nm->method()->print_value_string(), p2i(pc), p2i(thread));\n+                 nm->method()->print_value_string(), p2i(pc), p2i(current));\n@@ -553,1 +553,1 @@\n-  bool guard_pages_enabled = thread->stack_overflow_state()->reguard_stack_if_needed();\n+  bool guard_pages_enabled = current->stack_overflow_state()->reguard_stack_if_needed();\n@@ -564,2 +564,2 @@\n-    RegisterMap reg_map(thread);\n-    frame stub_frame = thread->last_frame();\n+    RegisterMap reg_map(current);\n+    frame stub_frame = current->last_frame();\n@@ -571,1 +571,1 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -582,1 +582,1 @@\n-      thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -600,1 +600,1 @@\n-    thread->clear_exception_oop_and_pc();\n+    current->clear_exception_oop_and_pc();\n@@ -605,2 +605,2 @@\n-    thread->set_exception_oop(exception());\n-    thread->set_exception_pc(pc);\n+    current->set_exception_oop(exception());\n+    current->set_exception_pc(pc);\n@@ -618,1 +618,1 @@\n-  thread->set_vm_result(exception());\n+  current->set_vm_result(exception());\n@@ -620,1 +620,1 @@\n-  thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -626,1 +626,1 @@\n-                         p2i(thread), p2i(continuation), p2i(pc));\n+                         p2i(current), p2i(continuation), p2i(pc));\n@@ -637,3 +637,3 @@\n-address Runtime1::exception_handler_for_pc(JavaThread* thread) {\n-  oop exception = thread->exception_oop();\n-  address pc = thread->exception_pc();\n+address Runtime1::exception_handler_for_pc(JavaThread* current) {\n+  oop exception = current->exception_oop();\n+  address pc = current->exception_pc();\n@@ -647,1 +647,1 @@\n-    continuation = exception_handler_for_pc_helper(thread, exception, pc, nm);\n+    continuation = exception_handler_for_pc_helper(current, exception, pc, nm);\n@@ -662,1 +662,1 @@\n-JRT_ENTRY(void, Runtime1::throw_range_check_exception(JavaThread* thread, int index, arrayOopDesc* a))\n+JRT_ENTRY(void, Runtime1::throw_range_check_exception(JavaThread* current, int index, arrayOopDesc* a))\n@@ -668,1 +668,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), message);\n@@ -672,1 +672,1 @@\n-JRT_ENTRY(void, Runtime1::throw_index_exception(JavaThread* thread, int index))\n+JRT_ENTRY(void, Runtime1::throw_index_exception(JavaThread* current, int index))\n@@ -676,1 +676,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IndexOutOfBoundsException(), message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IndexOutOfBoundsException(), message);\n@@ -680,1 +680,1 @@\n-JRT_ENTRY(void, Runtime1::throw_div0_exception(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_div0_exception(JavaThread* current))\n@@ -682,1 +682,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n@@ -686,1 +686,1 @@\n-JRT_ENTRY(void, Runtime1::throw_null_pointer_exception(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_null_pointer_exception(JavaThread* current))\n@@ -688,1 +688,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n@@ -692,1 +692,1 @@\n-JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))\n+JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* current, oopDesc* object))\n@@ -694,5 +694,3 @@\n-  ResourceMark rm(thread);\n-  char* message = SharedRuntime::generate_class_cast_message(\n-    thread, object->klass());\n-  SharedRuntime::throw_and_post_jvmti_exception(\n-    thread, vmSymbols::java_lang_ClassCastException(), message);\n+  ResourceMark rm(current);\n+char* message = SharedRuntime::generate_class_cast_message(current, object->klass());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ClassCastException(), message);\n@@ -702,1 +700,1 @@\n-JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* current))\n@@ -704,2 +702,2 @@\n-  ResourceMark rm(thread);\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IncompatibleClassChangeError());\n@@ -709,1 +707,1 @@\n-JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))\n+JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* current, oopDesc* obj, BasicObjectLock* lock))\n@@ -715,1 +713,1 @@\n-  SharedRuntime::monitor_enter_helper(obj, lock->lock(), thread);\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n@@ -719,1 +717,1 @@\n-JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))\n+JRT_LEAF(void, Runtime1::monitorexit(JavaThread* current, BasicObjectLock* lock))\n@@ -721,1 +719,1 @@\n-  assert(thread->last_Java_sp(), \"last_Java_sp must be set\");\n+  assert(current->last_Java_sp(), \"last_Java_sp must be set\");\n@@ -724,1 +722,1 @@\n-  SharedRuntime::monitor_exit_helper(obj, lock->lock(), thread);\n+  SharedRuntime::monitor_exit_helper(obj, lock->lock(), current);\n@@ -728,1 +726,1 @@\n-JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))\n+JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* current, jint trap_request))\n@@ -730,2 +728,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -736,1 +734,1 @@\n-  methodHandle method(thread, nm->method());\n+  methodHandle method(current, nm->method());\n@@ -744,1 +742,1 @@\n-        MethodData* trap_mdo = Deoptimization::get_method_data(thread, method, true \/*create_if_missing*\/);\n+        MethodData* trap_mdo = Deoptimization::get_method_data(current, method, true \/*create_if_missing*\/);\n@@ -753,1 +751,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -871,1 +869,1 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id ))\n+JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id ))\n@@ -874,3 +872,3 @@\n-  ResourceMark rm(thread);\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+  ResourceMark rm(current);\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -880,1 +878,1 @@\n-  vframeStream vfst(thread, true);\n+  vframeStream vfst(current, true);\n@@ -883,1 +881,1 @@\n-  methodHandle caller_method(THREAD, vfst.method());\n+  methodHandle caller_method(current, vfst.method());\n@@ -898,2 +896,2 @@\n-  Handle mirror(THREAD, NULL);                    \/\/ oop needed by load_mirror_patching code\n-  Handle appendix(THREAD, NULL);                  \/\/ oop needed by appendix_patching code\n+  Handle mirror(current, NULL);                    \/\/ oop needed by load_mirror_patching code\n+  Handle appendix(current, NULL);                  \/\/ oop needed by appendix_patching code\n@@ -908,1 +906,1 @@\n-    constantPoolHandle constants(THREAD, caller_method->constants());\n+    constantPoolHandle constants(current, caller_method->constants());\n@@ -945,1 +943,1 @@\n-          mirror = Handle(THREAD, klass->java_mirror());\n+          mirror = Handle(current, klass->java_mirror());\n@@ -979,1 +977,1 @@\n-          mirror = Handle(THREAD, m);\n+          mirror = Handle(current, m);\n@@ -990,1 +988,1 @@\n-    constantPoolHandle pool(thread, caller_method->constants());\n+    constantPoolHandle pool(current, caller_method->constants());\n@@ -999,1 +997,1 @@\n-        appendix = Handle(THREAD, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n@@ -1005,1 +1003,1 @@\n-        appendix = Handle(THREAD, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n@@ -1034,1 +1032,1 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1042,1 +1040,1 @@\n-    MutexLocker ml_patch (THREAD, Patching_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_patch (current, Patching_lock, Mutex::_no_safepoint_check_flag);\n@@ -1254,1 +1252,1 @@\n-    MutexLocker ml_code (THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1266,1 +1264,1 @@\n-void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {\n+void Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id) {\n@@ -1277,1 +1275,1 @@\n-  RegisterMap reg_map(thread, false);\n+  RegisterMap reg_map(current, false);\n@@ -1279,1 +1277,1 @@\n-  frame runtime_frame = thread->last_frame();\n+  frame runtime_frame = current->last_frame();\n@@ -1289,1 +1287,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1304,1 +1302,1 @@\n-int Runtime1::move_klass_patching(JavaThread* thread) {\n+int Runtime1::move_klass_patching(JavaThread* current) {\n@@ -1308,1 +1306,0 @@\n-  Thread* THREAD = thread;\n@@ -1313,1 +1310,1 @@\n-    patch_code(thread, load_klass_patching_id);\n+    patch_code(current, load_klass_patching_id);\n@@ -1322,1 +1319,1 @@\n-int Runtime1::move_mirror_patching(JavaThread* thread) {\n+int Runtime1::move_mirror_patching(JavaThread* current) {\n@@ -1326,1 +1323,0 @@\n-  Thread* THREAD = thread;\n@@ -1331,1 +1327,1 @@\n-    patch_code(thread, load_mirror_patching_id);\n+    patch_code(current, load_mirror_patching_id);\n@@ -1340,1 +1336,1 @@\n-int Runtime1::move_appendix_patching(JavaThread* thread) {\n+int Runtime1::move_appendix_patching(JavaThread* current) {\n@@ -1344,1 +1340,0 @@\n-  Thread* THREAD = thread;\n@@ -1349,1 +1344,1 @@\n-    patch_code(thread, load_appendix_patching_id);\n+    patch_code(current, load_appendix_patching_id);\n@@ -1366,1 +1361,1 @@\n-int Runtime1::access_field_patching(JavaThread* thread) {\n+int Runtime1::access_field_patching(JavaThread* current) {\n@@ -1376,1 +1371,1 @@\n-    patch_code(thread, access_field_patching_id);\n+    patch_code(current, access_field_patching_id);\n@@ -1404,1 +1399,1 @@\n-JRT_ENTRY(void, Runtime1::predicate_failed_trap(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::predicate_failed_trap(JavaThread* current))\n@@ -1407,2 +1402,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -1415,1 +1410,1 @@\n-  methodHandle m(thread, nm->method());\n+  methodHandle m(current, nm->method());\n@@ -1436,1 +1431,1 @@\n-    vframeStream vfst(thread);\n+    vframeStream vfst(current);\n@@ -1444,1 +1439,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":117,"deletions":122,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -136,4 +136,4 @@\n-  static void new_instance    (JavaThread* thread, Klass* klass);\n-  static void new_type_array  (JavaThread* thread, Klass* klass, jint length);\n-  static void new_object_array(JavaThread* thread, Klass* klass, jint length);\n-  static void new_multi_array (JavaThread* thread, Klass* klass, int rank, jint* dims);\n+  static void new_instance    (JavaThread* current, Klass* klass);\n+  static void new_type_array  (JavaThread* current, Klass* klass, jint length);\n+  static void new_object_array(JavaThread* current, Klass* klass, jint length);\n+  static void new_multi_array (JavaThread* current, Klass* klass, int rank, jint* dims);\n@@ -141,1 +141,1 @@\n-  static address counter_overflow(JavaThread* thread, int bci, Method* method);\n+  static address counter_overflow(JavaThread* current, int bci, Method* method);\n@@ -143,1 +143,1 @@\n-  static void unimplemented_entry   (JavaThread* thread, StubID id);\n+  static void unimplemented_entry(JavaThread* current, StubID id);\n@@ -145,1 +145,1 @@\n-  static address exception_handler_for_pc(JavaThread* thread);\n+  static address exception_handler_for_pc(JavaThread* current);\n@@ -147,7 +147,7 @@\n-  static void throw_range_check_exception(JavaThread* thread, int index, arrayOopDesc* a);\n-  static void throw_index_exception(JavaThread* thread, int index);\n-  static void throw_div0_exception(JavaThread* thread);\n-  static void throw_null_pointer_exception(JavaThread* thread);\n-  static void throw_class_cast_exception(JavaThread* thread, oopDesc* object);\n-  static void throw_incompatible_class_change_error(JavaThread* thread);\n-  static void throw_array_store_exception(JavaThread* thread, oopDesc* object);\n+  static void throw_range_check_exception(JavaThread* current, int index, arrayOopDesc* a);\n+  static void throw_index_exception(JavaThread* current, int index);\n+  static void throw_div0_exception(JavaThread* current);\n+  static void throw_null_pointer_exception(JavaThread* current);\n+  static void throw_class_cast_exception(JavaThread* current, oopDesc* object);\n+  static void throw_incompatible_class_change_error(JavaThread* current);\n+  static void throw_array_store_exception(JavaThread* current, oopDesc* object);\n@@ -155,2 +155,2 @@\n-  static void monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock);\n-  static void monitorexit (JavaThread* thread, BasicObjectLock* lock);\n+  static void monitorenter(JavaThread* current, oopDesc* obj, BasicObjectLock* lock);\n+  static void monitorexit (JavaThread* current, BasicObjectLock* lock);\n@@ -158,1 +158,1 @@\n-  static void deoptimize(JavaThread* thread, jint trap_request);\n+  static void deoptimize(JavaThread* current, jint trap_request);\n@@ -160,4 +160,4 @@\n-  static int access_field_patching(JavaThread* thread);\n-  static int move_klass_patching(JavaThread* thread);\n-  static int move_mirror_patching(JavaThread* thread);\n-  static int move_appendix_patching(JavaThread* thread);\n+  static int access_field_patching(JavaThread* current);\n+  static int move_klass_patching(JavaThread* current);\n+  static int move_mirror_patching(JavaThread* current);\n+  static int move_appendix_patching(JavaThread* current);\n@@ -165,1 +165,1 @@\n-  static void patch_code(JavaThread* thread, StubID stub_id);\n+  static void patch_code(JavaThread* current, StubID stub_id);\n@@ -192,1 +192,1 @@\n-  static void predicate_failed_trap(JavaThread* thread);\n+  static void predicate_failed_trap(JavaThread* current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -85,3 +85,3 @@\n-  LastFrameAccessor(JavaThread* thread) {\n-    assert(thread == Thread::current(), \"sanity\");\n-    _last_frame = thread->last_frame();\n+  LastFrameAccessor(JavaThread* current) {\n+    assert(current == Thread::current(), \"sanity\");\n+    _last_frame = current->last_frame();\n@@ -131,2 +131,2 @@\n-void InterpreterRuntime::set_bcp_and_mdp(address bcp, JavaThread *thread) {\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::set_bcp_and_mdp(address bcp, JavaThread *current) {\n+  LastFrameAccessor last_frame(current);\n@@ -149,1 +149,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))\n+JRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* current, bool wide))\n@@ -151,1 +151,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -158,2 +158,2 @@\n-    oop java_class = klass->java_mirror();\n-    thread->set_vm_result(java_class);\n+  oop java_class = klass->java_mirror();\n+  current->set_vm_result(java_class);\n@@ -162,1 +162,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode)) {\n+JRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* current, Bytecodes::Code bytecode)) {\n@@ -168,1 +168,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -171,2 +171,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  methodHandle m (thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  methodHandle m (current, last_frame.method());\n@@ -202,1 +202,1 @@\n-  thread->set_vm_result(result);\n+  current->set_vm_result(result);\n@@ -209,1 +209,1 @@\n-    thread->set_vm_result_2((Metadata*)flags);\n+    current->set_vm_result_2((Metadata*)flags);\n@@ -218,1 +218,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))\n+JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* current, ConstantPool* pool, int index))\n@@ -243,1 +243,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -247,1 +247,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))\n+JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* current, BasicType type, jint size))\n@@ -249,1 +249,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -253,1 +253,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))\n+JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* current, ConstantPool* pool, int index, jint size))\n@@ -256,1 +256,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -260,1 +260,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))\n+JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* current, jint* first_size_address))\n@@ -262,1 +262,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -271,1 +271,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -284,1 +284,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -288,1 +288,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))\n+JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* current, oopDesc* obj))\n@@ -296,1 +296,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* current))\n@@ -298,1 +298,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -303,1 +303,1 @@\n-  \/\/ thread quicken the bytecode before we get here.\n+  \/\/ current quicken the bytecode before we get here.\n@@ -306,1 +306,1 @@\n-  thread->set_vm_result_2(klass);\n+  current->set_vm_result_2(klass);\n@@ -313,2 +313,2 @@\n-void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,\n-                                         const methodHandle& trap_method, int trap_bci, TRAPS) {\n+void InterpreterRuntime::note_trap_inner(JavaThread* current, int reason,\n+                                         const methodHandle& trap_method, int trap_bci) {\n@@ -318,0 +318,2 @@\n+      ExceptionMark em(current);\n+      JavaThread* THREAD = current; \/\/ for exception macros\n@@ -338,1 +340,1 @@\n-void InterpreterRuntime::note_trap(JavaThread* thread, int reason, TRAPS) {\n+void InterpreterRuntime::note_trap(JavaThread* current, int reason) {\n@@ -340,2 +342,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  methodHandle trap_method(thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  methodHandle trap_method(current, last_frame.method());\n@@ -343,1 +345,1 @@\n-  note_trap_inner(thread, reason, trap_method, trap_bci, THREAD);\n+  note_trap_inner(current, reason, trap_method, trap_bci);\n@@ -366,1 +368,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* current))\n@@ -375,1 +377,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* current))\n@@ -386,1 +388,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* thread, char* name, char* message))\n+JRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* current, char* name, char* message))\n@@ -391,1 +393,1 @@\n-      note_trap(thread, Deoptimization::Reason_div0_check, CHECK);\n+      note_trap(current, Deoptimization::Reason_div0_check);\n@@ -393,1 +395,1 @@\n-      note_trap(thread, Deoptimization::Reason_null_check, CHECK);\n+      note_trap(current, Deoptimization::Reason_null_check);\n@@ -397,2 +399,2 @@\n-  Handle exception = Exceptions::new_exception(thread, s, message);\n-  thread->set_vm_result(exception());\n+  Handle exception = Exceptions::new_exception(current, s, message);\n+  current->set_vm_result(exception());\n@@ -402,1 +404,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* thread, char* name, oopDesc* obj))\n+JRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* current, char* name, oopDesc* obj))\n@@ -404,1 +406,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -409,1 +411,1 @@\n-    note_trap(thread, Deoptimization::Reason_class_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_class_check);\n@@ -412,2 +414,2 @@\n-  Handle exception = Exceptions::new_exception(thread, s, klass_name);\n-  thread->set_vm_result(exception());\n+  Handle exception = Exceptions::new_exception(current, s, klass_name);\n+  current->set_vm_result(exception());\n@@ -416,1 +418,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index))\n+JRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* current, arrayOopDesc* a, jint index))\n@@ -418,1 +420,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -423,1 +425,1 @@\n-    note_trap(thread, Deoptimization::Reason_range_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_range_check);\n@@ -430,1 +432,1 @@\n-  JavaThread* thread, oopDesc* obj))\n+  JavaThread* current, oopDesc* obj))\n@@ -433,1 +435,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -435,1 +437,1 @@\n-    thread, obj->klass());\n+    current, obj->klass());\n@@ -438,1 +440,1 @@\n-    note_trap(thread, Deoptimization::Reason_class_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_class_check);\n@@ -453,1 +455,1 @@\n-JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* thread, oopDesc* exception))\n+JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* current, oopDesc* exception))\n@@ -457,1 +459,1 @@\n-  StackWatermarkSet::after_unwind(thread);\n+  StackWatermarkSet::after_unwind(current);\n@@ -459,4 +461,4 @@\n-  LastFrameAccessor last_frame(thread);\n-  Handle             h_exception(thread, exception);\n-  methodHandle       h_method   (thread, last_frame.method());\n-  constantPoolHandle h_constants(thread, h_method->constants());\n+  LastFrameAccessor last_frame(current);\n+  Handle             h_exception(current, exception);\n+  methodHandle       h_method   (current, last_frame.method());\n+  constantPoolHandle h_constants(current, h_method->constants());\n@@ -467,1 +469,1 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0) {\n+  if (current->frames_to_pop_failed_realloc() > 0) {\n@@ -470,2 +472,2 @@\n-    thread->dec_frames_to_pop_failed_realloc();\n-    thread->set_vm_result(h_exception());\n+    current->dec_frames_to_pop_failed_realloc();\n+    current->set_vm_result(h_exception());\n@@ -475,1 +477,1 @@\n-    thread->set_do_not_unlock_if_synchronized(true);\n+    current->set_do_not_unlock_if_synchronized(true);\n@@ -483,1 +485,1 @@\n-  if (thread->do_not_unlock_if_synchronized()) {\n+  if (current->do_not_unlock_if_synchronized()) {\n@@ -486,1 +488,1 @@\n-    thread->set_vm_result(exception);\n+    current->set_vm_result(exception);\n@@ -501,1 +503,1 @@\n-      ResourceMark rm(thread);\n+      ResourceMark rm(current);\n@@ -505,1 +507,1 @@\n-                   h_method->print_value_string(), current_bci, p2i(thread), thread->name());\n+                   h_method->print_value_string(), current_bci, p2i(current), current->name());\n@@ -538,1 +540,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -550,1 +552,1 @@\n-    JvmtiExport::post_exception_throw(thread, h_method(), last_frame.bcp(), h_exception());\n+    JvmtiExport::post_exception_throw(current, h_method(), last_frame.bcp(), h_exception());\n@@ -555,1 +557,1 @@\n-  if (handler_bci < 0 || !thread->stack_overflow_state()->reguard_stack((address) &continuation)) {\n+  if (handler_bci < 0 || !current->stack_overflow_state()->reguard_stack((address) &continuation)) {\n@@ -568,1 +570,1 @@\n-    set_bcp_and_mdp(handler_pc, thread);\n+    set_bcp_and_mdp(handler_pc, current);\n@@ -578,1 +580,1 @@\n-    JvmtiExport::notice_unwind_due_to_exception(thread, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n+    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n@@ -581,1 +583,1 @@\n-  thread->set_vm_result(h_exception());\n+  current->set_vm_result(h_exception());\n@@ -586,2 +588,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* thread))\n-  assert(thread->has_pending_exception(), \"must only ne called if there's an exception pending\");\n+JRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* current))\n+  assert(current->has_pending_exception(), \"must only be called if there's an exception pending\");\n@@ -592,1 +594,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* current))\n@@ -602,1 +604,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* current,\n@@ -604,1 +606,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -606,1 +608,1 @@\n-  methodHandle m(thread, missingMethod);\n+  methodHandle m(current, missingMethod);\n@@ -610,1 +612,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* current,\n@@ -613,2 +615,2 @@\n-  ResourceMark rm(thread);\n-  methodHandle mh = methodHandle(thread, missingMethod);\n+  ResourceMark rm(current);\n+  methodHandle mh = methodHandle(current, missingMethod);\n@@ -619,1 +621,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* current))\n@@ -623,1 +625,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* current,\n@@ -626,1 +628,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -636,1 +638,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_NullPointerException(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_NullPointerException(JavaThread* current))\n@@ -644,2 +646,1 @@\n-void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {\n-  Thread* THREAD = thread;\n+void InterpreterRuntime::resolve_get_put(JavaThread* current, Bytecodes::Code bytecode) {\n@@ -648,3 +649,3 @@\n-  LastFrameAccessor last_frame(thread);\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n-  methodHandle m(thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n+  methodHandle m(current, last_frame.method());\n@@ -656,1 +657,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -724,1 +726,1 @@\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))\n+JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, BasicObjectLock* elem))\n@@ -726,1 +728,1 @@\n-  thread->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -731,1 +733,1 @@\n-  Handle h_obj(thread, elem->obj());\n+  Handle h_obj(current, elem->obj());\n@@ -734,1 +736,1 @@\n-  ObjectSynchronizer::enter(h_obj, elem->lock(), thread);\n+  ObjectSynchronizer::enter(h_obj, elem->lock(), current);\n@@ -738,1 +740,1 @@\n-  thread->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -761,1 +763,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* current))\n@@ -766,1 +768,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* current))\n@@ -773,1 +775,1 @@\n-  Handle exception(thread, thread->vm_result());\n+  Handle exception(current, current->vm_result());\n@@ -775,1 +777,1 @@\n-  thread->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n+  current->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n@@ -781,1 +783,1 @@\n-  thread->set_vm_result(exception());\n+  current->set_vm_result(exception());\n@@ -788,1 +790,1 @@\n-JRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* thread, Method* method, address bcp))\n+JRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* current, Method* method, address bcp))\n@@ -792,1 +794,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code))\n+JRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* current, Method* method, address bcp, Bytecodes::Code new_code))\n@@ -796,2 +798,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* thread, Method* method, address bcp))\n-  JvmtiExport::post_raw_breakpoint(thread, method, bcp);\n+JRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* current, Method* method, address bcp))\n+  JvmtiExport::post_raw_breakpoint(current, method, bcp);\n@@ -800,3 +802,2 @@\n-void InterpreterRuntime::resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode) {\n-  Thread* THREAD = thread;\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::resolve_invoke(JavaThread* current, Bytecodes::Code bytecode) {\n+  LastFrameAccessor last_frame(current);\n@@ -804,1 +805,1 @@\n-  Handle receiver(thread, NULL);\n+  Handle receiver(current, NULL);\n@@ -807,2 +808,2 @@\n-    ResourceMark rm(thread);\n-    methodHandle m (thread, last_frame.method());\n+    ResourceMark rm(current);\n+    methodHandle m (current, last_frame.method());\n@@ -811,1 +812,1 @@\n-    receiver = Handle(thread, last_frame.callee_receiver(signature));\n+    receiver = Handle(current, last_frame.callee_receiver(signature));\n@@ -822,1 +823,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -827,1 +828,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -832,1 +834,1 @@\n-      resolved_method = methodHandle(THREAD, info.resolved_method()->get_new_method());\n+      resolved_method = methodHandle(current, info.resolved_method()->get_new_method());\n@@ -834,1 +836,1 @@\n-      resolved_method = methodHandle(THREAD, info.resolved_method());\n+      resolved_method = methodHandle(current, info.resolved_method());\n@@ -899,2 +901,1 @@\n-void InterpreterRuntime::resolve_invokehandle(JavaThread* thread) {\n-  Thread* THREAD = thread;\n+void InterpreterRuntime::resolve_invokehandle(JavaThread* current) {\n@@ -902,1 +903,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -906,1 +907,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -908,1 +909,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -919,3 +921,2 @@\n-void InterpreterRuntime::resolve_invokedynamic(JavaThread* thread) {\n-  Thread* THREAD = thread;\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::resolve_invokedynamic(JavaThread* current) {\n+  LastFrameAccessor last_frame(current);\n@@ -926,1 +927,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -929,1 +930,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -941,1 +943,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {\n+JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* current, Bytecodes::Code bytecode)) {\n@@ -947,1 +949,1 @@\n-    resolve_get_put(thread, bytecode);\n+    resolve_get_put(current, bytecode);\n@@ -953,1 +955,1 @@\n-    resolve_invoke(thread, bytecode);\n+    resolve_invoke(current, bytecode);\n@@ -956,1 +958,1 @@\n-    resolve_invokehandle(thread);\n+    resolve_invokehandle(current);\n@@ -959,1 +961,1 @@\n-    resolve_invokedynamic(thread);\n+    resolve_invokedynamic(current);\n@@ -972,1 +974,1 @@\n-nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp) {\n+nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* current, address branch_bcp) {\n@@ -974,1 +976,1 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n@@ -977,1 +979,1 @@\n-  nmethod* nm = frequency_counter_overflow_inner(thread, branch_bcp);\n+  nmethod* nm = frequency_counter_overflow_inner(current, branch_bcp);\n@@ -985,1 +987,1 @@\n-    LastFrameAccessor last_frame(thread);\n+    LastFrameAccessor last_frame(current);\n@@ -997,1 +999,1 @@\n-  if (nm != NULL && thread->is_interp_only_mode()) {\n+  if (nm != NULL && current->is_interp_only_mode()) {\n@@ -1017,1 +1019,1 @@\n-          InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp))\n+          InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* current, address branch_bcp))\n@@ -1020,1 +1022,1 @@\n-  UnlockFlagSaver fs(thread);\n+  UnlockFlagSaver fs(current);\n@@ -1022,1 +1024,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -1024,1 +1026,1 @@\n-  methodHandle method(thread, last_frame.method());\n+  methodHandle method(current, last_frame.method());\n@@ -1028,1 +1030,1 @@\n-  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, CHECK_NULL);\n@@ -1051,1 +1053,1 @@\n-          objects_to_revoke->append(Handle(THREAD, kptr->obj()));\n+          objects_to_revoke->append(Handle(current, kptr->obj()));\n@@ -1054,1 +1056,1 @@\n-      BiasedLocking::revoke(objects_to_revoke, thread);\n+      BiasedLocking::revoke(objects_to_revoke, current);\n@@ -1097,1 +1099,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* thread, int return_bci))\n+JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* current, int return_bci))\n@@ -1099,2 +1101,2 @@\n-  ResourceMark rm(thread);\n-  LastFrameAccessor last_frame(thread);\n+  ResourceMark rm(current);\n+  LastFrameAccessor last_frame(current);\n@@ -1117,2 +1119,2 @@\n-JRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* thread, Method* m))\n-  return Method::build_method_counters(thread, m);\n+JRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* current, Method* m))\n+  return Method::build_method_counters(current, m);\n@@ -1122,1 +1124,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* current))\n@@ -1134,1 +1136,1 @@\n-    StackWatermarkSet::before_unwind(thread);\n+    StackWatermarkSet::before_unwind(current);\n@@ -1139,2 +1141,2 @@\n-    LastFrameAccessor last_frame(thread);\n-    JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());\n+    LastFrameAccessor last_frame(current);\n+    JvmtiExport::at_single_stepping_point(current, last_frame.method(), last_frame.bcp());\n@@ -1144,1 +1146,1 @@\n-JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n+JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* current))\n@@ -1152,1 +1154,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -1155,2 +1157,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,\n-ConstantPoolCacheEntry *cp_entry))\n+JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *current, oopDesc* obj,\n+                                                      ConstantPoolCacheEntry *cp_entry))\n@@ -1165,1 +1167,1 @@\n-  HandleMark hm(thread);\n+  HandleMark hm(current);\n@@ -1170,1 +1172,1 @@\n-    h_obj = Handle(thread, obj);\n+    h_obj = Handle(current, obj);\n@@ -1174,2 +1176,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n@@ -1178,2 +1180,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,\n-  oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))\n+JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread* current, oopDesc* obj,\n+                                                            ConstantPoolCacheEntry *cp_entry, jvalue *value))\n@@ -1205,1 +1207,1 @@\n-  HandleMark hm(thread);\n+  HandleMark hm(current);\n@@ -1227,1 +1229,1 @@\n-    h_obj = Handle(thread, obj);\n+    h_obj = Handle(current, obj);\n@@ -1230,2 +1232,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_raw_field_modification(thread, last_frame.method(), last_frame.bcp(), ik, h_obj,\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_raw_field_modification(current, last_frame.method(), last_frame.bcp(), ik, h_obj,\n@@ -1235,3 +1237,3 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread *thread))\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_method_entry(thread, last_frame.method(), last_frame.get_frame());\n+JRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread *current))\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_method_entry(current, last_frame.method(), last_frame.get_frame());\n@@ -1244,3 +1246,3 @@\n-JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_method_exit(thread, last_frame.method(), last_frame.get_frame());\n+JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *current))\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_method_exit(current, last_frame.method(), last_frame.get_frame());\n@@ -1446,2 +1448,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n@@ -1462,1 +1464,1 @@\n-JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address))\n+JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* current, void* src_address, void* dest_address))\n@@ -1467,1 +1469,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -1470,1 +1472,1 @@\n-  methodHandle mh(thread, last_frame.method());\n+  methodHandle mh(current, last_frame.method());\n@@ -1486,1 +1488,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* thread, address member_name,\n+JRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* current, address member_name,\n@@ -1503,1 +1505,1 @@\n-    thread->set_vm_result(member_name_oop);\n+    current->set_vm_result(member_name_oop);\n@@ -1505,1 +1507,1 @@\n-    thread->set_vm_result(NULL);\n+    current->set_vm_result(NULL);\n@@ -1515,2 +1517,2 @@\n-JRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))\n-  LastFrameAccessor last_frame(thread);\n+JRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* current, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))\n+  LastFrameAccessor last_frame(current);\n@@ -1518,1 +1520,1 @@\n-  methodHandle mh(thread, last_frame.method());\n+  methodHandle mh(current, last_frame.method());\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":188,"deletions":186,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -48,4 +48,4 @@\n-  static void      set_bcp_and_mdp(address bcp, JavaThread*thread);\n-  static void      note_trap_inner(JavaThread* thread, int reason,\n-                                   const methodHandle& trap_method, int trap_bci, TRAPS);\n-  static void      note_trap(JavaThread *thread, int reason, TRAPS);\n+  static void      set_bcp_and_mdp(address bcp, JavaThread* current);\n+  static void      note_trap_inner(JavaThread* current, int reason,\n+                                   const methodHandle& trap_method, int trap_bci);\n+  static void      note_trap(JavaThread* current, int reason);\n@@ -54,1 +54,1 @@\n-  static nmethod* frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp);\n+  static nmethod* frequency_counter_overflow_inner(JavaThread* current, address branch_bcp);\n@@ -58,2 +58,2 @@\n-  static void    ldc           (JavaThread* thread, bool wide);\n-  static void    resolve_ldc   (JavaThread* thread, Bytecodes::Code bytecode);\n+  static void    ldc           (JavaThread* current, bool wide);\n+  static void    resolve_ldc   (JavaThread* current, Bytecodes::Code bytecode);\n@@ -62,5 +62,5 @@\n-  static void    _new          (JavaThread* thread, ConstantPool* pool, int index);\n-  static void    newarray      (JavaThread* thread, BasicType type, jint size);\n-  static void    anewarray     (JavaThread* thread, ConstantPool* pool, int index, jint size);\n-  static void    multianewarray(JavaThread* thread, jint* first_size_address);\n-  static void    register_finalizer(JavaThread* thread, oopDesc* obj);\n+  static void    _new          (JavaThread* current, ConstantPool* pool, int index);\n+  static void    newarray      (JavaThread* current, BasicType type, jint size);\n+  static void    anewarray     (JavaThread* current, ConstantPool* pool, int index, jint size);\n+  static void    multianewarray(JavaThread* current, jint* first_size_address);\n+  static void    register_finalizer(JavaThread* current, oopDesc* obj);\n@@ -69,1 +69,1 @@\n-  static void    quicken_io_cc(JavaThread* thread);\n+  static void    quicken_io_cc(JavaThread* current);\n@@ -72,3 +72,3 @@\n-  static void    throw_AbstractMethodError(JavaThread* thread);\n-  static void    throw_AbstractMethodErrorWithMethod(JavaThread* thread, Method* oop);\n-  static void    throw_AbstractMethodErrorVerbose(JavaThread* thread,\n+  static void    throw_AbstractMethodError(JavaThread* current);\n+  static void    throw_AbstractMethodErrorWithMethod(JavaThread* current, Method* oop);\n+  static void    throw_AbstractMethodErrorVerbose(JavaThread* current,\n@@ -78,2 +78,2 @@\n-  static void    throw_IncompatibleClassChangeError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,\n+  static void    throw_IncompatibleClassChangeError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeErrorVerbose(JavaThread* current,\n@@ -82,9 +82,9 @@\n-  static void    throw_StackOverflowError(JavaThread* thread);\n-  static void    throw_delayed_StackOverflowError(JavaThread* thread);\n-  static void    throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index);\n-  static void    throw_ClassCastException(JavaThread* thread, oopDesc* obj);\n-  static void    throw_NullPointerException(JavaThread* thread);\n-\n-  static void    create_exception(JavaThread* thread, char* name, char* message);\n-  static void    create_klass_exception(JavaThread* thread, char* name, oopDesc* obj);\n-  static address exception_handler_for_exception(JavaThread* thread, oopDesc* exception);\n+  static void    throw_StackOverflowError(JavaThread* current);\n+  static void    throw_delayed_StackOverflowError(JavaThread* current);\n+  static void    throw_ArrayIndexOutOfBoundsException(JavaThread* current, arrayOopDesc* a, jint index);\n+  static void    throw_ClassCastException(JavaThread* current, oopDesc* obj);\n+  static void    throw_NullPointerException(JavaThread* current);\n+\n+  static void    create_exception(JavaThread* current, char* name, char* message);\n+  static void    create_klass_exception(JavaThread* current, char* name, oopDesc* obj);\n+  static address exception_handler_for_exception(JavaThread* current, oopDesc* exception);\n@@ -92,1 +92,1 @@\n-  static void    member_name_arg_or_null(JavaThread* thread, address dmh, Method* m, address bcp);\n+  static void    member_name_arg_or_null(JavaThread* current, address dmh, Method* m, address bcp);\n@@ -94,1 +94,1 @@\n-  static void    throw_pending_exception(JavaThread* thread);\n+  static void    throw_pending_exception(JavaThread* current);\n@@ -96,1 +96,1 @@\n-  static void resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode);\n+  static void resolve_from_cache(JavaThread* current, Bytecodes::Code bytecode);\n@@ -99,1 +99,1 @@\n-  static void resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode);\n+  static void resolve_get_put(JavaThread* current, Bytecodes::Code bytecode);\n@@ -102,3 +102,3 @@\n-  static void resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode);\n-  static void resolve_invokehandle (JavaThread* thread);\n-  static void resolve_invokedynamic(JavaThread* thread);\n+  static void resolve_invoke(JavaThread* current, Bytecodes::Code bytecode);\n+  static void resolve_invokehandle (JavaThread* current);\n+  static void resolve_invokedynamic(JavaThread* current);\n@@ -108,1 +108,1 @@\n-  static void    monitorenter(JavaThread* thread, BasicObjectLock* elem);\n+  static void    monitorenter(JavaThread* current, BasicObjectLock* elem);\n@@ -111,2 +111,2 @@\n-  static void    throw_illegal_monitor_state_exception(JavaThread* thread);\n-  static void    new_illegal_monitor_state_exception(JavaThread* thread);\n+  static void    throw_illegal_monitor_state_exception(JavaThread* current);\n+  static void    new_illegal_monitor_state_exception(JavaThread* current);\n@@ -115,3 +115,3 @@\n-  static void _breakpoint(JavaThread* thread, Method* method, address bcp);\n-  static Bytecodes::Code get_original_bytecode_at(JavaThread* thread, Method* method, address bcp);\n-  static void            set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code);\n+  static void _breakpoint(JavaThread* current, Method* method, address bcp);\n+  static Bytecodes::Code get_original_bytecode_at(JavaThread* current, Method* method, address bcp);\n+  static void            set_original_bytecode_at(JavaThread* current, Method* method, address bcp, Bytecodes::Code new_code);\n@@ -120,2 +120,2 @@\n-  static void    at_safepoint(JavaThread* thread);\n-  static void    at_unwind(JavaThread* thread);\n+  static void    at_safepoint(JavaThread* current);\n+  static void    at_unwind(JavaThread* current);\n@@ -124,1 +124,1 @@\n-  static void post_field_access(JavaThread *thread, oopDesc* obj,\n+  static void post_field_access(JavaThread* current, oopDesc* obj,\n@@ -126,1 +126,1 @@\n-  static void post_field_modification(JavaThread *thread, oopDesc* obj,\n+  static void post_field_modification(JavaThread* current, oopDesc* obj,\n@@ -128,2 +128,2 @@\n-  static void post_method_entry(JavaThread *thread);\n-  static void post_method_exit (JavaThread *thread);\n+  static void post_method_entry(JavaThread* current);\n+  static void post_method_exit (JavaThread* current);\n@@ -133,2 +133,2 @@\n-  static void prepare_native_call(JavaThread* thread, Method* method);\n-  static address slow_signature_handler(JavaThread* thread,\n+  static void prepare_native_call(JavaThread* current, Method* method);\n+  static address slow_signature_handler(JavaThread* current,\n@@ -140,1 +140,1 @@\n-  static void popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address);\n+  static void popframe_move_outgoing_args(JavaThread* current, void* src_address, void* dest_address);\n@@ -144,1 +144,1 @@\n-  static intptr_t trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2) PRODUCT_RETURN0;\n+  static intptr_t trace_bytecode(JavaThread* current, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2) PRODUCT_RETURN0;\n@@ -153,1 +153,1 @@\n-  static nmethod* frequency_counter_overflow(JavaThread* thread, address branch_bcp);\n+  static nmethod* frequency_counter_overflow(JavaThread* current, address branch_bcp);\n@@ -157,1 +157,1 @@\n-  static void    update_mdp_for_ret(JavaThread* thread, int bci);\n+  static void    update_mdp_for_ret(JavaThread* current, int bci);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail))\n@@ -126,1 +126,1 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -129,1 +129,1 @@\n-    RetryableAllocationMark ram(thread, null_on_fail);\n+    RetryableAllocationMark ram(current, null_on_fail);\n@@ -144,1 +144,1 @@\n-    thread->set_vm_result(obj);\n+    current->set_vm_result(obj);\n@@ -147,1 +147,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -150,1 +150,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* current, Klass* array_klass, jint length, bool null_on_fail))\n@@ -159,1 +159,1 @@\n-    RetryableAllocationMark ram(thread, null_on_fail);\n+    RetryableAllocationMark ram(current, null_on_fail);\n@@ -162,1 +162,1 @@\n-    Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, array_klass->klass_holder()); \/\/ keep the klass alive\n@@ -164,1 +164,1 @@\n-    RetryableAllocationMark ram(thread, null_on_fail);\n+    RetryableAllocationMark ram(current, null_on_fail);\n@@ -167,1 +167,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -177,1 +177,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm(current);\n@@ -185,1 +185,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -188,1 +188,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail))\n@@ -191,2 +191,2 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n-  RetryableAllocationMark ram(thread, null_on_fail);\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n+  RetryableAllocationMark ram(current, null_on_fail);\n@@ -194,1 +194,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -197,2 +197,2 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))\n-  RetryableAllocationMark ram(thread, null_on_fail);\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail))\n+  RetryableAllocationMark ram(current, null_on_fail);\n@@ -200,1 +200,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -203,1 +203,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail))\n@@ -207,1 +207,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -210,1 +210,1 @@\n-  RetryableAllocationMark ram(thread, null_on_fail);\n+  RetryableAllocationMark ram(current, null_on_fail);\n@@ -227,1 +227,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -248,1 +248,1 @@\n-JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*& cm))\n+JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* current, oopDesc* ex, address pc, CompiledMethod*& cm))\n@@ -250,1 +250,1 @@\n-  thread->set_is_method_handle_return(false);\n+  current->set_is_method_handle_return(false);\n@@ -252,1 +252,1 @@\n-  Handle exception(thread, ex);\n+  Handle exception(current, ex);\n@@ -257,2 +257,2 @@\n-    RegisterMap map(thread, false);\n-    frame exception_frame = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false);\n+    frame exception_frame = current->last_frame().sender(&map);\n@@ -277,1 +277,1 @@\n-                 cm->method()->print_value_string(), p2i(pc), p2i(thread));\n+                 cm->method()->print_value_string(), p2i(pc), p2i(current));\n@@ -286,1 +286,1 @@\n-  bool guard_pages_enabled = thread->stack_overflow_state()->reguard_stack_if_needed();\n+  bool guard_pages_enabled = current->stack_overflow_state()->reguard_stack_if_needed();\n@@ -297,2 +297,2 @@\n-    RegisterMap reg_map(thread);\n-    frame stub_frame = thread->last_frame();\n+    RegisterMap reg_map(current);\n+    frame stub_frame = current->last_frame();\n@@ -304,1 +304,1 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);\n+    Deoptimization::deoptimize_frame(current, caller_frame.id(), Deoptimization::Reason_constraint);\n@@ -315,1 +315,1 @@\n-      thread->set_is_method_handle_return(cm->is_method_handle_return(pc));\n+      current->set_is_method_handle_return(cm->is_method_handle_return(pc));\n@@ -333,1 +333,1 @@\n-    thread->clear_exception_oop_and_pc();\n+    current->clear_exception_oop_and_pc();\n@@ -338,2 +338,2 @@\n-    thread->set_exception_oop(exception());\n-    thread->set_exception_pc(pc);\n+    current->set_exception_oop(exception());\n+    current->set_exception_pc(pc);\n@@ -353,1 +353,1 @@\n-  thread->set_is_method_handle_return(cm->is_method_handle_return(pc));\n+  current->set_is_method_handle_return(cm->is_method_handle_return(pc));\n@@ -359,1 +359,1 @@\n-                         p2i(thread), p2i(continuation), p2i(pc));\n+                         p2i(current), p2i(continuation), p2i(pc));\n@@ -370,3 +370,3 @@\n-address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {\n-  oop exception = thread->exception_oop();\n-  address pc = thread->exception_pc();\n+address JVMCIRuntime::exception_handler_for_pc(JavaThread* current) {\n+  oop exception = current->exception_oop();\n+  address pc = current->exception_pc();\n@@ -380,1 +380,1 @@\n-    continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);\n+    continuation = exception_handler_for_pc_helper(current, exception, pc, cm);\n@@ -394,2 +394,2 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))\n-  SharedRuntime::monitor_enter_helper(obj, lock, thread);\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* current, oopDesc* obj, BasicLock* lock))\n+  SharedRuntime::monitor_enter_helper(obj, lock, current);\n@@ -398,2 +398,2 @@\n-JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))\n-  assert(thread->last_Java_sp(), \"last_Java_sp must be set\");\n+JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* current, oopDesc* obj, BasicLock* lock))\n+  assert(current->last_Java_sp(), \"last_Java_sp must be set\");\n@@ -401,1 +401,1 @@\n-  SharedRuntime::monitor_exit_helper(obj, lock, thread);\n+  SharedRuntime::monitor_exit_helper(obj, lock, current);\n@@ -405,1 +405,1 @@\n-JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))\n+JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *current, oopDesc* obj))\n@@ -412,1 +412,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, false)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, false)) {\n@@ -421,1 +421,1 @@\n-JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))\n+JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *current, oopDesc* obj))\n@@ -424,1 +424,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, true)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, true)) {\n@@ -432,1 +432,1 @@\n-JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))\n+JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* current, const char* exception, const char* message))\n@@ -435,1 +435,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, symbol, message);\n@@ -440,1 +440,1 @@\n-JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))\n+JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* current, const char* exception, Klass* klass))\n@@ -442,1 +442,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -444,1 +444,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass->external_name());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, symbol, klass->external_name());\n@@ -449,1 +449,1 @@\n-JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))\n+JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* current, const char* exception, Klass* caster_klass, Klass* target_klass))\n@@ -451,1 +451,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -454,1 +454,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, symbol, message);\n@@ -520,1 +520,1 @@\n-JRT_ENTRY(jlong, JVMCIRuntime::invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument))\n+JRT_ENTRY(jlong, JVMCIRuntime::invoke_static_method_one_arg(JavaThread* current, Method* method, jlong argument))\n@@ -522,1 +522,1 @@\n-  HandleMark hm(THREAD);\n+  HandleMark hm(current);\n@@ -524,1 +524,1 @@\n-  methodHandle mh(thread, method);\n+  methodHandle mh(current, method);\n@@ -539,1 +539,1 @@\n-    thread->set_vm_result(result.get_oop());\n+    current->set_vm_result(result.get_oop());\n@@ -616,2 +616,2 @@\n-JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))\n-  ResourceMark rm;\n+JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* current, jlong where, jlong format, jlong value))\n+  ResourceMark rm(current);\n@@ -711,1 +711,1 @@\n-JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))\n+JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* current, oopDesc* obj))\n@@ -715,1 +715,1 @@\n-JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))\n+JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* current, int value))\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -357,5 +357,5 @@\n-  static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);\n-  static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);\n-  static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);\n-  static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);\n-  static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);\n+  static void new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail);\n+  static void new_array_common(JavaThread* current, Klass* klass, jint length, bool null_on_fail);\n+  static void new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail);\n+  static void dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail);\n+  static void dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail);\n@@ -371,5 +371,5 @@\n-  static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }\n-  static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }\n-  static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }\n-  static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }\n-  static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }\n+  static void new_instance(JavaThread* current, Klass* klass) { new_instance_common(current, klass, false); }\n+  static void new_array(JavaThread* current, Klass* klass, jint length) { new_array_common(current, klass, length, false); }\n+  static void new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims) { new_multi_array_common(current, klass, rank, dims, false); }\n+  static void dynamic_new_array(JavaThread* current, oopDesc* element_mirror, jint length) { dynamic_new_array_common(current, element_mirror, length, false); }\n+  static void dynamic_new_instance(JavaThread* current, oopDesc* type_mirror) { dynamic_new_instance_common(current, type_mirror, false); }\n@@ -387,7 +387,7 @@\n-  static jint identity_hash_code(JavaThread* thread, oopDesc* obj);\n-  static address exception_handler_for_pc(JavaThread* thread);\n-  static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);\n-  static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);\n-  static jboolean object_notify(JavaThread* thread, oopDesc* obj);\n-  static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);\n-  static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);\n+  static jint identity_hash_code(JavaThread* current, oopDesc* obj);\n+  static address exception_handler_for_pc(JavaThread* current);\n+  static void monitorenter(JavaThread* current, oopDesc* obj, BasicLock* lock);\n+  static void monitorexit (JavaThread* current, oopDesc* obj, BasicLock* lock);\n+  static jboolean object_notify(JavaThread* current, oopDesc* obj);\n+  static jboolean object_notifyAll(JavaThread* current, oopDesc* obj);\n+  static void vm_error(JavaThread* current, jlong where, jlong format, jlong value);\n@@ -410,1 +410,1 @@\n-  static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);\n+  static int throw_and_post_jvmti_exception(JavaThread* current, const char* exception, const char* message);\n@@ -412,2 +412,2 @@\n-  static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);\n-  static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);\n+  static int throw_klass_external_name_exception(JavaThread* current, const char* exception, Klass* klass);\n+  static int throw_class_cast_exception(JavaThread* current, const char* exception, Klass* caster_klass, Klass* target_klass);\n@@ -418,1 +418,1 @@\n-  static jlong invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument);\n+  static jlong invoke_static_method_one_arg(JavaThread* current, Method* method, jlong argument);\n@@ -421,1 +421,1 @@\n-  static jint test_deoptimize_call_int(JavaThread* thread, int value);\n+  static jint test_deoptimize_call_int(JavaThread* current, int value);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* current))\n@@ -205,1 +205,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -210,1 +210,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -219,1 +219,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -221,1 +221,1 @@\n-    thread->set_vm_result(result);\n+    current->set_vm_result(result);\n@@ -229,1 +229,1 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n@@ -233,1 +233,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -238,1 +238,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread* current))\n@@ -243,1 +243,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -257,1 +257,1 @@\n-    Handle holder(THREAD, array_type->klass_holder()); \/\/ keep the array klass alive\n+    Handle holder(current, array_type->klass_holder()); \/\/ keep the array klass alive\n@@ -266,2 +266,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -271,1 +271,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -275,1 +275,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread* current))\n@@ -280,1 +280,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -294,2 +294,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -300,1 +300,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -302,1 +302,1 @@\n-  oop result = thread->vm_result();\n+  oop result = current->vm_result();\n@@ -304,1 +304,1 @@\n-      is_deoptimized_caller_frame(thread)) {\n+      is_deoptimized_caller_frame(current)) {\n@@ -324,1 +324,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread* current))\n@@ -328,1 +328,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -333,1 +333,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -335,2 +335,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -340,1 +340,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread* current))\n@@ -344,1 +344,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -350,1 +350,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -352,2 +352,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -357,1 +357,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread* current))\n@@ -361,1 +361,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -368,1 +368,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -370,2 +370,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -375,1 +375,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread* current))\n@@ -379,1 +379,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -387,1 +387,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -389,2 +389,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -393,2 +393,2 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread* current))\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -405,1 +405,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -407,2 +407,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -411,1 +411,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread* current))\n@@ -418,1 +418,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, false)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, false)) {\n@@ -428,1 +428,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -433,1 +433,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread* current))\n@@ -436,1 +436,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, true)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, true)) {\n@@ -446,1 +446,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -1237,1 +1237,1 @@\n-JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &nm))\n+JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* current, nmethod* &nm))\n@@ -1242,1 +1242,1 @@\n-  assert(thread->exception_oop() != NULL, \"exception oop is found\");\n+  assert(current->exception_oop() != NULL, \"exception oop is found\");\n@@ -1245,2 +1245,2 @@\n-  Handle exception(thread, thread->exception_oop());\n-  address pc = thread->exception_pc();\n+  Handle exception(current, current->exception_oop());\n+  address pc = current->exception_pc();\n@@ -1252,1 +1252,1 @@\n-  thread->clear_exception_oop_and_pc();\n+  current->clear_exception_oop_and_pc();\n@@ -1288,1 +1288,1 @@\n-      deoptimize_caller_frame(thread);\n+      deoptimize_caller_frame(current);\n@@ -1295,1 +1295,1 @@\n-    bool force_unwind = !thread->stack_overflow_state()->reguard_stack();\n+    bool force_unwind = !current->stack_overflow_state()->reguard_stack();\n@@ -1299,2 +1299,2 @@\n-      RegisterMap map(thread, false);\n-      frame deoptee = thread->last_frame().sender(&map);\n+      RegisterMap map(current, false);\n+      frame deoptee = current->last_frame().sender(&map);\n@@ -1337,2 +1337,2 @@\n-    thread->set_exception_pc(pc);\n-    thread->set_exception_handler_pc(handler_address);\n+    current->set_exception_pc(pc);\n+    current->set_exception_handler_pc(handler_address);\n@@ -1341,1 +1341,1 @@\n-    thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -1345,1 +1345,1 @@\n-  thread->set_exception_oop(exception());\n+  current->set_exception_oop(exception());\n@@ -1357,1 +1357,1 @@\n-address OptoRuntime::handle_exception_C(JavaThread* thread) {\n+address OptoRuntime::handle_exception_C(JavaThread* current) {\n@@ -1371,1 +1371,1 @@\n-    handler_address = handle_exception_C_helper(thread, nm);\n+    handler_address = handle_exception_C_helper(current, nm);\n@@ -1380,2 +1380,2 @@\n-    RegisterMap map(thread, false);\n-    frame caller = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false);\n+    frame caller = current->last_frame().sender(&map);\n@@ -1537,1 +1537,1 @@\n-JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))\n+JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* current))\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  static void new_instance_C(Klass* instance_klass, JavaThread *thread);\n+  static void new_instance_C(Klass* instance_klass, JavaThread* current);\n@@ -161,2 +161,2 @@\n-  static void new_array_C(Klass* array_klass, int len, JavaThread *thread);\n-  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread *thread);\n+  static void new_array_C(Klass* array_klass, int len, JavaThread* current);\n+  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread* current);\n@@ -166,5 +166,5 @@\n-  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread *thread);\n-  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread *thread);\n-  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread *thread);\n-  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread *thread);\n-  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread *thread);\n+  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread* current);\n+  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread* current);\n+  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread* current);\n+  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread* current);\n+  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread* current);\n@@ -177,2 +177,2 @@\n-  static void monitor_notify_C(oopDesc* obj, JavaThread* thread);\n-  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* thread);\n+  static void monitor_notify_C(oopDesc* obj, JavaThread* current);\n+  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* current);\n@@ -186,2 +186,2 @@\n-  static address handle_exception_C       (JavaThread* thread);\n-  static address handle_exception_C_helper(JavaThread* thread, nmethod*& nm);\n+  static address handle_exception_C       (JavaThread* current);\n+  static address handle_exception_C_helper(JavaThread* current, nmethod*& nm);\n@@ -199,1 +199,1 @@\n-  static void register_finalizer(oopDesc* obj, JavaThread* thread);\n+  static void register_finalizer(oopDesc* obj, JavaThread* current);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1613,0 +1613,1 @@\n+  JavaThread* current = thread; \/\/ for JRT_BLOCK\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* thread, int exec_mode))\n+JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* current, int exec_mode))\n@@ -167,1 +167,1 @@\n-    tty->print_cr(\"Deoptimizing thread \" INTPTR_FORMAT, p2i(thread));\n+    tty->print_cr(\"Deoptimizing thread \" INTPTR_FORMAT, p2i(current));\n@@ -169,1 +169,1 @@\n-  thread->inc_in_deopt_handler();\n+  current->inc_in_deopt_handler();\n@@ -175,1 +175,1 @@\n-    StackWatermarkSet::after_unwind(thread);\n+    StackWatermarkSet::after_unwind(current);\n@@ -178,1 +178,1 @@\n-  return fetch_unroll_info_helper(thread, exec_mode);\n+  return fetch_unroll_info_helper(current, exec_mode);\n@@ -225,0 +225,1 @@\n+      JavaThread* current = thread; \/\/ For JRT_BLOCK\n@@ -327,1 +328,1 @@\n-Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {\n+Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* current, int exec_mode) {\n@@ -331,1 +332,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -339,3 +340,3 @@\n-  DeoptResourceMark* dmark = new DeoptResourceMark(thread);\n-  assert(thread->deopt_mark() == NULL, \"Pending deopt!\");\n-  thread->set_deopt_mark(dmark);\n+  DeoptResourceMark* dmark = new DeoptResourceMark(current);\n+  assert(current->deopt_mark() == NULL, \"Pending deopt!\");\n+  current->set_deopt_mark(dmark);\n@@ -343,3 +344,3 @@\n-  frame stub_frame = thread->last_frame(); \/\/ Makes stack walkable as side effect\n-  RegisterMap map(thread, true);\n-  RegisterMap dummy_map(thread, false);\n+  frame stub_frame = current->last_frame(); \/\/ Makes stack walkable as side effect\n+  RegisterMap map(current, true);\n+  RegisterMap dummy_map(current, false);\n@@ -349,1 +350,1 @@\n-  assert(thread->deopt_compiled_method() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_compiled_method() == NULL, \"Pending deopt!\");\n@@ -351,1 +352,1 @@\n-  thread->set_deopt_compiled_method(cm);\n+  current->set_deopt_compiled_method(cm);\n@@ -354,1 +355,1 @@\n-    thread->validate_frame_layout();\n+    current->validate_frame_layout();\n@@ -361,1 +362,1 @@\n-  vframe* vf = vframe::new_vframe(&deoptee, &map, thread);\n+  vframe* vf = vframe::new_vframe(&deoptee, &map, current);\n@@ -380,1 +381,1 @@\n-    realloc_failures = rematerialize_objects(thread, exec_mode, cm, deoptee, map, chunk, unused);\n+    realloc_failures = rematerialize_objects(current, exec_mode, cm, deoptee, map, chunk, unused);\n@@ -386,1 +387,1 @@\n-  revoke_from_deopt_handler(thread, deoptee, &map);\n+  revoke_from_deopt_handler(current, deoptee, &map);\n@@ -396,1 +397,1 @@\n-      && !EscapeBarrier::objs_are_deoptimized(thread, deoptee.id())) {\n+      && !EscapeBarrier::objs_are_deoptimized(current, deoptee.id())) {\n@@ -398,1 +399,1 @@\n-    restore_eliminated_locks(thread, chunk, realloc_failures, deoptee, exec_mode, unused);\n+    restore_eliminated_locks(current, chunk, realloc_failures, deoptee, exec_mode, unused);\n@@ -415,1 +416,1 @@\n-  vframeArray* array = create_vframeArray(thread, deoptee, &map, chunk, realloc_failures);\n+  vframeArray* array = create_vframeArray(current, deoptee, &map, chunk, realloc_failures);\n@@ -418,1 +419,1 @@\n-    pop_frames_failed_reallocs(thread, array);\n+    pop_frames_failed_reallocs(current, array);\n@@ -422,2 +423,2 @@\n-  assert(thread->vframe_array_head() == NULL, \"Pending deopt!\");\n-  thread->set_vframe_array_head(array);\n+  assert(current->vframe_array_head() == NULL, \"Pending deopt!\");\n+  current->set_vframe_array_head(array);\n@@ -429,1 +430,1 @@\n-  JvmtiDeferredUpdates::delete_updates_for_frame(thread, array->original().id());\n+  JvmtiDeferredUpdates::delete_updates_for_frame(current, array->original().id());\n@@ -475,2 +476,2 @@\n-  if (JvmtiExport::can_pop_frame() && thread->popframe_forcing_deopt_reexecution()) {\n-    popframe_extra_args = in_words(thread->popframe_preserved_args_size_in_words());\n+  if (JvmtiExport::can_pop_frame() && current->popframe_forcing_deopt_reexecution()) {\n+    popframe_extra_args = in_words(current->popframe_preserved_args_size_in_words());\n@@ -493,1 +494,1 @@\n-    methodHandle method(thread, deopt_sender.interpreter_frame_method());\n+    methodHandle method(current, deopt_sender.interpreter_frame_method());\n@@ -541,1 +542,1 @@\n-    methodHandle method(thread, array->element(0)->method());\n+    methodHandle method(current, array->element(0)->method());\n@@ -580,1 +581,1 @@\n-    thread->set_exception_oop(exceptionObject());\n+    current->set_exception_oop(exceptionObject());\n@@ -585,4 +586,4 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0 && exec_mode != Unpack_uncommon_trap) {\n-    assert(thread->has_pending_exception(), \"should have thrown OOME\");\n-    thread->set_exception_oop(thread->pending_exception());\n-    thread->clear_pending_exception();\n+  if (current->frames_to_pop_failed_realloc() > 0 && exec_mode != Unpack_uncommon_trap) {\n+    assert(current->has_pending_exception(), \"should have thrown OOME\");\n+    current->set_exception_oop(current->pending_exception());\n+    current->clear_pending_exception();\n@@ -593,2 +594,2 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0) {\n-    thread->set_pending_monitorenter(false);\n+  if (current->frames_to_pop_failed_realloc() > 0) {\n+    current->set_pending_monitorenter(false);\n@@ -1921,2 +1922,2 @@\n-JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {\n-  HandleMark hm(thread);\n+JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* current, jint trap_request)) {\n+  HandleMark hm(current);\n@@ -1928,1 +1929,1 @@\n-  thread->inc_in_deopt_handler();\n+  current->inc_in_deopt_handler();\n@@ -1933,1 +1934,1 @@\n-  RegisterMap reg_map(thread, true);\n+  RegisterMap reg_map(current, true);\n@@ -1935,1 +1936,1 @@\n-  RegisterMap reg_map(thread, UseBiasedLocking);\n+  RegisterMap reg_map(current, UseBiasedLocking);\n@@ -1937,1 +1938,1 @@\n-  frame stub_frame = thread->last_frame();\n+  frame stub_frame = current->last_frame();\n@@ -1944,1 +1945,1 @@\n-  Events::log_deopt_message(thread, \"Uncommon trap: trap_request=\" PTR32_FORMAT \" fr.pc=\" INTPTR_FORMAT \" relative=\" INTPTR_FORMAT,\n+  Events::log_deopt_message(current, \"Uncommon trap: trap_request=\" PTR32_FORMAT \" fr.pc=\" INTPTR_FORMAT \" relative=\" INTPTR_FORMAT,\n@@ -1957,1 +1958,1 @@\n-    vframe*  vf  = vframe::new_vframe(&fr, &reg_map, thread);\n+    vframe*  vf  = vframe::new_vframe(&fr, &reg_map, current);\n@@ -1973,1 +1974,1 @@\n-    methodHandle    trap_method(THREAD, trap_scope->method());\n+    methodHandle    trap_method(current, trap_scope->method());\n@@ -1976,1 +1977,1 @@\n-    jlong           speculation = thread->pending_failed_speculation();\n+    jlong           speculation = current->pending_failed_speculation();\n@@ -1978,1 +1979,1 @@\n-      nm->as_nmethod()->update_speculation(thread);\n+      nm->as_nmethod()->update_speculation(current);\n@@ -1985,1 +1986,1 @@\n-      thread->set_pending_monitorenter(true);\n+      current->set_pending_monitorenter(true);\n@@ -1989,1 +1990,1 @@\n-      thread->set_pending_transfer_to_interpreter(true);\n+      current->set_pending_transfer_to_interpreter(true);\n@@ -2004,1 +2005,1 @@\n-      profiled_method = methodHandle(THREAD, nm->method());\n+      profiled_method = methodHandle(current, nm->method());\n@@ -2013,1 +2014,1 @@\n-      get_method_data(thread, profiled_method, create_if_missing);\n+      get_method_data(current, profiled_method, create_if_missing);\n@@ -2018,1 +2019,1 @@\n-    Events::log_deopt_message(thread, \"Uncommon trap: reason=%s action=%s pc=\" INTPTR_FORMAT \" method=%s @ %d %s\",\n+    Events::log_deopt_message(current, \"Uncommon trap: reason=%s action=%s pc=\" INTPTR_FORMAT \" method=%s @ %d %s\",\n@@ -2041,1 +2042,1 @@\n-        constantPoolHandle constants (THREAD, trap_method->constants());\n+        constantPoolHandle constants (current, trap_method->constants());\n@@ -2118,1 +2119,1 @@\n-      constantPoolHandle constants(THREAD, trap_method->constants());\n+      constantPoolHandle constants(current, trap_method->constants());\n@@ -2230,1 +2231,1 @@\n-      assert(trap_mdo == get_method_data(thread, profiled_method, false), \"sanity\");\n+      assert(trap_mdo == get_method_data(current, profiled_method, false), \"sanity\");\n@@ -2471,1 +2472,1 @@\n-Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, jint trap_request, jint exec_mode) {\n+Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* current, jint trap_request, jint exec_mode) {\n@@ -2481,1 +2482,1 @@\n-    uncommon_trap_inner(thread, trap_request);\n+    uncommon_trap_inner(current, trap_request);\n@@ -2483,2 +2484,2 @@\n-  HandleMark hm(thread);\n-  return fetch_unroll_info_helper(thread, exec_mode);\n+  HandleMark hm(current);\n+  return fetch_unroll_info_helper(current, exec_mode);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":61,"deletions":60,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-  static UnrollBlock* fetch_unroll_info(JavaThread* thread, int exec_mode);\n+  static UnrollBlock* fetch_unroll_info(JavaThread* current, int exec_mode);\n@@ -301,1 +301,1 @@\n-  static UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index, jint exec_mode);\n+  static UnrollBlock* uncommon_trap(JavaThread* current, jint unloaded_class_index, jint exec_mode);\n@@ -303,1 +303,1 @@\n-  static void uncommon_trap_inner(JavaThread* thread, jint unloaded_class_index);\n+  static void uncommon_trap_inner(JavaThread* current, jint unloaded_class_index);\n@@ -468,1 +468,1 @@\n-  static UnrollBlock* fetch_unroll_info_helper(JavaThread* thread, int exec_mode);\n+  static UnrollBlock* fetch_unroll_info_helper(JavaThread* current, int exec_mode);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    assert(thread == Thread::current(), \"must be current thread\");\n@@ -318,3 +319,3 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n-    ThreadInVMfromJava __tiv(thread);                                \\\n-    VM_ENTRY_BASE(result_type, header, thread)                       \\\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n+    ThreadInVMfromJava __tiv(current);                               \\\n+    VM_ENTRY_BASE(result_type, header, current)                      \\\n@@ -345,3 +346,3 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n-    ThreadInVMfromJava __tiv(thread, false \/* check asyncs *\/);      \\\n-    VM_ENTRY_BASE(result_type, header, thread)                       \\\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n+    ThreadInVMfromJava __tiv(current, false \/* check asyncs *\/);     \\\n+    VM_ENTRY_BASE(result_type, header, current)                      \\\n@@ -354,2 +355,2 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n-    HandleMarkCleaner __hm(thread);\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current));       \\\n+    HandleMarkCleaner __hm(current);\n@@ -359,2 +360,2 @@\n-    ThreadInVMfromJava __tiv(thread);                                \\\n-    Thread* THREAD = thread;                                         \\\n+    ThreadInVMfromJava __tiv(current);                               \\\n+    Thread* THREAD = current;                                        \\\n@@ -365,2 +366,2 @@\n-    ThreadInVMfromJava __tiv(thread, false \/* check asyncs *\/);      \\\n-    Thread* THREAD = thread;                                         \\\n+    ThreadInVMfromJava __tiv(current, false \/* check asyncs *\/);     \\\n+    Thread* THREAD = current;                                        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thread, address return_address) {\n+address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* current, address return_address) {\n@@ -466,1 +466,1 @@\n-  assert(thread->frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), \"missed frames to pop?\");\n+  assert(current->frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), \"missed frames to pop?\");\n@@ -469,1 +469,1 @@\n-  thread->set_is_method_handle_return(false);\n+  current->set_is_method_handle_return(false);\n@@ -474,1 +474,1 @@\n-  thread->set_exception_pc(NULL);\n+  current->set_exception_pc(NULL);\n@@ -482,1 +482,1 @@\n-    thread->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n+    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n@@ -491,1 +491,1 @@\n-      StackOverflow* overflow_state = thread->stack_overflow_state();\n+      StackOverflow* overflow_state = current->stack_overflow_state();\n@@ -493,2 +493,2 @@\n-      if (overflow_state->reserved_stack_activation() != thread->stack_base()) {\n-        overflow_state->set_reserved_stack_activation(thread->stack_base());\n+      if (overflow_state->reserved_stack_activation() != current->stack_base()) {\n+        overflow_state->set_reserved_stack_activation(current->stack_base());\n@@ -537,2 +537,2 @@\n-JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))\n-  return raw_exception_handler_for_return_address(thread, return_address);\n+JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* current, address return_address))\n+  return raw_exception_handler_for_return_address(current, return_address);\n@@ -595,1 +595,1 @@\n-void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception) {\n+void SharedRuntime::throw_and_post_jvmti_exception(JavaThread* current, Handle h_exception) {\n@@ -597,2 +597,2 @@\n-    vframeStream vfst(thread, true);\n-    methodHandle method = methodHandle(thread, vfst.method());\n+    vframeStream vfst(current, true);\n+    methodHandle method = methodHandle(current, vfst.method());\n@@ -600,1 +600,1 @@\n-    JvmtiExport::post_exception_throw(thread, method(), bcp, h_exception());\n+    JvmtiExport::post_exception_throw(current, method(), bcp, h_exception());\n@@ -605,2 +605,2 @@\n-    vframeStream vfst(thread, true);\n-    methodHandle method = methodHandle(thread, vfst.method());\n+    vframeStream vfst(current, true);\n+    methodHandle method = methodHandle(current, vfst.method());\n@@ -613,1 +613,1 @@\n-        ResourceMark rm(thread);\n+        ResourceMark rm(current);\n@@ -624,1 +624,1 @@\n-  Exceptions::_throw(thread, __FILE__, __LINE__, h_exception);\n+  Exceptions::_throw(current, __FILE__, __LINE__, h_exception);\n@@ -627,3 +627,3 @@\n-void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message) {\n-  Handle h_exception = Exceptions::new_exception(thread, name, message);\n-  throw_and_post_jvmti_exception(thread, h_exception);\n+void SharedRuntime::throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message) {\n+  Handle h_exception = Exceptions::new_exception(current, name, message);\n+  throw_and_post_jvmti_exception(current, h_exception);\n@@ -755,1 +755,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* current))\n@@ -757,1 +757,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_AbstractMethodError());\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_AbstractMethodError());\n@@ -760,1 +760,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* current))\n@@ -762,1 +762,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError(), \"vtable stub\");\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IncompatibleClassChangeError(), \"vtable stub\");\n@@ -765,2 +765,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* thread))\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n+JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* current))\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n@@ -769,2 +769,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* thread))\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* current))\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n@@ -773,1 +773,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* current))\n@@ -776,1 +776,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n@@ -779,2 +779,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* thread))\n-  throw_StackOverflowError_common(thread, false);\n+JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* current))\n+  throw_StackOverflowError_common(current, false);\n@@ -783,2 +783,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* thread))\n-  throw_StackOverflowError_common(thread, true);\n+JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* current))\n+  throw_StackOverflowError_common(current, true);\n@@ -787,1 +787,1 @@\n-void SharedRuntime::throw_StackOverflowError_common(JavaThread* thread, bool delayed) {\n+void SharedRuntime::throw_StackOverflowError_common(JavaThread* current, bool delayed) {\n@@ -790,1 +790,1 @@\n-  Thread* THREAD = thread;\n+  Thread* THREAD = current; \/\/ For exception processing.\n@@ -797,1 +797,1 @@\n-  Handle exception (thread, exception_oop);\n+  Handle exception (current, exception_oop);\n@@ -803,1 +803,1 @@\n-  throw_and_post_jvmti_exception(thread, exception);\n+  throw_and_post_jvmti_exception(current, exception);\n@@ -806,1 +806,1 @@\n-address SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,\n+address SharedRuntime::continuation_for_implicit_exception(JavaThread* current,\n@@ -832,2 +832,2 @@\n-        assert(thread->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n-        Events::log_exception(thread, \"StackOverflowError at \" INTPTR_FORMAT, p2i(pc));\n+        assert(current->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n+        Events::log_exception(current, \"StackOverflowError at \" INTPTR_FORMAT, p2i(pc));\n@@ -850,1 +850,1 @@\n-            Events::log_exception(thread, \"AbstractMethodError at \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"AbstractMethodError at \" INTPTR_FORMAT, p2i(pc));\n@@ -856,1 +856,1 @@\n-            Events::log_exception(thread, \"NullPointerException at vtable entry \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException at vtable entry \" INTPTR_FORMAT, p2i(pc));\n@@ -879,1 +879,1 @@\n-            Events::log_exception(thread, \"NullPointerException in code blob at \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in code blob at \" INTPTR_FORMAT, p2i(pc));\n@@ -891,1 +891,1 @@\n-            Events::log_exception(thread, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n@@ -897,1 +897,1 @@\n-            Events::log_exception(thread, \"NullPointerException in MH adapter \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in MH adapter \" INTPTR_FORMAT, p2i(pc));\n@@ -937,1 +937,1 @@\n-      Events::log_exception(thread, \"Implicit null exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n+      Events::log_exception(current, \"Implicit null exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n@@ -943,1 +943,1 @@\n-      Events::log_exception(thread, \"Implicit division by zero exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n+      Events::log_exception(current, \"Implicit division by zero exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n@@ -977,1 +977,1 @@\n-JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))\n+JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* current, oopDesc* obj))\n@@ -1019,1 +1019,1 @@\n-    JavaThread* thread, Method* method))\n+    JavaThread* current, Method* method))\n@@ -1025,1 +1025,1 @@\n-      get_java_tid(thread),\n+      get_java_tid(current),\n@@ -1033,1 +1033,1 @@\n-    JavaThread* thread, Method* method))\n+    JavaThread* current, Method* method))\n@@ -1039,1 +1039,1 @@\n-      get_java_tid(thread),\n+      get_java_tid(current),\n@@ -1051,2 +1051,3 @@\n-Handle SharedRuntime::find_callee_info(JavaThread* thread, Bytecodes::Code& bc, CallInfo& callinfo, TRAPS) {\n-  ResourceMark rm(THREAD);\n+Handle SharedRuntime::find_callee_info(Bytecodes::Code& bc, CallInfo& callinfo, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1055,1 +1056,1 @@\n-  vframeStream vfst(thread, true);  \/\/ Do not skip and javaCalls\n+  vframeStream vfst(current, true);  \/\/ Do not skip and javaCalls\n@@ -1057,1 +1058,1 @@\n-  return find_callee_info_helper(thread, vfst, bc, callinfo, THREAD);\n+  return find_callee_info_helper(vfst, bc, callinfo, CHECK_NH);\n@@ -1076,3 +1077,1 @@\n-Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,\n-                                              vframeStream& vfst,\n-                                              Bytecodes::Code& bc,\n+Handle SharedRuntime::find_callee_info_helper(vframeStream& vfst, Bytecodes::Code& bc,\n@@ -1081,1 +1080,2 @@\n-  Handle nullHandle;  \/\/create a handy null handle for exception returns\n+  Handle nullHandle;  \/\/ create a handy null handle for exception returns\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1086,1 +1086,1 @@\n-  methodHandle caller(THREAD, vfst.method());\n+  methodHandle caller(current, vfst.method());\n@@ -1093,1 +1093,1 @@\n-  methodHandle attached_method(THREAD, extract_attached_method(vfst));\n+  methodHandle attached_method(current, extract_attached_method(vfst));\n@@ -1137,2 +1137,2 @@\n-    RegisterMap reg_map2(thread);\n-    frame stubFrame   = thread->last_frame();\n+    RegisterMap reg_map2(current);\n+    frame stubFrame   = current->last_frame();\n@@ -1150,1 +1150,1 @@\n-    receiver = Handle(THREAD, callerFrame.retrieve_receiver(&reg_map2));\n+    receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n@@ -1163,1 +1163,1 @@\n-    constantPoolHandle constants(THREAD, caller->constants());\n+    constantPoolHandle constants(current, caller->constants());\n@@ -1178,1 +1178,1 @@\n-      constantPoolHandle constants(THREAD, caller->constants());\n+      constantPoolHandle constants(current, caller->constants());\n@@ -1197,2 +1197,3 @@\n-methodHandle SharedRuntime::find_callee_method(JavaThread* thread, TRAPS) {\n-  ResourceMark rm(THREAD);\n+methodHandle SharedRuntime::find_callee_method(TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1202,1 +1203,1 @@\n-  vframeStream vfst(thread, true);  \/\/ Do not skip any javaCalls\n+  vframeStream vfst(current, true);  \/\/ Do not skip any javaCalls\n@@ -1208,2 +1209,2 @@\n-    RegisterMap reg_map(thread, false);\n-    frame fr = thread->last_frame();\n+    RegisterMap reg_map(current, false);\n+    frame fr = current->last_frame();\n@@ -1214,1 +1215,1 @@\n-    callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()->callee_method());\n+    callee_method = methodHandle(current, fr.entry_frame_call_wrapper()->callee_method());\n@@ -1218,2 +1219,2 @@\n-    find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));\n-    callee_method = methodHandle(THREAD, callinfo.selected_method());\n+    find_callee_info_helper(vfst, bc, callinfo, CHECK_(methodHandle()));\n+    callee_method = methodHandle(current, callinfo.selected_method());\n@@ -1226,3 +1227,1 @@\n-methodHandle SharedRuntime::resolve_helper(JavaThread *thread,\n-                                           bool is_virtual,\n-                                           bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, TRAPS) {\n@@ -1230,1 +1229,1 @@\n-  callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);\n+  callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n@@ -1247,1 +1246,1 @@\n-      callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);\n+      callee_method = resolve_sub_helper(is_virtual, is_optimized, THREAD);\n@@ -1338,7 +1337,5 @@\n-methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,\n-                                               bool is_virtual,\n-                                               bool is_optimized, TRAPS) {\n-\n-  ResourceMark rm(thread);\n-  RegisterMap cbl_map(thread, false);\n-  frame caller_frame = thread->last_frame().sender(&cbl_map);\n+methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n+  RegisterMap cbl_map(current, false);\n+  frame caller_frame = current->last_frame().sender(&cbl_map);\n@@ -1360,3 +1357,2 @@\n-  Handle receiver = find_callee_info(thread, invoke_code,\n-                                     call_info, CHECK_(methodHandle()));\n-  methodHandle callee_method(THREAD, call_info.selected_method());\n+  Handle receiver = find_callee_info(invoke_code, call_info, CHECK_(methodHandle()));\n+  methodHandle callee_method(current, call_info.selected_method());\n@@ -1380,1 +1376,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -1382,2 +1378,2 @@\n-      (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n-      Bytecodes::name(invoke_code));\n+               (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n+               Bytecodes::name(invoke_code));\n@@ -1392,1 +1388,1 @@\n-           callee_method->method_holder()->is_reentrant_initialization(thread),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n@@ -1440,1 +1436,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* current))\n@@ -1442,2 +1438,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1451,1 +1447,1 @@\n-    callee_method = SharedRuntime::handle_ic_miss_helper(thread, CHECK_NULL);\n+    callee_method = SharedRuntime::handle_ic_miss_helper(CHECK_NULL);\n@@ -1453,1 +1449,1 @@\n-    thread->set_vm_result_2(callee_method());\n+    current->set_vm_result_2(callee_method());\n@@ -1462,1 +1458,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* current))\n@@ -1472,2 +1468,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1479,1 +1475,1 @@\n-    Method* callee = thread->callee_target();\n+    Method* callee = current->callee_target();\n@@ -1481,2 +1477,2 @@\n-    thread->set_vm_result_2(callee);\n-    thread->set_callee_target(NULL);\n+    current->set_vm_result_2(callee);\n+    current->set_callee_target(NULL);\n@@ -1502,2 +1498,2 @@\n-    callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::reresolve_call_site(CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1511,1 +1507,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* current))\n@@ -1514,1 +1510,1 @@\n-  vframeStream vfst(thread, true);\n+  vframeStream vfst(current, true);\n@@ -1516,1 +1512,1 @@\n-  methodHandle caller(thread, vfst.method());\n+  methodHandle caller(current, vfst.method());\n@@ -1521,2 +1517,2 @@\n-  RegisterMap reg_map(thread);\n-  frame stubFrame = thread->last_frame();\n+  RegisterMap reg_map(current);\n+  frame stubFrame = current->last_frame();\n@@ -1530,1 +1526,1 @@\n-    methodHandle callee(thread, invoke.static_target(thread));\n+    methodHandle callee(current, invoke.static_target(current));\n@@ -1534,1 +1530,0 @@\n-      LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);\n@@ -1536,0 +1531,1 @@\n+      LinkResolver::throw_abstract_method_error(callee, recv_klass, CHECK_(res));\n@@ -1543,1 +1539,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread* current ))\n@@ -1546,2 +1542,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, false, false, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(false, false, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1556,1 +1552,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread* current))\n@@ -1559,2 +1555,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, true, false, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(true, false, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1570,1 +1566,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread* current))\n@@ -1573,2 +1569,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, true, true, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(true, true, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1661,2 +1657,3 @@\n-methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, TRAPS) {\n-  ResourceMark rm(thread);\n+methodHandle SharedRuntime::handle_ic_miss_helper(TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1668,2 +1665,1 @@\n-  Handle receiver = find_callee_info(thread, bc, call_info,\n-                                     CHECK_(methodHandle()));\n+  Handle receiver = find_callee_info(bc, call_info, CHECK_(methodHandle()));\n@@ -1681,1 +1677,1 @@\n-    methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_(methodHandle()));\n+    methodHandle callee_method = SharedRuntime::reresolve_call_site(CHECK_(methodHandle()));\n@@ -1683,3 +1679,3 @@\n-      RegisterMap reg_map(thread, false);\n-      frame caller_frame = thread->last_frame().sender(&reg_map);\n-      ResourceMark rm(thread);\n+      RegisterMap reg_map(current, false);\n+      frame caller_frame = current->last_frame().sender(&reg_map);\n+      ResourceMark rm(current);\n@@ -1694,1 +1690,1 @@\n-  methodHandle callee_method(thread, call_info.selected_method());\n+  methodHandle callee_method(current, call_info.selected_method());\n@@ -1701,1 +1697,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -1709,2 +1705,2 @@\n-    RegisterMap reg_map(thread, false);\n-    frame f = thread->last_frame().real_sender(&reg_map);\/\/ skip runtime stub\n+    RegisterMap reg_map(current, false);\n+    frame f = current->last_frame().real_sender(&reg_map);\/\/ skip runtime stub\n@@ -1727,2 +1723,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame caller_frame = thread->last_frame().sender(&reg_map);\n+  RegisterMap reg_map(current, false);\n+  frame caller_frame = current->last_frame().sender(&reg_map);\n@@ -1768,4 +1764,5 @@\n-methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, TRAPS) {\n-  ResourceMark rm(thread);\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+methodHandle SharedRuntime::reresolve_call_site(TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1852,1 +1849,1 @@\n-  methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));\n+  methodHandle callee_method = find_callee_method(CHECK_(methodHandle()));\n@@ -1859,1 +1856,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -2021,1 +2018,1 @@\n-                                                JavaThread* thread)) {\n+                                                JavaThread* current)) {\n@@ -2037,1 +2034,1 @@\n-                                        length, thread);\n+                                        length, current);\n@@ -2109,1 +2106,1 @@\n-void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {\n+void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* current) {\n@@ -2113,1 +2110,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;\n+    if (ObjectSynchronizer::quick_enter(obj, current, lock)) return;\n@@ -2124,1 +2121,1 @@\n-  ObjectSynchronizer::enter(h_obj, lock, thread);\n+  ObjectSynchronizer::enter(h_obj, lock, current);\n@@ -2130,2 +2127,2 @@\n-JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n-  SharedRuntime::monitor_enter_helper(obj, lock, thread);\n+JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current))\n+  SharedRuntime::monitor_enter_helper(obj, lock, current);\n@@ -2150,2 +2147,2 @@\n-JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n-  SharedRuntime::monitor_exit_helper(obj, lock, thread);\n+JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* current))\n+  SharedRuntime::monitor_exit_helper(obj, lock, current);\n@@ -3021,1 +3018,1 @@\n-JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *thread) )\n+JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *current) )\n@@ -3027,1 +3024,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -3037,1 +3034,1 @@\n-  frame fr = thread->last_frame();\n+  frame fr = current->last_frame();\n@@ -3141,2 +3138,2 @@\n-JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))\n-  StackOverflow* overflow_state = thread->stack_overflow_state();\n+JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* current))\n+  StackOverflow* overflow_state = current->stack_overflow_state();\n@@ -3144,1 +3141,1 @@\n-  overflow_state->set_reserved_stack_activation(thread->stack_base());\n+  overflow_state->set_reserved_stack_activation(current->stack_base());\n@@ -3147,2 +3144,2 @@\n-frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr) {\n-  ResourceMark rm(thread);\n+frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* current, frame fr) {\n+  ResourceMark rm(current);\n@@ -3198,1 +3195,1 @@\n-void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {\n+void SharedRuntime::on_slowpath_allocation_exit(JavaThread* current) {\n@@ -3204,1 +3201,1 @@\n-  oop new_obj = thread->vm_result();\n+  oop new_obj = current->vm_result();\n@@ -3208,1 +3205,1 @@\n-  bs->on_slowpath_allocation_exit(thread, new_obj);\n+  bs->on_slowpath_allocation_exit(current, new_obj);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":162,"deletions":165,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -55,3 +55,1 @@\n-  static methodHandle resolve_sub_helper(JavaThread *thread,\n-                                         bool is_virtual,\n-                                         bool is_optimized, TRAPS);\n+  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, TRAPS);\n@@ -186,2 +184,2 @@\n-  static address raw_exception_handler_for_return_address(JavaThread* thread, address return_address);\n-  static address exception_handler_for_return_address(JavaThread* thread, address return_address);\n+  static address raw_exception_handler_for_return_address(JavaThread* current, address return_address);\n+  static address exception_handler_for_return_address(JavaThread* current, address return_address);\n@@ -197,9 +195,9 @@\n-  static void    throw_AbstractMethodError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeError(JavaThread* thread);\n-  static void    throw_ArithmeticException(JavaThread* thread);\n-  static void    throw_NullPointerException(JavaThread* thread);\n-  static void    throw_NullPointerException_at_call(JavaThread* thread);\n-  static void    throw_StackOverflowError(JavaThread* thread);\n-  static void    throw_delayed_StackOverflowError(JavaThread* thread);\n-  static void    throw_StackOverflowError_common(JavaThread* thread, bool delayed);\n-  static address continuation_for_implicit_exception(JavaThread* thread,\n+  static void    throw_AbstractMethodError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeError(JavaThread* current);\n+  static void    throw_ArithmeticException(JavaThread* current);\n+  static void    throw_NullPointerException(JavaThread* current);\n+  static void    throw_NullPointerException_at_call(JavaThread* current);\n+  static void    throw_StackOverflowError(JavaThread* current);\n+  static void    throw_delayed_StackOverflowError(JavaThread* current);\n+  static void    throw_StackOverflowError_common(JavaThread* current, bool delayed);\n+  static address continuation_for_implicit_exception(JavaThread* current,\n@@ -211,1 +209,1 @@\n-  static void on_slowpath_allocation_exit(JavaThread* thread);\n+  static void on_slowpath_allocation_exit(JavaThread* current);\n@@ -213,2 +211,2 @@\n-  static void enable_stack_reserved_zone(JavaThread* thread);\n-  static frame look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr);\n+  static void enable_stack_reserved_zone(JavaThread* current);\n+  static frame look_for_reserved_stack_annotated_method(JavaThread* current, frame fr);\n@@ -262,2 +260,2 @@\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception);\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message = NULL);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Handle h_exception);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = NULL);\n@@ -319,3 +317,1 @@\n-  static methodHandle resolve_helper(JavaThread *thread,\n-                                     bool is_virtual,\n-                                     bool is_optimized, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, TRAPS);\n@@ -335,1 +331,1 @@\n-  static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);\n+  static methodHandle reresolve_call_site(TRAPS);\n@@ -339,1 +335,1 @@\n-  static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);\n+  static methodHandle handle_ic_miss_helper(TRAPS);\n@@ -342,1 +338,1 @@\n-  static methodHandle find_callee_method(JavaThread* thread, TRAPS);\n+  static methodHandle find_callee_method(TRAPS);\n@@ -349,7 +345,2 @@\n-  static Handle find_callee_info(JavaThread* thread,\n-                                 Bytecodes::Code& bc,\n-                                 CallInfo& callinfo, TRAPS);\n-  static Handle find_callee_info_helper(JavaThread* thread,\n-                                        vframeStream& vfst,\n-                                        Bytecodes::Code& bc,\n-                                        CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info(Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info_helper(vframeStream& vfst, Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n@@ -497,2 +488,2 @@\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n+  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n+  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n@@ -501,3 +492,3 @@\n-  static address resolve_static_call_C     (JavaThread *thread);\n-  static address resolve_virtual_call_C    (JavaThread *thread);\n-  static address resolve_opt_virtual_call_C(JavaThread *thread);\n+  static address resolve_static_call_C     (JavaThread* current);\n+  static address resolve_virtual_call_C    (JavaThread* current);\n+  static address resolve_opt_virtual_call_C(JavaThread* current);\n@@ -512,3 +503,3 @@\n-  static address handle_wrong_method(JavaThread* thread);\n-  static address handle_wrong_method_abstract(JavaThread* thread);\n-  static address handle_wrong_method_ic_miss(JavaThread* thread);\n+  static address handle_wrong_method(JavaThread* current);\n+  static address handle_wrong_method_abstract(JavaThread* current);\n+  static address handle_wrong_method_ic_miss(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":31,"deletions":40,"binary":false,"changes":71,"status":"modified"}]}