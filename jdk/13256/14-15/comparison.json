{"files":[{"patch":"@@ -84,1 +84,1 @@\n-                throw new ProviderException(e);\n+                throw new ProviderException(\"internal error\", e);\n@@ -103,1 +103,1 @@\n-                return new SecretKeySpec(key, from, to, algorithm);\n+                return new SecretKeySpec(key, from, to - from, algorithm);\n@@ -107,1 +107,1 @@\n-                throw new ProviderException();\n+                throw new ProviderException(\"internal error\", e);\n@@ -207,1 +207,1 @@\n-                throw new ProviderException(e);\n+                throw new ProviderException(\"internal error\", e);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -229,1 +229,3 @@\n-         *          and an algorithm name as specified.\n+         *          and an algorithm name as specified. For example,\n+         *          {@code encapsulate(0, 16, \"AES\")} uses the first 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n@@ -345,2 +347,6 @@\n-         * @return a portion of the shared secret as a {@code SecretKey} with\n-         *          the specified algorithm\n+         * @return a portion of the shared secret as a {@code SecretKey}\n+         *          containing the bytes of the secret ranging from {@code from}\n+         *          to {@code to}, exclusive, and an algorithm name as specified.\n+         *          For example, {@code decapsulate(encapsulation, secretSize()\n+         *          - 16, secretSize(), \"AES\")} uses the last 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,1 +89,6 @@\n- *             \/\/ ...\n+ *             byte[] encapsulation;\n+ *             byte[] secret;\n+ *             \/\/ calculating...\n+ *             return new KEM.Encapsulated(\n+ *                     new SecretKeySpec(secret, from, to - from, algorithm),\n+ *                     encapsulation, null);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEMSpi.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,0 +148,14 @@\n+        KEM.Encapsulated encHead = e2.encapsulate(0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encHead.key().getAlgorithm(), \"AES\");\n+        SecretKey decHead = d.decapsulate(encHead.encapsulation(), 0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key(), decHead);\n+\n+        KEM.Encapsulated encTail = e2.encapsulate(\n+                e2.secretSize() - 16, e2.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encTail.key().getAlgorithm(), \"AES\");\n+        SecretKey decTail = d.decapsulate(encTail.encapsulation(),\n+                d.secretSize() - 16, d.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key(), decTail);\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                    return new SecretKeySpec(kdf(Z), from, to, algorithm);\n+                    return new SecretKeySpec(kdf(Z), from, to - from, algorithm);\n@@ -424,1 +424,1 @@\n-                        new SecretKeySpec(kdf(Z), from, to, algorithm),\n+                        new SecretKeySpec(kdf(Z), from, to - from, algorithm),\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}