{"files":[{"patch":"@@ -151,1 +151,1 @@\n-     * A decapsulator, generated by {@link #newDecapsulator}.\n+     * An encapsulator, generated by {@link #newEncapsulator}.\n@@ -153,3 +153,4 @@\n-     * This class represents the key decapsulation function of a KEM.\n-     * An invocation of the {@code decapsulate} method recovers the\n-     * secret key from the key encapsulation message.\n+     * This class represents the key encapsulation function of a KEM.\n+     * Each invocation of the {@code encapsulate} method generates a\n+     * new secret key and key encapsulation message that is returned\n+     * in an {@link Encapsulated} object.\n@@ -157,2 +158,3 @@\n-    public static final class Decapsulator {\n-        private final KEMSpi.DecapsulatorSpi d;\n+    public static final class Encapsulator {\n+\n+        private final KEMSpi.EncapsulatorSpi e;\n@@ -161,2 +163,2 @@\n-        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {\n-            assert d != null;\n+        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {\n+            assert e != null;\n@@ -164,1 +166,1 @@\n-            this.d = d;\n+            this.e = e;\n@@ -178,2 +180,3 @@\n-         * The key decapsulation function. An invocation of this method\n-         * recovers the secret key from the key encapsulation message.\n+         * The key encapsulation function. Each invocation of this method\n+         * generates a new secret key and key encapsulation message that is\n+         * returned in an {@link Encapsulated} object.\n@@ -182,2 +185,2 @@\n-         * {@code decapsulate(encapsulation, 0, secretSize(), \"Generic\")}. This\n-         * combination of arguments should be supported by every implementation.\n+         * {@code encapsulate(0, secretSize(), \"Generic\")}. This combination\n+         * of arguments should be supported by every implementation.\n@@ -185,9 +188,4 @@\n-         * @param encapsulation the key encapsulation message from the sender.\n-         *          The size must be equal to the value returned by\n-         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n-         *          will be thrown.\n-         * @return the shared secret as a {@code SecretKey} with\n-         *          an algorithm name of \"Generic\"\n-         * @throws DecapsulateException if an error occurs during the\n-         *          decapsulation process\n-         * @throws NullPointerException if {@code encapsulation} is {@code null}\n+         * @return a {@link KEM.Encapsulated} object containing the shared\n+         *          secret, key encapsulation message, and optional parameters.\n+         *          The shared secret is a {@code SecretKey} containing all of\n+         *          the bytes of the secret, and an algorithm name of \"Generic\".\n@@ -195,2 +193,2 @@\n-        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {\n-            return decapsulate(encapsulation, 0, secretSize(), \"Generic\");\n+        public KEM.Encapsulated encapsulate() {\n+            return encapsulate(0, secretSize(), \"Generic\");\n@@ -200,2 +198,3 @@\n-         * The key decapsulation function. An invocation of this method\n-         * recovers the secret key from the key encapsulation message.\n+         * The key encapsulation function. Each invocation of this method\n+         * generates a new secret key and key encapsulation message that is\n+         * returned in an {@link Encapsulated} object.\n@@ -203,4 +202,0 @@\n-         * @param encapsulation the key encapsulation message from the sender.\n-         *          The size must be equal to the value returned by\n-         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n-         *          will be thrown.\n@@ -212,4 +207,6 @@\n-         * @return a portion of the shared secret as a {@code SecretKey} with\n-         *          the specified algorithm\n-         * @throws DecapsulateException if an error occurs during the\n-         *          decapsulation process\n+         * @return a {@link KEM.Encapsulated} object containing a portion of\n+         *          the shared secret, key encapsulation message, and optional\n+         *          parameters. The portion of the shared secret is a\n+         *          {@code SecretKey} containing the bytes of the secret\n+         *          ranging from {@code from} to {@code to}, exclusive,\n+         *          and an algorithm name as specified.\n@@ -217,3 +214,2 @@\n-         *          {@code from > to}, or {@code to > secretSize()}\n-         * @throws NullPointerException if {@code encapsulation} or\n-         *          {@code algorithm} is {@code null}\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n@@ -222,1 +218,1 @@\n-         *          is not supported by the decapsulator\n+         *          is not supported by the encapsulator\n@@ -224,7 +220,2 @@\n-        public SecretKey decapsulate(byte[] encapsulation,\n-                int from, int to, String algorithm)\n-                throws DecapsulateException {\n-            return d.engineDecapsulate(\n-                    encapsulation,\n-                    from, to,\n-                    algorithm);\n+        public Encapsulated encapsulate(int from, int to, String algorithm) {\n+            return e.engineEncapsulate(from, to, algorithm);\n@@ -237,1 +228,1 @@\n-         * before {@code decapsulate} is called or if the obtained\n+         * before {@code encapsulate} is called or if the obtained\n@@ -243,1 +234,1 @@\n-            int result = d.engineSecretSize();\n+            int result = e.engineSecretSize();\n@@ -252,3 +243,2 @@\n-         * This method can be used to extract the encapsulation message\n-         * from a longer byte array if no length information is provided\n-         * by a higher level protocol.\n+         * This method can be called to find out the length of the encapsulation\n+         * message before {@code encapsulate} is called.\n@@ -259,1 +249,1 @@\n-            int result = d.engineEncapsulationSize();\n+            int result = e.engineEncapsulationSize();\n@@ -267,1 +257,1 @@\n-     * An encapsulator, generated by {@link #newEncapsulator}.\n+     * A decapsulator, generated by {@link #newDecapsulator}.\n@@ -269,4 +259,3 @@\n-     * This class represents the key encapsulation function of a KEM.\n-     * Each invocation of the {@code encapsulate} method generates a\n-     * new secret key and key encapsulation message that is returned\n-     * in an {@link Encapsulated} object.\n+     * This class represents the key decapsulation function of a KEM.\n+     * An invocation of the {@code decapsulate} method recovers the\n+     * secret key from the key encapsulation message.\n@@ -274,3 +263,2 @@\n-    public static final class Encapsulator {\n-\n-        private final KEMSpi.EncapsulatorSpi e;\n+    public static final class Decapsulator {\n+        private final KEMSpi.DecapsulatorSpi d;\n@@ -279,2 +267,2 @@\n-        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {\n-            assert e != null;\n+        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {\n+            assert d != null;\n@@ -282,1 +270,1 @@\n-            this.e = e;\n+            this.d = d;\n@@ -296,3 +284,2 @@\n-         * The key encapsulation function. Each invocation of this method\n-         * generates a new secret key and key encapsulation message that is\n-         * returned in an {@link Encapsulated} object.\n+         * The key decapsulation function. An invocation of this method\n+         * recovers the secret key from the key encapsulation message.\n@@ -301,2 +288,2 @@\n-         * {@code encapsulate(0, secretSize(), \"Generic\")}. This combination\n-         * of arguments should be supported by every implementation.\n+         * {@code decapsulate(encapsulation, 0, secretSize(), \"Generic\")}. This\n+         * combination of arguments should be supported by every implementation.\n@@ -304,4 +291,9 @@\n-         * @return a {@link KEM.Encapsulated} object containing the shared\n-         *          secret, key encapsulation message, and optional parameters.\n-         *          The shared secret is a {@code SecretKey} containing all of\n-         *          the bytes of the secret, and an algorithm name of \"Generic\".\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @return the shared secret as a {@code SecretKey} with\n+         *          an algorithm name of \"Generic\"\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws NullPointerException if {@code encapsulation} is {@code null}\n@@ -309,2 +301,2 @@\n-        public KEM.Encapsulated encapsulate() {\n-            return encapsulate(0, secretSize(), \"Generic\");\n+        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {\n+            return decapsulate(encapsulation, 0, secretSize(), \"Generic\");\n@@ -314,3 +306,2 @@\n-         * The key encapsulation function. Each invocation of this method\n-         * generates a new secret key and key encapsulation message that is\n-         * returned in an {@link Encapsulated} object.\n+         * The key decapsulation function. An invocation of this method\n+         * recovers the secret key from the key encapsulation message.\n@@ -318,0 +309,4 @@\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n@@ -323,6 +318,4 @@\n-         * @return a {@link KEM.Encapsulated} object containing a portion of\n-         *          the shared secret, key encapsulation message, and optional\n-         *          parameters. The portion of the shared secret is a\n-         *          {@code SecretKey} containing the bytes of the secret\n-         *          ranging from {@code from} to {@code to}, exclusive,\n-         *          and an algorithm name as specified.\n+         * @return a portion of the shared secret as a {@code SecretKey} with\n+         *          the specified algorithm\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n@@ -330,2 +323,3 @@\n-         *     {@code from > to}, or {@code to > secretSize()}\n-         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n@@ -334,1 +328,1 @@\n-         *          is not supported by the encapsulator\n+         *          is not supported by the decapsulator\n@@ -336,2 +330,7 @@\n-        public Encapsulated encapsulate(int from, int to, String algorithm) {\n-            return e.engineEncapsulate(from, to, algorithm);\n+        public SecretKey decapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm)\n+                throws DecapsulateException {\n+            return d.engineDecapsulate(\n+                    encapsulation,\n+                    from, to,\n+                    algorithm);\n@@ -344,1 +343,1 @@\n-         * before {@code encapsulate} is called or if the obtained\n+         * before {@code decapsulate} is called or if the obtained\n@@ -350,1 +349,1 @@\n-            int result = e.engineSecretSize();\n+            int result = d.engineSecretSize();\n@@ -359,2 +358,3 @@\n-         * This method can be called to find out the length of the encapsulation\n-         * message before {@code encapsulate} is called.\n+         * This method can be used to extract the encapsulation message\n+         * from a longer byte array if no length information is provided\n+         * by a higher level protocol.\n@@ -365,1 +365,1 @@\n-            int result = e.engineEncapsulationSize();\n+            int result = d.engineEncapsulationSize();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"}]}