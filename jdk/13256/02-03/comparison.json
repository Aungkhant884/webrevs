{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Objects;\n@@ -52,0 +53,2 @@\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n@@ -72,0 +75,6 @@\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n+            Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+            if (encapsulation.length != params.Npk) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n@@ -312,0 +321,3 @@\n+        if (pk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n@@ -322,0 +334,3 @@\n+        if (sk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+ *    \/\/ Receiver side\n@@ -67,2 +68,3 @@\n- *    var kem = KEM.getInstance(\"DHKEM\");\n- *    var sender = kem.newEncapsulator(kp.getPublic());\n+ *    \/\/ Sender side\n+ *    var kem1 = KEM.getInstance(\"DHKEM\");\n+ *    var sender = kem1.newEncapsulator(kp.getPublic());\n@@ -72,1 +74,3 @@\n- *    var receiver = kem.newDecapsulator(kp.getPrivate());\n+ *    \/\/ Receiver side\n+ *    var kem2 = KEM.getInstance(\"DHKEM\");\n+ *    var receiver = kem2.newDecapsulator(kp.getPrivate());\n@@ -221,6 +225,1 @@\n-            Objects.checkFromToIndex(from, to, secretSize());\n-            Objects.requireNonNull(encapsulation, \"null encapsulation\");\n-            if (encapsulation.length != encapsulationSize()) {\n-                throw new DecapsulateException(\"Invalid encapsulation size\");\n-            }\n-            var result = d.engineDecapsulate(\n+            return d.engineDecapsulate(\n@@ -229,3 +228,1 @@\n-                    Objects.requireNonNull(algorithm, \"null algorithm\"));\n-            assert result != null : \"null engineDecapsulate result\";\n-            return result;\n+                    algorithm);\n@@ -338,5 +335,1 @@\n-            Objects.checkFromToIndex(from, to, secretSize());\n-            var result = e.engineEncapsulate(from, to,\n-                    Objects.requireNonNull(algorithm, \"null algorithm\"));\n-            assert result != null : \"null engineEncapsulate result\";\n-            return result;\n+            return e.engineEncapsulate(from, to, algorithm);\n@@ -388,0 +381,3 @@\n+            if (pk == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n@@ -431,0 +427,3 @@\n+            if (sk == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n@@ -501,1 +500,1 @@\n-     * @throws NullPointerException if the input argument is {@code null}\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n@@ -586,1 +585,0 @@\n-     * @throws NullPointerException if {@code pk} is {@code null}\n@@ -611,1 +609,0 @@\n-     * @throws NullPointerException if {@code pk} is {@code null}\n@@ -651,1 +648,0 @@\n-     * @throws NullPointerException if {@code pk} is {@code null}\n@@ -656,1 +652,0 @@\n-        Objects.requireNonNull(pk, \"null public key\");\n@@ -670,1 +665,0 @@\n-     * @throws NullPointerException if {@code sk} is {@code null}\n@@ -692,1 +686,0 @@\n-     * @throws NullPointerException if {@code sk} is {@code null}\n@@ -696,1 +689,0 @@\n-        Objects.requireNonNull(sk, \"null private key\");\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -113,6 +113,0 @@\n-         * <p>\n-         * The caller of this method has already validated the parameters to\n-         * ensure that {@code algorithm} is not {@code null}, and the values\n-         * of {@code from} and {@code to} are within the correct range.\n-         * Therefore an implementation of this method does not need to\n-         * validate them.\n@@ -120,3 +114,5 @@\n-         * @param from the initial index of the shared secret to be returned, inclusive\n-         * @param to the final index of the shared secret to be returned, exclusive.\n-         * @param algorithm the algorithm for the secret key returned\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n@@ -126,0 +122,3 @@\n+         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n@@ -128,1 +127,1 @@\n-         *          is not supported by the decapsulator.\n+         *          is not supported by the encapsulator\n@@ -171,8 +170,0 @@\n-         * <p>\n-         * The caller of this method has already validated the parameters to\n-         * ensure that neither {@code encapsulation} not {@code algorithm} is\n-         * {@code null}, the size of {@code encapsulation} is equal to the\n-         * value returned by {@link #engineEncapsulationSize()}, and\n-         * the values of {@code from} and {@code to} are\n-         * within the correct range. Therefore an implementation of this method\n-         * does not to validate them.\n@@ -180,4 +171,9 @@\n-         * @param encapsulation the key encapsulation message from the sender\n-         * @param from the initial index of the shared secret to be returned, inclusive\n-         * @param to the final index of the shared secret to be returned, exclusive.\n-         * @param algorithm the algorithm for the secret key returned\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #engineEncapsulationSize()} ()}, or a\n+         *          {@code DecapsulateException} must be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n@@ -186,3 +182,0 @@\n-         * @throws UnsupportedOperationException if the combination of\n-         *          {@code from}, {@code to}, and {@code algorithm}\n-         *          is not supported by the decapsulator.\n@@ -191,0 +184,7 @@\n+         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n@@ -223,4 +223,0 @@\n-     * <p>\n-     * The caller of this method has already validated the parameters to\n-     * ensure that {@code pk} is not {@code null}. Therefore an implementation\n-     * of this method does not need to validate it.\n@@ -228,1 +224,1 @@\n-     * @param pk the receiver's public key. This argument is never {@code null}.\n+     * @param pk the receiver's public key, must not be {@code null}\n@@ -245,4 +241,0 @@\n-     * <p>\n-     * The caller of this method has already validated the parameters to\n-     * ensure that {@code sk} is not {@code null}. Therefore an implementation\n-     * of this method does not need to validate it.\n@@ -250,2 +242,2 @@\n-     * @param sk the receiver's private key. This argument is never {@code null}.\n-     * @param spec the optional parameter, can be {@code null}\n+     * @param sk the receiver's private key, must not be {@code null}\n+     * @param spec the parameter, can be {@code null}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEMSpi.java","additions":28,"deletions":36,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import javax.crypto.KEMSpi;\n@@ -59,1 +58,0 @@\n-            badprovider();\n@@ -104,1 +102,1 @@\n-                NullPointerException.class);\n+                InvalidKeyException.class);\n@@ -107,1 +105,1 @@\n-                NullPointerException.class);\n+                InvalidKeyException.class);\n@@ -182,1 +180,0 @@\n-            put(\"KEM.BAD\", \"Compliance$BadKEMImpl\");\n@@ -286,134 +283,0 @@\n-\n-    static class BadKEMParameterSpec implements AlgorithmParameterSpec {\n-        final int ss;\n-        final int es;\n-        final SecretKey sk;\n-        final byte[] encap;\n-        final boolean noenc;\n-\n-        public BadKEMParameterSpec(int ss, int es, SecretKey sk, byte[] encap, boolean noenc) {\n-            this.ss = ss;\n-            this.es = es;\n-            this.sk = sk;\n-            this.encap = encap;\n-            this.noenc = noenc;\n-        }\n-\n-        BadKEMParameterSpec ss(int ss) {\n-            return new BadKEMParameterSpec(ss, es, sk, encap, noenc);\n-        }\n-\n-        BadKEMParameterSpec es(int es) {\n-            return new BadKEMParameterSpec(ss, es, sk, encap, noenc);\n-        }\n-\n-        BadKEMParameterSpec sk(SecretKey sk) {\n-            return new BadKEMParameterSpec(ss, es, sk, encap, noenc);\n-        }\n-\n-        BadKEMParameterSpec encap(byte[] encap) {\n-            return new BadKEMParameterSpec(ss, es, sk, encap, noenc);\n-        }\n-\n-        BadKEMParameterSpec noenc(boolean noenc) {\n-            return new BadKEMParameterSpec(ss, es, sk, encap, noenc);\n-        }\n-    }\n-\n-    static class BadHandler implements KEMSpi.DecapsulatorSpi, KEMSpi.EncapsulatorSpi {\n-        final BadKEMParameterSpec spec;\n-        BadHandler(BadKEMParameterSpec spec) {\n-            this.spec = spec;\n-        }\n-        @Override\n-        public SecretKey engineDecapsulate(byte[] encapsulation, int from, int to, String algorithm) throws DecapsulateException {\n-            return spec.sk;\n-        }\n-\n-        @Override\n-        public int engineSecretSize() {\n-            return spec.ss;\n-        }\n-\n-        @Override\n-        public int engineEncapsulationSize() {\n-            return spec.es;\n-        }\n-\n-        @Override\n-        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n-            return spec.noenc ? null : new KEM.Encapsulated(spec.sk, spec.encap, null);\n-        }\n-    }\n-\n-    public static class BadKEMImpl implements KEMSpi {\n-\n-        @Override\n-        public EncapsulatorSpi engineNewEncapsulator(PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom) {\n-            return spec == null ? null : new BadHandler((BadKEMParameterSpec) spec);\n-        }\n-\n-        @Override\n-        public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec) {\n-            return spec == null ? null : new BadHandler((BadKEMParameterSpec) spec);\n-        }\n-    }\n-\n-    static void badprovider() throws Exception {\n-        KeyPair kpX = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n-        SecretKeySpec k = new SecretKeySpec(new byte[10], \"AES\");\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\").newEncapsulator(kpX.getPublic()),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\").newDecapsulator(kpX.getPrivate()),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-\n-        BadKEMParameterSpec good = new BadKEMParameterSpec(10, 10, k, new byte[10], false);\n-        KEM kem = KEM.getInstance(\"BAD\");\n-        KEM.Encapsulator e = kem.newEncapsulator(kpX.getPublic(), good, null);\n-        Asserts.assertEQ(e.secretSize(), 10);\n-        Asserts.assertEQ(e.encapsulationSize(), 10);\n-        Asserts.assertTrue(e.encapsulate().key() != null);\n-        Asserts.assertTrue(e.encapsulate().encapsulation() != null);\n-        KEM.Decapsulator d = kem.newDecapsulator(kpX.getPrivate(), good);\n-        Asserts.assertEQ(d.secretSize(), 10);\n-        Asserts.assertEQ(d.encapsulationSize(), 10);\n-        Asserts.assertTrue(d.decapsulate(new byte[0]) != null);\n-\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.noenc(true), null).encapsulate(),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.ss(-1), null).secretSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.ss(Integer.MAX_VALUE), null).secretSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.es(-1), null).encapsulationSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.es(Integer.MAX_VALUE), null).encapsulationSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Encapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.sk(null), null).encapsulate(),\n-                ExChecker.of(NullPointerException.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newEncapsulator(kpX.getPublic(), good.encap(null), null).encapsulate(),\n-                ExChecker.of(NullPointerException.class));\n-\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newDecapsulator(kpX.getPrivate(), good.ss(-1)).secretSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newDecapsulator(kpX.getPrivate(), good.ss(Integer.MAX_VALUE)).secretSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newDecapsulator(kpX.getPrivate(), good.es(-1)).encapsulationSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newDecapsulator(kpX.getPrivate(), good.es(Integer.MAX_VALUE)).encapsulationSize(),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-        Utils.runAndCheckException(() -> KEM.getInstance(\"BAD\")\n-                        .newDecapsulator(kpX.getPrivate(), good.sk(null)).decapsulate(new byte[1]),\n-                ExChecker.of(AssertionError.class).by(KEM.Decapsulator.class));\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":2,"deletions":139,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Objects;\n@@ -377,0 +378,6 @@\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+                if (encapsulation.length != KeyUtil.getKeySize(rsk) \/ 8) {\n+                    throw new DecapsulateException(\"incorrect encapsulation size\");\n+                }\n@@ -387,0 +394,2 @@\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n@@ -463,1 +472,1 @@\n-                return KeyUtil.getKeySize(rsk == null ? rpk : rsk);\n+                return KeyUtil.getKeySize(rsk == null ? rpk : rsk) \/ 8;\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}