{"files":[{"patch":"@@ -31,0 +31,2 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub) {}\n+  static int entry_barrier_stub_size() { return 0; }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub) {}\n+  static int entry_barrier_stub_size() { return 0; }\n+\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub) {}\n+  static int entry_barrier_stub_size() { return 0; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub) {}\n+  static int entry_barrier_stub_size() { return 0; }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub) {}\n+  static int entry_barrier_stub_size() { return 0; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -328,1 +328,2 @@\n-  bs->nmethod_entry_barrier(this);\n+  \/\/ C1 code is not hot enough to micro optimize the nmethod entry barrier with an out-of-line stub\n+  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/output.hpp\"\n@@ -131,1 +132,19 @@\n-    bs->nmethod_entry_barrier(this);\n+ #ifdef _LP64\n+    if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+      \/\/ We put the non-hot code of the nmethod entry barrier out-of-line in a stub.\n+      Label dummy_slow_path;\n+      Label dummy_continuation;\n+      Label* slow_path = &dummy_slow_path;\n+      Label* continuation = &dummy_continuation;\n+      if (!Compile::current()->output()->in_scratch_emit_size()) {\n+        \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n+        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n+        slow_path = &stub->slow_path();\n+        continuation = &stub->continuation();\n+      }\n+      bs->nmethod_entry_barrier(this, slow_path, continuation);\n+    }\n+#else\n+    \/\/ Don't bother with out-of-line nmethod entry barrier stub for x86_32.\n+    bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+#endif\n@@ -135,0 +154,10 @@\n+void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n+  bind(stub->slow_path());\n+  call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n+  jmp(stub->continuation(), false \/* maybe_short *\/);\n+}\n+\n+int C2_MacroAssembler::entry_barrier_stub_size() {\n+  return 10;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+  void emit_entry_barrier_stub(C2EntryBarrierStub* stub);\n+  static int entry_barrier_stub_size();\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {\n+void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm, Label* slow_path, Label* continuation) {\n@@ -317,1 +317,0 @@\n-  Label continuation;\n@@ -320,1 +319,5 @@\n-  __ align(8);\n+  \/\/ The immediate is the last 4 bytes, so if we align the start of the cmp\n+  \/\/ instruction to 4 bytes, we know that the second half of it is also 4\n+  \/\/ byte aligned, which means that the immediate will not cross a cache line\n+  __ align(4);\n+  uintptr_t before_cmp = (uintptr_t)__ pc();\n@@ -322,3 +325,12 @@\n-  __ jcc(Assembler::equal, continuation);\n-  __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n-  __ bind(continuation);\n+  uintptr_t after_cmp = (uintptr_t)__ pc();\n+  guarantee(after_cmp - before_cmp == 8, \"Wrong assumed instruction length\");\n+\n+  if (slow_path != NULL) {\n+    __ jcc(Assembler::notEqual, *slow_path);\n+    __ bind(*continuation);\n+  } else {\n+    Label done;\n+    __ jccb(Assembler::equal, done);\n+    __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n+    __ bind(done);\n+  }\n@@ -327,1 +339,1 @@\n-void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {\n+void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm, Label*, Label*) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  virtual void nmethod_entry_barrier(MacroAssembler* masm);\n+  virtual void nmethod_entry_barrier(MacroAssembler* masm, Label* slow_path, Label* continuation);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -65,1 +66,1 @@\n-  if (((uintptr_t) instruction_address()) & 0x7) {\n+  if (((uintptr_t) instruction_address()) & 0x3) {\n@@ -159,1 +160,11 @@\n-static const int entry_barrier_offset = LP64_ONLY(-19) NOT_LP64(-18);\n+static const int entry_barrier_offset(nmethod* nm) {\n+#ifdef _LP64\n+  if (nm->is_compiled_by_c2()) {\n+    return -14;\n+  } else {\n+    return -15;\n+  }\n+#else\n+  return -18;\n+#endif\n+}\n@@ -162,1 +173,1 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset;\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1521,1 +1521,1 @@\n-  bs->nmethod_entry_barrier(masm);\n+  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1747,1 +1747,2 @@\n-  bs->nmethod_entry_barrier(masm);\n+  \/\/ native wrapper is not hot enough to micro optimize the nmethod entry barrier with an out-of-line stub\n+  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class C2EntryBarrierStub;\n+\n","filename":"src\/hotspot\/share\/opto\/c2_MacroAssembler.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -287,0 +288,37 @@\n+\/\/ Nmethod entry barrier stubs\n+C2EntryBarrierStub* C2EntryBarrierStubTable::add_entry_barrier() {\n+  assert(_stub == NULL, \"There can only be one entry barrier stub\");\n+  _stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+  return _stub;\n+}\n+\n+void C2EntryBarrierStubTable::emit(CodeBuffer& cb) {\n+  if (_stub == NULL) {\n+    \/\/ No stub - nothing to do\n+    return;\n+  }\n+\n+  C2_MacroAssembler masm(&cb);\n+  \/\/ Make sure there is enough space in the code buffer\n+  if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return;\n+  }\n+\n+  intptr_t before = masm.offset();\n+  masm.emit_entry_barrier_stub(_stub);\n+  intptr_t after = masm.offset();\n+  int actual_size = (int)(after - before);\n+  int expected_size = masm.entry_barrier_stub_size();\n+  assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n+}\n+\n+int C2EntryBarrierStubTable::estimate_stub_size() const {\n+  if (BarrierSet::barrier_set()->barrier_set_nmethod() == NULL) {\n+    \/\/ No nmethod entry barrier?\n+    return 0;\n+  }\n+\n+  return C2_MacroAssembler::entry_barrier_stub_size();\n+}\n+\n@@ -293,0 +331,2 @@\n+    _safepoint_poll_table(),\n+    _entry_barrier_table(),\n@@ -1305,0 +1345,1 @@\n+  stub_req += entry_barrier_table()->estimate_stub_size();\n@@ -1815,0 +1856,4 @@\n+  \/\/ Fill in stubs for calling the runtime from nmethod entries.\n+  entry_barrier_table()->emit(*cb);\n+  if (C->failing())  return;\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class C2_MacroAssembler;\n@@ -116,0 +117,24 @@\n+\/\/ We move non-hot code of the nmethod entry barrier to an out-of-line stub\n+class C2EntryBarrierStub: public ResourceObj {\n+  Label _slow_path;\n+  Label _continuation;\n+\n+public:\n+  C2EntryBarrierStub() :\n+    _slow_path(),\n+    _continuation() {}\n+\n+  Label& slow_path() { return _slow_path; }\n+  Label& continuation() { return _continuation; }\n+};\n+\n+class C2EntryBarrierStubTable {\n+  C2EntryBarrierStub* _stub;\n+\n+public:\n+  C2EntryBarrierStubTable() : _stub(NULL) {}\n+  C2EntryBarrierStub* add_entry_barrier();\n+  int estimate_stub_size() const;\n+  void emit(CodeBuffer& cb);\n+};\n+\n@@ -125,0 +150,1 @@\n+  C2EntryBarrierStubTable _entry_barrier_table;  \/\/ Table for entry barrier stubs\n@@ -175,0 +201,3 @@\n+  \/\/ Entry barrier table\n+  C2EntryBarrierStubTable* entry_barrier_table() { return &_entry_barrier_table; }\n+\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}