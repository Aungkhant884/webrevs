{"files":[{"patch":"@@ -1446,8 +1446,16 @@\n-    \/\/ Check <MethodHandle subclass>.argL0 field\n-    \/\/ Probably BoundMethodHandle.Species_L, but we only care if the field exists\n-    oop arg = obj_field(mh, \"argL0\");\n-    if (arg != NULL) {\n-      RecordLocation fp(this, \"argL0\");\n-      if (arg->klass()->is_instance_klass()) {\n-        InstanceKlass* ik2 = InstanceKlass::cast(arg->klass());\n-        record_best_dyno_loc(ik2);\n+    \/\/ Check <MethodHandle subclass>.argL<n> fields\n+    \/\/ Probably BoundMethodHandle.Species_L*, but we only care if the field exists\n+    char arg_name[] = \"argLXX\";\n+    int max_arg = 99;\n+    for (int index = 0; index <= max_arg; ++index) {\n+      jio_snprintf(arg_name, sizeof (arg_name), \"argL%d\", index);\n+      oop arg = obj_field(mh, arg_name);\n+      if (arg != NULL) {\n+        RecordLocation fp(this, \"%s\", arg_name);\n+        if (arg->klass()->is_instance_klass()) {\n+          InstanceKlass* ik2 = InstanceKlass::cast(arg->klass());\n+          record_best_dyno_loc(ik2);\n+          record_call_site_obj(thread, arg);\n+        }\n+      } else {\n+        break;\n@@ -1462,1 +1470,1 @@\n-void ciEnv::record_call_site_obj(Thread* thread, const constantPoolHandle& pool, const Handle obj)\n+void ciEnv::record_call_site_obj(Thread* thread, oop obj)\n@@ -1464,5 +1472,5 @@\n-  if (obj.not_null()) {\n-    if (java_lang_invoke_MethodHandle::is_instance(obj())) {\n-        record_mh(thread, obj());\n-    } else if (java_lang_invoke_ConstantCallSite::is_instance(obj())) {\n-      oop target = java_lang_invoke_CallSite::target(obj());\n+  if (obj != NULL) {\n+    if (java_lang_invoke_MethodHandle::is_instance(obj)) {\n+        record_mh(thread, obj);\n+    } else if (java_lang_invoke_ConstantCallSite::is_instance(obj)) {\n+      oop target = java_lang_invoke_CallSite::target(obj);\n@@ -1479,1 +1487,1 @@\n-void ciEnv::record_call_site_method(Thread* thread, const constantPoolHandle& pool, Method* adapter) {\n+void ciEnv::record_call_site_method(Thread* thread, Method* adapter) {\n@@ -1494,1 +1502,1 @@\n-    record_call_site_method(thread, cp, adapter);\n+    record_call_site_method(thread, adapter);\n@@ -1496,1 +1504,1 @@\n-    Handle appendix(thread, cp_cache_entry->appendix_if_resolved(cp));\n+    oop appendix = cp_cache_entry->appendix_if_resolved(cp);\n@@ -1499,1 +1507,1 @@\n-      record_call_site_obj(thread, cp, appendix);\n+      record_call_site_obj(thread, appendix);\n@@ -1504,2 +1512,1 @@\n-    oop bsm_oop = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), thread);\n-    Handle bsm(thread, bsm_oop);\n+    oop bsm = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), thread);\n@@ -1508,1 +1515,1 @@\n-      record_call_site_obj(thread, cp, bsm);\n+      record_call_site_obj(thread, bsm);\n@@ -1526,2 +1533,2 @@\n-      Handle appendix(thread, cp_cache_entry->appendix_if_resolved(cp));\n-      record_call_site_method(thread, cp, adapter);\n+      oop appendix = cp_cache_entry->appendix_if_resolved(cp);\n+      record_call_site_method(thread, adapter);\n@@ -1531,1 +1538,1 @@\n-        record_call_site_obj(thread, cp, appendix);\n+        record_call_site_obj(thread, appendix);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -511,2 +511,2 @@\n-  void record_call_site_obj(Thread* thread, const constantPoolHandle& pool, const Handle appendix);\n-  void record_call_site_method(Thread* thread, const constantPoolHandle& pool, Method* adapter);\n+  void record_call_site_obj(Thread* thread, oop obj);\n+  void record_call_site_method(Thread* thread, Method* adapter);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275670\n+ * @library \/ \/test\/lib\n+ * @summary testing of ciReplay with inlining\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestLambdas\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+public class TestLambdas extends CiReplayBase {\n+    public static void main(String args[]) {\n+        new TestLambdas().runTest(false, TIERED_DISABLED_VM_OPTION);\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(TIERED_DISABLED_VM_OPTION);\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return Test.class.getName();\n+    }\n+}\n+\n+class Test {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(i);\n+        }\n+    }\n+\n+    static void test(int i) {\n+        concat_lambdas();\n+    }\n+\n+\n+    \/\/ Create nested BoundMethodHandle using StringConcatHelper\n+    static boolean concat_lambdas() {\n+        String source = \"0123456789abcdefgABCDEFG\";\n+        String result = \"\";\n+\n+        int max = 10;\n+        for (int cp = 0; cp < max; ++cp) {\n+            String regex = new String(Character.toChars(cp));\n+            result =  source.substring(0, 3) + regex\n+                 + source.substring(3, 9) + regex\n+                 + source.substring(9, 15) + regex\n+                 + source.substring(15);\n+        }\n+        return result.equals(\"xyzzy\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestLambdas.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}