{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/threadSMR.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/threadSMR.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/threadSMR.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_VMOPERATION_HPP\n+#define SHARE_RUNTIME_VMOPERATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+\/\/ The following classes are used for operations\n+\/\/ initiated by a Java thread but that must\n+\/\/ take place in the VMThread.\n+\n+#define VM_OP_ENUM(type)   VMOp_##type,\n+\n+\/\/ Note: When new VM_XXX comes up, add 'XXX' to the template table.\n+#define VM_OPS_DO(template)                       \\\n+  template(None)                                  \\\n+  template(Cleanup)                               \\\n+  template(ThreadDump)                            \\\n+  template(PrintThreads)                          \\\n+  template(FindDeadlocks)                         \\\n+  template(ClearICs)                              \\\n+  template(ForceSafepoint)                        \\\n+  template(ForceAsyncSafepoint)                   \\\n+  template(DeoptimizeFrame)                       \\\n+  template(DeoptimizeAll)                         \\\n+  template(ZombieAll)                             \\\n+  template(Verify)                                \\\n+  template(PrintJNI)                              \\\n+  template(HeapDumper)                            \\\n+  template(DeoptimizeTheWorld)                    \\\n+  template(CollectForMetadataAllocation)          \\\n+  template(GC_HeapInspection)                     \\\n+  template(GenCollectFull)                        \\\n+  template(GenCollectFullConcurrent)              \\\n+  template(GenCollectForAllocation)               \\\n+  template(ParallelGCFailedAllocation)            \\\n+  template(ParallelGCSystemGC)                    \\\n+  template(G1CollectForAllocation)                \\\n+  template(G1CollectFull)                         \\\n+  template(G1Concurrent)                          \\\n+  template(G1TryInitiateConcMark)                 \\\n+  template(ZMarkStart)                            \\\n+  template(ZMarkEnd)                              \\\n+  template(ZRelocateStart)                        \\\n+  template(ZVerify)                               \\\n+  template(HandshakeOneThread)                    \\\n+  template(HandshakeAllThreads)                   \\\n+  template(HandshakeFallback)                     \\\n+  template(EnableBiasedLocking)                   \\\n+  template(BulkRevokeBias)                        \\\n+  template(PopulateDumpSharedSpace)               \\\n+  template(JNIFunctionTableCopier)                \\\n+  template(RedefineClasses)                       \\\n+  template(GetObjectMonitorUsage)                 \\\n+  template(GetAllStackTraces)                     \\\n+  template(GetThreadListStackTraces)              \\\n+  template(ChangeBreakpoints)                     \\\n+  template(GetOrSetLocal)                         \\\n+  template(ChangeSingleStep)                      \\\n+  template(HeapWalkOperation)                     \\\n+  template(HeapIterateOperation)                  \\\n+  template(ReportJavaOutOfMemory)                 \\\n+  template(JFRCheckpoint)                         \\\n+  template(ShenandoahFullGC)                      \\\n+  template(ShenandoahInitMark)                    \\\n+  template(ShenandoahFinalMarkStartEvac)          \\\n+  template(ShenandoahInitUpdateRefs)              \\\n+  template(ShenandoahFinalUpdateRefs)             \\\n+  template(ShenandoahDegeneratedGC)               \\\n+  template(Exit)                                  \\\n+  template(LinuxDllLoad)                          \\\n+  template(RotateGCLog)                           \\\n+  template(WhiteBoxOperation)                     \\\n+  template(JVMCIResizeCounters)                   \\\n+  template(ClassLoaderStatsOperation)             \\\n+  template(ClassLoaderHierarchyOperation)         \\\n+  template(DumpHashtable)                         \\\n+  template(DumpTouchedMethods)                    \\\n+  template(CleanClassLoaderDataMetaspaces)        \\\n+  template(PrintCompileQueue)                     \\\n+  template(PrintClassHierarchy)                   \\\n+  template(ThreadSuspend)                         \\\n+  template(ThreadsSuspendJVMTI)                   \\\n+  template(ICBufferFull)                          \\\n+  template(ScavengeMonitors)                      \\\n+  template(PrintMetadata)                         \\\n+  template(GTestExecuteAtSafepoint)               \\\n+  template(JFROldObject)                          \\\n+  template(JvmtiPostObjectFree)\n+\n+class Thread;\n+class outputStream;\n+\n+class VM_Operation : public StackObj {\n+ public:\n+  enum VMOp_Type {\n+    VM_OPS_DO(VM_OP_ENUM)\n+    VMOp_Terminating\n+  };\n+\n+ private:\n+  Thread*         _calling_thread;\n+\n+  \/\/ The VM operation name array\n+  static const char* _names[];\n+\n+ public:\n+  VM_Operation() : _calling_thread(NULL) {}\n+\n+  \/\/ VM operation support (used by VM thread)\n+  Thread* calling_thread() const                 { return _calling_thread; }\n+  void set_calling_thread(Thread* thread);\n+\n+  \/\/ Called by VM thread - does in turn invoke doit(). Do not override this\n+  void evaluate();\n+\n+  \/\/ evaluate() is called by the VMThread and in turn calls doit().\n+  \/\/ If the thread invoking VMThread::execute((VM_Operation*) is a JavaThread,\n+  \/\/ doit_prologue() is called in that thread before transferring control to\n+  \/\/ the VMThread.\n+  \/\/ If doit_prologue() returns true the VM operation will proceed, and\n+  \/\/ doit_epilogue() will be called by the JavaThread once the VM operation\n+  \/\/ completes. If doit_prologue() returns false the VM operation is cancelled.\n+  virtual void doit()                            = 0;\n+  virtual bool doit_prologue()                   { return true; };\n+  virtual void doit_epilogue()                   {};\n+\n+  \/\/ Configuration. Override these appropriately in subclasses.\n+  virtual VMOp_Type type() const = 0;\n+  virtual bool allow_nested_vm_operations() const { return false; }\n+\n+  \/\/ You may override skip_thread_oop_barriers to return true if the operation\n+  \/\/ does not access thread-private oops (including frames).\n+  virtual bool skip_thread_oop_barriers() const { return false; }\n+\n+  \/\/ An operation can either be done inside a safepoint\n+  \/\/ or concurrently with Java threads running.\n+  virtual bool evaluate_at_safepoint() const { return true; }\n+\n+  \/\/ Debugging\n+  virtual void print_on_error(outputStream* st) const;\n+  virtual const char* name() const  { return _names[type()]; }\n+  static const char* name(int type) {\n+    assert(type >= 0 && type < VMOp_Terminating, \"invalid VM operation type\");\n+    return _names[type];\n+  }\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const { print_on_error(st); }\n+#endif\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_VMOPERATION_HPP\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/vmOperation.hpp\"\n@@ -33,140 +33,1 @@\n-\/\/ The following classes are used for operations\n-\/\/ initiated by a Java thread but that must\n-\/\/ take place in the VMThread.\n-\n-#define VM_OP_ENUM(type)   VMOp_##type,\n-\n-\/\/ Note: When new VM_XXX comes up, add 'XXX' to the template table.\n-#define VM_OPS_DO(template)                       \\\n-  template(None)                                  \\\n-  template(Cleanup)                               \\\n-  template(ThreadDump)                            \\\n-  template(PrintThreads)                          \\\n-  template(FindDeadlocks)                         \\\n-  template(ClearICs)                              \\\n-  template(ForceSafepoint)                        \\\n-  template(ForceAsyncSafepoint)                   \\\n-  template(DeoptimizeFrame)                       \\\n-  template(DeoptimizeAll)                         \\\n-  template(ZombieAll)                             \\\n-  template(Verify)                                \\\n-  template(PrintJNI)                              \\\n-  template(HeapDumper)                            \\\n-  template(DeoptimizeTheWorld)                    \\\n-  template(CollectForMetadataAllocation)          \\\n-  template(GC_HeapInspection)                     \\\n-  template(GenCollectFull)                        \\\n-  template(GenCollectFullConcurrent)              \\\n-  template(GenCollectForAllocation)               \\\n-  template(ParallelGCFailedAllocation)            \\\n-  template(ParallelGCSystemGC)                    \\\n-  template(G1CollectForAllocation)                \\\n-  template(G1CollectFull)                         \\\n-  template(G1Concurrent)                          \\\n-  template(G1TryInitiateConcMark)                 \\\n-  template(ZMarkStart)                            \\\n-  template(ZMarkEnd)                              \\\n-  template(ZRelocateStart)                        \\\n-  template(ZVerify)                               \\\n-  template(HandshakeOneThread)                    \\\n-  template(HandshakeAllThreads)                   \\\n-  template(HandshakeFallback)                     \\\n-  template(EnableBiasedLocking)                   \\\n-  template(BulkRevokeBias)                        \\\n-  template(PopulateDumpSharedSpace)               \\\n-  template(JNIFunctionTableCopier)                \\\n-  template(RedefineClasses)                       \\\n-  template(GetObjectMonitorUsage)                 \\\n-  template(GetAllStackTraces)                     \\\n-  template(GetThreadListStackTraces)              \\\n-  template(ChangeBreakpoints)                     \\\n-  template(GetOrSetLocal)                         \\\n-  template(ChangeSingleStep)                      \\\n-  template(HeapWalkOperation)                     \\\n-  template(HeapIterateOperation)                  \\\n-  template(ReportJavaOutOfMemory)                 \\\n-  template(JFRCheckpoint)                         \\\n-  template(ShenandoahFullGC)                      \\\n-  template(ShenandoahInitMark)                    \\\n-  template(ShenandoahFinalMarkStartEvac)          \\\n-  template(ShenandoahInitUpdateRefs)              \\\n-  template(ShenandoahFinalUpdateRefs)             \\\n-  template(ShenandoahDegeneratedGC)               \\\n-  template(Exit)                                  \\\n-  template(LinuxDllLoad)                          \\\n-  template(RotateGCLog)                           \\\n-  template(WhiteBoxOperation)                     \\\n-  template(JVMCIResizeCounters)                   \\\n-  template(ClassLoaderStatsOperation)             \\\n-  template(ClassLoaderHierarchyOperation)         \\\n-  template(DumpHashtable)                         \\\n-  template(DumpTouchedMethods)                    \\\n-  template(CleanClassLoaderDataMetaspaces)        \\\n-  template(PrintCompileQueue)                     \\\n-  template(PrintClassHierarchy)                   \\\n-  template(ThreadSuspend)                         \\\n-  template(ThreadsSuspendJVMTI)                   \\\n-  template(ICBufferFull)                          \\\n-  template(ScavengeMonitors)                      \\\n-  template(PrintMetadata)                         \\\n-  template(GTestExecuteAtSafepoint)               \\\n-  template(JFROldObject)                          \\\n-  template(JvmtiPostObjectFree)\n-\n-class VM_Operation : public StackObj {\n- public:\n-  enum VMOp_Type {\n-    VM_OPS_DO(VM_OP_ENUM)\n-    VMOp_Terminating\n-  };\n-\n- private:\n-  Thread*         _calling_thread;\n-\n-  \/\/ The VM operation name array\n-  static const char* _names[];\n-\n- public:\n-  VM_Operation() : _calling_thread(NULL) {}\n-\n-  \/\/ VM operation support (used by VM thread)\n-  Thread* calling_thread() const                 { return _calling_thread; }\n-  void set_calling_thread(Thread* thread);\n-\n-  \/\/ Called by VM thread - does in turn invoke doit(). Do not override this\n-  void evaluate();\n-\n-  \/\/ evaluate() is called by the VMThread and in turn calls doit().\n-  \/\/ If the thread invoking VMThread::execute((VM_Operation*) is a JavaThread,\n-  \/\/ doit_prologue() is called in that thread before transferring control to\n-  \/\/ the VMThread.\n-  \/\/ If doit_prologue() returns true the VM operation will proceed, and\n-  \/\/ doit_epilogue() will be called by the JavaThread once the VM operation\n-  \/\/ completes. If doit_prologue() returns false the VM operation is cancelled.\n-  virtual void doit()                            = 0;\n-  virtual bool doit_prologue()                   { return true; };\n-  virtual void doit_epilogue()                   {};\n-\n-  \/\/ Configuration. Override these appropriately in subclasses.\n-  virtual VMOp_Type type() const = 0;\n-  virtual bool allow_nested_vm_operations() const { return false; }\n-\n-  \/\/ You may override skip_thread_oop_barriers to return true if the operation\n-  \/\/ does not access thread-private oops (including frames).\n-  virtual bool skip_thread_oop_barriers() const { return false; }\n-\n-  \/\/ An operation can either be done inside a safepoint\n-  \/\/ or concurrently with Java threads running.\n-  virtual bool evaluate_at_safepoint() const { return true; }\n-\n-  \/\/ Debugging\n-  virtual void print_on_error(outputStream* st) const;\n-  virtual const char* name() const  { return _names[type()]; }\n-  static const char* name(int type) {\n-    assert(type >= 0 && type < VMOp_Terminating, \"invalid VM operation type\");\n-    return _names[type];\n-  }\n-#ifndef PRODUCT\n-  void print_on(outputStream* st) const { print_on_error(st); }\n-#endif\n-};\n+\/\/ A hodge podge of commonly used VM Operations\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":3,"deletions":142,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/xmlstream.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}