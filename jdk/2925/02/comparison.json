{"files":[{"patch":"@@ -95,0 +95,55 @@\n+int ClassListParser::parse(TRAPS) {\n+  int class_count = 0;\n+\n+  while (parse_one_line()) {\n+    if (lambda_form_line()) {\n+      \/\/ The current line is \"@lambda-form-invoker ...\". It has been recorded in LambdaFormInvokers,\n+      \/\/ and will be processed later.\n+      continue;\n+    }\n+\n+    TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+    if (_indy_items->length() > 0) {\n+      \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n+      resolve_indy(THREAD, class_name_symbol);\n+      class_count++;\n+      continue;\n+    }\n+\n+    Klass* klass = load_current_class(class_name_symbol, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+        \/\/ If we have run out of memory, don't try to load the rest of the classes in\n+        \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n+        return 0; \/\/ THROW\n+      }\n+\n+      \/\/ We might have an invalid class name or an bad class. Warn about it\n+      \/\/ and keep going to the next line.\n+      CLEAR_PENDING_EXCEPTION;\n+      log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+      continue;\n+    }\n+\n+    assert(klass != NULL, \"sanity\");\n+    if (log_is_enabled(Trace, cds)) {\n+      ResourceMark rm(THREAD);\n+      log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    }\n+\n+    if (klass->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+\n+      \/\/ Link the class to cause the bytecodes to be rewritten and the\n+      \/\/ cpcache to be created. The linking is done as soon as classes\n+      \/\/ are loaded in order that the related data structures (klass and\n+      \/\/ cpCache) are located together.\n+      MetaspaceShared::try_link_class(THREAD, ik);\n+    }\n+\n+    class_count++;\n+  }\n+\n+  return class_count;\n+}\n+\n@@ -401,1 +456,1 @@\n-    return NULL;\n+    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n@@ -405,0 +460,6 @@\n+  if (k->local_interfaces()->length() != _interfaces->length()) {\n+    print_specified_interfaces();\n+    print_actual_interfaces(k);\n+    error(\"The number of interfaces (%d) specified in class list does not match the class file (%d)\",\n+          _interfaces->length(), k->local_interfaces()->length());\n+  }\n@@ -406,17 +467,4 @@\n-  if (k != NULL) {\n-    if (k->local_interfaces()->length() != _interfaces->length()) {\n-      print_specified_interfaces();\n-      print_actual_interfaces(k);\n-      error(\"The number of interfaces (%d) specified in class list does not match the class file (%d)\",\n-            _interfaces->length(), k->local_interfaces()->length());\n-    }\n-\n-    bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);\n-    if (!added) {\n-      \/\/ We allow only a single unregistered class for each unique name.\n-      error(\"Duplicated class %s\", _class_name);\n-    }\n-\n-    \/\/ This tells JVM_FindLoadedClass to not find this class.\n-    k->set_shared_classpath_index(UNREGISTERED_INDEX);\n-    k->clear_shared_class_loader_type();\n+  bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);\n+  if (!added) {\n+    \/\/ We allow only a single unregistered class for each unique name.\n+    error(\"Duplicated class %s\", _class_name);\n@@ -425,0 +473,4 @@\n+  \/\/ This tells JVM_FindLoadedClass to not find this class.\n+  k->set_shared_classpath_index(UNREGISTERED_INDEX);\n+  k->clear_shared_class_loader_type();\n+\n@@ -445,4 +497,2 @@\n-        Klass* callee = pool->klass_at(callee_index, THREAD);\n-        if (callee != NULL) {\n-          cii->add_item(callee->name()->as_C_string());\n-        }\n+        Klass* callee = pool->klass_at(callee_index, CHECK);\n+        cii->add_item(callee->name()->as_C_string());\n@@ -461,1 +511,1 @@\n-  populate_cds_indy_info(pool, cp_index, &cii, THREAD);\n+  populate_cds_indy_info(pool, cp_index, &cii, CHECK_0);\n@@ -474,1 +524,4 @@\n-void ClassListParser::resolve_indy(Symbol* class_name_symbol, TRAPS) {\n+\n+void ClassListParser::resolve_indy(Thread* current, Symbol* class_name_symbol) {\n+  ExceptionMark em(current);\n+  Thread* THREAD = current; \/\/ For exception macros.\n@@ -477,1 +530,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -494,2 +547,2 @@\n-  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK); \/\/ FIXME should really be just a lookup\n-  if (klass != NULL && klass->is_instance_klass()) {\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK);\n+  if (klass->is_instance_klass()) {\n@@ -497,2 +550,3 @@\n-    if (SystemDictionaryShared::has_class_failed_verification(ik)) {\n-      \/\/ don't attempt to resolve indy on classes that has previously failed verification\n+    MetaspaceShared::try_link_class(THREAD, ik);\n+    if (!ik->is_linked()) {\n+      \/\/ Verification of ik has failed\n@@ -501,1 +555,0 @@\n-    MetaspaceShared::try_link_class(ik, CHECK);\n@@ -541,9 +594,2 @@\n-Klass* ClassListParser::load_current_class(TRAPS) {\n-  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n-\n-  if (_indy_items->length() > 0) {\n-    resolve_indy(class_name_symbol, CHECK_NULL);\n-    return NULL;\n-  }\n-\n-  Klass* klass = NULL;\n+Klass* ClassListParser::load_current_class(Symbol* class_name_symbol, TRAPS) {\n+  Klass* klass;\n@@ -559,25 +605,1 @@\n-    bool non_array = !Signature::is_array(class_name_symbol);\n-\n-    JavaValue result(T_OBJECT);\n-    if (non_array) {\n-      \/\/ At this point, we are executing in the context of the boot loader. We\n-      \/\/ cannot call Class.forName because that is context dependent and\n-      \/\/ would load only classes for the boot loader.\n-      \/\/\n-      \/\/ Instead, let's call java_system_loader().loadClass() directly, which will\n-      \/\/ delegate to the correct loader (boot, platform or app) depending on\n-      \/\/ the class name.\n-\n-      Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n-      \/\/ ClassLoader.loadClass() wants external class name format, i.e., convert '\/' chars to '.'\n-      Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n-      Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());\n-\n-      JavaCalls::call_virtual(&result,\n-                              loader, \/\/SystemDictionary::java_system_loader(),\n-                              vmClasses::ClassLoader_klass(),\n-                              vmSymbols::loadClass_name(),\n-                              vmSymbols::string_class_signature(),\n-                              ext_class_name,\n-                              CHECK_NULL);\n-    } else {\n+    if (Signature::is_array(class_name_symbol)) {\n@@ -587,0 +609,19 @@\n+\n+    JavaValue result(T_OBJECT);\n+    \/\/ Call java_system_loader().loadClass() directly, which will\n+    \/\/ delegate to the correct loader (boot, platform or app) depending on\n+    \/\/ the package name.\n+\n+    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n+    \/\/ ClassLoader.loadClass() wants external class name format, i.e., convert '\/' chars to '.'\n+    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());\n+\n+    JavaCalls::call_virtual(&result,\n+                            loader, \/\/SystemDictionary::java_system_loader(),\n+                            vmClasses::ClassLoader_klass(),\n+                            vmSymbols::loadClass_name(),\n+                            vmSymbols::string_class_signature(),\n+                            ext_class_name,\n+                            CHECK_NULL);\n+\n@@ -595,3 +636,0 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-    }\n@@ -600,1 +638,4 @@\n-  if (klass != NULL && klass->is_instance_klass() && is_id_specified()) {\n+  assert(klass != NULL, \"exception should have been thrown\");\n+  assert(klass->is_instance_klass(), \"array classes should have been filtered out\");\n+\n+  if (is_id_specified()) {\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":109,"deletions":68,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  void resolve_indy(Symbol* class_name_symbol, TRAPS);\n+  void resolve_indy(Thread* current, Symbol* class_name_symbol);\n@@ -121,0 +121,3 @@\n+  bool parse_one_line();\n+  Klass* load_current_class(Symbol* class_name_symbol, TRAPS);\n+\n@@ -132,1 +135,1 @@\n-  bool parse_one_line();\n+  int parse(TRAPS);\n@@ -172,2 +175,0 @@\n-  Klass* load_current_class(TRAPS);\n-\n","filename":"src\/hotspot\/share\/classfile\/classListParser.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1271,8 +1271,1 @@\n-                                                           THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    if (DumpSharedSpaces) {\n-      log_error(cds)(\"Preload Error: Failed to load %s\", class_name);\n-    }\n-    return NULL;\n-  }\n-\n+                                                           CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-\n@@ -270,1 +269,1 @@\n-  ClassPathEntry* e = find_classpath_entry_from_cache(path, CHECK_NULL);\n+  ClassPathEntry* e = find_classpath_entry_from_cache(THREAD, path);\n@@ -272,7 +271,1 @@\n-    return NULL;\n-  }\n-  {\n-    PerfClassTraceTime vmtimer(perf_sys_class_lookup_time(),\n-                               THREAD->as_Java_thread()->get_thread_stat()->perf_timers_addr(),\n-                               PerfClassTraceTime::CLASS_LOAD);\n-    stream = e->open_stream(file_name, CHECK_NULL);\n+    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n@@ -281,2 +274,3 @@\n-  if (NULL == stream) {\n-    log_warning(cds)(\"Preload Warning: Cannot find %s\", class_name);\n+  stream = e->open_stream(file_name, CHECK_NULL);\n+  if (stream == NULL) {\n+    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n@@ -285,2 +279,0 @@\n-\n-  assert(stream != NULL, \"invariant\");\n@@ -292,12 +284,6 @@\n-\n-  InstanceKlass* result = KlassFactory::create_from_stream(stream,\n-                                                           name,\n-                                                           loader_data,\n-                                                           cl_info,\n-                                                           THREAD);\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_error(cds)(\"Preload Error: Failed to load %s\", class_name);\n-    return NULL;\n-  }\n-  return result;\n+  InstanceKlass* k = KlassFactory::create_from_stream(stream,\n+                                                      name,\n+                                                      loader_data,\n+                                                      cl_info,\n+                                                      CHECK_NULL);\n+  return k;\n@@ -313,1 +299,1 @@\n-ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(const char* path, TRAPS) {\n+ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(Thread* current, const char* path) {\n@@ -339,1 +325,4 @@\n-  new_entry = create_class_path_entry(path, &st, false, false, false, CHECK_NULL);\n+  ExceptionMark em(current);\n+  Thread* THREAD = current; \/\/ For exception macros.\n+  new_entry = create_class_path_entry(path, &st, \/*throw_exception=*\/false,\n+                                      false, false, CATCH); \/\/ will never throw\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":16,"deletions":27,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  static ClassPathEntry* find_classpath_entry_from_cache(const char* path, TRAPS);\n+  static ClassPathEntry* find_classpath_entry_from_cache(Thread* current, const char* path);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  MetaspaceShared::try_link_class(result, THREAD);\n+  MetaspaceShared::try_link_class(THREAD, result);\n","filename":"src\/hotspot\/share\/classfile\/lambdaFormInvokers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,9 +351,0 @@\n-\n-void ArchiveUtils::check_for_oom(oop exception) {\n-  assert(exception != nullptr, \"Sanity check\");\n-  if (exception->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    vm_direct_exit(-1,\n-      err_msg(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n-              SIZE_FORMAT \"M\", MaxHeapSize\/M));\n-  }\n-}\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  static void check_for_oom(oop exception) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  reset_states(SystemDictionary::java_system_loader(), THREAD);\n+  reset_states(SystemDictionary::java_system_loader(), CHECK);\n@@ -363,1 +363,0 @@\n-  Thread* THREAD = Thread::current();\n@@ -1247,1 +1246,1 @@\n-                                            int num, Thread* THREAD) {\n+                                            int num, TRAPS) {\n@@ -1253,8 +1252,1 @@\n-    Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      ResourceMark rm(THREAD);\n-      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-      log_info(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n-                    java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n-      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n-    }\n+    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n@@ -1264,2 +1256,1 @@\n-    ik->initialize(THREAD);\n-    guarantee(!HAS_PENDING_EXCEPTION, \"exception in initialize\");\n+    ik->initialize(CHECK);\n@@ -1276,1 +1267,1 @@\n-void HeapShared::init_subgraph_entry_fields(Thread* THREAD) {\n+void HeapShared::init_subgraph_entry_fields(TRAPS) {\n@@ -1281,1 +1272,1 @@\n-                             THREAD);\n+                             CHECK);\n@@ -1284,1 +1275,1 @@\n-                             THREAD);\n+                             CHECK);\n@@ -1288,1 +1279,1 @@\n-                               THREAD);\n+                               CHECK);\n@@ -1292,1 +1283,1 @@\n-void HeapShared::init_for_dumping(Thread* THREAD) {\n+void HeapShared::init_for_dumping(TRAPS) {\n@@ -1295,1 +1286,1 @@\n-    init_subgraph_entry_fields(THREAD);\n+    init_subgraph_entry_fields(CHECK);\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+  static void init_subgraph_entry_fields(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -226,1 +227,1 @@\n-                                         int num, Thread* THREAD);\n+                                         int num, TRAPS);\n@@ -402,2 +403,1 @@\n-  static void init_for_dumping(Thread* THREAD) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void init_subgraph_entry_fields(Thread* THREAD) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_for_dumping(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/memory\/heapShared.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -68,1 +69,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -239,1 +239,1 @@\n-void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {\n+void MetaspaceShared::read_extra_data(Thread* current, const char* filename) {\n@@ -249,1 +249,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -263,0 +263,2 @@\n+      ExceptionMark em(current);\n+      Thread* THREAD = current; \/\/ For exception macros.\n@@ -454,2 +456,0 @@\n-  Thread* THREAD = VMThread::vm_thread();\n-\n@@ -556,2 +556,1 @@\n-  bool res = MetaspaceShared::try_link_class(ik, THREAD);\n-  guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n+  bool res = MetaspaceShared::try_link_class(THREAD, ik);\n@@ -563,1 +562,1 @@\n-    ik->constants()->resolve_class_constants(THREAD);\n+    ik->constants()->resolve_class_constants(CHECK_0); \/\/ may throw OOM when interning strings.\n@@ -584,1 +583,1 @@\n-            has_linked |= link_class_for_cds(ik, THREAD);\n+            has_linked |= link_class_for_cds(ik, CHECK);\n@@ -618,31 +617,6 @@\n-  { TraceTime timer(\"Dump Shared Spaces\", TRACETIME_LOG(Info, startuptime));\n-    ResourceMark rm(THREAD);\n-    char class_list_path_str[JVM_MAXPATHLEN];\n-    \/\/ Preload classes to be shared.\n-    const char* class_list_path;\n-    if (SharedClassListFile == NULL) {\n-      \/\/ Construct the path to the class list (in jre\/lib)\n-      \/\/ Walk up two directories from the location of the VM and\n-      \/\/ optionally tack on \"lib\" (depending on platform)\n-      os::jvm_path(class_list_path_str, sizeof(class_list_path_str));\n-      for (int i = 0; i < 3; i++) {\n-        char *end = strrchr(class_list_path_str, *os::file_separator());\n-        if (end != NULL) *end = '\\0';\n-      }\n-      int class_list_path_len = (int)strlen(class_list_path_str);\n-      if (class_list_path_len >= 3) {\n-        if (strcmp(class_list_path_str + class_list_path_len - 3, \"lib\") != 0) {\n-          if (class_list_path_len < JVM_MAXPATHLEN - 4) {\n-            jio_snprintf(class_list_path_str + class_list_path_len,\n-                         sizeof(class_list_path_str) - class_list_path_len,\n-                         \"%slib\", os::file_separator());\n-            class_list_path_len += 4;\n-          }\n-        }\n-      }\n-      if (class_list_path_len < JVM_MAXPATHLEN - 10) {\n-        jio_snprintf(class_list_path_str + class_list_path_len,\n-                     sizeof(class_list_path_str) - class_list_path_len,\n-                     \"%sclasslist\", os::file_separator());\n-      }\n-      class_list_path = class_list_path_str;\n+  ResourceMark rm(THREAD);\n+  preload_and_dump_impl(THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      vm_direct_exit(-1,  err_msg(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                                  SIZE_FORMAT \"M\", MaxHeapSize\/M));\n@@ -650,1 +624,3 @@\n-      class_list_path = SharedClassListFile;\n+      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n@@ -652,0 +628,6 @@\n+  } else {\n+    \/\/ On success, the VM_PopulateDumpSharedSpace op should have\n+    \/\/ exited the VM.\n+    ShouldNotReachHere();\n+  }\n+}\n@@ -653,5 +635,12 @@\n-    log_info(cds)(\"Loading classes to share ...\");\n-    _has_error_classes = false;\n-    int class_count = preload_classes(class_list_path, THREAD);\n-    if (ExtraSharedClassListFile) {\n-      class_count += preload_classes(ExtraSharedClassListFile, THREAD);\n+void MetaspaceShared::preload_classes(TRAPS) {\n+  char default_classlist[JVM_MAXPATHLEN];\n+  const char* classlist_path;\n+\n+  if (SharedClassListFile == NULL) {\n+    \/\/ Construct the path to the class list (in jre\/lib)\n+    \/\/ Walk up two directories from the location of the VM and\n+    \/\/ optionally tack on \"lib\" (depending on platform)\n+    os::jvm_path(default_classlist, sizeof(default_classlist));\n+    for (int i = 0; i < 3; i++) {\n+      char *end = strrchr(default_classlist, *os::file_separator());\n+      if (end != NULL) *end = '\\0';\n@@ -659,8 +648,10 @@\n-    log_info(cds)(\"Loading classes to share: done.\");\n-\n-    log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n-\n-    if (SharedArchiveConfigFile) {\n-      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n-      read_extra_data(SharedArchiveConfigFile, THREAD);\n-      log_info(cds)(\"Reading extra data: done.\");\n+    int classlist_path_len = (int)strlen(default_classlist);\n+    if (classlist_path_len >= 3) {\n+      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n+          jio_snprintf(default_classlist + classlist_path_len,\n+                       sizeof(default_classlist) - classlist_path_len,\n+                       \"%slib\", os::file_separator());\n+          classlist_path_len += 4;\n+        }\n+      }\n@@ -668,5 +659,4 @@\n-\n-    if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n-      log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n-      LambdaFormInvokers::regenerate_holder_classes(THREAD);\n-      log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n+    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n+      jio_snprintf(default_classlist + classlist_path_len,\n+                   sizeof(default_classlist) - classlist_path_len,\n+                   \"%sclasslist\", os::file_separator());\n@@ -674,0 +664,4 @@\n+    classlist_path = default_classlist;\n+  } else {\n+    classlist_path = SharedClassListFile;\n+  }\n@@ -675,1 +669,6 @@\n-    HeapShared::init_for_dumping(THREAD);\n+  log_info(cds)(\"Loading classes to share ...\");\n+  _has_error_classes = false;\n+  int class_count = parse_classlist(classlist_path, CHECK);\n+  if (ExtraSharedClassListFile) {\n+    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+  }\n@@ -677,4 +676,4 @@\n-    \/\/ exercise the manifest processing code to ensure classes used by CDS are always archived\n-    SystemDictionaryShared::create_jar_manifest(\"Manifest-Version: 1.0\\n\", strlen(\"Manifest-Version: 1.0\\n\"), THREAD);\n-    \/\/ Rewrite and link classes\n-    log_info(cds)(\"Rewriting and linking classes ...\");\n+  \/\/ Exercise the manifest processing code to ensure classes used by CDS at runtime\n+  \/\/ are always archived\n+  const char* dummy = \"Manifest-Version: 1.0\\n\";\n+  SystemDictionaryShared::create_jar_manifest(dummy, strlen(dummy), CHECK);\n@@ -682,6 +681,3 @@\n-    \/\/ Link any classes which got missed. This would happen if we have loaded classes that\n-    \/\/ were not explicitly specified in the classlist. E.g., if an interface implemented by class K\n-    \/\/ fails verification, all other interfaces that were not specified in the classlist but\n-    \/\/ are implemented by K are not verified.\n-    link_and_cleanup_shared_classes(CATCH);\n-    log_info(cds)(\"Rewriting and linking classes: done\");\n+  log_info(cds)(\"Loading classes to share: done.\");\n+  log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n+}\n@@ -689,5 +685,2 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (use_full_module_graph()) {\n-      HeapShared::reset_archived_object_states(THREAD);\n-    }\n-#endif\n+void MetaspaceShared::preload_and_dump_impl(TRAPS) {\n+  preload_classes(CHECK);\n@@ -695,2 +688,4 @@\n-    VM_PopulateDumpSharedSpace op;\n-    VMThread::execute(&op);\n+  if (SharedArchiveConfigFile) {\n+    log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+    read_extra_data(THREAD, SharedArchiveConfigFile);\n+    log_info(cds)(\"Reading extra data: done.\");\n@@ -698,2 +693,0 @@\n-}\n-\n@@ -701,3 +694,5 @@\n-int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {\n-  ClassListParser parser(class_list_path);\n-  int class_count = 0;\n+  if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n+  }\n@@ -705,23 +700,1 @@\n-  while (parser.parse_one_line()) {\n-    if (parser.lambda_form_line()) {\n-      continue;\n-    }\n-    Klass* klass = parser.load_current_class(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      if (klass == NULL) {\n-        Symbol* exception_klass_name = PENDING_EXCEPTION->klass()->name();\n-        if (exception_klass_name == vmSymbols::java_lang_ClassNotFoundException() ||\n-            exception_klass_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {\n-          \/\/ print a warning only when the class is not found or has a version that's too old.\n-          \/\/ Todo: the CDS test cases expect \"Cannot find\" in the log, but we should consider\n-          \/\/ distinguishing the different failure modes.\n-          log_warning(cds)(\"Preload Warning: Cannot find %s\", parser.current_class_name());\n-        }\n-      }\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n-    if (klass != NULL) {\n-      if (log_is_enabled(Trace, cds)) {\n-        ResourceMark rm(THREAD);\n-        log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n-      }\n+  HeapShared::init_for_dumping(CHECK);\n@@ -729,2 +702,2 @@\n-      if (klass->is_instance_klass()) {\n-        InstanceKlass* ik = InstanceKlass::cast(klass);\n+  \/\/ Rewrite and link classes\n+  log_info(cds)(\"Rewriting and linking classes ...\");\n@@ -732,7 +705,6 @@\n-        \/\/ Link the class to cause the bytecodes to be rewritten and the\n-        \/\/ cpcache to be created. The linking is done as soon as classes\n-        \/\/ are loaded in order that the related data structures (klass and\n-        \/\/ cpCache) are located together.\n-        try_link_class(ik, THREAD);\n-        guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n-      }\n+  \/\/ Link any classes which got missed. This would happen if we have loaded classes that\n+  \/\/ were not explicitly specified in the classlist. E.g., if an interface implemented by class K\n+  \/\/ fails verification, all other interfaces that were not specified in the classlist but\n+  \/\/ are implemented by K are not verified.\n+  link_and_cleanup_shared_classes(CATCH);\n+  log_info(cds)(\"Rewriting and linking classes: done\");\n@@ -740,2 +712,3 @@\n-      class_count++;\n-    }\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (use_full_module_graph()) {\n+    HeapShared::reset_archived_object_states(CHECK);\n@@ -743,0 +716,6 @@\n+#endif\n+\n+  VM_PopulateDumpSharedSpace op;\n+  VMThread::execute(&op);\n+}\n+\n@@ -744,1 +723,3 @@\n-  return class_count;\n+int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n+  ClassListParser parser(classlist_path);\n+  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n@@ -747,2 +728,4 @@\n-\/\/ Returns true if the class's status has changed\n-bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {\n+\/\/ Returns true if the class's status has changed.\n+bool MetaspaceShared::try_link_class(Thread* current, InstanceKlass* ik) {\n+  ExceptionMark em(current);\n+  Thread* THREAD = current; \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":102,"deletions":119,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-  static int preload_classes(const char * class_list_path,\n-                             TRAPS) NOT_CDS_RETURN_(0);\n@@ -84,0 +82,8 @@\n+private:\n+  static void preload_and_dump_impl(TRAPS) NOT_CDS_RETURN;\n+  static void preload_classes(TRAPS) NOT_CDS_RETURN;\n+  static int parse_classlist(const char * classlist_path,\n+                              TRAPS) NOT_CDS_RETURN_(0);\n+\n+\n+public:\n@@ -130,1 +136,1 @@\n-  static bool try_link_class(InstanceKlass* ik, TRAPS);\n+  static bool try_link_class(Thread* current, InstanceKlass* ik);\n@@ -179,1 +185,1 @@\n-  static void read_extra_data(const char* filename, TRAPS) NOT_CDS_RETURN;\n+  static void read_extra_data(Thread* current, const char* filename) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                              .shouldContain(\"Preload Error: Failed to load jdk\/internal\/math\/FDBigInteger\")\n+                              .shouldContain(\"Preload Warning: Cannot find jdk\/internal\/math\/FDBigInteger\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/ExceptionDuringDumpAtObjectsInitPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}