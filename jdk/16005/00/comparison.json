{"files":[{"patch":"@@ -277,1 +277,1 @@\n-                                   checked_cast<int>(st.st_size),\n+                                   checked_cast<int, true>(st.st_size),\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-      stream->write_int(checked_cast<int>(content_reg()->value()));\n+      stream->write_int(content_reg()->value());\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,2 @@\n-    size_t min_expected_size = checked_cast<size_t>(ceil(current_size \/ WantedLoadFactor));\n+    assert((current_size \/ WantedLoadFactor) <= SIZE_MAX, \"table overflow\");\n+    size_t min_expected_size = current_size \/ WantedLoadFactor;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  page_expected.lgrp_id = checked_cast<uint>(lgrp_id());\n+  page_expected.lgrp_id = lgrp_id();\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1239,1 +1239,1 @@\n-  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  Node* int_stride = _igvn.intcon(stride_con);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1084,1 +1084,1 @@\n-      _high = checked_cast<PrimitiveType>(_low + cache->length() - 1);\n+      _high = checked_cast<PrimitiveType, true>(_low + cache->length() - 1);\n@@ -1103,1 +1103,1 @@\n-      int offset = checked_cast<int>(value - _low);\n+      int offset = checked_cast<int, true>(value - _low);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  T adjusted = checked_cast<T>(size + alignment_mask(alignment));\n+  T adjusted = checked_cast<T, true>(size + alignment_mask(alignment));\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -29,0 +30,3 @@\n+#include \"utilities\/macros.hpp\"\n+#include <limits>\n+#include <type_traits>\n@@ -30,13 +34,147 @@\n-\/\/ In many places we've added C-style casts to silence compiler\n-\/\/ warnings, for example when truncating a size_t to an int when we\n-\/\/ know the size_t is a small struct. Such casts are risky because\n-\/\/ they effectively disable useful compiler warnings. We can make our\n-\/\/ lives safer with this function, which ensures that any cast is\n-\/\/ reversible without loss of information. It doesn't check\n-\/\/ everything: it isn't intended to make sure that pointer types are\n-\/\/ compatible, for example.\n-template <typename T2, typename T1>\n-constexpr T2 checked_cast(T1 thing) {\n-  T2 result = static_cast<T2>(thing);\n-  assert(static_cast<T1>(result) == thing, \"must be\");\n-  return result;\n+\/\/ Implementation support for checked_cast.\n+\/\/\n+\/\/ Because of details of C++ conversion rules, including undefined or\n+\/\/ implementation-defined behavior in some cases, along with the possibility\n+\/\/ of tautological comparison warnings from some compilers, the implementation\n+\/\/ is not as simple as doing the obvious range checks.\n+class CheckedCastImpl {\n+  template<typename To, typename From, bool permit_tautology>\n+  struct CheckSameSign;\n+\n+  template<typename To, typename From, bool permit_tautology,\n+           bool is_narrowing = (sizeof(To) <= sizeof(From))>\n+  struct CheckToSigned;\n+\n+  template<typename To, typename From, bool permit_tautology,\n+           bool is_narrowing = (sizeof(To) < sizeof(From))>\n+  struct CheckFromSigned;\n+\n+  template<typename To, typename From>\n+  static constexpr bool check_range(From from) {\n+    To to_max = std::numeric_limits<To>::max();\n+    return from <= static_cast<From>(to_max);\n+  }\n+\n+  template<typename To, typename From, bool permit_tautology>\n+  struct Dispatcher {\n+    static const bool to_signed = std::is_signed<To>::value;\n+    static const bool from_signed = std::is_signed<From>::value;\n+    using SameSign = CheckSameSign<To, From, permit_tautology>;\n+    using ToSigned = CheckToSigned<To, From, permit_tautology>;\n+    using FromSigned = CheckFromSigned<To, From, permit_tautology>;\n+    using type =\n+      std::conditional_t<(to_signed == from_signed),\n+                         SameSign,\n+                         std::conditional_t<to_signed, ToSigned, FromSigned>>;\n+  };\n+\n+public:\n+  template<typename To, typename From>\n+  static constexpr bool is_tautology() {\n+    using Dispatcher = Dispatcher<To, From, true>;\n+    using Checker = typename Dispatcher::type;\n+    return Checker::is_tautology;\n+  }\n+\n+  template<typename To, bool permit_tautology, typename From>\n+  static constexpr bool check(From from) {\n+    using Dispatcher = Dispatcher<To, From, permit_tautology>;\n+    using Checker = typename Dispatcher::type;\n+    return Checker()(from);\n+  }\n+};\n+\n+\/\/ If both types are signed or both are unsigned, only a narrowing conversion\n+\/\/ can lose information.  We check for such loss via a round-trip conversion.\n+\/\/ C++14 4.7 defines the result for unsigned types, and implementation-defined\n+\/\/ for signed types.  All supported implementations do the \"obvious\" discard\n+\/\/ of high-order bits when narrowing signed values, and C++20 requires that\n+\/\/ behavior.  This approach avoids any additional complexity to avoid\n+\/\/ potential tautological comparisons.\n+template<typename To, typename From, bool permit_tautology>\n+struct CheckedCastImpl::CheckSameSign {\n+  static const bool is_narrowing = sizeof(To) < sizeof(From);\n+  static const bool is_tautology = !is_narrowing;\n+  static_assert(permit_tautology || is_narrowing, \"tautological checked_cast\");\n+  constexpr bool operator()(From from) const {\n+    return !is_narrowing || (static_cast<From>(static_cast<To>(from)) == from);\n+  }\n+};\n+\n+\/\/ Conversion from unsigned to signed is okay if value <= To's max.\n+template<typename To, typename From, bool permit_tautology>\n+struct CheckedCastImpl::CheckToSigned<To, From, permit_tautology, true \/* is_narrowing *\/> {\n+  static const bool is_tautology = false;\n+  constexpr bool operator()(From from) const {\n+    return check_range<To>(from);\n+  }\n+};\n+\n+\/\/ Avoid tautological comparison when not narrowing.\n+template<typename To, typename From, bool permit_tautology>\n+struct CheckedCastImpl::CheckToSigned<To, From, permit_tautology, false \/* is_narrowing *\/> {\n+  static const bool is_tautology = true;\n+  static_assert(permit_tautology, \"tautological checked_cast\");\n+  constexpr bool operator()(From from) const {\n+    return true;\n+  }\n+};\n+\n+\/\/ Conversion from signed to unsigned is okay when 0 <= value <= To's max.\n+template<typename To, typename From, bool permit_tautology>\n+struct CheckedCastImpl::CheckFromSigned<To, From, permit_tautology, true \/* is_narrowing *\/> {\n+  static const bool is_tautology = false;\n+  constexpr bool operator()(From from) const {\n+    return (from >= 0) && check_range<To>(from);\n+  }\n+};\n+\n+\/\/ Avoid tautological comparison when not narrowing.\n+template<typename To, typename From, bool permit_tautology>\n+struct CheckedCastImpl::CheckFromSigned<To, From, permit_tautology, false \/* is_narrowing *\/> {\n+  static const bool is_tautology = false;\n+  constexpr bool operator()(From from) const {\n+    return (from >= 0);\n+  }\n+};\n+\n+\/**\n+ * Convert an integral value to another integral type via static_cast, after a\n+ * debug-only check that the value is within the range for the destination\n+ * type.\n+ *\n+ * * To is the desired result type, which must be integral.\n+ *\n+ * * From is the type of the argument, which must be integral.\n+ *\n+ * * permit_tautology determines the behavior when a conversion will\n+ * always succeed because the range of values for the From type is enclosed by\n+ * the range of values for the To type.  If true, the conversion will be\n+ * performed as requested.  If false, a compile-time error is produced.  The\n+ * default is false for 64bit platforms, true for 32bit platforms.\n+ *\n+ * * from is the value to be converted.\n+ *\n+ * Unnecessary checked_casts make code harder to understand.  Hence the\n+ * compile-time failure for tautological conversions, to alert that a code\n+ * change is making a checked_cast unnecessary.  This can be suppressed on a\n+ * per-call basis, because there are cases where a conversion might only\n+ * sometimes be tautological.  For example, the types involved may vary by\n+ * platform.  Another case is if the operation is in a template with dependent\n+ * types, with the operation only being tautological for some instantiations.\n+ * Suppressing the tautology check is an alternative to possibly complex\n+ * metaprogramming to only perform the checked_cast when necessary.\n+ *\n+ * Despite that, for 32bit platforms the default is to not reject unnecessary\n+ * checked_casts.  This is because 64bit platforms are the primary target, and\n+ * are likely to require conversions in some places.  However, some of those\n+ * conversions will be tautological on 32bit platforms.\n+ *\/\n+template<typename To,\n+         bool permit_tautology = LP64_ONLY(false) NOT_LP64(true),\n+         typename From,\n+         ENABLE_IF(std::is_integral<To>::value),\n+         ENABLE_IF(std::is_integral<From>::value)>\n+constexpr To checked_cast(From from) {\n+  assert((CheckedCastImpl::check<To, permit_tautology>(from)), \"checked_cast failed\");\n+  return static_cast<To>(from);\n@@ -45,1 +183,17 @@\n-#endif \/\/ SHARE_UTILITIES_CHECKEDCAST_HPP\n+\/**\n+ * Convert an enumerator to an integral value via static_cast, after a\n+ * debug-only check that the value is within the range for the destination\n+ * type.  This is mostly for compatibility with old code.  Class scoped enums\n+ * were used to work around ancient compilers that didn't implement class\n+ * scoped static integral constants properly, and HotSpot code still has many\n+ * examples of this.  For others it might be sufficient to provide an explicit\n+ * underlying type and either permit implicit conversions or use\n+ * PrimitiveConversion::cast.\n+ *\/\n+template<typename To, typename From,\n+         ENABLE_IF(std::is_integral<To>::value),\n+         ENABLE_IF(std::is_enum<From>::value)>\n+constexpr To checked_cast(From from) {\n+  using U = std::underlying_type_t<From>;\n+  return checked_cast<To, true \/* permit_tautology *\/>(static_cast<U>(from));\n+}\n@@ -47,0 +201,1 @@\n+#endif \/\/ SHARE_UTILITIES_CHECKEDCAST_HPP\n","filename":"src\/hotspot\/share\/utilities\/checkedCast.hpp","additions":169,"deletions":14,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-  return checked_cast<unsigned>(static_cast<T>(r) >> (((sizeof(T) - 1) * BitsPerByte)));\n+  T result = static_cast<T>(r) >> ((sizeof(T) - 1) * BitsPerByte);\n+  return static_cast<unsigned>(result); \/\/ Safe potentially narrowing conversion.\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <limits>\n+#include <type_traits>\n+#include \"unittest.hpp\"\n+\n+\/\/ Enable gcc warnings to verify we don't get any of these.\n+\/\/ Eventually we plan to have these globally enabled, but not there yet.\n+#ifdef __GNUC__\n+#pragma GCC diagnostic warning \"-Wconversion\"\n+#pragma GCC diagnostic warning \"-Wsign-conversion\"\n+#endif\n+\n+template<typename To, typename From>\n+static constexpr bool is_tautology() {\n+  return CheckedCastImpl::is_tautology<To, From>();\n+}\n+\n+template<typename To, typename From>\n+static constexpr bool check_normal(From from) {\n+  return !is_tautology<To, From>() && CheckedCastImpl::check<To, false>(from);\n+}\n+\n+template<typename To, typename From>\n+static constexpr bool check_tautological(From from) {\n+  return is_tautology<To, From>() && CheckedCastImpl::check<To, true>(from);\n+}\n+\n+template<typename T>\n+struct TestCheckedCastValues {\n+  static TestCheckedCastValues values;\n+\n+  T minus_one = static_cast<T>(-1);\n+  T zero = static_cast<T>(0);\n+  T one = static_cast<T>(1);\n+  T min = std::numeric_limits<T>::min();\n+  T max = std::numeric_limits<T>::max();\n+};\n+\n+template<typename T>\n+TestCheckedCastValues<T> TestCheckedCastValues<T>::values{};\n+\n+template<typename Small, typename Large>\n+struct TestCheckedCastSmallAsLargeValues {\n+  static TestCheckedCastSmallAsLargeValues values;\n+\n+  Large min = static_cast<Large>(std::numeric_limits<Small>::min());\n+  Large max = static_cast<Large>(std::numeric_limits<Small>::max());\n+};\n+\n+template<typename Small, typename Large>\n+TestCheckedCastSmallAsLargeValues<Small, Large>\n+TestCheckedCastSmallAsLargeValues<Small, Large>::values{};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Checked casts between integral types of different sizes.\n+\/\/ Test narrowing to verify checking.\n+\/\/ Test widening to verify no compiler warnings for tautological comparisons.\n+\n+template<typename Small, typename Large>\n+struct TestCheckedCastIntegerValues {\n+  static TestCheckedCastIntegerValues values;\n+\n+  TestCheckedCastValues<Small> small;\n+  TestCheckedCastValues<Large> large;\n+  TestCheckedCastSmallAsLargeValues<Small, Large> small_as_large;\n+};\n+\n+template<typename Small, typename Large>\n+TestCheckedCastIntegerValues<Small, Large>\n+TestCheckedCastIntegerValues<Small, Large>::values{};\n+\n+TEST(TestCheckedCast, signed_integers) {\n+  using T32 = int32_t;\n+  using T64 = int64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_TRUE(check_normal<T32>(values.large.minus_one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.zero));\n+  EXPECT_TRUE(check_normal<T32>(values.large.one));\n+  EXPECT_FALSE(check_normal<T32>(values.large.min));\n+  EXPECT_FALSE(check_normal<T32>(values.large.max));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.min));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.max));\n+\n+  EXPECT_TRUE(check_tautological<T64>(values.small.minus_one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.zero));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.max));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.max));\n+}\n+\n+TEST(TestCheckedCast, unsigned_integers) {\n+  using T32 = uint32_t;\n+  using T64 = uint64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_FALSE(check_normal<T32>(values.large.minus_one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.zero));\n+  EXPECT_TRUE(check_normal<T32>(values.large.one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.min));\n+  EXPECT_FALSE(check_normal<T32>(values.large.max));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.min));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.min));\n+\n+  EXPECT_TRUE(check_tautological<T64>(values.small.minus_one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.zero));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.max));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.max));\n+}\n+\n+TEST(TestCheckedCast, unsigned_to_signed_integers) {\n+  using T32 = int32_t;\n+  using T64 = uint64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_FALSE(check_normal<T32>(values.large.minus_one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.zero));\n+  EXPECT_TRUE(check_normal<T32>(values.large.one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.min));\n+  EXPECT_FALSE(check_normal<T32>(values.large.max));\n+  EXPECT_FALSE(check_normal<T32>(values.small_as_large.min));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.max));\n+}\n+\n+TEST(TestCheckedCast, signed_to_unsigned_integers) {\n+  using T32 = uint32_t;\n+  using T64 = int64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_FALSE(check_normal<T32>(values.large.minus_one));\n+  EXPECT_TRUE(check_normal<T32>(values.large.zero));\n+  EXPECT_TRUE(check_normal<T32>(values.large.one));\n+  EXPECT_FALSE(check_normal<T32>(values.large.min));\n+  EXPECT_FALSE(check_normal<T32>(values.large.max));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.min));\n+  EXPECT_TRUE(check_normal<T32>(values.small_as_large.max));\n+}\n+\n+TEST(TestCheckedCast, unsigned_to_wide_signed_integers) {\n+  using T32 = uint32_t;\n+  using T64 = int64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_TRUE(check_tautological<T64>(values.small.minus_one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.zero));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.one));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small.max));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.max));\n+}\n+\n+TEST(TestCheckedCast, signed_to_wide_unsigned_integers) {\n+  using T32 = int32_t;\n+  using T64 = uint64_t;\n+  using Values = TestCheckedCastIntegerValues<T32, T64>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_FALSE(check_normal<T64>(values.small.minus_one));\n+  EXPECT_TRUE(check_normal<T64>(values.small.zero));\n+  EXPECT_TRUE(check_normal<T64>(values.small.one));\n+  EXPECT_FALSE(check_normal<T64>(values.small.min));\n+  EXPECT_TRUE(check_normal<T64>(values.small.max));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.min));\n+  EXPECT_TRUE(check_tautological<T64>(values.small_as_large.max));\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Checked casts from enum to integral.\n+\n+TEST(TestCheckedCast, enums) {\n+  using I = int;\n+  enum class TestEnum : I {};\n+  using Values = TestCheckedCastValues<I>;\n+  const Values& values = Values::values;\n+\n+  EXPECT_TRUE(check_normal<I>(static_cast<TestEnum>(values.minus_one)));\n+  EXPECT_TRUE(check_normal<I>(static_cast<TestEnum>(values.zero)));\n+  EXPECT_TRUE(check_normal<I>(static_cast<TestEnum>(values.one)));\n+  EXPECT_TRUE(check_normal<I>(static_cast<TestEnum>(values.min)));\n+  EXPECT_TRUE(check_normal<I>(static_cast<TestEnum>(values.max)));\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_checkedCast.cpp","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"}]}