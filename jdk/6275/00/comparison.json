{"files":[{"patch":"@@ -5447,1 +5447,3 @@\n-        return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);\n+        var spliterator = spliterator(array, startInclusive, endExclusive);\n+        if (startInclusive == endExclusive) return Stream.empty();\n+        return StreamSupport.stream(spliterator, false);\n@@ -5477,1 +5479,3 @@\n-        return StreamSupport.intStream(spliterator(array, startInclusive, endExclusive), false);\n+        var spliterator = spliterator(array, startInclusive, endExclusive);\n+        if (startInclusive == endExclusive) return IntStream.empty();\n+        return StreamSupport.intStream(spliterator, false);\n@@ -5507,1 +5511,3 @@\n-        return StreamSupport.longStream(spliterator(array, startInclusive, endExclusive), false);\n+        var spliterator = spliterator(array, startInclusive, endExclusive);\n+        if (startInclusive == endExclusive) return LongStream.empty();\n+        return StreamSupport.longStream(spliterator, false);\n@@ -5537,1 +5543,3 @@\n-        return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);\n+        var spliterator = spliterator(array, startInclusive, endExclusive);\n+        if (startInclusive == endExclusive) return DoubleStream.empty();\n+        return StreamSupport.doubleStream(spliterator, false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -743,1 +743,3 @@\n-        return StreamSupport.stream(spliterator(), false);\n+        var spliterator = spliterator();\n+        if (isEmpty()) return StreamSupport.emptyStream(spliterator);\n+        return StreamSupport.stream(spliterator, false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -957,1 +957,1 @@\n-        return StreamSupport.doubleStream(Spliterators.emptyDoubleSpliterator(), false);\n+        return new Streams.EmptyDoubleStream(Spliterators.emptyDoubleSpliterator());\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/DoubleStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -898,1 +898,1 @@\n-        return StreamSupport.intStream(Spliterators.emptyIntSpliterator(), false);\n+        return new Streams.EmptyIntStream(Spliterators.emptyIntSpliterator());\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/IntStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -887,1 +887,1 @@\n-        return StreamSupport.longStream(Spliterators.emptyLongSpliterator(), false);\n+        return new Streams.EmptyLongStream(Spliterators.emptyLongSpliterator());\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/LongStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);\n+        return new Streams.EmptyStream<>(Spliterators.emptySpliterator());\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Stream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Spliterators;\n@@ -318,0 +319,12 @@\n+\n+    \/**\n+     * Creates a new sequential empty {@code Stream} with the\n+     * characteristics of the provided {@code Spliterator}.\n+     *\n+     * @param <T> the type of stream elements\n+     * @param spliterator a {@code Spliterator} describing the stream elements\n+     * @return a new sequential empty {@code Stream}\n+     *\/\n+    public static <T> Stream<T> emptyStream(Spliterator<T> spliterator) {\n+        return new Streams.EmptyStream<>(spliterator);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSupport.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+import java.util.Collections;\n@@ -28,0 +31,6 @@\n+import java.util.DoubleSummaryStatistics;\n+import java.util.IntSummaryStatistics;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.LongSummaryStatistics;\n+import java.util.NoSuchElementException;\n@@ -29,0 +38,5 @@\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalInt;\n+import java.util.OptionalLong;\n+import java.util.PrimitiveIterator;\n@@ -30,0 +44,4 @@\n+import java.util.Spliterators;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n@@ -31,0 +49,1 @@\n+import java.util.function.DoubleBinaryOperator;\n@@ -32,0 +51,7 @@\n+import java.util.function.DoubleFunction;\n+import java.util.function.DoublePredicate;\n+import java.util.function.DoubleToIntFunction;\n+import java.util.function.DoubleToLongFunction;\n+import java.util.function.DoubleUnaryOperator;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n@@ -33,0 +59,6 @@\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n+import java.util.function.IntToDoubleFunction;\n+import java.util.function.IntToLongFunction;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.LongBinaryOperator;\n@@ -34,1 +66,13 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import java.util.function.LongFunction;\n+import java.util.function.LongPredicate;\n+import java.util.function.LongToDoubleFunction;\n+import java.util.function.LongToIntFunction;\n+import java.util.function.LongUnaryOperator;\n+import java.util.function.ObjDoubleConsumer;\n+import java.util.function.ObjIntConsumer;\n+import java.util.function.ObjLongConsumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n@@ -888,0 +932,1383 @@\n+\n+    private static final int DISTINCT = Spliterator.DISTINCT; \/\/ 0x1\n+    private static final int OPERATED_ON = 0x2;\n+    private static final int SORTED = Spliterator.SORTED; \/\/ 0x4\n+    private static final int CLOSED = 0x8;\n+    private static final int ORDERED = Spliterator.ORDERED; \/\/ 0x10\n+    private static final int PARALLEL = 0x20;\n+    private static final int SIZED = Spliterator.SIZED; \/\/ 0x40\n+    private static final int NONNULL = Spliterator.NONNULL; \/\/ 0x100\n+    private static final int IMMUTABLE = Spliterator.IMMUTABLE; \/\/ 0x400\n+    private static final int CONCURRENT = Spliterator.CONCURRENT; \/\/ 0x1000\n+    private static final int SUBSIZED = Spliterator.SUBSIZED; \/\/ 0x4000\n+    private static final int EXTRA_FLAGS = OPERATED_ON | CLOSED | PARALLEL;\n+\n+    private static sealed class EmptyBaseStream {\n+        private int state = 0;\n+\n+        public EmptyBaseStream(EmptyBaseStream input) {\n+            this.state = input.state & ~(OPERATED_ON);\n+        }\n+\n+        public EmptyBaseStream(Spliterator<?> spliterator) {\n+            this.state = spliterator.characteristics();\n+        }\n+\n+        protected final void checkIfOperatedOnOrClosed() {\n+            if ((state & (OPERATED_ON | CLOSED)) != 0) {\n+                throw new IllegalStateException(\n+                        \"stream has already been operated upon or closed\"\n+                );\n+            }\n+        }\n+\n+        protected final void checkIfOperatedOnOrClosedAndChangeState() {\n+            checkIfOperatedOnOrClosed();\n+            state |= OPERATED_ON;\n+        }\n+\n+        protected final void stateDistinct(boolean hasComparator) {\n+            state |= DISTINCT;\n+            state &= ~(SIZED | SUBSIZED | CONCURRENT | NONNULL | IMMUTABLE);\n+            if (hasComparator)\n+                state &= ~(SORTED);\n+        }\n+\n+        protected final void stateDistinctPrimitiveStream() {\n+            state &= ~(SIZED | SUBSIZED | IMMUTABLE | SORTED);\n+        }\n+\n+        protected void stateSorted() {\n+            state |= SORTED | ORDERED;\n+            state &= ~(CONCURRENT | NONNULL | IMMUTABLE);\n+        }\n+\n+        protected final boolean isSorted() {\n+            return (state & SORTED) == SORTED;\n+        }\n+\n+        protected boolean stateIsUnordered() {\n+            return (state & ORDERED) == 0;\n+        }\n+\n+        protected void stateUnordered() {\n+            state &= ~ORDERED;\n+        }\n+\n+        protected final int stateBareCharacteristics() {\n+            return state & ~EXTRA_FLAGS;\n+        }\n+\n+        public final void close() {\n+            \/\/ nothing to do\n+            state |= CLOSED;\n+        }\n+    }\n+\n+\n+    \/**\n+     * EmptyStream is an optimization to reduce object allocation\n+     * during stream creation for empty streams. Most of the\n+     * methods such as filter() and map() will return \"this\".\n+     * We have tried to mirror the behavior of the previous\n+     * Stream.empty() for spliterator characteristics, parallel()\n+     * and\n+     *\n+     * @param <T>\n+     *\/\n+    static final class EmptyStream<T> extends EmptyBaseStream implements Stream<T> {\n+        private final Comparator<? super T> comparator;\n+\n+        public EmptyStream(EmptyBaseStream input) {\n+            super(input);\n+            comparator = null;\n+        }\n+\n+        public EmptyStream(Spliterator<T> spliterator) {\n+            super(spliterator);\n+            comparator = spliterator.hasCharacteristics(Spliterator.SORTED) ?\n+                    spliterator.getComparator() : null;\n+        }\n+\n+        @Override\n+        public Stream<T> filter(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public <R> Stream<R> map(Function<? super T, ? extends R> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public IntStream mapToInt(ToIntFunction<? super T> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public LongStream mapToLong(ToLongFunction<? super T> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public <R> Stream<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public IntStream mapMultiToInt(BiConsumer<? super T, ? super IntConsumer> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public LongStream mapMultiToLong(BiConsumer<? super T, ? super LongConsumer> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream mapMultiToDouble(BiConsumer<? super T, ? super DoubleConsumer> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public Stream<T> distinct() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateDistinct(comparator != null);\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> sorted() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateSorted();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> sorted(Comparator<? super T> comparator) {\n+            \/\/ the check is the other way round to normal\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(comparator);\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> peek(Consumer<? super T> action) {\n+            Objects.requireNonNull(action);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> limit(long maxSize) {\n+            if (maxSize < 0)\n+                throw new IllegalArgumentException(Long.toString(maxSize));\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> skip(long n) {\n+            if (n < 0)\n+                throw new IllegalArgumentException(Long.toString(n));\n+            if (n == 0) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> takeWhile(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> dropWhile(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public void forEach(Consumer<? super T> action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public void forEachOrdered(Consumer<? super T> action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        private static final Object[] EMPTY_ARRAY = {};\n+\n+        @Override\n+        public Object[] toArray() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ARRAY;\n+        }\n+\n+        @Override\n+        public <A> A[] toArray(IntFunction<A[]> generator) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(generator);\n+            return Objects.requireNonNull(generator.apply(0));\n+        }\n+\n+        @Override\n+        public T reduce(T identity, BinaryOperator<T> accumulator) {\n+            Objects.requireNonNull(accumulator);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return identity;\n+        }\n+\n+        @Override\n+        public Optional<T> reduce(BinaryOperator<T> accumulator) {\n+            Objects.requireNonNull(accumulator);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {\n+            Objects.requireNonNull(accumulator);\n+            Objects.requireNonNull(combiner);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return identity;\n+        }\n+\n+        @Override\n+        public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {\n+            Objects.requireNonNull(supplier);\n+            Objects.requireNonNull(accumulator);\n+            Objects.requireNonNull(combiner);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return supplier.get();\n+        }\n+\n+        @Override\n+        public <R, A> R collect(Collector<? super T, A, R> collector) {\n+            Objects.requireNonNull(collector);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return collector.finisher().apply(collector.supplier().get());\n+        }\n+\n+        @Override\n+        public List<T> toList() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return List.of();\n+        }\n+\n+        @Override\n+        public Optional<T> min(Comparator<? super T> comparator) {\n+            Objects.requireNonNull(comparator);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<T> max(Comparator<? super T> comparator) {\n+            Objects.requireNonNull(comparator);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public long count() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0L;\n+        }\n+\n+        @Override\n+        public boolean anyMatch(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean allMatch(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean noneMatch(Predicate<? super T> predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public Optional<T> findFirst() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<T> findAny() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return Collections.emptyIterator();\n+        }\n+\n+        @Override\n+        public Spliterator<T> spliterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            if (isSorted())\n+                return new EmptySpliterator.OfRefSorted<>(stateBareCharacteristics(), comparator);\n+            else\n+                return new EmptySpliterator.OfRef<>(stateBareCharacteristics());\n+        }\n+\n+\n+        @Override\n+        public boolean isParallel() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Stream<T> sequential() {\n+            return this;\n+        }\n+\n+        @Override\n+        public Stream<T> parallel() {\n+            return StreamSupport.stream(spliterator(), true);\n+        }\n+\n+        @Override\n+        public Stream<T> unordered() {\n+            checkIfOperatedOnOrClosed();\n+            if (super.stateIsUnordered()) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateUnordered();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public Stream<T> onClose(Runnable closeHandler) {\n+            return StreamSupport.stream(\n+                    spliterator(), isParallel()\n+            ).onClose(closeHandler);\n+        }\n+    }\n+\n+    static final class EmptyIntStream extends EmptyBaseStream implements IntStream {\n+        public EmptyIntStream(EmptyBaseStream input) {\n+            super(input);\n+        }\n+\n+        public EmptyIntStream(Spliterator.OfInt spliterator) {\n+            super(spliterator);\n+        }\n+\n+        @Override\n+        public IntStream filter(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream map(IntUnaryOperator mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public <U> Stream<U> mapToObj(IntFunction<? extends U> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public LongStream mapToLong(IntToLongFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream mapToDouble(IntToDoubleFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public IntStream flatMap(IntFunction<? extends IntStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream mapMulti(IntMapMultiConsumer mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream distinct() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateDistinctPrimitiveStream();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream sorted() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateSorted();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream peek(IntConsumer action) {\n+            Objects.requireNonNull(action);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream limit(long maxSize) {\n+            if (maxSize < 0)\n+                throw new IllegalArgumentException(Long.toString(maxSize));\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream skip(long n) {\n+            if (n < 0)\n+                throw new IllegalArgumentException(Long.toString(n));\n+            if (n == 0) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream takeWhile(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream dropWhile(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public void forEach(IntConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public void forEachOrdered(IntConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        private static final int[] EMPTY_ARRAY = {};\n+\n+        @Override\n+        public int[] toArray() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ARRAY;\n+        }\n+\n+        @Override\n+        public int reduce(int identity, IntBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return identity;\n+        }\n+\n+        @Override\n+        public OptionalInt reduce(IntBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalInt.empty();\n+        }\n+\n+        @Override\n+        public <R> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner) {\n+            Objects.requireNonNull(supplier);\n+            Objects.requireNonNull(accumulator);\n+            Objects.requireNonNull(combiner);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return supplier.get();\n+        }\n+\n+        @Override\n+        public OptionalInt min() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalInt.empty();\n+        }\n+\n+        @Override\n+        public OptionalInt max() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalInt.empty();\n+        }\n+\n+        @Override\n+        public long count() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0L;\n+        }\n+\n+        @Override\n+        public boolean anyMatch(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean allMatch(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean noneMatch(IntPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public OptionalInt findFirst() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalInt.empty();\n+        }\n+\n+        @Override\n+        public OptionalInt findAny() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalInt.empty();\n+        }\n+\n+        private static final PrimitiveIterator.OfInt EMPTY_ITERATOR =\n+                new PrimitiveIterator.OfInt() {\n+                    @Override\n+                    public int nextInt() {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+                };\n+\n+\n+        @Override\n+        public PrimitiveIterator.OfInt iterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ITERATOR;\n+        }\n+\n+        @Override\n+        public Spliterator.OfInt spliterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptySpliterator.OfInt(stateBareCharacteristics());\n+        }\n+\n+        @Override\n+        public boolean isParallel() {\n+            return false;\n+        }\n+\n+        @Override\n+        public IntStream sequential() {\n+            return this;\n+        }\n+\n+        @Override\n+        public IntStream parallel() {\n+            return StreamSupport.intStream(spliterator(), true);\n+        }\n+\n+        @Override\n+        public IntStream unordered() {\n+            if (super.stateIsUnordered()) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateUnordered();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public IntStream onClose(Runnable closeHandler) {\n+            return StreamSupport.intStream(\n+                    spliterator(), isParallel()\n+            ).onClose(closeHandler);\n+        }\n+\n+        @Override\n+        public int sum() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0;\n+        }\n+\n+        @Override\n+        public OptionalDouble average() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public IntSummaryStatistics summaryStatistics() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new IntSummaryStatistics();\n+        }\n+\n+        @Override\n+        public LongStream asLongStream() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream asDoubleStream() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public Stream<Integer> boxed() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+    }\n+\n+    static final class EmptyLongStream extends EmptyBaseStream implements LongStream {\n+        public EmptyLongStream(EmptyBaseStream input) {\n+            super(input);\n+        }\n+\n+        public EmptyLongStream(Spliterator.OfLong spliterator) {\n+            super(spliterator);\n+        }\n+\n+        @Override\n+        public LongStream filter(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream map(LongUnaryOperator mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public <U> Stream<U> mapToObj(LongFunction<? extends U> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public IntStream mapToInt(LongToIntFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream mapToDouble(LongToDoubleFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public LongStream flatMap(LongFunction<? extends LongStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream mapMulti(LongMapMultiConsumer mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream distinct() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateDistinctPrimitiveStream();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream sorted() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateSorted();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream peek(LongConsumer action) {\n+            Objects.requireNonNull(action);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream limit(long maxSize) {\n+            if (maxSize < 0)\n+                throw new IllegalArgumentException(Long.toString(maxSize));\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream skip(long n) {\n+            if (n < 0)\n+                throw new IllegalArgumentException(Long.toString(n));\n+            if (n == 0) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream takeWhile(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream dropWhile(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public void forEach(LongConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public void forEachOrdered(LongConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        private static final long[] EMPTY_ARRAY = {};\n+\n+        @Override\n+        public long[] toArray() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ARRAY;\n+        }\n+\n+        @Override\n+        public long reduce(long identity, LongBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return identity;\n+        }\n+\n+        @Override\n+        public OptionalLong reduce(LongBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalLong.empty();\n+        }\n+\n+        @Override\n+        public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {\n+            Objects.requireNonNull(supplier);\n+            Objects.requireNonNull(accumulator);\n+            Objects.requireNonNull(combiner);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return supplier.get();\n+        }\n+\n+        @Override\n+        public OptionalLong min() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalLong.empty();\n+        }\n+\n+        @Override\n+        public OptionalLong max() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalLong.empty();\n+        }\n+\n+        @Override\n+        public long count() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0L;\n+        }\n+\n+        @Override\n+        public boolean anyMatch(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean allMatch(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean noneMatch(LongPredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public OptionalLong findFirst() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalLong.empty();\n+        }\n+\n+        @Override\n+        public OptionalLong findAny() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalLong.empty();\n+        }\n+\n+        private static final PrimitiveIterator.OfLong EMPTY_ITERATOR =\n+                new PrimitiveIterator.OfLong() {\n+                    @Override\n+                    public long nextLong() {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+                };\n+\n+\n+        @Override\n+        public PrimitiveIterator.OfLong iterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ITERATOR;\n+        }\n+\n+        @Override\n+        public Spliterator.OfLong spliterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptySpliterator.OfLong(stateBareCharacteristics());\n+        }\n+\n+        @Override\n+        public boolean isParallel() {\n+            return false;\n+        }\n+\n+        @Override\n+        public LongStream sequential() {\n+            return this;\n+        }\n+\n+        @Override\n+        public LongStream parallel() {\n+            return StreamSupport.longStream(spliterator(), true);\n+        }\n+\n+        @Override\n+        public LongStream unordered() {\n+            if (super.stateIsUnordered()) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateUnordered();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public LongStream onClose(Runnable closeHandler) {\n+            return StreamSupport.longStream(\n+                    spliterator(), isParallel()\n+            ).onClose(closeHandler);\n+        }\n+\n+        @Override\n+        public long sum() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0;\n+        }\n+\n+        @Override\n+        public OptionalDouble average() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public LongSummaryStatistics summaryStatistics() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new LongSummaryStatistics();\n+        }\n+\n+        @Override\n+        public DoubleStream asDoubleStream() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public Stream<Long> boxed() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+    }\n+\n+    static final class EmptyDoubleStream extends EmptyBaseStream implements DoubleStream {\n+        public EmptyDoubleStream(EmptyBaseStream input) {\n+            super(input);\n+        }\n+\n+        public EmptyDoubleStream(Spliterator.OfDouble spliterator) {\n+            super(spliterator);\n+        }\n+\n+        @Override\n+        public DoubleStream filter(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream map(DoubleUnaryOperator mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public <U> Stream<U> mapToObj(DoubleFunction<? extends U> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+\n+        @Override\n+        public IntStream mapToInt(DoubleToIntFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyIntStream(this);\n+        }\n+\n+        @Override\n+        public LongStream mapToLong(DoubleToLongFunction mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyLongStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream flatMap(DoubleFunction<? extends DoubleStream> mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream mapMulti(DoubleMapMultiConsumer mapper) {\n+            Objects.requireNonNull(mapper);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream distinct() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateDistinctPrimitiveStream();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream sorted() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateSorted();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream peek(DoubleConsumer action) {\n+            Objects.requireNonNull(action);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream limit(long maxSize) {\n+            if (maxSize < 0)\n+                throw new IllegalArgumentException(Double.toString(maxSize));\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream skip(long n) {\n+            if (n < 0)\n+                throw new IllegalArgumentException(Double.toString(n));\n+            if (n == 0) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream takeWhile(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream dropWhile(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public void forEach(DoubleConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public void forEachOrdered(DoubleConsumer action) {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            Objects.requireNonNull(action);\n+            \/\/ do nothing\n+        }\n+\n+        private static final double[] EMPTY_ARRAY = {};\n+\n+        @Override\n+        public double[] toArray() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ARRAY;\n+        }\n+\n+        @Override\n+        public double reduce(double identity, DoubleBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return identity;\n+        }\n+\n+        @Override\n+        public OptionalDouble reduce(DoubleBinaryOperator op) {\n+            Objects.requireNonNull(op);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {\n+            Objects.requireNonNull(supplier);\n+            Objects.requireNonNull(accumulator);\n+            Objects.requireNonNull(combiner);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return supplier.get();\n+        }\n+\n+        @Override\n+        public OptionalDouble min() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public OptionalDouble max() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public long count() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0L;\n+        }\n+\n+        @Override\n+        public boolean anyMatch(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean allMatch(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean noneMatch(DoublePredicate predicate) {\n+            Objects.requireNonNull(predicate);\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return true;\n+        }\n+\n+        @Override\n+        public OptionalDouble findFirst() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public OptionalDouble findAny() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        private static final PrimitiveIterator.OfDouble EMPTY_ITERATOR =\n+                new PrimitiveIterator.OfDouble() {\n+                    @Override\n+                    public double nextDouble() {\n+                        throw new NoSuchElementException();\n+                    }\n+\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+                };\n+\n+\n+        @Override\n+        public PrimitiveIterator.OfDouble iterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return EMPTY_ITERATOR;\n+        }\n+\n+        @Override\n+        public Spliterator.OfDouble spliterator() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptySpliterator.OfDouble(stateBareCharacteristics());\n+        }\n+\n+        @Override\n+        public boolean isParallel() {\n+            return false;\n+        }\n+\n+        @Override\n+        public DoubleStream sequential() {\n+            return this;\n+        }\n+\n+        @Override\n+        public DoubleStream parallel() {\n+            return StreamSupport.doubleStream(spliterator(), true);\n+        }\n+\n+        @Override\n+        public DoubleStream unordered() {\n+            if (super.stateIsUnordered()) return this;\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            super.stateUnordered();\n+            return new EmptyDoubleStream(this);\n+        }\n+\n+        @Override\n+        public DoubleStream onClose(Runnable closeHandler) {\n+            return StreamSupport.doubleStream(\n+                    spliterator(), isParallel()\n+            ).onClose(closeHandler);\n+        }\n+\n+        @Override\n+        public double sum() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return 0;\n+        }\n+\n+        @Override\n+        public OptionalDouble average() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return OptionalDouble.empty();\n+        }\n+\n+        @Override\n+        public DoubleSummaryStatistics summaryStatistics() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new DoubleSummaryStatistics();\n+        }\n+\n+        @Override\n+        public Stream<Double> boxed() {\n+            checkIfOperatedOnOrClosedAndChangeState();\n+            return new EmptyStream<>(this);\n+        }\n+    }\n+\n+    private abstract static class EmptySpliterator<T, S extends Spliterator<T>, C> {\n+        private final int characteristics;\n+\n+        EmptySpliterator(int characteristics) {\n+            this.characteristics = characteristics;\n+        }\n+\n+        public S trySplit() {\n+            return null;\n+        }\n+\n+        public boolean tryAdvance(C consumer) {\n+            Objects.requireNonNull(consumer);\n+            return false;\n+        }\n+\n+        public void forEachRemaining(C consumer) {\n+            Objects.requireNonNull(consumer);\n+        }\n+\n+        public long estimateSize() {\n+            return 0;\n+        }\n+\n+        public int characteristics() {\n+            return characteristics;\n+        }\n+\n+        private static final class OfRef<T>\n+                extends EmptySpliterator<T, Spliterator<T>, Consumer<? super T>>\n+                implements Spliterator<T> {\n+            OfRef(int characteristics) {\n+                super(characteristics);\n+            }\n+        }\n+\n+        private static final class OfRefSorted<T>\n+                extends EmptySpliterator<T, Spliterator<T>, Consumer<? super T>>\n+                implements Spliterator<T> {\n+            private final Comparator<? super T> comparator;\n+\n+            OfRefSorted(int characteristics, Comparator<? super T> comparator) {\n+                super(characteristics);\n+                if (!hasCharacteristics(SORTED))\n+                    throw new IllegalArgumentException(\"Spliterator only for SORTED\");\n+                this.comparator = comparator;\n+            }\n+\n+            @Override\n+            public Comparator<? super T> getComparator() {\n+                return comparator;\n+            }\n+        }\n+\n+        private static final class OfInt\n+                extends EmptySpliterator<Integer, Spliterator.OfInt, IntConsumer>\n+                implements Spliterator.OfInt {\n+            OfInt(int characteristics) {\n+                super(characteristics);\n+            }\n+        }\n+\n+        private static final class OfLong\n+                extends EmptySpliterator<Long, Spliterator.OfLong, LongConsumer>\n+                implements Spliterator.OfLong {\n+            OfLong(int characteristics) {\n+                super(characteristics);\n+            }\n+        }\n+\n+        private static final class OfDouble\n+                extends EmptySpliterator<Double, Spliterator.OfDouble, DoubleConsumer>\n+                implements Spliterator.OfDouble {\n+            OfDouble(int characteristics) {\n+                super(characteristics);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Streams.java","additions":1428,"deletions":1,"binary":false,"changes":1429,"status":"modified"},{"patch":"@@ -0,0 +1,467 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalInt;\n+import java.util.OptionalLong;\n+import java.util.Spliterator;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.BaseStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * The new EmptyStream, EmptyIntStream, etc. are supposed to\n+ * be drop-in replacements for the previous Stream.empty(),\n+ * IntStream.empty(), etc. factory methods, which used to be\n+ * generated using {@link\n+ * StreamSupport#stream(Spliterator, boolean)}. In our tests,\n+ * we thus compare all the behavior of the empty streams, to\n+ * ensure that they are exactly the same as before.\n+ * <p>\n+ * Implementations of this class have to implement the testAll()\n+ * method, in which we would call\n+ * {@link EmptyBaseStreamTest#compare(Class, Supplier, Supplier)}\n+ * The BaseStreamTest checks the methods in the BaseStream,\n+ * such as parallel(), unordered(), spliterator(), iterator(),\n+ * onClose(), etc. Subclasses implement the testAll() method\n+ * and then call compare() with the type that we are\n+ *\n+ * @author Heinz Kabutz heinz@javaspecialists.eu\n+ *\/\n+\n+sealed abstract class EmptyBaseStreamTest permits EmptyDoubleStreamTest,\n+        EmptyIntStreamTest, EmptyLongStreamTest, EmptyStreamTest {\n+    @Test\n+    public abstract void testAll();\n+\n+    protected final <T> T failing(Class<T> clazz) {\n+        return clazz.cast(\n+                Proxy.newProxyInstance(\n+                        clazz.getClassLoader(),\n+                        new Class<?>[]{clazz},\n+                        (proxy, method, args) -> {\n+                            throw new AssertionError();\n+                        }));\n+    }\n+\n+    \/**\n+     * Helper function that uses reflection to call the rest of the\n+     * test method, depending on the parameter types. For example,\n+     * to test the Stream class, we would search for methods\n+     * beginning with \"test\" and with two Stream.class parameters,\n+     * such as {@link testFilter(Stream,Stream)}.\n+     *\n+     * @param type             the type of parameters to find test\n+     *                         methods for\n+     * @param actualSupplier   creates the actual stream\n+     * @param expectedSupplier creates the expected stream\n+     * @throws ReflectiveOperationException\n+     *\/\n+    protected final void compare(Class<?> type,\n+                                 Supplier<?> actualSupplier,\n+                                 Supplier<?> expectedSupplier) {\n+        if (type == null) return;\n+        for (Class<?> superInterface : type.getInterfaces()) {\n+            compare(superInterface, actualSupplier, expectedSupplier);\n+        }\n+        try {\n+            Class<?>[] parameterTypes = {type, type};\n+            for (Method method : getClass().getMethods()) {\n+                if (method.getName().startsWith(\"test\") &&\n+                        method.getParameterCount() == 2 &&\n+                        Arrays.equals(parameterTypes,\n+                                method.getParameterTypes())) {\n+                    method.invoke(this, actualSupplier.get(),\n+                            expectedSupplier.get());\n+                }\n+            }\n+        } catch (InvocationTargetException e) {\n+            try {\n+                throw e.getCause();\n+            } catch (RuntimeException | Error cause) {\n+                throw cause;\n+            } catch (Throwable other) {\n+                throw new AssertionError(other);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    private static final Map<Class<?>, Object> magicMap = Map.of(\n+            int.class, 42,\n+            long.class, 42L,\n+            double.class, 42.0\n+    );\n+\n+    private Object createMagic(Class<?> type) {\n+        return magicMap.getOrDefault(type, magicMap.get(int.class));\n+    }\n+\n+    protected final Class<? extends Throwable> getThrowableType(ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+            return null;\n+        } catch (Throwable e) {\n+            return e.getClass();\n+        }\n+    }\n+\n+    protected final void checkExpectedExceptions(\n+            BaseStream<?, ?> actual, BaseStream<?, ?> expected,\n+            String methodName, Class<?>... parameterTypes) {\n+        try {\n+            Method method = findMethod(actual, methodName, parameterTypes);\n+            Object[] parameters = Arrays.stream(parameterTypes)\n+                    .map(type -> type.isInterface() ? failing(type) : createMagic(type))\n+                    .toArray();\n+            invokeWithNullParameters(actual, expected, method, parameters);\n+            checkExceptionsAreTheSame(actual, expected, method, parameters);\n+            invokeWithNullParameters(actual, expected, method, parameters);\n+            checkExceptionsAreTheSame(actual, expected, method, parameters);\n+            invokeWithNullParameters(actual, expected, method, parameters);\n+            checkExceptionsAreTheSame(actual, expected, method, parameters);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    private void checkExceptionsAreTheSame(BaseStream<?, ?> actual, BaseStream<?, ?> expected, Method method, Object[] parameters) {\n+        var actualExceptionType = getThrowableType(actual, method, parameters);\n+        var expectedExceptionType = getThrowableType(expected, method, parameters);\n+        assertSame(actualExceptionType, expectedExceptionType,\n+                getExpectedExceptionMessage(actualExceptionType, expectedExceptionType, method, parameters));\n+    }\n+\n+    private String getExpectedExceptionMessage(Class<?> actualExceptionType, Class<?> expectedExceptionType, Method method, Object[] parameters) {\n+        return \"Got \" + (actualExceptionType == null ? \"no exception\" : actualExceptionType.getName())\n+                + \" from method \" + method.getName() +\n+                (Arrays.stream(parameters).map(o -> o == null ? \"null\" : \"?\")\n+                        .collect(Collectors.joining(\", \", \"(\", \")\"))) +\n+                \" but was hoping for \" + (expectedExceptionType == null ? \"no exception\" : expectedExceptionType.getName());\n+    }\n+\n+    private void invokeWithNullParameters(BaseStream<?, ?> actual, BaseStream<?, ?> expected,\n+                                          Method method, Object[] parameters) {\n+        for (int i = 0; i < parameters.length; i++) {\n+            if (!(parameters[i] instanceof Number)) {\n+                Object savedParameter = parameters[i];\n+                parameters[i] = null;\n+                var actualThrowable = getThrowableType(actual, method, parameters);\n+                var expectedThrowable = getThrowableType(expected, method, parameters);\n+                assertSame(actualThrowable, expectedThrowable,\n+                        getExpectedExceptionMessage(actualThrowable, expectedThrowable, method, parameters));\n+                parameters[i] = savedParameter;\n+            }\n+        }\n+    }\n+\n+    private Class<?> getThrowableType(BaseStream<?, ?> stream, Method method, Object[] parameters) {\n+        try {\n+            method.invoke(stream, parameters);\n+        } catch (InvocationTargetException ite) {\n+            return ite.getCause().getClass();\n+        } catch (IllegalAccessException e) {\n+            return e.getClass();\n+        }\n+        return null;\n+    }\n+\n+    protected final void compareResults(Object actual, Object expected) {\n+        assertSame(actual.getClass(), expected.getClass());\n+        if (actual instanceof List<?> actualList\n+                && expected instanceof List<?> expectedList) {\n+            assertEquals(actualList, expectedList);\n+            assertTrue(actualList.isEmpty());\n+        } else if (actual.getClass().isArray()\n+                && expected.getClass().isArray()) {\n+            assertEquals(Array.getLength(actual), Array.getLength(expected));\n+        } else if (actual instanceof Optional<?> actualOptional\n+                && expected instanceof Optional<?> expectedOptional) {\n+            assertEquals(actualOptional, expectedOptional);\n+            assertTrue(actualOptional.isEmpty());\n+        } else if (actual instanceof OptionalInt actualOptional\n+                && expected instanceof OptionalInt expectedOptional) {\n+            assertEquals(actualOptional, expectedOptional);\n+            assertTrue(actualOptional.isEmpty());\n+        } else if (actual instanceof OptionalLong actualOptional\n+                && expected instanceof OptionalLong expectedOptional) {\n+            assertEquals(actualOptional, expectedOptional);\n+            assertTrue(actualOptional.isEmpty());\n+        } else if (actual instanceof OptionalDouble actualOptional\n+                && expected instanceof OptionalDouble expectedOptional) {\n+            assertEquals(actualOptional, expectedOptional);\n+            assertTrue(actualOptional.isEmpty());\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid parameter types\");\n+        }\n+    }\n+\n+    \/\/\/\/\/ Methods from BaseStream\n+\n+    public final void testIterator(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = actual.iterator();\n+        var expectedResult = expected.iterator();\n+        assertEquals(actualResult.hasNext(), expectedResult.hasNext());\n+        assertThrows(NoSuchElementException.class, actualResult::next);\n+        assertThrows(NoSuchElementException.class, expectedResult::next);\n+        try {\n+            actualResult.remove();\n+            fail();\n+        } catch (IllegalStateException | UnsupportedOperationException ignore) {\n+        }\n+        try {\n+            expectedResult.remove();\n+            fail();\n+        } catch (IllegalStateException | UnsupportedOperationException ignore) {\n+        }\n+    }\n+\n+    public final void testIteratorCannotBeCalledAgain(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        checkExpectedExceptions(actual, expected, \"iterator\");\n+    }\n+\n+    public final void testSequential(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        actual = actual.sequential().parallel().sequential();\n+        expected = expected.sequential().parallel().sequential();\n+        var actualResult = actual.isParallel();\n+        var expectedResult = expected.isParallel();\n+        assertEquals(actualResult, expectedResult);\n+        assertFalse(actualResult);\n+    }\n+\n+    public final void testSequentialIgnoringExpected(BaseStream<?, ?> actual, BaseStream<?, ?> ignored) {\n+        assertSame(actual, actual.sequential());\n+    }\n+\n+    public final void testParallelAndIsParallel(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ The correct way of invoking parallel is to have it inside\n+        \/\/ a call chain, since we might return a new stream (in our\n+        \/\/ emptyStream() case we do)\n+        actual = actual.parallel();\n+        expected = expected.parallel();\n+        var actualResult = actual.isParallel();\n+        var expectedResult = expected.isParallel();\n+        assertEquals(actualResult, expectedResult);\n+        assertTrue(actualResult);\n+    }\n+\n+    public final void testUnordered(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = actual.unordered().spliterator();\n+        var expectedResult = expected.unordered().spliterator();\n+        assertEquals(actualResult.hasCharacteristics(Spliterator.ORDERED),\n+                expectedResult.hasCharacteristics(Spliterator.ORDERED));\n+        assertFalse(actualResult.hasCharacteristics(Spliterator.ORDERED));\n+    }\n+\n+    public final void testUnorderedExceptions(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        checkExpectedExceptions(actual, expected, \"unordered\");\n+    }\n+\n+    public final void testOnCloseAndClose(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = new AtomicBoolean(false);\n+        var expectedResult = new AtomicBoolean(false);\n+        actual.onClose(() -> actualResult.set(true)).close();\n+        expected.onClose(() -> expectedResult.set(true)).close();\n+        assertEquals(actualResult.get(), expectedResult.get());\n+        assertTrue(actualResult.get());\n+    }\n+\n+    public final void testCloseAndOnClose(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = new AtomicBoolean(false);\n+        var expectedResult = new AtomicBoolean(false);\n+        actual.close();\n+        expected.close();\n+        assertThrows(IllegalStateException.class, () -> actual.onClose(failing(Runnable.class)));\n+        assertThrows(IllegalStateException.class, () -> expected.onClose(failing(Runnable.class)));\n+    }\n+\n+    public final void testOnCloseExceptions(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        assertThrows(NullPointerException.class, () -> actual.onClose(null));\n+        assertThrows(NullPointerException.class, () -> expected.onClose(null));\n+    }\n+\n+    public final void testOnCloseCannotBeCalledAgain(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = actual.iterator();\n+        var expectedResult = expected.iterator();\n+        assertThrows(IllegalStateException.class, () -> actual.onClose(failing(Runnable.class)));\n+        assertThrows(IllegalStateException.class, () -> expected.onClose(failing(Runnable.class)));\n+    }\n+\n+    public final void testSpliterator(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = actual.spliterator();\n+        var expectedResult = expected.spliterator();\n+\n+        assertEquals(actualResult.characteristics(), expectedResult.characteristics());\n+        assertTrue(actualResult.estimateSize() == 0 || actualResult.estimateSize() == Long.MAX_VALUE,\n+                \"actualResult.estimateSize() = \" + actualResult.estimateSize());\n+        assertTrue(expectedResult.estimateSize() == 0 || expectedResult.estimateSize() == Long.MAX_VALUE,\n+                \"expectedResult.estimateSize() = \" + expectedResult.estimateSize());\n+\n+\/\/        assertTrue(actualResult.hasCharacteristics(Spliterator.SIZED));\n+\/\/        assertTrue(actualResult.hasCharacteristics(Spliterator.SUBSIZED));\n+\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.CONCURRENT));\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.DISTINCT));\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.IMMUTABLE));\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.NONNULL));\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.ORDERED));\n+\/\/        assertFalse(actualResult.hasCharacteristics(Spliterator.SORTED));\n+\n+        assertNull(actualResult.trySplit());\n+        actualResult.tryAdvance(failing(Consumer.class));\n+        actualResult.forEachRemaining(failing(Consumer.class));\n+    }\n+\n+    public final void testSpliteratorExceptions(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        checkExpectedExceptions(actual, expected, \"spliterator\");\n+    }\n+\n+    private void compareCharacteristics(BaseStream<?, ?> actual, BaseStream<?, ?> expected, String... methodsToCall) {\n+        try {\n+            for (String method : methodsToCall) {\n+                actual = (BaseStream<?, ?>) findMethod(actual, method).invoke(actual);\n+                expected = (BaseStream<?, ?>) findMethod(expected, method).invoke(expected);\n+            }\n+            var actualResult = actual.spliterator().characteristics();\n+            var expectedResult = expected.spliterator().characteristics();\n+            assertEquals(actualResult, expectedResult);\n+        } catch (InvocationTargetException e) {\n+            try {\n+                throw e.getCause();\n+            } catch (RuntimeException | Error cause) {\n+                throw cause;\n+            } catch (Throwable ex) {\n+                throw new AssertionError(ex);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    private Method findMethod(BaseStream<?, ?> stream,\n+                              String method,\n+                              Class<?>... parameterTypes) throws NoSuchMethodException {\n+        if (stream instanceof Stream)\n+            return Stream.class.getMethod(method, parameterTypes);\n+        if (stream instanceof IntStream)\n+            return IntStream.class.getMethod(method, parameterTypes);\n+        if (stream instanceof LongStream)\n+            return LongStream.class.getMethod(method, parameterTypes);\n+        if (stream instanceof DoubleStream)\n+            return DoubleStream.class.getMethod(method, parameterTypes);\n+        throw new AssertionError();\n+    }\n+\n+    private void compareCharacteristics(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        var actualResult = actual.spliterator().characteristics();\n+        var expectedResult = expected.spliterator().characteristics();\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public final void testCharacteristicsDistinct(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ distinct()\n+        compareCharacteristics(actual, expected, \"distinct\");\n+    }\n+\n+    public final void testCharacteristicsDistinctSorted(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ sorted().unordered().distinct()\n+        compareCharacteristics(actual, expected, \"sorted\", \"unordered\", \"distinct\");\n+    }\n+\n+    public final void testCharacteristicsDistinctOrderedSorted(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ distinct().sorted()\n+        compareCharacteristics(actual, expected, \"distinct\", \"sorted\");\n+    }\n+\n+    public final void testCharacteristicsSizedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ String.empty()\n+        compareCharacteristics(actual, expected);\n+    }\n+\n+    public final void testCharacteristicsSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ sorted().unordered()\n+        compareCharacteristics(actual, expected, \"sorted\", \"unordered\");\n+    }\n+\n+    public final void testCharacteristicsOrderedSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ sorted()\n+        compareCharacteristics(actual, expected, \"sorted\");\n+    }\n+\n+    public final void testCharacteristicsParallelDistinct(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel().distinct()\n+        compareCharacteristics(actual, expected, \"parallel\", \"distinct\");\n+    }\n+\n+    public final void testCharacteristicsParallelDistinctSorted(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel().sorted().unordered().distinct()\n+        compareCharacteristics(actual, expected, \"sorted\", \"unordered\", \"distinct\");\n+    }\n+\n+    public final void testCharacteristicsParallelSizedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel()\n+        compareCharacteristics(actual, expected, \"parallel\");\n+    }\n+\n+    public final void testCharacteristicsParallelSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel().sorted().unordered()\n+        compareCharacteristics(actual, expected, \"sorted\", \"unordered\");\n+    }\n+\n+    public final void testCharacteristicsParallelDistinctSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel().distinct().sorted().unordered()\n+        compareCharacteristics(actual, expected, \"distinct\", \"sorted\", \"unordered\");\n+    }\n+\n+    public final void testCharacteristicsParallelOrderedSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/ parallel().sorted()\n+        compareCharacteristics(actual, expected, \"parallel\", \"sorted\");\n+    }\n+\n+    public final void testCharacteristicsParallelDistinctOrderedSizedSortedSubsized(BaseStream<?, ?> actual, BaseStream<?, ?> expected) {\n+        \/\/parallel().distinct().sorted()\n+        compareCharacteristics(actual, expected, \"parallel\", \"distinct\", \"sorted\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/EmptyBaseStreamTest.java","additions":467,"deletions":0,"binary":false,"changes":467,"status":"added"},{"patch":"@@ -0,0 +1,448 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.Spliterators;\n+import java.util.function.BiConsumer;\n+import java.util.function.DoubleBinaryOperator;\n+import java.util.function.DoubleConsumer;\n+import java.util.function.DoubleFunction;\n+import java.util.function.DoublePredicate;\n+import java.util.function.DoubleToIntFunction;\n+import java.util.function.DoubleToLongFunction;\n+import java.util.function.DoubleUnaryOperator;\n+import java.util.function.ObjDoubleConsumer;\n+import java.util.function.Supplier;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Checks that the EmptyStream is equivalent to the\n+ * old way of creating it with StreamSupport.\n+ * @author Heinz Kabutz\n+ *\/\n+\n+public final class EmptyDoubleStreamTest extends EmptyBaseStreamTest {\n+    @Test\n+    public void testAll() {\n+        this.compare(DoubleStream.class,\n+                DoubleStream::empty, () -> StreamSupport.doubleStream(Spliterators.emptyDoubleSpliterator(), false)\n+        );\n+        this.compare(DoubleStream.class,\n+                () -> DoubleStream.empty().parallel(), () -> StreamSupport.doubleStream(Spliterators.emptyDoubleSpliterator(), true)\n+        );\n+    }\n+\n+    public void testFilter(DoubleStream actual, DoubleStream expected) {\n+        actual = actual.filter(failing(DoublePredicate.class));\n+        expected = expected.filter(failing(DoublePredicate.class));\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFilterExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"filter\", DoublePredicate.class);\n+    }\n+\n+    public void testMap(DoubleStream actual, DoubleStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.map(failing(DoubleUnaryOperator.class));\n+        DoubleStream expectedAsDoubleStream = expected.map(failing(DoubleUnaryOperator.class));\n+        var actualResult = actualAsDoubleStream.toArray();\n+        var expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"map\", DoubleUnaryOperator.class);\n+    }\n+\n+    public void testMapToObj(DoubleStream actual, DoubleStream expected) {\n+        Stream<Double> actualAsStream = actual.mapToObj(failing(DoubleFunction.class));\n+        Stream<Double> expectedAsStream = expected.mapToObj(failing(DoubleFunction.class));\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToObjExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToObj\", DoubleFunction.class);\n+    }\n+\n+    public void testMapToInt(DoubleStream actual, DoubleStream expected) {\n+        IntStream actualAsIntStream = actual.mapToInt(failing(DoubleToIntFunction.class));\n+        IntStream expectedAsIntStream = expected.mapToInt(failing(DoubleToIntFunction.class));\n+        var actualResult = actualAsIntStream.toArray();\n+        var expectedResult = expectedAsIntStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToIntExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToInt\", DoubleToIntFunction.class);\n+    }\n+\n+    public void testMapToDouble(DoubleStream actual, DoubleStream expected) {\n+        LongStream actualAsLongStream = actual.mapToLong(failing(DoubleToLongFunction.class));\n+        LongStream expectedAsLongStream = expected.mapToLong(failing(DoubleToLongFunction.class));\n+        var actualResult = actualAsLongStream.toArray();\n+        var expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToDoubleExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToLong\", DoubleToLongFunction.class);\n+    }\n+\n+    public void testFlatMap(DoubleStream actual, DoubleStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.flatMap(failing(DoubleFunction.class));\n+        DoubleStream expectedAsDoubleStream = expected.flatMap(failing(DoubleFunction.class));\n+        var actualResult = actualAsDoubleStream.toArray();\n+        var expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMap\", DoubleFunction.class);\n+    }\n+\n+    public void testDistinct(DoubleStream actual, DoubleStream expected) {\n+        actual = actual.distinct();\n+        expected = expected.distinct();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDistinctExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"distinct\");\n+    }\n+\n+    public void testSorted(DoubleStream actual, DoubleStream expected) {\n+        actual = actual.sorted();\n+        expected = expected.sorted();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSortedExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sorted\");\n+    }\n+\n+    public void testPeek(DoubleStream actual, DoubleStream expected) {\n+        actual.peek(failing(DoubleConsumer.class)).toArray();\n+        expected.peek(failing(DoubleConsumer.class)).toArray();\n+    }\n+\n+    public void testPeekExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"peek\", DoubleConsumer.class);\n+    }\n+\n+    public void testLimit(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.limit(10).toArray();\n+        var expectedResult = expected.limit(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testLimitExceptions(DoubleStream actual, DoubleStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.limit(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.limit(-1));\n+\n+        actual.limit(10);\n+        expected.limit(10);\n+        assertThrows(IllegalStateException.class, () -> actual.limit(10));\n+        assertThrows(IllegalStateException.class, () -> expected.limit(10));\n+    }\n+\n+    public void testSkip(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.skip(10).toArray();\n+        var expectedResult = expected.skip(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSkipExceptions(DoubleStream actual, DoubleStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.skip(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.skip(-1));\n+\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+\n+        actual.skip(10);\n+        expected.skip(10);\n+        assertThrows(IllegalStateException.class, () -> actual.skip(10));\n+        assertThrows(IllegalStateException.class, () -> expected.skip(10));\n+    }\n+\n+    public void testForEach(DoubleStream actual, DoubleStream expected) {\n+        actual.forEach(failing(DoubleConsumer.class));\n+        expected.forEach(failing(DoubleConsumer.class));\n+    }\n+\n+    public void testForEachExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEach\", DoubleConsumer.class);\n+    }\n+\n+    public void testForEachOrdered(DoubleStream actual, DoubleStream expected) {\n+        actual.forEachOrdered(failing(DoubleConsumer.class));\n+        expected.forEachOrdered(failing(DoubleConsumer.class));\n+    }\n+\n+    public void testForEachOrderedExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEachOrdered\", DoubleConsumer.class);\n+    }\n+\n+    public void testToArray(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testToArrayExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"toArray\");\n+    }\n+\n+    public void testReduceDoubleBinaryOperator(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.reduce(failing(DoubleBinaryOperator.class));\n+        var expectedResult = expected.reduce(failing(DoubleBinaryOperator.class));\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testReduceDoubleBinaryOperatorExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", DoubleBinaryOperator.class);\n+    }\n+\n+    public void testReduceIdentityDoubleBinaryOperator(DoubleStream actual, DoubleStream expected) {\n+        var magicIdentity = 42L;\n+        var actualResult = actual.reduce(magicIdentity, failing(DoubleBinaryOperator.class));\n+        var expectedResult = expected.reduce(magicIdentity, failing(DoubleBinaryOperator.class));\n+\n+        assertEquals(actualResult, magicIdentity);\n+        assertEquals(expectedResult, magicIdentity);\n+    }\n+\n+    public void testReduceIdentityDoubleBinaryOperatorExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", double.class, DoubleBinaryOperator.class);\n+    }\n+\n+    public void testCollect(DoubleStream actual, DoubleStream expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.collect(() -> magicIdentity, failing(ObjDoubleConsumer.class), failing(BiConsumer.class));\n+        var expectedResult = expected.collect(() -> magicIdentity, failing(ObjDoubleConsumer.class), failing(BiConsumer.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testCollectExceptions(DoubleStream actual, DoubleStream expected) {\n+        Supplier<Object> supplier = Object::new;\n+        var accumulator = failing(ObjDoubleConsumer.class);\n+        var combiner = failing(BiConsumer.class);\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        actual.collect(supplier, accumulator, combiner);\n+        expected.collect(supplier, accumulator, combiner);\n+\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        assertThrows(IllegalStateException.class, () -> actual.collect(supplier, accumulator, combiner));\n+        assertThrows(IllegalStateException.class, () -> expected.collect(supplier, accumulator, combiner));\n+    }\n+\n+    public void testSum(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.sum();\n+        var expectedResult = expected.sum();\n+\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0);\n+    }\n+\n+    public void testSumExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sum\");\n+    }\n+\n+    public void testMin(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.min();\n+        var expectedResult = expected.min();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMinExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"min\");\n+    }\n+\n+    public void testMax(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.max();\n+        var expectedResult = expected.max();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMaxExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"max\");\n+    }\n+\n+    public void testCount(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.count();\n+        var expectedResult = expected.count();\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0L);\n+    }\n+\n+    public void testCountExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"count\");\n+    }\n+\n+    public void testAverage(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.average();\n+        var expectedResult = expected.average();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAverageExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"average\");\n+    }\n+\n+    public void testSummaryStatistics(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.summaryStatistics().toString();\n+        var expectedResult = expected.summaryStatistics().toString();\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testSummaryStatisticsExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"summaryStatistics\");\n+    }\n+\n+    public void testAnyMatch(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.anyMatch(failing(DoublePredicate.class));\n+        var expectedResult = expected.anyMatch(failing(DoublePredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAnyMatchExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"anyMatch\", DoublePredicate.class);\n+    }\n+\n+    public void testAllMatch(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.allMatch(failing(DoublePredicate.class));\n+        var expectedResult = expected.allMatch(failing(DoublePredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAllMatchExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"allMatch\", DoublePredicate.class);\n+    }\n+\n+    public void testNoneMatch(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.noneMatch(failing(DoublePredicate.class));\n+        var expectedResult = expected.noneMatch(failing(DoublePredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testNoneMatchExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"noneMatch\", DoublePredicate.class);\n+    }\n+\n+    public void testFindFirst(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.findFirst();\n+        var expectedResult = expected.findFirst();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindFirstExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findFirst\");\n+    }\n+\n+    public void testFindAny(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.findAny();\n+        var expectedResult = expected.findAny();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindAnyExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findAny\");\n+    }\n+\n+    public void testBoxed(DoubleStream actual, DoubleStream expected) {\n+        Stream<Double> actualAsStream = actual.boxed();\n+        Stream<Double> expectedAsStream = expected.boxed();\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testBoxedExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"boxed\");\n+    }\n+\n+    public void testMapMulti(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.mapMulti(failing(DoubleStream.DoubleMapMultiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMulti(failing(DoubleStream.DoubleMapMultiConsumer.class)).toArray();\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMulti\", DoubleStream.DoubleMapMultiConsumer.class);\n+    }\n+\n+    public void testTakeWhile(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.takeWhile(failing(DoublePredicate.class)).toArray();\n+        var expectedResult = expected.takeWhile(failing(DoublePredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testTakeWhileExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"takeWhile\", DoublePredicate.class);\n+    }\n+\n+    public void testDropWhile(DoubleStream actual, DoubleStream expected) {\n+        var actualResult = actual.dropWhile(failing(DoublePredicate.class)).toArray();\n+        var expectedResult = expected.dropWhile(failing(DoublePredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDropWhileExceptions(DoubleStream actual, DoubleStream expected) {\n+        checkExpectedExceptions(actual, expected, \"dropWhile\", DoublePredicate.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/EmptyDoubleStreamTest.java","additions":448,"deletions":0,"binary":false,"changes":448,"status":"added"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.Spliterators;\n+import java.util.function.BiConsumer;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntConsumer;\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n+import java.util.function.IntToDoubleFunction;\n+import java.util.function.IntToLongFunction;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.ObjIntConsumer;\n+import java.util.function.Supplier;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Checks that the EmptyInttream is equivalent to the\n+ * old way of creating it with StreamSupport.\n+ * @author Heinz Kabutz\n+ *\/\n+\n+public final class EmptyIntStreamTest extends EmptyBaseStreamTest {\n+    @Test\n+    public void testAll() {\n+        this.compare(IntStream.class,\n+                IntStream::empty, () -> StreamSupport.intStream(Spliterators.emptyIntSpliterator(), false)\n+        );\n+        this.compare(IntStream.class,\n+                () -> IntStream.empty().parallel(), () -> StreamSupport.intStream(Spliterators.emptyIntSpliterator(), true)\n+        );\n+    }\n+\n+    public void testFilter(IntStream actual, IntStream expected) {\n+        actual = actual.filter(failing(IntPredicate.class));\n+        expected = expected.filter(failing(IntPredicate.class));\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFilterExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"filter\", IntPredicate.class);\n+    }\n+\n+    public void testMap(IntStream actual, IntStream expected) {\n+        IntStream actualAsIntStream = actual.map(failing(IntUnaryOperator.class));\n+        IntStream expectedAsIntStream = expected.map(failing(IntUnaryOperator.class));\n+        var actualResult = actualAsIntStream.toArray();\n+        var expectedResult = expectedAsIntStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"map\", IntUnaryOperator.class);\n+    }\n+\n+    public void testMapToObj(IntStream actual, IntStream expected) {\n+        Stream<Integer> actualAsStream = actual.mapToObj(failing(IntFunction.class));\n+        Stream<Integer> expectedAsStream = expected.mapToObj(failing(IntFunction.class));\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToObjExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToObj\", IntFunction.class);\n+    }\n+\n+    public void testMapToLong(IntStream actual, IntStream expected) {\n+        LongStream actualAsLongStream = actual.mapToLong(failing(IntToLongFunction.class));\n+        LongStream expectedAsLongStream = expected.mapToLong(failing(IntToLongFunction.class));\n+        var actualResult = actualAsLongStream.toArray();\n+        var expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToLongExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToLong\", IntToLongFunction.class);\n+    }\n+\n+    public void testMapToDouble(IntStream actual, IntStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.mapToDouble(failing(IntToDoubleFunction.class));\n+        DoubleStream expectedAsDoubleStream = expected.mapToDouble(failing(IntToDoubleFunction.class));\n+        var actualResult = actualAsDoubleStream.toArray();\n+        var expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToDoubleExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToDouble\", IntToDoubleFunction.class);\n+    }\n+\n+    public void testFlatMap(IntStream actual, IntStream expected) {\n+        IntStream actualAsIntStream = actual.flatMap(failing(IntFunction.class));\n+        IntStream expectedAsIntStream = expected.flatMap(failing(IntFunction.class));\n+        var actualResult = actualAsIntStream.toArray();\n+        var expectedResult = expectedAsIntStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMap\", IntFunction.class);\n+    }\n+\n+    public void testDistinct(IntStream actual, IntStream expected) {\n+        actual = actual.distinct();\n+        expected = expected.distinct();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDistinctExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"distinct\");\n+    }\n+\n+    public void testSorted(IntStream actual, IntStream expected) {\n+        actual = actual.sorted();\n+        expected = expected.sorted();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSortedExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sorted\");\n+    }\n+\n+    public void testPeek(IntStream actual, IntStream expected) {\n+        actual.peek(failing(IntConsumer.class)).toArray();\n+        expected.peek(failing(IntConsumer.class)).toArray();\n+    }\n+\n+    public void testPeekExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"peek\", IntConsumer.class);\n+    }\n+\n+    public void testLimit(IntStream actual, IntStream expected) {\n+        var actualResult = actual.limit(10).toArray();\n+        var expectedResult = expected.limit(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testLimitExceptions(IntStream actual, IntStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.limit(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.limit(-1));\n+\n+        actual.limit(10);\n+        expected.limit(10);\n+        assertThrows(IllegalStateException.class, () -> actual.limit(10));\n+        assertThrows(IllegalStateException.class, () -> expected.limit(10));\n+    }\n+\n+    public void testSkip(IntStream actual, IntStream expected) {\n+        var actualResult = actual.skip(10).toArray();\n+        var expectedResult = expected.skip(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSkipExceptions(IntStream actual, IntStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.skip(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.skip(-1));\n+\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+\n+        actual.skip(10);\n+        expected.skip(10);\n+        assertThrows(IllegalStateException.class, () -> actual.skip(10));\n+        assertThrows(IllegalStateException.class, () -> expected.skip(10));\n+    }\n+\n+    public void testForEach(IntStream actual, IntStream expected) {\n+        actual.forEach(failing(IntConsumer.class));\n+        expected.forEach(failing(IntConsumer.class));\n+    }\n+\n+    public void testForEachExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEach\", IntConsumer.class);\n+    }\n+\n+    public void testForEachOrdered(IntStream actual, IntStream expected) {\n+        actual.forEachOrdered(failing(IntConsumer.class));\n+        expected.forEachOrdered(failing(IntConsumer.class));\n+    }\n+\n+    public void testForEachOrderedExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEachOrdered\", IntConsumer.class);\n+    }\n+\n+    public void testToArray(IntStream actual, IntStream expected) {\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testToArrayExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"toArray\");\n+    }\n+\n+    public void testReduceIntBinaryOperator(IntStream actual, IntStream expected) {\n+        var actualResult = actual.reduce(failing(IntBinaryOperator.class));\n+        var expectedResult = expected.reduce(failing(IntBinaryOperator.class));\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testReduceIntBinaryOperatorExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", IntBinaryOperator.class);\n+    }\n+\n+    public void testReduceIdentityIntBinaryOperator(IntStream actual, IntStream expected) {\n+        var magicIdentity = 42;\n+        var actualResult = actual.reduce(magicIdentity, failing(IntBinaryOperator.class));\n+        var expectedResult = expected.reduce(magicIdentity, failing(IntBinaryOperator.class));\n+\n+        assertEquals(actualResult, magicIdentity);\n+        assertEquals(expectedResult, magicIdentity);\n+    }\n+\n+    public void testReduceIdentityIntBinaryOperatorExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", int.class, IntBinaryOperator.class);\n+    }\n+\n+    public void testCollect(IntStream actual, IntStream expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.collect(() -> magicIdentity, failing(ObjIntConsumer.class), failing(BiConsumer.class));\n+        var expectedResult = expected.collect(() -> magicIdentity, failing(ObjIntConsumer.class), failing(BiConsumer.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testCollectExceptions(IntStream actual, IntStream expected) {\n+        Supplier<Object> supplier = Object::new;\n+        var accumulator = failing(ObjIntConsumer.class);\n+        var combiner = failing(BiConsumer.class);\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        actual.collect(supplier, accumulator, combiner);\n+        expected.collect(supplier, accumulator, combiner);\n+\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        assertThrows(IllegalStateException.class, () -> actual.collect(supplier, accumulator, combiner));\n+        assertThrows(IllegalStateException.class, () -> expected.collect(supplier, accumulator, combiner));\n+    }\n+\n+    public void testSum(IntStream actual, IntStream expected) {\n+        var actualResult = actual.sum();\n+        var expectedResult = expected.sum();\n+\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0);\n+    }\n+\n+    public void testSumExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sum\");\n+    }\n+\n+    public void testMin(IntStream actual, IntStream expected) {\n+        var actualResult = actual.min();\n+        var expectedResult = expected.min();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMinExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"min\");\n+    }\n+\n+    public void testMax(IntStream actual, IntStream expected) {\n+        var actualResult = actual.max();\n+        var expectedResult = expected.max();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMaxExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"max\");\n+    }\n+\n+    public void testCount(IntStream actual, IntStream expected) {\n+        var actualResult = actual.count();\n+        var expectedResult = expected.count();\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0L);\n+    }\n+\n+    public void testCountExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"count\");\n+    }\n+\n+    public void testAverage(IntStream actual, IntStream expected) {\n+        var actualResult = actual.average();\n+        var expectedResult = expected.average();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAverageExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"average\");\n+    }\n+\n+    public void testSummaryStatistics(IntStream actual, IntStream expected) {\n+        var actualResult = actual.summaryStatistics().toString();\n+        var expectedResult = expected.summaryStatistics().toString();\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testSummaryStatisticsExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"summaryStatistics\");\n+    }\n+\n+    public void testAnyMatch(IntStream actual, IntStream expected) {\n+        var actualResult = actual.anyMatch(failing(IntPredicate.class));\n+        var expectedResult = expected.anyMatch(failing(IntPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAnyMatchExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"anyMatch\", IntPredicate.class);\n+    }\n+\n+    public void testAllMatch(IntStream actual, IntStream expected) {\n+        var actualResult = actual.allMatch(failing(IntPredicate.class));\n+        var expectedResult = expected.allMatch(failing(IntPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAllMatchExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"allMatch\", IntPredicate.class);\n+    }\n+\n+    public void testNoneMatch(IntStream actual, IntStream expected) {\n+        var actualResult = actual.noneMatch(failing(IntPredicate.class));\n+        var expectedResult = expected.noneMatch(failing(IntPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testNoneMatchExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"noneMatch\", IntPredicate.class);\n+    }\n+\n+    public void testFindFirst(IntStream actual, IntStream expected) {\n+        var actualResult = actual.findFirst();\n+        var expectedResult = expected.findFirst();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindFirstExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findFirst\");\n+    }\n+\n+    public void testFindAny(IntStream actual, IntStream expected) {\n+        var actualResult = actual.findAny();\n+        var expectedResult = expected.findAny();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindAnyExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findAny\");\n+    }\n+\n+    public void testAsLongStream(IntStream actual, IntStream expected) {\n+        LongStream actualAsLongStream = actual.asLongStream();\n+        LongStream expectedAsLongStream = expected.asLongStream();\n+        long[] actualResult = actualAsLongStream.toArray();\n+        long[] expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAsLongStreamExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"asLongStream\");\n+    }\n+\n+    public void testAsDoubleStream(IntStream actual, IntStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.asDoubleStream();\n+        DoubleStream expectedAsDoubleStream = expected.asDoubleStream();\n+        double[] actualResult = actualAsDoubleStream.toArray();\n+        double[] expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAsDoubleStreamExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"asDoubleStream\");\n+    }\n+\n+    public void testBoxed(IntStream actual, IntStream expected) {\n+        Stream<Integer> actualAsStream = actual.boxed();\n+        Stream<Integer> expectedAsStream = expected.boxed();\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testBoxedExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"boxed\");\n+    }\n+\n+    public void testMapMulti(IntStream actual, IntStream expected) {\n+        var actualResult = actual.mapMulti(failing(IntStream.IntMapMultiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMulti(failing(IntStream.IntMapMultiConsumer.class)).toArray();\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMulti\", IntStream.IntMapMultiConsumer.class);\n+    }\n+\n+    public void testTakeWhile(IntStream actual, IntStream expected) {\n+        var actualResult = actual.takeWhile(failing(IntPredicate.class)).toArray();\n+        var expectedResult = expected.takeWhile(failing(IntPredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testTakeWhileExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"takeWhile\", IntPredicate.class);\n+    }\n+\n+    public void testDropWhile(IntStream actual, IntStream expected) {\n+        var actualResult = actual.dropWhile(failing(IntPredicate.class)).toArray();\n+        var expectedResult = expected.dropWhile(failing(IntPredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDropWhileExceptions(IntStream actual, IntStream expected) {\n+        checkExpectedExceptions(actual, expected, \"dropWhile\", IntPredicate.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/EmptyIntStreamTest.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.Spliterators;\n+import java.util.function.BiConsumer;\n+import java.util.function.LongBinaryOperator;\n+import java.util.function.LongConsumer;\n+import java.util.function.LongFunction;\n+import java.util.function.LongPredicate;\n+import java.util.function.LongToDoubleFunction;\n+import java.util.function.LongToIntFunction;\n+import java.util.function.LongUnaryOperator;\n+import java.util.function.ObjLongConsumer;\n+import java.util.function.Supplier;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Checks that the EmptyLongStream is equivalent to the\n+ * old way of creating it with StreamSupport.\n+ * @author Heinz Kabutz\n+ *\/\n+\n+public final class EmptyLongStreamTest extends EmptyBaseStreamTest {\n+    @Test\n+    public void testAll() {\n+        this.compare(LongStream.class,\n+                LongStream::empty, () -> StreamSupport.longStream(Spliterators.emptyLongSpliterator(), false)\n+        );\n+        this.compare(LongStream.class,\n+                () -> LongStream.empty().parallel(), () -> StreamSupport.longStream(Spliterators.emptyLongSpliterator(), true)\n+        );\n+    }\n+\n+    public void testFilter(LongStream actual, LongStream expected) {\n+        actual = actual.filter(failing(LongPredicate.class));\n+        expected = expected.filter(failing(LongPredicate.class));\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFilterExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"filter\", LongPredicate.class);\n+    }\n+\n+    public void testMap(LongStream actual, LongStream expected) {\n+        LongStream actualAsLongStream = actual.map(failing(LongUnaryOperator.class));\n+        LongStream expectedAsLongStream = expected.map(failing(LongUnaryOperator.class));\n+        var actualResult = actualAsLongStream.toArray();\n+        var expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"map\", LongUnaryOperator.class);\n+    }\n+\n+    public void testMapToObj(LongStream actual, LongStream expected) {\n+        Stream<Long> actualAsStream = actual.mapToObj(failing(LongFunction.class));\n+        Stream<Long> expectedAsStream = expected.mapToObj(failing(LongFunction.class));\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToObjExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToObj\", LongFunction.class);\n+    }\n+\n+    public void testMapToInt(LongStream actual, LongStream expected) {\n+        IntStream actualAsIntStream = actual.mapToInt(failing(LongToIntFunction.class));\n+        IntStream expectedAsIntStream = expected.mapToInt(failing(LongToIntFunction.class));\n+        var actualResult = actualAsIntStream.toArray();\n+        var expectedResult = expectedAsIntStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToIntExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToInt\", LongToIntFunction.class);\n+    }\n+\n+    public void testMapToDouble(LongStream actual, LongStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.mapToDouble(failing(LongToDoubleFunction.class));\n+        DoubleStream expectedAsDoubleStream = expected.mapToDouble(failing(LongToDoubleFunction.class));\n+        var actualResult = actualAsDoubleStream.toArray();\n+        var expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapToDoubleExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToDouble\", LongToDoubleFunction.class);\n+    }\n+\n+    public void testFlatMap(LongStream actual, LongStream expected) {\n+        LongStream actualAsLongStream = actual.flatMap(failing(LongFunction.class));\n+        LongStream expectedAsLongStream = expected.flatMap(failing(LongFunction.class));\n+        var actualResult = actualAsLongStream.toArray();\n+        var expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMap\", LongFunction.class);\n+    }\n+\n+    public void testDistinct(LongStream actual, LongStream expected) {\n+        actual = actual.distinct();\n+        expected = expected.distinct();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDistinctExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"distinct\");\n+    }\n+\n+    public void testSorted(LongStream actual, LongStream expected) {\n+        actual = actual.sorted();\n+        expected = expected.sorted();\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSortedExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sorted\");\n+    }\n+\n+    public void testPeek(LongStream actual, LongStream expected) {\n+        actual.peek(failing(LongConsumer.class)).toArray();\n+        expected.peek(failing(LongConsumer.class)).toArray();\n+    }\n+\n+    public void testPeekExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"peek\", LongConsumer.class);\n+    }\n+\n+    public void testLimit(LongStream actual, LongStream expected) {\n+        var actualResult = actual.limit(10).toArray();\n+        var expectedResult = expected.limit(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testLimitExceptions(LongStream actual, LongStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.limit(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.limit(-1));\n+\n+        actual.limit(10);\n+        expected.limit(10);\n+        assertThrows(IllegalStateException.class, () -> actual.limit(10));\n+        assertThrows(IllegalStateException.class, () -> expected.limit(10));\n+    }\n+\n+    public void testSkip(LongStream actual, LongStream expected) {\n+        var actualResult = actual.skip(10).toArray();\n+        var expectedResult = expected.skip(10).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSkipExceptions(LongStream actual, LongStream expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.skip(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.skip(-1));\n+\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+\n+        actual.skip(10);\n+        expected.skip(10);\n+        assertThrows(IllegalStateException.class, () -> actual.skip(10));\n+        assertThrows(IllegalStateException.class, () -> expected.skip(10));\n+    }\n+\n+    public void testForEach(LongStream actual, LongStream expected) {\n+        actual.forEach(failing(LongConsumer.class));\n+        expected.forEach(failing(LongConsumer.class));\n+    }\n+\n+    public void testForEachExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEach\", LongConsumer.class);\n+    }\n+\n+    public void testForEachOrdered(LongStream actual, LongStream expected) {\n+        actual.forEachOrdered(failing(LongConsumer.class));\n+        expected.forEachOrdered(failing(LongConsumer.class));\n+    }\n+\n+    public void testForEachOrderedExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"forEachOrdered\", LongConsumer.class);\n+    }\n+\n+    public void testToArray(LongStream actual, LongStream expected) {\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testToArrayExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"toArray\");\n+    }\n+\n+    public void testReduceLongBinaryOperator(LongStream actual, LongStream expected) {\n+        var actualResult = actual.reduce(failing(LongBinaryOperator.class));\n+        var expectedResult = expected.reduce(failing(LongBinaryOperator.class));\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testReduceLongBinaryOperatorExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", LongBinaryOperator.class);\n+    }\n+\n+    public void testReduceIdentityLongBinaryOperator(LongStream actual, LongStream expected) {\n+        var magicIdentity = 42L;\n+        var actualResult = actual.reduce(magicIdentity, failing(LongBinaryOperator.class));\n+        var expectedResult = expected.reduce(magicIdentity, failing(LongBinaryOperator.class));\n+\n+        assertEquals(actualResult, magicIdentity);\n+        assertEquals(expectedResult, magicIdentity);\n+    }\n+\n+    public void testReduceIdentityLongBinaryOperatorExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", long.class, LongBinaryOperator.class);\n+    }\n+\n+    public void testCollect(LongStream actual, LongStream expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.collect(() -> magicIdentity, failing(ObjLongConsumer.class), failing(BiConsumer.class));\n+        var expectedResult = expected.collect(() -> magicIdentity, failing(ObjLongConsumer.class), failing(BiConsumer.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testCollectExceptions(LongStream actual, LongStream expected) {\n+        Supplier<Object> supplier = Object::new;\n+        var accumulator = failing(ObjLongConsumer.class);\n+        var combiner = failing(BiConsumer.class);\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        actual.collect(supplier, accumulator, combiner);\n+        expected.collect(supplier, accumulator, combiner);\n+\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        assertThrows(IllegalStateException.class, () -> actual.collect(supplier, accumulator, combiner));\n+        assertThrows(IllegalStateException.class, () -> expected.collect(supplier, accumulator, combiner));\n+    }\n+\n+    public void testSum(LongStream actual, LongStream expected) {\n+        var actualResult = actual.sum();\n+        var expectedResult = expected.sum();\n+\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0);\n+    }\n+\n+    public void testSumExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"sum\");\n+    }\n+\n+    public void testMin(LongStream actual, LongStream expected) {\n+        var actualResult = actual.min();\n+        var expectedResult = expected.min();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMinExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"min\");\n+    }\n+\n+    public void testMax(LongStream actual, LongStream expected) {\n+        var actualResult = actual.max();\n+        var expectedResult = expected.max();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMaxExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"max\");\n+    }\n+\n+    public void testCount(LongStream actual, LongStream expected) {\n+        var actualResult = actual.count();\n+        var expectedResult = expected.count();\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0L);\n+    }\n+\n+    public void testCountExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"count\");\n+    }\n+\n+    public void testAverage(LongStream actual, LongStream expected) {\n+        var actualResult = actual.average();\n+        var expectedResult = expected.average();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAverageExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"average\");\n+    }\n+\n+    public void testSummaryStatistics(LongStream actual, LongStream expected) {\n+        var actualResult = actual.summaryStatistics().toString();\n+        var expectedResult = expected.summaryStatistics().toString();\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testSummaryStatisticsExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"summaryStatistics\");\n+    }\n+\n+    public void testAnyMatch(LongStream actual, LongStream expected) {\n+        var actualResult = actual.anyMatch(failing(LongPredicate.class));\n+        var expectedResult = expected.anyMatch(failing(LongPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAnyMatchExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"anyMatch\", LongPredicate.class);\n+    }\n+\n+    public void testAllMatch(LongStream actual, LongStream expected) {\n+        var actualResult = actual.allMatch(failing(LongPredicate.class));\n+        var expectedResult = expected.allMatch(failing(LongPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAllMatchExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"allMatch\", LongPredicate.class);\n+    }\n+\n+    public void testNoneMatch(LongStream actual, LongStream expected) {\n+        var actualResult = actual.noneMatch(failing(LongPredicate.class));\n+        var expectedResult = expected.noneMatch(failing(LongPredicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testNoneMatchExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"noneMatch\", LongPredicate.class);\n+    }\n+\n+    public void testFindFirst(LongStream actual, LongStream expected) {\n+        var actualResult = actual.findFirst();\n+        var expectedResult = expected.findFirst();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindFirstExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findFirst\");\n+    }\n+\n+    public void testFindAny(LongStream actual, LongStream expected) {\n+        var actualResult = actual.findAny();\n+        var expectedResult = expected.findAny();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindAnyExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"findAny\");\n+    }\n+\n+    public void testAsDoubleStream(LongStream actual, LongStream expected) {\n+        DoubleStream actualAsDoubleStream = actual.asDoubleStream();\n+        DoubleStream expectedAsDoubleStream = expected.asDoubleStream();\n+        double[] actualResult = actualAsDoubleStream.toArray();\n+        double[] expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testAsDoubleStreamExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"asDoubleStream\");\n+    }\n+\n+    public void testBoxed(LongStream actual, LongStream expected) {\n+        Stream<Long> actualAsStream = actual.boxed();\n+        Stream<Long> expectedAsStream = expected.boxed();\n+        var actualResult = actualAsStream.toArray();\n+        var expectedResult = expectedAsStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testBoxedExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"boxed\");\n+    }\n+\n+    public void testMapMulti(LongStream actual, LongStream expected) {\n+        var actualResult = actual.mapMulti(failing(LongStream.LongMapMultiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMulti(failing(LongStream.LongMapMultiConsumer.class)).toArray();\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMulti\", LongStream.LongMapMultiConsumer.class);\n+    }\n+\n+    public void testTakeWhile(LongStream actual, LongStream expected) {\n+        var actualResult = actual.takeWhile(failing(LongPredicate.class)).toArray();\n+        var expectedResult = expected.takeWhile(failing(LongPredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testTakeWhileExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"takeWhile\", LongPredicate.class);\n+    }\n+\n+    public void testDropWhile(LongStream actual, LongStream expected) {\n+        var actualResult = actual.dropWhile(failing(LongPredicate.class)).toArray();\n+        var expectedResult = expected.dropWhile(failing(LongPredicate.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDropWhileExceptions(LongStream actual, LongStream expected) {\n+        checkExpectedExceptions(actual, expected, \"dropWhile\", LongPredicate.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/EmptyLongStreamTest.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -0,0 +1,613 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.tests.java.util.stream;\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.Spliterators;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Checks that the EmptyStream is equivalent to the\n+ * old way of creating it with StreamSupport.\n+ * @author Heinz Kabutz\n+ *\/\n+\n+public final class EmptyStreamTest extends EmptyBaseStreamTest {\n+    @Test\n+    public void testAll() {\n+        this.compare(Stream.class,\n+                Stream::empty,\n+                () -> StreamSupport.stream(Spliterators.emptySpliterator(), false)\n+        );\n+        this.compare(Stream.class,\n+                () -> Stream.empty().parallel(),\n+                () -> StreamSupport.stream(Spliterators.emptySpliterator(), true)\n+        );\n+    }\n+\n+    public void testFilter(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual = actual.filter(failing(Predicate.class));\n+        expected = expected.filter(failing(Predicate.class));\n+        var actualResult = actual.toList();\n+        var expectedResult = expected.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFilterExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"filter\", Predicate.class);\n+    }\n+\n+    public void testMap(Stream<Integer> actual, Stream<Integer> expected) {\n+        Stream<String> actualAsStrings = actual.map(failing(Function.class));\n+        Stream<String> expectedAsStrings = expected.map(failing(Function.class));\n+        var actualResult = actualAsStrings.toList();\n+        var expectedResult = expectedAsStrings.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"map\", Function.class);\n+    }\n+\n+    public void testMapToInt(Stream<Integer> actual, Stream<Integer> expected) {\n+        IntStream actualAsIntStream = actual.mapToInt(failing(ToIntFunction.class));\n+        IntStream expectedAsIntStream = expected.mapToInt(failing(ToIntFunction.class));\n+        var actualResult = actualAsIntStream.toArray();\n+        var expectedResult = expectedAsIntStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+        assertEquals(actual.isParallel(), actualAsIntStream.isParallel());\n+        assertEquals(expected.isParallel(), expectedAsIntStream.isParallel());\n+    }\n+\n+    public void testMapToIntExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToInt\", ToIntFunction.class);\n+    }\n+\n+    public void testMapToLong(Stream<Integer> actual, Stream<Integer> expected) {\n+        LongStream actualAsLongStream = actual.mapToLong(failing(ToLongFunction.class));\n+        LongStream expectedAsLongStream = expected.mapToLong(failing(ToLongFunction.class));\n+        var actualResult = actualAsLongStream.toArray();\n+        var expectedResult = expectedAsLongStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+        assertEquals(actual.isParallel(), actualAsLongStream.isParallel());\n+        assertEquals(expected.isParallel(), expectedAsLongStream.isParallel());\n+    }\n+\n+    public void testMapToLongExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToLong\", ToLongFunction.class);\n+    }\n+\n+    public void testMapToDouble(Stream<Integer> actual, Stream<Integer> expected) {\n+        DoubleStream actualAsDoubleStream = actual.mapToDouble(failing(ToDoubleFunction.class));\n+        DoubleStream expectedAsDoubleStream = expected.mapToDouble(failing(ToDoubleFunction.class));\n+        var actualResult = actualAsDoubleStream.toArray();\n+        var expectedResult = expectedAsDoubleStream.toArray();\n+        compareResults(actualResult, expectedResult);\n+        assertEquals(actual.isParallel(), actualAsDoubleStream.isParallel());\n+        assertEquals(expected.isParallel(), expectedAsDoubleStream.isParallel());\n+    }\n+\n+    public void testMapToDoubleExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapToDouble\", ToDoubleFunction.class);\n+    }\n+\n+    public void testFlatMap(Stream<Stream<Integer>> actual, Stream<Stream<Integer>> expected) {\n+        var actualResult = actual.flatMap(Function.identity()).toList();\n+        var expectedResult = expected.flatMap(Function.identity()).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapExceptions(Stream<Stream<Integer>> actual, Stream<Stream<Integer>> expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMap\", Function.class);\n+    }\n+\n+    public void testFlatMapToInt(Stream<IntStream> actual, Stream<IntStream> expected) {\n+        var actualResult = actual.flatMapToInt(Function.identity()).toArray();\n+        var expectedResult = expected.flatMapToInt(Function.identity()).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapToIntExceptions(Stream<IntStream> actual, Stream<IntStream> expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMapToInt\", Function.class);\n+    }\n+\n+    public void testFlatMapToLong(Stream<LongStream> actual, Stream<LongStream> expected) {\n+        var actualResult = actual.flatMapToLong(Function.identity()).toArray();\n+        var expectedResult = expected.flatMapToLong(Function.identity()).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapToLongExceptions(Stream<LongStream> actual, Stream<LongStream> expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMapToLong\", Function.class);\n+    }\n+\n+    public void testFlatMapToDouble(Stream<DoubleStream> actual, Stream<DoubleStream> expected) {\n+        var actualResult = actual.flatMapToDouble(Function.identity()).toArray();\n+        var expectedResult = expected.flatMapToDouble(Function.identity()).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFlatMapToDoubleExceptions(Stream<DoubleStream> actual, Stream<DoubleStream> expected) {\n+        checkExpectedExceptions(actual, expected, \"flatMapToDouble\", Function.class);\n+    }\n+\n+    public void testMapMulti(Stream<Number> actual, Stream<Number> expected) {\n+        var actualResult = actual.mapMulti(failing(BiConsumer.class)).toList();\n+        var expectedResult = expected.mapMulti(failing(BiConsumer.class)).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMulti\", BiConsumer.class);\n+    }\n+\n+    public void testMapMultiToInt(Stream<Number> actual, Stream<Number> expected) {\n+        var actualResult = actual.mapMultiToInt(failing(BiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMultiToInt(failing(BiConsumer.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiToIntExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMultiToInt\", BiConsumer.class);\n+    }\n+\n+    public void testMapMultiToLong(Stream<Number> actual, Stream<Number> expected) {\n+        var actualResult = actual.mapMultiToLong(failing(BiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMultiToLong(failing(BiConsumer.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiToLongExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMultiToLong\", BiConsumer.class);\n+    }\n+\n+    public void testMapMultiToDouble(Stream<Number> actual, Stream<Number> expected) {\n+        var actualResult = actual.mapMultiToDouble(failing(BiConsumer.class)).toArray();\n+        var expectedResult = expected.mapMultiToDouble(failing(BiConsumer.class)).toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMapMultiToDoubleExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"mapMultiToDouble\", BiConsumer.class);\n+    }\n+\n+    public void testDistinct(Stream<?> actual, Stream<?> expected) {\n+        actual = actual.distinct();\n+        expected = expected.distinct();\n+        var actualResult = actual.toList();\n+        var expectedResult = expected.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDistinctExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"distinct\");\n+    }\n+\n+    public void testSorted(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual = actual.sorted();\n+        expected = expected.sorted();\n+        var actualResult = actual.toList();\n+        var expectedResult = expected.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSortedExceptions(Stream<Number> actual, Stream<Number> expected) {\n+        checkExpectedExceptions(actual, expected, \"sorted\");\n+    }\n+\n+    public void testSortedComparator(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual = actual.sorted(Comparator.reverseOrder());\n+        expected = expected.sorted(Comparator.reverseOrder());\n+        var actualResult = actual.toList();\n+        var expectedResult = expected.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSortedComparatorNullPointerExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"sorted\", Comparator.class);\n+    }\n+\n+    public void testPeek(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual.peek(failing(Consumer.class)).toList();\n+        expected.peek(failing(Consumer.class)).toList();\n+    }\n+\n+    public void testPeekExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"peek\", Consumer.class);\n+    }\n+\n+    public void testSkip(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.skip(10).toList();\n+        var expectedResult = expected.skip(10).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testSkipExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.skip(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.skip(-1));\n+\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+        actual.skip(0); \/\/ should be ok\n+        expected.skip(0); \/\/ should be ok\n+\n+        actual.skip(10);\n+        expected.skip(10);\n+        assertThrows(IllegalStateException.class, () -> actual.skip(10));\n+        assertThrows(IllegalStateException.class, () -> expected.skip(10));\n+    }\n+\n+    public void testTakeWhile(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.takeWhile(failing(Predicate.class)).toList();\n+        var expectedResult = expected.takeWhile(failing(Predicate.class)).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testTakeWhileExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"takeWhile\", Predicate.class);\n+    }\n+\n+    public void testDropWhile(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.dropWhile(failing(Predicate.class)).toList();\n+        var expectedResult = expected.dropWhile(failing(Predicate.class)).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testDropWhileExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"dropWhile\", Predicate.class);\n+    }\n+\n+    public void testForEach(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual.forEach(failing(Consumer.class));\n+        expected.forEach(failing(Consumer.class));\n+    }\n+\n+    public void testForEachExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        assertThrows(NullPointerException.class, () -> actual.forEach(null));\n+        assertThrows(NullPointerException.class, () -> expected.forEach(null));\n+\n+        var actualException = getThrowableType(() -> actual.forEach(null));\n+        var expectedException = getThrowableType(() -> expected.forEach(null));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEach(null));\n+        expectedException = getThrowableType(() -> expected.forEach(null));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEach(failing(Consumer.class)));\n+        expectedException = getThrowableType(() -> expected.forEach(failing(Consumer.class)));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEach(failing(Consumer.class)));\n+        expectedException = getThrowableType(() -> expected.forEach(failing(Consumer.class)));\n+        assertSame(actualException, expectedException);\n+    }\n+\n+    public void testForEachOrdered(Stream<Integer> actual, Stream<Integer> expected) {\n+        actual.forEachOrdered(failing(Consumer.class));\n+        expected.forEachOrdered(failing(Consumer.class));\n+    }\n+\n+    public void testForEachOrderedExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        assertThrows(NullPointerException.class, () -> actual.forEachOrdered(null));\n+        assertThrows(NullPointerException.class, () -> expected.forEachOrdered(null));\n+\n+        var actualException = getThrowableType(() -> actual.forEachOrdered(null));\n+        var expectedException = getThrowableType(() -> expected.forEachOrdered(null));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEachOrdered(null));\n+        expectedException = getThrowableType(() -> expected.forEachOrdered(null));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEachOrdered(failing(Consumer.class)));\n+        expectedException = getThrowableType(() -> expected.forEachOrdered(failing(Consumer.class)));\n+        assertSame(actualException, expectedException);\n+\n+        actualException = getThrowableType(() -> actual.forEachOrdered(failing(Consumer.class)));\n+        expectedException = getThrowableType(() -> expected.forEachOrdered(failing(Consumer.class)));\n+        assertSame(actualException, expectedException);\n+    }\n+\n+    public void testToArray(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.toArray();\n+        var expectedResult = expected.toArray();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testToArrayExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"toArray\");\n+    }\n+\n+    public void testToArrayFunction(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.toArray(Integer[]::new);\n+        var expectedResult = expected.toArray(Integer[]::new);\n+        compareResults(actualResult, expectedResult);\n+        assertEquals(Integer.class, expectedResult.getClass().getComponentType());\n+    }\n+\n+    public void testToArrayFunctionExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        checkExpectedExceptions(actual, expected, \"toArray\", IntFunction.class);\n+    }\n+\n+    public void testToArrayFunctionReturnNullException(Stream<Integer> actual, Stream<Integer> expected) {\n+        assertThrows(NullPointerException.class, () -> actual.toArray(i -> null));\n+        assertThrows(NullPointerException.class, () -> expected.toArray(i -> null));\n+    }\n+\n+    public void testReduceIdentityAccumulator(Stream<Object> actual, Stream<Object> expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.reduce(magicIdentity, failing(BinaryOperator.class));\n+        var expectedResult = expected.reduce(magicIdentity, failing(BinaryOperator.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testReduceIdentityAccumulatorExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", Object.class, BinaryOperator.class);\n+    }\n+\n+    public void testReduceAccumulator(Stream<Object> actual, Stream<Object> expected) {\n+        var actualResult = actual.reduce(failing(BinaryOperator.class));\n+        var expectedResult = expected.reduce(failing(BinaryOperator.class));\n+\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testReduceAccumulatorExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", BinaryOperator.class);\n+    }\n+\n+    public void testReduceIdentityAccumulatorCombiner(Stream<Object> actual, Stream<Object> expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.reduce(magicIdentity, failing(BinaryOperator.class), failing(BinaryOperator.class));\n+        var expectedResult = expected.reduce(magicIdentity, failing(BinaryOperator.class), failing(BinaryOperator.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testReduceIdentityAccumulatorCombinerExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"reduce\", Object.class, BiFunction.class, BinaryOperator.class);\n+    }\n+\n+    public void testCollectSupplierAccumulatorCombiner(Stream<Integer> actual, Stream<Integer> expected) {\n+        var magicIdentity = new Object();\n+        var actualResult = actual.collect(() -> magicIdentity, failing(BiConsumer.class), failing(BiConsumer.class));\n+        var expectedResult = expected.collect(() -> magicIdentity, failing(BiConsumer.class), failing(BiConsumer.class));\n+\n+        assertSame(magicIdentity, actualResult);\n+        assertSame(magicIdentity, expectedResult);\n+    }\n+\n+    public void testCollectSupplierAccumulatorCombinerExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        var magicIdentity = new Object();\n+        Supplier<Object> supplier = () -> magicIdentity;\n+        var accumulator = failing(BiConsumer.class);\n+        var combiner = failing(BiConsumer.class);\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        actual.collect(supplier, accumulator, combiner);\n+        expected.collect(supplier, accumulator, combiner);\n+\n+        assertThrows(NullPointerException.class, () -> actual.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null, accumulator, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, null, combiner));\n+        assertThrows(NullPointerException.class, () -> actual.collect(supplier, accumulator, null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(supplier, accumulator, null));\n+\n+        assertThrows(IllegalStateException.class, () -> actual.collect(supplier, accumulator, combiner));\n+        assertThrows(IllegalStateException.class, () -> expected.collect(supplier, accumulator, combiner));\n+    }\n+\n+    public void testCollectCollector(Stream<Object> actual, Stream<Object> expected) {\n+        var magicIdentity = new Object();\n+        var superMagicIdentity = new Object();\n+        Collector<Object, Object, Object> collector = new Collector<>() {\n+            @Override\n+            public Supplier<Object> supplier() {\n+                return () -> magicIdentity;\n+            }\n+\n+            @Override\n+            public BiConsumer<Object, Object> accumulator() {\n+                return failing(BiConsumer.class);\n+            }\n+\n+            @Override\n+            public BinaryOperator<Object> combiner() {\n+                return failing(BinaryOperator.class);\n+            }\n+\n+            @Override\n+            public Function<Object, Object> finisher() {\n+                return a -> {\n+                    assertSame(magicIdentity, a);\n+                    return superMagicIdentity;\n+                };\n+            }\n+\n+            @Override\n+            public Set<Characteristics> characteristics() {\n+                return Set.of();\n+            }\n+        };\n+        var actualResult = actual.collect(collector);\n+        var expectedResult = expected.collect(collector);\n+\n+        assertSame(superMagicIdentity, actualResult);\n+        assertSame(superMagicIdentity, expectedResult);\n+    }\n+\n+    public void testCollectCollectorExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        assertThrows(NullPointerException.class, () -> actual.collect(null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null));\n+\n+        actual.collect(Collectors.toList());\n+        expected.collect(Collectors.toList());\n+\n+        assertThrows(NullPointerException.class, () -> actual.collect(null));\n+        assertThrows(NullPointerException.class, () -> expected.collect(null));\n+\n+        assertThrows(IllegalStateException.class, () -> actual.collect(Collectors.toList()));\n+        assertThrows(IllegalStateException.class, () -> expected.collect(Collectors.toList()));\n+    }\n+\n+    public void testToList(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.toList();\n+        var expectedResult = expected.toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testToListExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"toList\");\n+    }\n+\n+    public void testMin(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.min(Comparator.reverseOrder());\n+        var expectedResult = expected.min(Comparator.reverseOrder());\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMinExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"min\", Comparator.class);\n+    }\n+\n+    public void testMax(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.max(Comparator.reverseOrder());\n+        var expectedResult = expected.max(Comparator.reverseOrder());\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testMaxExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"max\", Comparator.class);\n+    }\n+\n+    public void testCount(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.count();\n+        var expectedResult = expected.count();\n+        assertEquals(actualResult, expectedResult);\n+        assertEquals(actualResult, 0L);\n+    }\n+\n+    public void testCountExceptions(Stream<Object> actual, Stream<Object> expected) {\n+        checkExpectedExceptions(actual, expected, \"count\");\n+    }\n+\n+    public void testAnyMatch(Stream<?> actual, Stream<?> expected) {\n+        var actualResult = actual.anyMatch(failing(Predicate.class));\n+        var expectedResult = expected.anyMatch(failing(Predicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAnyMatchExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"anyMatch\", Predicate.class);\n+    }\n+\n+    public void testAllMatch(Stream<?> actual, Stream<?> expected) {\n+        var actualResult = actual.allMatch(failing(Predicate.class));\n+        var expectedResult = expected.allMatch(failing(Predicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testAllMatchExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"allMatch\", Predicate.class);\n+    }\n+\n+    public void testNoneMatch(Stream<?> actual, Stream<?> expected) {\n+        var actualResult = actual.noneMatch(failing(Predicate.class));\n+        var expectedResult = expected.noneMatch(failing(Predicate.class));\n+        assertEquals(actualResult, expectedResult);\n+    }\n+\n+    public void testNoneMatchExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"noneMatch\", Predicate.class);\n+    }\n+\n+    public void testFindFirst(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.findFirst();\n+        var expectedResult = expected.findFirst();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindFirstExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"findFirst\");\n+    }\n+\n+    public void testFindAny(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.findAny();\n+        var expectedResult = expected.findAny();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testFindAnyExceptions(Stream<?> actual, Stream<?> expected) {\n+        checkExpectedExceptions(actual, expected, \"findAny\");\n+    }\n+\n+    public void testLimit(Stream<Integer> actual, Stream<Integer> expected) {\n+        var actualResult = actual.limit(10).toList();\n+        var expectedResult = expected.limit(10).toList();\n+        compareResults(actualResult, expectedResult);\n+    }\n+\n+    public void testLimitExceptions(Stream<Integer> actual, Stream<Integer> expected) {\n+        assertThrows(IllegalArgumentException.class, () -> actual.limit(-1));\n+        assertThrows(IllegalArgumentException.class, () -> expected.limit(-1));\n+\n+        actual.limit(10);\n+        expected.limit(10);\n+        assertThrows(IllegalStateException.class, () -> actual.limit(10));\n+        assertThrows(IllegalStateException.class, () -> expected.limit(10));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/EmptyStreamTest.java","additions":613,"deletions":0,"binary":false,"changes":613,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalInt;\n+import java.util.Spliterators;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * Benchmark for checking that the new empty stream\n+ * implementations are faster than the old way of creating\n+ * empty streams from empty spliterators.\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 2)\/\/, jvmArgsAppend = {\"-XX:+UseParallelGC\", \"-Xmx16g\", \"-Xms16g\", \"-XX:+AlwaysPreTouch\", \"-XX:NewRatio=1\", \"-XX:SurvivorRatio=1\"})\n+@Warmup(iterations = 20, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 3, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class EmptyStreams {\n+    @Param({\"0\", \"1\", \"10\", \"100\"})\n+    private int a_length;\n+\n+    @Param({\"ArrayList\", \"ConcurrentLinkedQueue\", \"ConcurrentSkipListSet\", \"CopyOnWriteArrayList\", \"ConcurrentHashMap\"})\n+    private String b_typeOfCollection;\n+\n+    @Param({\"minimal\", \"basic\", \"complex\", \"crossover\"})\n+    private String c_typeOfStreamDecoration;\n+\n+    @Param({\"old\", \"new\"})\n+    private String d_streamCreation;\n+\n+    private static final Map<Integer\/*length*\/, Map<String\/*typeOfCollection*\/, Collection<Integer>>> collectionData =\n+            Map.ofEntries(\n+                    makeMapEntries(0),\n+                    makeMapEntries(1),\n+                    makeMapEntries(3),\n+                    makeMapEntries(5),\n+                    makeMapEntries(10),\n+                    makeMapEntries(20),\n+                    makeMapEntries(100)\n+            );\n+\n+    private static Map.Entry<Integer, Map<String, Collection<Integer>>> makeMapEntries(int length) {\n+        return Map.entry(length, Map.of(\n+                \"ArrayList\", makeCollection(length, ArrayList::new),\n+                \"ConcurrentLinkedQueue\", makeCollection(length, ConcurrentLinkedQueue::new),\n+                \"ConcurrentSkipListSet\", makeCollection(length, ConcurrentSkipListSet::new),\n+                \"CopyOnWriteArrayList\", makeCollection(length, CopyOnWriteArrayList::new),\n+                \"ConcurrentHashMap\", makeCollection(length, ConcurrentHashMap::newKeySet)\n+        ));\n+    }\n+\n+    private static Collection<Integer> makeCollection(int length, Supplier<Collection<Integer>> supplier) {\n+        return IntStream.range(0, length).boxed().collect(Collectors.toCollection(supplier));\n+    }\n+\n+    private Stream<Integer> createStream() {\n+        Collection<Integer> collection = collectionData.get(a_length).get(b_typeOfCollection);\n+        return switch (d_streamCreation) {\n+            case \"old\" -> StreamSupport.stream(collection.spliterator(), false);\n+            case \"new\" -> collection.stream();\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    private Optional<Integer> decorateStream(Stream<Integer> stream) {\n+        return streamDecorators.get(c_typeOfStreamDecoration).apply(stream);\n+    }\n+\n+    private static final Map<String, Function<Stream<Integer>, Optional<Integer>>> streamDecorators =\n+            Map.of(\n+                    \/\/ with no additional intermediate operations\n+                    \"minimal\", stream ->\n+                            stream.max(Integer::compare),\n+                    \/\/ basic filter\/map\n+                    \"basic\", stream -> stream\n+                            .filter(Objects::nonNull)\n+                            .map(Function.identity())\n+                            .max(Integer::compare),\n+                    \/\/ more complex, including sorted and distinct, both of which\n+                    \/\/ would cause a fallback to the old empty stream approach\n+                    \"complex\", stream -> stream\n+                            .filter(Objects::nonNull)\n+                            .map(Function.identity())\n+                            .filter(Objects::nonNull)\n+                            .sorted()\n+                            .distinct()\n+                            .max(Integer::compare),\n+                    \/\/ we crossover from an Object Stream to an IntStream, LongStream,\n+                    \/\/ etc. but always with operations that keep using the empty streams\n+                    \"crossover\", stream -> stream\n+                            .filter(Objects::nonNull)\n+                            .map(String::valueOf)\n+                            .filter(s -> s.length() > 0)\n+                            .mapToInt(Integer::parseInt)\n+                            .map(i -> i * 2)\n+                            .mapToLong(i -> i + 1000)\n+                            .mapToDouble(i -> i * 3.5)\n+                            .boxed()\n+                            .mapToLong(Double::intValue)\n+                            .mapToInt(d -> (int) d)\n+                            .boxed()\n+                            .max(Integer::compare)\n+            );\n+\n+    @Benchmark\n+    public void mixOfCollectionsAndSizesAndStreams() {\n+        decorateStream(createStream());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/EmptyStreams.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+package org.openjdk.bench.java.util.stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * Benchmark for checking that having mixed types for the\n+ * streams does not make performance worse. We test this by\n+ * having collections of differing lengths within each run,\n+ * with different percentage of empty collections, ranging\n+ * from 0% to 100%. We also pre-create all the Function\n+ * instances necessary for creating the streams and to\n+ * decorate them.\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 1)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 3, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class EmptyStreamsMixedLength {\n+    @Param({\"20\", \"50\", \"80\", \"90\", \"99\", \"1\", \"10\"})\n+    private int a_percentageOfEmptyStreams;\n+\n+    @Param({\"ArrayList\", \"ConcurrentLinkedQueue\", \"ConcurrentSkipListSet\", \"CopyOnWriteArrayList\", \"ConcurrentHashMap\"})\n+    private String b_typeOfCollection;\n+\n+    @Param({\"minimal\", \"basic\", \"complex\", \"crossover\"})\n+    private String c_typeOfStreamDecoration;\n+\n+    @Param({\"old\", \"new\", \"guarded\"})\n+    private String d_streamCreation;\n+\n+    protected static final int NUMBER_OF_COLLECTIONS = 16 * 1024;\n+    private List<Collection<Integer>> collections;\n+    private int length_pos;\n+    private Function<Collection<Integer>, Stream<Integer>> streamCreator;\n+    private Function<Stream<Integer>, Optional<Integer>> streamDecorator;\n+\n+    @Setup\n+    public void setupExperiment() {\n+        System.out.println(\"EmptyStreamsMixedLength.setupExperiment\");\n+        collections = new ArrayList<>();\n+        length_pos = 0;\n+        var collectionSupplier = makeCollectionSupplier();\n+        List<Integer> lengths = new ArrayList<>();\n+        for (int i = 0; i < NUMBER_OF_COLLECTIONS; i++) {\n+            var collection = collectionSupplier.get();\n+            if (i >= NUMBER_OF_COLLECTIONS * a_percentageOfEmptyStreams \/ 100) {\n+                int numberOfElements = ThreadLocalRandom.current().nextInt(1, 11);\n+                ThreadLocalRandom.current().ints(numberOfElements).forEach(collection::add);\n+            }\n+            collections.add(collection);\n+        }\n+        Collections.shuffle(collections, new Random(42));\n+        var lengthDistribution = collections.stream()\n+                .collect(Collectors.groupingBy(Collection::size, TreeMap::new, Collectors.counting()));\n+        var empties = lengthDistribution.getOrDefault(0, 0L);\n+        System.out.printf(\"%d\/%d (%.0f%%) are empty, lengthDistribution = %s%n\",\n+                empties,\n+                NUMBER_OF_COLLECTIONS,\n+                100.0 * empties \/ NUMBER_OF_COLLECTIONS,\n+                lengthDistribution);\n+        this.streamCreator = makeStreamCreator();\n+        this.streamDecorator = makeStreamDecorator();\n+    }\n+\n+    @TearDown\n+    public void cleanupExperiment() {\n+        collections = null;\n+        streamCreator = null;\n+        streamDecorator = null;\n+    }\n+\n+    private Supplier<Collection<Integer>> makeCollectionSupplier() {\n+        return switch (b_typeOfCollection) {\n+            case \"ArrayList\" -> ArrayList::new;\n+            case \"ConcurrentLinkedQueue\" -> ConcurrentLinkedQueue::new;\n+            case \"ConcurrentSkipListSet\" -> ConcurrentSkipListSet::new;\n+            case \"CopyOnWriteArrayList\" -> CopyOnWriteArrayList::new;\n+            case \"ConcurrentHashMap\" -> ConcurrentHashMap::newKeySet;\n+            default -> throw new AssertionError(\"Incorrect collection type : \" + b_typeOfCollection);\n+        };\n+    }\n+\n+    private Function<Collection<Integer>, Stream<Integer>> makeStreamCreator() {\n+        return collection ->\n+                switch (d_streamCreation) {\n+                    case \"old\" -> createOld(collection);\n+                    case \"new\" -> createNew(collection);\n+                    case \"guarded\" -> collection.isEmpty() ? null : createOld(collection);\n+                    default -> throw new AssertionError(\"Unknown stream creation : \" + d_streamCreation);\n+                };\n+    }\n+\n+    private Function<Stream<Integer>, Optional<Integer>> makeStreamDecorator() {\n+        return switch (c_typeOfStreamDecoration) {\n+            \/\/ with no additional intermediate operations\n+            case \"minimal\" -> stream ->\n+                    stream.max(Integer::compare);\n+            \/\/ basic filter\/map\n+            case \"basic\" -> stream ->\n+                    stream\n+                            .filter(Objects::nonNull)\n+                            .map(Function.identity())\n+                            .max(Integer::compare);\n+            \/\/ more complex, including sorted and distinct\n+            case \"complex\" -> stream ->\n+                    stream\n+                            .filter(Objects::nonNull)\n+                            .map(Function.identity())\n+                            .filter(Objects::nonNull)\n+                            .sorted() \/\/ causes it to change to old empty stream\n+                            .distinct()\n+                            .max(Integer::compare);\n+            \/\/ we crossover from an Object Stream to an IntStream, LongStream,\n+            \/\/ etc. but always with operations that keep using the empty streams\n+            case \"crossover\" -> stream ->\n+                    stream\n+                            .filter(Objects::nonNull)\n+                            .map(String::valueOf)\n+                            .filter(s -> s.length() > 0)\n+                            .mapToInt(Integer::parseInt)\n+                            .map(i -> i * 2)\n+                            .mapToLong(i -> i + 1000)\n+                            .mapToDouble(i -> i * 3.5)\n+                            .boxed()\n+                            .mapToLong(Double::intValue)\n+                            .mapToInt(d -> (int) d)\n+                            .boxed()\n+                            .max(Integer::compare);\n+            default -> throw new AssertionError(\"Unknown stream decoration: \" + c_typeOfStreamDecoration);\n+        };\n+    }\n+\n+    private Stream<Integer> createOld(Collection<Integer> collection) {\n+        return StreamSupport.stream(collection.spliterator(), false);\n+    }\n+\n+    private Stream<Integer> createNew(Collection<Integer> collection) {\n+        if (collection.isEmpty()) return StreamSupport.emptyStream(collection.spliterator());\n+        else return createOld(collection);\n+    }\n+\n+    private Collection<Integer> nextCollection() {\n+        int index = length_pos++;\n+        if (length_pos == NUMBER_OF_COLLECTIONS) length_pos = 0;\n+        return collections.get(index);\n+    }\n+\n+    @Benchmark\n+    public void mixOfCollectionsAndSizeMixesAndStreams() {\n+        var collection = nextCollection();\n+        var stream = streamCreator.apply(collection);\n+        Optional<Integer> max = stream != null ? streamDecorator.apply(stream) : Optional.empty();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/EmptyStreamsMixedLength.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"}]}