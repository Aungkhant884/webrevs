{"files":[{"patch":"@@ -168,0 +168,19 @@\n+\n+        public void delete() throws KeyStoreException {\n+            \/\/ Get end-entity certificate and remove from system cert store\n+            X509Certificate[] certChain = getCertificateChain();\n+            if (certChain != null && certChain.length > 0) {\n+                try {\n+                    byte[] encoding = certChain[0].getEncoded();\n+                    removeCertificate(getName(), getAlias(), encoding,\n+                            encoding.length);\n+                } catch (CertificateException e) {\n+                    throw new KeyStoreException(\"Cannot remove entry: \", e);\n+                }\n+            }\n+            CKey privateKey = getPrivateKey();\n+            if (privateKey != null) {\n+                destroyKeyContainer(\n+                        CKey.getContainerName(privateKey.getHCryptProvider()));\n+            }\n+        }\n@@ -371,2 +390,0 @@\n-            KeyEntry entry = entries.get(alias);\n-\n@@ -385,8 +402,1 @@\n-            if (entry == null) {\n-                entry =\n-                    \/\/TODO new KeyEntry(alias, key, (X509Certificate[]) chain);\n-                    new KeyEntry(alias, null, xchain);\n-                storeWithUniqueAlias(alias, entry);\n-            }\n-\n-            entry.setAlias(alias);\n+            KeyEntry oldEntry = entries.get(alias);\n@@ -395,8 +405,6 @@\n-                entry.setRSAPrivateKey(key);\n-                entry.setCertificateChain(xchain);\n-\n-            } catch (CertificateException ce) {\n-                throw new KeyStoreException(ce);\n-\n-            } catch (InvalidKeyException ike) {\n-                throw new KeyStoreException(ike);\n+                KeyEntry newEntry = new KeyEntry(alias, null, xchain);\n+                newEntry.setRSAPrivateKey(key);\n+                newEntry.setCertificateChain(xchain);\n+                entries.put(alias, newEntry);\n+            } catch (CertificateException | InvalidKeyException e) {\n+                throw new KeyStoreException(e);\n@@ -405,0 +413,3 @@\n+            if (oldEntry != null) {\n+                oldEntry.delete();\n+            }\n@@ -466,1 +477,0 @@\n-            KeyEntry entry = entries.get(alias);\n@@ -468,4 +478,3 @@\n-            if (entry == null) {\n-                entry =\n-                    new KeyEntry(alias, null, chain);\n-                storeWithUniqueAlias(alias, entry);\n+            KeyEntry oldEntry = entries.get(alias);\n+            if (oldEntry != null && oldEntry.privateKey != null) {\n+                throw new KeyStoreException(\"Cannot overwrite key entry\");\n@@ -474,9 +483,6 @@\n-            if (entry.getPrivateKey() == null) { \/\/ trusted-cert entry\n-                entry.setAlias(alias);\n-\n-                try {\n-                    entry.setCertificateChain(chain);\n-\n-                } catch (CertificateException ce) {\n-                    throw new KeyStoreException(ce);\n-                }\n+            try {\n+                KeyEntry newEntry = new KeyEntry(alias, null, chain);\n+                newEntry.setCertificateChain(chain);\n+                entries.put(alias, newEntry);\n+            } catch (CertificateException ce) {\n+                throw new KeyStoreException(ce);\n@@ -485,0 +491,3 @@\n+            if (oldEntry != null) {\n+                oldEntry.delete();\n+            }\n@@ -505,19 +514,1 @@\n-            \/\/ Get end-entity certificate and remove from system cert store\n-            X509Certificate[] certChain = entry.getCertificateChain();\n-            if (certChain != null && certChain.length > 0) {\n-\n-                try {\n-\n-                    byte[] encoding = certChain[0].getEncoded();\n-                    removeCertificate(getName(), entry.getAlias(), encoding,\n-                            encoding.length);\n-\n-                } catch (CertificateException e) {\n-                    throw new KeyStoreException(\"Cannot remove entry: \", e);\n-                }\n-            }\n-            CKey privateKey = entry.getPrivateKey();\n-            if (privateKey != null) {\n-                destroyKeyContainer(\n-                    CKey.getContainerName(privateKey.getHCryptProvider()));\n-            }\n+            entry.delete();\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CKeyStore.java","additions":42,"deletions":51,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8185844\n+ * @summary ensure setEntry overwrite old entry\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+public class SetDupNameEntry {\n+\n+    final KeyStore keyStore;\n+    final CertAndKeyGen ckg;\n+\n+    static final String PREFIX = \"8185844\";\n+\n+    public static void main(String[] args) throws Exception {\n+        SetDupNameEntry test = new SetDupNameEntry();\n+        test.cleanup();\n+        try {\n+            test.test(true);    \/\/ test key entry\n+            test.test(false);   \/\/ test cert entry\n+        } finally {\n+            test.cleanup();\n+        }\n+    }\n+\n+    SetDupNameEntry() throws Exception {\n+        keyStore = KeyStore.getInstance(\"Windows-MY\");\n+        ckg = new CertAndKeyGen(\"RSA\", \"SHA1withRSA\");\n+    }\n+\n+    void test(boolean testKey) throws Exception {\n+        keyStore.load(null, null);\n+        int size = keyStore.size();\n+\n+        String alias = PREFIX + (testKey ? \"k\" : \"c\");\n+        for (int i = 0; i < 2; i++) {\n+            ckg.generate(1024);\n+            X509Certificate cert = ckg\n+                    .getSelfCertificate(new X500Name(\"CN=TEST\"), 1000);\n+            if (testKey) {\n+                keyStore.setKeyEntry(\n+                        alias,\n+                        ckg.getPrivateKey(),\n+                        null,\n+                        new Certificate[] { cert });\n+            } else {\n+                keyStore.setCertificateEntry(alias, cert);\n+            }\n+        }\n+        Asserts.assertEQ(keyStore.size(), size + 1);\n+\n+        keyStore.load(null, null);\n+        Asserts.assertEQ(keyStore.size(), size + 1);\n+    }\n+\n+    void cleanup() throws Exception {\n+        keyStore.load(null, null);\n+        for (String alias : Collections.list(keyStore.aliases())) {\n+            if (alias.startsWith(PREFIX)) {\n+                keyStore.deleteEntry(alias);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/mscapi\/SetDupNameEntry.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}