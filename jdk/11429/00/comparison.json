{"files":[{"patch":"@@ -129,3 +129,0 @@\n-  Relocation* reloc = _rspec.reloc();\n-  relocInfo::relocType rtype = (relocInfo::relocType) reloc->type();\n-\n@@ -134,1 +131,1 @@\n-    if (_offset == 0 && _base == r) \/\/ it's a nop\n+    if (offset() == 0 && base() == r) \/\/ it's a nop\n@@ -136,2 +133,2 @@\n-    if (_offset > 0)\n-      __ add(r, _base, _offset);\n+    if (offset() > 0)\n+      __ add(r, base(), offset());\n@@ -139,1 +136,1 @@\n-      __ sub(r, _base, -_offset);\n+      __ sub(r, base(), -offset());\n@@ -143,1 +140,1 @@\n-    __ add(r, _base, _index, _ext.op(), MAX2(_ext.shift(), 0));\n+    __ add(r, base(), index(), ext().op(), MAX2(ext().shift(), 0));\n@@ -147,1 +144,2 @@\n-    if (rtype == relocInfo::none)\n+    as->code_section()->relocate(as->inst_mark(), rspec());\n+    if (rspec().type() == relocInfo::none)\n@@ -240,2 +238,14 @@\n-Address::Address(address target, relocInfo::relocType rtype) : _mode(literal){\n-  _target = target;\n+#ifdef ASSERT\n+\n+void Address::assert_is_literal() const {\n+  assert(_mode == literal, \"addressing mode is non-literal: %d\", _mode);\n+}\n+\n+void Address::assert_is_nonliteral() const {\n+  assert(_mode != literal, \"unexpected literal addressing mode\");\n+  assert(_mode != no_mode, \"unexpected no_mode addressing mode\");\n+}\n+\n+#endif \/\/ ASSERT\n+\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n@@ -249,1 +259,1 @@\n-    break;\n+    return RelocationHolder::none;\n@@ -251,2 +261,1 @@\n-    _rspec = external_word_Relocation::spec(target);\n-    break;\n+    return external_word_Relocation::spec(target);\n@@ -254,2 +263,1 @@\n-    _rspec = internal_word_Relocation::spec(target);\n-    break;\n+    return internal_word_Relocation::spec(target);\n@@ -257,2 +265,1 @@\n-    _rspec = opt_virtual_call_Relocation::spec();\n-    break;\n+    return opt_virtual_call_Relocation::spec();\n@@ -260,2 +267,1 @@\n-    _rspec = static_call_Relocation::spec();\n-    break;\n+    return static_call_Relocation::spec();\n@@ -263,2 +269,1 @@\n-    _rspec = runtime_call_Relocation::spec();\n-    break;\n+    return runtime_call_Relocation::spec();\n@@ -267,2 +272,1 @@\n-    _rspec = Relocation::spec_simple(rtype);\n-    break;\n+    return Relocation::spec_simple(rtype);\n@@ -270,2 +274,1 @@\n-    _rspec = RelocationHolder::none;\n-    break;\n+    return RelocationHolder::none;\n@@ -274,1 +277,1 @@\n-    break;\n+    return RelocationHolder::none;\n@@ -278,0 +281,5 @@\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n@@ -361,5 +365,12 @@\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  extend _ext;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset, extend ext = extend())\n+      : _base(base), _index(index), _offset(offset), _ext(ext) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+    extend _ext;\n+  };\n+\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n@@ -367,1 +378,20 @@\n-  RelocationHolder _rspec;\n+    \/\/ If the target is far we'll need to load the ea of this to a\n+    \/\/ register to reach it. Otherwise if near we can do PC-relative\n+    \/\/ addressing.\n+    address _target;\n+\n+    RelocationHolder _rspec;\n+  };\n+\n+  void assert_is_nonliteral() const NOT_DEBUG_RETURN;\n+  void assert_is_literal() const NOT_DEBUG_RETURN;\n+\n+  \/\/ Discriminated union, based on _mode.\n+  \/\/ - no_mode: uses dummy _nonliteral, for ease of copying.\n+  \/\/ - literal: only _literal is used.\n+  \/\/ - others: only _nonliteral is used.\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n@@ -369,4 +399,11 @@\n-  \/\/ If the target is far we'll need to load the ea of this to a\n-  \/\/ register to reach it. Otherwise if near we can do PC-relative\n-  \/\/ addressing.\n-  address          _target;\n+  \/\/ Helper for copy constructor and assignment operator.\n+  \/\/ Copy mode-relevant part of a into this.\n+  void copy_data(const Address& a) {\n+    assert(_mode == a._mode, \"precondition\");\n+    if (_mode == literal) {\n+      new (&_literal) Literal(a._literal);\n+    } else {\n+      \/\/ non-literal mode or no_mode.\n+      new (&_nonliteral) Nonliteral(a._nonliteral);\n+    }\n+  }\n@@ -375,4 +412,10 @@\n-  Address()\n-    : _mode(no_mode) { }\n-  Address(Register r)\n-    : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }\n+  \/\/ no_mode initializes _nonliteral for ease of copying.\n+  Address() :\n+    _mode(no_mode),\n+    _nonliteral(noreg, noreg, 0)\n+  {}\n+\n+  Address(Register r) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, 0)\n+  {}\n@@ -381,17 +424,27 @@\n-  Address(Register r, T o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) {}\n-\n-  Address(Register r, ByteSize disp)\n-    : Address(r, in_bytes(disp)) { }\n-  Address(Register r, Register r1, extend ext = lsl())\n-    : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),\n-      _ext(ext), _target(0) { }\n-  Address(Pre p)\n-    : _base(p.reg()), _offset(p.offset()), _mode(pre) { }\n-  Address(Post p)\n-    : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),\n-      _mode(p.is_postreg() ? post_reg : post), _target(0) { }\n-  Address(address target, RelocationHolder const& rspec)\n-    : _mode(literal),\n-      _rspec(rspec),\n-      _target(target)  { }\n+  Address(Register r, T o) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, o)\n+  {}\n+\n+  Address(Register r, ByteSize disp) : Address(r, in_bytes(disp)) {}\n+\n+  Address(Register r, Register r1, extend ext = lsl()) :\n+    _mode(base_plus_offset_reg),\n+    _nonliteral(r, r1, 0, ext)\n+  {}\n+\n+  Address(Pre p) :\n+    _mode(pre),\n+    _nonliteral(p.reg(), noreg, p.offset())\n+  {}\n+\n+  Address(Post p) :\n+    _mode(p.is_postreg() ? post_reg : post),\n+    _nonliteral(p.reg(), p.idx_reg(), p.offset())\n+  {}\n+\n+  Address(address target, const RelocationHolder& rspec) :\n+    _mode(literal),\n+    _literal(target, rspec)\n+  {}\n+\n@@ -399,3 +452,2 @@\n-  Address(Register base, RegisterOrConstant index, extend ext = lsl())\n-    : _base (base),\n-      _offset(0), _ext(ext), _target(0) {\n+\n+  Address(Register base, RegisterOrConstant index, extend ext = lsl()) {\n@@ -404,1 +456,1 @@\n-      _index = index.as_register();\n+      new (&_nonliteral) Nonliteral(base, index.as_register(), 0, ext);\n@@ -409,1 +461,3 @@\n-      _offset = index.as_constant() << ext.shift();\n+      new (&_nonliteral) Nonliteral(base,\n+                                    noreg,\n+                                    index.as_constant() << ext.shift());\n@@ -413,0 +467,16 @@\n+  Address(const Address& a) : _mode(a._mode) { copy_data(a); }\n+\n+  \/\/ Verify the value is trivially destructible regardless of mode, so our\n+  \/\/ destructor can also be trivial, and so our assignment operator doesn't\n+  \/\/ need to destruct the old value before copying over it.\n+  static_assert(std::is_trivially_destructible<Literal>::value, \"must be\");\n+  static_assert(std::is_trivially_destructible<Nonliteral>::value, \"must be\");\n+\n+  Address& operator=(const Address& a) {\n+    _mode = a._mode;\n+    copy_data(a);\n+    return *this;\n+  }\n+\n+  ~Address() = default;\n+\n@@ -414,4 +484,2 @@\n-    guarantee((_mode == base_plus_offset || _mode == base_plus_offset_reg\n-               || _mode == post || _mode == post_reg),\n-              \"wrong mode\");\n-    return _base;\n+    assert_is_nonliteral();\n+    return _nonliteral._base;\n@@ -419,0 +487,1 @@\n+\n@@ -420,1 +489,2 @@\n-    return _offset;\n+    assert_is_nonliteral();\n+    return _nonliteral._offset;\n@@ -422,0 +492,1 @@\n+\n@@ -423,1 +494,2 @@\n-    return _index;\n+    assert_is_nonliteral();\n+    return _nonliteral._index;\n@@ -425,0 +497,6 @@\n+\n+  extend ext() const {\n+    assert_is_nonliteral();\n+    return _nonliteral._ext;\n+  }\n+\n@@ -428,3 +506,14 @@\n-  bool uses(Register reg) const { return _base == reg || _index == reg; }\n-  address target() const { return _target; }\n-  const RelocationHolder& rspec() const { return _rspec; }\n+\n+  bool uses(Register reg) const {\n+    return base() == reg || index() == reg;\n+  }\n+\n+  address target() const {\n+    assert_is_literal();\n+    return _literal._target;\n+  }\n+\n+  const RelocationHolder& rspec() const {\n+    assert_is_literal();\n+    return _literal._rspec;\n+  }\n@@ -434,1 +523,1 @@\n-    i->srf(_base, 5);\n+    i->srf(base(), 5);\n@@ -445,2 +534,2 @@\n-        assert(offset_ok_for_immed(_offset, size),\n-               \"must be, was: \" INT64_FORMAT \", %d\", _offset, size);\n+        assert(offset_ok_for_immed(offset(), size),\n+               \"must be, was: \" INT64_FORMAT \", %d\", offset(), size);\n@@ -448,1 +537,1 @@\n-        if (_offset < 0 || _offset & mask) {\n+        if (offset() < 0 || offset() & mask) {\n@@ -451,1 +540,1 @@\n-          i->sf(_offset, 20, 12);\n+          i->sf(offset(), 20, 12);\n@@ -454,1 +543,1 @@\n-          i->f(_offset >> size, 21, 10);\n+          i->f(offset() >> size, 21, 10);\n@@ -463,2 +552,2 @@\n-        i->rf(_index, 16);\n-        i->f(_ext.option(), 15, 13);\n+        i->rf(index(), 16);\n+        i->f(ext().option(), 15, 13);\n@@ -472,1 +561,1 @@\n-          i->f(_ext.shift() >= 0, 12);\n+          i->f(ext().shift() >= 0, 12);\n@@ -474,2 +563,2 @@\n-          assert(_ext.shift() <= 0 || _ext.shift() == (int)size, \"bad shift\");\n-          i->f(_ext.shift() > 0, 12);\n+          assert(ext().shift() <= 0 || ext().shift() == (int)size, \"bad shift\");\n+          i->f(ext().shift() > 0, 12);\n@@ -484,1 +573,1 @@\n-      i->sf(_offset, 20, 12);\n+      i->sf(offset(), 20, 12);\n@@ -490,1 +579,1 @@\n-      i->sf(_offset, 20, 12);\n+      i->sf(offset(), 20, 12);\n@@ -532,3 +621,3 @@\n-    guarantee(_offset % size == 0, \"bad offset\");\n-    i->sf(_offset \/ size, 21, 15);\n-    i->srf(_base, 5);\n+    guarantee(offset() % size == 0, \"bad offset\");\n+    i->sf(offset() \/ size, 21, 15);\n+    i->srf(base(), 5);\n@@ -538,1 +627,1 @@\n-    \/\/ Only base + offset is allowed\n+    guarantee(_mode == base_plus_offset, \"Bad addressing mode for nontemporal op\");\n@@ -542,5 +631,3 @@\n-    guarantee(_offset % size == 0, \"bad offset\");\n-    i->sf(_offset \/ size, 21, 15);\n-    i->srf(_base, 5);\n-    guarantee(_mode == Address::base_plus_offset,\n-              \"Bad addressing mode for non-temporal op\");\n+    guarantee(offset() % size == 0, \"bad offset\");\n+    i->sf(offset() \/ size, 21, 15);\n+    i->srf(base(), 5);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":154,"deletions":67,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-    code_section()->relocate(inst_mark(), a.rspec());\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}