{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -76,4 +77,5 @@\n-\/\/ Specializations must provide static const data members named\n-\/\/ \"_first\" and \"_last\", whose values are the smallest \/ largest\n-\/\/ (resp.) enumerator values for T. For iteration, the enumerators of\n-\/\/ T must have sequential values in that range.\n+\/\/ Specializations must provide static const data members named \"_start\" and \"_end\".\n+\/\/ The type of _start and _end must be the underlying type of T.\n+\/\/ _start is the inclusive lower bound of values in the range.\n+\/\/ _end is the exclusive upper bound of values in the range.\n+\/\/ The enumerators of T must have sequential values in that range.\n@@ -82,5 +84,26 @@\n-\/\/ Specialize EnumeratorRange<T>.\n-#define ENUMERATOR_RANGE(T, First, Last)        \\\n-  template<> struct EnumeratorRange<T> {        \\\n-    static constexpr T _first = First;          \\\n-    static constexpr T _last = Last;            \\\n+\/\/ Helper class for ENUMERATOR_RANGE and ENUMERATOR_VALUE_RANGE.\n+struct EnumeratorRangeImpl : AllStatic {\n+  template<typename T> using Underlying = std::underlying_type_t<T>;\n+\n+  \/\/ T not deduced to verify argument is of expected type.\n+  template<typename T, typename U, ENABLE_IF(std::is_same<T, U>::value)>\n+  static constexpr Underlying<T> start_value(U first) {\n+    return static_cast<Underlying<T>>(first);\n+  }\n+\n+  \/\/ T not deduced to verify argument is of expected type.\n+  template<typename T, typename U, ENABLE_IF(std::is_same<T, U>::value)>\n+  static constexpr Underlying<T> end_value(U last) {\n+    Underlying<T> value = static_cast<Underlying<T>>(last);\n+    assert(value < std::numeric_limits<Underlying<T>>::max(), \"end value overflow\");\n+    return static_cast<Underlying<T>>(value + 1);\n+  }\n+};\n+\n+\/\/ Specialize EnumeratorRange<T>.  Start and End must be constant expressions\n+\/\/ whose value is convertible to the underlying type of T.  They provide the\n+\/\/ values of the required _start and _end members respectively.\n+#define ENUMERATOR_VALUE_RANGE(T, Start, End)                           \\\n+  template<> struct EnumeratorRange<T> {                                \\\n+    static constexpr EnumeratorRangeImpl::Underlying<T> _start{Start};  \\\n+    static constexpr EnumeratorRangeImpl::Underlying<T> _end{End};      \\\n@@ -89,2 +112,11 @@\n-\/\/ A helper class for EnumIterator, computing some additional information the\n-\/\/ iterator uses, based on T and EnumeratorRange.\n+\/\/ Specialize EnumeratorRange<T>.  First and Last must be constant expressions\n+\/\/ of type T.  They determine the values of the required _start and _end members\n+\/\/ respectively.  _start is the underlying value of First. _end is the underlying\n+\/\/ value of Last, plus one.\n+#define ENUMERATOR_RANGE(T, First, Last)                                \\\n+  ENUMERATOR_VALUE_RANGE(T,                                             \\\n+                         EnumeratorRangeImpl::start_value<T>(First),    \\\n+                         EnumeratorRangeImpl::end_value<T>(Last));\n+\n+\/\/ A helper class for EnumRange and EnumIterator, computing some\n+\/\/ additional information based on T and EnumeratorRange<T>.\n@@ -99,2 +131,2 @@\n-  \/\/ The first enumerator of T.\n-  static constexpr T _first = RangeType::_first;\n+  \/\/ The value of the first enumerator of T.\n+  static constexpr Underlying _start = RangeType::_start;\n@@ -102,2 +134,2 @@\n-  \/\/ The last enumerator of T.\n-  static constexpr T _last = RangeType::_last;\n+  \/\/ The one-past-the-end value for T.\n+  static constexpr Underlying _end = RangeType::_end;\n@@ -105,3 +137,2 @@\n-  static_assert(static_cast<Underlying>(_last) <\n-                std::numeric_limits<Underlying>::max(),\n-                \"No one-past-the-end value for enum\");\n+  \/\/ The first enumerator of T.\n+  static constexpr T _first = static_cast<T>(_start);\n@@ -109,2 +140,2 @@\n-  \/\/ The value of the first enumerator of T.\n-  static constexpr Underlying _start = static_cast<Underlying>(_first);\n+  \/\/ The last enumerator of T.\n+  static constexpr T _last = static_cast<T>(_end - 1);\n@@ -112,2 +143,2 @@\n-  \/\/ The one-past-the-end value for T.\n-  static constexpr Underlying _end = static_cast<Underlying>(_last) + 1;\n+  static_assert(_start != _end, \"empty range\");\n+  static_assert(_start <= _end, \"invalid range\"); \/\/ <= so only one failure when ==.\n@@ -128,0 +159,2 @@\n+  using EnumType = T;\n+\n@@ -183,0 +216,1 @@\n+  using EnumType = T;\n@@ -217,0 +251,11 @@\n+\n+  constexpr T first() const { return static_cast<T>(_start); }\n+  constexpr T last() const { return static_cast<T>(_end - 1); }\n+\n+  \/\/ Convert value to a zero-based index into the range [first(), last()].\n+  \/\/ precondition: first() <= value && value <= last()\n+  constexpr size_t index(T value) const {\n+    assert(first() <= value, \"out of bounds\");\n+    assert(value <= last(), \"out of bounds\");\n+    return static_cast<size_t>(static_cast<Underlying>(value) - _start);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":67,"deletions":22,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/enumIterator.hpp\"\n+#include <type_traits>\n+#include \"unittest.hpp\"\n+\n+enum class ExplicitTest : int { value1, value2, value3 };\n+ENUMERATOR_RANGE(ExplicitTest, ExplicitTest::value1, ExplicitTest::value3);\n+constexpr int explicit_start = 0;\n+constexpr int explicit_end = 3;\n+\n+enum class ImplicitTest : int {};\n+ENUMERATOR_VALUE_RANGE(ImplicitTest, 5, 10);\n+constexpr int implicit_start = 5;\n+constexpr int implicit_end = 10;\n+\n+TEST(TestEnumIterator, explicit_full_range) {\n+  using Range = EnumRange<ExplicitTest>;\n+  constexpr Range range{};\n+  EXPECT_TRUE((std::is_same<ExplicitTest, Range::EnumType>::value));\n+  EXPECT_EQ(size_t(explicit_end - explicit_start), range.size());\n+  EXPECT_EQ(ExplicitTest::value1, range.first());\n+  EXPECT_EQ(ExplicitTest::value3, range.last());\n+  EXPECT_EQ(size_t(1), range.index(ExplicitTest::value2));\n+}\n+\n+TEST(TestEnumIterator, explicit_partial_range) {\n+  using Range = EnumRange<ExplicitTest>;\n+  constexpr Range range{ExplicitTest::value2};\n+  EXPECT_TRUE((std::is_same<ExplicitTest, Range::EnumType>::value));\n+  EXPECT_EQ(size_t(explicit_end - (explicit_start + 1)), range.size());\n+  EXPECT_EQ(ExplicitTest::value2, range.first());\n+  EXPECT_EQ(ExplicitTest::value3, range.last());\n+  EXPECT_EQ(size_t(0), range.index(ExplicitTest::value2));\n+}\n+\n+TEST(TestEnumIterator, implicit_full_range) {\n+  using Range = EnumRange<ImplicitTest>;\n+  constexpr Range range{};\n+  EXPECT_TRUE((std::is_same<ImplicitTest, Range::EnumType>::value));\n+  EXPECT_EQ(size_t(implicit_end - implicit_start), range.size());\n+  EXPECT_EQ(static_cast<ImplicitTest>(implicit_start), range.first());\n+  EXPECT_EQ(static_cast<ImplicitTest>(implicit_end - 1), range.last());\n+  EXPECT_EQ(size_t(2), range.index(static_cast<ImplicitTest>(implicit_start + 2)));\n+}\n+\n+TEST(TestEnumIterator, implicit_partial_range) {\n+  using Range = EnumRange<ImplicitTest>;\n+  constexpr Range range{static_cast<ImplicitTest>(implicit_start + 2)};\n+  EXPECT_TRUE((std::is_same<ImplicitTest, Range::EnumType>::value));\n+  EXPECT_EQ(size_t(implicit_end - (implicit_start + 2)), range.size());\n+  EXPECT_EQ(static_cast<ImplicitTest>(implicit_start + 2), range.first());\n+  EXPECT_EQ(static_cast<ImplicitTest>(implicit_end - 1), range.last());\n+  EXPECT_EQ(size_t(1), range.index(static_cast<ImplicitTest>(implicit_start + 3)));\n+}\n+\n+TEST(TestEnumIterator, explict_iterator) {\n+  using Range = EnumRange<ExplicitTest>;\n+  using Iterator = EnumIterator<ExplicitTest>;\n+  constexpr Range range{};\n+  EXPECT_EQ(range.first(), *range.begin());\n+  EXPECT_EQ(Iterator(range.first()), range.begin());\n+  EnumIterator<ExplicitTest> it = range.begin();\n+  ++it;\n+  EXPECT_EQ(ExplicitTest::value2, *it);\n+  it = range.begin();\n+  for (int i = explicit_start; i < explicit_end; ++i, ++it) {\n+    ExplicitTest value = static_cast<ExplicitTest>(i);\n+    EXPECT_EQ(value, *it);\n+    EXPECT_EQ(Iterator(value), it);\n+    EXPECT_EQ(size_t(i - explicit_start), range.index(value));\n+  }\n+  EXPECT_EQ(it, range.end());\n+}\n+\n+TEST(TestEnumIterator, implicit_iterator) {\n+  using Range = EnumRange<ImplicitTest>;\n+  using Iterator = EnumIterator<ImplicitTest>;\n+  constexpr Range range{};\n+  EXPECT_EQ(range.first(), *range.begin());\n+  EXPECT_EQ(Iterator(range.first()), range.begin());\n+  EnumIterator<ImplicitTest> it = range.begin();\n+  for (int i = implicit_start; i < implicit_end; ++i, ++it) {\n+    ImplicitTest value = static_cast<ImplicitTest>(i);\n+    EXPECT_EQ(value, *it);\n+    EXPECT_EQ(Iterator(value), it);\n+    EXPECT_EQ(size_t(i - implicit_start), range.index(value));\n+  }\n+  EXPECT_EQ(it, range.end());\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_enumIterator.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}