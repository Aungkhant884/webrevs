{"files":[{"patch":"@@ -2670,1 +2670,1 @@\n-objArrayOop java_lang_Throwable::get_stack_trace(Handle throwable, TRAPS) {\n+Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n@@ -2681,2 +2681,2 @@\n-                          CHECK_NULL);\n-  oop stack_trace = result.get_oop();\n+                          CHECK_NH);\n+  Handle stack_trace(THREAD, result.get_oop());\n@@ -2684,2 +2684,0 @@\n-  return (objArrayOop)stack_trace;\n-}\n@@ -2687,2 +2685,11 @@\n-oop java_lang_Throwable::recreate_cause(Symbol* exception, Symbol* message, const char* thread_name,\n-                                        Handle stack_trace, TRAPS) {\n+  \/\/ If the original exception was in java.base, then use that otherwise use\n+  \/\/ ExceptionInInitializerError as the cause with this stack trace, which might be a\n+  \/\/ little wierd but still helpful.\n+  Klass* tk = throwable->klass();\n+  bool null_classloader = tk->class_loader() == nullptr;\n+\n+  Symbol* exception_name = null_classloader ?  tk->name() :\n+                             vmSymbols::java_lang_ExceptionInInitializerError();\n+\n+  \/\/ Now create a the same exception with this stacktrace and thread name.\n+  Symbol* message = java_lang_Throwable::detail_message(throwable());\n@@ -2691,0 +2698,4 @@\n+  if (!null_classloader) {\n+    st.print(\"Exception %s%s \", tk->name()->as_klass_external_name(),\n+             message == nullptr ? \"\" : \":\");\n+  }\n@@ -2692,1 +2703,1 @@\n-    st.print(\"[in thread \\\"%s\\\"]\", thread_name);\n+    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n@@ -2694,1 +2705,8 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), thread_name);\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+  }\n+\n+  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n+\n+  \/\/ If new exception returns a different exception while creating the exception, return null.\n+  if (h_cause->klass()->name() != exception_name) {\n+    return Handle();\n@@ -2696,1 +2714,0 @@\n-  Handle h_cause = Exceptions::new_exception(THREAD, exception, st.as_string());\n@@ -2700,1 +2717,1 @@\n-  return h_cause();\n+  return h_cause;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -571,3 +571,1 @@\n-  static objArrayOop get_stack_trace(Handle throwable, TRAPS);\n-  static oop  recreate_cause(Symbol* exception, Symbol* message, const char* thread_name,\n-                             Handle stack_trace, TRAPS);\n+  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1020,34 +1020,1 @@\n-class InitErrorElement {\n-  Symbol* _exception;\n-  Symbol* _message;\n-  OopHandle _stack_trace;\n-  const char* _thread_name;\n- public:\n-  InitErrorElement(JavaThread* current, Handle exception, Handle stack_trace) {\n-    _exception = exception->klass()->name();\n-    _exception->increment_refcount();\n-    _message = java_lang_Throwable::detail_message(exception());\n-    if (_message != nullptr) {\n-      _message->increment_refcount();\n-    }\n-    _stack_trace = OopHandle(Universe::vm_global(), stack_trace());\n-    ResourceMark rm(current);\n-    stringStream st;\n-    st.print(\"%s\", current->name());\n-    _thread_name = st.as_string(\/* c_heap *\/ true);\n-  }\n-  void clean() {\n-    _exception->decrement_refcount();\n-    if (_message != nullptr) {\n-      _message->decrement_refcount();\n-    }\n-    _stack_trace.release(Universe::vm_global());\n-    FREE_C_HEAP_ARRAY(char*, _thread_name);\n-  }\n-  Symbol* exception() const { return _exception; }\n-  Symbol* message() const   { return _message; }\n-  oop stack_trace() const   { return _stack_trace.resolve(); }\n-  const char* thread_name() const { return _thread_name; }\n-};\n-\n-ResizeableResourceHashtable<const InstanceKlass*, InitErrorElement, ResourceObj::C_HEAP, mtClass>\n+ResizeableResourceHashtable<const InstanceKlass*, OopHandle, ResourceObj::C_HEAP, mtClass>\n@@ -1058,4 +1025,5 @@\n-  \/\/ Save the StackTraceElements, and the exception name.\n-  \/\/ If the initialization error is OOM, this might not work, but a NULL\n-  \/\/ stack trace with the original OOM exception might be helpful anyway.\n-  objArrayOop st = java_lang_Throwable::get_stack_trace(exception, THREAD);\n+  \/\/ Create the same exception with a message indicating the thread name,\n+  \/\/ and the StackTraceElements.\n+  \/\/ If the initialization error is OOM, this might not work, but if GC kicks in\n+  \/\/ this would be still be helpful.\n+  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n@@ -1063,1 +1031,0 @@\n-  Handle stack_trace(THREAD, st);\n@@ -1066,1 +1033,1 @@\n-  InitErrorElement elem(THREAD, exception, stack_trace);\n+  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n@@ -1071,13 +1038,4 @@\n-oop InstanceKlass::get_initialization_error(TRAPS) {\n-  InitErrorElement* h;\n-  {\n-    MutexLocker ml(THREAD, ClassInitError_lock);\n-    h = _initialization_error_table.get(this);\n-  }\n-  if (h != nullptr) {\n-    oop cause = java_lang_Throwable::recreate_cause(h->exception(), h->message(), h->thread_name(),\n-                                                    Handle(THREAD, h->stack_trace()), CHECK_NULL);\n-    return cause;\n-  } else {\n-    return nullptr;\n-  }\n+oop InstanceKlass::get_initialization_error(JavaThread* current) {\n+  MutexLocker ml(current, ClassInitError_lock);\n+  OopHandle* h = _initialization_error_table.get(this);\n+  return (h != nullptr) ? h->resolve() : nullptr;\n@@ -1089,1 +1047,1 @@\n-    bool do_entry(const InstanceKlass* ik, InitErrorElement h) {\n+    bool do_entry(const InstanceKlass* ik, OopHandle h) {\n@@ -1091,1 +1049,1 @@\n-        h.clean();\n+        h.release(Universe::vm_global());\n@@ -1104,12 +1062,0 @@\n-void print_initialization_error_table() {\n-  struct Printer {\n-    bool do_entry(const InstanceKlass* ik, InitErrorElement) {\n-      tty->print_cr(\"klass\");\n-      ik->print();\n-      return true;\n-    }\n-  };\n-  Printer p;\n-  _initialization_error_table.iterate(&p);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":13,"deletions":67,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @compile ThrowsSpecialException.jasm\n@@ -46,0 +47,7 @@\n+    static public class SpecialException extends Throwable {\n+        SpecialException(int count, String message) {\n+            super(message + count);\n+        }\n+    }\n+    \/\/ Has to be in jasm to throw special exception in class initializer.\n+    \/\/ static public class ThrowsSpecialException\n@@ -54,1 +62,1 @@\n-            throw new RuntimeException(expected + \" and \" + cause + \" missing from stacktrace: \" + stackTrace);\n+            throw new RuntimeException(expected + \" and \" + cause + \" missing from stacktrace\");\n@@ -66,1 +74,5 @@\n-        \"Caused by: java.lang.Error\" };\n+        \"Caused by: java.lang.Error\",\n+        \"java.lang.ExceptionInInitializerError\",\n+        \"Caused by: InitExceptionUnloadTest$SpecialException: Very Special 3\",\n+        \"java.lang.NoClassDefFoundError: Cound not initialize class InitExceptionUnloadTest$ThrowsSpecialException\",\n+        \"Caused by: java.lang.ExceptionInInitializerError: Exception InitExceptionUnloadTest$SpecialException: Very Special 3\" };\n@@ -69,2 +81,3 @@\n-         \"InitExceptionUnloadTest$ThrowsRuntimeException\",\n-         \"InitExceptionUnloadTest$ThrowsError\" };\n+        \"InitExceptionUnloadTest$ThrowsRuntimeException\",\n+        \"InitExceptionUnloadTest$ThrowsError\",\n+        \"InitExceptionUnloadTest$ThrowsSpecialException\" };\n@@ -78,1 +91,0 @@\n-            System.err.println(\"--- try to load \" + className);\n@@ -80,0 +92,1 @@\n+                System.err.println(\"--- try to load \" + className);\n@@ -85,0 +98,2 @@\n+                    System.err.println();\n+                    System.err.println(\"Check results\");\n@@ -87,0 +102,1 @@\n+                    System.err.println();\n@@ -92,2 +108,3 @@\n-        ClassUnloadCommon.failIf(wb.isClassAlive(classNames[0]), \"should be unloaded\");\n-        ClassUnloadCommon.failIf(wb.isClassAlive(classNames[1]), \"should be unloaded\");\n+        for (String className : classNames) {\n+          ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should be unloaded\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/InitExceptionUnloadTest.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+    static public class ThrowsSpecialException {\n+        static {\n+            \/\/ Can't trick javac, have to use jasm.\n+            \/\/ if (true) foo();\n+        }\n+        static private void foo() throws SpecialException {\n+            if (true) throw new SpecialException(3, \"Very Special \");\n+        }\n+    }\n+*\/\n+\n+super public class InitExceptionUnloadTest$ThrowsSpecialException\n+\tversion 62:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+{\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+}\n+\n+private static Method foo:\"()V\"\n+\tthrows InitExceptionUnloadTest$SpecialException\n+\tstack 4 locals 0\n+{\n+\t\tnew\tclass InitExceptionUnloadTest$SpecialException;\n+\t\tdup;\n+\t\ticonst_3;\n+\t\tldc\tString \"Very Special \";\n+\t\tinvokespecial\tMethod InitExceptionUnloadTest$SpecialException.\"<init>\":\"(ILjava\/lang\/String;)V\";\n+\t\tathrow;\n+}\n+\n+static Method \"<clinit>\":\"()V\"\n+\tstack 0 locals 0\n+{\n+                invokestatic  Method \"foo\":\"()V\";\n+\t\treturn;\n+}\n+\n+NestHost InitExceptionUnloadTest;\n+public static InnerClass SpecialException=class InitExceptionUnloadTest$SpecialException of class InitExceptionUnloadTest;\n+public static InnerClass ThrowsSpecialException=class InitExceptionUnloadTest$ThrowsSpecialException of class InitExceptionUnloadTest;\n+\n+} \/\/ end Class InitExceptionUnloadTest$ThrowsSpecialException\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/ThrowsSpecialException.jasm","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}