{"files":[{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Test JCMD across container boundary. The JCMD runs on a host system,\n+ *          while sending commands to a JVM that runs inside a container.\n+ * @requires docker.support\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *          jdk.jartool\/sun.tools.jar\n+ * @library \/test\/lib\n+ * @build EventGeneratorLoop\n+ * @run driver TestJcmd\n+ *\/\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import jdk.test.lib.Container;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+\n+public class TestJcmd {\n+    private static final String IMAGE_NAME = Common.imageName(\"jcmd\");\n+    private static final int TIME_TO_RUN_CONTAINER_PROCESS = (int) (10 * Utils.TIMEOUT_FACTOR); \/\/ seconds\n+    private static final String CONTAINER_NAME = \"test-container\";\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        DockerTestUtils.canTestDocker();\n+\n+        \/\/ See JDK-8273216 for details\n+        if (Container.ENGINE_COMMAND.equals(\"podman\")) {\n+            throw new SkippedException(\"JCMD does not work across container boundaries when using Podman\");\n+        }\n+\n+        \/\/ Need to create a custom dockerfile where user name and id, as well as group name and id\n+        \/\/ of the JVM running in container must match the ones from the inspecting JCMD process.\n+        String uid = getId(\"-u\");\n+        String gid = getId(\"-g\");\n+        String userName = getId(\"-un\");\n+        String groupName = getId(\"-gn\");\n+        String content = generateCustomDockerfile(uid, gid, userName, groupName);\n+        DockerTestUtils.buildJdkContainerImage(IMAGE_NAME, content);\n+\n+        try {\n+            Process p = startObservedContainer();\n+            long pid = testJcmdGetPid(\"EventGeneratorLoop\");\n+\n+            assertIsAlive(p);\n+            testJcmdHelp(pid);\n+\n+            assertIsAlive(p);\n+            testVmInfo(pid);\n+\n+            p.waitFor();\n+        } finally {\n+            DockerTestUtils.removeDockerImage(IMAGE_NAME);\n+        }\n+    }\n+\n+\n+    \/\/ Run \"jcmd -l\" in a sidecar container, find the target process.\n+    private static long testJcmdGetPid(String className) throws Exception {\n+        System.out.println(\"TestCase: testJcmdGetPid()\");\n+        ProcessBuilder pb = new ProcessBuilder(JDKToolFinder.getJDKTool(\"jcmd\"), \"-l\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+            .shouldHaveExitValue(0);\n+\n+        System.out.println(\"------------------ jcmd -l output: \");\n+        System.out.println(out.getOutput());\n+        System.out.println(\"-----------------------------------\");\n+\n+        List<String> l = out.asLines()\n+            .stream()\n+            .filter(s -> s.contains(className))\n+            .collect(Collectors.toList());\n+        if (l.isEmpty()) {\n+            throw new RuntimeException(\"Could not find specified process\");\n+        }\n+\n+        String pid = l.get(0).split(\"\\\\s+\", 3)[0];\n+        return Long.parseLong(pid);\n+    }\n+\n+\n+    private static void testJcmdHelp(long pid) throws Exception {\n+        System.out.println(\"TestCase: testJcmdHelp()\");\n+        ProcessBuilder pb = new ProcessBuilder(JDKToolFinder.getJDKTool(\"jcmd\"), \"\" + pid, \"help\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"JFR.start\")\n+            .shouldContain(\"VM.version\");\n+    }\n+\n+    private static void testVmInfo(long pid) throws Exception {\n+        System.out.println(\"TestCase: testVmInfo()\");\n+        ProcessBuilder pb = new ProcessBuilder(JDKToolFinder.getJDKTool(\"jcmd\"), \"\" + pid, \"VM.info\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"vm_info\")\n+            .shouldContain(\"VM Arguments\");\n+    }\n+\n+    \/\/ Need to make sure that user name+id and group name+id are created for the image, and\n+    \/\/ match the host system. This is necessary to allow proper permission\/access for JCMD.\n+    private static String generateCustomDockerfile(String uid, String gid,\n+                                            String userName, String groupName) throws Exception {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(String.format(\"FROM %s:%s\\n\", DockerfileConfig.getBaseImageName(),\n+                                DockerfileConfig.getBaseImageVersion()));\n+        sb.append(\"COPY \/jdk \/jdk\\n\");\n+        sb.append(\"ENV JAVA_HOME=\/jdk\\n\");\n+\n+        sb.append(String.format(\"RUN groupadd --gid %s %s \\n\", gid, groupName));\n+        sb.append(String.format(\"RUN useradd  --uid %s --gid %s %s \\n\", uid, gid, userName));\n+        sb.append(String.format(\"USER %s \\n\", userName));\n+\n+        sb.append(\"CMD [\\\"\/bin\/bash\\\"]\\n\");\n+\n+        return sb.toString();\n+    }\n+\n+\n+    private static Process startObservedContainer() throws Exception {\n+        DockerRunOptions opts = new DockerRunOptions(IMAGE_NAME, \"\/jdk\/bin\/java\", \"EventGeneratorLoop\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\")\n+            .addJavaOpts(\"-cp\", \"\/test-classes\/\")\n+            .addDockerOpts(\"--cap-add=SYS_PTRACE\")\n+            .addDockerOpts(\"--name\", CONTAINER_NAME)\n+            .addJavaOpts(\"-XX:+UsePerfData\") \/\/ TODO: do we really need this one\n+            .addClassOptions(\"\" + TIME_TO_RUN_CONTAINER_PROCESS);\n+\n+        \/\/ avoid large Xmx\n+        opts.appendTestJavaOptions = false;\n+\n+        List<String> cmd = DockerTestUtils.buildJavaCommand(opts);\n+        ProcessBuilder pb = new ProcessBuilder(cmd);\n+        return ProcessTools.startProcess(\"main-container-process\",\n+                                      pb,\n+                                      line -> line.contains(EventGeneratorLoop.MAIN_METHOD_STARTED),\n+                                      5, TimeUnit.SECONDS);\n+    }\n+\n+\n+    private static void assertIsAlive(Process p) throws Exception {\n+        if (!p.isAlive()) {\n+            throw new RuntimeException(\"Main container process stopped unexpectedly, exit value: \"\n+                                       + p.exitValue());\n+        }\n+    }\n+\n+\n+    \/\/ -u for userId, -g for groupId\n+    private static String getId(String param) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder(\"id\", param);\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+            .shouldHaveExitValue(0);\n+        String result = out.asLines().get(0);\n+        System.out.println(\"getId() \" + param + \" returning: \" + result);\n+        return result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmd.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,4 +85,2 @@\n-            \/\/ JCMD does not work in sidecar configuration, except for \"jcmd -l\".\n-            \/\/ Including this test case to assist in reproduction of the problem.\n-            \/\/ mainContainer.assertIsAlive();\n-            \/\/ testCase03(mainProcPid);\n+            mainContainer.assertIsAlive();\n+            testCase03(mainProcPid);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    static String getBaseImageName() {\n+    public static String getBaseImageName() {\n@@ -59,1 +59,1 @@\n-    static String getBaseImageVersion() {\n+    public static String getBaseImageVersion() {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}