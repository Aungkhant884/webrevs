{"files":[{"patch":"@@ -37,2 +37,2 @@\n-  @Param({\"16\", \"32\", \"64\", \"128\", \"256\", \"512\", \"1024\"})\n-  private int VECLEN;\n+    @Param({\"16\", \"32\", \"64\", \"128\", \"256\", \"512\", \"1024\"})\n+    private int VECLEN;\n@@ -40,3 +40,3 @@\n-  private byte[][] a;\n-  private byte[][] b;\n-  private byte[][] c;\n+    private byte[][] a;\n+    private byte[][] b;\n+    private byte[][] c;\n@@ -44,6 +44,6 @@\n-  @Setup\n-  public void init() {\n-    a = new byte[VECLEN][VECLEN];\n-    b = new byte[VECLEN][VECLEN];\n-    c = new byte[VECLEN][VECLEN];\n-  }\n+    @Setup\n+    public void init() {\n+        a = new byte[VECLEN][VECLEN];\n+        b = new byte[VECLEN][VECLEN];\n+        c = new byte[VECLEN][VECLEN];\n+    }\n@@ -51,6 +51,8 @@\n-  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-  private int run_workload1(int count, byte[][] a , byte[][] b, byte[][] c) {\n-    for(int i = 0; i < a.length; i++) {\n-      for (int j = 0; j < a[0].length; j++) {\n-        a[i][j] = (byte)(b[i][j] + c[i][j]);\n-      }\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_workload1(int count, byte[][] a , byte[][] b, byte[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = (byte)(b[i][j] + c[i][j]);\n+            }\n+        }\n+        return a[count][count];\n@@ -58,2 +60,0 @@\n-    return a[count][count];\n-  }\n@@ -61,5 +61,7 @@\n-  @Benchmark\n-  public void workload1_caller(Blackhole bh) {\n-    int r = 0;\n-    for(int i = 0 ; i < 100; i++) {\n-      r += run_workload1(i % a.length, a, b, c);\n+    @Benchmark\n+    public void workload1_caller(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_workload1(i % a.length, a, b, c);\n+        }\n+        bh.consume(r);\n@@ -67,2 +69,0 @@\n-    bh.consume(r);\n-  }\n@@ -70,6 +70,8 @@\n-  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-  private int run_workload2(int count, byte[][] a , byte[][] b) {\n-    for(int i = 0; i < b.length; i++) {\n-      for (int j = 0; j < b[0].length; j++) {\n-        a[i][j] = b[i][j];\n-      }\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_workload2(int count, byte[][] a , byte[][] b) {\n+        for(int i = 0; i < b.length; i++) {\n+            for (int j = 0; j < b[0].length; j++) {\n+                a[i][j] = b[i][j];\n+            }\n+        }\n+        return a[count][count];\n@@ -77,2 +79,0 @@\n-    return a[count][count];\n-  }\n@@ -80,5 +80,7 @@\n-  @Benchmark\n-  public void workload2_caller(Blackhole bh) {\n-    int r = 0;\n-    for(int i = 0 ; i < 100; i++) {\n-      r += run_workload2(i % a.length, a, b);\n+    @Benchmark\n+    public void workload2_caller(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_workload2(i % a.length, a, b);\n+        }\n+        bh.consume(r);\n@@ -86,2 +88,0 @@\n-    bh.consume(r);\n-  }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LoopUnroll.java","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"}]}