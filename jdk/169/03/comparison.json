{"files":[{"patch":"@@ -468,1 +468,0 @@\n-  assert(!HAS_PENDING_EXCEPTION, \"Should not have any exceptions pending\");\n@@ -470,1 +469,0 @@\n-  assert(!HAS_PENDING_EXCEPTION, \"Event handler should not throw any exceptions\");\n@@ -1419,0 +1417,1 @@\n+      \/\/ Only metaspace OOM is expected. No Java code executed.\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4795,0 +4795,21 @@\n+\/\/ java_lang_InternalError\n+int java_lang_InternalError::_during_unsafe_access_offset;\n+\n+void java_lang_InternalError::set_during_unsafe_access(oop internal_error) {\n+  internal_error->bool_field_put(_during_unsafe_access_offset, true);\n+}\n+\n+jboolean java_lang_InternalError::during_unsafe_access(oop internal_error) {\n+  return internal_error->bool_field(_during_unsafe_access_offset);\n+}\n+\n+void java_lang_InternalError::compute_offsets() {\n+  INTERNALERROR_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_InternalError::serialize_offsets(SerializeClosure* f) {\n+  INTERNALERROR_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  f(java_lang_InternalError) \\\n@@ -1654,0 +1655,16 @@\n+\n+\/\/ Interface to java.lang.InternalError objects\n+\n+#define INTERNALERROR_INJECTED_FIELDS(macro)                      \\\n+  macro(java_lang_InternalError, during_unsafe_access, bool_signature, false)\n+\n+class java_lang_InternalError : AllStatic {\n+ private:\n+  static int _during_unsafe_access_offset;\n+ public:\n+  static jboolean during_unsafe_access(oop internal_error);\n+  static void set_during_unsafe_access(oop internal_error);\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+};\n+\n@@ -1693,1 +1710,3 @@\n-  MODULE_INJECTED_FIELDS(macro)\n+  MODULE_INJECTED_FIELDS(macro)             \\\n+  INTERNALERROR_INJECTED_FIELDS(macro)\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  do_klass(InternalError_klass,                         java_lang_InternalError                               ) \\\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  template(during_unsafe_access_name,                 \"during_unsafe_access\")                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        methodHandle(), 0, CompileTask::Reason_MustBeCompiled, CHECK);\n+        methodHandle(), 0, CompileTask::Reason_MustBeCompiled, THREAD);\n@@ -381,1 +381,1 @@\n-                                    int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread) {\n+                                    int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS) {\n@@ -384,1 +384,1 @@\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+  if (JvmtiExport::can_post_interpreter_events() && THREAD->as_Java_thread()->is_interp_only_mode()) {\n@@ -410,1 +410,1 @@\n-      method_invocation_event(method, thread);\n+      method_invocation_event(method, THREAD);\n@@ -426,1 +426,1 @@\n-      method_back_branch_event(method, bci, thread);\n+      method_back_branch_event(method, bci, THREAD);\n@@ -481,1 +481,1 @@\n-void SimpleCompPolicy::method_invocation_event(const methodHandle& m, JavaThread* thread) {\n+void SimpleCompPolicy::method_invocation_event(const methodHandle& m, TRAPS) {\n@@ -489,1 +489,1 @@\n-      CompileBroker::compile_method(m, InvocationEntryBci, comp_level, m, hot_count, CompileTask::Reason_InvocationCount, thread);\n+      CompileBroker::compile_method(m, InvocationEntryBci, comp_level, m, hot_count, CompileTask::Reason_InvocationCount, THREAD);\n@@ -494,1 +494,1 @@\n-void SimpleCompPolicy::method_back_branch_event(const methodHandle& m, int bci, JavaThread* thread) {\n+void SimpleCompPolicy::method_back_branch_event(const methodHandle& m, int bci, TRAPS) {\n@@ -499,1 +499,1 @@\n-    CompileBroker::compile_method(m, bci, comp_level, m, hot_count, CompileTask::Reason_BackedgeCount, thread);\n+    CompileBroker::compile_method(m, bci, comp_level, m, hot_count, CompileTask::Reason_BackedgeCount, THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  virtual nmethod* event(const methodHandle& method, const methodHandle& inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread) = 0;\n+  virtual nmethod* event(const methodHandle& method, const methodHandle& inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS) = 0;\n@@ -93,2 +93,2 @@\n-  void method_invocation_event(const methodHandle& m, JavaThread* thread);\n-  void method_back_branch_event(const methodHandle& m, int bci, JavaThread* thread);\n+  void method_invocation_event(const methodHandle& m, TRAPS);\n+  void method_back_branch_event(const methodHandle& m, int bci, TRAPS);\n@@ -105,1 +105,1 @@\n-  virtual nmethod* event(const methodHandle& method, const methodHandle& inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread);\n+  virtual nmethod* event(const methodHandle& method, const methodHandle& inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1258,1 +1258,1 @@\n-                                       Thread* THREAD) {\n+                                       TRAPS) {\n@@ -1268,0 +1268,1 @@\n+  \/\/ CompileBroker::compile_method can trap and can have pending aysnc exception.\n@@ -1278,1 +1279,1 @@\n-                                         Thread* THREAD) {\n+                                         TRAPS) {\n@@ -1331,1 +1332,1 @@\n-    method->constants()->resolve_string_constants(CHECK_AND_CLEAR_NULL);\n+    method->constants()->resolve_string_constants(CHECK_AND_CLEAR_NONASYNC_NULL);\n@@ -1334,1 +1335,1 @@\n-    Method::load_signature_classes(method, CHECK_AND_CLEAR_NULL);\n+    Method::load_signature_classes(method, CHECK_AND_CLEAR_NONASYNC_NULL);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-                                 Thread* thread);\n+                                 TRAPS);\n@@ -315,1 +315,1 @@\n-                                   Thread* thread);\n+                                   TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-                                      int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread) {\n+                                      int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS) {\n@@ -486,1 +486,1 @@\n-      thread->is_interp_only_mode()) {\n+      THREAD->as_Java_thread()->is_interp_only_mode()) {\n@@ -504,1 +504,1 @@\n-    method_invocation_event(method, inlinee, comp_level, nm, thread);\n+    method_invocation_event(method, inlinee, comp_level, nm, THREAD);\n@@ -507,1 +507,1 @@\n-    method_back_branch_event(method, inlinee, bci, comp_level, nm, thread);\n+    method_back_branch_event(method, inlinee, bci, comp_level, nm, THREAD);\n@@ -525,1 +525,1 @@\n-void TieredThresholdPolicy::compile(const methodHandle& mh, int bci, CompLevel level, JavaThread* thread) {\n+void TieredThresholdPolicy::compile(const methodHandle& mh, int bci, CompLevel level, TRAPS) {\n@@ -537,3 +537,4 @@\n-      RegisterMap map(thread, false);\n-      frame fr = thread->last_frame().sender(&map);\n-      Deoptimization::deoptimize_frame(thread, fr.id());\n+      JavaThread* jt = THREAD->as_Java_thread();\n+      RegisterMap map(jt, false);\n+      frame fr = jt->last_frame().sender(&map);\n+      Deoptimization::deoptimize_frame(jt, fr.id());\n@@ -569,1 +570,1 @@\n-        compile(mh, bci, CompLevel_simple, thread);\n+        compile(mh, bci, CompLevel_simple, THREAD);\n@@ -580,1 +581,1 @@\n-        compile(mh, bci, CompLevel_simple, thread);\n+        compile(mh, bci, CompLevel_simple, THREAD);\n@@ -594,1 +595,1 @@\n-    CompileBroker::compile_method(mh, bci, level, mh, hot_count, CompileTask::Reason_Tiered, thread);\n+    CompileBroker::compile_method(mh, bci, level, mh, hot_count, CompileTask::Reason_Tiered, THREAD);\n@@ -813,1 +814,1 @@\n-void TieredThresholdPolicy::create_mdo(const methodHandle& mh, JavaThread* THREAD) {\n+void TieredThresholdPolicy::create_mdo(const methodHandle& mh, Thread* THREAD) {\n@@ -994,1 +995,1 @@\n-CompLevel TieredThresholdPolicy::call_event(const methodHandle& method, CompLevel cur_level, JavaThread* thread) {\n+CompLevel TieredThresholdPolicy::call_event(const methodHandle& method, CompLevel cur_level, Thread* thread) {\n@@ -1015,1 +1016,1 @@\n-CompLevel TieredThresholdPolicy::loop_event(const methodHandle& method, CompLevel cur_level, JavaThread* thread) {\n+CompLevel TieredThresholdPolicy::loop_event(const methodHandle& method, CompLevel cur_level, Thread* thread) {\n@@ -1028,1 +1029,1 @@\n-bool TieredThresholdPolicy::maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, JavaThread* thread) {\n+bool TieredThresholdPolicy::maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, Thread* thread) {\n@@ -1050,1 +1051,1 @@\n-                                                      CompLevel level, CompiledMethod* nm, JavaThread* thread) {\n+                                                      CompLevel level, CompiledMethod* nm, TRAPS) {\n@@ -1052,1 +1053,1 @@\n-    create_mdo(mh, thread);\n+    create_mdo(mh, THREAD);\n@@ -1054,1 +1055,1 @@\n-  CompLevel next_level = call_event(mh, level, thread);\n+  CompLevel next_level = call_event(mh, level, THREAD);\n@@ -1056,1 +1057,1 @@\n-    if (maybe_switch_to_aot(mh, level, next_level, thread)) {\n+    if (maybe_switch_to_aot(mh, level, next_level, THREAD)) {\n@@ -1061,1 +1062,1 @@\n-      compile(mh, InvocationEntryBci, next_level, thread);\n+      compile(mh, InvocationEntryBci, next_level, THREAD);\n@@ -1069,1 +1070,1 @@\n-                                                     int bci, CompLevel level, CompiledMethod* nm, JavaThread* thread) {\n+                                                     int bci, CompLevel level, CompiledMethod* nm, TRAPS) {\n@@ -1071,1 +1072,1 @@\n-    create_mdo(mh, thread);\n+    create_mdo(mh, THREAD);\n@@ -1075,1 +1076,1 @@\n-    create_mdo(imh, thread);\n+    create_mdo(imh, THREAD);\n@@ -1079,1 +1080,1 @@\n-    CompLevel next_osr_level = loop_event(imh, level, thread);\n+    CompLevel next_osr_level = loop_event(imh, level, THREAD);\n@@ -1083,1 +1084,1 @@\n-      compile(imh, bci, next_osr_level, thread);\n+      compile(imh, bci, next_osr_level, CHECK);\n@@ -1094,1 +1095,1 @@\n-          compile(mh, InvocationEntryBci, enclosing_level, thread);\n+          compile(mh, InvocationEntryBci, enclosing_level, THREAD);\n@@ -1100,1 +1101,1 @@\n-        next_level = call_event(mh, cur_level, thread);\n+        next_level = call_event(mh, cur_level, THREAD);\n@@ -1129,2 +1130,2 @@\n-          if (!maybe_switch_to_aot(mh, cur_level, next_level, thread) && !CompileBroker::compilation_is_in_queue(mh)) {\n-            compile(mh, InvocationEntryBci, next_level, thread);\n+          if (!maybe_switch_to_aot(mh, cur_level, next_level, THREAD) && !CompileBroker::compilation_is_in_queue(mh)) {\n+            compile(mh, InvocationEntryBci, next_level, THREAD);\n@@ -1136,1 +1137,1 @@\n-      next_level = call_event(mh, cur_level, thread);\n+      next_level = call_event(mh, cur_level, THREAD);\n@@ -1138,2 +1139,2 @@\n-        if (!maybe_switch_to_aot(mh, cur_level, next_level, thread) && !CompileBroker::compilation_is_in_queue(mh)) {\n-          compile(mh, InvocationEntryBci, next_level, thread);\n+        if (!maybe_switch_to_aot(mh, cur_level, next_level, THREAD) && !CompileBroker::compilation_is_in_queue(mh)) {\n+          compile(mh, InvocationEntryBci, next_level, THREAD);\n","filename":"src\/hotspot\/share\/compiler\/tieredThresholdPolicy.cpp","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  CompLevel call_event(const methodHandle& method, CompLevel cur_level, JavaThread* thread);\n+  CompLevel call_event(const methodHandle& method, CompLevel cur_level, Thread* thread);\n@@ -193,1 +193,1 @@\n-  CompLevel loop_event(const methodHandle& method, CompLevel cur_level, JavaThread* thread);\n+  CompLevel loop_event(const methodHandle& method, CompLevel cur_level, Thread* thread);\n@@ -216,1 +216,1 @@\n-  void create_mdo(const methodHandle& mh, JavaThread* thread);\n+  void create_mdo(const methodHandle& mh, Thread* thread);\n@@ -222,1 +222,1 @@\n-  bool maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, JavaThread* thread);\n+  bool maybe_switch_to_aot(const methodHandle& mh, CompLevel cur_level, CompLevel next_level, Thread* thread);\n@@ -232,1 +232,1 @@\n-  void compile(const methodHandle& mh, int bci, CompLevel level, JavaThread* thread);\n+  void compile(const methodHandle& mh, int bci, CompLevel level, TRAPS);\n@@ -247,1 +247,1 @@\n-                               CompLevel level, CompiledMethod* nm, JavaThread* thread);\n+                               CompLevel level, CompiledMethod* nm, TRAPS);\n@@ -249,1 +249,1 @@\n-                                int bci, CompLevel level, CompiledMethod* nm, JavaThread* thread);\n+                                int bci, CompLevel level, CompiledMethod* nm, TRAPS);\n@@ -269,1 +269,1 @@\n-                         int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread);\n+                         int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/tieredThresholdPolicy.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+        \/\/ Only metaspace OOM is expected. No Java code executed.\n@@ -978,0 +979,1 @@\n+  \/\/ frequency_counter_overflow_inner can throw async exception.\n@@ -1019,3 +1021,0 @@\n-  if (HAS_PENDING_EXCEPTION) {\n-    return NULL;\n-  }\n@@ -1032,2 +1031,1 @@\n-  nmethod* osr_nm = CompilationPolicy::policy()->event(method, method, branch_bci, bci, CompLevel_none, NULL, thread);\n-  assert(!HAS_PENDING_EXCEPTION, \"Event handler should not throw any exceptions\");\n+  nmethod* osr_nm = CompilationPolicy::policy()->event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n@@ -1074,3 +1072,0 @@\n-  if (HAS_PENDING_EXCEPTION) {\n-    return;\n-  }\n@@ -1087,0 +1082,1 @@\n+    \/\/ Only metaspace OOM is expected. No Java code executed.\n@@ -1146,0 +1142,1 @@\n+    \/\/ Only metaspace OOM is expected. No Java code executed.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -255,1 +255,0 @@\n-\n@@ -261,4 +260,1 @@\n-\n-    assert(!HAS_PENDING_EXCEPTION, \"Should not have any exceptions pending\");\n-    CompilationPolicy::policy()->event(emh, mh, InvocationEntryBci, InvocationEntryBci, CompLevel_aot, cm, thread);\n-    assert(!HAS_PENDING_EXCEPTION, \"Event handler should not throw any exceptions\");\n+    CompilationPolicy::policy()->event(emh, mh, InvocationEntryBci, InvocationEntryBci, CompLevel_aot, cm, THREAD);\n@@ -284,3 +280,1 @@\n-    assert(!HAS_PENDING_EXCEPTION, \"Should not have any exceptions pending\");\n-    nmethod* osr_nm = CompilationPolicy::policy()->event(emh, mh, branch_bci, target_bci, CompLevel_aot, cm, thread);\n-    assert(!HAS_PENDING_EXCEPTION, \"Event handler should not throw any exceptions\");\n+    nmethod* osr_nm = CompilationPolicy::policy()->event(emh, mh, branch_bci, target_bci, CompLevel_aot, cm, THREAD);\n","filename":"src\/hotspot\/share\/jvmci\/compilerRuntime.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, mh, hot_count, CompileTask::Reason_Bootstrap, THREAD);\n+      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, mh, hot_count, CompileTask::Reason_Bootstrap, CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-\/\/ If there is a pending exception upon closing the scope and the runtime\n+\/\/ If there is a pending nonasync exception upon closing the scope and the runtime\n@@ -82,1 +82,1 @@\n-\/\/   1. The pending exception is cleared\n+\/\/   1. The pending nonasync exception is cleared\n@@ -104,1 +104,2 @@\n-        CLEAR_PENDING_EXCEPTION;\n+        \/\/ Do not clear probable async exceptions.\n+        CLEAR_PENDING_NONASYNC_EXCEPTION;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-  nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh->invocation_count(), CompileTask::Reason_Whitebox, THREAD);\n+  nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh->invocation_count(), CompileTask::Reason_Whitebox, CHECK_false);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,2 +531,2 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0 && exec_mode != Unpack_uncommon_trap) {\n-    assert(thread->has_pending_exception(), \"should have thrown OOME\");\n+  if ((thread->has_pending_exception() || thread->frames_to_pop_failed_realloc() > 0) && exec_mode != Unpack_uncommon_trap) {\n+    assert(thread->has_pending_exception(), \"should have thrown OOME\/Async\");\n@@ -1660,0 +1660,1 @@\n+      \/\/ Only metaspace OOM is expected. No Java code executed.\n@@ -1678,1 +1679,17 @@\n-    Klass* tk = constant_pool->klass_at_ignore_error(index, CHECK);\n+    Klass* tk = constant_pool->klass_at_ignore_error(index, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ Exception happened during classloading. We ignore the exception here, since it\n+      \/\/ is going to be rethrown since the current activation is going to be deoptimized and\n+      \/\/ the interpreter will re-execute the bytecode.\n+      \/\/ Do not clear probable Async Exceptions.\n+      CLEAR_PENDING_NONASYNC_EXCEPTION;\n+      \/\/ Class loading called java code which may have caused a stack\n+      \/\/ overflow. If the exception was thrown right before the return\n+      \/\/ to the runtime the stack is no longer guarded. Reguard the\n+      \/\/ stack otherwise if we return to the uncommon trap blob and the\n+      \/\/ stack bang causes a stack overflow we crash.\n+      JavaThread* jt = THREAD->as_Java_thread();\n+      bool guard_pages_enabled = jt->stack_guards_enabled();\n+      if (!guard_pages_enabled) guard_pages_enabled = jt->reguard_stack();\n+      assert(guard_pages_enabled, \"stack banging in uncommon trap blob may cause crash\");\n+    }\n@@ -1686,21 +1703,0 @@\n-\n-void Deoptimization::load_class_by_index(const constantPoolHandle& constant_pool, int index) {\n-  EXCEPTION_MARK;\n-  load_class_by_index(constant_pool, index, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ Exception happened during classloading. We ignore the exception here, since it\n-    \/\/ is going to be rethrown since the current activation is going to be deoptimized and\n-    \/\/ the interpreter will re-execute the bytecode.\n-    CLEAR_PENDING_EXCEPTION;\n-    \/\/ Class loading called java code which may have caused a stack\n-    \/\/ overflow. If the exception was thrown right before the return\n-    \/\/ to the runtime the stack is no longer guarded. Reguard the\n-    \/\/ stack otherwise if we return to the uncommon trap blob and the\n-    \/\/ stack bang causes a stack overflow we crash.\n-    JavaThread* thread = THREAD->as_Java_thread();\n-    bool guard_pages_enabled = thread->stack_guards_enabled();\n-    if (!guard_pages_enabled) guard_pages_enabled = thread->reguard_stack();\n-    assert(guard_pages_enabled, \"stack banging in uncommon trap blob may cause crash\");\n-  }\n-}\n-\n@@ -1968,1 +1964,1 @@\n-      load_class_by_index(constants, unloaded_class_index);\n+      load_class_by_index(constants, unloaded_class_index, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -454,1 +454,0 @@\n-  static void load_class_by_index(const constantPoolHandle& constant_pool, int index);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2330,2 +2330,0 @@\n-  \/\/ May be we are at method entry and requires to save do not unlock flag.\n-  UnlockFlagSaver fs(this);\n@@ -2394,0 +2392,2 @@\n+    \/\/ We may be at method entry which requires we save the do-not-unlock flag.\n+    UnlockFlagSaver fs(this);\n@@ -2398,1 +2398,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in an unsafe memory access operation\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+      return;\n@@ -2403,1 +2404,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in an unsafe memory access operation\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+      return;\n@@ -2408,1 +2410,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      return;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -72,0 +72,10 @@\n+\n+void ThreadShadow::clear_pending_nonasync_exception() {\n+  \/\/ Do not clear probable async exceptions.\n+  if (!_pending_exception->is_a(SystemDictionary::ThreadDeath_klass()) &&\n+      (_pending_exception->klass() != SystemDictionary::InternalError_klass() ||\n+       java_lang_InternalError::during_unsafe_access(_pending_exception) != JNI_TRUE)) {\n+    clear_pending_exception();\n+  }\n+}\n+\n@@ -243,0 +253,6 @@\n+void Exceptions::throw_unsafe_access_internal_error(Thread* thread, const char* file, int line, const char* message) {\n+  Handle h_exception = new_exception(thread, vmSymbols::java_lang_InternalError(), message);\n+  java_lang_InternalError::set_during_unsafe_access(h_exception());\n+  _throw(thread, file, line, h_exception, message);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -94,0 +94,3 @@\n+  \/\/ use CLEAR_PENDING_NONASYNC_EXCEPTION to clear probable nonasync exception.\n+  void clear_pending_nonasync_exception();\n+\n@@ -173,0 +176,2 @@\n+  static void throw_unsafe_access_internal_error(Thread* thread, const char* file, int line, const char* message);\n+\n@@ -229,0 +234,1 @@\n+\/\/ CAUTION: These macros clears all exceptions including async exceptions, use it with caution.\n@@ -236,0 +242,10 @@\n+\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError and j.l.ThreadDeath.\n+\/\/ So use it with caution.\n+#define CLEAR_PENDING_NONASYNC_EXCEPTION        (((ThreadShadow*)THREAD)->clear_pending_nonasync_exception())\n+#define CHECK_AND_CLEAR_NONASYNC                THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_NONASYNC_EXCEPTION; return; } (void)(0\n+#define CHECK_AND_CLEAR_NONASYNC_(result)       THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_NONASYNC_EXCEPTION; return result; } (void)(0\n+#define CHECK_AND_CLEAR_NONASYNC_0              CHECK_AND_CLEAR_NONASYNC_(0)\n+#define CHECK_AND_CLEAR_NONASYNC_NH             CHECK_AND_CLEAR_NONASYNC_(Handle())\n+#define CHECK_AND_CLEAR_NONASYNC_NULL           CHECK_AND_CLEAR_NONASYNC_(NULL)\n+#define CHECK_AND_CLEAR_NONASYNC_false          CHECK_AND_CLEAR_NONASYNC_(false)\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}