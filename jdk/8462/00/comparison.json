{"files":[{"patch":"@@ -676,0 +676,3 @@\n+     *\n+     * @implNote The data in {@code src} may be modified during the decryption\n+     * process.\n@@ -713,0 +716,3 @@\n+     *\n+     * @implNote The data in {@code src} may be modified during the decryption\n+     * process\n@@ -801,0 +807,3 @@\n+     *\n+     * @implNote The data in {@code src} may be modified during the decryption\n+     * process\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLEngine.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,10 @@\n+import sun.security.ssl.Authenticator.MAC;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n@@ -44,11 +54,11 @@\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.Cipher;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.NoSuchPaddingException;\n-import javax.crypto.SecretKey;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.GCMParameterSpec;\n-import javax.crypto.spec.IvParameterSpec;\n-import sun.security.ssl.Authenticator.MAC;\n-import static sun.security.ssl.CipherType.*;\n-import static sun.security.ssl.JsseJce.*;\n+\n+import static sun.security.ssl.CipherType.AEAD_CIPHER;\n+import static sun.security.ssl.CipherType.BLOCK_CIPHER;\n+import static sun.security.ssl.CipherType.NULL_CIPHER;\n+import static sun.security.ssl.CipherType.STREAM_CIPHER;\n+import static sun.security.ssl.JsseJce.CIPHER_3DES;\n+import static sun.security.ssl.JsseJce.CIPHER_AES;\n+import static sun.security.ssl.JsseJce.CIPHER_AES_GCM;\n+import static sun.security.ssl.JsseJce.CIPHER_CHACHA20_POLY1305;\n+import static sun.security.ssl.JsseJce.CIPHER_DES;\n+import static sun.security.ssl.JsseJce.CIPHER_RC4;\n@@ -884,2 +894,12 @@\n-                int pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                int pos;\n+                ByteBuffer pt;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(bb.remaining());\n+                    pos = 0;\n+                }\n+\n@@ -887,1 +907,1 @@\n-                    if (len != cipher.update(dup, bb)) {\n+                    if (len != cipher.update(bb, pt)) {\n@@ -892,4 +912,0 @@\n-                    if (bb.position() != dup.position()) {\n-                        throw new RuntimeException(\n-                                \"Unexpected ByteBuffer position\");\n-                    }\n@@ -901,1 +917,1 @@\n-                bb.position(pos);\n+                pt.position(pos);\n@@ -904,1 +920,1 @@\n-                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                            \"Plaintext after DECRYPTION\", pt.duplicate());\n@@ -909,1 +925,1 @@\n-                    checkStreamMac(signer, bb, contentType, sequence);\n+                    checkStreamMac(signer, pt, contentType, sequence);\n@@ -916,1 +932,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -1062,1 +1078,1 @@\n-                    if (!sanityCheck(tagLen, bb.remaining())) {\n+                    if (!sanityCheck(tagLen, cipheredLength)) {\n@@ -1068,3 +1084,12 @@\n-                int len = bb.remaining();\n-                int pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(cipheredLength);\n+                    pos = 0;\n+                }\n+\n@@ -1072,1 +1097,1 @@\n-                    if (len != cipher.update(dup, bb)) {\n+                    if (cipheredLength != cipher.update(bb, pt)) {\n@@ -1077,5 +1102,0 @@\n-\n-                    if (bb.position() != dup.position()) {\n-                        throw new RuntimeException(\n-                                \"Unexpected ByteBuffer position\");\n-                    }\n@@ -1091,1 +1111,1 @@\n-                            bb.duplicate().position(pos));\n+                            pt.duplicate().position(pos));\n@@ -1095,2 +1115,1 @@\n-                int blockSize = cipher.getBlockSize();\n-                bb.position(pos);\n+                pt.position(pos);\n@@ -1098,1 +1117,2 @@\n-                    removePadding(bb, tagLen, blockSize, protocolVersion);\n+                    removePadding(pt, tagLen, cipher.getBlockSize(),\n+                        protocolVersion);\n@@ -1109,1 +1129,1 @@\n-                        checkCBCMac(signer, bb,\n+                        checkCBCMac(signer, pt,\n@@ -1127,1 +1147,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -1333,1 +1353,1 @@\n-                    if (!sanityCheck(tagLen, bb.remaining())) {\n+                    if (!sanityCheck(tagLen, cipheredLength)) {\n@@ -1340,3 +1360,12 @@\n-                int len = bb.remaining();\n-                int pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(cipheredLength);\n+                    pos = 0;\n+                }\n+\n@@ -1344,1 +1373,1 @@\n-                    if (len != cipher.update(dup, bb)) {\n+                    if (cipheredLength != cipher.update(bb, pt)) {\n@@ -1349,5 +1378,0 @@\n-\n-                    if (bb.position() != dup.position()) {\n-                        throw new RuntimeException(\n-                                \"Unexpected ByteBuffer position\");\n-                    }\n@@ -1361,3 +1385,2 @@\n-                    SSLLogger.fine(\n-                            \"Padded plaintext after DECRYPTION\",\n-                            bb.duplicate().position(pos));\n+                    SSLLogger.fine(\"Padded plaintext after DECRYPTION\",\n+                        pt.duplicate().position(pos));\n@@ -1367,2 +1390,3 @@\n-                bb.position(pos + cipher.getBlockSize());\n-                pos = bb.position();\n+                int blockSize = cipher.getBlockSize();\n+                pos += blockSize;\n+                pt.position(pos);\n@@ -1371,2 +1395,0 @@\n-                int blockSize = cipher.getBlockSize();\n-                bb.position(pos);\n@@ -1374,1 +1396,1 @@\n-                    removePadding(bb, tagLen, blockSize, protocolVersion);\n+                    removePadding(pt, tagLen, blockSize, protocolVersion);\n@@ -1385,1 +1407,1 @@\n-                        checkCBCMac(signer, bb,\n+                        checkCBCMac(signer, pt,\n@@ -1403,1 +1425,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -1658,2 +1680,12 @@\n-                int len, pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int len, pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(bb.remaining());\n+                    pos = 0;\n+                }\n+\n@@ -1661,1 +1693,1 @@\n-                    len = cipher.doFinal(dup, bb);\n+                    len = cipher.doFinal(bb, pt);\n@@ -1673,2 +1705,2 @@\n-                bb.position(pos);\n-                bb.limit(pos + len);\n+                pt.position(pos);\n+                pt.limit(pos + len);\n@@ -1678,1 +1710,1 @@\n-                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                            \"Plaintext after DECRYPTION\", pt.duplicate());\n@@ -1683,1 +1715,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -1925,1 +1957,0 @@\n-\n@@ -1932,2 +1963,12 @@\n-                int len, pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int len, pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(bb.remaining());\n+                    pos = 0;\n+                }\n+\n@@ -1935,1 +1976,1 @@\n-                    len = cipher.doFinal(dup, bb);\n+                    len = cipher.doFinal(bb, pt);\n@@ -1947,2 +1988,2 @@\n-                bb.position(pos);\n-                bb.limit(pos + len);\n+                pt.position(pos);\n+                pt.limit(pos + len);\n@@ -1951,4 +1992,3 @@\n-                int i = bb.limit() - 1;\n-                for (; i > 0 && bb.get(i) == 0; i--) {\n-                    \/\/ blank\n-                }\n+                int i = pt.limit() - 1;\n+                for (; i > 0 && pt.get(i) == 0; i--);\n+\n@@ -1959,2 +1999,2 @@\n-                contentType = bb.get(i);\n-                bb.limit(i);\n+                contentType = pt.get(i);\n+                pt.limit(i);\n@@ -1964,1 +2004,1 @@\n-                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                            \"Plaintext after DECRYPTION\", pt.duplicate());\n@@ -1972,1 +2012,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -2206,3 +2246,12 @@\n-                int len;\n-                int pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int len, pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(bb.remaining());\n+                    pos = 0;\n+                }\n+\n@@ -2210,1 +2259,1 @@\n-                    len = cipher.doFinal(dup, bb);\n+                    len = cipher.doFinal(bb, pt);\n@@ -2222,2 +2271,2 @@\n-                bb.position(pos);\n-                bb.limit(pos + len);\n+                pt.position(pos);\n+                pt.limit(pos + len);\n@@ -2227,1 +2276,1 @@\n-                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                            \"Plaintext after DECRYPTION\", pt.duplicate());\n@@ -2232,1 +2281,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n@@ -2476,3 +2525,12 @@\n-                int len;\n-                int pos = bb.position();\n-                ByteBuffer dup = bb.duplicate();\n+                ByteBuffer pt;\n+                int len, pos;\n+\n+                \/\/ Do in-place with the bb buffer if it's not read-only\n+                if (!bb.isReadOnly()) {\n+                    pt = bb.duplicate();\n+                    pos = bb.position();\n+                } else {\n+                    pt = ByteBuffer.allocate(bb.remaining());\n+                    pos = 0;\n+                }\n+\n@@ -2480,1 +2538,1 @@\n-                    len = cipher.doFinal(dup, bb);\n+                    len = cipher.doFinal(bb, pt);\n@@ -2492,2 +2550,2 @@\n-                bb.position(pos);\n-                bb.limit(pos + len);\n+                pt.position(pos);\n+                pt.limit(pos + len);\n@@ -2496,2 +2554,2 @@\n-                int i = bb.limit() - 1;\n-                for (; i > 0 && bb.get(i) == 0; i--) {\n+                int i = pt.limit() - 1;\n+                for (; i > 0 && pt.get(i) == 0; i--) {\n@@ -2504,2 +2562,2 @@\n-                contentType = bb.get(i);\n-                bb.limit(i);\n+                contentType = pt.get(i);\n+                pt.limit(i);\n@@ -2509,1 +2567,1 @@\n-                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                            \"Plaintext after DECRYPTION\", pt.duplicate());\n@@ -2514,1 +2572,1 @@\n-                        -1, -1L, bb.slice());\n+                        -1, -1L, pt.slice());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":158,"deletions":100,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8283577\n+ * @summary Test SSLEngine to use read-only input bytebuffers\n+ * @run main\/othervm ReadOnlyEngine\n+ *\/\n+\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.io.FileInputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ReadOnlyEngine {\n+\n+    private static String pathToStores = \"..\/etc\";\n+    private static String keyStoreFile = \"keystore\";\n+    private static String trustStoreFile = \"truststore\";\n+    private static char[] passwd = \"passphrase\".toCharArray();\n+\n+    private static String keyFilename =\n+        System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            \"\/\" + keyStoreFile;\n+    private static String trustFilename =\n+        System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+            \"\/\" + trustStoreFile;\n+\n+    SSLEngine server;\n+    SSLEngine client;\n+    final static ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+    HandshakeStatus doHandshake(SSLEngine engine, ByteBuffer src,\n+        ByteBuffer dst) {\n+        HandshakeStatus status;\n+        status = engine.getHandshakeStatus();\n+        while (status != SSLEngineResult.HandshakeStatus.FINISHED &&\n+            status != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            dst.clear();\n+            switch (status) {\n+                case NEED_UNWRAP:\n+                    try {\n+                        return receive(engine, src, dst);\n+                    } catch (SSLException e) {\n+                        e.printStackTrace();\n+                    }\n+                    break;\n+                case NEED_WRAP:\n+                    try {\n+                        return send(engine, src, dst);\n+                    } catch (SSLException e) {\n+                        e.printStackTrace();\n+                    }\n+                    break;\n+                case NEED_TASK:\n+                    Runnable task;\n+                    while ((task = engine.getDelegatedTask()) != null) {\n+                        executor.execute(task);\n+                    }\n+                    status = engine.getHandshakeStatus();\n+                    break;\n+                case FINISHED:\n+                    break;\n+                case NOT_HANDSHAKING:\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Invalid SSL status: \" +\n+                        status);\n+            }\n+        }\n+        return status;\n+    }\n+\n+    HandshakeStatus send(SSLEngine engine, ByteBuffer src, ByteBuffer dst)\n+        throws SSLException {\n+        SSLEngineResult status = engine.wrap(src, dst);\n+        dst.flip();\n+        return status.getHandshakeStatus();\n+    }\n+\n+    HandshakeStatus receive(SSLEngine engine, ByteBuffer src, ByteBuffer dst)\n+        throws SSLException {\n+        SSLEngineResult status = engine.unwrap(src, dst);\n+        dst.flip();\n+        return status.getHandshakeStatus();\n+    }\n+\n+    ReadOnlyEngine(SSLContext sslc, String ciphersuite) throws Exception {\n+        System.err.println(\"==== Test Protocol: \" + sslc.getProtocol() +\n+            \", CipherSuite: \" + ciphersuite);\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n+\n+        ks.load(new FileInputStream(keyFilename), passwd);\n+        ts.load(new FileInputStream(trustFilename), passwd);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passwd);\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        sslc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        client = sslc.createSSLEngine(\"client\", 1);\n+        client.setUseClientMode(true);\n+        server = sslc.createSSLEngine(\"server\", 2);\n+        if (ciphersuite != null) {\n+            server.setEnabledCipherSuites(new String[] { ciphersuite });\n+        }\n+        server.setUseClientMode(false);\n+\n+        SSLSession session = server.getSession();\n+        int maxData = session.getPacketBufferSize();\n+\n+        ByteBuffer in = ByteBuffer.allocate(maxData);\n+        ByteBuffer out = ByteBuffer.allocate(maxData);\n+\n+        HandshakeStatus statusClient, statusServer;\n+        client.beginHandshake();\n+        server.beginHandshake();\n+\n+        \/\/ Do TLS handshake\n+        do {\n+            statusClient = doHandshake(client, out, in);\n+            statusServer = doHandshake(server, in, out);\n+        } while (statusClient != HandshakeStatus.NOT_HANDSHAKING ||\n+            statusServer != HandshakeStatus.NOT_HANDSHAKING);\n+\n+        \/\/ Read NST\n+        in.clear();\n+        receive(client, out, in);\n+\n+        System.out.println(\"done\");\n+\n+        \/\/ Send bytes from the client and make sure the server receives the same\n+        in.clear();\n+        out.clear();\n+        String testString = \"ASDF\";\n+        in.put(testString.getBytes()).flip();\n+        String testResult;\n+        System.out.println(\"1: Client send: \" + testString);\n+        send(client, in.asReadOnlyBuffer(), out);\n+        in.clear();\n+        receive(server, out.asReadOnlyBuffer(), in);\n+        testResult = StandardCharsets.UTF_8.decode(in.duplicate()).toString();\n+        System.out.println(\"1: Server receive: \" + testResult);\n+        if (!testString.equalsIgnoreCase(testResult)) {\n+            throw new Exception(\"unequal\");\n+        }\n+\n+        \/\/ Send bytes from the server and make sure the client receives the same\n+        out.clear();\n+        in.clear();\n+        System.out.println(\"2: Server send: \" + testString);\n+        in.put(testString.getBytes()).flip();\n+        send(server, in, out);\n+        in.clear();\n+        receive(client, out, in);\n+        testResult = StandardCharsets.UTF_8.decode(in.duplicate()).toString();\n+        System.out.println(\"2: Client receive: \" + testResult);\n+        if (!testString.equalsIgnoreCase(testResult)) {\n+            throw new Exception(\"not equal\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1.3\"),\n+            \"TLS_AES_256_GCM_SHA384\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1.3\"),\n+            \"TLS_CHACHA20_POLY1305_SHA256\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1.2\"),\n+            \"TLS_RSA_WITH_AES_128_GCM_SHA256\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1.2\"),\n+            \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1.1\"),\n+            \"TLS_RSA_WITH_AES_128_CBC_SHA\");\n+        new ReadOnlyEngine(SSLContext.getInstance(\"TLSv1\"),\n+            \"TLS_RSA_WITH_AES_128_CBC_SHA\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/ReadOnlyEngine.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}