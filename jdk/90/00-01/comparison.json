{"files":[{"patch":"@@ -233,1 +233,1 @@\n-void G1ParScanThreadState::start_partial_objArray(G1HeapRegionAttr dest_attr,\n+void G1ParScanThreadState::start_partial_objarray(G1HeapRegionAttr dest_attr,\n@@ -488,1 +488,1 @@\n-        start_partial_objArray(dest_attr, old, obj);\n+        start_partial_objarray(dest_attr, old, obj);\n@@ -498,1 +498,1 @@\n-    if (G1StringDedup::is_enabled() && (klass == SystemDictionary::String_klass())) {\n+    if (G1StringDedup::is_enabled()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  inline void start_partial_objArray(G1HeapRegionAttr dest_dir, oop from, oop to);\n+  inline void start_partial_objarray(G1HeapRegionAttr dest_dir, oop from, oop to);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,5 +46,0 @@\n-  \/\/ Limit on the number of partial array tasks to create for a given array.\n-  uint _task_limit;\n-  \/\/ Maximum number of new tasks to create when processing an existing task.\n-  uint _task_fannout;\n-\n@@ -63,1 +58,1 @@\n-  inline Step start(arrayOop from, arrayOop to, int chunk_size);\n+  inline Step start(arrayOop from, arrayOop to, int chunk_size) const;\n@@ -69,1 +64,16 @@\n-  inline Step next(arrayOop from, arrayOop to, int chunk_size);\n+  inline Step next(arrayOop from, arrayOop to, int chunk_size) const;\n+\n+  class TestSupport;            \/\/ For unit tests\n+\n+private:\n+  \/\/ Limit on the number of partial array tasks to create for a given array.\n+  uint _task_limit;\n+  \/\/ Maximum number of new tasks to create when processing an existing task.\n+  uint _task_fannout;\n+\n+  \/\/ Split start\/next into public part dealing with oops and private\n+  \/\/ impl dealing with lengths and pointers to lengths, for unit testing.\n+  \/\/ length is the actual length obtained from the from-space object.\n+  \/\/ to_length_addr is the address of the to-space object's length value.\n+  inline Step start_impl(int length, int* to_length_addr, int chunk_size) const;\n+  inline Step next_impl(int length, int* to_length_addr, int chunk_size) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n-PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) {\n+PartialArrayTaskStepper::start_impl(int length,\n+                                    int* to_length_addr,\n+                                    int chunk_size) const {\n@@ -36,1 +38,0 @@\n-  int length = from->length();\n@@ -47,1 +48,1 @@\n-  to->set_length(end);\n+  *to_length_addr = end;\n@@ -57,1 +58,8 @@\n-PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) {\n+PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) const {\n+  return start_impl(from->length(), to->length_addr(), chunk_size);\n+}\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::next_impl(int length,\n+                                   int* to_length_addr,\n+                                   int chunk_size) const {\n@@ -65,1 +73,1 @@\n-  int start = Atomic::fetch_and_add(to->length_addr(),\n+  int start = Atomic::fetch_and_add(to_length_addr,\n@@ -69,2 +77,0 @@\n-  \/\/ The from-space object contains the real length.\n-  int length = from->length();\n@@ -106,0 +112,5 @@\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) const {\n+  return next_impl(from->length(), to->length_addr(), chunk_size);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+  \/\/ Returns the address of the length \"field\".  See length_offset_in_bytes().\n+  static int* length_addr_impl(void* obj_ptr) {\n+    char* ptr = static_cast<char*>(obj_ptr);\n+    return reinterpret_cast<int*>(ptr + length_offset_in_bytes());\n+  }\n+\n@@ -105,4 +111,4 @@\n-  \/\/ Accessors for instance variable which is not a C++ declared nonstatic\n-  \/\/ field.\n-  int length() const { return *length_addr(); }\n-  void set_length(int length) { *length_addr() = length; }\n+  \/\/ Accessors for array length.  There's not a member variable for\n+  \/\/ it; see length_offset_in_bytes().\n+  int length() const { return *length_addr_impl(const_cast<arrayOopDesc*>(this)); }\n+  void set_length(int length) { *length_addr_impl(this) = length; }\n@@ -111,7 +117,1 @@\n-    char* base = reinterpret_cast<char*>(this);\n-    char* addr = base +  length_offset_in_bytes();\n-    return reinterpret_cast<int*>(addr);\n-  }\n-\n-  const int* length_addr() const {\n-    return const_cast<arrayOopDesc*>(this)->length_addr();\n+    return length_addr_impl(this);\n@@ -121,1 +121,1 @@\n-    *(int*)(((char*)mem) + length_offset_in_bytes()) = length;\n+    *length_addr_impl(mem) = length;\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"unittest.hpp\"\n+\n+using Step = PartialArrayTaskStepper::Step;\n+using Stepper = PartialArrayTaskStepper;\n+\n+class PartialArrayTaskStepper::TestSupport : AllStatic {\n+public:\n+  static Step start(const Stepper* stepper,\n+                    int length,\n+                    int* to_length_addr,\n+                    uint chunk_size) {\n+    return stepper->start_impl(length, to_length_addr, chunk_size);\n+  }\n+\n+  static Step next(const Stepper* stepper,\n+                   int length,\n+                   int* to_length_addr,\n+                   uint chunk_size) {\n+    return stepper->next_impl(length, to_length_addr, chunk_size);\n+  }\n+};\n+\n+using StepperSupport = PartialArrayTaskStepper::TestSupport;\n+\n+static int simulate(const Stepper* stepper,\n+                     int length,\n+                     int* to_length_addr,\n+                     uint chunk_size) {\n+  Step init = StepperSupport::start(stepper, length, to_length_addr, chunk_size);\n+  uint queue_count = init._ncreate;\n+  int task = 0;\n+  for ( ; queue_count > 0; ++task) {\n+    --queue_count;\n+    Step step = StepperSupport::next(stepper, length, to_length_addr, chunk_size);\n+    queue_count += step._ncreate;\n+  }\n+  return task;\n+}\n+\n+static void run_test(int length, int chunk_size, uint n_workers) {\n+  const PartialArrayTaskStepper stepper(n_workers);\n+  int to_length;\n+  int tasks = simulate(&stepper, length, &to_length, chunk_size);\n+  ASSERT_EQ(length, to_length);\n+  ASSERT_EQ(tasks, length \/ chunk_size);\n+}\n+\n+TEST(PartialArrayTaskStepperTest, doit) {\n+  for (int chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n+    for (uint n_workers = 1; n_workers <= 256; n_workers = (n_workers * 3 \/ 2 + 1)) {\n+      for (int length = 0; length <= 1000000; length = (length * 2 + 1)) {\n+        run_test(length, chunk_size, n_workers);\n+      }\n+      \/\/ Ensure we hit boundary cases for length % chunk_size == 0.\n+      for (uint i = 0; i < 2 * n_workers; ++i) {\n+        run_test(i * chunk_size, chunk_size, n_workers);\n+      }\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}