{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -43,0 +46,1 @@\n+                                           uint n_workers,\n@@ -63,0 +67,2 @@\n+    _partial_objarray_chunk_size(ParGCArrayScanChunk),\n+    _partial_array_stepper(n_workers),\n@@ -202,4 +208,0 @@\n-  objArrayOop from_obj_array = objArrayOop(from_obj);\n-  \/\/ The from-space object contains the real length.\n-  int length                 = from_obj_array->length();\n-\n@@ -207,1 +209,2 @@\n-  oop to_obj                 = from_obj->forwardee();\n+\n+  oop to_obj = from_obj->forwardee();\n@@ -209,16 +212,8 @@\n-  objArrayOop to_obj_array   = objArrayOop(to_obj);\n-  \/\/ We keep track of the next start index in the length field of the\n-  \/\/ to-space object.\n-  int next_index             = to_obj_array->length();\n-  assert(0 <= next_index && next_index < length,\n-         \"invariant, next index: %d, length: %d\", next_index, length);\n-\n-  int start                  = next_index;\n-  int end                    = length;\n-  int remainder              = end - start;\n-  \/\/ We'll try not to push a range that's smaller than ParGCArrayScanChunk.\n-  if (remainder > 2 * ParGCArrayScanChunk) {\n-    end = start + ParGCArrayScanChunk;\n-    to_obj_array->set_length(end);\n-    \/\/ Push the remainder before we process the range in case another\n-    \/\/ worker has run out of things to do and can steal it.\n+  assert(to_obj->is_objArray(), \"must be obj array\");\n+  objArrayOop to_array = objArrayOop(to_obj);\n+\n+  PartialArrayTaskStepper::Step step\n+    = _partial_array_stepper.next(objArrayOop(from_obj),\n+                                  to_array,\n+                                  _partial_objarray_chunk_size);\n+  for (uint i = 0; i < step._ncreate; ++i) {\n@@ -226,5 +221,0 @@\n-  } else {\n-    assert(length == end, \"sanity\");\n-    \/\/ We'll process the final range for this object. Restore the length\n-    \/\/ so that the heap remains parsable in case of evacuation failure.\n-    to_obj_array->set_length(end);\n@@ -233,1 +223,1 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(to_obj);\n+  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n@@ -235,9 +225,36 @@\n-  \/\/ Process indexes [start,end). It will also process the header\n-  \/\/ along with the first chunk (i.e., the chunk with start == 0).\n-  \/\/ Note that at this point the length field of to_obj_array is not\n-  \/\/ correct given that we are using it to keep track of the next\n-  \/\/ start index. oop_iterate_range() (thankfully!) ignores the length\n-  \/\/ field and only relies on the start \/ end parameters.  It does\n-  \/\/ however return the size of the object which will be incorrect. So\n-  \/\/ we have to ignore it even if we wanted to use it.\n-  to_obj_array->oop_iterate_range(&_scanner, start, end);\n+  \/\/ Process claimed task.  The length of to_array is not correct, but\n+  \/\/ fortunately the iteration ignores the length field and just relies\n+  \/\/ on start\/end.\n+  to_array->oop_iterate_range(&_scanner,\n+                              step._index,\n+                              step._index + _partial_objarray_chunk_size);\n+}\n+\n+void G1ParScanThreadState::start_partial_objArray(G1HeapRegionAttr dest_attr,\n+                                                  oop from_obj,\n+                                                  oop to_obj) {\n+  assert(from_obj->is_objArray(), \"precondition\");\n+  assert(from_obj->is_forwarded(), \"precondition\");\n+  assert(from_obj->forwardee() == to_obj, \"precondition\");\n+  assert(from_obj != to_obj, \"should not be scanning self-forwarded objects\");\n+  assert(to_obj->is_objArray(), \"precondition\");\n+\n+  objArrayOop to_array = objArrayOop(to_obj);\n+\n+  PartialArrayTaskStepper::Step step\n+    = _partial_array_stepper.start(objArrayOop(from_obj),\n+                                   to_array,\n+                                   _partial_objarray_chunk_size);\n+\n+  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n+  \/\/ intitial chunk to allow other workers to steal while we're processing.\n+  for (uint i = 0; i < step._ncreate; ++i) {\n+    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  }\n+\n+  G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+  \/\/ Process the initial chunk.  No need to process the type in the\n+  \/\/ klass, as it will already be handled by processing the built-in\n+  \/\/ module. The length of to_array is not correct, but fortunately\n+  \/\/ the iteration ignores that length field and relies on start\/end.\n+  to_array->oop_iterate_range(&_scanner, 0, step._index);\n@@ -397,1 +414,4 @@\n-  const size_t word_sz = old->size();\n+  \/\/ Get the klass once.  We'll need it again later, and this avoids\n+  \/\/ re-decoding when it's compressed.\n+  Klass* klass = old->klass();\n+  const size_t word_sz = old->size_given_klass(klass);\n@@ -464,1 +484,15 @@\n-    if (G1StringDedup::is_enabled()) {\n+    \/\/ Most objects are not arrays, so do one array check rather than\n+    \/\/ checking for each array category for each object.\n+    if (klass->is_array_klass()) {\n+      if (klass->is_objArray_klass()) {\n+        start_partial_objArray(dest_attr, old, obj);\n+      } else {\n+        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n+        \/\/ any oops to scan, and the type in the klass will already be handled\n+        \/\/ by processing the built-in module.\n+        assert(klass->is_typeArray_klass(), \"invariant\");\n+      }\n+      return obj;\n+    }\n+\n+    if (G1StringDedup::is_enabled() && (klass == SystemDictionary::String_klass())) {\n@@ -477,10 +511,2 @@\n-    if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {\n-      \/\/ We keep track of the next start index in the length field of\n-      \/\/ the to-space object. The actual length can be found in the\n-      \/\/ length field of the from-space object.\n-      arrayOop(obj)->set_length(0);\n-      do_partial_array(PartialArrayScanTask(old));\n-    } else {\n-      G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n-      obj->oop_iterate_backwards(&_scanner);\n-    }\n+    G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+    obj->oop_iterate_backwards(&_scanner);\n@@ -488,0 +514,1 @@\n+\n@@ -506,1 +533,3 @@\n-      new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);\n+      new G1ParScanThreadState(_g1h, _rdcqs,\n+                               worker_id, _n_workers,\n+                               _young_cset_length, _optional_cset_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":78,"deletions":49,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -82,0 +83,3 @@\n+  \/\/ Size (in elements) of a partial objArray task chunk.\n+  int _partial_objarray_chunk_size;\n+  PartialArrayTaskStepper _partial_array_stepper;\n@@ -108,0 +112,1 @@\n+                       uint n_workers,\n@@ -160,0 +165,1 @@\n+  inline void start_partial_objArray(G1HeapRegionAttr dest_dir, oop from, oop to);\n@@ -252,3 +258,0 @@\n-\n- private:\n-  G1ParScanThreadState* new_par_scan_state(uint worker_id, size_t young_cset_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static uint compute_task_limit(uint n_workers) {\n+  \/\/ Don't need more than n_workers tasks at a time.  But allowing up to\n+  \/\/ that maximizes available parallelism.\n+  return n_workers;\n+}\n+\n+static uint compute_task_fannout(uint task_limit) {\n+  assert(task_limit > 0, \"precondition\");\n+  \/\/ There is a tradeoff between providing parallelism more quickly and\n+  \/\/ number of enqueued tasks.  A constant fannout may be too slow when\n+  \/\/ parallelism (and so task_limit) is large.  A constant fraction might\n+  \/\/ be overly eager.  Using log2 attempts to balance between those.\n+  uint result = log2_uint(task_limit);\n+  \/\/ result must be > 0.  result should be > 1 if task_limit > 1, to\n+  \/\/ provide some potentially parallel tasks.  But don't just +1 to\n+  \/\/ avoid otherwise increasing rate of task generation.\n+  if (result < 2) ++result;\n+  return result;\n+}\n+\n+PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers) :\n+  _task_limit(compute_task_limit(n_workers)),\n+  _task_fannout(compute_task_fannout(_task_limit))\n+{}\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n+\n+#include \"oops\/arrayOop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Helper for handling PartialArrayTasks.\n+\/\/\n+\/\/ When an array is large, we want to split it up into chunks that can be\n+\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.\n+\/\/ We can enqueue multiple tasks at the same time.  We want to enqueue\n+\/\/ enough tasks to benefit from the available parallelism, while not so many\n+\/\/ as to substantially expand the task queues.\n+\/\/\n+\/\/ A task directly refers to the from-space array.  The from-space array's\n+\/\/ forwarding pointer refers to the associated to-space array, and its\n+\/\/ length is the actual length. The to-space array's length field is used to\n+\/\/ indicate processing progress.  It is the starting index of the next chunk\n+\/\/ to process, or equals the actual length when there are no more chunks to\n+\/\/ be processed.\n+class PartialArrayTaskStepper {\n+  \/\/ Limit on the number of partial array tasks to create for a given array.\n+  uint _task_limit;\n+  \/\/ Maximum number of new tasks to create when processing an existing task.\n+  uint _task_fannout;\n+\n+public:\n+  PartialArrayTaskStepper(uint n_workers);\n+\n+  struct Step {\n+    int _index;                 \/\/ Array index for the step.\n+    uint _ncreate;              \/\/ Number of new tasks to create.\n+  };\n+\n+  \/\/ Set to's length to the end of the initial chunk, which is the start of\n+  \/\/ the first partial task if the array is large enough to need splitting.\n+  \/\/ Returns a Step with _index being that index and _ncreate being the\n+  \/\/ initial number of partial tasks to enqueue.\n+  inline Step start(arrayOop from, arrayOop to, int chunk_size);\n+\n+  \/\/ Increment to's length by chunk_size to claim the next chunk.  Returns a\n+  \/\/ Step with _index being the starting index of the claimed chunk and\n+  \/\/ _ncreate being the number of additional partial tasks to enqueue.\n+  \/\/ precondition: chunk_size must be the same as used to start the task sequence.\n+  inline Step next(arrayOop from, arrayOop to, int chunk_size);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) {\n+  assert(chunk_size > 0, \"precondition\");\n+\n+  int length = from->length();\n+  int end = length % chunk_size; \/\/ End of initial chunk.\n+  \/\/ Set to's length to end of initial chunk.  Partial tasks use that length\n+  \/\/ field as the start of the next chunk to process.  Must be done before\n+  \/\/ enqueuing partial scan tasks, in case other threads steal any of those\n+  \/\/ tasks.\n+  \/\/\n+  \/\/ The value of end can be 0, either because of a 0-length array or\n+  \/\/ because length is a multiple of the chunk size.  Both of those are\n+  \/\/ relatively rare and handled in the normal course of the iteration, so\n+  \/\/ not worth doing anything special about here.\n+  to->set_length(end);\n+\n+  \/\/ If the initial chunk is the complete array, then don't need any partial\n+  \/\/ tasks.  Otherwise, start with just one partial task; see new task\n+  \/\/ calculation in next().\n+  Step result = { end, (length > end) ? 1u : 0u };\n+  return result;\n+}\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) {\n+  assert(chunk_size > 0, \"precondition\");\n+\n+  \/\/ The start of the next task is in the length field of the to-space object.\n+  \/\/ Atomically increment by the chunk size to claim the associated chunk.\n+  \/\/ Because we limit the number of enqueued tasks to being no more than the\n+  \/\/ number of remaining chunks to process, we can use an atomic add for the\n+  \/\/ claim, rather than a CAS loop.\n+  int start = Atomic::fetch_and_add(to->length_addr(),\n+                                    chunk_size,\n+                                    memory_order_relaxed);\n+\n+  \/\/ The from-space object contains the real length.\n+  int length = from->length();\n+  assert(start < length, \"invariant: start %d, length %d\", start, length);\n+  assert(((length - start) % chunk_size) == 0,\n+         \"invariant: start %d, length %d, chunk size %d\",\n+         start, length, chunk_size);\n+\n+  \/\/ Determine the number of new tasks to create.\n+  \/\/ Zero-based index for this partial task.  The initial task isn't counted.\n+  uint task_num = (start \/ chunk_size);\n+  \/\/ Number of tasks left to process, including this one.\n+  uint remaining_tasks = (length - start) \/ chunk_size;\n+  assert(remaining_tasks > 0, \"invariant\");\n+  \/\/ Compute number of pending tasks, including this one.  The maximum number\n+  \/\/ of tasks is a function of task_num (N) and _task_fannout (F).\n+  \/\/   1    : current task\n+  \/\/   N    : number of preceeding tasks\n+  \/\/   F*N  : maximum created for preceeding tasks\n+  \/\/ => F*N - N + 1 : maximum number of tasks\n+  \/\/ => (F-1)*N + 1\n+  assert(_task_limit > 0, \"precondition\");\n+  assert(_task_fannout > 0, \"precondition\");\n+  uint max_pending = (_task_fannout - 1) * task_num + 1;\n+\n+  \/\/ The actual pending may be less than that.  Bound by remaining_tasks to\n+  \/\/ not overrun.  Also bound by _task_limit to avoid spawning an excessive\n+  \/\/ number of tasks for a large array.  The +1 is to replace the current\n+  \/\/ task with a new task when _task_limit limited.  The pending value may\n+  \/\/ not be what's actually in the queues, because of concurrent task\n+  \/\/ processing.  That's okay; we just need to determine the correct number\n+  \/\/ of tasks to add for this task.\n+  uint pending = MIN3(max_pending, remaining_tasks, _task_limit);\n+  uint ncreate = MIN2(_task_fannout, MIN2(remaining_tasks, _task_limit + 1) - pending);\n+  Step result = { start, ncreate };\n+  return result;\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,7 @@\n-  int length() const {\n-    return *(int*)(((intptr_t)this) + length_offset_in_bytes());\n+  int length() const { return *length_addr(); }\n+  void set_length(int length) { *length_addr() = length; }\n+\n+  int* length_addr() {\n+    char* base = reinterpret_cast<char*>(this);\n+    char* addr = base +  length_offset_in_bytes();\n+    return reinterpret_cast<int*>(addr);\n@@ -110,2 +115,3 @@\n-  void set_length(int length) {\n-    set_length((HeapWord*)this, length);\n+\n+  const int* length_addr() const {\n+    return const_cast<arrayOopDesc*>(this)->length_addr();\n@@ -113,0 +119,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  friend class G1ParScanPartialArrayClosure;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}