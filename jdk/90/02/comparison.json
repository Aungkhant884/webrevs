{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -43,0 +46,1 @@\n+                                           uint n_workers,\n@@ -63,0 +67,2 @@\n+    _partial_objarray_chunk_size(ParGCArrayScanChunk),\n+    _partial_array_stepper(n_workers),\n@@ -202,4 +208,0 @@\n-  objArrayOop from_obj_array = objArrayOop(from_obj);\n-  \/\/ The from-space object contains the real length.\n-  int length                 = from_obj_array->length();\n-\n@@ -207,1 +209,2 @@\n-  oop to_obj                 = from_obj->forwardee();\n+\n+  oop to_obj = from_obj->forwardee();\n@@ -209,16 +212,8 @@\n-  objArrayOop to_obj_array   = objArrayOop(to_obj);\n-  \/\/ We keep track of the next start index in the length field of the\n-  \/\/ to-space object.\n-  int next_index             = to_obj_array->length();\n-  assert(0 <= next_index && next_index < length,\n-         \"invariant, next index: %d, length: %d\", next_index, length);\n-\n-  int start                  = next_index;\n-  int end                    = length;\n-  int remainder              = end - start;\n-  \/\/ We'll try not to push a range that's smaller than ParGCArrayScanChunk.\n-  if (remainder > 2 * ParGCArrayScanChunk) {\n-    end = start + ParGCArrayScanChunk;\n-    to_obj_array->set_length(end);\n-    \/\/ Push the remainder before we process the range in case another\n-    \/\/ worker has run out of things to do and can steal it.\n+  assert(to_obj->is_objArray(), \"must be obj array\");\n+  objArrayOop to_array = objArrayOop(to_obj);\n+\n+  PartialArrayTaskStepper::Step step\n+    = _partial_array_stepper.next(objArrayOop(from_obj),\n+                                  to_array,\n+                                  _partial_objarray_chunk_size);\n+  for (uint i = 0; i < step._ncreate; ++i) {\n@@ -226,5 +221,0 @@\n-  } else {\n-    assert(length == end, \"sanity\");\n-    \/\/ We'll process the final range for this object. Restore the length\n-    \/\/ so that the heap remains parsable in case of evacuation failure.\n-    to_obj_array->set_length(end);\n@@ -233,1 +223,1 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(to_obj);\n+  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n@@ -235,9 +225,36 @@\n-  \/\/ Process indexes [start,end). It will also process the header\n-  \/\/ along with the first chunk (i.e., the chunk with start == 0).\n-  \/\/ Note that at this point the length field of to_obj_array is not\n-  \/\/ correct given that we are using it to keep track of the next\n-  \/\/ start index. oop_iterate_range() (thankfully!) ignores the length\n-  \/\/ field and only relies on the start \/ end parameters.  It does\n-  \/\/ however return the size of the object which will be incorrect. So\n-  \/\/ we have to ignore it even if we wanted to use it.\n-  to_obj_array->oop_iterate_range(&_scanner, start, end);\n+  \/\/ Process claimed task.  The length of to_array is not correct, but\n+  \/\/ fortunately the iteration ignores the length field and just relies\n+  \/\/ on start\/end.\n+  to_array->oop_iterate_range(&_scanner,\n+                              step._index,\n+                              step._index + _partial_objarray_chunk_size);\n+}\n+\n+void G1ParScanThreadState::start_partial_objarray(G1HeapRegionAttr dest_attr,\n+                                                  oop from_obj,\n+                                                  oop to_obj) {\n+  assert(from_obj->is_objArray(), \"precondition\");\n+  assert(from_obj->is_forwarded(), \"precondition\");\n+  assert(from_obj->forwardee() == to_obj, \"precondition\");\n+  assert(from_obj != to_obj, \"should not be scanning self-forwarded objects\");\n+  assert(to_obj->is_objArray(), \"precondition\");\n+\n+  objArrayOop to_array = objArrayOop(to_obj);\n+\n+  PartialArrayTaskStepper::Step step\n+    = _partial_array_stepper.start(objArrayOop(from_obj),\n+                                   to_array,\n+                                   _partial_objarray_chunk_size);\n+\n+  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n+  \/\/ intitial chunk to allow other workers to steal while we're processing.\n+  for (uint i = 0; i < step._ncreate; ++i) {\n+    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  }\n+\n+  G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+  \/\/ Process the initial chunk.  No need to process the type in the\n+  \/\/ klass, as it will already be handled by processing the built-in\n+  \/\/ module. The length of to_array is not correct, but fortunately\n+  \/\/ the iteration ignores that length field and relies on start\/end.\n+  to_array->oop_iterate_range(&_scanner, 0, step._index);\n@@ -397,1 +414,4 @@\n-  const size_t word_sz = old->size();\n+  \/\/ Get the klass once.  We'll need it again later, and this avoids\n+  \/\/ re-decoding when it's compressed.\n+  Klass* klass = old->klass();\n+  const size_t word_sz = old->size_given_klass(klass);\n@@ -464,0 +484,14 @@\n+    \/\/ Most objects are not arrays, so do one array check rather than\n+    \/\/ checking for each array category for each object.\n+    if (klass->is_array_klass()) {\n+      if (klass->is_objArray_klass()) {\n+        start_partial_objarray(dest_attr, old, obj);\n+      } else {\n+        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n+        \/\/ any oops to scan, and the type in the klass will already be handled\n+        \/\/ by processing the built-in module.\n+        assert(klass->is_typeArray_klass(), \"invariant\");\n+      }\n+      return obj;\n+    }\n+\n@@ -477,10 +511,2 @@\n-    if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {\n-      \/\/ We keep track of the next start index in the length field of\n-      \/\/ the to-space object. The actual length can be found in the\n-      \/\/ length field of the from-space object.\n-      arrayOop(obj)->set_length(0);\n-      do_partial_array(PartialArrayScanTask(old));\n-    } else {\n-      G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n-      obj->oop_iterate_backwards(&_scanner);\n-    }\n+    G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+    obj->oop_iterate_backwards(&_scanner);\n@@ -488,0 +514,1 @@\n+\n@@ -506,1 +533,3 @@\n-      new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);\n+      new G1ParScanThreadState(_g1h, _rdcqs,\n+                               worker_id, _n_workers,\n+                               _young_cset_length, _optional_cset_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":77,"deletions":48,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -82,0 +83,3 @@\n+  \/\/ Size (in elements) of a partial objArray task chunk.\n+  int _partial_objarray_chunk_size;\n+  PartialArrayTaskStepper _partial_array_stepper;\n@@ -108,0 +112,1 @@\n+                       uint n_workers,\n@@ -160,0 +165,1 @@\n+  inline void start_partial_objarray(G1HeapRegionAttr dest_dir, oop from, oop to);\n@@ -252,3 +258,0 @@\n-\n- private:\n-  G1ParScanThreadState* new_par_scan_state(uint worker_id, size_t young_cset_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static uint compute_task_limit(uint n_workers) {\n+  \/\/ Don't need more than n_workers tasks at a time.  But allowing up to\n+  \/\/ that maximizes available parallelism.\n+  return n_workers;\n+}\n+\n+static uint compute_task_fanout(uint task_limit) {\n+  assert(task_limit > 0, \"precondition\");\n+  \/\/ There is a tradeoff between providing parallelism more quickly and\n+  \/\/ number of enqueued tasks.  A constant fanout may be too slow when\n+  \/\/ parallelism (and so task_limit) is large.  A constant fraction might\n+  \/\/ be overly eager.  Using log2 attempts to balance between those.\n+  uint result = log2_uint(task_limit);\n+  \/\/ result must be > 0.  result should be > 1 if task_limit > 1, to\n+  \/\/ provide some potentially parallel tasks.  But don't just +1 to\n+  \/\/ avoid otherwise increasing rate of task generation.\n+  if (result < 2) ++result;\n+  return result;\n+}\n+\n+PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers) :\n+  _task_limit(compute_task_limit(n_workers)),\n+  _task_fanout(compute_task_fanout(_task_limit))\n+{}\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n+\n+#include \"oops\/arrayOop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Helper for handling PartialArrayTasks.\n+\/\/\n+\/\/ When an array is large, we want to split it up into chunks that can be\n+\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.\n+\/\/ We can enqueue multiple tasks at the same time.  We want to enqueue\n+\/\/ enough tasks to benefit from the available parallelism, while not so many\n+\/\/ as to substantially expand the task queues.\n+\/\/\n+\/\/ A task directly refers to the from-space array.  The from-space array's\n+\/\/ forwarding pointer refers to the associated to-space array, and its\n+\/\/ length is the actual length. The to-space array's length field is used to\n+\/\/ indicate processing progress.  It is the starting index of the next chunk\n+\/\/ to process, or equals the actual length when there are no more chunks to\n+\/\/ be processed.\n+class PartialArrayTaskStepper {\n+public:\n+  PartialArrayTaskStepper(uint n_workers);\n+\n+  struct Step {\n+    int _index;                 \/\/ Array index for the step.\n+    uint _ncreate;              \/\/ Number of new tasks to create.\n+  };\n+\n+  \/\/ Set to's length to the end of the initial chunk, which is the start of\n+  \/\/ the first partial task if the array is large enough to need splitting.\n+  \/\/ Returns a Step with _index being that index and _ncreate being the\n+  \/\/ initial number of partial tasks to enqueue.\n+  inline Step start(arrayOop from, arrayOop to, int chunk_size) const;\n+\n+  \/\/ Increment to's length by chunk_size to claim the next chunk.  Returns a\n+  \/\/ Step with _index being the starting index of the claimed chunk and\n+  \/\/ _ncreate being the number of additional partial tasks to enqueue.\n+  \/\/ precondition: chunk_size must be the same as used to start the task sequence.\n+  inline Step next(arrayOop from, arrayOop to, int chunk_size) const;\n+\n+  class TestSupport;            \/\/ For unit tests\n+\n+private:\n+  \/\/ Limit on the number of partial array tasks to create for a given array.\n+  uint _task_limit;\n+  \/\/ Maximum number of new tasks to create when processing an existing task.\n+  uint _task_fanout;\n+\n+  \/\/ Split start\/next into public part dealing with oops and private\n+  \/\/ impl dealing with lengths and pointers to lengths, for unit testing.\n+  \/\/ length is the actual length obtained from the from-space object.\n+  \/\/ to_length_addr is the address of the to-space object's length value.\n+  inline Step start_impl(int length, int* to_length_addr, int chunk_size) const;\n+  inline Step next_impl(int length, int* to_length_addr, int chunk_size) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/arrayOop.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::start_impl(int length,\n+                                    int* to_length_addr,\n+                                    int chunk_size) const {\n+  assert(chunk_size > 0, \"precondition\");\n+\n+  int end = length % chunk_size; \/\/ End of initial chunk.\n+  \/\/ Set to's length to end of initial chunk.  Partial tasks use that length\n+  \/\/ field as the start of the next chunk to process.  Must be done before\n+  \/\/ enqueuing partial scan tasks, in case other threads steal any of those\n+  \/\/ tasks.\n+  \/\/\n+  \/\/ The value of end can be 0, either because of a 0-length array or\n+  \/\/ because length is a multiple of the chunk size.  Both of those are\n+  \/\/ relatively rare and handled in the normal course of the iteration, so\n+  \/\/ not worth doing anything special about here.\n+  *to_length_addr = end;\n+\n+  \/\/ If the initial chunk is the complete array, then don't need any partial\n+  \/\/ tasks.  Otherwise, start with just one partial task; see new task\n+  \/\/ calculation in next().\n+  Step result = { end, (length > end) ? 1u : 0u };\n+  return result;\n+}\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) const {\n+  return start_impl(from->length(), to->length_addr(), chunk_size);\n+}\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::next_impl(int length,\n+                                   int* to_length_addr,\n+                                   int chunk_size) const {\n+  assert(chunk_size > 0, \"precondition\");\n+\n+  \/\/ The start of the next task is in the length field of the to-space object.\n+  \/\/ Atomically increment by the chunk size to claim the associated chunk.\n+  \/\/ Because we limit the number of enqueued tasks to being no more than the\n+  \/\/ number of remaining chunks to process, we can use an atomic add for the\n+  \/\/ claim, rather than a CAS loop.\n+  int start = Atomic::fetch_and_add(to_length_addr,\n+                                    chunk_size,\n+                                    memory_order_relaxed);\n+\n+  assert(start < length, \"invariant: start %d, length %d\", start, length);\n+  assert(((length - start) % chunk_size) == 0,\n+         \"invariant: start %d, length %d, chunk size %d\",\n+         start, length, chunk_size);\n+\n+  \/\/ Determine the number of new tasks to create.\n+  \/\/ Zero-based index for this partial task.  The initial task isn't counted.\n+  uint task_num = (start \/ chunk_size);\n+  \/\/ Number of tasks left to process, including this one.\n+  uint remaining_tasks = (length - start) \/ chunk_size;\n+  assert(remaining_tasks > 0, \"invariant\");\n+  \/\/ Compute number of pending tasks, including this one.  The maximum number\n+  \/\/ of tasks is a function of task_num (N) and _task_fanout (F).\n+  \/\/   1    : current task\n+  \/\/   N    : number of preceeding tasks\n+  \/\/   F*N  : maximum created for preceeding tasks\n+  \/\/ => F*N - N + 1 : maximum number of tasks\n+  \/\/ => (F-1)*N + 1\n+  assert(_task_limit > 0, \"precondition\");\n+  assert(_task_fanout > 0, \"precondition\");\n+  uint max_pending = (_task_fanout - 1) * task_num + 1;\n+\n+  \/\/ The actual pending may be less than that.  Bound by remaining_tasks to\n+  \/\/ not overrun.  Also bound by _task_limit to avoid spawning an excessive\n+  \/\/ number of tasks for a large array.  The +1 is to replace the current\n+  \/\/ task with a new task when _task_limit limited.  The pending value may\n+  \/\/ not be what's actually in the queues, because of concurrent task\n+  \/\/ processing.  That's okay; we just need to determine the correct number\n+  \/\/ of tasks to add for this task.\n+  uint pending = MIN3(max_pending, remaining_tasks, _task_limit);\n+  uint ncreate = MIN2(_task_fanout, MIN2(remaining_tasks, _task_limit + 1) - pending);\n+  Step result = { start, ncreate };\n+  return result;\n+}\n+\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) const {\n+  return next_impl(from->length(), to->length_addr(), chunk_size);\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTEPPER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,6 @@\n+  \/\/ Returns the address of the length \"field\".  See length_offset_in_bytes().\n+  static int* length_addr_impl(void* obj_ptr) {\n+    char* ptr = static_cast<char*>(obj_ptr);\n+    return reinterpret_cast<int*>(ptr + length_offset_in_bytes());\n+  }\n+\n@@ -105,7 +111,7 @@\n-  \/\/ Accessors for instance variable which is not a C++ declared nonstatic\n-  \/\/ field.\n-  int length() const {\n-    return *(int*)(((intptr_t)this) + length_offset_in_bytes());\n-  }\n-  void set_length(int length) {\n-    set_length((HeapWord*)this, length);\n+  \/\/ Accessors for array length.  There's not a member variable for\n+  \/\/ it; see length_offset_in_bytes().\n+  int length() const { return *length_addr_impl(const_cast<arrayOopDesc*>(this)); }\n+  void set_length(int length) { *length_addr_impl(this) = length; }\n+\n+  int* length_addr() {\n+    return length_addr_impl(this);\n@@ -113,0 +119,1 @@\n+\n@@ -114,1 +121,1 @@\n-    *(int*)(((char*)mem) + length_offset_in_bytes()) = length;\n+    *length_addr_impl(mem) = length;\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  friend class G1ParScanPartialArrayClosure;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"unittest.hpp\"\n+\n+using Step = PartialArrayTaskStepper::Step;\n+using Stepper = PartialArrayTaskStepper;\n+\n+class PartialArrayTaskStepper::TestSupport : AllStatic {\n+public:\n+  static Step start(const Stepper* stepper,\n+                    int length,\n+                    int* to_length_addr,\n+                    uint chunk_size) {\n+    return stepper->start_impl(length, to_length_addr, chunk_size);\n+  }\n+\n+  static Step next(const Stepper* stepper,\n+                   int length,\n+                   int* to_length_addr,\n+                   uint chunk_size) {\n+    return stepper->next_impl(length, to_length_addr, chunk_size);\n+  }\n+};\n+\n+using StepperSupport = PartialArrayTaskStepper::TestSupport;\n+\n+static int simulate(const Stepper* stepper,\n+                    int length,\n+                    int* to_length_addr,\n+                    uint chunk_size) {\n+  Step init = StepperSupport::start(stepper, length, to_length_addr, chunk_size);\n+  uint queue_count = init._ncreate;\n+  int task = 0;\n+  for ( ; queue_count > 0; ++task) {\n+    --queue_count;\n+    Step step = StepperSupport::next(stepper, length, to_length_addr, chunk_size);\n+    queue_count += step._ncreate;\n+  }\n+  return task;\n+}\n+\n+static void run_test(int length, int chunk_size, uint n_workers) {\n+  const PartialArrayTaskStepper stepper(n_workers);\n+  int to_length;\n+  int tasks = simulate(&stepper, length, &to_length, chunk_size);\n+  ASSERT_EQ(length, to_length);\n+  ASSERT_EQ(tasks, length \/ chunk_size);\n+}\n+\n+TEST(PartialArrayTaskStepperTest, doit) {\n+  for (int chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n+    for (uint n_workers = 1; n_workers <= 256; n_workers = (n_workers * 3 \/ 2 + 1)) {\n+      for (int length = 0; length <= 1000000; length = (length * 2 + 1)) {\n+        run_test(length, chunk_size, n_workers);\n+      }\n+      \/\/ Ensure we hit boundary cases for length % chunk_size == 0.\n+      for (uint i = 0; i < 2 * n_workers; ++i) {\n+        run_test(i * chunk_size, chunk_size, n_workers);\n+      }\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}