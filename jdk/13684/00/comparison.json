{"files":[{"patch":"@@ -1233,4 +1233,4 @@\n-  INSN(vfcvt_xu_f_v, 0b1010111, 0b001, 0b00000, 0b010010);\n-  INSN(vfcvt_x_f_v,  0b1010111, 0b001, 0b00001, 0b010010);\n-  INSN(vfcvt_f_xu_v, 0b1010111, 0b001, 0b00010, 0b010010);\n-  INSN(vfcvt_f_x_v,  0b1010111, 0b001, 0b00011, 0b010010);\n+  INSN(vfcvt_xu_f_v,     0b1010111, 0b001, 0b00000, 0b010010);\n+  INSN(vfcvt_x_f_v,      0b1010111, 0b001, 0b00001, 0b010010);\n+  INSN(vfcvt_f_xu_v,     0b1010111, 0b001, 0b00010, 0b010010);\n+  INSN(vfcvt_f_x_v,      0b1010111, 0b001, 0b00011, 0b010010);\n@@ -1240,0 +1240,19 @@\n+  \/\/ Vector Widening Floating-Point\/Integer Type-Convert Instructions\n+  INSN(vfwcvt_xu_f_v,     0b1010111, 0b001, 0b01000, 0b010010);\n+  INSN(vfwcvt_x_f_v,      0b1010111, 0b001, 0b01001, 0b010010);\n+  INSN(vfwcvt_f_xu_v,     0b1010111, 0b001, 0b01010, 0b010010);\n+  INSN(vfwcvt_f_x_v,      0b1010111, 0b001, 0b01011, 0b010010);\n+  INSN(vfwcvt_f_f_v,      0b1010111, 0b001, 0b01100, 0b010010);\n+  INSN(vfwcvt_rtz_xu_f_v, 0b1010111, 0b001, 0b01110, 0b010010);\n+  INSN(vfwcvt_rtz_x_f_v,  0b1010111, 0b001, 0b01111, 0b010010);\n+\n+  \/\/ Vector Narrowing Floating-Point\/Integer Type-Convert Instructions\n+  INSN(vfncvt_xu_f_w,     0b1010111, 0b001, 0b10000, 0b010010);\n+  INSN(vfncvt_x_f_w,      0b1010111, 0b001, 0b10001, 0b010010);\n+  INSN(vfncvt_f_xu_w,     0b1010111, 0b001, 0b10010, 0b010010);\n+  INSN(vfncvt_f_x_w,      0b1010111, 0b001, 0b10011, 0b010010);\n+  INSN(vfncvt_f_f_w,      0b1010111, 0b001, 0b10100, 0b010010);\n+  INSN(vfncvt_rod_f_f_w,  0b1010111, 0b001, 0b10101, 0b010010);\n+  INSN(vfncvt_rtz_xu_f_w, 0b1010111, 0b001, 0b10110, 0b010010);\n+  INSN(vfncvt_rtz_x_f_w,  0b1010111, 0b001, 0b10111, 0b010010);\n+\n@@ -1434,0 +1453,4 @@\n+  \/\/ Vector Register Gather Instructions\n+  INSN(vrgather_vv,     0b1010111, 0b000, 0b001100);\n+  INSN(vrgatherei16_vv, 0b1010111, 0b000, 0b001110);\n+\n@@ -1489,0 +1512,3 @@\n+  \/\/ Vector Register Gather Instructions\n+  INSN(vrgather_vx, 0b1010111, 0b100, 0b001100);\n+\n@@ -1553,0 +1579,3 @@\n+  \/\/ Vector Register Gather Instructions\n+  INSN(vrgather_vi, 0b1010111, 0b011, 0b001100);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-  \/\/ Check vector elements of src1 and src2 for quiet or signaling NaN.\n+  \/\/ Check vector elements of src1 and src2 for quiet and signaling NaN.\n@@ -1785,0 +1785,75 @@\n+}\n+\n+void C2_MacroAssembler::vector_integer_extend(VectorRegister dst, BasicType dst_bt,\n+                                              VectorRegister src, BasicType src_bt) {\n+  assert(type2aelembytes(dst_bt) > type2aelembytes(src_bt) && type2aelembytes(dst_bt) <= 8 && type2aelembytes(src_bt) <= 4, \"invalid element size\");\n+  assert(dst_bt != T_FLOAT && dst_bt != T_DOUBLE && src_bt != T_FLOAT && src_bt != T_DOUBLE, \"should be integer element\");\n+  \/\/ https:\/\/github.com\/riscv\/riscv-v-spec\/blob\/master\/v-spec.adoc#52-vector-operands\n+  \/\/ The destination EEW is greater than the source EEW, the source EMUL is at least 1,\n+  \/\/ and the overlap is in the highest-numbered part of the destination register group.\n+  \/\/ Since LMUL=1, vd and vs cannot be the same.\n+  assert_different_registers(dst, src);\n+\n+  Assembler::SEW sew = Assembler::elemtype_to_sew(dst_bt);\n+  vsetvli(t0, x0, sew);\n+  if (src_bt == T_BYTE) {\n+    switch (dst_bt) {\n+    case T_SHORT:\n+      vsext_vf2(dst, src);\n+      break;\n+    case T_INT:\n+      vsext_vf4(dst, src);\n+      break;\n+    case T_LONG:\n+      vsext_vf8(dst, src);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+  } else if (src_bt == T_SHORT) {\n+    if (dst_bt == T_INT) {\n+      vsext_vf2(dst, src);\n+    } else {\n+      vsext_vf4(dst, src);\n+    }\n+  } else if (src_bt == T_INT) {\n+    vsext_vf2(dst, src);\n+  }\n+}\n+\n+\/\/ Vector narrow from src to dst with specified element sizes.\n+\/\/ High part of dst vector will be filled with zero.\n+void C2_MacroAssembler::vector_integer_narrow(VectorRegister dst, BasicType dst_bt, int length_in_bytes,\n+                                              VectorRegister src, BasicType src_bt, VectorRegister tmp) {\n+  assert(type2aelembytes(dst_bt) < type2aelembytes(src_bt) && type2aelembytes(dst_bt) <= 4 && type2aelembytes(src_bt) <= 8, \"invalid element size\");\n+  assert(dst_bt != T_FLOAT && dst_bt != T_DOUBLE && src_bt != T_FLOAT && src_bt != T_DOUBLE, \"should be integer element\");\n+  assert_different_registers(dst, tmp);\n+  vmv1r_v(tmp, src);\n+  mv(t0, length_in_bytes);\n+  if (src_bt == T_LONG) {\n+    \/\/ https:\/\/github.com\/riscv\/riscv-v-spec\/blob\/master\/v-spec.adoc#117-vector-narrowing-integer-right-shift-instructions\n+    \/\/ Future extensions might add support for versions that narrow to a destination that is 1\/4 the width of the source.\n+    \/\/ So we can currently only scale down by 1\/2 the width at a time.\n+    vsetvli(t0, t0, Assembler::e32, Assembler::mf2);\n+    vncvt_x_x_w(tmp, tmp);\n+    if (dst_bt == T_SHORT || dst_bt == T_BYTE) {\n+      vsetvli(t0, t0, Assembler::e16, Assembler::mf2);\n+      vncvt_x_x_w(tmp, tmp);\n+      if (dst_bt == T_BYTE) {\n+        vsetvli(t0, t0, Assembler::e8, Assembler::mf2);\n+        vncvt_x_x_w(tmp, tmp);\n+      }\n+    }\n+  } else if (src_bt == T_INT) {\n+      \/\/ T_SHORT\n+      vsetvli(t0, t0, Assembler::e16, Assembler::mf2);\n+      vncvt_x_x_w(tmp, tmp);\n+      if (dst_bt == T_BYTE) {\n+        vsetvli(t0, t0, Assembler::e8, Assembler::mf2);\n+        vncvt_x_x_w(tmp, tmp);\n+      }\n+  } else if (src_bt == T_SHORT) {\n+    vsetvli(t0, t0, Assembler::e8, Assembler::mf2);\n+    vncvt_x_x_w(tmp, tmp);\n+  }\n+  vmv_v_v(dst, tmp);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -233,0 +233,6 @@\n+  void vector_integer_extend(VectorRegister dst, BasicType dst_bt,\n+                             VectorRegister src, BasicType src_bt);\n+\n+  void vector_integer_narrow(VectorRegister dst, BasicType dst_bt, int length_in_bytes,\n+                             VectorRegister src, BasicType src_bt, VectorRegister tmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1947,0 +1947,2 @@\n+    case Op_MaskAll:\n+    case Op_VectorReinterpret:\n@@ -2033,1 +2035,4 @@\n-  if (bt == T_BOOLEAN) {\n+  if (bt == T_BYTE) {\n+    \/\/ To support vector api shuffle\/rearrange.\n+    size = 4;\n+  } else if (bt == T_BOOLEAN) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,7 +73,0 @@\n-      case Op_VectorCast:\n-      case Op_VectorCastB2X:\n-      case Op_VectorCastD2X:\n-      case Op_VectorCastF2X:\n-      case Op_VectorCastI2X:\n-      case Op_VectorCastL2X:\n-      case Op_VectorCastS2X:\n@@ -81,3 +74,0 @@\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-      case Op_VectorReinterpret:\n@@ -2053,36 +2043,1 @@\n-instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"vmv.v.x $dst, $cnt\\t#@vshiftcntB\" %}\n-  ins_encode %{\n-    __ rvv_vsetvli(T_BYTE, Matcher::vector_length_in_bytes(this));\n-    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_SHORT ||\n-            Matcher::vector_element_basic_type(n) == T_CHAR);\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"vmv.v.x $dst, $cnt\\t#@vshiftcntS\" %}\n-  ins_encode %{\n-    __ rvv_vsetvli(T_SHORT, Matcher::vector_length_in_bytes(this));\n-    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"vmv.v.x $dst, $cnt\\t#@vshiftcntI\" %}\n-  ins_encode %{\n-    __ rvv_vsetvli(T_INT, Matcher::vector_length_in_bytes(this));\n-    __ vmv_v_x(as_VectorRegister($dst$$reg), as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ vector shift count\n@@ -2090,2 +2045,1 @@\n-instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+instruct vshiftcnt(vReg dst, iRegIorL2I cnt) %{\n@@ -2094,1 +2048,1 @@\n-  format %{ \"vmv.v.x $dst, $cnt\\t#@vshiftcntL\" %}\n+  format %{ \"vshiftcnt $dst, $cnt\" %}\n@@ -2096,1 +2050,2 @@\n-    __ rvv_vsetvli(T_LONG, Matcher::vector_length_in_bytes(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ rvv_vsetvli(bt, Matcher::vector_length_in_bytes(this));\n@@ -2572,0 +2527,14 @@\n+instruct vmaskAllI_masked(vRegMask dst, iRegI src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (MaskAll src v0));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmaskAllI_masked $dst, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ rvv_vsetvli(bt, Matcher::vector_length_in_bytes(this));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), as_Register($src$$reg));\n+    __ vmxor_mm(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+    __ vmsne_vx(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), x0, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2601,0 +2570,14 @@\n+instruct vmaskAllL_masked(vRegMask dst, iRegL src, vRegMask_V0 v0, vReg tmp) %{\n+  match(Set dst (MaskAll src v0));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmaskAllL_masked $dst, $src, $v0\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ rvv_vsetvli(bt, Matcher::vector_length_in_bytes(this));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), as_Register($src$$reg));\n+    __ vmxor_mm(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+    __ vmsne_vx(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), x0, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2690,0 +2673,300 @@\n+%}\n+\n+\/\/ ------------------------------ Vector cast ----------------------------------\n+\n+\/\/ VectorCastB2X\n+\n+instruct vcvtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastB2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), bt == T_FLOAT ? T_INT : T_LONG,\n+                               as_VectorRegister($src$$reg), T_BYTE);\n+      __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+    } else {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), bt,\n+                               as_VectorRegister($src$$reg), T_BYTE);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastS2X\n+\n+instruct vcvtStoB(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP_DEF dst,TEMP tmp);\n+  format %{ \"vcvtStoB $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), T_BYTE, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($src$$reg), T_SHORT, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtStoX_extend $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), bt == T_FLOAT ? T_INT : T_LONG,\n+                               as_VectorRegister($src$$reg), T_SHORT);\n+      __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+    } else {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), bt,\n+                               as_VectorRegister($src$$reg), T_SHORT);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastI2X\n+\n+instruct vcvtItoX_narrow(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtItoX_narrow $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), bt, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($src$$reg), T_INT, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_FLOAT) {\n+      __ vsetvli(t0, x0, Assembler::e32);\n+      __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    } else {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), T_LONG,\n+                               as_VectorRegister($src$$reg), T_INT);\n+      if (bt == T_DOUBLE) {\n+        __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastL2X\n+\n+instruct vcvtLtoI(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst,TEMP tmp);\n+  format %{ \"vcvtLtoI $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), bt, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($src$$reg), T_LONG, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst,TEMP tmp);\n+  format %{ \"vcvtLtoF $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), T_INT, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($src$$reg), T_LONG, as_VectorRegister($tmp$$reg));\n+    __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoD $dst, $src\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e64);\n+    __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2X\n+\n+instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst,TEMP tmp);\n+  format %{ \"vcvtFtoX_narrow $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e32);\n+    __ vfcvt_x_f_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), bt, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($dst$$reg), T_INT, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoI(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vcvtFtoX $dst, $src\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e32);\n+    __ vfcvt_x_f_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_LONG) {\n+      __ vector_integer_extend(as_VectorRegister($dst$$reg), T_LONG,\n+                               as_VectorRegister($dst$$reg), T_INT);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtFtoD $dst, $src\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e32, Assembler::mf2);\n+    __ vfwcvt_f_f_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastD2X\n+\n+instruct vcvtDtoI(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst,TEMP tmp);\n+  format %{ \"vcvtDtoI $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e64);\n+    __ vfcvt_x_f_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_integer_narrow(as_VectorRegister($dst$$reg), bt, Matcher::vector_length_in_bytes(this),\n+                             as_VectorRegister($dst$$reg), T_LONG, as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoL $dst, $src\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e64);\n+    __ vfcvt_x_f_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF(vReg dst_src1, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst_src1 (VectorCastD2X dst_src1));\n+  effect(TEMP tmp);\n+  format %{ \"vcvtDtoF $dst_src1\" %}\n+  ins_encode %{\n+    __ vsetvli(t0, x0, Assembler::e32, Assembler::mf2);\n+    __ vfncvt_f_f_w(as_VectorRegister($tmp$$reg), as_VectorRegister($dst_src1$$reg));\n+    __ vmv1r_v(as_VectorRegister($dst_src1$$reg), as_VectorRegister($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpretResize(vReg dst, vReg src) %{\n+  predicate(n->as_Vector()->length_in_bytes() !=\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reinterpretResize $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ rvv_vsetvli(T_BYTE, length_in_bytes_resize);\n+    __ vmv_v_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask reinterpret\n+\n+instruct vmask_reinterpret_same_esize(vRegMask dst_src) %{\n+  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmask_reinterpret_diff_esize(vRegMask dst, vRegMask_V0 src, vReg tmp) %{\n+  predicate(Matcher::vector_length(n) != Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_reinterpret_diff_esize $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n+    __ rvv_vsetvli(from_bt, Matcher::vector_length_in_bytes(this, $src));\n+    __ vmv_v_x(as_VectorRegister($tmp$$reg), x0);\n+    __ vmerge_vim(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), -1);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    __ rvv_vsetvli(to_bt, Matcher::vector_length_in_bytes(this));\n+    __ vmseq_vi(as_VectorRegister($dst$$reg), as_VectorRegister($tmp$$reg), -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -----------------------------\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle) %{\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP_DEF dst);\n+  format %{ \"rearrange $dst, $src, $shuffle\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ rvv_vsetvli(bt, Matcher::vector_length_in_bytes(this));\n+    __ vrgather_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), as_VectorRegister($shuffle$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":333,"deletions":50,"binary":false,"changes":383,"status":"modified"}]}