{"files":[{"patch":"@@ -41,1 +41,0 @@\n-#include \"gc\/shared\/objectMarker.hpp\"\n@@ -659,4 +658,0 @@\n-\n-ObjectMarker* CollectedHeap::init_object_marker() {\n-  return new HeaderObjectMarker();\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-class ObjectMarker;\n-class ObjectMarkerController;\n@@ -101,1 +99,0 @@\n-  friend class ObjectMarkerController;\n@@ -433,2 +430,0 @@\n-  virtual ObjectMarker* init_object_marker();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/objectMarker.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-ObjectMarker* ObjectMarkerController::_marker = NULL;\n-\n-ObjectMarkerController::ObjectMarkerController() {\n-  \/\/ prepare heap for iteration\n-  CollectedHeap* heap = Universe::heap();\n-  heap->ensure_parsability(false);  \/\/ no need to retire TLABs\n-  _marker = heap->init_object_marker();\n-}\n-\n-ObjectMarkerController::~ObjectMarkerController() {\n-  delete _marker;\n-  _marker = NULL;\n-}\n-\n-void ObjectMarkerController::mark(oop o) {\n-  assert(_marker != NULL, \"need object marker\");\n-  _marker->mark(o);\n-}\n-\n-bool ObjectMarkerController::is_marked(oop o) {\n-  assert(_marker != NULL, \"need object marker\");\n-  return _marker->is_marked(o);\n-}\n-\n-void ObjectMarkerController::set_needs_reset(bool needs_reset) {\n-  assert(_marker != NULL, \"need object marker\");\n-  return _marker->set_needs_reset(needs_reset);\n-}\n-\n-class RestoreMarksClosure : public ObjectClosure {\n-public:\n-  void do_object(oop o) {\n-    if (o != NULL) {\n-      markWord mark = o->mark();\n-      if (mark.is_marked()) {\n-        o->init_mark();\n-      }\n-    }\n-  }\n-};\n-\n-HeaderObjectMarker::HeaderObjectMarker() :\n- _saved_oop_stack(new (ResourceObj::C_HEAP, mtGC) GrowableArray<oop>(4000, mtGC)),\n- _saved_mark_stack(new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(4000, mtGC)),\n- _needs_reset(false) {\n-}\n-\n-\/\/ object marking done, so restore headers\n-HeaderObjectMarker::~HeaderObjectMarker() {\n-  \/\/ iterate over all objects and restore the mark bits to\n-  \/\/ their initial value\n-  RestoreMarksClosure blk;\n-  if (_needs_reset) {\n-    Universe::heap()->object_iterate(&blk);\n-  }\n-\n-  \/\/ Now restore the interesting headers\n-  for (int i = 0; i < _saved_oop_stack->length(); i++) {\n-    oop o = _saved_oop_stack->at(i);\n-    markWord mark = _saved_mark_stack->at(i);\n-    o->set_mark(mark);\n-  }\n-\n-  \/\/ free the stacks\n-  delete _saved_oop_stack;\n-  delete _saved_mark_stack;\n-}\n-\n-void HeaderObjectMarker::set_needs_reset(bool needs_reset) {\n-  _needs_reset = needs_reset;\n-}\n-\n-\/\/ mark an object\n-void HeaderObjectMarker::mark(oop o) {\n-  assert(Universe::heap()->is_in(o), \"sanity check\");\n-  assert(!o->mark().is_marked(), \"should only mark an object once\");\n-\n-  \/\/ object's mark word\n-  markWord mark = o->mark();\n-\n-  if (o->mark_must_be_preserved(mark)) {\n-    _saved_mark_stack->push(mark);\n-    _saved_oop_stack->push(o);\n-  }\n-\n-  \/\/ mark the object\n-  o->set_mark(markWord::prototype().set_marked());\n-}\n-\n-\/\/ return true if object is marked\n-bool HeaderObjectMarker::is_marked(oop o) {\n-  return o->mark().is_marked();\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/objectMarker.cpp","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_OBJECTMARKER_HPP\n-#define SHARE_GC_SHARED_OBJECTMARKER_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-\n-\/\/ ObjectMarker is used to support the marking objects when walking the\n-\/\/ heap.\n-class ObjectMarker : public CHeapObj<mtGC>{\n-public:\n-  virtual ~ObjectMarker() {};\n-  virtual void mark(oop o) = 0;\n-  virtual bool is_marked(oop o) = 0;\n-\n-  virtual void set_needs_reset(bool needs_reset) {};\n-};\n-\n-\/\/ Stack allocated class to help ensure that ObjectMarker is used\n-\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n-\/\/ ObjectMarker's done() function to restore object headers.\n-class ObjectMarkerController : public StackObj {\n-private:\n-  static ObjectMarker* _marker;\n-public:\n-  ObjectMarkerController();\n-  ~ObjectMarkerController();\n-\n-  static void mark(oop o);\n-  static bool is_marked(oop o);\n-\n-  static void set_needs_reset(bool needs_reset);\n-};\n-\n-\/\/ ObjectMarker is used to support the marking objects when walking the\n-\/\/ heap.\n-\/\/\n-\/\/ This implementation uses the existing mark bits in an object for\n-\/\/ marking. Objects that are marked must later have their headers restored.\n-\/\/ As most objects are unlocked and don't have their identity hash computed\n-\/\/ we don't have to save their headers. Instead we save the headers that\n-\/\/ are \"interesting\". Later when the headers are restored this implementation\n-\/\/ restores all headers to their initial value and then restores the few\n-\/\/ objects that had interesting headers.\n-\/\/\n-\/\/ Future work: This implementation currently uses growable arrays to save\n-\/\/ the oop and header of interesting objects. As an optimization we could\n-\/\/ use the same technique as the GC and make use of the unused area\n-\/\/ between top() and end().\n-class HeaderObjectMarker : public ObjectMarker {\n-private:\n-  GrowableArray<oop>* _saved_oop_stack;\n-  GrowableArray<markWord>* _saved_mark_stack;\n-  bool _needs_reset;\n-public:\n-  HeaderObjectMarker();\n-  ~HeaderObjectMarker();\n-  void mark(oop o) override;\n-  bool is_marked(oop o) override;\n-  void set_needs_reset(bool needs_reset) override;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_OBJECTMARKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/objectMarker.hpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/objectMarker.hpp\"\n@@ -69,0 +68,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -1335,0 +1335,30 @@\n+\/\/ Stack allocated class to help ensure that ObjectMarker is used\n+\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n+\/\/ ObjectMarker's done() function to restore object headers.\n+class ObjectMarkerController : public StackObj {\n+private:\n+  static BitSet* _bitset;\n+public:\n+  ObjectMarkerController() {\n+    assert(_bitset == NULL, \"don't initialize bitset twice\");\n+    _bitset = new BitSet();\n+  }\n+\n+  ~ObjectMarkerController() {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    delete _bitset;\n+    _bitset = NULL;\n+  }\n+\n+  static void mark(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    _bitset->mark_obj(o);\n+  }\n+\n+  static bool is_marked(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    return _bitset->is_marked(o);\n+  }\n+};\n+\n+BitSet* ObjectMarkerController::_bitset = NULL;\n@@ -2808,3 +2838,0 @@\n-\n-    \/\/ no early return so enable heap traversal to reset its state, if necessary\n-    ObjectMarkerController::set_needs_reset(true);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/bitset.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.cpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n+#ifndef SHARE_UTILITIES_BITSET_HPP\n+#define SHARE_UTILITIES_BITSET_HPP\n@@ -34,1 +34,0 @@\n-class JfrVirtualMemory;\n@@ -117,1 +116,1 @@\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n+#endif \/\/ SHARE_UTILITIES_BITSET_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.hpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n+#ifndef SHARE_UTILITIES_BITSET_INLINE_HPP\n+#define SHARE_UTILITIES_BITSET_INLINE_HPP\n@@ -28,1 +28,1 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.hpp\"\n+#include \"utilities\/bitset.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/storage\/jfrVirtualMemory.hpp\"\n@@ -107,1 +106,1 @@\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n+#endif \/\/ SHARE_UTILITIES_BITSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.inline.hpp","status":"renamed"}]}