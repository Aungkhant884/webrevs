{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -40,1 +40,1 @@\n-BFSClosure::BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet* mark_bits) :\n+BFSClosure::BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet<mtTracing>* mark_bits) :\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+template<MEMFLAGS F>\n@@ -41,1 +42,1 @@\n-  BitSet* _mark_bits;\n+  BitSet<mtTracing>* _mark_bits;\n@@ -68,1 +69,1 @@\n-  BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet* mark_bits);\n+  BFSClosure(EdgeQueue* edge_queue, EdgeStore* edge_store, BitSet<mtTracing>* mark_bits);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-#include \"precompiled.hpp\"\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n-\n-BitSet::BitMapFragment::BitMapFragment(uintptr_t granule, BitMapFragment* next) :\n-    _bits(_bitmap_granularity_size >> LogMinObjAlignmentInBytes, mtTracing, true \/* clear *\/),\n-    _next(next) {\n-}\n-\n-BitSet::BitSet() :\n-    _bitmap_fragments(32),\n-    _fragment_list(NULL),\n-    _last_fragment_bits(NULL),\n-    _last_fragment_granule(UINTPTR_MAX) {\n-}\n-\n-BitSet::~BitSet() {\n-  BitMapFragment* current = _fragment_list;\n-  while (current != NULL) {\n-    BitMapFragment* next = current->next();\n-    delete current;\n-    current = next;\n-  }\n-}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/hashtable.hpp\"\n-\n-class JfrVirtualMemory;\n-class MemRegion;\n-\n-class BitSet : public CHeapObj<mtTracing> {\n-  const static size_t _bitmap_granularity_shift = 26; \/\/ 64M\n-  const static size_t _bitmap_granularity_size = (size_t)1 << _bitmap_granularity_shift;\n-  const static size_t _bitmap_granularity_mask = _bitmap_granularity_size - 1;\n-\n-  class BitMapFragment;\n-\n-  class BitMapFragmentTable : public BasicHashtable<mtTracing> {\n-    class Entry : public BasicHashtableEntry<mtTracing> {\n-    public:\n-      uintptr_t _key;\n-      CHeapBitMap* _value;\n-\n-      Entry* next() {\n-        return (Entry*)BasicHashtableEntry<mtTracing>::next();\n-      }\n-    };\n-\n-  protected:\n-    Entry* bucket(int i) const;\n-\n-    Entry* new_entry(unsigned int hashValue, uintptr_t key, CHeapBitMap* value);\n-\n-    unsigned hash_segment(uintptr_t key) {\n-      unsigned hash = (unsigned)key;\n-      return hash ^ (hash >> 3);\n-    }\n-\n-    unsigned hash_to_index(unsigned hash) {\n-      return hash & (BasicHashtable<mtTracing>::table_size() - 1);\n-    }\n-\n-  public:\n-    BitMapFragmentTable(int table_size) : BasicHashtable<mtTracing>(table_size, sizeof(Entry)) {}\n-    void add(uintptr_t key, CHeapBitMap* value);\n-    CHeapBitMap** lookup(uintptr_t key);\n-  };\n-\n-  CHeapBitMap* get_fragment_bits(uintptr_t addr);\n-\n-  BitMapFragmentTable _bitmap_fragments;\n-  BitMapFragment* _fragment_list;\n-  CHeapBitMap* _last_fragment_bits;\n-  uintptr_t _last_fragment_granule;\n-\n- public:\n-  BitSet();\n-  ~BitSet();\n-\n-  BitMap::idx_t addr_to_bit(uintptr_t addr) const;\n-\n-  void mark_obj(uintptr_t addr);\n-\n-  void mark_obj(oop obj) {\n-    return mark_obj(cast_from_oop<uintptr_t>(obj));\n-  }\n-\n-  bool is_marked(uintptr_t addr);\n-\n-  bool is_marked(oop obj) {\n-    return is_marked(cast_from_oop<uintptr_t>(obj));\n-  }\n-};\n-\n-class BitSet::BitMapFragment : public CHeapObj<mtTracing> {\n-  CHeapBitMap _bits;\n-  BitMapFragment* _next;\n-\n-public:\n-  BitMapFragment(uintptr_t granule, BitMapFragment* next);\n-\n-  BitMapFragment* next() const {\n-    return _next;\n-  }\n-\n-  CHeapBitMap* bits() {\n-    return &_bits;\n-  }\n-};\n-\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.hpp","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n-\n-#include \"jfr\/leakprofiler\/chains\/bitset.hpp\"\n-\n-#include \"jfr\/recorder\/storage\/jfrVirtualMemory.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n-#include \"utilities\/hashtable.inline.hpp\"\n-\n-inline BitSet::BitMapFragmentTable::Entry* BitSet::BitMapFragmentTable::bucket(int i) const {\n-  return (Entry*)BasicHashtable<mtTracing>::bucket(i);\n-}\n-\n-inline BitSet::BitMapFragmentTable::Entry* BitSet::BitMapFragmentTable::new_entry(unsigned int hash,\n-                                                                                  uintptr_t key,\n-                                                                                  CHeapBitMap* value) {\n-  Entry* entry = (Entry*)BasicHashtable<mtTracing>::new_entry(hash);\n-  entry->_key = key;\n-  entry->_value = value;\n-  return entry;\n-}\n-\n-inline void BitSet::BitMapFragmentTable::add(uintptr_t key, CHeapBitMap* value) {\n-  unsigned hash = hash_segment(key);\n-  Entry* entry = new_entry(hash, key, value);\n-  BasicHashtable<mtTracing>::add_entry(hash_to_index(hash), entry);\n-}\n-\n-inline CHeapBitMap** BitSet::BitMapFragmentTable::lookup(uintptr_t key) {\n-  unsigned hash = hash_segment(key);\n-  int index = hash_to_index(hash);\n-  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->hash() == hash && e->_key == key) {\n-      return &(e->_value);\n-    }\n-  }\n-  return NULL;\n-}\n-\n-inline BitMap::idx_t BitSet::addr_to_bit(uintptr_t addr) const {\n-  return (addr & _bitmap_granularity_mask) >> LogMinObjAlignmentInBytes;\n-}\n-\n-inline CHeapBitMap* BitSet::get_fragment_bits(uintptr_t addr) {\n-  uintptr_t granule = addr >> _bitmap_granularity_shift;\n-  if (granule == _last_fragment_granule) {\n-    return _last_fragment_bits;\n-  }\n-  CHeapBitMap* bits = NULL;\n-\n-  CHeapBitMap** found = _bitmap_fragments.lookup(granule);\n-  if (found != NULL) {\n-    bits = *found;\n-  } else {\n-    BitMapFragment* fragment = new BitMapFragment(granule, _fragment_list);\n-    bits = fragment->bits();\n-    _fragment_list = fragment;\n-    if (_bitmap_fragments.number_of_entries() * 100 \/ _bitmap_fragments.table_size() > 25) {\n-      _bitmap_fragments.resize(_bitmap_fragments.table_size() * 2);\n-    }\n-    _bitmap_fragments.add(granule, bits);\n-  }\n-\n-  _last_fragment_bits = bits;\n-  _last_fragment_granule = granule;\n-\n-  return bits;\n-}\n-\n-inline void BitSet::mark_obj(uintptr_t addr) {\n-  CHeapBitMap* bits = get_fragment_bits(addr);\n-  const BitMap::idx_t bit = addr_to_bit(addr);\n-  bits->set_bit(bit);\n-}\n-\n-inline bool BitSet::is_marked(uintptr_t addr) {\n-  CHeapBitMap* bits = get_fragment_bits(addr);\n-  const BitMap::idx_t bit = addr_to_bit(addr);\n-  return bits->at(bit);\n-}\n-\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.inline.hpp","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -43,1 +43,1 @@\n-                                      BitSet* mark_bits,\n+                                      BitSet<mtTracing>* mark_bits,\n@@ -55,1 +55,1 @@\n-                                          BitSet* mark_bits) {\n+                                          BitSet<mtTracing>* mark_bits) {\n@@ -71,1 +71,1 @@\n-DFSClosure::DFSClosure(EdgeStore* edge_store, BitSet* mark_bits, const Edge* start_edge)\n+DFSClosure::DFSClosure(EdgeStore* edge_store, BitSet<mtTracing>* mark_bits, const Edge* start_edge)\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+template<MEMFLAGS F>\n@@ -44,1 +45,1 @@\n-  BitSet* _mark_bits;\n+  BitSet<mtTracing>* _mark_bits;\n@@ -50,1 +51,1 @@\n-  DFSClosure(EdgeStore* edge_store, BitSet* mark_bits, const Edge* start_edge);\n+  DFSClosure(EdgeStore* edge_store, BitSet<mtTracing>* mark_bits, const Edge* start_edge);\n@@ -58,2 +59,2 @@\n-  static void find_leaks_from_edge(EdgeStore* edge_store, BitSet* mark_bits, const Edge* start_edge);\n-  static void find_leaks_from_root_set(EdgeStore* edge_store, BitSet* mark_bits);\n+  static void find_leaks_from_edge(EdgeStore* edge_store, BitSet<mtTracing>* mark_bits, const Edge* start_edge);\n+  static void find_leaks_from_root_set(EdgeStore* edge_store, BitSet<mtTracing>* mark_bits);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -87,1 +87,1 @@\n-  BitSet mark_bits;\n+  BitSet<mtTracing> mark_bits;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -1334,78 +1335,10 @@\n-\n-\/\/ ObjectMarker is used to support the marking objects when walking the\n-\/\/ heap.\n-\/\/\n-\/\/ This implementation uses the existing mark bits in an object for\n-\/\/ marking. Objects that are marked must later have their headers restored.\n-\/\/ As most objects are unlocked and don't have their identity hash computed\n-\/\/ we don't have to save their headers. Instead we save the headers that\n-\/\/ are \"interesting\". Later when the headers are restored this implementation\n-\/\/ restores all headers to their initial value and then restores the few\n-\/\/ objects that had interesting headers.\n-\/\/\n-\/\/ Future work: This implementation currently uses growable arrays to save\n-\/\/ the oop and header of interesting objects. As an optimization we could\n-\/\/ use the same technique as the GC and make use of the unused area\n-\/\/ between top() and end().\n-\/\/\n-\n-\/\/ An ObjectClosure used to restore the mark bits of an object\n-class RestoreMarksClosure : public ObjectClosure {\n- public:\n-  void do_object(oop o) {\n-    if (o != NULL) {\n-      markWord mark = o->mark();\n-      if (mark.is_marked()) {\n-        o->init_mark();\n-      }\n-    }\n-  }\n-};\n-\n-\/\/ ObjectMarker provides the mark and visited functions\n-class ObjectMarker : AllStatic {\n- private:\n-  \/\/ saved headers\n-  static GrowableArray<oop>* _saved_oop_stack;\n-  static GrowableArray<markWord>* _saved_mark_stack;\n-  static bool _needs_reset;                  \/\/ do we need to reset mark bits?\n-\n- public:\n-  static void init();                       \/\/ initialize\n-  static void done();                       \/\/ clean-up\n-\n-  static inline void mark(oop o);           \/\/ mark an object\n-  static inline bool visited(oop o);        \/\/ check if object has been visited\n-\n-  static inline bool needs_reset()            { return _needs_reset; }\n-  static inline void set_needs_reset(bool v)  { _needs_reset = v; }\n-};\n-\n-GrowableArray<oop>* ObjectMarker::_saved_oop_stack = NULL;\n-GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;\n-bool ObjectMarker::_needs_reset = true;  \/\/ need to reset mark bits by default\n-\n-\/\/ initialize ObjectMarker - prepares for object marking\n-void ObjectMarker::init() {\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  \/\/ prepare heap for iteration\n-  Universe::heap()->ensure_parsability(false);  \/\/ no need to retire TLABs\n-\n-  \/\/ create stacks for interesting headers\n-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<markWord>(4000, mtServiceability);\n-  _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(4000, mtServiceability);\n-}\n-\n-\/\/ Object marking is done so restore object headers\n-void ObjectMarker::done() {\n-  \/\/ iterate over all objects and restore the mark bits to\n-  \/\/ their initial value\n-  RestoreMarksClosure blk;\n-  if (needs_reset()) {\n-    Universe::heap()->object_iterate(&blk);\n-  } else {\n-    \/\/ We don't need to reset mark bits on this call, but reset the\n-    \/\/ flag to the default for the next call.\n-    set_needs_reset(true);\n+\/\/ Stack allocated class to help ensure that ObjectMarker is used\n+\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n+\/\/ ObjectMarker's done() function to restore object headers.\n+class ObjectMarker : public StackObj {\n+private:\n+  static BitSet<mtServiceability>* _bitset;\n+public:\n+  ObjectMarker() {\n+    assert(_bitset == NULL, \"don't initialize bitset twice\");\n+    _bitset = new BitSet<mtServiceability>();\n@@ -1414,5 +1347,4 @@\n-  \/\/ now restore the interesting headers\n-  for (int i = 0; i < _saved_oop_stack->length(); i++) {\n-    oop o = _saved_oop_stack->at(i);\n-    markWord mark = _saved_mark_stack->at(i);\n-    o->set_mark(mark);\n+  ~ObjectMarker() {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    delete _bitset;\n+    _bitset = NULL;\n@@ -1421,16 +1353,3 @@\n-  \/\/ free the stacks\n-  delete _saved_oop_stack;\n-  delete _saved_mark_stack;\n-}\n-\n-\/\/ mark an object\n-inline void ObjectMarker::mark(oop o) {\n-  assert(Universe::heap()->is_in(o), \"sanity check\");\n-  assert(!o->mark().is_marked(), \"should only mark an object once\");\n-\n-  \/\/ object's mark word\n-  markWord mark = o->mark();\n-\n-  if (o->mark_must_be_preserved(mark)) {\n-    _saved_mark_stack->push(mark);\n-    _saved_oop_stack->push(o);\n+  static void mark(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    _bitset->mark_obj(o);\n@@ -1439,19 +1358,3 @@\n-  \/\/ mark the object\n-  o->set_mark(markWord::prototype().set_marked());\n-}\n-\n-\/\/ return true if object is marked\n-inline bool ObjectMarker::visited(oop o) {\n-  return o->mark().is_marked();\n-}\n-\n-\/\/ Stack allocated class to help ensure that ObjectMarker is used\n-\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n-\/\/ ObjectMarker's done() function to restore object headers.\n-class ObjectMarkerController : public StackObj {\n- public:\n-  ObjectMarkerController() {\n-    ObjectMarker::init();\n-  }\n-  ~ObjectMarkerController() {\n-    ObjectMarker::done();\n+  static bool is_marked(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    return _bitset->is_marked(o);\n@@ -1461,0 +1364,1 @@\n+BitSet<mtServiceability>* ObjectMarker::_bitset = NULL;\n@@ -1603,1 +1507,1 @@\n-    if (!ObjectMarker::visited(obj)) visit_stack()->push(obj);\n+    if (!ObjectMarker::is_marked(obj)) visit_stack()->push(obj);\n@@ -2890,1 +2794,1 @@\n-  assert(!ObjectMarker::visited(o), \"can't visit same object more than once\");\n+  assert(!ObjectMarker::is_marked(o), \"can't visit same object more than once\");\n@@ -2920,1 +2824,1 @@\n-  ObjectMarkerController marker;\n+  ObjectMarker marker;\n@@ -2929,6 +2833,0 @@\n-    \/\/ If either collect_stack_roots() or collect_simple_roots()\n-    \/\/ returns false at this point, then there are no mark bits\n-    \/\/ to reset.\n-    ObjectMarker::set_needs_reset(false);\n-\n-    \/\/ Calling collect_stack_roots() before collect_simple_roots()\n@@ -2940,3 +2838,0 @@\n-\n-    \/\/ no early return so enable heap traversal to reset the mark bits\n-    ObjectMarker::set_needs_reset(true);\n@@ -2954,1 +2849,1 @@\n-      if (!ObjectMarker::visited(o)) {\n+      if (!ObjectMarker::is_marked(o)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":26,"deletions":131,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_BITSET_HPP\n+#define SHARE_UTILITIES_BITSET_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+\n+class MemRegion;\n+\n+template<MEMFLAGS F>\n+class BitSet : public CHeapObj<F> {\n+  const static size_t _bitmap_granularity_shift = 26; \/\/ 64M\n+  const static size_t _bitmap_granularity_size = (size_t)1 << _bitmap_granularity_shift;\n+  const static size_t _bitmap_granularity_mask = _bitmap_granularity_size - 1;\n+\n+  class BitMapFragment;\n+\n+  class BitMapFragmentTable : public BasicHashtable<F> {\n+    class Entry : public BasicHashtableEntry<F> {\n+    public:\n+      uintptr_t _key;\n+      CHeapBitMap* _value;\n+\n+      Entry* next() {\n+        return (Entry*)BasicHashtableEntry<F>::next();\n+      }\n+    };\n+\n+  protected:\n+    Entry* bucket(int i) const;\n+\n+    Entry* new_entry(unsigned int hashValue, uintptr_t key, CHeapBitMap* value);\n+\n+    unsigned hash_segment(uintptr_t key) {\n+      unsigned hash = (unsigned)key;\n+      return hash ^ (hash >> 3);\n+    }\n+\n+    unsigned hash_to_index(unsigned hash) {\n+      return hash & (BasicHashtable<F>::table_size() - 1);\n+    }\n+\n+  public:\n+    BitMapFragmentTable(int table_size) : BasicHashtable<F>(table_size, sizeof(Entry)) {}\n+    void add(uintptr_t key, CHeapBitMap* value);\n+    CHeapBitMap** lookup(uintptr_t key);\n+  };\n+\n+  CHeapBitMap* get_fragment_bits(uintptr_t addr);\n+\n+  BitMapFragmentTable _bitmap_fragments;\n+  BitMapFragment* _fragment_list;\n+  CHeapBitMap* _last_fragment_bits;\n+  uintptr_t _last_fragment_granule;\n+\n+ public:\n+  BitSet();\n+  ~BitSet();\n+\n+  BitMap::idx_t addr_to_bit(uintptr_t addr) const;\n+\n+  void mark_obj(uintptr_t addr);\n+\n+  void mark_obj(oop obj) {\n+    return mark_obj(cast_from_oop<uintptr_t>(obj));\n+  }\n+\n+  bool is_marked(uintptr_t addr);\n+\n+  bool is_marked(oop obj) {\n+    return is_marked(cast_from_oop<uintptr_t>(obj));\n+  }\n+};\n+\n+template<MEMFLAGS F>\n+class BitSet<F>::BitMapFragment : public CHeapObj<F> {\n+  CHeapBitMap _bits;\n+  BitMapFragment* _next;\n+\n+public:\n+  BitMapFragment(uintptr_t granule, BitMapFragment* next);\n+\n+  BitMapFragment* next() const {\n+    return _next;\n+  }\n+\n+  CHeapBitMap* bits() {\n+    return &_bits;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_BITSET_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_BITSET_INLINE_HPP\n+#define SHARE_UTILITIES_BITSET_INLINE_HPP\n+\n+#include \"utilities\/bitset.hpp\"\n+\n+#include \"memory\/memRegion.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/hashtable.inline.hpp\"\n+\n+template<MEMFLAGS F>\n+BitSet<F>::BitMapFragment::BitMapFragment(uintptr_t granule, BitMapFragment* next) :\n+        _bits(_bitmap_granularity_size >> LogMinObjAlignmentInBytes, F, true \/* clear *\/),\n+        _next(next) {\n+}\n+\n+template<MEMFLAGS F>\n+BitSet<F>::BitSet() :\n+        _bitmap_fragments(32),\n+        _fragment_list(NULL),\n+        _last_fragment_bits(NULL),\n+        _last_fragment_granule(UINTPTR_MAX) {\n+}\n+\n+template<MEMFLAGS F>\n+BitSet<F>::~BitSet() {\n+  BitMapFragment* current = _fragment_list;\n+  while (current != NULL) {\n+    BitMapFragment* next = current->next();\n+    delete current;\n+    current = next;\n+  }\n+}\n+\n+template<MEMFLAGS F>\n+inline typename BitSet<F>::BitMapFragmentTable::Entry* BitSet<F>::BitMapFragmentTable::bucket(int i) const {\n+  return (Entry*)BasicHashtable<F>::bucket(i);\n+}\n+\n+template<MEMFLAGS F>\n+inline typename BitSet<F>::BitMapFragmentTable::Entry* BitSet<F>::BitMapFragmentTable::new_entry(unsigned int hash,\n+                                                                                                 uintptr_t key,\n+                                                                                                 CHeapBitMap* value) {\n+  Entry* entry = (Entry*)BasicHashtable<F>::new_entry(hash);\n+  entry->_key = key;\n+  entry->_value = value;\n+  return entry;\n+}\n+\n+template<MEMFLAGS F>\n+inline void BitSet<F>::BitMapFragmentTable::add(uintptr_t key, CHeapBitMap* value) {\n+  unsigned hash = hash_segment(key);\n+  Entry* entry = new_entry(hash, key, value);\n+  BasicHashtable<F>::add_entry(hash_to_index(hash), entry);\n+}\n+\n+template<MEMFLAGS F>\n+inline CHeapBitMap** BitSet<F>::BitMapFragmentTable::lookup(uintptr_t key) {\n+  unsigned hash = hash_segment(key);\n+  int index = hash_to_index(hash);\n+  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n+    if (e->hash() == hash && e->_key == key) {\n+      return &(e->_value);\n+    }\n+  }\n+  return NULL;\n+}\n+\n+template<MEMFLAGS F>\n+inline BitMap::idx_t BitSet<F>::addr_to_bit(uintptr_t addr) const {\n+  return (addr & _bitmap_granularity_mask) >> LogMinObjAlignmentInBytes;\n+}\n+\n+template<MEMFLAGS F>\n+inline CHeapBitMap* BitSet<F>::get_fragment_bits(uintptr_t addr) {\n+  uintptr_t granule = addr >> _bitmap_granularity_shift;\n+  if (granule == _last_fragment_granule) {\n+    return _last_fragment_bits;\n+  }\n+  CHeapBitMap* bits = NULL;\n+\n+  CHeapBitMap** found = _bitmap_fragments.lookup(granule);\n+  if (found != NULL) {\n+    bits = *found;\n+  } else {\n+    BitMapFragment* fragment = new BitMapFragment(granule, _fragment_list);\n+    bits = fragment->bits();\n+    _fragment_list = fragment;\n+    if (_bitmap_fragments.number_of_entries() * 100 \/ _bitmap_fragments.table_size() > 25) {\n+      _bitmap_fragments.resize(_bitmap_fragments.table_size() * 2);\n+    }\n+    _bitmap_fragments.add(granule, bits);\n+  }\n+\n+  _last_fragment_bits = bits;\n+  _last_fragment_granule = granule;\n+\n+  return bits;\n+}\n+\n+template<MEMFLAGS F>\n+inline void BitSet<F>::mark_obj(uintptr_t addr) {\n+  CHeapBitMap* bits = get_fragment_bits(addr);\n+  const BitMap::idx_t bit = addr_to_bit(addr);\n+  bits->set_bit(bit);\n+}\n+\n+template<MEMFLAGS F>\n+inline bool BitSet<F>::is_marked(uintptr_t addr) {\n+  CHeapBitMap* bits = get_fragment_bits(addr);\n+  const BitMap::idx_t bit = addr_to_bit(addr);\n+  return bits->at(bit);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_BITSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.inline.hpp","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}