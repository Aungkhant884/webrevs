{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"utilities\/bitset.inline.hpp\"\n@@ -1334,114 +1335,0 @@\n-\n-\/\/ ObjectMarker is used to support the marking objects when walking the\n-\/\/ heap.\n-\/\/\n-\/\/ This implementation uses the existing mark bits in an object for\n-\/\/ marking. Objects that are marked must later have their headers restored.\n-\/\/ As most objects are unlocked and don't have their identity hash computed\n-\/\/ we don't have to save their headers. Instead we save the headers that\n-\/\/ are \"interesting\". Later when the headers are restored this implementation\n-\/\/ restores all headers to their initial value and then restores the few\n-\/\/ objects that had interesting headers.\n-\/\/\n-\/\/ Future work: This implementation currently uses growable arrays to save\n-\/\/ the oop and header of interesting objects. As an optimization we could\n-\/\/ use the same technique as the GC and make use of the unused area\n-\/\/ between top() and end().\n-\/\/\n-\n-\/\/ An ObjectClosure used to restore the mark bits of an object\n-class RestoreMarksClosure : public ObjectClosure {\n- public:\n-  void do_object(oop o) {\n-    if (o != NULL) {\n-      markWord mark = o->mark();\n-      if (mark.is_marked()) {\n-        o->init_mark();\n-      }\n-    }\n-  }\n-};\n-\n-\/\/ ObjectMarker provides the mark and visited functions\n-class ObjectMarker : AllStatic {\n- private:\n-  \/\/ saved headers\n-  static GrowableArray<oop>* _saved_oop_stack;\n-  static GrowableArray<markWord>* _saved_mark_stack;\n-  static bool _needs_reset;                  \/\/ do we need to reset mark bits?\n-\n- public:\n-  static void init();                       \/\/ initialize\n-  static void done();                       \/\/ clean-up\n-\n-  static inline void mark(oop o);           \/\/ mark an object\n-  static inline bool visited(oop o);        \/\/ check if object has been visited\n-\n-  static inline bool needs_reset()            { return _needs_reset; }\n-  static inline void set_needs_reset(bool v)  { _needs_reset = v; }\n-};\n-\n-GrowableArray<oop>* ObjectMarker::_saved_oop_stack = NULL;\n-GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;\n-bool ObjectMarker::_needs_reset = true;  \/\/ need to reset mark bits by default\n-\n-\/\/ initialize ObjectMarker - prepares for object marking\n-void ObjectMarker::init() {\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  \/\/ prepare heap for iteration\n-  Universe::heap()->ensure_parsability(false);  \/\/ no need to retire TLABs\n-\n-  \/\/ create stacks for interesting headers\n-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<markWord>(4000, mtServiceability);\n-  _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(4000, mtServiceability);\n-}\n-\n-\/\/ Object marking is done so restore object headers\n-void ObjectMarker::done() {\n-  \/\/ iterate over all objects and restore the mark bits to\n-  \/\/ their initial value\n-  RestoreMarksClosure blk;\n-  if (needs_reset()) {\n-    Universe::heap()->object_iterate(&blk);\n-  } else {\n-    \/\/ We don't need to reset mark bits on this call, but reset the\n-    \/\/ flag to the default for the next call.\n-    set_needs_reset(true);\n-  }\n-\n-  \/\/ now restore the interesting headers\n-  for (int i = 0; i < _saved_oop_stack->length(); i++) {\n-    oop o = _saved_oop_stack->at(i);\n-    markWord mark = _saved_mark_stack->at(i);\n-    o->set_mark(mark);\n-  }\n-\n-  \/\/ free the stacks\n-  delete _saved_oop_stack;\n-  delete _saved_mark_stack;\n-}\n-\n-\/\/ mark an object\n-inline void ObjectMarker::mark(oop o) {\n-  assert(Universe::heap()->is_in(o), \"sanity check\");\n-  assert(!o->mark().is_marked(), \"should only mark an object once\");\n-\n-  \/\/ object's mark word\n-  markWord mark = o->mark();\n-\n-  if (o->mark_must_be_preserved(mark)) {\n-    _saved_mark_stack->push(mark);\n-    _saved_oop_stack->push(o);\n-  }\n-\n-  \/\/ mark the object\n-  o->set_mark(markWord::prototype().set_marked());\n-}\n-\n-\/\/ return true if object is marked\n-inline bool ObjectMarker::visited(oop o) {\n-  return o->mark().is_marked();\n-}\n-\n@@ -1452,1 +1339,3 @@\n- public:\n+private:\n+  static BitSet* _bitset;\n+public:\n@@ -1454,1 +1343,2 @@\n-    ObjectMarker::init();\n+    assert(_bitset == NULL, \"don't initialize bitset twice\");\n+    _bitset = new BitSet();\n@@ -1456,0 +1346,1 @@\n+\n@@ -1457,1 +1348,13 @@\n-    ObjectMarker::done();\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    delete _bitset;\n+    _bitset = NULL;\n+  }\n+\n+  static void mark(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    _bitset->mark_obj(o);\n+  }\n+\n+  static bool is_marked(oop o) {\n+    assert(_bitset != NULL, \"bitset must be initialized\");\n+    return _bitset->is_marked(o);\n@@ -1461,0 +1364,1 @@\n+BitSet* ObjectMarkerController::_bitset = NULL;\n@@ -1603,1 +1507,1 @@\n-    if (!ObjectMarker::visited(obj)) visit_stack()->push(obj);\n+    if (!ObjectMarkerController::is_marked(obj)) visit_stack()->push(obj);\n@@ -2890,2 +2794,2 @@\n-  assert(!ObjectMarker::visited(o), \"can't visit same object more than once\");\n-  ObjectMarker::mark(o);\n+  assert(!ObjectMarkerController::is_marked(o), \"can't visit same object more than once\");\n+  ObjectMarkerController::mark(o);\n@@ -2929,6 +2833,0 @@\n-    \/\/ If either collect_stack_roots() or collect_simple_roots()\n-    \/\/ returns false at this point, then there are no mark bits\n-    \/\/ to reset.\n-    ObjectMarker::set_needs_reset(false);\n-\n-    \/\/ Calling collect_stack_roots() before collect_simple_roots()\n@@ -2940,3 +2838,0 @@\n-\n-    \/\/ no early return so enable heap traversal to reset the mark bits\n-    ObjectMarker::set_needs_reset(true);\n@@ -2954,1 +2849,1 @@\n-      if (!ObjectMarker::visited(o)) {\n+      if (!ObjectMarkerController::is_marked(o)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":25,"deletions":130,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.inline.hpp\"\n+#include \"utilities\/bitset.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/bitset.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.cpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n+#ifndef SHARE_UTILITIES_BITSET_HPP\n+#define SHARE_UTILITIES_BITSET_HPP\n@@ -34,1 +34,0 @@\n-class JfrVirtualMemory;\n@@ -117,1 +116,1 @@\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_HPP\n+#endif \/\/ SHARE_UTILITIES_BITSET_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.hpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n-#ifndef SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n-#define SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n+#ifndef SHARE_UTILITIES_BITSET_INLINE_HPP\n+#define SHARE_UTILITIES_BITSET_INLINE_HPP\n@@ -28,1 +28,1 @@\n-#include \"jfr\/leakprofiler\/chains\/bitset.hpp\"\n+#include \"utilities\/bitset.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/storage\/jfrVirtualMemory.hpp\"\n@@ -107,1 +106,1 @@\n-#endif \/\/ SHARE_JFR_LEAKPROFILER_CHAINS_BITSET_INLINE_HPP\n+#endif \/\/ SHARE_UTILITIES_BITSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitset.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bitset.inline.hpp","status":"renamed"}]}