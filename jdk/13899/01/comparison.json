{"files":[{"patch":"@@ -184,0 +184,1 @@\n+JVM_PrintWarningAtDynamicAgentLoad\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1167,0 +1167,6 @@\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_PrintWarningAtDynamicAgentLoad(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4027,0 +4027,7 @@\n+\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JVM_LEAF(jboolean, JVM_PrintWarningAtDynamicAgentLoad(void))\n+  return (EnableDynamicAgentLoading && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading)) ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-    A VM may support a mechanism that allows agents to be started in the VM during the live\n+    A VM may support a mechanism to load an agent library and start an agent during the live\n@@ -643,0 +643,4 @@\n+    The VM will print a warning to the standard error stream for each agent that it starts\n+    during the live phase. Warnings can be disabled by means of an implementation-specific\n+    command line option.\n+    <p\/>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -506,0 +508,9 @@\n+\n+    \/\/ Print warning if EnableDynamicAgentLoading not enabled on the command line\n+    assert(EnableDynamicAgentLoading, \"Dynamic loading of agents not enabled\");\n+    if (!FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib()) {\n+      jio_fprintf(defaultStream::error_stream(),\n+        \"WARNING: A JVM TI agent has been dynamically loaded (%s)\\n\"\n+        \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n+        \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * programs running on the JVM. The mechanism for instrumentation is modification\n- * of the byte-codes of methods.\n+ * programs running on the Java Virtual Machine (JVM). The mechanism for\n+ * instrumentation is modification of the byte-codes of methods.\n@@ -35,3 +35,2 @@\n- * <p> An agent is deployed as a JAR file. An attribute in the JAR file manifest\n- * specifies the agent class which will be loaded to start the agent. Agents can\n- * be started in several ways:\n+ * <p> Agent classes are packaged in a JAR file. An agent can be <em>started<\/em>\n+ * in a number of ways:\n@@ -40,2 +39,2 @@\n- *   <li><p> For implementations that support a command-line interface, an agent\n- *   can be started by specifying an option on the command-line. <\/p><\/li>\n+ *   <li><p> At JVM Startup when named in the manifest of the application's executable\n+ *   JAR file.\n@@ -43,4 +42,1 @@\n- *   <li><p> An implementation may support a mechanism to start agents some time\n- *   after the VM has started. For example, an implementation may provide a\n- *   mechanism that allows a tool to <i>attach<\/i> to a running application, and\n- *   initiate the loading of the tool's agent into the running application. <\/p><\/li>\n+ *   <li><p> At JVM Startup with a command-line option.\n@@ -48,2 +44,2 @@\n- *   <li><p> An agent may be packaged with an application in an executable JAR\n- *   file.<\/p><\/li>\n+ *   <li><p> After JVM Startup where an implementation supports a mechanism to start\n+ *   agents some time after the JVM has started.\n@@ -57,1 +53,1 @@\n- * agent including the content and structure of the agent JAR file.\n+ * agent including the content and structure of the agent JAR file..\n@@ -59,1 +55,1 @@\n- * <p> The three ways to start an agent are described below.\n+ * <h2>Starting an Agent<\/h2>\n@@ -61,1 +57,30 @@\n- * <h2>Starting an Agent from the Command-Line Interface<\/h2>\n+ * <h3>Starting an Agent named in the manifest of the application's executable JAR file <\/h3>\n+ *\n+ * <p> The <a href=\"{@docRoot}\/..\/specs\/jar\/jar.html\">JAR FileSpecification<\/a> defines\n+ * manifest attributes for standalone applications that are packaged as <em>executable\n+ * JAR files<\/em>. If an implementation supports a mechanism to start an application as\n+ * an executable JAR then the main manifest may include the {@code Launcher-Agent-Class}\n+ * attribute to specify the class name of an agent to start before the application\n+ * {@code main} method is invoked. The JVM attempts to load the agent class and invoke\n+ * the following method on the class:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs, Instrumentation inst)\n+ * }<\/blockquote>\n+ *\n+ * <p> If the agent class does not implement this method then the JVM will\n+ * attempt to invoke:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs)\n+ * }<\/blockquote>\n+ *\n+ * <p> The value of the {@code agentArgs} parameter is always the empty string.\n+ *\n+ * <p> The {@code agentmain} method should do any necessary initialization\n+ * required to start the agent and return. If the agent cannot be started, for\n+ * example the agent class cannot be loaded, the agent class does not define a\n+ * conformant {@code agentmain} method, or the {@code agentmain} method throws\n+ * an uncaught exception or error, the JVM will abort.\n+ *\n+ * <h3>Starting an Agent from the command-line interface<\/h3>\n@@ -64,1 +89,1 @@\n- * command-line interface, an agent is started by adding the following option\n+ * command-line interface, an agent can be started by adding the following option\n@@ -97,1 +122,1 @@\n- * the agent is started after VM startup (see below). When the agent is started\n+ * the agent is started after JVM startup (see below). When the agent is started\n@@ -122,1 +147,1 @@\n- * <h2>Starting an Agent After VM Startup<\/h2>\n+ * <h3>Starting an Agent after JVM startup<\/h3>\n@@ -125,1 +150,1 @@\n- * the VM has started. The details as to how this is initiated are\n+ * the JVM has started. The details as to how this is initiated are\n@@ -128,1 +153,1 @@\n- * implementation supports the starting of agents after the VM has started the\n+ * implementation supports starting an agent after the JVM has started, the\n@@ -140,0 +165,4 @@\n+ *   <li><p> The JVM prints a warning on the standard error stream. The warning is\n+ *   printed for each agent started after JVM startup. The warning can be disabled\n+ *   by means of an implementation-specific command line option. <\/p><\/li>\n+ *\n@@ -158,1 +187,1 @@\n- * VM startup the {@code premain} method is not invoked.\n+ * JVM startup the {@code premain} method is not invoked.\n@@ -172,31 +201,0 @@\n- *\n- * <h2>Including an Agent in an Executable JAR file<\/h2>\n- *\n- * <p> The JAR File Specification defines manifest attributes for standalone\n- * applications that are packaged as <em>executable JAR files<\/em>. If an\n- * implementation supports a mechanism to start an application as an executable\n- * JAR then the main manifest may include the {@code Launcher-Agent-Class}\n- * attribute to specify the class name of an agent to start before the application\n- * {@code main} method is invoked. The Java virtual machine attempts to\n- * invoke the following method on the agent class:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs, Instrumentation inst)\n- * }<\/blockquote>\n- *\n- * <p> If the agent class does not implement this method then the JVM will\n- * attempt to invoke:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs)\n- * }<\/blockquote>\n- *\n- * <p> The value of the {@code agentArgs} parameter is always the empty string.\n- *\n- * <p> The {@code agentmain} method should do any necessary initialization\n- * required to start the agent and return. If the agent cannot be started, for\n- * example the agent class cannot be loaded, the agent class does not define a\n- * conformant {@code agentmain} method, or the {@code agentmain} method throws\n- * an uncaught exception or error, the JVM will abort.\n- *\n- *\n@@ -266,1 +264,1 @@\n- * the VM has started then this attribute specifies the agent class. That is,\n+ * the JVM has started then this attribute specifies the agent class. That is,\n@@ -287,1 +285,1 @@\n- * started sometime after the VM has started then paths that do not represent a\n+ * started sometime after the JVM has started then paths that do not represent a\n@@ -315,1 +313,1 @@\n- * after the VM has started, then the {@code Agent-Class} attribute specifies\n+ * after the JVM has started, then the {@code Agent-Class} attribute specifies\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/package-info.java","additions":55,"deletions":57,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.nio.file.InvalidPathException;\n+import java.net.URL;\n@@ -36,0 +40,1 @@\n+import java.security.CodeSource;\n@@ -46,1 +51,1 @@\n-\n+import java.util.stream.Collectors;\n@@ -62,0 +67,9 @@\n+    private static final String TRACE_USAGE_PROP_NAME = \"jdk.instrument.traceUsage\";\n+    private static final boolean TRACE_USAGE;\n+    static {\n+        PrivilegedAction<String> pa = () -> System.getProperty(TRACE_USAGE_PROP_NAME);\n+        @SuppressWarnings(\"removal\")\n+        String s = AccessController.doPrivileged(pa);\n+        TRACE_USAGE = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+    }\n+\n@@ -74,1 +88,2 @@\n-                        boolean environmentSupportsNativeMethodPrefix) {\n+                        boolean environmentSupportsNativeMethodPrefix,\n+                        boolean printWarning) {\n@@ -82,0 +97,30 @@\n+\n+        if (printWarning) {\n+            String source = jarFile(nativeAgent);\n+            try {\n+                Path path = Path.of(source);\n+                PrivilegedAction<Path> pa = path::toAbsolutePath;\n+                @SuppressWarnings(\"removal\")\n+                Path absolutePath = AccessController.doPrivileged(pa);\n+                source = absolutePath.toString();\n+            } catch (InvalidPathException e) {\n+                \/\/ use original path\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"WARNING: A Java agent has been loaded dynamically (\")\n+                    .append(source)\n+                    .append(\")\")\n+                    .append(System.lineSeparator());\n+            sb.append(\"WARNING: If a serviceability tool is in use, please run with\"\n+                            + \" -XX:+EnableDynamicAgentLoading to hide this warning\")\n+                    .append(System.lineSeparator());\n+            if (!TRACE_USAGE) {\n+                sb.append(\"WARNING: If a serviceability tool is not in use, please run with\"\n+                                + \" -D\" + TRACE_USAGE_PROP_NAME + \" for more information\")\n+                        .append(System.lineSeparator());\n+            }\n+            sb.append(\"WARNING: Dynamic loading of agents will be disallowed by default in a future release\");\n+            String warningMessage = sb.toString();\n+            System.err.println(warningMessage);\n+        }\n@@ -84,2 +129,2 @@\n-    public void\n-    addTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer) {\n@@ -89,2 +134,3 @@\n-    public synchronized void\n-    addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+        trace(\"addTransformer\");\n@@ -94,16 +140,18 @@\n-        if (canRetransform) {\n-            if (!isRetransformClassesSupported()) {\n-                throw new UnsupportedOperationException(\n-                  \"adding retransformable transformers is not supported in this environment\");\n-            }\n-            if (mRetransfomableTransformerManager == null) {\n-                mRetransfomableTransformerManager = new TransformerManager(true);\n-            }\n-            mRetransfomableTransformerManager.addTransformer(transformer);\n-            if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n-                setHasRetransformableTransformers(mNativeAgent, true);\n-            }\n-        } else {\n-            mTransformerManager.addTransformer(transformer);\n-            if (mTransformerManager.getTransformerCount() == 1) {\n-                setHasTransformers(mNativeAgent, true);\n+        synchronized (this) {\n+            if (canRetransform) {\n+                if (!isRetransformClassesSupported()) {\n+                    throw new UnsupportedOperationException(\n+                        \"adding retransformable transformers is not supported in this environment\");\n+                }\n+                if (mRetransfomableTransformerManager == null) {\n+                    mRetransfomableTransformerManager = new TransformerManager(true);\n+                }\n+                mRetransfomableTransformerManager.addTransformer(transformer);\n+                if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n+                    setHasRetransformableTransformers(mNativeAgent, true);\n+                }\n+            } else {\n+                mTransformerManager.addTransformer(transformer);\n+                if (mTransformerManager.getTransformerCount() == 1) {\n+                    setHasTransformers(mNativeAgent, true);\n+                }\n@@ -114,2 +162,3 @@\n-    public synchronized boolean\n-    removeTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public boolean removeTransformer(ClassFileTransformer transformer) {\n+        trace(\"removeTransformer\");\n@@ -119,8 +168,10 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr != null) {\n-            mgr.removeTransformer(transformer);\n-            if (mgr.getTransformerCount() == 0) {\n-                if (mgr.isRetransformable()) {\n-                    setHasRetransformableTransformers(mNativeAgent, false);\n-                } else {\n-                    setHasTransformers(mNativeAgent, false);\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr != null) {\n+                mgr.removeTransformer(transformer);\n+                if (mgr.getTransformerCount() == 0) {\n+                    if (mgr.isRetransformable()) {\n+                        setHasRetransformableTransformers(mNativeAgent, false);\n+                    } else {\n+                        setHasTransformers(mNativeAgent, false);\n+                    }\n@@ -128,0 +179,1 @@\n+                return true;\n@@ -129,1 +181,1 @@\n-            return true;\n+            return false;\n@@ -131,1 +183,0 @@\n-        return false;\n@@ -134,2 +185,3 @@\n-    public boolean\n-    isModifiableClass(Class<?> theClass) {\n+    @Override\n+    public boolean isModifiableClass(Class<?> theClass) {\n+        trace(\"isModifiableClass\");\n@@ -143,0 +195,1 @@\n+    @Override\n@@ -144,0 +197,1 @@\n+        trace(\"isModifiableModule\");\n@@ -150,2 +204,3 @@\n-    public boolean\n-    isRetransformClassesSupported() {\n+    @Override\n+    public boolean isRetransformClassesSupported() {\n+        trace(\"isRetransformClassesSupported\");\n@@ -160,2 +215,3 @@\n-    public void\n-    retransformClasses(Class<?>... classes) {\n+    @Override\n+    public void retransformClasses(Class<?>... classes) {\n+        trace(\"retransformClasses\");\n@@ -172,2 +228,3 @@\n-    public boolean\n-    isRedefineClassesSupported() {\n+    @Override\n+    public boolean isRedefineClassesSupported() {\n+        trace(\"isRedefineClassesSupported\");\n@@ -177,3 +234,3 @@\n-    public void\n-    redefineClasses(ClassDefinition...  definitions)\n-            throws  ClassNotFoundException {\n+    @Override\n+    public void redefineClasses(ClassDefinition... definitions) throws ClassNotFoundException {\n+        trace(\"retransformClasses\");\n@@ -194,1 +251,0 @@\n-\n@@ -198,0 +254,1 @@\n+    @Override\n@@ -199,2 +256,2 @@\n-    public Class[]\n-    getAllLoadedClasses() {\n+    public Class[] getAllLoadedClasses() {\n+        trace(\"getAllLoadedClasses\");\n@@ -204,0 +261,1 @@\n+    @Override\n@@ -205,2 +263,2 @@\n-    public Class[]\n-    getInitiatedClasses(ClassLoader loader) {\n+    public Class[] getInitiatedClasses(ClassLoader loader) {\n+        trace(\"getInitiatedClasses\");\n@@ -210,2 +268,3 @@\n-    public long\n-    getObjectSize(Object objectToSize) {\n+    @Override\n+    public long getObjectSize(Object objectToSize) {\n+        trace(\"getObjectSize\");\n@@ -218,2 +277,3 @@\n-    public void\n-    appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToBootstrapClassLoaderSearch\");\n@@ -223,2 +283,3 @@\n-    public void\n-    appendToSystemClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToSystemClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToSystemClassLoaderSearch\");\n@@ -228,2 +289,3 @@\n-    public boolean\n-    isNativeMethodPrefixSupported() {\n+    @Override\n+    public boolean isNativeMethodPrefixSupported() {\n+        trace(\"isNativeMethodPrefixSupported\");\n@@ -233,2 +295,3 @@\n-    public synchronized void\n-    setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+    @Override\n+    public void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+        trace(\"setNativeMethodPrefix\");\n@@ -243,4 +306,9 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr == null) {\n-            throw new IllegalArgumentException(\n-                       \"transformer not registered in setNativeMethodPrefix\");\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr == null) {\n+                throw new IllegalArgumentException(\n+                        \"transformer not registered in setNativeMethodPrefix\");\n+            }\n+            mgr.setNativeMethodPrefix(transformer, prefix);\n+            String[] prefixes = mgr.getNativeMethodPrefixes();\n+            setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -248,3 +316,0 @@\n-        mgr.setNativeMethodPrefix(transformer, prefix);\n-        String[] prefixes = mgr.getNativeMethodPrefixes();\n-        setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -261,0 +326,2 @@\n+        trace(\"redefineModule\");\n+\n@@ -300,1 +367,0 @@\n-\n@@ -354,2 +420,2 @@\n-    private TransformerManager\n-    findTransformerManager(ClassFileTransformer transformer) {\n+    private TransformerManager findTransformerManager(ClassFileTransformer transformer) {\n+        assert Thread.holdsLock(this);\n@@ -370,0 +436,3 @@\n+    private native\n+    String jarFile(long nativeAgent);\n+\n@@ -560,0 +629,57 @@\n+\n+    \/**\n+     * Prints a trace message and stack trace when tracing is enabled.\n+     *\/\n+    private void trace(String methodName) {\n+        if (!TRACE_USAGE) return;\n+\n+        \/\/ stack trace without frames in java.instrument module\n+        List<StackWalker.StackFrame> stack = HolderStackWalker.walker.walk(s ->\n+            s.dropWhile(f -> f.getDeclaringClass().getModule() == Instrumentation.class.getModule())\n+                .collect(Collectors.toList())\n+        );\n+\n+        \/\/ for tracing purposes, use the direct caller to code in java.instrument as the source\n+        if (stack.size() > 0) {\n+            Class<?> callerClass = stack.get(0).getDeclaringClass();\n+            URL callerUrl = codeSource(callerClass);\n+            String source;\n+            if (callerUrl == null) {\n+                source = callerClass.getName();\n+            } else {\n+                source = callerClass.getName() + \" (\" + callerUrl + \")\";\n+            }\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"java.lang.instrument.Instrumentation.\")\n+                    .append(methodName)\n+                    .append(\" has been called by \")\n+                    .append(source);\n+            stack.forEach(f -> sb.append(System.lineSeparator()).append(\"\\tat \" + f));\n+            String traceMessage = sb.toString();\n+            System.out.println(traceMessage);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the possibly-bnull code source of the given class.\n+     *\/\n+    private static URL codeSource(Class<?> clazz) {\n+        PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        return (cs != null) ? cs.getLocation() : null;\n+    }\n+\n+    \/**\n+     * Holder for StackWalker object.\n+     *\/\n+    private static class HolderStackWalker {\n+        static final StackWalker walker;\n+        static {\n+            PrivilegedAction<StackWalker> pa = () ->\n+                    StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            @SuppressWarnings(\"removal\")\n+            StackWalker w = AccessController.doPrivileged(pa);\n+            walker = w;\n+        }\n+    }\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":197,"deletions":71,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,12 @@\n+\n+\/*\n+ * Class:     sun_instrument_InstrumentationImpl\n+ * Method:    jarFile\n+ * Signature: (J)Ljava\/lang\/String;\n+ *\/\n+JNIEXPORT jstring JNICALL\n+Java_sun_instrument_InstrumentationImpl_jarFile\n+  (JNIEnv * jnienv, jobject implThis, jlong agent) {\n+    return jarFile(jnienv, (JPLISAgent*)(intptr_t)agent);\n+}\n+\n@@ -60,1 +72,1 @@\n- * Signature: (Ljava\/lang\/Class;)Z\n+ * Signature: (JLjava\/lang\/Class;)Z\n@@ -71,1 +83,1 @@\n- * Signature: ()Z\n+ * Signature: (J)Z\n@@ -82,1 +94,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -93,1 +105,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -104,1 +116,1 @@\n- * Signature: ([Ljava\/lang\/Class;)V\n+ * Signature: (J[Ljava\/lang\/Class;)V\n@@ -115,1 +127,1 @@\n- * Signature: ([Ljava\/lang\/instrument\/ClassDefinition;)V\n+ * Signature: (J[Ljava\/lang\/instrument\/ClassDefinition;)V\n@@ -125,1 +137,1 @@\n- * Signature: ()[Ljava\/lang\/Class;\n+ * Signature: (J)[Ljava\/lang\/Class;\n@@ -135,1 +147,1 @@\n- * Signature: (Ljava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n+ * Signature: (JLjava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n@@ -145,1 +157,1 @@\n- * Signature: (Ljava\/lang\/Object;)J\n+ * Signature: (JLjava\/lang\/Object;)J\n@@ -156,1 +168,1 @@\n- * Signature: (Ljava\/lang\/String;Z)V\n+ * Signature: (JLjava\/lang\/String;Z)V\n@@ -167,1 +179,1 @@\n- * Signature: ([Ljava\/lang\/String;Z)V\n+ * Signature: (J[Ljava\/lang\/String;Z)V\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InstrumentationImplNativeMethods.c","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -150,0 +150,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -151,1 +153,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n+        fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE);\n@@ -154,2 +164,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -160,8 +168,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n-            fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n-            return JNI_ERR;\n-        }\n-\n@@ -195,3 +195,0 @@\n-        \/* Save the jarfile name *\/\n-        agent->mJarfile = jarfile;\n-\n@@ -257,1 +254,0 @@\n-        if (options != NULL) free(options);\n@@ -262,0 +258,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -310,0 +311,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -318,1 +321,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(args, &jarfile, &options) != 0) {\n+        return JNI_ENOMEM;\n+    }\n+\n+    jboolean print_warning = JVM_PrintWarningAtDynamicAgentLoad();\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, print_warning);\n@@ -321,2 +332,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -328,7 +337,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(args, &jarfile, &options) != 0) {\n-            return JNI_ENOMEM;\n-        }\n-\n@@ -453,2 +455,0 @@\n-        free(jarfile);\n-        if (options != NULL) free(options);\n@@ -459,0 +459,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE || result != JNI_OK) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -489,5 +494,0 @@\n-    \/\/ create JPLISAgent with JVMTI environment\n-    if (createNewJPLISAgent(vm, &agent) != JPLIS_INIT_ERROR_NONE) {\n-        return JNI_ERR;\n-    }\n-\n@@ -500,0 +500,6 @@\n+    \/\/ create JPLISAgent with JVMTI environment\n+    if (createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE) != JPLIS_INIT_ERROR_NONE) {\n+        (*env)->ReleaseStringUTFChars(env, path, jarfile);\n+        return JNI_ERR;\n+    }\n+\n@@ -573,1 +579,1 @@\n-    if (jarfile != NULL) {\n+    if (result != JNI_OK && jarfile != NULL) {\n@@ -615,2 +621,0 @@\n-    free((void *)agent->mJarfile);\n-    agent->mJarfile = NULL;\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InvocationAdapter.c","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -66,1 +66,3 @@\n-                        jvmtiEnv *      jvmtienv);\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning);\n@@ -205,1 +207,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr) {\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning) {\n@@ -223,1 +225,3 @@\n-                                               jvmtienv);\n+                                               jvmtienv,\n+                                               jarfile,\n+                                               printWarning);\n@@ -254,1 +258,3 @@\n-                        jvmtiEnv *      jvmtienv) {\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning) {\n@@ -275,1 +281,2 @@\n-    agent->mJarfile                                  = NULL;\n+    agent->mJarfile                                  = jarfile;\n+    agent->mPrintWarning                             = printWarning;\n@@ -515,1 +522,2 @@\n-                                                agent->mNativeMethodPrefixAdded);\n+                                                agent->mNativeMethodPrefixAdded,\n+                                                agent->mPrintWarning);\n@@ -1608,0 +1616,5 @@\n+\n+jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent) {\n+    return (*jnienv)->NewStringUTF(jnienv, agent->mJarfile);\n+}\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.c","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZ)V\"\n+#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZZ)V\"\n@@ -111,0 +111,1 @@\n+    jboolean                mPrintWarning;          \/* print warning when started *\/\n@@ -154,1 +155,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr);\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning);\n@@ -275,0 +276,3 @@\n+extern jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent);\n+\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.h","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    vm.jvmti \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.DataOutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+\n+\/**\n+ * The \"application\" launched by DyamicLoadWarningTest.\n+ *\n+ * The application phones home, sends its pid to the test, waits for a reply, then exits.\n+ *\/\n+public class Application {\n+    public static void main(String[] args) throws Exception {\n+        InetAddress lh = InetAddress.getLoopbackAddress();\n+        int port = Integer.parseInt(args[0]);\n+        try (Socket s = new Socket(lh, port);\n+             DataOutputStream out = new DataOutputStream(s.getOutputStream())) {\n+\n+            \/\/ send pid\n+            long pid = ProcessHandle.current().pid();\n+            out.writeLong(pid);\n+\n+            \/\/ wait for shutdown\n+            s.getInputStream().read();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/Application.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307478\n+ * @summary Test that a warning is printed when an agent is dynamically loaded\n+ * @requires vm.jvmti\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib \/test\/jdk\n+ * @build Application JavaAgent\n+ * @run junit\/othervm\/native DynamicLoadWarningTest\n+ *\/\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Path;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+import java.util.stream.Stream;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class DynamicLoadWarningTest {\n+\n+    \/\/ JVM TI agent\n+    private static final String JVMTI_AGENT_LIB = \"JvmtiAgent\";\n+    private static String jvmtiAgentPath;\n+\n+    \/\/ Java agent\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    private static String javaAgent;\n+\n+    @BeforeAll\n+    static void createJavaAgent() throws Exception {\n+        \/\/ create JAR file with Java agent\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(new Attributes.Name(\"Agent-Class\"), \"JavaAgent\");\n+        Path jarfile = Path.of(\"javaagent.jar\");\n+        Path classes = Path.of(TEST_CLASSES);\n+        JarUtils.createJarFile(jarfile, man, classes, Path.of(\"JavaAgent.class\"));\n+        javaAgent = jarfile.toString();\n+\n+        \/\/ get absolute path to JVM TI agent\n+        String libname;\n+        if (Platform.isWindows()) {\n+            libname = JVMTI_AGENT_LIB + \".dll\";\n+        } else if (Platform.isOSX()) {\n+            libname = \"lib\" + JVMTI_AGENT_LIB + \".dylib\";\n+        } else {\n+            libname = \"lib\" + JVMTI_AGENT_LIB + \".so\";\n+        }\n+        jvmtiAgentPath = Path.of(Utils.TEST_NATIVE_PATH, libname)\n+                .toAbsolutePath()\n+                .toString();\n+    }\n+\n+    \/**\n+     * Test loading JVM TI agent into a running VM with the Attach API.\n+     *\/\n+    @Test\n+    void testLoadJvmtiAgent() throws Exception {\n+        String message = \"WARNING: A JVM TI agent has been dynamically loaded\";\n+\n+        \/\/ warning should be printed\n+        test((pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT_LIB)).shouldContain(message);\n+\n+        \/\/ no warning should be printed\n+        test((pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT_LIB), \"-XX:+EnableDynamicAgentLoading\")\n+                .shouldNotContain(message);\n+    }\n+\n+    \/**\n+     * Test loading JVM TI agent into a running VM with jcmd VMTI.agent_load command.\n+     *\/\n+    @Test\n+    void testJCmdJvmtiAgentLoad() throws Exception {\n+        String message = \"WARNING: A JVM TI agent has been dynamically loaded\";\n+\n+        \/\/ jcmd <pid> JVMTI.agent_load <agent>\n+        Op op = (pid, vm) -> {\n+            var jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(\"\"+pid)\n+                    .addToolArg(\"JVMTI.agent_load\")\n+                    .addToolArg(jvmtiAgentPath);\n+            var pb = new ProcessBuilder(jcmd.getCommand());\n+            int exitValue = ProcessTools.executeProcess(pb)\n+                    .outputTo(System.out)\n+                    .errorTo(System.out)\n+                    .getExitValue();\n+            assertEquals(0, exitValue);\n+        };\n+\n+        \/\/ warning should be printed\n+        test(op).shouldContain(message);\n+\n+        \/\/ no warning should be printed\n+        test(op, \"-XX:+EnableDynamicAgentLoading\").shouldNotContain(message);\n+    }\n+\n+    \/**\n+     * Test loading Java agent into a running VM.\n+     *\/\n+    @Test\n+    void testLoadJavaAgent() throws Exception {\n+        String message = \"WARNING: A Java agent has been loaded dynamically\";\n+\n+        \/\/ warning should be printed\n+        test((pid, vm) -> vm.loadAgent(javaAgent)).shouldContain(message);\n+\n+        \/\/ no warning should be printed\n+        test((pid, vm) -> vm.loadAgent(javaAgent), \"-XX:+EnableDynamicAgentLoading\")\n+                .shouldNotContain(message);\n+    }\n+\n+    private interface Op {\n+        void accept(long pid, VirtualMachine vm) throws Exception;\n+    }\n+\n+    \/**\n+     * Starts a new VM to run an application, attaches to the VM, runs a given action\n+     * with the VirtualMachine object, and returns the output (both stdout and stderr)\n+     * for analysis.\n+     *\/\n+    private OutputAnalyzer test(Op action, String... vmopts) throws Exception {\n+        \/\/ start a listener socket that the application will connect to\n+        try (ServerSocket listener = new ServerSocket()) {\n+            InetAddress lh = InetAddress.getLoopbackAddress();\n+            listener.bind(new InetSocketAddress(lh, 0));\n+\n+            var done = new AtomicBoolean();\n+\n+            \/\/ start a thread to wait for the application to phone home\n+            Thread.ofPlatform().daemon().start(() -> {\n+                try (Socket s = listener.accept();\n+                     DataInputStream in = new DataInputStream(s.getInputStream())) {\n+\n+                    \/\/ read pid\n+                    long pid = in.readLong();\n+\n+                    \/\/ attach and run the action with the vm object\n+                    VirtualMachine vm = VirtualMachine.attach(\"\"+pid);\n+                    try {\n+                        action.accept(pid, vm);\n+                        done.set(true);\n+                    } finally {\n+                        vm.detach();\n+                    }\n+\n+                    \/\/ shutdown\n+                    s.getOutputStream().write(0);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+\n+            \/\/ launch application with the given VM options, waiting for it to terminate\n+            Stream<String> s1 = Stream.of(vmopts);\n+            Stream<String> s2 = Stream.of(\"Application\", \"\"+listener.getLocalPort());\n+            String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+            OutputAnalyzer outputAnalyzer = ProcessTools\n+                    .executeTestJava(opts)\n+                    .outputTo(System.out)\n+                    .errorTo(System.out);\n+            assertEquals(0, outputAnalyzer.getExitValue());\n+            assertTrue(done.get(), \"Attach or action failed, see log for details\");\n+\n+            return outputAnalyzer;\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -23,3 +23,6 @@\n-public class A {\n-    public static void main(String[] args) throws Exception {\n-        B.go();\n+\n+\/**\n+ * A no-op Java agent.\n+ *\/\n+public class JavaAgent {\n+    public static void agentmain(String args) {\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/JavaAgent.java","additions":6,"deletions":3,"binary":false,"changes":9,"previous_filename":"test\/lib-test\/jdk\/test\/lib\/process\/proc\/A.java","status":"copied"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * Agent used by TraceUsageTest. The premain and agentmain methods invoke Instrumentation\n+ * methods so the usages can be traced by the test.\n+ *\/\n+public class TraceUsageAgent {\n+    public static void premain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    public static void agentmain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    private static void test(String methodNames, Instrumentation inst) throws Exception {\n+        for (String methodName : methodNames.split(\",\")) {\n+            switch (methodName) {\n+                case \"addTransformer\" -> {\n+                    var transformer = new ClassFileTransformer() { };\n+                    inst.addTransformer(transformer);\n+                }\n+                case \"retransformClasses\" -> {\n+                    inst.retransformClasses(Object.class);\n+                }\n+                case \"redefineModule\" -> {\n+                    Module base = Object.class.getModule();\n+                    inst.redefineModule(base, Set.of(), Map.of(), Map.of(), Set.of(), Map.of());\n+                }\n+                default -> {\n+                    throw new RuntimeException(\"Unknown method name: \" + methodName);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageAgent.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307478\n+ * @summary Test Instrumentation tracing is enabled with a system property\n+ * @library \/test\/lib\n+ * @run shell MakeJAR3.sh TraceUsageAgent 'Agent-Class: TraceUsageAgent' 'Can-Retransform-Classes: true'\n+ * @run junit TraceUsageTest\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TraceUsageTest {\n+    private static final String JAVA_AGENT = \"TraceUsageAgent.jar\";\n+\n+    \/\/ Instrumentation methods to test\n+    private static final String[] INSTRUMENTATION_METHODS = {\n+            \"addTransformer\",\n+            \"retransformClasses\",\n+            \"redefineModule\"\n+    };\n+\n+    \/**\n+     * If launched with the argument \"attach\" then it loads the java agent into the\n+     * current VM with the given options.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0 && args[0].equals(\"attach\")) {\n+            String options = args[1];\n+            long pid = ProcessHandle.current().pid();\n+            VirtualMachine vm = VirtualMachine.attach(\"\"+pid);\n+            try {\n+                vm.loadAgent(JAVA_AGENT, options);\n+            } finally {\n+                vm.detach();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test agent started on the command line with -javaagent.\n+     *\/\n+    @Test\n+    void testPremain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-javaagent:\" + JAVA_AGENT + \"=\" + String.join(\",\", INSTRUMENTATION_METHODS),\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\"\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.premain\");\n+    }\n+\n+    \/**\n+     * Test agent loaded into a running VM with the attach mechanism.\n+     *\/\n+    @Test\n+    void testAgentmain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-Djdk.attach.allowAttachSelf=true\",\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\",\n+                \"attach\",\n+                String.join(\",\", INSTRUMENTATION_METHODS)\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.agentmain\");\n+    }\n+\n+    private OutputAnalyzer execute(String... command) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        assertEquals(0, outputAnalyzer.getExitValue());\n+        return outputAnalyzer;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}