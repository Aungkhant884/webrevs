{"files":[{"patch":"@@ -184,0 +184,1 @@\n+JVM_PrintWarningAtDynamicAgentLoad\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1167,0 +1167,6 @@\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_PrintWarningAtDynamicAgentLoad(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4027,0 +4027,7 @@\n+\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JVM_LEAF(jboolean, JVM_PrintWarningAtDynamicAgentLoad(void))\n+  return (EnableDynamicAgentLoading && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading)) ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -643,0 +643,11 @@\n+    The VM prints a warning on the standard error stream for each agent that it attempts\n+    to start in the live phase. If an agent was previously started (in the <code>OnLoad<\/code>\n+    phase or in the live phase), then it is implementation specific as to whether a\n+    warning is printed when attempting to start the same agent a second or subsequent time.\n+    Warnings can be disabled by means of an implementation-specific command line option.\n+    <p\/>\n+    <b>Implementation Note:<\/b> For the HotSpot VM, the VM option\n+    <code>-XX:+EnableDynamicAgentLoading<\/code> is used to opt-in to allow dynamic loading\n+    of agents in the live phase. This option suppresses the warning to standard error when\n+    starting an agent in the live phase.\n+    <p\/>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -40,0 +42,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -263,1 +266,1 @@\n-\/\/ For statically linked agents we cant't rely on os_lib == nullptr because\n+\/\/ For statically linked agents we can't rely on os_lib == nullptr because\n@@ -265,1 +268,1 @@\n-\/\/ If this function returns true, then agent->is_static_lib().&& agent->is_loaded().\n+\/\/ If this function returns true, then agent->is_static_lib() && agent->is_loaded().\n@@ -494,1 +497,4 @@\n-  if (!load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+  bool previously_loaded;\n+  if (load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+    previously_loaded = JvmtiAgentList::is_static_lib_loaded(agent->name());\n+  } else {\n@@ -506,0 +512,9 @@\n+    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(library);\n+  }\n+\n+  \/\/ Print warning if agent was not previously loaded and EnableDynamicAgentLoading not enabled on the command line.\n+  if (!previously_loaded && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib()) {\n+    jio_fprintf(defaultStream::error_stream(),\n+      \"WARNING: A JVM TI agent has been loaded dynamically (%s)\\n\"\n+      \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n+      \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n@@ -507,0 +522,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -223,0 +223,24 @@\n+\/\/ Return true if a statically linked agent is on the list\n+bool JvmtiAgentList::is_static_lib_loaded(const char* name) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (agent->is_static_lib() && strcmp(agent->name(), name) == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Return true if a agent library on the list\n+bool JvmtiAgentList::is_dynamic_lib_loaded(void* os_lib) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (!agent->is_static_lib() && agent->os_lib() == os_lib) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  static bool is_static_lib_loaded(const char* name);\n+  static bool is_dynamic_lib_loaded(void* os_lib);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * programs running on the JVM. The mechanism for instrumentation is modification\n- * of the byte-codes of methods.\n+ * programs running on the Java Virtual Machine (JVM). The mechanism for\n+ * instrumentation is modification of the bytecodes of methods.\n@@ -35,3 +35,6 @@\n- * <p> An agent is deployed as a JAR file. An attribute in the JAR file manifest\n- * specifies the agent class which will be loaded to start the agent. Agents can\n- * be started in several ways:\n+ * <p> The class files that comprise an agent are packaged into a JAR file, either\n+ * with the application in an executable JAR, or more commonly, as a separate JAR file\n+ * called an <em>agent JAR<\/em>. An attribute in the main manifest of the JAR file\n+ * identifies one of the class files in the JAR file as the <em>agent class<\/em>.\n+ * The agent class defines a special method that the JVM invokes to <em>start<\/em>\n+ * the agent.\n@@ -39,12 +42,4 @@\n- * <ol>\n- *   <li><p> For implementations that support a command-line interface, an agent\n- *   can be started by specifying an option on the command-line. <\/p><\/li>\n- *\n- *   <li><p> An implementation may support a mechanism to start agents some time\n- *   after the VM has started. For example, an implementation may provide a\n- *   mechanism that allows a tool to <i>attach<\/i> to a running application, and\n- *   initiate the loading of the tool's agent into the running application. <\/p><\/li>\n- *\n- *   <li><p> An agent may be packaged with an application in an executable JAR\n- *   file.<\/p><\/li>\n- * <\/ol>\n+ * <p> Agents that are packaged with an application in an executable JAR are started\n+ * at JVM statup time. Agents that are packaged into an agent JAR file may be started\n+ * at JVM startup time via a command line option, or where an implementation supports\n+ * it, started in a running JVM.\n@@ -59,1 +54,29 @@\n- * <p> The three ways to start an agent are described below.\n+ * <h2>Starting an agent<\/h2>\n+ *\n+ * <h3>Starting an agent packaged with an application in an executable JAR file<\/h3>\n+ *\n+ * <p> The <a href=\"{@docRoot}\/..\/specs\/jar\/jar.html\">JAR File Specification<\/a> defines\n+ * manifest attributes for standalone applications that are packaged as <em>executable\n+ * JAR files<\/em>. If an implementation supports a mechanism to start an application as\n+ * an executable JAR, then the main manifest of the JAR file can include the\n+ * {@code Launcher-Agent-Class} attribute to specify the binary name of the Java agent\n+ * class that is packaged with the application. If the attribute is present then the\n+ * JVM starts the agent by loading the agent class and invoking its {@code agentmain}\n+ * method. The method is invoked before the application {@code main} method is invoked.\n+ * The {@code agentmain} method has one of two possible signatures. The JVM first\n+ * attempts to invoke the following method on the agent class:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs, Instrumentation inst)\n+ * }<\/blockquote>\n+ *\n+ * <p> If the agent class does not define this method then the JVM will attempt\n+ * to invoke:\n+ *\n+ * <blockquote>{@code\n+ *     public static void agentmain(String agentArgs)\n+ * }<\/blockquote>\n+ *\n+ * <p> The value of the {@code agentArgs} parameter is always the empty string. In\n+ * the first method, the {@code inst} parameter is an {@link Instrumentation} object\n+ * that the agent can use to instrument code.\n@@ -61,1 +84,6 @@\n- * <h2>Starting an Agent from the Command-Line Interface<\/h2>\n+ * <p> The {@code agentmain} method should do any necessary initialization\n+ * required to start the agent and return. If the agent cannot be started, for\n+ * example the agent class cannot be loaded, the agent class does not define a\n+ * conformant {@code agentmain} method, or the {@code agentmain} method throws\n+ * an uncaught exception or error, the JVM will abort before the application\n+ * {@code main} method is invoked.\n@@ -63,3 +91,4 @@\n- * <p> Where an implementation provides a means to start agents from the\n- * command-line interface, an agent is started by adding the following option\n- * to the command-line:\n+ * <h3>Starting an agent from the command-line interface<\/h3>\n+ *\n+ * <p> Where an implementation provides a means to start agents from the command-line\n+ * interface, an agent JAR is specified via the following command line option:\n@@ -74,11 +103,6 @@\n- * <p> The manifest of the agent JAR file must contain the attribute {@code\n- * Premain-Class} in its main manifest. The value of this attribute is the\n- * name of the <i>agent class<\/i>. The agent class must implement a public\n- * static {@code premain} method similar in principle to the {@code main}\n- * application entry point. After the Java Virtual Machine (JVM) has\n- * initialized, the {@code premain} method will be called, then the real\n- * application {@code main} method. The {@code premain} method must return\n- * in order for the startup to proceed.\n- *\n- * <p> The {@code premain} method has one of two possible signatures. The\n- * JVM first attempts to invoke the following method on the agent class:\n+ * <p> The main manifest of the agent JAR file must contain the attribute {@code\n+ * Premain-Class}. The value of this attribute is the binary name of the agent class\n+ * in the JAR file. The JVM starts the agent by loading the agent class and invoking its\n+ * {@code premain} method. The method is invoked before the application {@code main}\n+ * method is invoked. The {@code premain} method has one of two possible signatures.\n+ * The JVM first attempts to invoke the following method on the agent class:\n@@ -90,2 +114,1 @@\n- * <p> If the agent class does not implement this method then the JVM will\n- * attempt to invoke:\n+ * <p> If the agent class does not define this method then the JVM will attempt to invoke:\n@@ -95,4 +118,0 @@\n-\n- * <p> The agent class may also have an {@code agentmain} method for use when\n- * the agent is started after VM startup (see below). When the agent is started\n- * using a command-line option, the {@code agentmain} method is not invoked.\n@@ -100,1 +119,1 @@\n- * <p> Each agent is passed its agent options via the {@code agentArgs} parameter.\n+ * <p> The agent is passed its agent options via the {@code agentArgs} parameter.\n@@ -102,1 +121,3 @@\n- * should be performed by the agent itself.\n+ * should be performed by the agent itself. In the first method, the {@code inst}\n+ * parameter is an {@link Instrumentation} object that the agent can use to instrument\n+ * code.\n@@ -104,4 +125,4 @@\n- * <p> If the agent cannot be started (for example, because the agent class\n- * cannot be loaded, or because the agent class does not have an appropriate\n- * {@code premain} method), the JVM will abort. If a {@code premain} method\n- * throws an uncaught exception, the JVM will abort.\n+ * <p> If the agent cannot be started, for example the agent class cannot be loaded,\n+ * the agent class does not define a conformant {@code premain} method, or the {@code\n+ * premain} method throws an uncaught exception or error, the JVM will abort before\n+ * the application {@code main} method is invoked.\n@@ -117,6 +138,3 @@\n- * <p> There are no modeling restrictions on what the agent {@code premain}\n- * method may do. Anything application {@code main} can do, including creating\n- * threads, is legal from {@code premain}.\n- *\n- *\n- * <h2>Starting an Agent After VM Startup<\/h2>\n+ * <p> The agent class may also have an {@code agentmain} method for use when the agent\n+ * is started after in a running JVM (see below). When the agent is started using a\n+ * command-line option, the {@code agentmain} method is not invoked.\n@@ -124,6 +142,1 @@\n- * <p> An implementation may provide a mechanism to start agents sometime after\n- * the VM has started. The details as to how this is initiated are\n- * implementation specific but typically the application has already started and\n- * its {@code main} method has already been invoked. In cases where an\n- * implementation supports the starting of agents after the VM has started the\n- * following applies:\n+ * <h3>Starting an agent in a running JVM<\/h3>\n@@ -131,0 +144,5 @@\n+ * <p> An implementation may provide a mechanism to start agents in a running JVM (meaning\n+ * after JVM startup). The details as to how this is initiated are implementation specific\n+ * but typically the application has already started, and its {@code main} method has\n+ * already been invoked. Where an implementation supports starting an agent in a running\n+ * JVM, the following applies:\n@@ -133,3 +151,3 @@\n- *   <li><p> The manifest of the agent JAR must contain the attribute {@code\n- *   Agent-Class} in its main manfiest. The value of this attribute is the name\n- *   of the <i>agent class<\/i>. <\/p><\/li>\n+ *   <li><p> The agent class must be packaged into an agent JAR file. The main manifest\n+ *   of the agent JAR file must contain the attribute {@code Agent-Class}. The value of\n+ *   this attribute is the binary name of the agent class in the JAR file. <\/p><\/li>\n@@ -137,2 +155,12 @@\n- *   <li><p> The agent class must implement a public static {@code agentmain}\n- *   method. <\/p><\/li>\n+ *   <li><p> The agent class must define a public static {@code agentmain} method. <\/p><\/li>\n+ *\n+ *   <li><p> The JVM prints a warning on the standard error stream for each agent that it\n+ *   attempts to start in a running JVM. If an agent was previously started (at JVM\n+ *   startup, or started in a running JVM), then it is implementation specific as to whether\n+ *   a warning is printed when attempting to start the same agent a second or subsequent\n+ *   time. Warnings can be disabled by means of an implementation-specific command line\n+ *   option.\n+ *   <p><b>Implementation Note:<\/b> For the HotSpot VM, the JVM option\n+ *   {@code -XX:+EnableDynamicAgentLoading} is used to opt-in to allow dynamic loading of\n+ *   agents into a running JVM. This option suppresses the warning to standard error when\n+ *   starting an agent in a running JVM. <\/p><\/li>\n@@ -142,2 +170,3 @@\n- * <p> The {@code agentmain} method has one of two possible signatures. The JVM\n- * first attempts to invoke the following method on the agent class:\n+ * <p> The JVM starts the agent by loading the agent class and invoking its {@code\n+ * agentmain} method. The {@code agentmain} method has one of two possible signatures.\n+ * The JVM first attempts to invoke the following method on the agent class:\n@@ -149,1 +178,1 @@\n- * <p> If the agent class does not implement this method then the JVM will\n+ * <p> If the agent class does not define this method then the JVM will\n@@ -156,7 +185,5 @@\n- * <p> The agent class may also have a {@code premain} method for use when the\n- * agent is started using a command-line option. When the agent is started after\n- * VM startup the {@code premain} method is not invoked.\n- *\n- * <p> The agent is passed its agent options via the {@code agentArgs}\n- * parameter. The agent options are passed as a single string, any additional\n- * parsing should be performed by the agent itself.\n+ * <p> The agent is passed its agent options via the {@code agentArgs} parameter.\n+ * The agent options are passed as a single string, any additional parsing\n+ * should be performed by the agent itself. In the first method, the {@code inst}\n+ * parameter is an {@link Instrumentation} object that the agent can use to instrument\n+ * code.\n@@ -172,30 +199,3 @@\n- *\n- * <h2>Including an Agent in an Executable JAR file<\/h2>\n- *\n- * <p> The JAR File Specification defines manifest attributes for standalone\n- * applications that are packaged as <em>executable JAR files<\/em>. If an\n- * implementation supports a mechanism to start an application as an executable\n- * JAR then the main manifest may include the {@code Launcher-Agent-Class}\n- * attribute to specify the class name of an agent to start before the application\n- * {@code main} method is invoked. The Java virtual machine attempts to\n- * invoke the following method on the agent class:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs, Instrumentation inst)\n- * }<\/blockquote>\n- *\n- * <p> If the agent class does not implement this method then the JVM will\n- * attempt to invoke:\n- *\n- * <blockquote>{@code\n- *     public static void agentmain(String agentArgs)\n- * }<\/blockquote>\n- *\n- * <p> The value of the {@code agentArgs} parameter is always the empty string.\n- *\n- * <p> The {@code agentmain} method should do any necessary initialization\n- * required to start the agent and return. If the agent cannot be started, for\n- * example the agent class cannot be loaded, the agent class does not define a\n- * conformant {@code agentmain} method, or the {@code agentmain} method throws\n- * an uncaught exception or error, the JVM will abort.\n- *\n+ * <p> The agent class may also have a {@code premain} method for use when the agent\n+ * is started using a command-line option. The {@code premain} method is not invoked\n+ * when the agent is started in a running JVM.\n@@ -251,1 +251,1 @@\n- * <h2>Manifest Attributes<\/h2>\n+ * <h2>JAR File Manifest Attributes<\/h2>\n@@ -253,1 +253,2 @@\n- * <p> The following manifest attributes are defined for an agent JAR file:\n+ * <p> The following attributes in the main section of the application or agent\n+ * JAR file manifest are defined for Java agents:\n@@ -257,0 +258,7 @@\n+ * <dt>{@code Launcher-Agent-Class}<\/dt>\n+ * <dd> If an implementation supports a mechanism to start an application in an\n+ * executable JAR file, then this attribute, if present, specifies the binary name\n+ * of the agent class that is packaged with the application.\n+ * The agent is started by invoking the agent class {@code agentmain} method. It is\n+ * invoked before the application {@code main} method is invoked. <\/dd>\n+ *\n@@ -258,5 +266,5 @@\n- * <dd> When an agent is specified at JVM launch time this attribute specifies\n- * the agent class. That is, the class containing the {@code premain} method.\n- * When an agent is specified at JVM launch time this attribute is required. If\n- * the attribute is not present the JVM will abort. Note: this is a class name,\n- * not a file name or path. <\/dd>\n+ * <dd> If an agent JAR is specified at JVM launch time, this attribute specifies\n+ * the binary name of the agent class in the JAR file.\n+ * The agent is started by invoking the agent class {@code premain} method. It is\n+ * invoked before the application {@code main} method is invoked.\n+ * If the attribute is not present the JVM will abort. <\/dd>\n@@ -265,11 +273,5 @@\n- * <dd> If an implementation supports a mechanism to start agents sometime after\n- * the VM has started then this attribute specifies the agent class. That is,\n- * the class containing the {@code agentmain} method. This attribute is required\n- * if it is not present the agent will not be started. Note: this is a class name,\n- * not a file name or path. <\/dd>\n- *\n- * <dt>{@code Launcher-Agent-Class}<\/dt>\n- * <dd> If an implementation supports a mechanism to start an application as an\n- * executable JAR then the main manifest may include this attribute to specify\n- * the class name of an agent to start before the application {@code main}\n- * method is invoked. <\/dd>\n+ * <dd> If an implementation supports a mechanism to start an agent sometime after\n+ * the JVM has started, then this attribute specifies the binary name of the Java\n+ * agent class in the agent JAR file.\n+ * The agent is started by invoking the agent class {@code agentmain} method.\n+ * This attribute is required; if not present the agent will not be started. <\/dd>\n@@ -287,1 +289,1 @@\n- * started sometime after the VM has started then paths that do not represent a\n+ * started sometime after the JVM has started then paths that do not represent a\n@@ -313,1 +315,1 @@\n- * Premain-Class} attribute specifies the name of the agent class and the {@code\n+ * Premain-Class} attribute specifies the binary name of the agent class and the {@code\n@@ -315,2 +317,2 @@\n- * after the VM has started, then the {@code Agent-Class} attribute specifies\n- * the name of the agent class (the value of {@code Premain-Class} attribute is\n+ * after the JVM has started, then the {@code Agent-Class} attribute specifies\n+ * the binary name of the agent class (the value of {@code Premain-Class} attribute is\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/package-info.java","additions":127,"deletions":125,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.nio.file.InvalidPathException;\n+import java.net.URL;\n@@ -36,0 +40,1 @@\n+import java.security.CodeSource;\n@@ -46,1 +51,1 @@\n-\n+import java.util.stream.Collectors;\n@@ -62,0 +67,9 @@\n+    private static final String TRACE_USAGE_PROP_NAME = \"jdk.instrument.traceUsage\";\n+    private static final boolean TRACE_USAGE;\n+    static {\n+        PrivilegedAction<String> pa = () -> System.getProperty(TRACE_USAGE_PROP_NAME);\n+        @SuppressWarnings(\"removal\")\n+        String s = AccessController.doPrivileged(pa);\n+        TRACE_USAGE = (s != null) && (s.isEmpty() || Boolean.parseBoolean(s));\n+    }\n+\n@@ -74,1 +88,2 @@\n-                        boolean environmentSupportsNativeMethodPrefix) {\n+                        boolean environmentSupportsNativeMethodPrefix,\n+                        boolean printWarning) {\n@@ -82,0 +97,30 @@\n+\n+        if (printWarning) {\n+            String source = jarFile(nativeAgent);\n+            try {\n+                Path path = Path.of(source);\n+                PrivilegedAction<Path> pa = path::toAbsolutePath;\n+                @SuppressWarnings(\"removal\")\n+                Path absolutePath = AccessController.doPrivileged(pa);\n+                source = absolutePath.toString();\n+            } catch (InvalidPathException e) {\n+                \/\/ use original path\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"WARNING: A Java agent has been loaded dynamically (\")\n+                    .append(source)\n+                    .append(\")\")\n+                    .append(System.lineSeparator());\n+            sb.append(\"WARNING: If a serviceability tool is in use, please run with\"\n+                            + \" -XX:+EnableDynamicAgentLoading to hide this warning\")\n+                    .append(System.lineSeparator());\n+            if (!TRACE_USAGE) {\n+                sb.append(\"WARNING: If a serviceability tool is not in use, please run with\"\n+                                + \" -D\" + TRACE_USAGE_PROP_NAME + \" for more information\")\n+                        .append(System.lineSeparator());\n+            }\n+            sb.append(\"WARNING: Dynamic loading of agents will be disallowed by default in a future release\");\n+            String warningMessage = sb.toString();\n+            System.err.println(warningMessage);\n+        }\n@@ -84,2 +129,2 @@\n-    public void\n-    addTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer) {\n@@ -89,2 +134,3 @@\n-    public synchronized void\n-    addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+    @Override\n+    public void addTransformer(ClassFileTransformer transformer, boolean canRetransform) {\n+        trace(\"addTransformer\");\n@@ -94,16 +140,18 @@\n-        if (canRetransform) {\n-            if (!isRetransformClassesSupported()) {\n-                throw new UnsupportedOperationException(\n-                  \"adding retransformable transformers is not supported in this environment\");\n-            }\n-            if (mRetransfomableTransformerManager == null) {\n-                mRetransfomableTransformerManager = new TransformerManager(true);\n-            }\n-            mRetransfomableTransformerManager.addTransformer(transformer);\n-            if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n-                setHasRetransformableTransformers(mNativeAgent, true);\n-            }\n-        } else {\n-            mTransformerManager.addTransformer(transformer);\n-            if (mTransformerManager.getTransformerCount() == 1) {\n-                setHasTransformers(mNativeAgent, true);\n+        synchronized (this) {\n+            if (canRetransform) {\n+                if (!isRetransformClassesSupported()) {\n+                    throw new UnsupportedOperationException(\n+                        \"adding retransformable transformers is not supported in this environment\");\n+                }\n+                if (mRetransfomableTransformerManager == null) {\n+                    mRetransfomableTransformerManager = new TransformerManager(true);\n+                }\n+                mRetransfomableTransformerManager.addTransformer(transformer);\n+                if (mRetransfomableTransformerManager.getTransformerCount() == 1) {\n+                    setHasRetransformableTransformers(mNativeAgent, true);\n+                }\n+            } else {\n+                mTransformerManager.addTransformer(transformer);\n+                if (mTransformerManager.getTransformerCount() == 1) {\n+                    setHasTransformers(mNativeAgent, true);\n+                }\n@@ -114,2 +162,3 @@\n-    public synchronized boolean\n-    removeTransformer(ClassFileTransformer transformer) {\n+    @Override\n+    public boolean removeTransformer(ClassFileTransformer transformer) {\n+        trace(\"removeTransformer\");\n@@ -119,8 +168,10 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr != null) {\n-            mgr.removeTransformer(transformer);\n-            if (mgr.getTransformerCount() == 0) {\n-                if (mgr.isRetransformable()) {\n-                    setHasRetransformableTransformers(mNativeAgent, false);\n-                } else {\n-                    setHasTransformers(mNativeAgent, false);\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr != null) {\n+                mgr.removeTransformer(transformer);\n+                if (mgr.getTransformerCount() == 0) {\n+                    if (mgr.isRetransformable()) {\n+                        setHasRetransformableTransformers(mNativeAgent, false);\n+                    } else {\n+                        setHasTransformers(mNativeAgent, false);\n+                    }\n@@ -128,0 +179,1 @@\n+                return true;\n@@ -129,1 +181,1 @@\n-            return true;\n+            return false;\n@@ -131,1 +183,0 @@\n-        return false;\n@@ -134,2 +185,3 @@\n-    public boolean\n-    isModifiableClass(Class<?> theClass) {\n+    @Override\n+    public boolean isModifiableClass(Class<?> theClass) {\n+        trace(\"isModifiableClass\");\n@@ -143,0 +195,1 @@\n+    @Override\n@@ -144,0 +197,1 @@\n+        trace(\"isModifiableModule\");\n@@ -150,2 +204,3 @@\n-    public boolean\n-    isRetransformClassesSupported() {\n+    @Override\n+    public boolean isRetransformClassesSupported() {\n+        trace(\"isRetransformClassesSupported\");\n@@ -160,2 +215,3 @@\n-    public void\n-    retransformClasses(Class<?>... classes) {\n+    @Override\n+    public void retransformClasses(Class<?>... classes) {\n+        trace(\"retransformClasses\");\n@@ -172,2 +228,3 @@\n-    public boolean\n-    isRedefineClassesSupported() {\n+    @Override\n+    public boolean isRedefineClassesSupported() {\n+        trace(\"isRedefineClassesSupported\");\n@@ -177,3 +234,3 @@\n-    public void\n-    redefineClasses(ClassDefinition...  definitions)\n-            throws  ClassNotFoundException {\n+    @Override\n+    public void redefineClasses(ClassDefinition... definitions) throws ClassNotFoundException {\n+        trace(\"retransformClasses\");\n@@ -194,1 +251,0 @@\n-\n@@ -198,0 +254,1 @@\n+    @Override\n@@ -199,2 +256,2 @@\n-    public Class[]\n-    getAllLoadedClasses() {\n+    public Class[] getAllLoadedClasses() {\n+        trace(\"getAllLoadedClasses\");\n@@ -204,0 +261,1 @@\n+    @Override\n@@ -205,2 +263,2 @@\n-    public Class[]\n-    getInitiatedClasses(ClassLoader loader) {\n+    public Class[] getInitiatedClasses(ClassLoader loader) {\n+        trace(\"getInitiatedClasses\");\n@@ -210,2 +268,3 @@\n-    public long\n-    getObjectSize(Object objectToSize) {\n+    @Override\n+    public long getObjectSize(Object objectToSize) {\n+        trace(\"getObjectSize\");\n@@ -218,2 +277,3 @@\n-    public void\n-    appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToBootstrapClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToBootstrapClassLoaderSearch\");\n@@ -223,2 +283,3 @@\n-    public void\n-    appendToSystemClassLoaderSearch(JarFile jarfile) {\n+    @Override\n+    public void appendToSystemClassLoaderSearch(JarFile jarfile) {\n+        trace(\"appendToSystemClassLoaderSearch\");\n@@ -228,2 +289,3 @@\n-    public boolean\n-    isNativeMethodPrefixSupported() {\n+    @Override\n+    public boolean isNativeMethodPrefixSupported() {\n+        trace(\"isNativeMethodPrefixSupported\");\n@@ -233,2 +295,3 @@\n-    public synchronized void\n-    setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+    @Override\n+    public void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix) {\n+        trace(\"setNativeMethodPrefix\");\n@@ -243,4 +306,9 @@\n-        TransformerManager mgr = findTransformerManager(transformer);\n-        if (mgr == null) {\n-            throw new IllegalArgumentException(\n-                       \"transformer not registered in setNativeMethodPrefix\");\n+        synchronized (this) {\n+            TransformerManager mgr = findTransformerManager(transformer);\n+            if (mgr == null) {\n+                throw new IllegalArgumentException(\n+                        \"transformer not registered in setNativeMethodPrefix\");\n+            }\n+            mgr.setNativeMethodPrefix(transformer, prefix);\n+            String[] prefixes = mgr.getNativeMethodPrefixes();\n+            setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -248,3 +316,0 @@\n-        mgr.setNativeMethodPrefix(transformer, prefix);\n-        String[] prefixes = mgr.getNativeMethodPrefixes();\n-        setNativeMethodPrefixes(mNativeAgent, prefixes, mgr.isRetransformable());\n@@ -261,0 +326,2 @@\n+        trace(\"redefineModule\");\n+\n@@ -300,1 +367,0 @@\n-\n@@ -354,2 +420,2 @@\n-    private TransformerManager\n-    findTransformerManager(ClassFileTransformer transformer) {\n+    private TransformerManager findTransformerManager(ClassFileTransformer transformer) {\n+        assert Thread.holdsLock(this);\n@@ -370,0 +436,3 @@\n+    private native\n+    String jarFile(long nativeAgent);\n+\n@@ -560,0 +629,57 @@\n+\n+    \/**\n+     * Prints a trace message and stack trace when tracing is enabled.\n+     *\/\n+    private void trace(String methodName) {\n+        if (!TRACE_USAGE) return;\n+\n+        \/\/ stack trace without frames in java.instrument module\n+        List<StackWalker.StackFrame> stack = HolderStackWalker.walker.walk(s ->\n+            s.dropWhile(f -> f.getDeclaringClass().getModule() == Instrumentation.class.getModule())\n+                .collect(Collectors.toList())\n+        );\n+\n+        \/\/ for tracing purposes, use the direct caller to code in java.instrument as the source\n+        if (stack.size() > 0) {\n+            Class<?> callerClass = stack.get(0).getDeclaringClass();\n+            URL callerUrl = codeSource(callerClass);\n+            String source;\n+            if (callerUrl == null) {\n+                source = callerClass.getName();\n+            } else {\n+                source = callerClass.getName() + \" (\" + callerUrl + \")\";\n+            }\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"java.lang.instrument.Instrumentation.\")\n+                    .append(methodName)\n+                    .append(\" has been called by \")\n+                    .append(source);\n+            stack.forEach(f -> sb.append(System.lineSeparator()).append(\"\\tat \" + f));\n+            String traceMessage = sb.toString();\n+            System.out.println(traceMessage);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the possibly-bnull code source of the given class.\n+     *\/\n+    private static URL codeSource(Class<?> clazz) {\n+        PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        return (cs != null) ? cs.getLocation() : null;\n+    }\n+\n+    \/**\n+     * Holder for StackWalker object.\n+     *\/\n+    private static class HolderStackWalker {\n+        static final StackWalker walker;\n+        static {\n+            PrivilegedAction<StackWalker> pa = () ->\n+                    StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            @SuppressWarnings(\"removal\")\n+            StackWalker w = AccessController.doPrivileged(pa);\n+            walker = w;\n+        }\n+    }\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":197,"deletions":71,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,12 @@\n+\n+\/*\n+ * Class:     sun_instrument_InstrumentationImpl\n+ * Method:    jarFile\n+ * Signature: (J)Ljava\/lang\/String;\n+ *\/\n+JNIEXPORT jstring JNICALL\n+Java_sun_instrument_InstrumentationImpl_jarFile\n+  (JNIEnv * jnienv, jobject implThis, jlong agent) {\n+    return jarFile(jnienv, (JPLISAgent*)(intptr_t)agent);\n+}\n+\n@@ -60,1 +72,1 @@\n- * Signature: (Ljava\/lang\/Class;)Z\n+ * Signature: (JLjava\/lang\/Class;)Z\n@@ -71,1 +83,1 @@\n- * Signature: ()Z\n+ * Signature: (J)Z\n@@ -82,1 +94,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -93,1 +105,1 @@\n- * Signature: (Z)V\n+ * Signature: (JZ)V\n@@ -104,1 +116,1 @@\n- * Signature: ([Ljava\/lang\/Class;)V\n+ * Signature: (J[Ljava\/lang\/Class;)V\n@@ -115,1 +127,1 @@\n- * Signature: ([Ljava\/lang\/instrument\/ClassDefinition;)V\n+ * Signature: (J[Ljava\/lang\/instrument\/ClassDefinition;)V\n@@ -125,1 +137,1 @@\n- * Signature: ()[Ljava\/lang\/Class;\n+ * Signature: (J)[Ljava\/lang\/Class;\n@@ -135,1 +147,1 @@\n- * Signature: (Ljava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n+ * Signature: (JLjava\/lang\/ClassLoader;)[Ljava\/lang\/Class;\n@@ -145,1 +157,1 @@\n- * Signature: (Ljava\/lang\/Object;)J\n+ * Signature: (JLjava\/lang\/Object;)J\n@@ -156,1 +168,1 @@\n- * Signature: (Ljava\/lang\/String;Z)V\n+ * Signature: (JLjava\/lang\/String;Z)V\n@@ -167,1 +179,1 @@\n- * Signature: ([Ljava\/lang\/String;Z)V\n+ * Signature: (J[Ljava\/lang\/String;Z)V\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InstrumentationImplNativeMethods.c","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -150,0 +150,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -151,1 +153,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n+        fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE);\n@@ -154,2 +164,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -160,8 +168,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(tail, &jarfile, &options) != 0) {\n-            fprintf(stderr, \"-javaagent: memory allocation failure.\\n\");\n-            return JNI_ERR;\n-        }\n-\n@@ -195,3 +195,0 @@\n-        \/* Save the jarfile name *\/\n-        agent->mJarfile = jarfile;\n-\n@@ -257,1 +254,0 @@\n-        if (options != NULL) free(options);\n@@ -262,0 +258,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -310,0 +311,2 @@\n+    char *                   jarfile    = NULL;\n+    char *                   options    = NULL;\n@@ -318,1 +321,9 @@\n-    initerror = createNewJPLISAgent(vm, &agent);\n+    \/*\n+     * Parse <jarfile>[=options] into jarfile and options\n+     *\/\n+    if (parseArgumentTail(args, &jarfile, &options) != 0) {\n+        return JNI_ENOMEM;\n+    }\n+\n+    jboolean print_warning = JVM_PrintWarningAtDynamicAgentLoad();\n+    initerror = createNewJPLISAgent(vm, &agent, jarfile, print_warning);\n@@ -321,2 +332,0 @@\n-        char *          jarfile;\n-        char *          options;\n@@ -328,7 +337,0 @@\n-        \/*\n-         * Parse <jarfile>[=options] into jarfile and options\n-         *\/\n-        if (parseArgumentTail(args, &jarfile, &options) != 0) {\n-            return JNI_ENOMEM;\n-        }\n-\n@@ -453,2 +455,0 @@\n-        free(jarfile);\n-        if (options != NULL) free(options);\n@@ -459,0 +459,5 @@\n+    if (initerror != JPLIS_INIT_ERROR_NONE || result != JNI_OK) {\n+        free(jarfile);\n+    }\n+    if (options != NULL) free(options);\n+\n@@ -489,5 +494,0 @@\n-    \/\/ create JPLISAgent with JVMTI environment\n-    if (createNewJPLISAgent(vm, &agent) != JPLIS_INIT_ERROR_NONE) {\n-        return JNI_ERR;\n-    }\n-\n@@ -500,0 +500,6 @@\n+    \/\/ create JPLISAgent with JVMTI environment\n+    if (createNewJPLISAgent(vm, &agent, jarfile, JNI_FALSE) != JPLIS_INIT_ERROR_NONE) {\n+        (*env)->ReleaseStringUTFChars(env, path, jarfile);\n+        return JNI_ERR;\n+    }\n+\n@@ -573,1 +579,1 @@\n-    if (jarfile != NULL) {\n+    if (result != JNI_OK && jarfile != NULL) {\n@@ -615,2 +621,0 @@\n-    free((void *)agent->mJarfile);\n-    agent->mJarfile = NULL;\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InvocationAdapter.c","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -66,1 +66,3 @@\n-                        jvmtiEnv *      jvmtienv);\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning);\n@@ -205,1 +207,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr) {\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning) {\n@@ -223,1 +225,3 @@\n-                                               jvmtienv);\n+                                               jvmtienv,\n+                                               jarfile,\n+                                               printWarning);\n@@ -254,1 +258,3 @@\n-                        jvmtiEnv *      jvmtienv) {\n+                        jvmtiEnv *      jvmtienv,\n+                        const char *    jarfile,\n+                        jboolean        printWarning) {\n@@ -275,1 +281,2 @@\n-    agent->mJarfile                                  = NULL;\n+    agent->mJarfile                                  = jarfile;\n+    agent->mPrintWarning                             = printWarning;\n@@ -515,1 +522,2 @@\n-                                                agent->mNativeMethodPrefixAdded);\n+                                                agent->mNativeMethodPrefixAdded,\n+                                                agent->mPrintWarning);\n@@ -1608,0 +1616,5 @@\n+\n+jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent) {\n+    return (*jnienv)->NewStringUTF(jnienv, agent->mJarfile);\n+}\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.c","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZ)V\"\n+#define JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE    \"(JZZZ)V\"\n@@ -111,0 +111,1 @@\n+    jboolean                mPrintWarning;          \/* print warning when started *\/\n@@ -154,1 +155,1 @@\n-createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr);\n+createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr, const char * jarfile, jboolean printWarning);\n@@ -275,0 +276,3 @@\n+extern jstring\n+jarFile(JNIEnv * jnienv, JPLISAgent * agent);\n+\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.h","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    vm.jvmti \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.DataOutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+\n+\/**\n+ * The \"application\" launched by DyamicLoadWarningTest.\n+ *\n+ * The application phones home, sends its pid to the test, waits for a reply, then exits.\n+ *\/\n+public class Application {\n+    public static void main(String[] args) throws Exception {\n+        InetAddress lh = InetAddress.getLoopbackAddress();\n+        int port = Integer.parseInt(args[0]);\n+        try (Socket s = new Socket(lh, port);\n+             DataOutputStream out = new DataOutputStream(s.getOutputStream())) {\n+\n+            \/\/ send pid\n+            long pid = ProcessHandle.current().pid();\n+            out.writeLong(pid);\n+\n+            \/\/ wait for shutdown\n+            s.getInputStream().read();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/Application.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307478\n+ * @summary Test that a warning is printed when an agent is dynamically loaded\n+ * @requires vm.jvmti\n+ * @modules jdk.attach jdk.jcmd\n+ * @library \/test\/lib \/test\/jdk\n+ * @build Application JavaAgent\n+ * @run junit\/othervm\/native DynamicLoadWarningTest\n+ *\/\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class DynamicLoadWarningTest {\n+    private static final String JVMTI_AGENT_WARNING = \"WARNING: A JVM TI agent has been loaded dynamically\";\n+    private static final String JAVA_AGENT_WARNING  = \"WARNING: A Java agent has been loaded dynamically\";\n+\n+    \/\/ JVM TI agents\n+    private static final String JVMTI_AGENT1_LIB = \"JvmtiAgent1\";\n+    private static final String JVMTI_AGENT2_LIB = \"JvmtiAgent2\";\n+    private static String jvmtiAgentPath1;\n+    private static String jvmtiAgentPath2;\n+\n+    \/\/ Java agent\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    private static String javaAgent;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        \/\/ get absolute path to JVM TI agents\n+        String prefix = Platform.isWindows() ? \"\" : \"lib\";\n+        String libname1 = prefix + JVMTI_AGENT1_LIB + \".\" + Platform.sharedLibraryExt();\n+        String libname2 = prefix + JVMTI_AGENT2_LIB + \".\" + Platform.sharedLibraryExt();\n+        jvmtiAgentPath1 = Path.of(Utils.TEST_NATIVE_PATH, libname1).toAbsolutePath().toString();\n+        jvmtiAgentPath2 = Path.of(Utils.TEST_NATIVE_PATH, libname2).toAbsolutePath().toString();\n+\n+        \/\/ create JAR file with Java agent\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(new Attributes.Name(\"Agent-Class\"), \"JavaAgent\");\n+        Path jarfile = Path.of(\"javaagent.jar\");\n+        Path classes = Path.of(TEST_CLASSES);\n+        JarUtils.createJarFile(jarfile, man, classes, Path.of(\"JavaAgent.class\"));\n+        javaAgent = jarfile.toString();\n+    }\n+\n+    \/**\n+     * Actions to load JvmtiAgent1 into a running VM.\n+     *\/\n+    private static Stream<OnAttachAction> loadJvmtiAgent1() {\n+        \/\/ load agent with the attach API\n+        OnAttachAction loadJvmtiAgent = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT1_LIB);\n+\n+        \/\/ jcmd <pid> JVMTI.agent_load <agent>\n+        OnAttachAction jcmdAgentLoad = jcmdAgentLoad(jvmtiAgentPath1);\n+\n+        return Stream.of(loadJvmtiAgent, jcmdAgentLoad);\n+    }\n+\n+    \/**\n+     * Test loading JvmtiAgent1 into a running VM.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"loadJvmtiAgent1\")\n+    void testLoadOneJvmtiAgent(OnAttachAction loadJvmtiAgent1) throws Exception {\n+        \/\/ dynamically load loadJvmtiAgent1\n+        test().whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n+\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Test loading JvmtiAgent1 and JvmtiAgent2 into a running VM.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"loadJvmtiAgent1\")\n+    void testLoadTwoJvmtiAgents(OnAttachAction loadJvmtiAgent1) throws Exception {\n+        OnAttachAction loadJvmtiAgent2 = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT2_LIB);\n+        OnAttachAction jcmdAgentLoad2 = jcmdAgentLoad(jvmtiAgentPath2);\n+\n+        \/\/ dynamically load loadJvmtiAgent1, then dynamically load loadJvmtiAgent2 with attach API\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 2);\n+\n+        \/\/ dynamically load loadJvmtiAgent1, then dynamically load loadJvmtiAgent2 with jcmd\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(jcmdAgentLoad2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 2);\n+\n+        \/\/ start loadJvmtiAgent2 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath2)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Test loading Java agent into a running VM.\n+     *\/\n+    @Test\n+    void testLoadJavaAgent() throws Exception {\n+        OnAttachAction loadJavaAgent = (pid, vm) -> vm.loadAgent(javaAgent);\n+\n+        \/\/ agent dynamically loaded\n+        test().whenRunning(loadJavaAgent)\n+                .stderrShouldContain(JAVA_AGENT_WARNING);\n+\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJavaAgent)\n+                .stderrShouldNotContain(JAVA_AGENT_WARNING);\n+    }\n+\n+    \/**\n+     * Represents an operation that accepts a process identifier and a VirtualMachine\n+     * that the current JVM is attached to.\n+     *\/\n+    private interface OnAttachAction {\n+        void accept(long pid, VirtualMachine vm) throws Exception;\n+    }\n+\n+    \/**\n+     * Returns an operation that invokes \"jcmd <pid> JVMTI.agent_load <agentpath>\" to\n+     * load the given agent library into the JVM that the current JVM is attached to.\n+     *\/\n+    private static OnAttachAction jcmdAgentLoad(String agentPath) {\n+        return (pid, vm) -> {\n+            String[] jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(pid))\n+                    .addToolArg(\"JVMTI.agent_load\")\n+                    .addToolArg(agentPath)\n+                    .getCommand();\n+            System.out.println(Arrays.stream(jcmd).collect(Collectors.joining(\" \")));\n+            Process p = new ProcessBuilder(jcmd).inheritIO().start();\n+            assertEquals(0, p.waitFor());\n+        };\n+    }\n+\n+    \/**\n+     * Returns a new app runner.\n+     *\/\n+    private static AppRunner test() {\n+        return new AppRunner();\n+    }\n+\n+    \/**\n+     * Runs an application in its own VM. Once started, it attachs to the VM, runs a set\n+     * of actions, then checks that the output contains, or does not contain, a string.\n+     *\/\n+    private static class AppRunner {\n+        private String[] vmopts = new String[0];\n+        private List<OnAttachAction> actions = new ArrayList<>();\n+\n+        \/**\n+         * Specifies VM options to run the application.\n+         *\/\n+        AppRunner withOpts(String... vmopts) {\n+            this.vmopts = vmopts;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies an action to run when the attached to the running application.\n+         *\/\n+        AppRunner whenRunning(OnAttachAction action) {\n+            actions.add(action);\n+            return this;\n+        }\n+\n+        OutputAnalyzer run() throws Exception {\n+            \/\/ start a listener socket that the application will connect to\n+            try (ServerSocket listener = new ServerSocket()) {\n+                InetAddress lh = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(lh, 0));\n+\n+                var done = new AtomicBoolean();\n+\n+                \/\/ start a thread to wait for the application to phone home\n+                Thread.ofPlatform().daemon().start(() -> {\n+                    try (Socket s = listener.accept();\n+                         DataInputStream in = new DataInputStream(s.getInputStream())) {\n+\n+                        \/\/ read pid\n+                        long pid = in.readLong();\n+\n+                        \/\/ attach and run the actions with the vm object\n+                        VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n+                        try {\n+                            for (OnAttachAction action : actions) {\n+                                action.accept(pid, vm);\n+                            }\n+                        } finally {\n+                            vm.detach();\n+                        }\n+                        done.set(true);\n+\n+                        \/\/ shutdown\n+                        s.getOutputStream().write(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+\n+                \/\/ launch application with the given VM options, waiting for it to terminate\n+                Stream<String> s1 = Stream.of(vmopts);\n+                Stream<String> s2 = Stream.of(\"Application\", Integer.toString(listener.getLocalPort()));\n+                String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+                OutputAnalyzer outputAnalyzer = ProcessTools\n+                        .executeTestJava(opts)\n+                        .outputTo(System.out)\n+                        .errorTo(System.out);\n+                assertEquals(0, outputAnalyzer.getExitValue());\n+                assertTrue(done.get(), \"Attach or action failed, see log for details\");\n+                return outputAnalyzer;\n+            }\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error contains a string.\n+         *\/\n+        void stderrShouldContain(String s) throws Exception {\n+            run().stderrShouldContain(s);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error contains the given number of\n+         * occurrences of a string.\n+         *\/\n+        void stderrShouldContain(String s, int occurrences) throws Exception {\n+            List<String> lines = run().asLines();\n+            int count = (int) lines.stream().filter(line -> line.indexOf(s) >= 0).count();\n+            assertEquals(occurrences, count);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error does not contain a string.\n+         *\/\n+        void stderrShouldNotContain(String s) throws Exception {\n+            run().stderrShouldNotContain(s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -24,3 +24,5 @@\n-public class TestUnnamedVariableElementData {\n-    private void test() {\n-        int _ = 0;\n+\/**\n+ * A no-op Java agent.\n+ *\/\n+public class JavaAgent {\n+    public static void agentmain(String args) {\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/JavaAgent.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestUnnamedVariableElementData.java","status":"copied"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent1.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent2.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * Agent used by TraceUsageTest. The premain and agentmain methods invoke Instrumentation\n+ * methods so the usages can be traced by the test.\n+ *\/\n+public class TraceUsageAgent {\n+    public static void premain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    public static void agentmain(String methodNames, Instrumentation inst) throws Exception {\n+        test(methodNames, inst);\n+    }\n+\n+    private static void test(String methodNames, Instrumentation inst) throws Exception {\n+        for (String methodName : methodNames.split(\",\")) {\n+            switch (methodName) {\n+                case \"addTransformer\" -> {\n+                    var transformer = new ClassFileTransformer() { };\n+                    inst.addTransformer(transformer);\n+                }\n+                case \"retransformClasses\" -> {\n+                    inst.retransformClasses(Object.class);\n+                }\n+                case \"redefineModule\" -> {\n+                    Module base = Object.class.getModule();\n+                    inst.redefineModule(base, Set.of(), Map.of(), Map.of(), Set.of(), Map.of());\n+                }\n+                default -> {\n+                    throw new RuntimeException(\"Unknown method name: \" + methodName);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageAgent.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307478\n+ * @summary Test Instrumentation tracing is enabled with a system property\n+ * @library \/test\/lib\n+ * @run shell MakeJAR3.sh TraceUsageAgent 'Agent-Class: TraceUsageAgent' 'Can-Retransform-Classes: true'\n+ * @run junit TraceUsageTest\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TraceUsageTest {\n+    private static final String JAVA_AGENT = \"TraceUsageAgent.jar\";\n+\n+    \/\/ Instrumentation methods to test\n+    private static final String[] INSTRUMENTATION_METHODS = {\n+            \"addTransformer\",\n+            \"retransformClasses\",\n+            \"redefineModule\"\n+    };\n+\n+    \/**\n+     * If launched with the argument \"attach\" then it loads the java agent into the\n+     * current VM with the given options.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0 && args[0].equals(\"attach\")) {\n+            String options = args[1];\n+            long pid = ProcessHandle.current().pid();\n+            VirtualMachine vm = VirtualMachine.attach(\"\"+pid);\n+            try {\n+                vm.loadAgent(JAVA_AGENT, options);\n+            } finally {\n+                vm.detach();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test agent started on the command line with -javaagent.\n+     *\/\n+    @Test\n+    void testPremain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-javaagent:\" + JAVA_AGENT + \"=\" + String.join(\",\", INSTRUMENTATION_METHODS),\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\"\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.premain\");\n+    }\n+\n+    \/**\n+     * Test agent loaded into a running VM with the attach mechanism.\n+     *\/\n+    @Test\n+    void testAgentmain() throws Exception {\n+        OutputAnalyzer outputAnalyzer = execute(\n+                \"-Djdk.attach.allowAttachSelf=true\",\n+                \"-Djdk.instrument.traceUsage=true\",\n+                \"TraceUsageTest\",\n+                \"attach\",\n+                String.join(\",\", INSTRUMENTATION_METHODS)\n+        );\n+        for (String mn : INSTRUMENTATION_METHODS) {\n+            String expected = \"Instrumentation.\" + mn + \" has been called by TraceUsageAgent\";\n+            outputAnalyzer.shouldContain(expected);\n+        }\n+        outputAnalyzer.shouldContain(\"at TraceUsageAgent.agentmain\");\n+    }\n+\n+    private OutputAnalyzer execute(String... command) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        assertEquals(0, outputAnalyzer.getExitValue());\n+        return outputAnalyzer;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/TraceUsageTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}