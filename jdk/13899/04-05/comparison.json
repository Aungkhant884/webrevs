{"files":[{"patch":"@@ -644,1 +644,3 @@\n-    to start in the live phase.\n+    to start in the live phase. If an agent was previously started (in the <code>OnLoad<\/code>\n+    phase or in the live phase), then it is implementation specific as to whether a\n+    warning is printed when attempting to start the same agent a second or subsequent time.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -508,0 +509,1 @@\n+  }\n@@ -509,8 +511,6 @@\n-    \/\/ Print warning if EnableDynamicAgentLoading not enabled on the command line\n-    assert(EnableDynamicAgentLoading, \"Dynamic loading of agents not enabled\");\n-    if (!FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib()) {\n-      jio_fprintf(defaultStream::error_stream(),\n-        \"WARNING: A JVM TI agent has been dynamically loaded (%s)\\n\"\n-        \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n-        \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n-    }\n+  \/\/ Print warning if EnableDynamicAgentLoading not enabled on the command line\n+  if (!FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib() && !JvmtiAgentList::is_loaded(library)) {\n+    jio_fprintf(defaultStream::error_stream(),\n+      \"WARNING: A JVM TI agent has been dynamically loaded (%s)\\n\"\n+      \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n+      \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n@@ -518,0 +518,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -223,0 +223,16 @@\n+\/\/ Return true if a library is a loaded agent library\n+bool JvmtiAgentList::is_loaded(void* os_lib) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (os_lib == nullptr) {\n+       if (agent->is_static_lib() && agent->is_loaded()) {\n+         return true;\n+       }\n+    } else if (agent->os_lib() == os_lib) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  static bool is_loaded(void* os_lib);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- * {@code Launcher-Agent-Class} attribute to specify the binary name of a Java agent\n+ * {@code Launcher-Agent-Class} attribute to specify the binary name of the Java agent\n@@ -144,1 +144,1 @@\n- * <p> An implementation may provide a mechanism to start agents in a running VM (meaning\n+ * <p> An implementation may provide a mechanism to start agents in a running JVM (meaning\n@@ -157,3 +157,6 @@\n- *   <li><p> The JVM prints a warning on the standard error stream for each agent that\n- *   it attempts to start in a running JVM. Warnings can be disabled by means of an\n- *   implementation-specific command line option. <\/p><\/li>\n+ *   <li><p> The JVM prints a warning on the standard error stream for each agent that it\n+ *   attempts to start in a running JVM. If an agent was previously started (at JVM\n+ *   startup, or started in a running JVM), then it is implementation specific as to whether\n+ *   a warning is printed when attempting to start the same agent a second or subsequent\n+ *   time. Warnings can be disabled by means of an implementation-specific command line\n+ *   option. <\/p><\/li>\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/package-info.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.io.DataOutputStream;\n@@ -43,0 +42,3 @@\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -45,0 +47,1 @@\n+import java.util.stream.Collectors;\n@@ -58,0 +61,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -61,0 +67,2 @@\n+    private static final String JVMTI_AGENT_WARNING = \"WARNING: A JVM TI agent has been dynamically loaded\";\n+    private static final String JAVA_AGENT_WARNING = \"WARNING: A Java agent has been loaded dynamically\";\n@@ -62,3 +70,5 @@\n-    \/\/ JVM TI agent\n-    private static final String JVMTI_AGENT_LIB = \"JvmtiAgent\";\n-    private static String jvmtiAgentPath;\n+    \/\/ JVM TI agents\n+    private static final String JVMTI_AGENT1_LIB = \"JvmtiAgent1\";\n+    private static final String JVMTI_AGENT2_LIB = \"JvmtiAgent2\";\n+    private static String jvmtiAgentPath1;\n+    private static String jvmtiAgentPath2;\n@@ -71,1 +81,8 @@\n-    static void createJavaAgent() throws Exception {\n+    static void setup() throws Exception {\n+        \/\/ get absolute path to JVM TI agents\n+        String prefix = Platform.isWindows() ? \"\" : \"lib\";\n+        String libname1 = prefix + JVMTI_AGENT1_LIB + \".\" + Platform.sharedLibraryExt();\n+        String libname2 = prefix + JVMTI_AGENT2_LIB + \".\" + Platform.sharedLibraryExt();\n+        jvmtiAgentPath1 = Path.of(Utils.TEST_NATIVE_PATH, libname1).toAbsolutePath().toString();\n+        jvmtiAgentPath2 = Path.of(Utils.TEST_NATIVE_PATH, libname2).toAbsolutePath().toString();\n+\n@@ -81,7 +98,0 @@\n-\n-        \/\/ get absolute path to JVM TI agent\n-        String prefix = Platform.isWindows() ? \"\" : \"lib\";\n-        String libname = prefix + JVMTI_AGENT_LIB + \".\" + Platform.sharedLibraryExt();\n-        jvmtiAgentPath = Path.of(Utils.TEST_NATIVE_PATH, libname)\n-                .toAbsolutePath()\n-                .toString();\n@@ -91,1 +101,1 @@\n-     * Test loading JVM TI agent into a running VM with the Attach API.\n+     * Arguments with pairs of actions to load agents into a running VM.\n@@ -93,3 +103,4 @@\n-    @Test\n-    void testLoadJvmtiAgent() throws Exception {\n-        String message = \"WARNING: A JVM TI agent has been dynamically loaded\";\n+    private static Stream<Arguments> loadJvmtiAgents() throws Exception {\n+        \/\/ load agents with the attach API\n+        OnAttachAction loadJvmtiAgent1 = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT1_LIB);\n+        OnAttachAction loadJvmtiAgent2 = (pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT2_LIB);\n@@ -97,2 +108,3 @@\n-        \/\/ warning should be printed\n-        test((pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT_LIB)).shouldContain(message);\n+        \/\/ jcmd <pid> JVMTI.agent_load <agent>\n+        OnAttachAction jcmdAgentLoad1 = jcmdAgentLoad(jvmtiAgentPath1);\n+        OnAttachAction jcmdAgentLoad2 = jcmdAgentLoad(jvmtiAgentPath2);\n@@ -100,3 +112,4 @@\n-        \/\/ no warning should be printed\n-        test((pid, vm) -> vm.loadAgentLibrary(JVMTI_AGENT_LIB), \"-XX:+EnableDynamicAgentLoading\")\n-                .shouldNotContain(message);\n+        return Stream.of(\n+                Arguments.of(loadJvmtiAgent1, loadJvmtiAgent2),\n+                Arguments.of(jcmdAgentLoad1, jcmdAgentLoad2)\n+        );\n@@ -106,1 +119,1 @@\n-     * Test loading JVM TI agent into a running VM with jcmd JVMTI.agent_load command.\n+     * Test loading JVM TI agents into a running VM.\n@@ -108,3 +121,4 @@\n-    @Test\n-    void testJCmdJvmtiAgentLoad() throws Exception {\n-        String message = \"WARNING: A JVM TI agent has been dynamically loaded\";\n+    @ParameterizedTest\n+    @MethodSource(\"loadJvmtiAgents\")\n+    void testLoadJvmtiAgent(OnAttachAction loadJvmtiAgent1,\n+                            OnAttachAction loadJvmtiAgent2) throws Exception {\n@@ -112,13 +126,3 @@\n-        \/\/ jcmd <pid> JVMTI.agent_load <agent>\n-        Op op = (pid, vm) -> {\n-            var jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\")\n-                    .addToolArg(Long.toString(pid))\n-                    .addToolArg(\"JVMTI.agent_load\")\n-                    .addToolArg(jvmtiAgentPath);\n-            var pb = new ProcessBuilder(jcmd.getCommand());\n-            int exitValue = ProcessTools.executeProcess(pb)\n-                    .outputTo(System.out)\n-                    .errorTo(System.out)\n-                    .getExitValue();\n-            assertEquals(0, exitValue);\n-        };\n+        \/\/ agent dynamically loaded\n+        test().whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n@@ -126,2 +130,4 @@\n-        \/\/ warning should be printed\n-        test(op).shouldContain(message);\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n@@ -129,2 +135,19 @@\n-        \/\/ no warning should be printed\n-        test(op, \"-XX:+EnableDynamicAgentLoading\").shouldNotContain(message);\n+        \/\/ agent started via command line, same agent dynamically loaded\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ agent started via command line, different agent dynamically loaded\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ same agent dynamically loaded twice, should be one warning\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n+\n+        \/\/ two different agents loaded dynamically, should be two warnings\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent2)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 2);\n@@ -138,1 +161,1 @@\n-        String message = \"WARNING: A Java agent has been loaded dynamically\";\n+        OnAttachAction loadJavaAgent = (pid, vm) -> vm.loadAgent(javaAgent);\n@@ -140,2 +163,3 @@\n-        \/\/ warning should be printed\n-        test((pid, vm) -> vm.loadAgent(javaAgent)).shouldContain(message);\n+        \/\/ agent dynamically loaded\n+        test().whenRunning(loadJavaAgent)\n+                .stderrShouldContain(JAVA_AGENT_WARNING);\n@@ -143,3 +167,4 @@\n-        \/\/ no warning should be printed\n-        test((pid, vm) -> vm.loadAgent(javaAgent), \"-XX:+EnableDynamicAgentLoading\")\n-                .shouldNotContain(message);\n+        \/\/ opt-in via command line option to allow dynamic loading of agents\n+        test().withOpts(\"-XX:+EnableDynamicAgentLoading\")\n+                .whenRunning(loadJavaAgent)\n+                .stderrShouldNotContain(JAVA_AGENT_WARNING);\n@@ -148,1 +173,5 @@\n-    private interface Op {\n+    \/**\n+     * Represents an operation that accepts a process identifier and a VirtualMachine\n+     * that the current JVM is attached to.\n+     *\/\n+    private interface OnAttachAction {\n@@ -153,3 +182,26 @@\n-     * Starts a new VM to run an application, attaches to the VM, runs a given action\n-     * with the VirtualMachine object, and returns the output (both stdout and stderr)\n-     * for analysis.\n+     * Returns an operation that invokes \"jcmd <pid> JVMTI.agent_load <agentpath>\" to\n+     * load the given agent library into the JVM that the current JVM is attached to.\n+     *\/\n+    private static OnAttachAction jcmdAgentLoad(String agentPath) throws Exception {\n+        return (pid, vm) -> {\n+            String[] jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(pid))\n+                    .addToolArg(\"JVMTI.agent_load\")\n+                    .addToolArg(agentPath)\n+                    .getCommand();\n+            System.out.println(Arrays.stream(jcmd).collect(Collectors.joining(\" \")));\n+            Process p = new ProcessBuilder(jcmd).inheritIO().start();\n+            assertEquals(0, p.waitFor());\n+        };\n+    }\n+\n+    \/**\n+     * Returns a new app runner.\n+     *\/\n+    private static AppRunner test() {\n+        return new AppRunner();\n+    }\n+\n+    \/**\n+     * Runs an application in its own VM. Once started, it attachs to the VM, runs a set\n+     * of actions, then checks that the output contains, or does not contain, a string.\n@@ -157,20 +209,45 @@\n-    private OutputAnalyzer test(Op action, String... vmopts) throws Exception {\n-        \/\/ start a listener socket that the application will connect to\n-        try (ServerSocket listener = new ServerSocket()) {\n-            InetAddress lh = InetAddress.getLoopbackAddress();\n-            listener.bind(new InetSocketAddress(lh, 0));\n-\n-            var done = new AtomicBoolean();\n-\n-            \/\/ start a thread to wait for the application to phone home\n-            Thread.ofPlatform().daemon().start(() -> {\n-                try (Socket s = listener.accept();\n-                     DataInputStream in = new DataInputStream(s.getInputStream())) {\n-\n-                    \/\/ read pid\n-                    long pid = in.readLong();\n-\n-                    \/\/ attach and run the action with the vm object\n-                    VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n-                    try {\n-                        action.accept(pid, vm);\n+    private static class AppRunner {\n+        private String[] vmopts = new String[0];\n+        private List<OnAttachAction> actions = new ArrayList<>();\n+\n+        \/**\n+         * Specifies VM options to run the application.\n+         *\/\n+        AppRunner withOpts(String... vmopts) {\n+            this.vmopts = vmopts;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies an action to run when the attached to the running application.\n+         *\/\n+        AppRunner whenRunning(OnAttachAction action) {\n+            actions.add(action);\n+            return this;\n+        }\n+\n+        OutputAnalyzer run() throws Exception {\n+            \/\/ start a listener socket that the application will connect to\n+            try (ServerSocket listener = new ServerSocket()) {\n+                InetAddress lh = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(lh, 0));\n+\n+                var done = new AtomicBoolean();\n+\n+                \/\/ start a thread to wait for the application to phone home\n+                Thread.ofPlatform().daemon().start(() -> {\n+                    try (Socket s = listener.accept();\n+                         DataInputStream in = new DataInputStream(s.getInputStream())) {\n+\n+                        \/\/ read pid\n+                        long pid = in.readLong();\n+\n+                        \/\/ attach and run the actions with the vm object\n+                        VirtualMachine vm = VirtualMachine.attach(Long.toString(pid));\n+                        try {\n+                            for (OnAttachAction action : actions) {\n+                                action.accept(pid, vm);\n+                            }\n+                        } finally {\n+                            vm.detach();\n+                        }\n@@ -178,2 +255,5 @@\n-                    } finally {\n-                        vm.detach();\n+\n+                        \/\/ shutdown\n+                        s.getOutputStream().write(0);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n@@ -181,0 +261,15 @@\n+                });\n+\n+                \/\/ launch application with the given VM options, waiting for it to terminate\n+                Stream<String> s1 = Stream.of(vmopts);\n+                Stream<String> s2 = Stream.of(\"Application\", Integer.toString(listener.getLocalPort()));\n+                String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+                OutputAnalyzer outputAnalyzer = ProcessTools\n+                        .executeTestJava(opts)\n+                        .outputTo(System.out)\n+                        .errorTo(System.out);\n+                assertEquals(0, outputAnalyzer.getExitValue());\n+                assertTrue(done.get(), \"Attach or action failed, see log for details\");\n+                return outputAnalyzer;\n+            }\n+        }\n@@ -182,19 +277,22 @@\n-                    \/\/ shutdown\n-                    s.getOutputStream().write(0);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            });\n-\n-            \/\/ launch application with the given VM options, waiting for it to terminate\n-            Stream<String> s1 = Stream.of(vmopts);\n-            Stream<String> s2 = Stream.of(\"Application\", Integer.toString(listener.getLocalPort()));\n-            String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n-            OutputAnalyzer outputAnalyzer = ProcessTools\n-                    .executeTestJava(opts)\n-                    .outputTo(System.out)\n-                    .errorTo(System.out);\n-            assertEquals(0, outputAnalyzer.getExitValue());\n-            assertTrue(done.get(), \"Attach or action failed, see log for details\");\n-\n-            return outputAnalyzer;\n+        \/**\n+         * Run the application, checking that standard error contains a string.\n+         *\/\n+        void stderrShouldContain(String s) throws Exception {\n+            run().stderrShouldContain(s);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error contains the given number of\n+         * occurrences of a string.\n+         *\/\n+        void stderrShouldContain(String s, int occurrences) throws Exception {\n+            List<String> lines = run().asLines();\n+            int count = (int) lines.stream().filter(line -> line.indexOf(s) >= 0).count();\n+            assertEquals(occurrences, count);\n+        }\n+\n+        \/**\n+         * Run the application, checking that standard error does not contain a string.\n+         *\/\n+        void stderrShouldNotContain(String s) throws Exception {\n+            run().stderrShouldNotContain(s);\n@@ -204,1 +302,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":191,"deletions":94,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jvmti.h\"\n-\n-\/**\n- * A no-op JVM TI agent.\n- *\/\n-JNIEXPORT jint JNICALL\n-Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n-    jvmtiEnv* jvmti;\n-    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n-}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent1.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * A no-op JVM TI agent.\n+ *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti;\n+    return vm->GetEnv((void**)&jvmti, JVMTI_VERSION);\n+}\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/libJvmtiAgent2.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"}]}