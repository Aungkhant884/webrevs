{"files":[{"patch":"@@ -28,1 +28,1 @@\n-\/\/ Byte swapping for 16-bit, 32-bit, and 64-bit integers.\n+\/\/ Byte swapping for 8-bit, 16-bit, 32-bit, and 64-bit integers.\n@@ -33,1 +33,1 @@\n-\/\/ introduced in C++23\n+\/\/ introduced in C++23.\n@@ -40,3 +40,3 @@\n-#if defined(__linux__)\n-#include <byteswap.h>\n-#endif\n+#include <cstddef>\n+#include <cstdint>\n+#include <type_traits>\n@@ -44,3 +44,3 @@\n-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)\n-#include <sys\/endian.h>\n-#endif\n+template <typename T>\n+struct CanByteswapImpl final\n+    : public std::integral_constant<bool, (std::is_integral<T>::value && sizeof(T) <= 8)> {};\n@@ -48,3 +48,2 @@\n-#if defined(__OpenBSD__)\n-#include <endian.h>\n-#endif\n+template <typename T, size_t N = sizeof(T)>\n+struct ByteswapImpl;\n@@ -52,3 +51,6 @@\n-#if defined(__APPLE__)\n-#include <libkern\/OSByteOrder.h>\n-#endif\n+template <typename T, ENABLE_IF(CanByteswapImpl<T>::value)>\n+ALWAYSINLINE T byteswap(T x) {\n+  using U = std::make_unsigned_t<T>;\n+  STATIC_ASSERT(sizeof(T) == sizeof(U));\n+  return static_cast<T>(ByteswapImpl<U>{}(static_cast<U>(x)));\n+}\n@@ -56,4 +58,3 @@\n-#include <cstddef>\n-#include <cstdint>\n-#include <cstdlib>\n-#include <type_traits>\n+\/*****************************************************************************\n+ * Implementation\n+ *****************************************************************************\/\n@@ -61,5 +62,5 @@\n-#if defined(_MSC_VER)\n-#pragma intrinsic(_byteswap_ushort)\n-#pragma intrinsic(_byteswap_ulong)\n-#pragma intrinsic(_byteswap_uint64)\n-#endif\n+\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n+template <typename T>\n+struct ByteswapImpl<T, 1> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 1);\n@@ -67,0 +68,10 @@\n+  ALWAYSINLINE T operator()(T x) const {\n+    return x;\n+  }\n+};\n+\n+\/*****************************************************************************\n+ * Fallback\n+ *****************************************************************************\/\n+\n+\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n@@ -68,4 +79,13 @@\n-struct CanByteswapImpl final\n-    : public std::integral_constant<bool, (std::is_integral<T>::value &&\n-                                           (sizeof(T) == 1 || sizeof(T) == 2 ||\n-                                            sizeof(T) == 4 || sizeof(T) == 8))> {};\n+struct ByteswapFallbackImpl<T, 1> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 1);\n+\n+  ALWAYSINLINE T operator()(T x) const {\n+    return x;\n+  }\n+};\n+\n+template <typename T>\n+struct ByteswapFallbackImpl<T, 2> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 2);\n@@ -73,1 +93,0 @@\n-struct Byteswap16Impl final {\n@@ -75,11 +94,0 @@\n-#if (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_bswap16)\n-    return __builtin_bswap16(x);\n-#elif defined(_MSC_VER)\n-    return _byteswap_ushort(x);\n-#elif defined(__linux__)\n-    return bswap_16(x);\n-#elif defined(__APPLE__)\n-    return OSSwapInt16(x);\n-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n-    return bswap16(x);\n-#else\n@@ -87,1 +95,0 @@\n-#endif\n@@ -91,1 +98,5 @@\n-struct Byteswap32Impl final {\n+template <typename T>\n+struct ByteswapFallbackImpl<T, 4> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 4);\n+\n@@ -93,11 +104,0 @@\n-#if (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_bswap32)\n-    return __builtin_bswap32(x);\n-#elif defined(_MSC_VER)\n-    return _byteswap_ulong(x);\n-#elif defined(__linux__)\n-    return bswap_32(x);\n-#elif defined(__APPLE__)\n-    return OSSwapInt32(x);\n-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n-    return bswap32(x);\n-#else\n@@ -106,1 +106,0 @@\n-#endif\n@@ -110,1 +109,5 @@\n-struct Byteswap64Impl final {\n+template <typename T>\n+struct ByteswapFallbackImpl<T, 8> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == 8);\n+\n@@ -112,11 +115,0 @@\n-#if (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_bswap64)\n-    return __builtin_bswap64(x);\n-#elif defined(_MSC_VER)\n-    return _byteswap_uint64(x);\n-#elif defined(__linux__)\n-    return bswap_64(x);\n-#elif defined(__APPLE__)\n-    return OSSwapInt64(x);\n-#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n-    return bswap64(x);\n-#else\n@@ -127,1 +119,0 @@\n-#endif\n@@ -131,2 +122,12 @@\n-template <typename T, size_t N = sizeof(T)>\n-struct ByteswapImpl;\n+\/*****************************************************************************\n+ * GCC and compatible (including Clang)\n+ *****************************************************************************\/\n+#if defined(TARGET_COMPILER_gcc)\n+\n+#if defined(__clang__)\n+\n+\/\/ Unlike GCC, Clang is willing to inline the generic implementation of __builtin_bswap when\n+\/\/ architecture support is unavailable in -O2. This ensures we avoid the function call to libgcc.\n+\/\/ Clang is able to recognize the fallback implementation as byteswapping, but not on every\n+\/\/ architecture unlike GCC. This suggests the optimization pass for GCC that recognizes byteswapping\n+\/\/ is architecture agnostic, while for Clang it is not.\n@@ -134,1 +135,0 @@\n-\/\/ We support 8-bit integer types to be compatible with C++23's std::byteswap.\n@@ -136,1 +136,4 @@\n-struct ByteswapImpl<T, 1> final {\n+struct ByteswapImpl<T, 2> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == sizeof(uint16_t));\n+\n@@ -138,3 +141,21 @@\n-    STATIC_ASSERT(CanByteswapImpl<T>::value);\n-    STATIC_ASSERT(sizeof(T) == 1);\n-    return x;\n+    return static_cast<T>(__builtin_bswap16(static_cast<uint16_t>(x)));\n+  }\n+};\n+\n+template <typename T>\n+struct ByteswapImpl<T, 4> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == sizeof(uint32_t));\n+\n+  ALWAYSINLINE T operator()(T x) const {\n+    return static_cast<T>(__builtin_bswap32(static_cast<uint32_t>(x)));\n+  }\n+};\n+\n+template <typename T>\n+struct ByteswapImpl<T, 8> final {\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(T) == sizeof(uint64_t));\n+\n+  ALWAYSINLINE T operator()(T x) const {\n+    return static_cast<T>(__builtin_bswap64(static_cast<uint64_t>(x)));\n@@ -144,0 +165,27 @@\n+#else\n+\n+\/\/ We do not use __builtin_bswap and friends for GCC. Unfortunately on architectures that do not\n+\/\/ have a byteswap instruction (i.e. RISC-V), GCC emits a function call to libgcc regardless of\n+\/\/ optimization options, even when the generic implementation is, for example, less than 20\n+\/\/ instructions. GCC is however able to recognize the fallback as byteswapping regardless of\n+\/\/ architecture and appropriately replaces the code in -O2 with the appropriate\n+\/\/ architecture-specific byteswap instruction, if available. If it is not available, GCC emits the\n+\/\/ exact same implementation that underpins its __builtin_bswap in libgcc as there is really only\n+\/\/ one way to implement it, as we have in fallback.\n+\n+template <typename T, size_t N>\n+struct ByteswapImpl final : public ByteswapFallbackImpl<T, N> {};\n+\n+#endif\n+\n+\/*****************************************************************************\n+ * Microsoft Visual Studio\n+ *****************************************************************************\/\n+#elif defined(TARGET_COMPILER_visCPP)\n+\n+#include <stdlib.h>\n+\n+#pragma intrinsic(_byteswap_ushort)\n+#pragma intrinsic(_byteswap_ulong)\n+#pragma intrinsic(_byteswap_uint64)\n+\n@@ -146,0 +194,4 @@\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(unsigned short) == sizeof(2));\n+  STATIC_ASSERT(sizeof(T) == sizeof(unsigned short));\n+\n@@ -147,3 +199,1 @@\n-    STATIC_ASSERT(CanByteswapImpl<T>::value);\n-    STATIC_ASSERT(sizeof(T) == 2);\n-    return static_cast<T>(Byteswap16Impl{}(static_cast<uint16_t>(x)));\n+    return static_cast<T>(_byteswap_ushort(static_cast<unsigned short>(x)));\n@@ -155,0 +205,4 @@\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(unsigned long) == sizeof(4));\n+  STATIC_ASSERT(sizeof(T) == sizeof(unsigned long));\n+\n@@ -156,3 +210,1 @@\n-    STATIC_ASSERT(CanByteswapImpl<T>::value);\n-    STATIC_ASSERT(sizeof(T) == 4);\n-    return static_cast<T>(Byteswap32Impl{}(static_cast<uint32_t>(x)));\n+    return static_cast<T>(__builtin_bswap32(static_cast<unsigned long>(x)));\n@@ -164,0 +216,4 @@\n+  STATIC_ASSERT(CanByteswapImpl<T>::value);\n+  STATIC_ASSERT(sizeof(unsigned __int64) == sizeof(4));\n+  STATIC_ASSERT(sizeof(T) == sizeof(unsigned __int64));\n+\n@@ -165,3 +221,1 @@\n-    STATIC_ASSERT(CanByteswapImpl<T>::value);\n-    STATIC_ASSERT(sizeof(T) == 8);\n-    return static_cast<T>(Byteswap64Impl{}(static_cast<uint64_t>(x)));\n+    return static_cast<T>(_byteswap_uint64(static_cast<unsigned __int64>(x)));\n@@ -171,4 +225,18 @@\n-template <typename T, ENABLE_IF(CanByteswapImpl<T>::value)>\n-ALWAYSINLINE T byteswap(T x) {\n-  return ByteswapImpl<T>{}(x);\n-}\n+\/*****************************************************************************\n+ * IBM XL C\/C++\n+ *****************************************************************************\/\n+#elif defined(TARGET_COMPILER_xlc)\n+\n+\/\/ To our knowledge XL C\/C++ does not have a compiler intrinsic for byteswapping.\n+\n+template <typename T, size_t N>\n+struct ByteswapImpl final : public ByteswapFallbackImpl<T, N> {};\n+\n+\/*****************************************************************************\n+ * Unknown toolchain\n+ *****************************************************************************\/\n+#else\n+\n+#error Unknown toolchain.\n+\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":154,"deletions":86,"binary":false,"changes":240,"status":"modified"}]}