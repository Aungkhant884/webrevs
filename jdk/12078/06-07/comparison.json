{"files":[{"patch":"@@ -69,0 +69,23 @@\n+struct UnalignedLoadImpl;\n+template <typename T, size_t S = sizeof(T), size_t A = alignof(T)>\n+struct UnalignedStoreImpl;\n+\n+class UnalignedAccess final : public AllStatic {\n+ public:\n+  \/\/ Load the bits of the value x of type T from the specified address p.\n+  template <typename T, ENABLE_IF(CanAccessUnalignedImpl<T>::value)>\n+  static ALWAYSINLINE T load(const void* p) {\n+    return UnalignedLoadImpl<T>{}(p);\n+  }\n+\n+  \/\/ Store the bits of the value x of type U, which must be implicitly convertible to type T, at the\n+  \/\/ specified address p. This approach requires explicitly specifying type T for readability,\n+  \/\/ rather than deriving type T from the argument.\n+  template <typename T, typename U = T, ENABLE_IF(CanAccessUnalignedImpl<T>::value &&\n+                                                  std::is_convertible<U, T>::value)>\n+  static ALWAYSINLINE void store(void* p, U x) {\n+    UnalignedStoreImpl<T>{}(p, x);\n+  }\n+};\n+\n+template <typename T, size_t S, size_t A>\n@@ -74,1 +97,1 @@\n-#if (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_memcpy)\n+#if defined(TARGET_COMPILER_gcc)\n@@ -83,1 +106,1 @@\n-#elif defined(_MSC_VER)\n+#elif defined(TARGET_COMPILER_visCPP)\n@@ -94,1 +117,1 @@\n-template <typename T, size_t S = sizeof(T), size_t A = alignof(T)>\n+template <typename T, size_t S, size_t A>\n@@ -100,1 +123,1 @@\n-#if (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_memcpy)\n+#if defined(TARGET_COMPILER_gcc)\n@@ -107,1 +130,1 @@\n-#elif defined(_MSC_VER)\n+#elif defined(TARGET_COMPILER_visCPP)\n@@ -147,1 +170,1 @@\n-#elif (defined(__GNUC__) && !defined(__clang__)) || HAS_BUILTIN(__builtin_memcpy)\n+#elif defined(TARGET_COMPILER_gcc)\n@@ -165,2 +188,2 @@\n-template <typename T>\n-struct UnalignedLoadImpl<T, 2, 2> final {\n+template <typename T, size_t A>\n+struct UnalignedLoadImpl<T, 2, A> final {\n@@ -170,1 +193,2 @@\n-    STATIC_ASSERT(alignof(T) == 2);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 2);\n@@ -175,2 +199,2 @@\n-template <typename T>\n-struct UnalignedStoreImpl<T, 2, 2> final {\n+template <typename T, size_t A>\n+struct UnalignedStoreImpl<T, 2, A> final {\n@@ -180,1 +204,2 @@\n-    STATIC_ASSERT(alignof(T) == 2);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 2);\n@@ -185,2 +210,2 @@\n-template <typename T>\n-struct UnalignedLoadImpl<T, 4, 4> final {\n+template <typename T, size_t A>\n+struct UnalignedLoadImpl<T, 4, A> final {\n@@ -190,1 +215,2 @@\n-    STATIC_ASSERT(alignof(T) == 4);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 4);\n@@ -195,2 +221,2 @@\n-template <typename T>\n-struct UnalignedStoreImpl<T, 4, 4> final {\n+template <typename T, size_t A>\n+struct UnalignedStoreImpl<T, 4, A> final {\n@@ -200,1 +226,2 @@\n-    STATIC_ASSERT(alignof(T) == 4);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 4);\n@@ -205,2 +232,2 @@\n-template <typename T>\n-struct UnalignedLoadImpl<T, 8, 8> final {\n+template <typename T, size_t A>\n+struct UnalignedLoadImpl<T, 8, A> final {\n@@ -210,1 +237,2 @@\n-    STATIC_ASSERT(alignof(T) == 8);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 8);\n@@ -215,2 +243,2 @@\n-template <typename T>\n-struct UnalignedStoreImpl<T, 8, 8> final {\n+template <typename T, size_t A>\n+struct UnalignedStoreImpl<T, 8, A> final {\n@@ -220,1 +248,2 @@\n-    STATIC_ASSERT(alignof(T) == 8);\n+    STATIC_ASSERT(alignof(T) == A);\n+    STATIC_ASSERT(A >= 8);\n@@ -226,18 +255,0 @@\n-class UnalignedAccess final : public AllStatic {\n- public:\n-  \/\/ Load the bits of the value x of type T from the specified address p.\n-  template <typename T, ENABLE_IF(CanAccessUnalignedImpl<T>::value)>\n-  static ALWAYSINLINE T load(const void* p) {\n-    return UnalignedLoadImpl<T>{}(p);\n-  }\n-\n-  \/\/ Store the bits of the value x of type U, which must be implicitly convertible to type T, at the\n-  \/\/ specified address p. This approach requires explicitly specifying type T for readability,\n-  \/\/ rather than deriving type T from the argument.\n-  template <typename T, typename U = T, ENABLE_IF(CanAccessUnalignedImpl<T>::value &&\n-                                                  std::is_convertible<U, T>::value)>\n-  static ALWAYSINLINE void store(void* p, U x) {\n-    UnalignedStoreImpl<T>{}(p, x);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/utilities\/unalignedAccess.hpp","additions":53,"deletions":42,"binary":false,"changes":95,"status":"modified"}]}