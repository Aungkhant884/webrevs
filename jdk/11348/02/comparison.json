{"files":[{"patch":"@@ -482,9 +482,6 @@\n-                if (mode.equals(\"readWrite\")) {\n-                    nssDbMode = Secmod.DbMode.READ_WRITE;\n-                } else if (mode.equals(\"readOnly\")) {\n-                    nssDbMode = Secmod.DbMode.READ_ONLY;\n-                } else if (mode.equals(\"noDb\")) {\n-                    nssDbMode = Secmod.DbMode.NO_DB;\n-                } else {\n-                    throw excToken(\"nssDbMode must be one of readWrite, readOnly, and noDb:\");\n-                }\n+                nssDbMode = switch (mode) {\n+                    case \"readWrite\" -> Secmod.DbMode.READ_WRITE;\n+                    case \"readOnly\" -> Secmod.DbMode.READ_ONLY;\n+                    case \"noDb\" -> Secmod.DbMode.NO_DB;\n+                    default -> throw excToken(\"nssDbMode must be one of readWrite, readOnly, and noDb:\");\n+                };\n@@ -519,1 +516,1 @@\n-        if (nssUseSecmod == false) {\n+        if (!nssUseSecmod) {\n@@ -536,1 +533,1 @@\n-            if (nssUseSecmodTrust != false) {\n+            if (nssUseSecmodTrust) {\n@@ -626,8 +623,5 @@\n-        switch (val) {\n-            case \"true\":\n-                return true;\n-            case \"false\":\n-                return false;\n-            default:\n-                throw excToken(\"Expected boolean value, read:\");\n-        }\n+        return switch (val) {\n+            case \"true\" -> true;\n+            case \"false\" -> false;\n+            default -> throw excToken(\"Expected boolean value, read:\");\n+        };\n@@ -691,1 +685,1 @@\n-        if (str.startsWith(\"0h\") == false) {\n+        if (!str.startsWith(\"0h\")) {\n@@ -836,1 +830,1 @@\n-            if (s.equals(\"compatibility\") == false) {\n+            if (!s.equals(\"compatibility\")) {\n@@ -967,10 +961,6 @@\n-        switch (op) {\n-            case \"*\":\n-                return TemplateManager.O_ANY;\n-            case \"generate\":\n-                return TemplateManager.O_GENERATE;\n-            case \"import\":\n-                return TemplateManager.O_IMPORT;\n-            default:\n-                throw excLine(\"Unknown operation \" + op);\n-        }\n+        return switch (op) {\n+            case \"*\" -> TemplateManager.O_ANY;\n+            case \"generate\" -> TemplateManager.O_GENERATE;\n+            case \"import\" -> TemplateManager.O_IMPORT;\n+            default -> throw excLine(\"Unknown operation \" + op);\n+        };\n@@ -1047,9 +1037,6 @@\n-        if (val.equals(\"ignoreAll\")) {\n-            handleStartupErrors = ERR_IGNORE_ALL;\n-        } else if (val.equals(\"ignoreMissingLibrary\")) {\n-            handleStartupErrors = ERR_IGNORE_LIB;\n-        } else if (val.equals(\"halt\")) {\n-            handleStartupErrors = ERR_HALT;\n-        } else {\n-            throw excToken(\"Invalid value for handleStartupErrors:\");\n-        }\n+        handleStartupErrors = switch (val) {\n+            case \"ignoreAll\" -> ERR_IGNORE_ALL;\n+            case \"ignoreMissingLibrary\" -> ERR_IGNORE_LIB;\n+            case \"halt\" -> ERR_HALT;\n+            default -> throw excToken(\"Invalid value for handleStartupErrors:\");\n+        };\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            if (o instanceof IdentityWrapper == false) {\n+            if (!(o instanceof IdentityWrapper)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/KeyCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-            case AES_GCM:\n+            case AES_GCM -> {\n@@ -221,2 +221,2 @@\n-            break;\n-            case CHACHA20_POLY1305:\n+            }\n+            case CHACHA20_POLY1305 -> {\n@@ -231,3 +231,2 @@\n-            break;\n-            default:\n-                throw new AssertionError(\"Unsupported type \" + type);\n+            }\n+            default -> throw new AssertionError(\"Unsupported type \" + type);\n@@ -314,12 +313,4 @@\n-                switch (type) {\n-                    case AES_GCM:\n-                        paramSpec =\n-                            params.getParameterSpec(GCMParameterSpec.class);\n-                        break;\n-                    case CHACHA20_POLY1305:\n-                        paramSpec =\n-                            params.getParameterSpec(IvParameterSpec.class);\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"Unsupported type \" + type);\n-                }\n+                paramSpec = switch (type) {\n+                    case AES_GCM -> params.getParameterSpec(GCMParameterSpec.class);\n+                    case CHACHA20_POLY1305 -> params.getParameterSpec(IvParameterSpec.class);\n+                };\n@@ -346,1 +337,1 @@\n-            case Cipher.ENCRYPT_MODE:\n+            case Cipher.ENCRYPT_MODE -> {\n@@ -354,2 +345,2 @@\n-                break;\n-            case Cipher.DECRYPT_MODE:\n+            }\n+            case Cipher.DECRYPT_MODE -> {\n@@ -358,6 +349,4 @@\n-                break;\n-            case Cipher.WRAP_MODE:\n-            case Cipher.UNWRAP_MODE:\n-                throw new UnsupportedOperationException\n-                        (\"Unsupported mode: \" + opmode);\n-            default:\n+            }\n+            case Cipher.WRAP_MODE, Cipher.UNWRAP_MODE -> throw new UnsupportedOperationException\n+                    (\"Unsupported mode: \" + opmode);\n+            default ->\n@@ -365,1 +354,1 @@\n-                throw new AssertionError(\"Unknown mode: \" + opmode);\n+                    throw new AssertionError(\"Unknown mode: \" + opmode);\n@@ -375,14 +364,3 @@\n-            switch (type) {\n-                case AES_GCM:\n-                    iv = new byte[type.defIvLen];\n-                    this.random.nextBytes(iv);\n-                    tagLen = type.defTagLen;\n-                    break;\n-                case CHACHA20_POLY1305:\n-                    iv = new byte[type.defIvLen];\n-                    this.random.nextBytes(iv);\n-                    tagLen = type.defTagLen;\n-                    break;\n-                default:\n-                    throw new AssertionError(\"Unsupported type \" + type);\n-            }\n+            iv = new byte[type.defIvLen];\n+            this.random.nextBytes(iv);\n+            tagLen = type.defTagLen;\n@@ -466,4 +444,2 @@\n-            CK_MECHANISM mechWithParams;\n-            switch (type) {\n-                case AES_GCM:\n-                    mechWithParams = new CK_MECHANISM(mechanism,\n+            CK_MECHANISM mechWithParams = switch (type) {\n+                case AES_GCM -> new CK_MECHANISM(mechanism,\n@@ -471,3 +447,1 @@\n-                    break;\n-                case CHACHA20_POLY1305:\n-                    mechWithParams = new CK_MECHANISM(mechanism,\n+                case CHACHA20_POLY1305 -> new CK_MECHANISM(mechanism,\n@@ -475,4 +449,1 @@\n-                    break;\n-                default:\n-                    throw new AssertionError(\"Unsupported type: \" + type);\n-            }\n+            };\n@@ -516,1 +487,1 @@\n-        return (result > 0 ? result : 0);\n+        return (Math.max(result, 0));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":25,"deletions":54,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -228,7 +228,8 @@\n-        int result;\n-        if (mode.equals(\"ECB\")) {\n-            result = MODE_ECB;\n-        } else if (mode.equals(\"CBC\")) {\n-            if (blockSize == 0) {\n-                throw new NoSuchAlgorithmException\n-                        (\"CBC mode not supported with stream ciphers\");\n+        return switch (mode) {\n+            case \"ECB\" -> MODE_ECB;\n+            case \"CBC\" -> {\n+                if (blockSize == 0) {\n+                    throw new NoSuchAlgorithmException\n+                            (\"CBC mode not supported with stream ciphers\");\n+                }\n+                yield MODE_CBC;\n@@ -236,7 +237,3 @@\n-            result = MODE_CBC;\n-        } else if (mode.equals(\"CTR\")) {\n-            result = MODE_CTR;\n-        } else {\n-            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        }\n-        return result;\n+            case \"CTR\" -> MODE_CTR;\n+            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        };\n@@ -324,1 +321,1 @@\n-            if (params instanceof IvParameterSpec == false) {\n+            if (!(params instanceof IvParameterSpec)) {\n@@ -366,12 +363,6 @@\n-        switch (opmode) {\n-            case Cipher.ENCRYPT_MODE:\n-                encrypt = true;\n-                break;\n-            case Cipher.DECRYPT_MODE:\n-                encrypt = false;\n-                break;\n-            case Cipher.WRAP_MODE:\n-            case Cipher.UNWRAP_MODE:\n-                throw new UnsupportedOperationException\n-                        (\"Unsupported mode: \" + opmode);\n-            default:\n+        encrypt = switch (opmode) {\n+            case Cipher.ENCRYPT_MODE -> true;\n+            case Cipher.DECRYPT_MODE -> false;\n+            case Cipher.WRAP_MODE, Cipher.UNWRAP_MODE -> throw new UnsupportedOperationException\n+                    (\"Unsupported mode: \" + opmode);\n+            default ->\n@@ -379,2 +370,2 @@\n-                throw new AssertionError(\"Unknown mode: \" + opmode);\n-        }\n+                    throw new AssertionError(\"Unknown mode: \" + opmode);\n+        };\n@@ -393,1 +384,1 @@\n-                if (encrypt == false) {\n+                if (!encrypt) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-            if (key instanceof DHPublicKey) {\n-                DHPublicKey dhKey = (DHPublicKey)key;\n+            if (key instanceof DHPublicKey dhKey) {\n@@ -83,2 +82,1 @@\n-            if (key instanceof DHPrivateKey) {\n-                DHPrivateKey dhKey = (DHPrivateKey)key;\n+            if (key instanceof DHPrivateKey dhKey) {\n@@ -123,1 +121,1 @@\n-        if (keySpec instanceof DHPublicKeySpec == false) {\n+        if (!(keySpec instanceof DHPublicKeySpec)) {\n@@ -154,1 +152,1 @@\n-        if (keySpec instanceof DHPrivateKeySpec == false) {\n+        if (!(keySpec instanceof DHPrivateKeySpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11DHKeyFactory.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-            if (key instanceof DSAPublicKey) {\n-                DSAPublicKey dsaKey = (DSAPublicKey)key;\n+            if (key instanceof DSAPublicKey dsaKey) {\n@@ -78,2 +77,1 @@\n-            if (key instanceof DSAPrivateKey) {\n-                DSAPrivateKey dsaKey = (DSAPrivateKey)key;\n+            if (key instanceof DSAPrivateKey dsaKey) {\n@@ -115,1 +113,1 @@\n-        if (keySpec instanceof DSAPublicKeySpec == false) {\n+        if (!(keySpec instanceof DSAPublicKeySpec)) {\n@@ -147,1 +145,1 @@\n-        if (keySpec instanceof DSAPrivateKeySpec == false) {\n+        if (!(keySpec instanceof DSAPrivateKeySpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11DSAKeyFactory.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -98,29 +98,9 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD2:\n-        case (int)CKM_MD5:\n-            digestLength = 16;\n-            break;\n-        case (int)CKM_SHA_1:\n-            digestLength = 20;\n-            break;\n-        case (int)CKM_SHA224:\n-        case (int)CKM_SHA512_224:\n-        case (int)CKM_SHA3_224:\n-            digestLength = 28;\n-            break;\n-        case (int)CKM_SHA256:\n-        case (int)CKM_SHA512_256:\n-        case (int)CKM_SHA3_256:\n-            digestLength = 32;\n-            break;\n-        case (int)CKM_SHA384:\n-        case (int)CKM_SHA3_384:\n-            digestLength = 48;\n-            break;\n-        case (int)CKM_SHA512:\n-        case (int)CKM_SHA3_512:\n-            digestLength = 64;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n-        }\n+        digestLength = switch ((int) mechanism) {\n+            case (int) CKM_MD2, (int) CKM_MD5 -> 16;\n+            case (int) CKM_SHA_1 -> 20;\n+            case (int) CKM_SHA224, (int) CKM_SHA512_224, (int) CKM_SHA3_224 -> 28;\n+            case (int) CKM_SHA256, (int) CKM_SHA512_256, (int) CKM_SHA3_256 -> 32;\n+            case (int) CKM_SHA384, (int) CKM_SHA3_384 -> 48;\n+            case (int) CKM_SHA512, (int) CKM_SHA3_512 -> 64;\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+        };\n@@ -153,2 +133,2 @@\n-            if (state == S_INIT && token.explicitCancel == true\n-                    && session.hasObjects() == false) {\n+            if (state == S_INIT && token.explicitCancel\n+                    && !session.hasObjects()) {\n@@ -255,1 +235,1 @@\n-        if (key instanceof P11Key == false) {\n+        if (!(key instanceof P11Key p11Key)) {\n@@ -258,1 +238,0 @@\n-        P11Key p11Key = (P11Key)key;\n@@ -292,1 +271,1 @@\n-        if (byteBuffer instanceof DirectBuffer == false) {\n+        if (!(byteBuffer instanceof DirectBuffer)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        if (key instanceof PrivateKey == false) {\n+        if (!(key instanceof PrivateKey)) {\n@@ -102,1 +102,1 @@\n-        if (lastPhase == false) {\n+        if (!lastPhase) {\n@@ -106,1 +106,1 @@\n-        if (key instanceof ECPublicKey == false) {\n+        if (!(key instanceof ECPublicKey ecKey)) {\n@@ -110,1 +110,0 @@\n-        ECPublicKey ecKey = (ECPublicKey)key;\n@@ -172,1 +171,1 @@\n-        if (algorithm.equals(\"TlsPremasterSecret\") == false) {\n+        if (!algorithm.equals(\"TlsPremasterSecret\")) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11ECDHKeyAgreement.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,2 +94,1 @@\n-        if (key instanceof ECPublicKey) {\n-            ECPublicKey ecKey = (ECPublicKey)key;\n+        if (key instanceof ECPublicKey ecKey) {\n@@ -108,2 +107,1 @@\n-            if (key instanceof ECPublicKey) {\n-                ECPublicKey ecKey = (ECPublicKey)key;\n+            if (key instanceof ECPublicKey ecKey) {\n@@ -137,2 +135,1 @@\n-            if (key instanceof ECPrivateKey) {\n-                ECPrivateKey ecKey = (ECPrivateKey)key;\n+            if (key instanceof ECPrivateKey ecKey) {\n@@ -177,1 +174,1 @@\n-        if (keySpec instanceof ECPublicKeySpec == false) {\n+        if (!(keySpec instanceof ECPublicKeySpec)) {\n@@ -207,1 +204,1 @@\n-        if (keySpec instanceof ECPrivateKeySpec == false) {\n+        if (!(keySpec instanceof ECPrivateKeySpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11ECKeyFactory.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -194,1 +194,1 @@\n-        if (obj instanceof Key == false) {\n+        if (!(obj instanceof Key other)) {\n@@ -203,2 +203,1 @@\n-        Key other = (Key)obj;\n-        if (thisFormat.equals(other.getFormat()) == false) {\n+        if (!thisFormat.equals(other.getFormat())) {\n@@ -219,1 +218,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -372,15 +371,10 @@\n-        switch (algorithm) {\n-            case \"RSA\":\n-                return new P11RSAPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"DSA\":\n-                return new P11DSAPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"DH\":\n-                return new P11DHPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"EC\":\n-                return new P11ECPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            default:\n-                throw new ProviderException\n+        return switch (algorithm) {\n+            case \"RSA\" -> new P11RSAPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"DSA\" -> new P11DSAPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"DH\" -> new P11DHPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"EC\" -> new P11ECPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            default -> throw new ProviderException\n@@ -388,1 +382,1 @@\n-        }\n+        };\n@@ -402,3 +396,2 @@\n-        switch (algorithm) {\n-        case \"RSA\":\n-            return P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n+        return switch (algorithm) {\n+            case \"RSA\" -> P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -406,2 +399,1 @@\n-        case \"DSA\":\n-            return P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"DSA\" -> P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -409,2 +401,1 @@\n-        case \"DH\":\n-            return P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"DH\" -> P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -412,2 +403,1 @@\n-        case \"EC\":\n-            return P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"EC\" -> P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -415,2 +405,1 @@\n-        default:\n-            throw new ProviderException\n+            default -> throw new ProviderException\n@@ -418,1 +407,1 @@\n-        }\n+        };\n@@ -1101,1 +1090,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1110,1 +1099,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1113,1 +1102,1 @@\n-            if (!(obj instanceof DHPublicKey)) {\n+            if (!(obj instanceof DHPublicKey other)) {\n@@ -1117,1 +1106,0 @@\n-            DHPublicKey other = (DHPublicKey) obj;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":25,"deletions":37,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        if (key instanceof PrivateKey == false) {\n+        if (!(key instanceof PrivateKey)) {\n@@ -129,1 +129,1 @@\n-        if ((multiPartyAgreement != null) || (lastPhase == false)) {\n+        if ((multiPartyAgreement != null) || (!lastPhase)) {\n@@ -142,2 +142,2 @@\n-        if ((key instanceof PublicKey == false)\n-                || (key.getAlgorithm().equals(algorithm) == false)) {\n+        if ((!(key instanceof PublicKey))\n+                || (!key.getAlgorithm().equals(algorithm))) {\n@@ -148,2 +148,1 @@\n-        if (key instanceof DHPublicKey) {\n-            DHPublicKey dhKey = (DHPublicKey)key;\n+        if (key instanceof DHPublicKey dhKey) {\n@@ -179,2 +178,1 @@\n-        if (privateKey instanceof DHPrivateKey) {\n-            DHPrivateKey dhKey = (DHPrivateKey)privateKey;\n+        if (privateKey instanceof DHPrivateKey dhKey) {\n@@ -182,2 +180,2 @@\n-            if ((p.equals(params.getP()) == false)\n-                                || (g.equals(params.getG()) == false)) {\n+            if ((!p.equals(params.getP()))\n+                                || (!g.equals(params.getG()))) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        if (key.getAlgorithm().equals(this.algorithm) == false) {\n+        if (!key.getAlgorithm().equals(this.algorithm)) {\n@@ -141,2 +141,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,89 +212,94 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_DES_KEY_GEN:\n-            keySize = 64;\n-            keyType = CKK_DES;\n-            significantKeySize = 56;\n-            break;\n-        case (int)CKM_DES2_KEY_GEN:\n-            keySize = 128;\n-            keyType = CKK_DES2;\n-            significantKeySize = 112;\n-            break;\n-        case (int)CKM_DES3_KEY_GEN:\n-            keySize = 192;\n-            keyType = CKK_DES3;\n-            significantKeySize = 168;\n-            break;\n-        case (int)CKM_AES_KEY_GEN:\n-            keySize = adjustKeySize\n-                    (SecurityProviderConstants.getDefAESKeySize(), range);\n-            keyType = CKK_AES;\n-            break;\n-        case (int)CKM_RC4_KEY_GEN:\n-            keySize = adjustKeySize(128, range);\n-            keyType = CKK_RC4;\n-            break;\n-        case (int)CKM_BLOWFISH_KEY_GEN:\n-            keySize = adjustKeySize(128, range);\n-            keyType = CKK_BLOWFISH;\n-            break;\n-        case (int)CKM_CHACHA20_KEY_GEN:\n-            keySize = 256;\n-            keyType = CKK_CHACHA20;\n-            break;\n-        case (int)CKM_SHA_1_KEY_GEN:\n-            keySize = adjustKeySize(160, range);\n-            keyType = CKK_SHA_1_HMAC;\n-            break;\n-        case (int)CKM_SHA224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA224_HMAC;\n-            break;\n-        case (int)CKM_SHA256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA256_HMAC;\n-            break;\n-        case (int)CKM_SHA384_KEY_GEN:\n-            keySize = adjustKeySize(384, range);\n-            keyType = CKK_SHA384_HMAC;\n-            break;\n-        case (int)CKM_SHA512_KEY_GEN:\n-            keySize = adjustKeySize(512, range);\n-            keyType = CKK_SHA512_HMAC;\n-            break;\n-        case (int)CKM_SHA512_224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA512_224_HMAC;\n-            break;\n-        case (int)CKM_SHA512_256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA512_256_HMAC;\n-            break;\n-        case (int)CKM_SHA3_224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA3_224_HMAC;\n-            break;\n-        case (int)CKM_SHA3_256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA3_256_HMAC;\n-            break;\n-        case (int)CKM_SHA3_384_KEY_GEN:\n-            keySize = adjustKeySize(384, range);\n-            keyType = CKK_SHA3_384_HMAC;\n-            break;\n-        case (int)CKM_SHA3_512_KEY_GEN:\n-            keySize = adjustKeySize(512, range);\n-            keyType = CKK_SHA3_512_HMAC;\n-            break;\n-        case (int)CKM_GENERIC_SECRET_KEY_GEN:\n-            if (algorithm.startsWith(\"Hmac\")) {\n-                String digest = algorithm.substring(4);\n-                keySize = adjustKeySize(switch (digest) {\n-                    case \"MD5\" -> 512;\n-                    case \"SHA1\" -> 160;\n-                    case \"SHA224\", \"SHA512\/224\", \"SHA3-224\" -> 224;\n-                    case \"SHA256\", \"SHA512\/256\", \"SHA3-256\" -> 256;\n-                    case \"SHA384\", \"SHA3-384\" -> 384;\n-                    case \"SHA512\", \"SHA3-512\" -> 512;\n-                    default -> {\n-                        throw new ProviderException(\"Unsupported algorithm \" +\n+        switch ((int) mechanism) {\n+            case (int) CKM_DES_KEY_GEN -> {\n+                keySize = 64;\n+                keyType = CKK_DES;\n+                significantKeySize = 56;\n+            }\n+            case (int) CKM_DES2_KEY_GEN -> {\n+                keySize = 128;\n+                keyType = CKK_DES2;\n+                significantKeySize = 112;\n+            }\n+            case (int) CKM_DES3_KEY_GEN -> {\n+                keySize = 192;\n+                keyType = CKK_DES3;\n+                significantKeySize = 168;\n+            }\n+            case (int) CKM_AES_KEY_GEN -> {\n+                keySize = adjustKeySize\n+                        (SecurityProviderConstants.getDefAESKeySize(), range);\n+                keyType = CKK_AES;\n+            }\n+            case (int) CKM_RC4_KEY_GEN -> {\n+                keySize = adjustKeySize(128, range);\n+                keyType = CKK_RC4;\n+            }\n+            case (int) CKM_BLOWFISH_KEY_GEN -> {\n+                keySize = adjustKeySize(128, range);\n+                keyType = CKK_BLOWFISH;\n+            }\n+            case (int) CKM_CHACHA20_KEY_GEN -> {\n+                keySize = 256;\n+                keyType = CKK_CHACHA20;\n+            }\n+            case (int) CKM_SHA_1_KEY_GEN -> {\n+                keySize = adjustKeySize(160, range);\n+                keyType = CKK_SHA_1_HMAC;\n+            }\n+            case (int) CKM_SHA224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA224_HMAC;\n+            }\n+            case (int) CKM_SHA256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA256_HMAC;\n+            }\n+            case (int) CKM_SHA384_KEY_GEN -> {\n+                keySize = adjustKeySize(384, range);\n+                keyType = CKK_SHA384_HMAC;\n+            }\n+            case (int) CKM_SHA512_KEY_GEN -> {\n+                keySize = adjustKeySize(512, range);\n+                keyType = CKK_SHA512_HMAC;\n+            }\n+            case (int) CKM_SHA512_224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA512_224_HMAC;\n+            }\n+            case (int) CKM_SHA512_256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA512_256_HMAC;\n+            }\n+            case (int) CKM_SHA3_224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA3_224_HMAC;\n+            }\n+            case (int) CKM_SHA3_256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA3_256_HMAC;\n+            }\n+            case (int) CKM_SHA3_384_KEY_GEN -> {\n+                keySize = adjustKeySize(384, range);\n+                keyType = CKK_SHA3_384_HMAC;\n+            }\n+            case (int) CKM_SHA3_512_KEY_GEN -> {\n+                keySize = adjustKeySize(512, range);\n+                keyType = CKK_SHA3_512_HMAC;\n+            }\n+            case (int) CKM_GENERIC_SECRET_KEY_GEN -> {\n+                if (algorithm.startsWith(\"Hmac\")) {\n+                    String digest = algorithm.substring(4);\n+                    keySize = adjustKeySize(switch (digest) {\n+                        case \"MD5\" -> 512;\n+                        case \"SHA1\" -> 160;\n+                        case \"SHA224\", \"SHA512\/224\", \"SHA3-224\" -> 224;\n+                        case \"SHA256\", \"SHA512\/256\", \"SHA3-256\" -> 256;\n+                        case \"SHA384\", \"SHA3-384\" -> 384;\n+                        case \"SHA512\", \"SHA3-512\" -> 512;\n+                        default -> {\n+                            throw new ProviderException(\"Unsupported algorithm \" +\n+                                    algorithm);\n+                        }\n+                    }, range);\n+                } else {\n+                    throw new ProviderException(\"Unsupported algorithm \" +\n@@ -302,5 +307,2 @@\n-                    }\n-                }, range);\n-            } else {\n-                throw new ProviderException(\"Unsupported algorithm \" +\n-                        algorithm);\n+                }\n+                keyType = CKK_GENERIC_SECRET;\n@@ -308,4 +310,1 @@\n-            keyType = CKK_GENERIC_SECRET;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism \" + mechanism);\n+            default -> throw new ProviderException(\"Unknown mechanism \" + mechanism);\n@@ -366,15 +365,9 @@\n-            CK_ATTRIBUTE[] attributes;\n-\n-            switch ((int)mechanism) {\n-            case (int)CKM_DES_KEY_GEN:\n-            case (int)CKM_DES2_KEY_GEN:\n-            case (int)CKM_DES3_KEY_GEN:\n-                \/\/ fixed length, do not specify CKA_VALUE_LEN\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                };\n-                break;\n-            default:\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                    new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3),\n+            CK_ATTRIBUTE[] attributes = switch ((int) mechanism) {\n+                case (int) CKM_DES_KEY_GEN, (int) CKM_DES2_KEY_GEN, (int) CKM_DES3_KEY_GEN ->\n+                    \/\/ fixed length, do not specify CKA_VALUE_LEN\n+                        new CK_ATTRIBUTE[]{\n+                                new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        };\n+                default -> new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3),\n@@ -382,2 +375,2 @@\n-                break;\n-            }\n+            };\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":108,"deletions":115,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -175,13 +175,8 @@\n-        if (algorithm.equals(\"DH\")) {\n-            if (params instanceof DHParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"DHParameterSpec required for Diffie-Hellman\");\n-            }\n-            DHParameterSpec dhParams = (DHParameterSpec) params;\n-            tmpKeySize = dhParams.getP().bitLength();\n-            checkKeySize(tmpKeySize, dhParams);\n-            \/\/ XXX sanity check params\n-        } else if (algorithm.equals(\"RSA\")) {\n-            if (params instanceof RSAKeyGenParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"RSAKeyGenParameterSpec required for RSA\");\n+        switch (algorithm) {\n+            case \"DH\" -> {\n+                if (!(params instanceof DHParameterSpec dhParams)) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"DHParameterSpec required for Diffie-Hellman\");\n+                }\n+                tmpKeySize = dhParams.getP().bitLength();\n+                checkKeySize(tmpKeySize, dhParams);\n@@ -189,7 +184,0 @@\n-            RSAKeyGenParameterSpec rsaParams =\n-                (RSAKeyGenParameterSpec) params;\n-            tmpKeySize = rsaParams.getKeysize();\n-            checkKeySize(tmpKeySize, rsaParams);\n-            \/\/ override the supplied params to null\n-            params = null;\n-            this.rsaPublicExponent = rsaParams.getPublicExponent();\n@@ -197,4 +185,10 @@\n-        } else if (algorithm.equals(\"DSA\")) {\n-            if (params instanceof DSAParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"DSAParameterSpec required for DSA\");\n+            case \"RSA\" -> {\n+                if (!(params instanceof RSAKeyGenParameterSpec rsaParams)) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"RSAKeyGenParameterSpec required for RSA\");\n+                }\n+                tmpKeySize = rsaParams.getKeysize();\n+                checkKeySize(tmpKeySize, rsaParams);\n+                \/\/ override the supplied params to null\n+                params = null;\n+                this.rsaPublicExponent = rsaParams.getPublicExponent();\n@@ -202,3 +196,0 @@\n-            DSAParameterSpec dsaParams = (DSAParameterSpec) params;\n-            tmpKeySize = dsaParams.getP().bitLength();\n-            checkKeySize(tmpKeySize, dsaParams);\n@@ -206,6 +197,2 @@\n-        } else if (algorithm.equals(\"EC\")) {\n-            ECParameterSpec ecParams;\n-            if (params instanceof ECParameterSpec) {\n-                ecParams = P11ECKeyFactory.getECParameterSpec(\n-                    (ECParameterSpec)params);\n-                if (ecParams == null) {\n+            case \"DSA\" -> {\n+                if (!(params instanceof DSAParameterSpec dsaParams)) {\n@@ -213,1 +200,1 @@\n-                        (\"Unsupported curve: \" + params);\n+                            (\"DSAParameterSpec required for DSA\");\n@@ -215,4 +202,22 @@\n-            } else if (params instanceof ECGenParameterSpec) {\n-                String name = ((ECGenParameterSpec) params).getName();\n-                ecParams = P11ECKeyFactory.getECParameterSpec(name);\n-                if (ecParams == null) {\n+                tmpKeySize = dsaParams.getP().bitLength();\n+                checkKeySize(tmpKeySize, dsaParams);\n+            }\n+            \/\/ XXX sanity check params\n+            case \"EC\" -> {\n+                ECParameterSpec ecParams;\n+                if (params instanceof ECParameterSpec ecParameterSpec) {\n+                    ecParams = P11ECKeyFactory.getECParameterSpec(ecParameterSpec);\n+                    if (ecParams == null) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Unsupported curve: \" + params);\n+                    }\n+                } else if (params instanceof ECGenParameterSpec ecGenParameterSpec) {\n+                    String name = ecGenParameterSpec.getName();\n+                    ecParams = P11ECKeyFactory.getECParameterSpec(name);\n+                    if (ecParams == null) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Unknown curve name: \" + name);\n+                    }\n+                    \/\/ override the supplied params with the derived one\n+                    params = ecParams;\n+                } else {\n@@ -220,1 +225,1 @@\n-                        (\"Unknown curve name: \" + name);\n+                            (\"ECParameterSpec or ECGenParameterSpec required for EC\");\n@@ -222,5 +227,2 @@\n-                \/\/ override the supplied params with the derived one\n-                params = ecParams;\n-            } else {\n-                throw new InvalidAlgorithmParameterException\n-                    (\"ECParameterSpec or ECGenParameterSpec required for EC\");\n+                tmpKeySize = ecParams.getCurve().getField().getFieldSize();\n+                checkKeySize(tmpKeySize, ecParams);\n@@ -228,4 +230,1 @@\n-            tmpKeySize = ecParams.getCurve().getField().getFieldSize();\n-            checkKeySize(tmpKeySize, ecParams);\n-        } else {\n-            throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n+            default -> throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n@@ -340,19 +339,24 @@\n-        if (algorithm.equals(\"RSA\")) {\n-            keyType = CKK_RSA;\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS_BITS, keySize),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT, rsaPublicExponent),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else if (algorithm.equals(\"DSA\")) {\n-            keyType = CKK_DSA;\n-            DSAParameterSpec dsaParams;\n-            if (params == null) {\n-                try {\n-                    dsaParams = ParameterCache.getDSAParameterSpec\n-                                                    (keySize, random);\n-                } catch (GeneralSecurityException e) {\n-                    throw new ProviderException\n-                            (\"Could not generate DSA parameters\", e);\n+        switch (algorithm) {\n+            case \"RSA\" -> {\n+                keyType = CKK_RSA;\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_MODULUS_BITS, keySize),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT, rsaPublicExponent),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n+            }\n+            case \"DSA\" -> {\n+                keyType = CKK_DSA;\n+                DSAParameterSpec dsaParams;\n+                if (params == null) {\n+                    try {\n+                        dsaParams = ParameterCache.getDSAParameterSpec\n+                                (keySize, random);\n+                    } catch (GeneralSecurityException e) {\n+                        throw new ProviderException\n+                                (\"Could not generate DSA parameters\", e);\n+                    }\n+                } else {\n+                    dsaParams = (DSAParameterSpec) params;\n@@ -360,2 +364,8 @@\n-            } else {\n-                dsaParams = (DSAParameterSpec)params;\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_PRIME, dsaParams.getP()),\n+                        new CK_ATTRIBUTE(CKA_SUBPRIME, dsaParams.getQ()),\n+                        new CK_ATTRIBUTE(CKA_BASE, dsaParams.getG()),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n@@ -363,19 +373,16 @@\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_PRIME, dsaParams.getP()),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME, dsaParams.getQ()),\n-                new CK_ATTRIBUTE(CKA_BASE, dsaParams.getG()),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else if (algorithm.equals(\"DH\")) {\n-            keyType = CKK_DH;\n-            DHParameterSpec dhParams;\n-            int privateBits;\n-            if (params == null) {\n-                try {\n-                    dhParams = ParameterCache.getDHParameterSpec\n-                                                    (keySize, random);\n-                } catch (GeneralSecurityException e) {\n-                    throw new ProviderException\n-                            (\"Could not generate DH parameters\", e);\n+            case \"DH\" -> {\n+                keyType = CKK_DH;\n+                DHParameterSpec dhParams;\n+                int privateBits;\n+                if (params == null) {\n+                    try {\n+                        dhParams = ParameterCache.getDHParameterSpec\n+                                (keySize, random);\n+                    } catch (GeneralSecurityException e) {\n+                        throw new ProviderException\n+                                (\"Could not generate DH parameters\", e);\n+                    }\n+                    privateBits = 0;\n+                } else {\n+                    dhParams = (DHParameterSpec) params;\n+                    privateBits = dhParams.getL();\n@@ -383,4 +390,11 @@\n-                privateBits = 0;\n-            } else {\n-                dhParams = (DHParameterSpec)params;\n-                privateBits = dhParams.getL();\n+                if (privateBits <= 0) {\n+                    \/\/ XXX find better defaults\n+                    privateBits = (keySize >= 1024) ? 768 : 512;\n+                }\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_PRIME, dhParams.getP()),\n+                        new CK_ATTRIBUTE(CKA_BASE, dhParams.getG())\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n+                };\n@@ -388,3 +402,10 @@\n-            if (privateBits <= 0) {\n-                \/\/ XXX find better defaults\n-                privateBits = (keySize >= 1024) ? 768 : 512;\n+            case \"EC\" -> {\n+                keyType = CKK_EC;\n+                byte[] encodedParams =\n+                        P11ECKeyFactory.encodeParameters((ECParameterSpec) params);\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, encodedParams),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n@@ -392,19 +413,1 @@\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_PRIME, dhParams.getP()),\n-                new CK_ATTRIBUTE(CKA_BASE, dhParams.getG())\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n-            };\n-        } else if (algorithm.equals(\"EC\")) {\n-            keyType = CKK_EC;\n-            byte[] encodedParams =\n-                    P11ECKeyFactory.encodeParameters((ECParameterSpec)params);\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, encodedParams),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else {\n-            throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n+            default -> throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyPairGenerator.java","additions":117,"deletions":114,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -782,1 +782,1 @@\n-            if (mapLabels() == true) {\n+            if (mapLabels()) {\n@@ -864,1 +864,1 @@\n-            if (mapLabels() == true) {\n+            if (mapLabels()) {\n@@ -1033,1 +1033,1 @@\n-            if (useSecmodTrust == false) {\n+            if (!useSecmodTrust) {\n@@ -1046,1 +1046,1 @@\n-            if (cert instanceof X509Certificate == false) {\n+            if (!(cert instanceof X509Certificate xcert)) {\n@@ -1049,1 +1049,0 @@\n-            X509Certificate xcert = (X509Certificate)cert;\n@@ -1125,1 +1124,1 @@\n-            } else if (entry instanceof KeyStore.SecretKeyEntry) {\n+            } else if (entry instanceof SecretKeyEntry ske) {\n@@ -1127,1 +1126,0 @@\n-                KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;\n@@ -1218,1 +1216,1 @@\n-            lChain = new ArrayList<X509Certificate>();\n+            lChain = new ArrayList<>();\n@@ -1512,1 +1510,1 @@\n-            if (key.tokenObject == true) {\n+            if (key.tokenObject) {\n@@ -1552,1 +1550,1 @@\n-        ArrayList<CK_ATTRIBUTE> attrList = new ArrayList<CK_ATTRIBUTE>();\n+        ArrayList<CK_ATTRIBUTE> attrList = new ArrayList<>();\n@@ -1676,2 +1674,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n@@ -1694,3 +1691,1 @@\n-        } else if (key instanceof DSAPrivateKey) {\n-\n-            DSAPrivateKey dsaKey = (DSAPrivateKey)key;\n+        } else if (key instanceof DSAPrivateKey dsaKey) {\n@@ -1725,3 +1720,1 @@\n-        } else if (key instanceof DHPrivateKey) {\n-\n-            DHPrivateKey dhKey = (DHPrivateKey)key;\n+        } else if (key instanceof DHPrivateKey dhKey) {\n@@ -1751,3 +1744,1 @@\n-        } else if (key instanceof ECPrivateKey) {\n-\n-            ECPrivateKey ecKey = (ECPrivateKey)key;\n+        } else if (key instanceof ECPrivateKey ecKey) {\n@@ -1782,1 +1773,1 @@\n-        } else if (key instanceof P11Key) {\n+        } else if (key instanceof P11Key p11Key) {\n@@ -1784,1 +1775,0 @@\n-            P11Key p11Key = (P11Key)key;\n@@ -1834,1 +1824,1 @@\n-        if (key instanceof RSAPrivateCrtKey) {\n+        if (key instanceof RSAPrivateCrtKey rsaKey) {\n@@ -1840,2 +1830,0 @@\n-            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n-\n@@ -1873,2 +1861,0 @@\n-            RSAPrivateKey rsaKey = key;\n-\n@@ -1882,1 +1868,1 @@\n-                                rsaKey.getModulus()),\n+                                key.getModulus()),\n@@ -1884,1 +1870,1 @@\n-                                rsaKey.getPrivateExponent()) };\n+                                key.getPrivateExponent()) };\n@@ -1908,1 +1894,1 @@\n-        if ((id || netscapeDb) == false) {\n+        if (!(id || netscapeDb)) {\n@@ -2013,1 +1999,1 @@\n-                    \/\/ self signed - done\n+                    \/\/ self-signed - done\n@@ -2236,1 +2222,1 @@\n-                ArrayList<THandle> list = new ArrayList<THandle>(h.length);\n+                ArrayList<THandle> list = new ArrayList<>(h.length);\n@@ -2302,1 +2288,1 @@\n-            ArrayList<byte[]> pkeyIDs = new ArrayList<byte[]>();\n+            ArrayList<byte[]> pkeyIDs = new ArrayList<>();\n@@ -2329,1 +2315,1 @@\n-                                new HashMap<String, HashSet<AliasInfo>>();\n+                                new HashMap<>();\n@@ -2402,5 +2388,1 @@\n-                HashSet<AliasInfo> infoSet = certMap.get(cka_label);\n-                if (infoSet == null) {\n-                    infoSet = new HashSet<AliasInfo>(2);\n-                    certMap.put(cka_label, infoSet);\n-                }\n+                HashSet<AliasInfo> infoSet = certMap.computeIfAbsent(cka_label, k -> new HashSet<>(2));\n@@ -2424,1 +2406,1 @@\n-                    new HashMap<String, AliasInfo>();\n+                    new HashMap<>();\n@@ -2480,1 +2462,1 @@\n-        aliasMap = new HashMap<String, AliasInfo>();\n+        aliasMap = new HashMap<>();\n@@ -2483,1 +2465,1 @@\n-        ArrayList<AliasInfo> matchedCerts = new ArrayList<AliasInfo>();\n+        ArrayList<AliasInfo> matchedCerts = new ArrayList<>();\n@@ -2569,1 +2551,1 @@\n-                if (aliasInfo.matched == true) {\n+                if (aliasInfo.matched) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyStore.java","additions":26,"deletions":44,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -348,2 +348,1 @@\n-                case Cipher.ENCRYPT_MODE:\n-                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                    case Cipher.ENCRYPT_MODE -> token.p11.C_EncryptInit(session.id(), mechWithParams,\n@@ -351,3 +350,1 @@\n-                break;\n-                case Cipher.DECRYPT_MODE:\n-                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                    case Cipher.DECRYPT_MODE -> token.p11.C_DecryptInit(session.id(), mechWithParams,\n@@ -355,1 +352,0 @@\n-                break;\n@@ -389,1 +385,1 @@\n-        return (result > 0 ? result : 0);\n+        return (Math.max(result, 0));\n@@ -747,1 +743,1 @@\n-            case Cipher.PRIVATE_KEY:\n+            case Cipher.PRIVATE_KEY -> {\n@@ -750,2 +746,2 @@\n-                break;\n-            case Cipher.SECRET_KEY:\n+            }\n+            case Cipher.SECRET_KEY -> {\n@@ -754,7 +750,6 @@\n-                break;\n-            case Cipher.PUBLIC_KEY:\n-                throw new UnsupportedOperationException\n-                        (\"cannot unwrap public keys\");\n-            default: \/\/ should never happen\n-                throw new AssertionError();\n-        };\n+            }\n+            case Cipher.PUBLIC_KEY -> throw new UnsupportedOperationException\n+                    (\"cannot unwrap public keys\");\n+            default -> \/\/ should never happen\n+                    throw new AssertionError();\n+        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -88,36 +88,17 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD5_HMAC:\n-            macLength = 16;\n-            break;\n-        case (int)CKM_SHA_1_HMAC:\n-            macLength = 20;\n-            break;\n-        case (int)CKM_SHA224_HMAC:\n-        case (int)CKM_SHA512_224_HMAC:\n-        case (int)CKM_SHA3_224_HMAC:\n-            macLength = 28;\n-            break;\n-        case (int)CKM_SHA256_HMAC:\n-        case (int)CKM_SHA512_256_HMAC:\n-        case (int)CKM_SHA3_256_HMAC:\n-            macLength = 32;\n-            break;\n-        case (int)CKM_SHA384_HMAC:\n-        case (int)CKM_SHA3_384_HMAC:\n-            macLength = 48;\n-            break;\n-        case (int)CKM_SHA512_HMAC:\n-        case (int)CKM_SHA3_512_HMAC:\n-            macLength = 64;\n-            break;\n-        case (int)CKM_SSL3_MD5_MAC:\n-            macLength = 16;\n-            params = Long.valueOf(16);\n-            break;\n-        case (int)CKM_SSL3_SHA1_MAC:\n-            macLength = 20;\n-            params = Long.valueOf(20);\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n-        }\n+        macLength = switch ((int) mechanism) {\n+            case (int) CKM_MD5_HMAC -> 16;\n+            case (int) CKM_SHA_1_HMAC -> 20;\n+            case (int) CKM_SHA224_HMAC, (int) CKM_SHA512_224_HMAC, (int) CKM_SHA3_224_HMAC -> 28;\n+            case (int) CKM_SHA256_HMAC, (int) CKM_SHA512_256_HMAC, (int) CKM_SHA3_256_HMAC -> 32;\n+            case (int) CKM_SHA384_HMAC, (int) CKM_SHA3_384_HMAC -> 48;\n+            case (int) CKM_SHA512_HMAC, (int) CKM_SHA3_512_HMAC -> 64;\n+            case (int) CKM_SSL3_MD5_MAC -> {\n+                params = Long.valueOf(16);\n+                yield 16;\n+            }\n+            case (int) CKM_SSL3_SHA1_MAC -> {\n+                params = Long.valueOf(20);\n+                yield 20;\n+            }\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+        };\n@@ -268,1 +249,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer directBuffer)) {\n@@ -272,1 +253,1 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n+            long addr = directBuffer.address();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":19,"deletions":38,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-    private static final Hashtable<String, Integer> DIGEST_LENGTHS =\n-        new Hashtable<String, Integer>();\n+    private static final Hashtable<String, Integer> DIGEST_LENGTHS = new Hashtable<>();\n@@ -176,19 +175,12 @@\n-        switch ((int)mechId) {\n-        case (int)CKM_SHA1_RSA_PKCS_PSS:\n-        case (int)CKM_SHA224_RSA_PKCS_PSS:\n-        case (int)CKM_SHA256_RSA_PKCS_PSS:\n-        case (int)CKM_SHA384_RSA_PKCS_PSS:\n-        case (int)CKM_SHA512_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_224_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_256_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_384_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_512_RSA_PKCS_PSS:\n-            type = T_UPDATE;\n-            this.md = null;\n-            break;\n-        case (int)CKM_RSA_PKCS_PSS:\n-            \/\/ check if the digest algo is supported by underlying PKCS11 lib\n-            if (this.mdAlg != null && token.getMechanismInfo\n-                    (Functions.getHashMechId(this.mdAlg)) == null) {\n-                throw new NoSuchAlgorithmException(\"Unsupported algorithm: \" +\n-                        algorithm);\n+        switch ((int) mechId) {\n+            case (int) CKM_SHA1_RSA_PKCS_PSS,\n+                 (int) CKM_SHA224_RSA_PKCS_PSS,\n+                 (int) CKM_SHA256_RSA_PKCS_PSS,\n+                 (int) CKM_SHA384_RSA_PKCS_PSS,\n+                 (int) CKM_SHA512_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_224_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_256_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_384_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_512_RSA_PKCS_PSS -> {\n+                type = T_UPDATE;\n+                this.md = null;\n@@ -196,6 +188,12 @@\n-            this.md = (this.mdAlg == null ? null :\n-                    MessageDigest.getInstance(this.mdAlg));\n-            type = T_DIGEST;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unsupported mechanism: \" + mechId);\n+            case (int) CKM_RSA_PKCS_PSS -> {\n+                \/\/ check if the digest algo is supported by underlying PKCS11 lib\n+                if (this.mdAlg != null && token.getMechanismInfo\n+                        (Functions.getHashMechId(this.mdAlg)) == null) {\n+                    throw new NoSuchAlgorithmException(\"Unsupported algorithm: \" +\n+                            algorithm);\n+                }\n+                this.md = (this.mdAlg == null ? null :\n+                        MessageDigest.getInstance(this.mdAlg));\n+                type = T_DIGEST;\n+            }\n+            default -> throw new ProviderException(\"Unsupported mechanism: \" + mechId);\n@@ -238,1 +236,1 @@\n-        if (initialized == false) {\n+        if (!initialized) {\n@@ -416,1 +414,1 @@\n-        if (!(p instanceof PSSParameterSpec)) {\n+        if (!(p instanceof PSSParameterSpec params)) {\n@@ -421,1 +419,0 @@\n-        PSSParameterSpec params = (PSSParameterSpec) p;\n@@ -618,5 +615,24 @@\n-        case T_UPDATE:\n-            if (byteBuffer instanceof DirectBuffer == false) {\n-                \/\/ cannot do better than default impl\n-                super.engineUpdate(byteBuffer);\n-                return;\n+            case T_UPDATE -> {\n+                if (byteBuffer instanceof DirectBuffer == false) {\n+                    \/\/ cannot do better than default impl\n+                    super.engineUpdate(byteBuffer);\n+                    return;\n+                }\n+                long addr = ((DirectBuffer) byteBuffer).address();\n+                int ofs = byteBuffer.position();\n+                try {\n+                    if (mode == M_SIGN) {\n+                        if (DEBUG) System.out.println(this + \": Calling C_SignUpdate\");\n+                        token.p11.C_SignUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    } else {\n+                        if (DEBUG) System.out.println(this + \": Calling C_VerifyUpdate\");\n+                        token.p11.C_VerifyUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    }\n+                    bytesProcessed += len;\n+                    byteBuffer.position(ofs + len);\n+                } catch (PKCS11Exception e) {\n+                    reset(false);\n+                    throw new ProviderException(\"Update failed\", e);\n+                }\n@@ -624,11 +640,4 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n-            int ofs = byteBuffer.position();\n-            try {\n-                if (mode == M_SIGN) {\n-                    if (DEBUG) System.out.println(this + \": Calling C_SignUpdate\");\n-                    token.p11.C_SignUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n-                } else {\n-                    if (DEBUG) System.out.println(this + \": Calling C_VerifyUpdate\");\n-                    token.p11.C_VerifyUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n+            case T_DIGEST -> {\n+                \/\/ should not happen as this should be covered by earlier checks\n+                if (md == null) {\n+                    throw new ProviderException(\"PSS Parameters required\");\n@@ -636,0 +645,1 @@\n+                md.update(byteBuffer);\n@@ -637,4 +647,0 @@\n-                byteBuffer.position(ofs + len);\n-            } catch (PKCS11Exception e) {\n-                reset(false);\n-                throw new ProviderException(\"Update failed\", e);\n@@ -642,5 +648,3 @@\n-            break;\n-        case T_DIGEST:\n-            \/\/ should not happen as this should be covered by earlier checks\n-            if (md == null) {\n-                throw new ProviderException(\"PSS Parameters required\");\n+            default -> {\n+                reset(false);\n+                throw new ProviderException(\"Internal error\");\n@@ -648,6 +652,0 @@\n-            md.update(byteBuffer);\n-            bytesProcessed += len;\n-            break;\n-        default:\n-            reset(false);\n-            throw new ProviderException(\"Internal error\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":59,"deletions":61,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -208,1 +208,1 @@\n-            if (p11Key.isPublic() == false) {\n+            if (!p11Key.isPublic()) {\n@@ -216,1 +216,1 @@\n-            if (p11Key.isPrivate() == false) {\n+            if (!p11Key.isPrivate()) {\n@@ -292,12 +292,7 @@\n-            case MODE_ENCRYPT:\n-                p11.C_Encrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n-                break;\n-            case MODE_DECRYPT:\n-                p11.C_Decrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n-                break;\n-            case MODE_SIGN:\n-                byte[] tmpBuffer = new byte[maxInputSize];\n-                p11.C_Sign(sessId, tmpBuffer);\n-                break;\n-            case MODE_VERIFY:\n-                p11.C_VerifyRecover(sessId, buffer, 0, inLen, buffer,\n+                case MODE_ENCRYPT -> p11.C_Encrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n+                case MODE_DECRYPT -> p11.C_Decrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n+                case MODE_SIGN -> {\n+                    byte[] tmpBuffer = new byte[maxInputSize];\n+                    p11.C_Sign(sessId, tmpBuffer);\n+                }\n+                case MODE_VERIFY -> p11.C_VerifyRecover(sessId, buffer, 0, inLen, buffer,\n@@ -305,3 +300,1 @@\n-                break;\n-            default:\n-                throw new ProviderException(\"internal error\");\n+                default -> throw new ProviderException(\"internal error\");\n@@ -335,14 +328,5 @@\n-            case MODE_ENCRYPT:\n-                p11.C_EncryptInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_DECRYPT:\n-                p11.C_DecryptInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_SIGN:\n-                p11.C_SignInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_VERIFY:\n-                p11.C_VerifyRecoverInit(session.id(), ckMechanism, keyID);\n-                break;\n-            default:\n-                throw new AssertionError(\"internal error\");\n+                case MODE_ENCRYPT -> p11.C_EncryptInit(session.id(), ckMechanism, keyID);\n+                case MODE_DECRYPT -> p11.C_DecryptInit(session.id(), ckMechanism, keyID);\n+                case MODE_SIGN -> p11.C_SignInit(session.id(), ckMechanism, keyID);\n+                case MODE_VERIFY -> p11.C_VerifyRecoverInit(session.id(), ckMechanism, keyID);\n+                default -> throw new AssertionError(\"internal error\");\n@@ -386,4 +370,2 @@\n-            int n;\n-            switch (mode) {\n-            case MODE_ENCRYPT:\n-                n = p11.C_Encrypt\n+            return switch (mode) {\n+                case MODE_ENCRYPT -> p11.C_Encrypt\n@@ -391,3 +373,1 @@\n-                break;\n-            case MODE_DECRYPT:\n-                n = p11.C_Decrypt\n+                case MODE_DECRYPT ->  p11.C_Decrypt\n@@ -395,9 +375,11 @@\n-                break;\n-            case MODE_SIGN:\n-                byte[] tmpBuffer = new byte[bufOfs];\n-                System.arraycopy(buffer, 0, tmpBuffer, 0, bufOfs);\n-                tmpBuffer = p11.C_Sign(session.id(), tmpBuffer);\n-                if (tmpBuffer.length > outLen) {\n-                    throw new BadPaddingException(\n-                        \"Output buffer (\" + outLen + \") is too small to \" +\n-                        \"hold the produced data (\" + tmpBuffer.length + \")\");\n+                case MODE_SIGN -> {\n+                    byte[] tmpBuffer = new byte[bufOfs];\n+                    System.arraycopy(buffer, 0, tmpBuffer, 0, bufOfs);\n+                    tmpBuffer = p11.C_Sign(session.id(), tmpBuffer);\n+                    if (tmpBuffer.length > outLen) {\n+                        throw new BadPaddingException(\n+                                \"Output buffer (\" + outLen + \") is too small to \" +\n+                                        \"hold the produced data (\" + tmpBuffer.length + \")\");\n+                    }\n+                    System.arraycopy(tmpBuffer, 0, out, outOfs, tmpBuffer.length);\n+                    yield tmpBuffer.length;\n@@ -405,5 +387,1 @@\n-                System.arraycopy(tmpBuffer, 0, out, outOfs, tmpBuffer.length);\n-                n = tmpBuffer.length;\n-                break;\n-            case MODE_VERIFY:\n-                n = p11.C_VerifyRecover\n+                case MODE_VERIFY -> p11.C_VerifyRecover\n@@ -411,5 +389,2 @@\n-                break;\n-            default:\n-                throw new ProviderException(\"internal error\");\n-            }\n-            return n;\n+                default -> throw new ProviderException(\"internal error\");\n+            };\n@@ -714,10 +689,6 @@\n-        switch (keyType) {\n-        case Cipher.SECRET_KEY:\n-            return constructSecretKey(encoding, keyAlgorithm);\n-        case Cipher.PRIVATE_KEY:\n-            return constructPrivateKey(encoding, keyAlgorithm);\n-        case Cipher.PUBLIC_KEY:\n-            return constructPublicKey(encoding, keyAlgorithm);\n-        default:\n-            throw new InvalidKeyException(\"Unknown keytype \" + keyType);\n-        }\n+        return switch (keyType) {\n+            case Cipher.SECRET_KEY -> constructSecretKey(encoding, keyAlgorithm);\n+            case Cipher.PRIVATE_KEY -> constructPrivateKey(encoding, keyAlgorithm);\n+            case Cipher.PUBLIC_KEY -> constructPublicKey(encoding, keyAlgorithm);\n+            default -> throw new InvalidKeyException(\"Unknown keytype \" + keyType);\n+        };\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSACipher.java","additions":39,"deletions":68,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-            if (key instanceof RSAPublicKey) {\n-                RSAPublicKey rsaKey = (RSAPublicKey)key;\n+            if (key instanceof RSAPublicKey rsaKey) {\n@@ -77,2 +76,1 @@\n-            if (key instanceof RSAPrivateCrtKey) {\n-                RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n+            if (key instanceof RSAPrivateCrtKey rsaKey) {\n@@ -89,2 +87,1 @@\n-            } else if (key instanceof RSAPrivateKey) {\n-                RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n+            } else if (key instanceof RSAPrivateKey rsaKey) {\n@@ -120,1 +117,1 @@\n-        if (keySpec instanceof RSAPublicKeySpec == false) {\n+        if (!(keySpec instanceof RSAPublicKeySpec)) {\n@@ -291,2 +288,1 @@\n-            if (key instanceof RSAPrivateCrtKey) {\n-                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+            if (key instanceof RSAPrivateCrtKey crtKey) {\n@@ -310,1 +306,1 @@\n-                if (!(key instanceof RSAPrivateKey)) {\n+                if (!(key instanceof RSAPrivateKey rsaKey)) {\n@@ -318,1 +314,0 @@\n-                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-        if (key instanceof SecretKey == false) {\n+        if (!(key instanceof SecretKey)) {\n@@ -158,2 +158,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n@@ -188,1 +187,1 @@\n-        if (\"RAW\".equalsIgnoreCase(key.getFormat()) == false) {\n+        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n@@ -211,2 +210,2 @@\n-            switch ((int)keyType) {\n-                case (int)CKK_DES:\n+            switch ((int) keyType) {\n+                case (int) CKK_DES -> {\n@@ -214,1 +213,1 @@\n-                        P11KeyGenerator.checkKeySize(CKM_DES_KEY_GEN, n, token);\n+                            P11KeyGenerator.checkKeySize(CKM_DES_KEY_GEN, n, token);\n@@ -216,2 +215,2 @@\n-                    break;\n-                case (int)CKK_DES3:\n+                }\n+                case (int) CKK_DES3 -> {\n@@ -219,1 +218,1 @@\n-                        P11KeyGenerator.checkKeySize(CKM_DES3_KEY_GEN, n, token);\n+                            P11KeyGenerator.checkKeySize(CKM_DES3_KEY_GEN, n, token);\n@@ -228,3 +227,2 @@\n-                    break;\n-                case (int)CKK_AES:\n-                    keyLength =\n+                }\n+                case (int) CKK_AES -> keyLength =\n@@ -232,3 +230,1 @@\n-                    break;\n-                case (int)CKK_RC4:\n-                    keyLength =\n+                case (int) CKK_RC4 -> keyLength =\n@@ -236,3 +232,1 @@\n-                    break;\n-                case (int)CKK_BLOWFISH:\n-                    keyLength =\n+                case (int) CKK_BLOWFISH -> keyLength =\n@@ -240,4 +234,2 @@\n-                        token);\n-                    break;\n-                case (int)CKK_CHACHA20:\n-                    keyLength = P11KeyGenerator.checkKeySize(\n+                                token);\n+                case (int) CKK_CHACHA20 -> keyLength = P11KeyGenerator.checkKeySize(\n@@ -245,9 +237,3 @@\n-                    break;\n-                case (int)CKK_GENERIC_SECRET:\n-                case (int)PCKK_TLSPREMASTER:\n-                case (int)PCKK_TLSRSAPREMASTER:\n-                case (int)PCKK_TLSMASTER:\n-                    keyType = CKK_GENERIC_SECRET;\n-                    break;\n-                case (int)PCKK_SSLMAC:\n-                case (int)PCKK_HMAC:\n+                case (int) CKK_GENERIC_SECRET, (int) PCKK_TLSPREMASTER, (int) PCKK_TLSRSAPREMASTER, (int) PCKK_TLSMASTER ->\n+                        keyType = CKK_GENERIC_SECRET;\n+                case (int) PCKK_SSLMAC, (int) PCKK_HMAC -> {\n@@ -259,4 +245,3 @@\n-                    break;\n-                default:\n-                    throw new InvalidKeyException(\"Unknown algorithm \" +\n-                            algorithm);\n+                }\n+                default -> throw new InvalidKeyException(\"Unknown algorithm \" +\n+                        algorithm);\n@@ -331,1 +316,1 @@\n-            if (\"RAW\".equalsIgnoreCase(key.getFormat()) == false) {\n+            if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":22,"deletions":37,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -175,54 +175,15 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD2_RSA_PKCS:\n-        case (int)CKM_MD5_RSA_PKCS:\n-        case (int)CKM_SHA1_RSA_PKCS:\n-        case (int)CKM_SHA224_RSA_PKCS:\n-        case (int)CKM_SHA256_RSA_PKCS:\n-        case (int)CKM_SHA384_RSA_PKCS:\n-        case (int)CKM_SHA512_RSA_PKCS:\n-        case (int)CKM_SHA3_224_RSA_PKCS:\n-        case (int)CKM_SHA3_256_RSA_PKCS:\n-        case (int)CKM_SHA3_384_RSA_PKCS:\n-        case (int)CKM_SHA3_512_RSA_PKCS:\n-            keyAlgorithm = \"RSA\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_DSA_SHA1:\n-        case (int)CKM_DSA_SHA224:\n-        case (int)CKM_DSA_SHA256:\n-        case (int)CKM_DSA_SHA384:\n-        case (int)CKM_DSA_SHA512:\n-        case (int)CKM_DSA_SHA3_224:\n-        case (int)CKM_DSA_SHA3_256:\n-        case (int)CKM_DSA_SHA3_384:\n-        case (int)CKM_DSA_SHA3_512:\n-            keyAlgorithm = \"DSA\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_ECDSA_SHA1:\n-        case (int)CKM_ECDSA_SHA224:\n-        case (int)CKM_ECDSA_SHA256:\n-        case (int)CKM_ECDSA_SHA384:\n-        case (int)CKM_ECDSA_SHA512:\n-        case (int)CKM_ECDSA_SHA3_224:\n-        case (int)CKM_ECDSA_SHA3_256:\n-        case (int)CKM_ECDSA_SHA3_384:\n-        case (int)CKM_ECDSA_SHA3_512:\n-            keyAlgorithm = \"EC\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_DSA:\n-            keyAlgorithm = \"DSA\";\n-            if (algorithm.equals(\"DSA\") ||\n-                algorithm.equals(\"DSAinP1363Format\")) {\n-                type = T_DIGEST;\n-                md = MessageDigest.getInstance(\"SHA-1\");\n-            } else if (algorithm.equals(\"RawDSA\") ||\n-                       algorithm.equals(\"RawDSAinP1363Format\")) {\n-                type = T_RAW;\n-                buffer = new byte[20];\n-            } else {\n-                throw new ProviderException(algorithm);\n+        switch ((int) mechanism) {\n+            case (int) CKM_MD2_RSA_PKCS,\n+                    (int) CKM_MD5_RSA_PKCS,\n+                    (int) CKM_SHA1_RSA_PKCS,\n+                    (int) CKM_SHA224_RSA_PKCS,\n+                    (int) CKM_SHA256_RSA_PKCS,\n+                    (int) CKM_SHA384_RSA_PKCS,\n+                    (int) CKM_SHA512_RSA_PKCS,\n+                    (int) CKM_SHA3_224_RSA_PKCS,\n+                    (int) CKM_SHA3_256_RSA_PKCS,\n+                    (int) CKM_SHA3_384_RSA_PKCS,\n+                    (int) CKM_SHA3_512_RSA_PKCS -> {\n+                keyAlgorithm = \"RSA\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n@@ -230,8 +191,54 @@\n-            break;\n-        case (int)CKM_ECDSA:\n-            keyAlgorithm = \"EC\";\n-            if (algorithm.equals(\"NONEwithECDSA\") ||\n-                algorithm.equals(\"NONEwithECDSAinP1363Format\")) {\n-                type = T_RAW;\n-                buffer = new byte[RAW_ECDSA_MAX];\n-            } else {\n+            case (int) CKM_DSA_SHA1,\n+                    (int) CKM_DSA_SHA224,\n+                    (int) CKM_DSA_SHA256,\n+                    (int) CKM_DSA_SHA384,\n+                    (int) CKM_DSA_SHA512,\n+                    (int) CKM_DSA_SHA3_224,\n+                    (int) CKM_DSA_SHA3_256,\n+                    (int) CKM_DSA_SHA3_384,\n+                    (int) CKM_DSA_SHA3_512 -> {\n+                keyAlgorithm = \"DSA\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n+            }\n+            case (int) CKM_ECDSA_SHA1,\n+                    (int) CKM_ECDSA_SHA224,\n+                    (int) CKM_ECDSA_SHA256,\n+                    (int) CKM_ECDSA_SHA384,\n+                    (int) CKM_ECDSA_SHA512,\n+                    (int) CKM_ECDSA_SHA3_224,\n+                    (int) CKM_ECDSA_SHA3_256,\n+                    (int) CKM_ECDSA_SHA3_384,\n+                    (int) CKM_ECDSA_SHA3_512 -> {\n+                keyAlgorithm = \"EC\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n+            }\n+            case (int) CKM_DSA -> {\n+                keyAlgorithm = \"DSA\";\n+                if (algorithm.equals(\"DSA\") ||\n+                        algorithm.equals(\"DSAinP1363Format\")) {\n+                    type = T_DIGEST;\n+                    md = MessageDigest.getInstance(\"SHA-1\");\n+                } else if (algorithm.equals(\"RawDSA\") ||\n+                        algorithm.equals(\"RawDSAinP1363Format\")) {\n+                    type = T_RAW;\n+                    buffer = new byte[20];\n+                } else {\n+                    throw new ProviderException(algorithm);\n+                }\n+            }\n+            case (int) CKM_ECDSA -> {\n+                keyAlgorithm = \"EC\";\n+                if (algorithm.equals(\"NONEwithECDSA\") ||\n+                        algorithm.equals(\"NONEwithECDSAinP1363Format\")) {\n+                    type = T_RAW;\n+                    buffer = new byte[RAW_ECDSA_MAX];\n+                } else {\n+                    type = T_DIGEST;\n+                    md = MessageDigest.getInstance\n+                            (getDigestEnum(algorithm).stdName());\n+                }\n+            }\n+            case (int) CKM_RSA_PKCS, (int) CKM_RSA_X_509 -> {\n+                keyAlgorithm = \"RSA\";\n@@ -239,2 +246,3 @@\n-                md = MessageDigest.getInstance\n-                        (getDigestEnum(algorithm).stdName());\n+                KnownOIDs digestAlg = getDigestEnum(algorithm);\n+                md = MessageDigest.getInstance(digestAlg.stdName());\n+                digestOID = ObjectIdentifier.of(digestAlg);\n@@ -242,11 +250,1 @@\n-            break;\n-        case (int)CKM_RSA_PKCS:\n-        case (int)CKM_RSA_X_509:\n-            keyAlgorithm = \"RSA\";\n-            type = T_DIGEST;\n-            KnownOIDs digestAlg = getDigestEnum(algorithm);\n-            md = MessageDigest.getInstance(digestAlg.stdName());\n-            digestOID = ObjectIdentifier.of(digestAlg);\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n@@ -411,2 +409,2 @@\n-        if (key instanceof P11Key) {\n-            keySize = ((P11Key) key).length();\n+        if (key instanceof P11Key keyP11) {\n+            keySize = keyP11.length();\n@@ -415,9 +413,6 @@\n-                if (keyAlgo.equals(\"RSA\")) {\n-                    keySize = ((RSAKey) key).getModulus().bitLength();\n-                } else if (keyAlgo.equals(\"DSA\")) {\n-                    keySize = ((DSAKey) key).getParams().getP().bitLength();\n-                } else if (keyAlgo.equals(\"EC\")) {\n-                    keySize = ((ECKey) key).getParams().getCurve().getField().getFieldSize();\n-                } else {\n-                    throw new ProviderException(\"Error: unsupported algo \" + keyAlgo);\n-                }\n+                keySize = switch (keyAlgo) {\n+                    case \"RSA\" -> ((RSAKey) key).getModulus().bitLength();\n+                    case \"DSA\" -> ((DSAKey) key).getParams().getP().bitLength();\n+                    case \"EC\" -> ((ECKey) key).getParams().getCurve().getField().getFieldSize();\n+                    default -> throw new ProviderException(\"Error: unsupported algo \" + keyAlgo);\n+                };\n@@ -509,12 +504,3 @@\n-        case T_UPDATE:\n-            buffer[0] = b;\n-            engineUpdate(buffer, 0, 1);\n-            break;\n-        case T_DIGEST:\n-            md.update(b);\n-            bytesProcessed++;\n-            break;\n-        case T_RAW:\n-            if (bytesProcessed >= buffer.length) {\n-                bytesProcessed = buffer.length + 1;\n-                return;\n+            case T_UPDATE -> {\n+                buffer[0] = b;\n+                engineUpdate(buffer, 0, 1);\n@@ -522,4 +508,12 @@\n-            buffer[bytesProcessed++] = b;\n-            break;\n-        default:\n-            throw new ProviderException(\"Internal error\");\n+            case T_DIGEST -> {\n+                md.update(b);\n+                bytesProcessed++;\n+            }\n+            case T_RAW -> {\n+                if (bytesProcessed >= buffer.length) {\n+                    bytesProcessed = buffer.length + 1;\n+                    return;\n+                }\n+                buffer[bytesProcessed++] = b;\n+            }\n+            default -> throw new ProviderException(\"Internal error\");\n@@ -583,5 +577,22 @@\n-        case T_UPDATE:\n-            if (byteBuffer instanceof DirectBuffer == false) {\n-                \/\/ cannot do better than default impl\n-                super.engineUpdate(byteBuffer);\n-                return;\n+            case T_UPDATE -> {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n+                    \/\/ cannot do better than default impl\n+                    super.engineUpdate(byteBuffer);\n+                    return;\n+                }\n+                long addr = ((DirectBuffer) byteBuffer).address();\n+                int ofs = byteBuffer.position();\n+                try {\n+                    if (mode == M_SIGN) {\n+                        token.p11.C_SignUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    } else {\n+                        token.p11.C_VerifyUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    }\n+                    bytesProcessed += len;\n+                    byteBuffer.position(ofs + len);\n+                } catch (PKCS11Exception e) {\n+                    reset(false);\n+                    throw new ProviderException(\"Update failed\", e);\n+                }\n@@ -589,9 +600,8 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n-            int ofs = byteBuffer.position();\n-            try {\n-                if (mode == M_SIGN) {\n-                    token.p11.C_SignUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n-                } else {\n-                    token.p11.C_VerifyUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n+            case T_DIGEST -> {\n+                md.update(byteBuffer);\n+                bytesProcessed += len;\n+            }\n+            case T_RAW -> {\n+                if (bytesProcessed + len > buffer.length) {\n+                    bytesProcessed = buffer.length + 1;\n+                    return;\n@@ -599,0 +609,1 @@\n+                byteBuffer.get(buffer, bytesProcessed, len);\n@@ -600,4 +611,0 @@\n-                byteBuffer.position(ofs + len);\n-            } catch (PKCS11Exception e) {\n-                reset(false);\n-                throw new ProviderException(\"Update failed\", e);\n@@ -605,9 +612,3 @@\n-            break;\n-        case T_DIGEST:\n-            md.update(byteBuffer);\n-            bytesProcessed += len;\n-            break;\n-        case T_RAW:\n-            if (bytesProcessed + len > buffer.length) {\n-                bytesProcessed = buffer.length + 1;\n-                return;\n+            default -> {\n+                reset(false);\n+                throw new ProviderException(\"Internal error\");\n@@ -615,6 +616,0 @@\n-            byteBuffer.get(buffer, bytesProcessed, len);\n-            bytesProcessed += len;\n-            break;\n-        default:\n-            reset(false);\n-            throw new ProviderException(\"Internal error\");\n@@ -654,1 +649,1 @@\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n@@ -727,1 +722,1 @@\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":132,"deletions":137,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (params instanceof TlsMasterSecretParameterSpec == false) {\n+        if (!(params instanceof TlsMasterSecretParameterSpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsMasterSecretGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        if (params instanceof TlsPrfParameterSpec == false) {\n+        if (!(params instanceof TlsPrfParameterSpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsPrfGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        if (!(params instanceof TlsRsaPremasterSecretParameterSpec)) {\n+        if (!(params instanceof TlsRsaPremasterSecretParameterSpec spec)) {\n@@ -90,2 +90,0 @@\n-        TlsRsaPremasterSecretParameterSpec spec =\n-            (TlsRsaPremasterSecretParameterSpec) params;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsRsaPremasterSecretGenerator.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        if (isLoaded() == false) {\n+        if (!isLoaded()) {\n@@ -139,1 +139,1 @@\n-        if (supported == false) {\n+        if (!supported) {\n@@ -197,1 +197,1 @@\n-            if (base.isDirectory() == false) {\n+            if (!base.isDirectory()) {\n@@ -201,1 +201,1 @@\n-            if (platformFile.isFile() == false) {\n+            if (!platformFile.isFile()) {\n@@ -217,1 +217,1 @@\n-            if (configBase.isDirectory() == false ) {\n+            if (!configBase.isDirectory()) {\n@@ -222,1 +222,1 @@\n-                if (secmodFile.isFile() == false) {\n+                if (!secmodFile.isFile()) {\n@@ -232,1 +232,1 @@\n-        if (supported == false) {\n+        if (!supported) {\n@@ -242,1 +242,1 @@\n-        if (initok == false) {\n+        if (!initok) {\n@@ -258,1 +258,1 @@\n-            if (isInitialized() == false) {\n+            if (!isInitialized()) {\n@@ -356,29 +356,34 @@\n-    static final String TEMPLATE_EXTERNAL =\n-        \"library = %s\\n\"\n-        + \"name = \\\"%s\\\"\\n\"\n-        + \"slotListIndex = %d\\n\";\n-\n-    static final String TEMPLATE_TRUSTANCHOR =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS Trust Anchors\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"enabledMechanisms = { KeyStore }\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n-\n-    static final String TEMPLATE_CRYPTO =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS SoftToken Crypto\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"disabledMechanisms = { KeyStore }\\n\";\n-\n-    static final String TEMPLATE_KEYSTORE =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS SoftToken KeyStore\\\"\\n\"\n-        + \"slotListIndex = 1\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n-\n-    static final String TEMPLATE_FIPS =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS FIPS SoftToken\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n+    static final String TEMPLATE_EXTERNAL = \"\"\"\n+                    library = %s\n+                    name = \"%s\"\n+                    slotListIndex = %d\n+                    \"\"\";\n+\n+    static final String TEMPLATE_TRUSTANCHOR = \"\"\"\n+                    library = %s\n+                    name = \"NSS Trust Anchors\"\n+                    slotListIndex = 0\n+                    enabledMechanisms = { KeyStore }\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n+\n+    static final String TEMPLATE_CRYPTO = \"\"\"\n+                    library = %s\n+                    name = \"NSS SoftToken Crypto\"\n+                    slotListIndex = 0\n+                    disabledMechanisms = { KeyStore }\n+                    \"\"\";\n+\n+    static final String TEMPLATE_KEYSTORE = \"\"\"\n+                    library = %s\n+                    name = \"NSS SoftToken KeyStore\"\n+                    slotListIndex = 1\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n+\n+    static final String TEMPLATE_FIPS = \"\"\"\n+                    library = %s\n+                    name = \"NSS FIPS SoftToken\"\n+                    slotListIndex = 0\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n@@ -445,20 +450,7 @@\n-            switch (type) {\n-            case EXTERNAL:\n-                config = String.format(TEMPLATE_EXTERNAL, libraryName,\n-                                            commonName + \" \" + slot, slot);\n-                break;\n-            case CRYPTO:\n-                config = String.format(TEMPLATE_CRYPTO, libraryName);\n-                break;\n-            case KEYSTORE:\n-                config = String.format(TEMPLATE_KEYSTORE, libraryName);\n-                break;\n-            case FIPS:\n-                config = String.format(TEMPLATE_FIPS, libraryName);\n-                break;\n-            case TRUSTANCHOR:\n-                config = String.format(TEMPLATE_TRUSTANCHOR, libraryName);\n-                break;\n-            default:\n-                throw new RuntimeException(\"Unknown module type: \" + type);\n-            }\n+            config = switch (type) {\n+                case EXTERNAL -> String.format(TEMPLATE_EXTERNAL, libraryName, commonName + \" \" + slot, slot);\n+                case CRYPTO -> String.format(TEMPLATE_CRYPTO, libraryName);\n+                case KEYSTORE -> String.format(TEMPLATE_KEYSTORE, libraryName);\n+                case FIPS -> String.format(TEMPLATE_FIPS, libraryName);\n+                case TRUSTANCHOR -> String.format(TEMPLATE_TRUSTANCHOR, libraryName);\n+            };\n@@ -548,1 +540,1 @@\n-                if (attr.isTrusted(TrustType.ALL) == false) {\n+                if (!attr.isTrusted(TrustType.ALL)) {\n@@ -749,1 +741,1 @@\n-            if (o instanceof Bytes == false) {\n+            if (!(o instanceof Bytes other)) {\n@@ -752,1 +744,0 @@\n-            Bytes other = (Bytes)o;\n@@ -759,1 +750,1 @@\n-        Map<Bytes,TrustAttributes> trustMap = new HashMap<Bytes,TrustAttributes>();\n+        Map<Bytes,TrustAttributes> trustMap = new HashMap<>();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Secmod.java","additions":53,"deletions":62,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        if (token.isPresent(this.id) == false) {\n+        if (!token.isPresent(this.id)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Session.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        if ((session == null) || (token.isValid() == false)) {\n+        if ((session == null) || (!token.isValid())) {\n@@ -179,1 +179,1 @@\n-        if ((session == null) || (token.isValid() == false)) {\n+        if ((session == null) || (!token.isValid())) {\n@@ -196,1 +196,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -205,1 +205,1 @@\n-        if (present == false) {\n+        if (!present) {\n@@ -212,1 +212,1 @@\n-        \/\/ higher. Therefore releaseSession method, which performs additional\n+        \/\/ higher. Therefore, releaseSession method, which performs additional\n@@ -258,1 +258,1 @@\n-                pool = new LinkedBlockingQueue<Session>();\n+                pool = new LinkedBlockingQueue<>();\n@@ -260,1 +260,1 @@\n-                pool = new LinkedBlockingQueue<Session>(SESSION_MAX);\n+                pool = new LinkedBlockingQueue<>(SESSION_MAX);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SessionManager.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                                (s.equals(nssSecmodDirectory) == false)) {\n+                                (!s.equals(nssSecmodDirectory))) {\n@@ -201,1 +201,1 @@\n-                                (s.equals(nssLibraryDirectory) == false)) {\n+                                (!s.equals(nssLibraryDirectory))) {\n@@ -304,2 +304,2 @@\n-        if (libraryFile.getName().equals(library) == false) {\n-            if (new File(library).isFile() == false) {\n+        if (!libraryFile.getName().equals(library)) {\n+            if (!new File(library).isFile()) {\n@@ -334,1 +334,1 @@\n-                if (config.getAllowSingleThreadedModules() == false) {\n+                if (!config.getAllowSingleThreadedModules()) {\n@@ -482,5 +482,1 @@\n-            List<Descriptor> list = descriptors.get(key);\n-            if (list == null) {\n-                list = new ArrayList<Descriptor>();\n-                descriptors.put(key, list);\n-            }\n+            List<Descriptor> list = descriptors.computeIfAbsent(key, k -> new ArrayList<>());\n@@ -956,1 +952,1 @@\n-                if (enabled == false) {\n+                if (!enabled) {\n@@ -1253,1 +1249,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1275,2 +1271,2 @@\n-                } else if (algorithm.indexOf(\"\/KW\/\") != -1 ||\n-                        algorithm.indexOf(\"\/KWP\/\") != -1) {\n+                } else if (algorithm.contains(\"\/KW\/\") ||\n+                        algorithm.contains(\"\/KWP\/\")) {\n@@ -1282,1 +1278,1 @@\n-                if (algorithm.indexOf(\"RSASSA-PSS\") != -1) {\n+                if (algorithm.contains(\"RSASSA-PSS\")) {\n@@ -1341,1 +1337,1 @@\n-            if ((param == null) || (token.isValid() == false)) {\n+            if ((param == null) || (!token.isValid())) {\n@@ -1344,1 +1340,1 @@\n-            if (param instanceof Key == false) {\n+            if (!(param instanceof Key key)) {\n@@ -1349,1 +1345,0 @@\n-            Key key = (Key)param;\n@@ -1353,2 +1348,2 @@\n-                    || (type == SIG) && (algorithm.indexOf(\"RSA\") != -1)) {\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                    || (type == SIG) && (algorithm.contains(\"RSA\"))) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n@@ -1364,1 +1359,1 @@\n-                if (keyAlgorithm.equals(\"EC\") == false) {\n+                if (!keyAlgorithm.equals(\"EC\")) {\n@@ -1374,1 +1369,1 @@\n-                if (keyAlgorithm.equals(\"DSA\") == false) {\n+                if (!keyAlgorithm.equals(\"DSA\")) {\n@@ -1388,1 +1383,1 @@\n-                if (keyAlgorithm.equals(\"DH\") == false) {\n+                if (!keyAlgorithm.equals(\"DH\")) {\n@@ -1579,1 +1574,1 @@\n-        if (hasValidToken() == false) {\n+        if (!hasValidToken()) {\n@@ -1777,1 +1772,1 @@\n-            if ((p == null) || (p.config.getFileName().equals(configName) == false)) {\n+            if ((p == null) || (!p.config.getFileName().equals(configName))) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-        primitiveTemplates = new ArrayList<KeyAndTemplate>();\n-        compositeTemplates = new ConcurrentHashMap<TemplateKey,Template>();\n+        primitiveTemplates = new ArrayList<>();\n+        compositeTemplates = new ConcurrentHashMap<>();\n@@ -154,1 +154,1 @@\n-            if (obj instanceof TemplateKey == false) {\n+            if (!(obj instanceof TemplateKey other)) {\n@@ -157,1 +157,0 @@\n-            TemplateKey other = (TemplateKey)obj;\n@@ -215,1 +214,1 @@\n-            List<CK_ATTRIBUTE> attrs = new ArrayList<CK_ATTRIBUTE>();\n+            List<CK_ATTRIBUTE> attrs = new ArrayList<>();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/TemplateManager.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    \/\/ that is done in SunPKCS11. Currently 50 ms.\n+    \/\/ that is done in SunPKCS11. Currently, 50 ms.\n@@ -170,2 +170,1 @@\n-        mechInfoMap =\n-            new ConcurrentHashMap<Long, CK_MECHANISM_INFO>(10);\n+        mechInfoMap = new ConcurrentHashMap<>(10);\n@@ -244,1 +243,1 @@\n-        if (isLoggedIn(session) == false) {\n+        if (!isLoggedIn(session)) {\n@@ -252,1 +251,1 @@\n-        if (removable == false) {\n+        if (!removable) {\n@@ -259,1 +258,1 @@\n-        if (isValid() == false) {\n+        if (!isValid()) {\n@@ -267,1 +266,1 @@\n-        if (removable == false) {\n+        if (!removable) {\n@@ -270,1 +269,1 @@\n-        if (valid == false) {\n+        if (!valid) {\n@@ -295,1 +294,1 @@\n-                    if (ok == false) {\n+                    if (!ok) {\n@@ -420,1 +419,1 @@\n-            serializedTokens.add(new WeakReference<Token>(this));\n+            serializedTokens.add(new WeakReference<>(this));\n@@ -429,2 +428,1 @@\n-    private static final List<Reference<Token>> serializedTokens =\n-        new ArrayList<Reference<Token>>();\n+    private static final List<Reference<Token>> serializedTokens = new ArrayList<>();\n@@ -433,1 +431,1 @@\n-        if (isValid() == false) {\n+        if (!isValid()) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"}]}