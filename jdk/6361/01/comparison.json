{"files":[{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276848\n+ * @summary Tests the command-line tool with port not specified\n+ * @modules jdk.httpserver\n+ * @library \/test\/lib\n+ * @run testng\/othervm\/manual CommandLinePortNotSpecifiedTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+\n+public class CommandLinePortNotSpecifiedTest {\n+\n+    static final Path JAVA_HOME = Path.of(System.getProperty(\"java.home\"));\n+    static final String JAVA = getJava(JAVA_HOME);\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final Path TEST_DIR = CWD.resolve(\"CommandLinePortNotSpecifiedTest\");\n+    static final Path TEST_FILE = TEST_DIR.resolve(\"file.txt\");\n+    static final String TEST_DIR_STR = TEST_DIR.toString();\n+    static final String LOOPBACK_ADDR = InetAddress.getLoopbackAddress().getHostAddress();\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+        Files.createFile(TEST_FILE);\n+    }\n+\n+    static final int SIGTERM = 15;\n+    static final int NORMAL_EXIT_CODE = normalExitCode();\n+\n+    static int normalExitCode() {\n+        if (Platform.isWindows()) {\n+            return 1; \/\/ expected process destroy exit code\n+        } else {\n+            \/\/ signal terminated exit code on Unix is 128 + signal value\n+            return 128 + SIGTERM;\n+        }\n+    }\n+\n+    \/**\n+     * This is a manual test to confirm the command-line tool starts successfully\n+     * in the case where the port is not specified. In this case the server uses\n+     * the default port 8000. The test is manual to avoid a BindException in the\n+     * unlikely but not impossible case that the port is already in use.\n+     *\/\n+    @Test\n+    public void testPortNotSpecified() throws Throwable {\n+        out.println(\"\\n--- testPortNotSpecified\");\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Binding to loopback by default. For all interfaces use \\\"-b 0.0.0.0\\\" or \\\"-b ::\\\".\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static String getJava(Path image) {\n+        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+        Path java = image.resolve(\"bin\").resolve(isWindows ? \"java.exe\" : \"java\");\n+        if (Files.notExists(java))\n+            throw new RuntimeException(java + \" not found\");\n+        return java.toAbsolutePath().toString();\n+    }\n+\n+    static final String REGULAR_STARTUP_LINE1_STRING = \"Serving\";\n+    static final String REGULAR_STARTUP_LINE2_STRING = \"URL http:\/\/\";\n+\n+    static final String OPTIONS_TEXT = \"\"\"\n+            Options:\n+            -b, --bind-address    - Address to bind to. Default: %s (loopback).\n+                                    For all interfaces use \"-b 0.0.0.0\" or \"-b ::\".\n+            -d, --directory       - Directory to serve. Default: current directory.\n+            -o, --output          - Output format. none|info|verbose. Default: info.\n+            -p, --port            - Port to listen on. Default: 8000.\n+            -h, -?, --help        - Print this help message.\n+            To stop the server, press Ctrl + C.\"\"\".formatted(LOOPBACK_ADDR);\n+\n+    \/\/ The stdout\/stderr output line to wait for when starting the simpleserver\n+    enum WaitForLine {\n+        REGULAR_STARTUP_LINE (REGULAR_STARTUP_LINE2_STRING) ,\n+        HELP_STARTUP_LINE (OPTIONS_TEXT.lines().reduce((first, second) -> second).orElseThrow());\n+\n+        final String value;\n+        WaitForLine(String value) { this.value = value; }\n+    }\n+\n+    static OutputAnalyzer simpleserver(String... args) throws Throwable {\n+        return simpleserver(WaitForLine.REGULAR_STARTUP_LINE, true, args);\n+    }\n+\n+    static OutputAnalyzer simpleserver(WaitForLine waitForLine, boolean destroy, String... args) throws Throwable {\n+        StringBuffer sb = new StringBuffer();  \/\/ stdout & stderr\n+        \/\/ start the process and await the waitForLine before returning\n+        var p = ProcessTools.startProcess(\"simpleserver\",\n+                new ProcessBuilder(args).directory(TEST_DIR.toFile()),\n+                line -> sb.append(line + \"\\n\"),\n+                line -> line.startsWith(waitForLine.value),\n+                30,  \/\/ suitably high default timeout, not expected to timeout\n+                TimeUnit.SECONDS);\n+        if (destroy) {\n+            p.destroy();  \/\/ SIGTERM on Unix\n+        }\n+        int ec = p.waitFor();\n+        var outputAnalyser = new OutputAnalyzer(sb.toString(), \"\", ec);\n+        return outputAnalyser;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLinePortNotSpecifiedTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -137,2 +137,2 @@\n-        out.println(\"\\n--- testPort, opt=\\\"%s\\\" \".formatted(opt));\n-        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"0.0.0.0\")\n+        out.println(\"\\n--- testBindAllInterfaces, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, \"0.0.0.0\")\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLinePositiveTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}