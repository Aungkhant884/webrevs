{"files":[{"patch":"@@ -161,1 +161,2 @@\n- *     <td headers=\"matches predef digit\">A digit: {@code [0-9]}<\/td><\/tr>\n+ *     <td headers=\"matches predef digit\">A digit: {@code [0-9]} if if <a href=\"#UNICODE_CHARACTER_CLASS\">\n+ *  *         UNICODE_CHARACTER_CLASS<\/a> is not set. See <a href=\"#unicodesupport\">Unicode Support<\/a>.<\/td><\/tr>\n@@ -170,1 +171,3 @@\n- *     <td headers=\"matches predef white\">A whitespace character: {@code [ \\t\\n\\x0B\\f\\r]}<\/td><\/tr>\n+ *     <td headers=\"matches predef white\">A whitespace character: {@code [ \\t\\n\\x0B\\f\\r]} if\n+ *     <a href=\"#UNICODE_CHARACTER_CLASS\"> UNICODE_CHARACTER_CLASS<\/a> is not set. See\n+ *     <a href=\"#unicodesupport\">Unicode Support<\/a>.<\/td><\/tr>\n@@ -179,1 +182,2 @@\n- *     <td headers=\"matches predef word\">A word character: {@code [a-zA-Z_0-9]}<\/td><\/tr>\n+ *     <td headers=\"matches predef word\">A word character: {@code [a-zA-Z_0-9]} if <a href=\"#UNICODE_CHARACTER_CLASS\">\n+ *         UNICODE_CHARACTER_CLASS<\/a> is not set. See <a href=\"#unicodesupport\">Unicode Support<\/a>. <\/td><\/tr>\n@@ -249,1 +253,1 @@\n- *     <td headers=\"matches bounds word_boundary\">A word boundary<\/td><\/tr>\n+ *     <td headers=\"matches bounds word_boundary\">A word boundary: {@code (?:(?<=\\w)(?=\\W)|(?<=\\W)(?=\\w))}<\/td><\/tr>\n@@ -253,1 +257,1 @@\n- *     <td headers=\"matches bounds non_word_boundary\">A non-word boundary<\/td><\/tr>\n+ *     <td headers=\"matches bounds non_word_boundary\">A non-word boundary: {@code [^\\b]}<\/td><\/tr>\n@@ -538,1 +542,1 @@\n- * <h2> Unicode support <\/h2>\n+ * <h2 id=\"unicodesupport\"> Unicode support <\/h2>\n@@ -5380,1 +5384,1 @@\n-                            : (ch == '_' || Character.isLetterOrDigit(ch));\n+                            : CharPredicates.ASCII_WORD().is(ch);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *\n+ * 8280403 8264160 8281315\n@@ -54,7 +54,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.Scanner;\n+import java.util.*;\n@@ -62,0 +56,1 @@\n+import java.util.function.IntFunction;\n@@ -70,0 +65,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -3857,1 +3853,1 @@\n-        twoFindIndexes(\" \\u0180sherman\\u0400 \", bound, 1, 10);\n+        twoFindIndexes(\" \\u0180sherman\\u0400 \", boundU, 1, 10);\n@@ -3859,1 +3855,1 @@\n-        twoFindIndexes(\" \\u0180sh\\u0345erman\\u0400 \", bound, 1, 11);\n+        twoFindIndexes(\" \\u0180sh\\u0345erman\\u0400 \", boundU, 1, 11);\n@@ -3861,1 +3857,1 @@\n-        twoFindIndexes(\" \\u0724\\u0739\\u0724 \", bound, 1, 4);\n+        twoFindIndexes(\" \\u0724\\u0739\\u0724 \", boundU, 1, 4);\n@@ -4560,0 +4556,55 @@\n+    \/\/This test is for 8264160\n+    @Test\n+    public static void wordBoundaryInconsistencies() {\n+        Pattern basicWordCharPattern = Pattern.compile(\"\\\\w\");\n+        Pattern basicWordCharBoundaryPattern =\n+                Pattern.compile(\";\\\\b.\", Pattern.DOTALL);\n+\n+        Pattern unicodeWordCharPattern =\n+                Pattern.compile(\"\\\\w\", Pattern.UNICODE_CHARACTER_CLASS);\n+\n+        Pattern unicodeWordCharBoundaryPattern =\n+                Pattern.compile(\";\\\\b.\",\n+                        Pattern.DOTALL | Pattern.UNICODE_CHARACTER_CLASS);\n+\n+        IntFunction<Boolean> basicWordCharCheck =\n+                (cp) -> cpMatches(basicWordCharPattern, cp, false);\n+\n+        IntFunction<Boolean> basicBoundaryCharCheck =\n+                (cp) -> cpMatches(basicWordCharBoundaryPattern,\n+                                  cp, true);\n+\n+        IntFunction<Boolean> unicodeWordCharCheck =\n+                (cp) -> cpMatches(unicodeWordCharPattern, cp, false);\n+\n+        IntFunction<Boolean> unicodeBoundaryCharCheck =\n+                (cp) -> cpMatches(unicodeWordCharBoundaryPattern,\n+                                  cp,true);\n+\n+        \/\/basic pattern comparison\n+        for(int cp = 0; cp <= Character.MAX_CODE_POINT; cp++){\n+            assertEquals(basicWordCharCheck.apply(cp),\n+                    basicBoundaryCharCheck.apply(cp),\n+                    \"Codepoint: \" + cp);\n+            assertEquals(unicodeWordCharCheck.apply(cp),\n+                    unicodeBoundaryCharCheck.apply(cp),\n+                    \"Codepoint: \" + cp);\n+        }\n+    }\n+\n+    private static boolean cpMatches(Pattern p, int cp, boolean boundary) {\n+        String cpString;\n+        if (Character.isBmpCodePoint(cp)) {\n+            cpString = \"\" + ((char) cp);\n+        } else {\n+            cpString = \"\" + Character.highSurrogate(cp) +\n+                    Character.lowSurrogate(cp);\n+        }\n+\n+        if (boundary) {\n+            return p.matcher(\";\" + cpString).matches();\n+        } else {\n+            return p.matcher(cpString).matches();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"}]}