{"files":[{"patch":"@@ -161,1 +161,2 @@\n- *     <td headers=\"matches predef digit\">A digit: {@code [0-9]}<\/td><\/tr>\n+ *     <td headers=\"matches predef digit\">A digit: {@code [0-9]} if <a href=\"#UNICODE_CHARACTER_CLASS\">\n+ *  *         UNICODE_CHARACTER_CLASS<\/a> is not set. See <a href=\"#unicodesupport\">Unicode Support<\/a>.<\/td><\/tr>\n@@ -170,1 +171,3 @@\n- *     <td headers=\"matches predef white\">A whitespace character: {@code [ \\t\\n\\x0B\\f\\r]}<\/td><\/tr>\n+ *     <td headers=\"matches predef white\">A whitespace character: {@code [ \\t\\n\\x0B\\f\\r]} if\n+ *     <a href=\"#UNICODE_CHARACTER_CLASS\"> UNICODE_CHARACTER_CLASS<\/a> is not set. See\n+ *     <a href=\"#unicodesupport\">Unicode Support<\/a>.<\/td><\/tr>\n@@ -179,1 +182,2 @@\n- *     <td headers=\"matches predef word\">A word character: {@code [a-zA-Z_0-9]}<\/td><\/tr>\n+ *     <td headers=\"matches predef word\">A word character: {@code [a-zA-Z_0-9]} if <a href=\"#UNICODE_CHARACTER_CLASS\">\n+ *         UNICODE_CHARACTER_CLASS<\/a> is not set. See <a href=\"#unicodesupport\">Unicode Support<\/a>. <\/td><\/tr>\n@@ -249,1 +253,2 @@\n- *     <td headers=\"matches bounds word_boundary\">A word boundary<\/td><\/tr>\n+ *     <td headers=\"matches bounds word_boundary\">A word boundary: {@code (?:(?<=\\w)(?=\\W)|(?<=\\W)(?=\\w))} (the location\n+ *     where a non-word character abuts a word character)<\/td><\/tr>\n@@ -253,1 +258,1 @@\n- *     <td headers=\"matches bounds non_word_boundary\">A non-word boundary<\/td><\/tr>\n+ *     <td headers=\"matches bounds non_word_boundary\">A non-word boundary: {@code [^\\b]}<\/td><\/tr>\n@@ -538,1 +543,1 @@\n- * <h2> Unicode support <\/h2>\n+ * <h2 id=\"unicodesupport\"> Unicode support <\/h2>\n@@ -5380,1 +5385,1 @@\n-                            : (ch == '_' || Character.isLetterOrDigit(ch));\n+                            : CharPredicates.ASCII_WORD().is(ch);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *\n+ * 8280403 8264160 8281315\n@@ -54,7 +54,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.Scanner;\n+import java.util.*;\n@@ -62,0 +56,1 @@\n+import java.util.function.IntFunction;\n@@ -3857,1 +3852,1 @@\n-        twoFindIndexes(\" \\u0180sherman\\u0400 \", bound, 1, 10);\n+        twoFindIndexes(\" \\u0180sherman\\u0400 \", boundU, 1, 10);\n@@ -3859,1 +3854,1 @@\n-        twoFindIndexes(\" \\u0180sh\\u0345erman\\u0400 \", bound, 1, 11);\n+        twoFindIndexes(\" \\u0180sh\\u0345erman\\u0400 \", boundU, 1, 11);\n@@ -3861,1 +3856,1 @@\n-        twoFindIndexes(\" \\u0724\\u0739\\u0724 \", bound, 1, 4);\n+        twoFindIndexes(\" \\u0724\\u0739\\u0724 \", boundU, 1, 4);\n@@ -4506,0 +4501,2 @@\n+    \/\/Ensure we don't drop nested interior character classes to the right of an\n+    \/\/intersection operator.\n@@ -4533,0 +4530,3 @@\n+    \/\/This is for ensuring that the caret doesn't point at the wrong character\n+    \/\/in a syntax exception message because we previously didn't compensate for\n+    \/\/tabs when rendering the offending string that contained tab characters.\n@@ -4543,0 +4543,2 @@\n+    \/\/Ensure our error message indicates we have an unescaped backslash when we\n+    \/\/encounter one.\n@@ -4552,0 +4554,1 @@\n+    \/\/Given bad intersection syntax, we should throw a PatternSyntaxException.\n@@ -4560,0 +4563,60 @@\n+    \/\/This test is for 8264160\n+    \/\/Here we check for inconsistencies between the behavior of \\w and the\n+    \/\/behavior of \\b. Prior to this fix, the two flags did not behave in a\n+    \/\/consistent way ie \\b would recognize non-\\w characters as part of a word\n+    \/\/in some cases. This test verifies that the two behave consistently\n+    \/\/for all codepoints we support.\n+    @Test\n+    public static void wordBoundaryInconsistencies() {\n+        Pattern basicWordCharPattern = Pattern.compile(\"\\\\w\");\n+        Pattern basicWordCharBoundaryPattern =\n+                Pattern.compile(\";\\\\b.\", Pattern.DOTALL);\n+\n+        Pattern unicodeWordCharPattern =\n+                Pattern.compile(\"\\\\w\", Pattern.UNICODE_CHARACTER_CLASS);\n+\n+        Pattern unicodeWordCharBoundaryPattern =\n+                Pattern.compile(\";\\\\b.\",\n+                        Pattern.DOTALL | Pattern.UNICODE_CHARACTER_CLASS);\n+\n+        IntFunction<Boolean> basicWordCharCheck =\n+                (cp) -> cpMatches(basicWordCharPattern, cp, false);\n+\n+        IntFunction<Boolean> basicBoundaryCharCheck =\n+                (cp) -> cpMatches(basicWordCharBoundaryPattern,\n+                                  cp, true);\n+\n+        IntFunction<Boolean> unicodeWordCharCheck =\n+                (cp) -> cpMatches(unicodeWordCharPattern, cp, false);\n+\n+        IntFunction<Boolean> unicodeBoundaryCharCheck =\n+                (cp) -> cpMatches(unicodeWordCharBoundaryPattern,\n+                                  cp,true);\n+\n+        \/\/basic pattern comparison\n+        for(int cp = 0; cp <= Character.MAX_CODE_POINT; cp++){\n+            assertEquals(basicWordCharCheck.apply(cp),\n+                    basicBoundaryCharCheck.apply(cp),\n+                    \"Codepoint: \" + cp);\n+            assertEquals(unicodeWordCharCheck.apply(cp),\n+                    unicodeBoundaryCharCheck.apply(cp),\n+                    \"Codepoint: \" + cp);\n+        }\n+    }\n+\n+    private static boolean cpMatches(Pattern p, int cp, boolean boundary) {\n+        String cpString;\n+        if (Character.isBmpCodePoint(cp)) {\n+            cpString = \"\" + ((char) cp);\n+        } else {\n+            cpString = \"\" + Character.highSurrogate(cp) +\n+                    Character.lowSurrogate(cp);\n+        }\n+\n+        if (boundary) {\n+            return p.matcher(\";\" + cpString).matches();\n+        } else {\n+            return p.matcher(cpString).matches();\n+        }\n+    }\n+\n@@ -4561,0 +4624,3 @@\n+    \/\/Checks that when the Canonical Equivalence flag is set, the behavior for\n+    \/\/Matcher::hitEnd is equivalent for these similar, patterns that saw\n+    \/\/inconsistencies.\n@@ -4585,0 +4651,2 @@\n+    \/\/Checks that we are able to correctly match this case with a backref\n+    \/\/without encountering an IndexOutOfBoundsException.\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":79,"deletions":11,"binary":false,"changes":90,"status":"modified"}]}