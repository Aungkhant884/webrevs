{"files":[{"patch":"@@ -1593,2 +1593,2 @@\n-        byte[] bytes = Classfile.parse(in.readAllBytes(),\n-                Classfile.Option.constantPoolSharing(false)).transform((clb, cle) -> {\n+        var cc = Classfile.of(Classfile.ConstantPoolSharingOption.NEW_POOL);\n+        byte[] bytes = cc.transform(cc.parse(in.readAllBytes()), (clb, cle) -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -51,4 +52,5 @@\n-     * Returns a default instance of {@linkplain ClassHierarchyResolver}\n-     * that reads from system class loader with\n-     * {@link ClassLoader#getSystemResourceAsStream(String)} and falls\n-     * back to reflection if a class is not found.\n+     * Returns new instance of {@link ClassHierarchyResolver}\n+     * that caches {@link ClassHierarchyInfo} instances read from system\n+     * class loader with {@link ClassLoader#getSystemResourceAsStream(String)}\n+     * and falls back to reflection if a class is not found.\n+     * The returned resolver is thread-safe.\n@@ -56,2 +58,14 @@\n-    static ClassHierarchyResolver defaultResolver() {\n-        return ClassHierarchyImpl.DEFAULT_RESOLVER;\n+    static ClassHierarchyResolver ofSystem() {\n+        record Factory() implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n+            static final Factory INSTANCE = new Factory();\n+\n+            @Override\n+            public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        }\n+        var sysLoader = ClassLoader.getSystemClassLoader();\n+        return ClassHierarchyResolver\n+            .ofResourceParsing(sysLoader)\n+            .orElse(ClassHierarchyResolver.ofClassLoading(sysLoader))\n+            .cached(Factory.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -75,19 +75,0 @@\n-    \/**\n-     * Transform this classfile into a new classfile with the aid of a\n-     * {@link ClassTransform}.  The transform will receive each element of\n-     * this class, as well as a {@link ClassBuilder} for building the new class.\n-     * The transform is free to preserve, remove, or replace elements as it\n-     * sees fit.\n-     *\n-     * @implNote\n-     * <p>This method behaves as if:\n-     * {@snippet lang=java :\n-     *     Classfile.build(thisClass(), ConstantPoolBuilder.of(this),\n-     *                     b -> b.transform(this, transform));\n-     * }\n-     *\n-     * @param transform the transform\n-     * @return the bytes of the new class\n-     *\/\n-    byte[] transform(ClassTransform transform);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassModel.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-     * the processing option {@link Classfile.Option#attributeMapper(Function)}.\n+     * the processing option {@link Classfile.AttributeMapperOption}.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,4 +31,0 @@\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n@@ -42,1 +38,0 @@\n-import jdk.internal.classfile.constantpool.PackageEntry;\n@@ -44,6 +39,2 @@\n-import jdk.internal.classfile.impl.ClassImpl;\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n-import jdk.internal.classfile.impl.DirectClassBuilder;\n-import jdk.internal.classfile.impl.Options;\n-import jdk.internal.classfile.impl.SplitConstantPool;\n-import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.ClassfileImpl;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -55,1 +46,0 @@\n-import java.lang.constant.PackageDesc;\n@@ -58,1 +48,3 @@\n- * Main entry points for parsing, transforming, and generating classfiles.\n+ * Represents a context for parsing, transforming, and generating classfiles.\n+ * A {@code Classfile} has a set of options that condition how parsing and\n+ * generation is done.\n@@ -60,3 +52,2 @@\n-public class Classfile {\n-    private Classfile() {\n-    }\n+public sealed interface Classfile\n+        permits ClassfileImpl {\n@@ -65,1 +56,2 @@\n-     * An option that affects the writing of classfiles.\n+     * {@return a new context with options altered from the default}\n+     * @param options the desired processing options\n@@ -67,8 +59,3 @@\n-    public sealed interface Option permits Options.OptionValue {\n-\n-        \/**\n-         * {@return an option describing whether or not to generate stackmaps}\n-         * Default is to generate stack maps.\n-         * @param b whether to generate stack maps\n-         *\/\n-        static Option generateStackmap(boolean b) { return new Options.OptionValue(Options.Key.GENERATE_STACK_MAPS, b); }\n+    static Classfile of(Option... options) {\n+        return ClassfileImpl.of(options);\n+    }\n@@ -76,9 +63,5 @@\n-        \/**\n-         * {@return an option describing whether to process or discard debug elements}\n-         * Debug elements include the local variable table, local variable type\n-         * table, and character range table.  Discarding debug elements may\n-         * reduce the overhead of parsing or transforming classfiles.\n-         * Default is to process debug elements.\n-         * @param b whether or not to process debug elements\n-         *\/\n-        static Option processDebug(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_DEBUG, b); }\n+    \/**\n+     * {@return a copy of the context with altered options}\n+     * @param options the desired processing options\n+     *\/\n+    Classfile withOptions(Option... options);\n@@ -86,8 +69,5 @@\n-        \/**\n-         * {@return an option describing whether to process or discard line numbers}\n-         * Discarding line numbers may reduce the overhead of parsing or transforming\n-         * classfiles.\n-         * Default is to process line numbers.\n-         * @param b whether or not to process line numbers\n-         *\/\n-        static Option processLineNumbers(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_LINE_NUMBERS, b); }\n+    \/**\n+     * An option that affects the parsing and writing of classfiles.\n+     *\/\n+    sealed interface Option {\n+    }\n@@ -95,8 +75,6 @@\n-        \/**\n-         * {@return an option describing whether to process or discard unrecognized\n-         * attributes}\n-         * Default is to process unrecognized attributes, and deliver as instances\n-         * of {@link UnknownAttribute}.\n-         * @param b whether or not to process unrecognized attributes\n-         *\/\n-        static Option processUnknownAttributes(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_UNKNOWN_ATTRIBUTES, b); }\n+    \/**\n+     * Option describing attribute mappers for custom attributes.\n+     * Default is only to process standard attributes.\n+     *\/\n+    sealed interface AttributeMapperOption extends Option\n+            permits ClassfileImpl.AttributeMapperOptionImpl {\n@@ -105,7 +83,2 @@\n-         * {@return an option describing whether to preserve the original constant\n-         * pool when transforming a classfile}  Reusing the constant pool enables significant\n-         * optimizations in processing time and minimizes differences between the\n-         * original and transformed classfile, but may result in a bigger classfile\n-         * when a classfile is significantly transformed.\n-         * Default is to preserve the original constant pool.\n-         * @param b whether or not to preserve the original constant pool\n+         * {@return an option describing attribute mappers for custom attributes}\n+         * @param attributeMapper a function mapping attribute names to attribute mappers\n@@ -113,1 +86,3 @@\n-        static Option constantPoolSharing(boolean b) { return new Options.OptionValue(Options.Key.CP_SHARING, b); }\n+        static AttributeMapperOption of(Function<Utf8Entry, AttributeMapper<?>> attributeMapper) {\n+            return new ClassfileImpl.AttributeMapperOptionImpl(attributeMapper);\n+        }\n@@ -115,7 +90,2 @@\n-        \/**\n-         * {@return an option describing whether or not to automatically rewrite\n-         * short jumps to long when necessary}\n-         * Default is to automatically rewrite jump instructions.\n-         * @param b whether or not to automatically rewrite short jumps to long when necessary\n-         *\/\n-        static Option fixShortJumps(boolean b) { return new Options.OptionValue(Options.Key.FIX_SHORT_JUMPS, b); }\n+        Function<Utf8Entry, AttributeMapper<?>> attributeMapper();\n+    }\n@@ -123,6 +93,6 @@\n-        \/**\n-         * {@return an option describing whether or not to patch out unreachable code}\n-         * Default is to automatically patch out unreachable code with NOPs.\n-         * @param b whether or not to automatically patch out unreachable code\n-         *\/\n-        static Option patchDeadCode(boolean b) { return new Options.OptionValue(Options.Key.PATCH_DEAD_CODE, b); }\n+    \/**\n+     * Option describing the class hierarchy resolver to use when generating\n+     * stack maps.\n+     *\/\n+    sealed interface ClassHierarchyResolverOption extends Option\n+            permits ClassfileImpl.ClassHierarchyResolverOptionImpl {\n@@ -133,1 +103,1 @@\n-         * @param r the resolver\n+         * @param classHierarchyResolver the resolver\n@@ -135,1 +105,3 @@\n-        static Option classHierarchyResolver(ClassHierarchyResolver r) { return new Options.OptionValue(Options.Key.HIERARCHY_RESOLVER, r); }\n+        static ClassHierarchyResolverOption of(ClassHierarchyResolver classHierarchyResolver) {\n+            return new ClassfileImpl.ClassHierarchyResolverOptionImpl(classHierarchyResolver);\n+        }\n@@ -137,6 +109,2 @@\n-        \/**\n-         * {@return an option describing attribute mappers for custom attributes}\n-         * Default is only to process standard attributes.\n-         * @param r a function mapping attribute names to attribute mappers\n-         *\/\n-        static Option attributeMapper(Function<Utf8Entry, AttributeMapper<?>> r) { return new Options.OptionValue(Options.Key.ATTRIBUTE_MAPPER, r); }\n+        ClassHierarchyResolver classHierarchyResolver();\n+    }\n@@ -144,9 +112,12 @@\n-        \/**\n-         * {@return an option describing whether or not to filter unresolved labels}\n-         * Default is to throw IllegalArgumentException when any {@link ExceptionCatch},\n-         * {@link LocalVariableInfo}, {@link LocalVariableTypeInfo}, or {@link CharacterRangeInfo}\n-         * reference to unresolved {@link Label} during bytecode serialization.\n-         * Setting this option to true filters the above elements instead.\n-         * @param b whether or not to automatically patch out unreachable code\n-         *\/\n-        static Option filterDeadLabels(boolean b) { return new Options.OptionValue(Options.Key.FILTER_DEAD_LABELS, b); }\n+    \/**\n+     * Option describing whether to preserve the original constant pool when\n+     * transforming a classfile.  Reusing the constant pool enables significant\n+     * optimizations in processing time and minimizes differences between the\n+     * original and transformed classfile, but may result in a bigger classfile\n+     * when a classfile is significantly transformed.\n+     * Default is {@code SHARED_POOL} to preserve the original constant\n+     * pool.\n+     *\/\n+    enum ConstantPoolSharingOption implements Option {\n+        SHARED_POOL,\n+        NEW_POOL\n@@ -156,4 +127,40 @@\n-     * Parse a classfile into a {@link ClassModel}.\n-     * @param bytes the bytes of the classfile\n-     * @param options the desired processing options\n-     * @return the class model\n+     * Option describing whether or not to patch out unreachable code.\n+     * Default is {@code PATCH_DEAD_CODE} to automatically patch out unreachable\n+     * code with NOPs.\n+     *\/\n+    enum DeadCodeOption implements Option {\n+        PATCH_DEAD_CODE,\n+        KEEP_DEAD_CODE\n+    }\n+\n+    \/**\n+     * Option describing whether or not to filter unresolved labels.\n+     * Default is {@code FAIL_ON_DEAD_LABELS} to throw IllegalStateException\n+     * when any {@link ExceptionCatch}, {@link LocalVariableInfo},\n+     * {@link LocalVariableTypeInfo}, or {@link CharacterRangeInfo}\n+     * reference to unresolved {@link Label} during bytecode serialization.\n+     * Setting this option to {@code DROP_DEAD_LABELS} filters the above\n+     * elements instead.\n+     *\/\n+    enum DeadLabelsOption implements Option {\n+        FAIL_ON_DEAD_LABELS,\n+        DROP_DEAD_LABELS\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard debug elements.\n+     * Debug elements include the local variable table, local variable type\n+     * table, and character range table.  Discarding debug elements may\n+     * reduce the overhead of parsing or transforming classfiles.\n+     * Default is {@code PASS_DEBUG} to process debug elements.\n+     *\/\n+    enum DebugElementsOption implements Option {\n+        PASS_DEBUG,\n+        DROP_DEBUG\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard line numbers.\n+     * Discarding line numbers may reduce the overhead of parsing or transforming\n+     * classfiles.\n+     * Default is {@code PASS_LINE_NUMBERS} to process line numbers.\n@@ -161,5 +168,37 @@\n-    public static ClassModel parse(byte[] bytes, Option... options) {\n-        Collection<Option> os = (options == null || options.length == 0)\n-                                   ? Collections.emptyList()\n-                                   : List.of(options);\n-        return new ClassImpl(bytes, os);\n+    enum LineNumbersOption implements Option {\n+        PASS_LINE_NUMBERS,\n+        DROP_LINE_NUMBERS;\n+    }\n+\n+    \/**\n+     * Option describing whether or not to automatically rewrite short jumps to\n+     * long when necessary.\n+     * Default is {@code FIX_SHORT_JUMPS} to automatically rewrite jump\n+     * instructions.\n+     *\/\n+    enum ShortJumpsOption implements Option {\n+        FIX_SHORT_JUMPS,\n+        FAIL_ON_SHORT_JUMPS\n+    }\n+\n+    \/**\n+     * Option describing whether or not to generate stackmaps.\n+     * Default is {@code STACK_MAPS_WHEN_REQUIRED} to generate stack\n+     * maps for {@link #JAVA_6_VERSION} or above, where specifically for\n+     * {@link #JAVA_6_VERSION} the stack maps may not be generated.\n+     * @jvms 4.10.1 Verification by Type Checking\n+     *\/\n+    enum StackMapsOption implements Option {\n+        STACK_MAPS_WHEN_REQUIRED,\n+        STACK_MAPS_ALWAYS,\n+        STACK_MAPS_NEVER\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard unrecognized attributes.\n+     * Default is {@code PASS_UNKNOWN_ATTRIBUTES} to process unrecognized\n+     * attributes, and deliver as instances of {@link UnknownAttribute}.\n+     *\/\n+    enum UnknownAttributesOption implements Option {\n+        PASS_UNKNOWN_ATTRIBUTES,\n+        DROP_UNKNOWN_ATTRIBUTES\n@@ -170,2 +209,1 @@\n-     * @param path the path to the classfile\n-     * @param options the desired processing options\n+     * @param bytes the bytes of the classfile\n@@ -174,3 +212,1 @@\n-    public static ClassModel parse(Path path, Option... options) throws IOException {\n-        return parse(Files.readAllBytes(path), options);\n-    }\n+    ClassModel parse(byte[] bytes);\n@@ -179,4 +215,3 @@\n-     * Build a classfile into a byte array.\n-     * @param thisClass the name of the class to build\n-     * @param handler a handler that receives a {@link ClassBuilder}\n-     * @return the classfile bytes\n+     * Parse a classfile into a {@link ClassModel}.\n+     * @param path the path to the classfile\n+     * @return the class model\n@@ -184,3 +219,2 @@\n-    public static byte[] build(ClassDesc thisClass,\n-                               Consumer<ClassBuilder> handler) {\n-        return build(thisClass, Collections.emptySet(), handler);\n+    default ClassModel parse(Path path) throws IOException {\n+        return parse(Files.readAllBytes(path));\n@@ -192,1 +226,0 @@\n-     * @param options the desired processing options\n@@ -196,4 +229,3 @@\n-    public static byte[] build(ClassDesc thisClass,\n-                               Collection<Option> options,\n-                               Consumer<? super ClassBuilder> handler) {\n-        ConstantPoolBuilder pool = ConstantPoolBuilder.of(options);\n+    default byte[] build(ClassDesc thisClass,\n+                         Consumer<? super ClassBuilder> handler) {\n+        ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n@@ -212,8 +244,3 @@\n-    public static byte[] build(ClassEntry thisClassEntry,\n-                               ConstantPoolBuilder constantPool,\n-                               Consumer<? super ClassBuilder> handler) {\n-        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n-        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, thisClassEntry);\n-        handler.accept(builder);\n-        return builder.build();\n-    }\n+    byte[] build(ClassEntry thisClassEntry,\n+                 ConstantPoolBuilder constantPool,\n+                 Consumer<? super ClassBuilder> handler);\n@@ -227,4 +254,4 @@\n-    public static void buildTo(Path path,\n-                               ClassDesc thisClass,\n-                               Consumer<ClassBuilder> handler) throws IOException {\n-        Files.write(path, build(thisClass, Collections.emptySet(), handler));\n+    default void buildTo(Path path,\n+                         ClassDesc thisClass,\n+                         Consumer<ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClass, handler));\n@@ -234,1 +261,3 @@\n-     * Build a classfile into a file.\n+     * Build a classfile into a file using the provided constant pool\n+     * builder (which encapsulates classfile processing options.)\n+     *\n@@ -236,2 +265,2 @@\n-     * @param thisClass the name of the class to build\n-     * @param options the desired processing options\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n@@ -240,5 +269,5 @@\n-    public static void buildTo(Path path,\n-                               ClassDesc thisClass,\n-                               Collection<Option> options,\n-                               Consumer<? super ClassBuilder> handler) throws IOException {\n-        Files.write(path, build(thisClass, options, handler));\n+    default void buildTo(Path path,\n+                         ClassEntry thisClassEntry,\n+                         ConstantPoolBuilder constantPool,\n+                         Consumer<? super ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClassEntry, constantPool, handler));\n@@ -252,1 +281,1 @@\n-    public static byte[] buildModule(ModuleAttribute moduleAttribute) {\n+    default byte[] buildModule(ModuleAttribute moduleAttribute) {\n@@ -262,1 +291,1 @@\n-    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n+    default byte[] buildModule(ModuleAttribute moduleAttribute,\n@@ -276,1 +305,1 @@\n-    public static void buildModuleTo(Path path,\n+    default void buildModuleTo(Path path,\n@@ -287,1 +316,1 @@\n-    public static void buildModuleTo(Path path,\n+    default void buildModuleTo(Path path,\n@@ -293,257 +322,285 @@\n-    public static final int MAGIC_NUMBER = 0xCAFEBABE;\n-\n-    public static final int NOP             = 0;\n-    public static final int ACONST_NULL     = 1;\n-    public static final int ICONST_M1       = 2;\n-    public static final int ICONST_0        = 3;\n-    public static final int ICONST_1        = 4;\n-    public static final int ICONST_2        = 5;\n-    public static final int ICONST_3        = 6;\n-    public static final int ICONST_4        = 7;\n-    public static final int ICONST_5        = 8;\n-    public static final int LCONST_0        = 9;\n-    public static final int LCONST_1        = 10;\n-    public static final int FCONST_0        = 11;\n-    public static final int FCONST_1        = 12;\n-    public static final int FCONST_2        = 13;\n-    public static final int DCONST_0        = 14;\n-    public static final int DCONST_1        = 15;\n-    public static final int BIPUSH          = 16;\n-    public static final int SIPUSH          = 17;\n-    public static final int LDC             = 18;\n-    public static final int LDC_W           = 19;\n-    public static final int LDC2_W          = 20;\n-    public static final int ILOAD           = 21;\n-    public static final int LLOAD           = 22;\n-    public static final int FLOAD           = 23;\n-    public static final int DLOAD           = 24;\n-    public static final int ALOAD           = 25;\n-    public static final int ILOAD_0         = 26;\n-    public static final int ILOAD_1         = 27;\n-    public static final int ILOAD_2         = 28;\n-    public static final int ILOAD_3         = 29;\n-    public static final int LLOAD_0         = 30;\n-    public static final int LLOAD_1         = 31;\n-    public static final int LLOAD_2         = 32;\n-    public static final int LLOAD_3         = 33;\n-    public static final int FLOAD_0         = 34;\n-    public static final int FLOAD_1         = 35;\n-    public static final int FLOAD_2         = 36;\n-    public static final int FLOAD_3         = 37;\n-    public static final int DLOAD_0         = 38;\n-    public static final int DLOAD_1         = 39;\n-    public static final int DLOAD_2         = 40;\n-    public static final int DLOAD_3         = 41;\n-    public static final int ALOAD_0         = 42;\n-    public static final int ALOAD_1         = 43;\n-    public static final int ALOAD_2         = 44;\n-    public static final int ALOAD_3         = 45;\n-    public static final int IALOAD          = 46;\n-    public static final int LALOAD          = 47;\n-    public static final int FALOAD          = 48;\n-    public static final int DALOAD          = 49;\n-    public static final int AALOAD          = 50;\n-    public static final int BALOAD          = 51;\n-    public static final int CALOAD          = 52;\n-    public static final int SALOAD          = 53;\n-    public static final int ISTORE          = 54;\n-    public static final int LSTORE          = 55;\n-    public static final int FSTORE          = 56;\n-    public static final int DSTORE          = 57;\n-    public static final int ASTORE          = 58;\n-    public static final int ISTORE_0        = 59;\n-    public static final int ISTORE_1        = 60;\n-    public static final int ISTORE_2        = 61;\n-    public static final int ISTORE_3        = 62;\n-    public static final int LSTORE_0        = 63;\n-    public static final int LSTORE_1        = 64;\n-    public static final int LSTORE_2        = 65;\n-    public static final int LSTORE_3        = 66;\n-    public static final int FSTORE_0        = 67;\n-    public static final int FSTORE_1        = 68;\n-    public static final int FSTORE_2        = 69;\n-    public static final int FSTORE_3        = 70;\n-    public static final int DSTORE_0        = 71;\n-    public static final int DSTORE_1        = 72;\n-    public static final int DSTORE_2        = 73;\n-    public static final int DSTORE_3        = 74;\n-    public static final int ASTORE_0        = 75;\n-    public static final int ASTORE_1        = 76;\n-    public static final int ASTORE_2        = 77;\n-    public static final int ASTORE_3        = 78;\n-    public static final int IASTORE         = 79;\n-    public static final int LASTORE         = 80;\n-    public static final int FASTORE         = 81;\n-    public static final int DASTORE         = 82;\n-    public static final int AASTORE         = 83;\n-    public static final int BASTORE         = 84;\n-    public static final int CASTORE         = 85;\n-    public static final int SASTORE         = 86;\n-    public static final int POP             = 87;\n-    public static final int POP2            = 88;\n-    public static final int DUP             = 89;\n-    public static final int DUP_X1          = 90;\n-    public static final int DUP_X2          = 91;\n-    public static final int DUP2            = 92;\n-    public static final int DUP2_X1         = 93;\n-    public static final int DUP2_X2         = 94;\n-    public static final int SWAP            = 95;\n-    public static final int IADD            = 96;\n-    public static final int LADD            = 97;\n-    public static final int FADD            = 98;\n-    public static final int DADD            = 99;\n-    public static final int ISUB            = 100;\n-    public static final int LSUB            = 101;\n-    public static final int FSUB            = 102;\n-    public static final int DSUB            = 103;\n-    public static final int IMUL            = 104;\n-    public static final int LMUL            = 105;\n-    public static final int FMUL            = 106;\n-    public static final int DMUL            = 107;\n-    public static final int IDIV            = 108;\n-    public static final int LDIV            = 109;\n-    public static final int FDIV            = 110;\n-    public static final int DDIV            = 111;\n-    public static final int IREM            = 112;\n-    public static final int LREM            = 113;\n-    public static final int FREM            = 114;\n-    public static final int DREM            = 115;\n-    public static final int INEG            = 116;\n-    public static final int LNEG            = 117;\n-    public static final int FNEG            = 118;\n-    public static final int DNEG            = 119;\n-    public static final int ISHL            = 120;\n-    public static final int LSHL            = 121;\n-    public static final int ISHR            = 122;\n-    public static final int LSHR            = 123;\n-    public static final int IUSHR           = 124;\n-    public static final int LUSHR           = 125;\n-    public static final int IAND            = 126;\n-    public static final int LAND            = 127;\n-    public static final int IOR             = 128;\n-    public static final int LOR             = 129;\n-    public static final int IXOR            = 130;\n-    public static final int LXOR            = 131;\n-    public static final int IINC            = 132;\n-    public static final int I2L             = 133;\n-    public static final int I2F             = 134;\n-    public static final int I2D             = 135;\n-    public static final int L2I             = 136;\n-    public static final int L2F             = 137;\n-    public static final int L2D             = 138;\n-    public static final int F2I             = 139;\n-    public static final int F2L             = 140;\n-    public static final int F2D             = 141;\n-    public static final int D2I             = 142;\n-    public static final int D2L             = 143;\n-    public static final int D2F             = 144;\n-    public static final int I2B             = 145;\n-    public static final int I2C             = 146;\n-    public static final int I2S             = 147;\n-    public static final int LCMP            = 148;\n-    public static final int FCMPL           = 149;\n-    public static final int FCMPG           = 150;\n-    public static final int DCMPL           = 151;\n-    public static final int DCMPG           = 152;\n-    public static final int IFEQ            = 153;\n-    public static final int IFNE            = 154;\n-    public static final int IFLT            = 155;\n-    public static final int IFGE            = 156;\n-    public static final int IFGT            = 157;\n-    public static final int IFLE            = 158;\n-    public static final int IF_ICMPEQ       = 159;\n-    public static final int IF_ICMPNE       = 160;\n-    public static final int IF_ICMPLT       = 161;\n-    public static final int IF_ICMPGE       = 162;\n-    public static final int IF_ICMPGT       = 163;\n-    public static final int IF_ICMPLE       = 164;\n-    public static final int IF_ACMPEQ       = 165;\n-    public static final int IF_ACMPNE       = 166;\n-    public static final int GOTO            = 167;\n-    public static final int JSR             = 168;\n-    public static final int RET             = 169;\n-    public static final int TABLESWITCH     = 170;\n-    public static final int LOOKUPSWITCH    = 171;\n-    public static final int IRETURN         = 172;\n-    public static final int LRETURN         = 173;\n-    public static final int FRETURN         = 174;\n-    public static final int DRETURN         = 175;\n-    public static final int ARETURN         = 176;\n-    public static final int RETURN          = 177;\n-    public static final int GETSTATIC       = 178;\n-    public static final int PUTSTATIC       = 179;\n-    public static final int GETFIELD        = 180;\n-    public static final int PUTFIELD        = 181;\n-    public static final int INVOKEVIRTUAL   = 182;\n-    public static final int INVOKESPECIAL   = 183;\n-    public static final int INVOKESTATIC    = 184;\n-    public static final int INVOKEINTERFACE = 185;\n-    public static final int INVOKEDYNAMIC   = 186;\n-    public static final int NEW             = 187;\n-    public static final int NEWARRAY        = 188;\n-    public static final int ANEWARRAY       = 189;\n-    public static final int ARRAYLENGTH     = 190;\n-    public static final int ATHROW          = 191;\n-    public static final int CHECKCAST       = 192;\n-    public static final int INSTANCEOF      = 193;\n-    public static final int MONITORENTER    = 194;\n-    public static final int MONITOREXIT     = 195;\n-    public static final int WIDE            = 196;\n-    public static final int MULTIANEWARRAY  = 197;\n-    public static final int IFNULL          = 198;\n-    public static final int IFNONNULL       = 199;\n-    public static final int GOTO_W          = 200;\n-    public static final int JSR_W           = 201;\n-\n-    public static final int ACC_PUBLIC = 0x0001;\n-    public static final int ACC_PROTECTED = 0x0004;\n-    public static final int ACC_PRIVATE = 0x0002;\n-    public static final int ACC_INTERFACE = 0x0200;\n-    public static final int ACC_ENUM = 0x4000;\n-    public static final int ACC_ANNOTATION = 0x2000;\n-    public static final int ACC_SUPER = 0x0020;\n-    public static final int ACC_ABSTRACT = 0x0400;\n-    public static final int ACC_VOLATILE = 0x0040;\n-    public static final int ACC_TRANSIENT = 0x0080;\n-    public static final int ACC_SYNTHETIC = 0x1000;\n-    public static final int ACC_STATIC = 0x0008;\n-    public static final int ACC_FINAL = 0x0010;\n-    public static final int ACC_SYNCHRONIZED = 0x0020;\n-    public static final int ACC_BRIDGE = 0x0040;\n-    public static final int ACC_VARARGS = 0x0080;\n-    public static final int ACC_NATIVE = 0x0100;\n-    public static final int ACC_STRICT = 0x0800;\n-    public static final int ACC_MODULE = 0x8000;\n-    public static final int ACC_OPEN = 0x20;\n-    public static final int ACC_MANDATED = 0x8000;\n-    public static final int ACC_TRANSITIVE = 0x20;\n-    public static final int ACC_STATIC_PHASE = 0x40;\n-\n-    public static final int CRT_STATEMENT       = 0x0001;\n-    public static final int CRT_BLOCK           = 0x0002;\n-    public static final int CRT_ASSIGNMENT      = 0x0004;\n-    public static final int CRT_FLOW_CONTROLLER = 0x0008;\n-    public static final int CRT_FLOW_TARGET     = 0x0010;\n-    public static final int CRT_INVOKE          = 0x0020;\n-    public static final int CRT_CREATE          = 0x0040;\n-    public static final int CRT_BRANCH_TRUE     = 0x0080;\n-    public static final int CRT_BRANCH_FALSE    = 0x0100;\n-\n-    public static final int TAG_CLASS = 7;\n-    public static final int TAG_CONSTANTDYNAMIC = 17;\n-    public static final int TAG_DOUBLE = 6;\n-    public static final int TAG_FIELDREF = 9;\n-    public static final int TAG_FLOAT = 4;\n-    public static final int TAG_INTEGER = 3;\n-    public static final int TAG_INTERFACEMETHODREF = 11;\n-    public static final int TAG_INVOKEDYNAMIC = 18;\n-    public static final int TAG_LONG = 5;\n-    public static final int TAG_METHODHANDLE = 15;\n-    public static final int TAG_METHODREF = 10;\n-    public static final int TAG_METHODTYPE = 16;\n-    public static final int TAG_MODULE = 19;\n-    public static final int TAG_NAMEANDTYPE = 12;\n-    public static final int TAG_PACKAGE = 20;\n-    public static final int TAG_STRING = 8;\n-    public static final int TAG_UNICODE = 2;\n-    public static final int TAG_UTF8 = 1;\n+    \/**\n+     * Transform one classfile into a new classfile with the aid of a\n+     * {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     *\n+     * @implNote\n+     * <p>This method behaves as if:\n+     * {@snippet lang=java :\n+     *     Classfile.of().build(thisClass(), ConstantPoolBuilder.of(this),\n+     *                     b -> b.transform(this, transform));\n+     * }\n+     *\n+     * @param model class model to transform\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     *\/\n+    default byte[] transform(ClassModel model, ClassTransform transform) {\n+        return transform(model, model.thisClass(), transform);\n+    }\n+\n+    default byte[] transform(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transform(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    }\n+\n+    byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+\n+    int MAGIC_NUMBER = 0xCAFEBABE;\n+\n+    int NOP             = 0;\n+    int ACONST_NULL     = 1;\n+    int ICONST_M1       = 2;\n+    int ICONST_0        = 3;\n+    int ICONST_1        = 4;\n+    int ICONST_2        = 5;\n+    int ICONST_3        = 6;\n+    int ICONST_4        = 7;\n+    int ICONST_5        = 8;\n+    int LCONST_0        = 9;\n+    int LCONST_1        = 10;\n+    int FCONST_0        = 11;\n+    int FCONST_1        = 12;\n+    int FCONST_2        = 13;\n+    int DCONST_0        = 14;\n+    int DCONST_1        = 15;\n+    int BIPUSH          = 16;\n+    int SIPUSH          = 17;\n+    int LDC             = 18;\n+    int LDC_W           = 19;\n+    int LDC2_W          = 20;\n+    int ILOAD           = 21;\n+    int LLOAD           = 22;\n+    int FLOAD           = 23;\n+    int DLOAD           = 24;\n+    int ALOAD           = 25;\n+    int ILOAD_0         = 26;\n+    int ILOAD_1         = 27;\n+    int ILOAD_2         = 28;\n+    int ILOAD_3         = 29;\n+    int LLOAD_0         = 30;\n+    int LLOAD_1         = 31;\n+    int LLOAD_2         = 32;\n+    int LLOAD_3         = 33;\n+    int FLOAD_0         = 34;\n+    int FLOAD_1         = 35;\n+    int FLOAD_2         = 36;\n+    int FLOAD_3         = 37;\n+    int DLOAD_0         = 38;\n+    int DLOAD_1         = 39;\n+    int DLOAD_2         = 40;\n+    int DLOAD_3         = 41;\n+    int ALOAD_0         = 42;\n+    int ALOAD_1         = 43;\n+    int ALOAD_2         = 44;\n+    int ALOAD_3         = 45;\n+    int IALOAD          = 46;\n+    int LALOAD          = 47;\n+    int FALOAD          = 48;\n+    int DALOAD          = 49;\n+    int AALOAD          = 50;\n+    int BALOAD          = 51;\n+    int CALOAD          = 52;\n+    int SALOAD          = 53;\n+    int ISTORE          = 54;\n+    int LSTORE          = 55;\n+    int FSTORE          = 56;\n+    int DSTORE          = 57;\n+    int ASTORE          = 58;\n+    int ISTORE_0        = 59;\n+    int ISTORE_1        = 60;\n+    int ISTORE_2        = 61;\n+    int ISTORE_3        = 62;\n+    int LSTORE_0        = 63;\n+    int LSTORE_1        = 64;\n+    int LSTORE_2        = 65;\n+    int LSTORE_3        = 66;\n+    int FSTORE_0        = 67;\n+    int FSTORE_1        = 68;\n+    int FSTORE_2        = 69;\n+    int FSTORE_3        = 70;\n+    int DSTORE_0        = 71;\n+    int DSTORE_1        = 72;\n+    int DSTORE_2        = 73;\n+    int DSTORE_3        = 74;\n+    int ASTORE_0        = 75;\n+    int ASTORE_1        = 76;\n+    int ASTORE_2        = 77;\n+    int ASTORE_3        = 78;\n+    int IASTORE         = 79;\n+    int LASTORE         = 80;\n+    int FASTORE         = 81;\n+    int DASTORE         = 82;\n+    int AASTORE         = 83;\n+    int BASTORE         = 84;\n+    int CASTORE         = 85;\n+    int SASTORE         = 86;\n+    int POP             = 87;\n+    int POP2            = 88;\n+    int DUP             = 89;\n+    int DUP_X1          = 90;\n+    int DUP_X2          = 91;\n+    int DUP2            = 92;\n+    int DUP2_X1         = 93;\n+    int DUP2_X2         = 94;\n+    int SWAP            = 95;\n+    int IADD            = 96;\n+    int LADD            = 97;\n+    int FADD            = 98;\n+    int DADD            = 99;\n+    int ISUB            = 100;\n+    int LSUB            = 101;\n+    int FSUB            = 102;\n+    int DSUB            = 103;\n+    int IMUL            = 104;\n+    int LMUL            = 105;\n+    int FMUL            = 106;\n+    int DMUL            = 107;\n+    int IDIV            = 108;\n+    int LDIV            = 109;\n+    int FDIV            = 110;\n+    int DDIV            = 111;\n+    int IREM            = 112;\n+    int LREM            = 113;\n+    int FREM            = 114;\n+    int DREM            = 115;\n+    int INEG            = 116;\n+    int LNEG            = 117;\n+    int FNEG            = 118;\n+    int DNEG            = 119;\n+    int ISHL            = 120;\n+    int LSHL            = 121;\n+    int ISHR            = 122;\n+    int LSHR            = 123;\n+    int IUSHR           = 124;\n+    int LUSHR           = 125;\n+    int IAND            = 126;\n+    int LAND            = 127;\n+    int IOR             = 128;\n+    int LOR             = 129;\n+    int IXOR            = 130;\n+    int LXOR            = 131;\n+    int IINC            = 132;\n+    int I2L             = 133;\n+    int I2F             = 134;\n+    int I2D             = 135;\n+    int L2I             = 136;\n+    int L2F             = 137;\n+    int L2D             = 138;\n+    int F2I             = 139;\n+    int F2L             = 140;\n+    int F2D             = 141;\n+    int D2I             = 142;\n+    int D2L             = 143;\n+    int D2F             = 144;\n+    int I2B             = 145;\n+    int I2C             = 146;\n+    int I2S             = 147;\n+    int LCMP            = 148;\n+    int FCMPL           = 149;\n+    int FCMPG           = 150;\n+    int DCMPL           = 151;\n+    int DCMPG           = 152;\n+    int IFEQ            = 153;\n+    int IFNE            = 154;\n+    int IFLT            = 155;\n+    int IFGE            = 156;\n+    int IFGT            = 157;\n+    int IFLE            = 158;\n+    int IF_ICMPEQ       = 159;\n+    int IF_ICMPNE       = 160;\n+    int IF_ICMPLT       = 161;\n+    int IF_ICMPGE       = 162;\n+    int IF_ICMPGT       = 163;\n+    int IF_ICMPLE       = 164;\n+    int IF_ACMPEQ       = 165;\n+    int IF_ACMPNE       = 166;\n+    int GOTO            = 167;\n+    int JSR             = 168;\n+    int RET             = 169;\n+    int TABLESWITCH     = 170;\n+    int LOOKUPSWITCH    = 171;\n+    int IRETURN         = 172;\n+    int LRETURN         = 173;\n+    int FRETURN         = 174;\n+    int DRETURN         = 175;\n+    int ARETURN         = 176;\n+    int RETURN          = 177;\n+    int GETSTATIC       = 178;\n+    int PUTSTATIC       = 179;\n+    int GETFIELD        = 180;\n+    int PUTFIELD        = 181;\n+    int INVOKEVIRTUAL   = 182;\n+    int INVOKESPECIAL   = 183;\n+    int INVOKESTATIC    = 184;\n+    int INVOKEINTERFACE = 185;\n+    int INVOKEDYNAMIC   = 186;\n+    int NEW             = 187;\n+    int NEWARRAY        = 188;\n+    int ANEWARRAY       = 189;\n+    int ARRAYLENGTH     = 190;\n+    int ATHROW          = 191;\n+    int CHECKCAST       = 192;\n+    int INSTANCEOF      = 193;\n+    int MONITORENTER    = 194;\n+    int MONITOREXIT     = 195;\n+    int WIDE            = 196;\n+    int MULTIANEWARRAY  = 197;\n+    int IFNULL          = 198;\n+    int IFNONNULL       = 199;\n+    int GOTO_W          = 200;\n+    int JSR_W           = 201;\n+\n+    int ACC_PUBLIC = 0x0001;\n+    int ACC_PROTECTED = 0x0004;\n+    int ACC_PRIVATE = 0x0002;\n+    int ACC_INTERFACE = 0x0200;\n+    int ACC_ENUM = 0x4000;\n+    int ACC_ANNOTATION = 0x2000;\n+    int ACC_SUPER = 0x0020;\n+    int ACC_ABSTRACT = 0x0400;\n+    int ACC_VOLATILE = 0x0040;\n+    int ACC_TRANSIENT = 0x0080;\n+    int ACC_SYNTHETIC = 0x1000;\n+    int ACC_STATIC = 0x0008;\n+    int ACC_FINAL = 0x0010;\n+    int ACC_SYNCHRONIZED = 0x0020;\n+    int ACC_BRIDGE = 0x0040;\n+    int ACC_VARARGS = 0x0080;\n+    int ACC_NATIVE = 0x0100;\n+    int ACC_STRICT = 0x0800;\n+    int ACC_MODULE = 0x8000;\n+    int ACC_OPEN = 0x20;\n+    int ACC_MANDATED = 0x8000;\n+    int ACC_TRANSITIVE = 0x20;\n+    int ACC_STATIC_PHASE = 0x40;\n+\n+    int CRT_STATEMENT       = 0x0001;\n+    int CRT_BLOCK           = 0x0002;\n+    int CRT_ASSIGNMENT      = 0x0004;\n+    int CRT_FLOW_CONTROLLER = 0x0008;\n+    int CRT_FLOW_TARGET     = 0x0010;\n+    int CRT_INVOKE          = 0x0020;\n+    int CRT_CREATE          = 0x0040;\n+    int CRT_BRANCH_TRUE     = 0x0080;\n+    int CRT_BRANCH_FALSE    = 0x0100;\n+\n+    int TAG_CLASS = 7;\n+    int TAG_CONSTANTDYNAMIC = 17;\n+    int TAG_DOUBLE = 6;\n+    int TAG_FIELDREF = 9;\n+    int TAG_FLOAT = 4;\n+    int TAG_INTEGER = 3;\n+    int TAG_INTERFACEMETHODREF = 11;\n+    int TAG_INVOKEDYNAMIC = 18;\n+    int TAG_LONG = 5;\n+    int TAG_METHODHANDLE = 15;\n+    int TAG_METHODREF = 10;\n+    int TAG_METHODTYPE = 16;\n+    int TAG_MODULE = 19;\n+    int TAG_NAMEANDTYPE = 12;\n+    int TAG_PACKAGE = 20;\n+    int TAG_STRING = 8;\n+    int TAG_UNICODE = 2;\n+    int TAG_UTF8 = 1;\n@@ -552,22 +609,22 @@\n-    public static final int TAT_CLASS_TYPE_PARAMETER = 0x00;\n-    public static final int TAT_METHOD_TYPE_PARAMETER = 0x01;\n-    public static final int TAT_CLASS_EXTENDS = 0x10;\n-    public static final int TAT_CLASS_TYPE_PARAMETER_BOUND = 0x11;\n-    public static final int TAT_METHOD_TYPE_PARAMETER_BOUND = 0x12;\n-    public static final int TAT_FIELD = 0x13;\n-    public static final int TAT_METHOD_RETURN = 0x14;\n-    public static final int TAT_METHOD_RECEIVER = 0x15;\n-    public static final int TAT_METHOD_FORMAL_PARAMETER = 0x16;\n-    public static final int TAT_THROWS = 0x17;\n-    public static final int TAT_LOCAL_VARIABLE = 0x40;\n-    public static final int TAT_RESOURCE_VARIABLE = 0x41;\n-    public static final int TAT_EXCEPTION_PARAMETER = 0x42;\n-    public static final int TAT_INSTANCEOF = 0x43;\n-    public static final int TAT_NEW = 0x44;\n-    public static final int TAT_CONSTRUCTOR_REFERENCE = 0x45;\n-    public static final int TAT_METHOD_REFERENCE = 0x46;\n-    public static final int TAT_CAST = 0x47;\n-    public static final int TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n-    public static final int TAT_METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n-    public static final int TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n-    public static final int TAT_METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n+    int TAT_CLASS_TYPE_PARAMETER = 0x00;\n+    int TAT_METHOD_TYPE_PARAMETER = 0x01;\n+    int TAT_CLASS_EXTENDS = 0x10;\n+    int TAT_CLASS_TYPE_PARAMETER_BOUND = 0x11;\n+    int TAT_METHOD_TYPE_PARAMETER_BOUND = 0x12;\n+    int TAT_FIELD = 0x13;\n+    int TAT_METHOD_RETURN = 0x14;\n+    int TAT_METHOD_RECEIVER = 0x15;\n+    int TAT_METHOD_FORMAL_PARAMETER = 0x16;\n+    int TAT_THROWS = 0x17;\n+    int TAT_LOCAL_VARIABLE = 0x40;\n+    int TAT_RESOURCE_VARIABLE = 0x41;\n+    int TAT_EXCEPTION_PARAMETER = 0x42;\n+    int TAT_INSTANCEOF = 0x43;\n+    int TAT_NEW = 0x44;\n+    int TAT_CONSTRUCTOR_REFERENCE = 0x45;\n+    int TAT_METHOD_REFERENCE = 0x46;\n+    int TAT_CAST = 0x47;\n+    int TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n+    int TAT_METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n+    int TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n+    int TAT_METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n@@ -576,37 +633,37 @@\n-    public static final int VT_TOP = 0;\n-    public static final int VT_INTEGER = 1;\n-    public static final int VT_FLOAT = 2;\n-    public static final int VT_DOUBLE = 3;\n-    public static final int VT_LONG = 4;\n-    public static final int VT_NULL = 5;\n-    public static final int VT_UNINITIALIZED_THIS = 6;\n-    public static final int VT_OBJECT = 7;\n-    public static final int VT_UNINITIALIZED = 8;\n-\n-    public static final int DEFAULT_CLASS_FLAGS = ACC_PUBLIC;\n-\n-    public static final int JAVA_1_VERSION = 45;\n-    public static final int JAVA_2_VERSION = 46;\n-    public static final int JAVA_3_VERSION = 47;\n-    public static final int JAVA_4_VERSION = 48;\n-    public static final int JAVA_5_VERSION = 49;\n-    public static final int JAVA_6_VERSION = 50;\n-    public static final int JAVA_7_VERSION = 51;\n-    public static final int JAVA_8_VERSION = 52;\n-    public static final int JAVA_9_VERSION = 53;\n-    public static final int JAVA_10_VERSION = 54;\n-    public static final int JAVA_11_VERSION = 55;\n-    public static final int JAVA_12_VERSION = 56;\n-    public static final int JAVA_13_VERSION = 57;\n-    public static final int JAVA_14_VERSION = 58;\n-    public static final int JAVA_15_VERSION = 59;\n-    public static final int JAVA_16_VERSION = 60;\n-    public static final int JAVA_17_VERSION = 61;\n-    public static final int JAVA_18_VERSION = 62;\n-    public static final int JAVA_19_VERSION = 63;\n-    public static final int JAVA_20_VERSION = 64;\n-    public static final int JAVA_21_VERSION = 65;\n-\n-    public static final int LATEST_MAJOR_VERSION = JAVA_21_VERSION;\n-    public static final int LATEST_MINOR_VERSION = 0;\n-    public static final int PREVIEW_MINOR_VERSION = -1;\n+    int VT_TOP = 0;\n+    int VT_INTEGER = 1;\n+    int VT_FLOAT = 2;\n+    int VT_DOUBLE = 3;\n+    int VT_LONG = 4;\n+    int VT_NULL = 5;\n+    int VT_UNINITIALIZED_THIS = 6;\n+    int VT_OBJECT = 7;\n+    int VT_UNINITIALIZED = 8;\n+\n+    int DEFAULT_CLASS_FLAGS = ACC_PUBLIC;\n+\n+    int JAVA_1_VERSION = 45;\n+    int JAVA_2_VERSION = 46;\n+    int JAVA_3_VERSION = 47;\n+    int JAVA_4_VERSION = 48;\n+    int JAVA_5_VERSION = 49;\n+    int JAVA_6_VERSION = 50;\n+    int JAVA_7_VERSION = 51;\n+    int JAVA_8_VERSION = 52;\n+    int JAVA_9_VERSION = 53;\n+    int JAVA_10_VERSION = 54;\n+    int JAVA_11_VERSION = 55;\n+    int JAVA_12_VERSION = 56;\n+    int JAVA_13_VERSION = 57;\n+    int JAVA_14_VERSION = 58;\n+    int JAVA_15_VERSION = 59;\n+    int JAVA_16_VERSION = 60;\n+    int JAVA_17_VERSION = 61;\n+    int JAVA_18_VERSION = 62;\n+    int JAVA_19_VERSION = 63;\n+    int JAVA_20_VERSION = 64;\n+    int JAVA_21_VERSION = 65;\n+\n+    int LATEST_MAJOR_VERSION = JAVA_21_VERSION;\n+    int LATEST_MINOR_VERSION = 0;\n+    int PREVIEW_MINOR_VERSION = -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":511,"deletions":454,"binary":false,"changes":965,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * {@link ClassModel#transform(ClassTransform)}, and the elements of the class,\n+ * {@link Classfile#transform(ClassModel, ClassTransform)}, and the elements of the class,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassfileTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * options (e.g., {@link Classfile.Option#processDebug(boolean)}).\n+ * options (e.g., {@link Classfile.DebugElementsOption}).\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/PseudoInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * {@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)} option.\n+ * {@link jdk.internal.classfile.Classfile.LineNumbersOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LineNumberTableAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * {@link jdk.internal.classfile.Classfile.Option#processDebug(boolean)} option.\n+ * {@link jdk.internal.classfile.Classfile.DebugElementsOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * {@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)} option.\n+ * {@link jdk.internal.classfile.Classfile.LineNumbersOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+     * @param context Classfile context\n@@ -102,3 +103,2 @@\n-    default byte[] remapClass(ClassModel clm) {\n-        return Classfile.build(map(clm.thisClass().asSymbol()),\n-                clb -> clm.forEachElement(resolve(clb).consumer()));\n+    default byte[] remapClass(Classfile context, ClassModel clm) {\n+        return context.transform(clm, map(clm.thisClass().asSymbol()), this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -104,1 +105,1 @@\n-\n+        var cc = Classfile.of();\n@@ -106,1 +107,1 @@\n-            byte[] newBytes = classRemapper.remapClass(classModel);\n+            byte[] newBytes = classRemapper.remapClass(cc, classModel);\n@@ -116,1 +117,1 @@\n-\n+        var cc = Classfile.of();\n@@ -118,1 +119,1 @@\n-            byte[] newBytes = classRemapper.remapClass(classModel);\n+            byte[] newBytes = classRemapper.remapClass(cc, classModel);\n@@ -126,8 +127,10 @@\n-        byte[] newBytes = classModel.transform((classBuilder, classElement) -> {\n-                if (classElement instanceof MethodModel method)\n-                    classBuilder.transformMethod(method,\n-                            MethodTransform.transformingCode(\n-                                    CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));\n-                else\n-                    classBuilder.accept(classElement);\n-            });\n+        byte[] newBytes = Classfile.of().transform(\n+                classModel,\n+                (classBuilder, classElement) -> {\n+                    if (classElement instanceof MethodModel method)\n+                        classBuilder.transformMethod(method,\n+                                MethodTransform.transformingCode(\n+                                        CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));\n+                    else\n+                        classBuilder.accept(classElement);\n+                });\n@@ -139,1 +142,2 @@\n-        byte[] newBytes = classModel.transform(\n+        byte[] newBytes = Classfile.of().transform(\n+                classModel,\n@@ -153,1 +157,1 @@\n-        return target.transform(\n+        return Classfile.of().transform(target,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.internal.classfile.impl.Options;\n+import jdk.internal.classfile.impl.ClassfileImpl;\n@@ -66,5 +66,3 @@\n-     * {@return a new constant pool builder}  The new constant pool builder\n-     * will inherit the classfile processing options of the specified class.\n-     * If the processing options include {@link Classfile.Option#constantPoolSharing(boolean)},\n-     * (the default) the new constant pool builder will be also be pre-populated with the\n-     * contents of the constant pool associated with the class reader.\n+     * {@return a new constant pool builder}  The new constant pool builder will\n+     * be pre-populated with the contents of the constant pool associated with\n+     * the class reader.\n@@ -75,4 +73,1 @@\n-        ClassReaderImpl reader = (ClassReaderImpl) classModel.constantPool();\n-        return reader.options().cpSharing\n-          ? new SplitConstantPool(reader)\n-          : new SplitConstantPool(reader.options());\n+        return new SplitConstantPool((ClassReaderImpl) classModel.constantPool());\n@@ -83,3 +78,1 @@\n-     * will be empty and have the specified classfile processing options.\n-     *\n-     * @param options the processing options\n+     * will be empty.\n@@ -87,2 +80,2 @@\n-    static ConstantPoolBuilder of(Collection<Classfile.Option> options) {\n-        return new SplitConstantPool(new Options(options));\n+    static ConstantPoolBuilder of() {\n+        return new SplitConstantPool();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+    protected final ClassfileImpl context;\n@@ -36,1 +37,1 @@\n-    public AbstractDirectBuilder(SplitConstantPool constantPool) {\n+    public AbstractDirectBuilder(SplitConstantPool constantPool, ClassfileImpl context) {\n@@ -38,0 +39,1 @@\n+        this.context = context;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-            } else if (((ClassReaderImpl)reader).options().processUnknownAttributes) {\n+            } else if (((ClassReaderImpl)reader).context().unknownAttributesOption() == Classfile.UnknownAttributesOption.PASS_UNKNOWN_ATTRIBUTES) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    private final ClassfileImpl context;\n@@ -48,2 +49,2 @@\n-    public BufWriterImpl(ConstantPoolBuilder constantPool) {\n-        this(constantPool, 64, null, 0);\n+    public BufWriterImpl(ConstantPoolBuilder constantPool, ClassfileImpl context) {\n+        this(constantPool, context, 64, null, 0);\n@@ -52,2 +53,2 @@\n-    public BufWriterImpl(ConstantPoolBuilder constantPool, int initialSize) {\n-        this(constantPool, initialSize, null, 0);\n+    public BufWriterImpl(ConstantPoolBuilder constantPool, ClassfileImpl context, int initialSize) {\n+        this(constantPool, context, initialSize, null, 0);\n@@ -56,1 +57,1 @@\n-    public BufWriterImpl(ConstantPoolBuilder constantPool, int initialSize, ClassEntry thisClass, int majorVersion) {\n+    public BufWriterImpl(ConstantPoolBuilder constantPool, ClassfileImpl context, int initialSize, ClassEntry thisClass, int majorVersion) {\n@@ -58,0 +59,1 @@\n+        this.context = context;\n@@ -88,0 +90,4 @@\n+    public ClassfileImpl context() {\n+        return context;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    private final ClassfileImpl context;\n@@ -57,0 +58,1 @@\n+                               ClassfileImpl context,\n@@ -59,0 +61,1 @@\n+        this.context = context;\n@@ -207,1 +210,1 @@\n-            DirectCodeBuilder.build(methodInfo, cb -> elements.forEach(cb), constantPool, null).writeTo(buf);\n+            DirectCodeBuilder.build(methodInfo, cb -> elements.forEach(cb), constantPool, context, null).writeTo(buf);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    private final ClassfileImpl context;\n@@ -46,0 +47,1 @@\n+                                ClassfileImpl context,\n@@ -50,0 +52,1 @@\n+        this.context = context;\n@@ -122,1 +125,1 @@\n-            DirectFieldBuilder fb = new DirectFieldBuilder(constantPool, name, desc, null);\n+            DirectFieldBuilder fb = new DirectFieldBuilder(constantPool, context, name, desc, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final ClassfileImpl context;\n@@ -58,0 +59,1 @@\n+                                 ClassfileImpl context,\n@@ -63,0 +65,1 @@\n+        this.context = context;\n@@ -122,1 +125,1 @@\n-        return with(new BufferedCodeBuilder(this, constantPool, null)\n+        return with(new BufferedCodeBuilder(this, constantPool, context, null)\n@@ -129,1 +132,1 @@\n-        BufferedCodeBuilder builder = new BufferedCodeBuilder(this, constantPool, code);\n+        BufferedCodeBuilder builder = new BufferedCodeBuilder(this, constantPool, context, code);\n@@ -136,1 +139,1 @@\n-        return new BufferedCodeBuilder(this, constantPool, original);\n+        return new BufferedCodeBuilder(this, constantPool, context, original);\n@@ -207,1 +210,1 @@\n-            DirectMethodBuilder mb = new DirectMethodBuilder(constantPool, name, desc, methodFlags(), null);\n+            DirectMethodBuilder mb = new DirectMethodBuilder(constantPool, context, name, desc, methodFlags(), null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return downstream.with(new BufferedFieldBuilder(terminal.constantPool,\n+        return downstream.with(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -71,1 +71,1 @@\n-        BufferedFieldBuilder builder = new BufferedFieldBuilder(terminal.constantPool,\n+        BufferedFieldBuilder builder = new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -81,1 +81,1 @@\n-        return downstream.with(new BufferedMethodBuilder(terminal.constantPool,\n+        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n@@ -89,1 +89,1 @@\n-        BufferedMethodBuilder builder = new BufferedMethodBuilder(terminal.constantPool,\n+        BufferedMethodBuilder builder = new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -37,1 +36,0 @@\n-import java.util.function.Supplier;\n@@ -55,10 +53,0 @@\n-    public static final ClassHierarchyResolver DEFAULT_RESOLVER = ClassHierarchyResolver\n-            .ofResourceParsing(ResourceParsingClassHierarchyResolver.SYSTEM_STREAM_PROVIDER)\n-            .orElse(new ClassLoadingClassHierarchyResolver(ClassLoadingClassHierarchyResolver.SYSTEM_CLASS_PROVIDER))\n-            .cached(new Supplier<>() {\n-                @Override\n-                public Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> get() {\n-                    return new ConcurrentHashMap<>();\n-                }\n-            });\n-\n@@ -128,1 +116,1 @@\n-        private final Function<ClassDesc, ClassHierarchyInfo> delegateFunction;\n+        private final ClassHierarchyResolver delegate;\n@@ -132,7 +120,1 @@\n-            this.delegateFunction = new Function<>() {\n-                @Override\n-                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n-                    var ret = delegate.getClassInfo(classDesc);\n-                    return ret == null ? NOPE : ret;\n-                }\n-            };\n+            this.delegate = delegate;\n@@ -143,1 +125,6 @@\n-            var ret = resolvedCache.computeIfAbsent(classDesc, delegateFunction);\n+            var ret = resolvedCache.get(classDesc);\n+            if (ret == null) {\n+                \/\/semi-synchronized caching, where the map is not locked during delegate call\n+                ret = delegate.getClassInfo(classDesc);\n+                resolvedCache.put(classDesc, ret == null ? NOPE : ret);\n+            }\n@@ -149,6 +136,0 @@\n-        public static final Function<ClassDesc, InputStream> SYSTEM_STREAM_PROVIDER = new Function<>() {\n-            @Override\n-            public InputStream apply(ClassDesc cd) {\n-                return ClassLoader.getSystemClassLoader().getResourceAsStream(Util.toInternalName(cd) + \".class\");\n-            }\n-        };\n@@ -220,10 +201,0 @@\n-        public static final Function<ClassDesc, Class<?>> SYSTEM_CLASS_PROVIDER = new Function<>() {\n-            @Override\n-            public Class<?> apply(ClassDesc cd) {\n-                try {\n-                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, ClassLoader.getSystemClassLoader());\n-                } catch (ClassNotFoundException ex) {\n-                    return null;\n-                }\n-            }\n-        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":8,"deletions":37,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -66,3 +66,2 @@\n-    public ClassImpl(byte[] cfbytes,\n-                     Collection<Classfile.Option> options) {\n-        this.reader = new ClassReaderImpl(cfbytes, options);\n+    public ClassImpl(byte[] cfbytes, ClassfileImpl context) {\n+        this.reader = new ClassReaderImpl(cfbytes, context);\n@@ -97,0 +96,4 @@\n+    public int classfileLength() {\n+        return reader.classfileLength();\n+    }\n+\n@@ -172,14 +175,0 @@\n-    @Override\n-    public byte[] transform(ClassTransform transform) {\n-        ConstantPoolBuilder constantPool = ConstantPoolBuilder.of(this);\n-        return Classfile.build(thisClass(), constantPool,\n-                               new Consumer<ClassBuilder>() {\n-                                   @Override\n-                                   public void accept(ClassBuilder builder) {\n-                                       ((DirectClassBuilder) builder).setOriginal(ClassImpl.this);\n-                                       ((DirectClassBuilder) builder).setSizeHint(reader.classfileLength());\n-                                       builder.transform(ClassImpl.this, transform);\n-                                   }\n-                               });\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    final Options options;\n+    final ClassfileImpl context;\n@@ -89,1 +89,1 @@\n-                    Collection<Classfile.Option> options) {\n+                    ClassfileImpl context) {\n@@ -92,2 +92,2 @@\n-        this.options = new Options(options);\n-        this.attributeMapper = this.options.attributeMapper;\n+        this.context = context;\n+        this.attributeMapper = this.context.attributeMapperOption().attributeMapper();\n@@ -137,2 +137,2 @@\n-    public Options options() {\n-        return options;\n+    public ClassfileImpl context() {\n+        return context;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public record ClassfileImpl(StackMapsOption stackMapsOption,\n+                            DebugElementsOption debugElementsOption,\n+                            LineNumbersOption lineNumbersOption,\n+                            UnknownAttributesOption unknownAttributesOption,\n+                            ConstantPoolSharingOption constantPoolSharingOption,\n+                            ShortJumpsOption shortJumpsOption,\n+                            DeadCodeOption deadCodeOption,\n+                            DeadLabelsOption deadLabelsOption,\n+                            ClassHierarchyResolverOption classHierarchyResolverOption,\n+                            AttributeMapperOption attributeMapperOption) implements Classfile {\n+\n+    private static final ClassfileImpl DEFAULT_STATIC_CONTEXT = new ClassfileImpl(\n+            StackMapsOption.STACK_MAPS_WHEN_REQUIRED,\n+             DebugElementsOption.PASS_DEBUG,\n+             LineNumbersOption.PASS_LINE_NUMBERS,\n+             UnknownAttributesOption.PASS_UNKNOWN_ATTRIBUTES,\n+             ConstantPoolSharingOption.SHARED_POOL,\n+             ShortJumpsOption.FIX_SHORT_JUMPS,\n+             DeadCodeOption.PATCH_DEAD_CODE,\n+             DeadLabelsOption.FAIL_ON_DEAD_LABELS,\n+             null,\n+             new AttributeMapperOptionImpl(new Function<>() {\n+                 @Override\n+                 public AttributeMapper<?> apply(Utf8Entry k) {\n+                     return null;\n+                 }\n+             }));\n+\n+    public static ClassfileImpl of(Option... options) {\n+        return DEFAULT_STATIC_CONTEXT.withOptions(options);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ClassfileImpl withOptions(Option... options) {\n+        var smo = stackMapsOption;\n+        var deo = debugElementsOption;\n+        var lno = lineNumbersOption;\n+        var uao = unknownAttributesOption;\n+        var cpso = constantPoolSharingOption;\n+        var sjo = shortJumpsOption;\n+        var dco = deadCodeOption;\n+        var dlo = deadLabelsOption;\n+        var chro = classHierarchyResolverOption;\n+        var amo = attributeMapperOption;\n+        for (var o : options) {\n+            switch (o) {\n+                case StackMapsOption oo -> smo = oo;\n+                case DebugElementsOption oo -> deo = oo;\n+                case LineNumbersOption oo -> lno = oo;\n+                case UnknownAttributesOption oo -> uao = oo;\n+                case ConstantPoolSharingOption oo -> cpso = oo;\n+                case ShortJumpsOption oo -> sjo = oo;\n+                case DeadCodeOption oo -> dco = oo;\n+                case DeadLabelsOption oo -> dlo = oo;\n+                case ClassHierarchyResolverOption oo -> chro = oo;\n+                case AttributeMapperOption oo -> amo = oo;\n+            }\n+        }\n+        if (chro == null) {\n+            chro = ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofSystem());\n+        }\n+        return new ClassfileImpl(smo, deo, lno, uao, cpso, sjo, dco, dlo, chro, amo);\n+    }\n+\n+    @Override\n+    public ClassModel parse(byte[] bytes) {\n+        return new ClassImpl(bytes, this);\n+    }\n+\n+    @Override\n+    public byte[] build(ClassEntry thisClassEntry,\n+                         ConstantPoolBuilder constantPool,\n+                         Consumer<? super ClassBuilder> handler) {\n+        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n+        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, this, thisClassEntry);\n+        handler.accept(builder);\n+        return builder.build();\n+    }\n+\n+    @Override\n+    public byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+        ConstantPoolBuilder constantPool = constantPoolSharingOption() == ConstantPoolSharingOption.SHARED_POOL\n+                                                                     ? ConstantPoolBuilder.of(model)\n+                                                                     : ConstantPoolBuilder.of();\n+        return build(newClassName, constantPool,\n+                new Consumer<ClassBuilder>() {\n+                    @Override\n+                    public void accept(ClassBuilder builder) {\n+                        ((DirectClassBuilder) builder).setOriginal((ClassImpl)model);\n+                        ((DirectClassBuilder) builder).setSizeHint(((ClassImpl)model).classfileLength());\n+                        builder.transform((ClassImpl)model, transform);\n+                    }\n+                });\n+    }\n+    public record AttributeMapperOptionImpl(Function<Utf8Entry, AttributeMapper<?>> attributeMapper)\n+            implements AttributeMapperOption {\n+    }\n+\n+    public record ClassHierarchyResolverOptionImpl(ClassHierarchyResolver classHierarchyResolver)\n+            implements ClassHierarchyResolverOption {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassfileImpl.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -121,1 +121,1 @@\n-            if (((ClassReaderImpl)classReader).options().processLineNumbers)\n+            if (((ClassReaderImpl)classReader).context().lineNumbersOption() == Classfile.LineNumbersOption.PASS_LINE_NUMBERS)\n@@ -153,0 +153,1 @@\n+                                    ((BufWriterImpl)buf).context(),\n@@ -169,1 +170,1 @@\n-        if (((ClassReaderImpl)classReader).options().processDebug)\n+        if (((ClassReaderImpl)classReader).context().debugElementsOption() == Classfile.DebugElementsOption.PASS_DEBUG)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+                              ClassfileImpl context,\n@@ -65,1 +66,1 @@\n-        super(constantPool);\n+        super(constantPool, context);\n@@ -84,1 +85,1 @@\n-        return withField(new DirectFieldBuilder(constantPool, name, descriptor, null)\n+        return withField(new DirectFieldBuilder(constantPool, context, name, descriptor, null)\n@@ -90,1 +91,1 @@\n-        DirectFieldBuilder builder = new DirectFieldBuilder(constantPool, field.fieldName(),\n+        DirectFieldBuilder builder = new DirectFieldBuilder(constantPool, context, field.fieldName(),\n@@ -101,1 +102,1 @@\n-        return withMethod(new DirectMethodBuilder(constantPool, name, descriptor, flags, null)\n+        return withMethod(new DirectMethodBuilder(constantPool, context, name, descriptor, flags, null)\n@@ -107,1 +108,1 @@\n-        DirectMethodBuilder builder = new DirectMethodBuilder(constantPool, method.methodName(),\n+        DirectMethodBuilder builder = new DirectMethodBuilder(constantPool, context, method.methodName(),\n@@ -144,1 +145,1 @@\n-    void setSizeHint(int sizeHint) {\n+    public void setSizeHint(int sizeHint) {\n@@ -169,2 +170,2 @@\n-        BufWriter head = new BufWriterImpl(constantPool, size);\n-        BufWriterImpl tail = new BufWriterImpl(constantPool, size, thisClassEntry, majorVersion);\n+        BufWriter head = new BufWriterImpl(constantPool, context, size);\n+        BufWriterImpl tail = new BufWriterImpl(constantPool, context, size, thisClassEntry, majorVersion);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.classfile.Instruction;\n@@ -90,0 +91,1 @@\n+    private boolean needsStackMap, ncf;\n@@ -104,0 +106,1 @@\n+                                                 ClassfileImpl context,\n@@ -107,1 +110,1 @@\n-            handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, original, false));\n+            handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, context, original, false));\n@@ -110,2 +113,2 @@\n-            if (constantPool.options().fixJumps) {\n-                handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, original, true));\n+            if (context.shortJumpsOption() == Classfile.ShortJumpsOption.FIX_SHORT_JUMPS) {\n+                handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, context, original, true));\n@@ -122,0 +125,1 @@\n+                              ClassfileImpl context,\n@@ -124,1 +128,1 @@\n-        super(constantPool);\n+        super(constantPool, context);\n@@ -128,3 +132,3 @@\n-        this.transformBackJumps = constantPool.options().fixJumps;\n-        bytecodesBufWriter = (original instanceof CodeImpl cai) ? new BufWriterImpl(constantPool, cai.codeLength())\n-                                                               : new BufWriterImpl(constantPool);\n+        this.transformBackJumps = context.shortJumpsOption() == Classfile.ShortJumpsOption.FIX_SHORT_JUMPS;\n+        bytecodesBufWriter = (original instanceof CodeImpl cai) ? new BufWriterImpl(constantPool, context, cai.codeLength())\n+                                                               : new BufWriterImpl(constantPool, context);\n@@ -136,0 +140,2 @@\n+        this.needsStackMap = false;\n+        this.ncf = false;\n@@ -141,0 +147,8 @@\n+        if (!needsStackMap && element instanceof Instruction i) {\n+            if (ncf) {\n+                needsStackMap = true;\n+            } else {\n+                var kind = i.opcode().kind();\n+                ncf = kind == Opcode.Kind.RETURN || kind == Opcode.Kind.THROW_EXCEPTION;\n+            }\n+        }\n@@ -199,1 +213,1 @@\n-                if (constantPool.options().filterDeadLabels) {\n+                if (context.deadLabelsOption() == Classfile.DeadLabelsOption.DROP_DEAD_LABELS) {\n@@ -223,1 +237,1 @@\n-        if (constantPool.options().processDebug) {\n+        if (context.debugElementsOption() == Classfile.DebugElementsOption.PASS_DEBUG) {\n@@ -236,1 +250,1 @@\n-                                if (constantPool.options().filterDeadLabels) {\n+                                if (context.deadLabelsOption() == Classfile.DeadLabelsOption.DROP_DEAD_LABELS) {\n@@ -265,1 +279,1 @@\n-                                if (constantPool.options().filterDeadLabels) {\n+                                if (context.deadLabelsOption() == Classfile.DeadLabelsOption.DROP_DEAD_LABELS) {\n@@ -288,1 +302,1 @@\n-                                if (constantPool.options().filterDeadLabels) {\n+                                if (context.deadLabelsOption() == Classfile.DeadLabelsOption.DROP_DEAD_LABELS) {\n@@ -308,0 +322,48 @@\n+\n+            private void writeCounters(boolean codeMatch, BufWriterImpl buf) {\n+                if (codeMatch) {\n+                    buf.writeU2(original.maxStack());\n+                    buf.writeU2(original.maxLocals());\n+                } else {\n+                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n+                    buf.writeU2(cntr.maxStack());\n+                    buf.writeU2(cntr.maxLocals());\n+                }\n+            }\n+\n+            private void generateStackMaps(BufWriterImpl buf) throws IllegalArgumentException {\n+                \/\/new instance of generator immediately calculates maxStack, maxLocals, all frames,\n+                \/\/ patches dead bytecode blocks and removes them from exception table\n+                StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n+                attributes.withAttribute(gen.stackMapTableAttribute());\n+                buf.writeU2(gen.maxStack());\n+                buf.writeU2(gen.maxLocals());\n+            }\n+\n+            private void tryGenerateStackMaps(boolean codeMatch, BufWriterImpl buf) {\n+                if (buf.getMajorVersion() >= Classfile.JAVA_6_VERSION) {\n+                    try {\n+                        generateStackMaps(buf);\n+                    } catch (IllegalArgumentException e) {\n+                        \/\/failover following JVMS-4.10\n+                        if (buf.getMajorVersion() == Classfile.JAVA_6_VERSION) {\n+                            writeCounters(codeMatch, buf);\n+                        } else {\n+                            throw e;\n+                        }\n+                    }\n+                } else {\n+                    writeCounters(codeMatch, buf);\n+                }\n+            }\n+\n+            private boolean writeOriginalAttribute(BufWriterImpl buf) {\n+                var stackMapAttr = original.findAttribute(Attributes.STACK_MAP_TABLE).orElse(null);\n+                if (stackMapAttr != null) {\n+                    attributes.withAttribute(stackMapAttr);\n+                    writeCounters(true, buf);\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n@@ -321,3 +383,0 @@\n-                int maxStack, maxLocals;\n-                Attribute<? extends StackMapTableAttribute> stackMapAttr;\n-                boolean canReuseStackmaps = codeAndExceptionsMatch(codeLength);\n@@ -325,28 +384,24 @@\n-                if (!constantPool.options().generateStackmaps) {\n-                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n-                    maxStack = cntr.maxStack();\n-                    maxLocals = cntr.maxLocals();\n-                    stackMapAttr = null;\n-                }\n-                else if (canReuseStackmaps) {\n-                    maxLocals = original.maxLocals();\n-                    maxStack = original.maxStack();\n-                    stackMapAttr = original.findAttribute(Attributes.STACK_MAP_TABLE).orElse(null);\n-                }\n-                else if (buf.getMajorVersion() >= Classfile.JAVA_6_VERSION) {\n-                    try {\n-                        \/\/new instance of generator immediately calculates maxStack, maxLocals, all frames,\n-                        \/\/ patches dead bytecode blocks and removes them from exception table\n-                        StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n-                        maxStack = gen.maxStack();\n-                        maxLocals = gen.maxLocals();\n-                        stackMapAttr = gen.stackMapTableAttribute();\n-                    } catch (IllegalArgumentException e) {\n-                        if (buf.getMajorVersion() == Classfile.JAVA_6_VERSION) {\n-                            \/\/failover following JVMS-4.10\n-                            StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n-                            maxStack = cntr.maxStack();\n-                            maxLocals = cntr.maxLocals();\n-                            stackMapAttr = null;\n-                        } else {\n-                            throw e;\n+                if (needsStackMap) {\n+                    if (codeAndExceptionsMatch(codeLength)) {\n+                        switch (context.stackMapsOption()) {\n+                            case STACK_MAPS_WHEN_REQUIRED -> {\n+                                if (!writeOriginalAttribute(buf)) {\n+                                    tryGenerateStackMaps(true, buf);\n+                                }\n+                            }\n+                            case STACK_MAPS_ALWAYS -> {\n+                                if (!writeOriginalAttribute(buf)) {\n+                                    generateStackMaps(buf);\n+                                }\n+                            }\n+                            case STACK_MAPS_NEVER ->\n+                                writeCounters(true, buf);\n+                        }\n+                    } else {\n+                        switch (context.stackMapsOption()) {\n+                            case STACK_MAPS_WHEN_REQUIRED ->\n+                                tryGenerateStackMaps(false, buf);\n+                            case STACK_MAPS_ALWAYS ->\n+                                generateStackMaps(buf);\n+                            case STACK_MAPS_NEVER ->\n+                                writeCounters(false, buf);\n@@ -355,0 +410,2 @@\n+                } else {\n+                    writeCounters(codeAndExceptionsMatch(codeLength), buf);\n@@ -356,8 +413,0 @@\n-                else {\n-                    StackCounter cntr = StackCounter.of(DirectCodeBuilder.this, buf);\n-                    maxStack = cntr.maxStack();\n-                    maxLocals = cntr.maxLocals();\n-                    stackMapAttr = null;\n-                }\n-\n-                attributes.withAttribute(stackMapAttr);\n@@ -365,2 +414,0 @@\n-                buf.writeU2(maxStack);\n-                buf.writeU2(maxLocals);\n@@ -380,1 +427,1 @@\n-        public DedupLineNumberTableAttribute(ConstantPoolBuilder constantPool) {\n+        public DedupLineNumberTableAttribute(ConstantPoolBuilder constantPool, ClassfileImpl context) {\n@@ -382,1 +429,1 @@\n-            buf = new BufWriterImpl(constantPool);\n+            buf = new BufWriterImpl(constantPool, context);\n@@ -427,1 +474,1 @@\n-                BufWriter bw = new BufWriterImpl(constantPool);\n+                BufWriter bw = new BufWriterImpl(constantPool, context);\n@@ -525,0 +572,1 @@\n+        needsStackMap = true;\n@@ -546,0 +594,1 @@\n+        needsStackMap = true;\n@@ -564,0 +613,1 @@\n+        needsStackMap = true;\n@@ -685,1 +735,1 @@\n-            lineNumberWriter = new DedupLineNumberTableAttribute(constantPool);\n+            lineNumberWriter = new DedupLineNumberTableAttribute(constantPool, context);\n@@ -739,0 +789,1 @@\n+        needsStackMap = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":108,"deletions":57,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+                              ClassfileImpl context,\n@@ -48,1 +49,1 @@\n-        super(constantPool);\n+        super(constantPool, context);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+                               ClassfileImpl context,\n@@ -57,1 +58,1 @@\n-        super(constantPool);\n+        super(constantPool, context);\n@@ -108,1 +109,1 @@\n-        return new BufferedCodeBuilder(this, constantPool, original);\n+        return new BufferedCodeBuilder(this, constantPool, context, original);\n@@ -119,1 +120,1 @@\n-        var cb = DirectCodeBuilder.build(this, handler, constantPool, original);\n+        var cb = DirectCodeBuilder.build(this, handler, constantPool, context, original);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.util.Collection;\n-import java.util.function.Function;\n-\n-import jdk.internal.classfile.AttributeMapper;\n-import jdk.internal.classfile.ClassHierarchyResolver;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n-\n-import static jdk.internal.classfile.ClassHierarchyResolver.defaultResolver;\n-\n-public class Options {\n-\n-    public enum Key {\n-        GENERATE_STACK_MAPS, PROCESS_DEBUG, PROCESS_LINE_NUMBERS, PROCESS_UNKNOWN_ATTRIBUTES,\n-        CP_SHARING, FIX_SHORT_JUMPS, PATCH_DEAD_CODE, HIERARCHY_RESOLVER, ATTRIBUTE_MAPPER,\n-        FILTER_DEAD_LABELS;\n-    }\n-\n-    public record OptionValue(Key key, Object value) implements Classfile.Option { }\n-\n-    public Boolean generateStackmaps = true;\n-    public Boolean processDebug = true;\n-    public Boolean processLineNumbers = true;\n-    public Boolean processUnknownAttributes = true;\n-    public Boolean cpSharing = true;\n-    public Boolean fixJumps = true;\n-    public Boolean patchCode = true;\n-    public Boolean filterDeadLabels = false;\n-    public ClassHierarchyResolver classHierarchyResolver = defaultResolver();\n-    public Function<Utf8Entry, AttributeMapper<?>> attributeMapper = new Function<>() {\n-        @Override\n-        public AttributeMapper<?> apply(Utf8Entry k) {\n-            return null;\n-        }\n-    };\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Options(Collection<Classfile.Option> options) {\n-        for (var o : options) {\n-            var ov = ((OptionValue)o);\n-            var v = ov.value();\n-            switch (ov.key()) {\n-                case GENERATE_STACK_MAPS -> generateStackmaps = (Boolean) v;\n-                case PROCESS_DEBUG -> processDebug = (Boolean) v;\n-                case PROCESS_LINE_NUMBERS -> processLineNumbers = (Boolean) v;\n-                case PROCESS_UNKNOWN_ATTRIBUTES -> processUnknownAttributes = (Boolean) v;\n-                case CP_SHARING -> cpSharing = (Boolean) v;\n-                case FIX_SHORT_JUMPS -> fixJumps = (Boolean) v;\n-                case PATCH_DEAD_CODE -> patchCode = (Boolean) v;\n-                case HIERARCHY_RESOLVER -> classHierarchyResolver = (ClassHierarchyResolver) v;\n-                case ATTRIBUTE_MAPPER -> attributeMapper = (Function<Utf8Entry, AttributeMapper<?>>) v;\n-                case FILTER_DEAD_LABELS -> filterDeadLabels = (Boolean) v;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Options.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collections;\n@@ -84,1 +83,0 @@\n-    final Options options;\n@@ -94,4 +92,0 @@\n-        this(new Options(Collections.emptyList()));\n-    }\n-\n-    public SplitConstantPool(Options options) {\n@@ -105,1 +99,0 @@\n-        this.options = options;\n@@ -110,1 +103,0 @@\n-        this.options = ((ClassReaderImpl) parent).options;\n@@ -120,12 +112,0 @@\n-    \/\/clone constructor for internal purposes\n-    SplitConstantPool(SplitConstantPool cloneFrom, Options options) {\n-        this.options = options;\n-        this.parent = cloneFrom.parent;\n-        this.parentSize = cloneFrom.parentSize;\n-        this.parentBsmSize = cloneFrom.parentBsmSize;\n-        this.size = cloneFrom.size;\n-        this.bsmSize = cloneFrom.bsmSize;\n-        this.myEntries = Arrays.copyOf(cloneFrom.myEntries, cloneFrom.myEntries.length);\n-        this.myBsmEntries = Arrays.copyOf(cloneFrom.myBsmEntries, cloneFrom.myBsmEntries.length);\n-    }\n-\n@@ -156,4 +136,0 @@\n-    public Options options() {\n-        return options;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+                dcb.context,\n@@ -197,0 +198,1 @@\n+    private final boolean filterDeadLabels;\n@@ -224,0 +226,1 @@\n+                     ClassfileImpl context,\n@@ -234,2 +237,3 @@\n-        this.classHierarchy = new ClassHierarchyImpl(cp.options().classHierarchyResolver);\n-        this.patchDeadCode = cp.options().patchCode;\n+        this.classHierarchy = new ClassHierarchyImpl(context.classHierarchyResolverOption().classHierarchyResolver());\n+        this.patchDeadCode = context.deadCodeOption() == Classfile.DeadCodeOption.PATCH_DEAD_CODE;\n+        this.filterDeadLabels = context.deadLabelsOption() == Classfile.DeadLabelsOption.DROP_DEAD_LABELS;\n@@ -835,16 +839,15 @@\n-            \/\/clone SplitConstantPool with alternate Options\n-            var newCp = new SplitConstantPool(cp, new Options(List.of(Classfile.Option.generateStackmap(false))));\n-            var clb = new DirectClassBuilder(newCp, newCp.classEntry(ClassDesc.of(\"FakeClass\")));\n-            clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n-                    ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n-                        @Override\n-                        public void writeBody(BufWriter b) {\n-                            b.writeU2(-1);\/\/max stack\n-                            b.writeU2(-1);\/\/max locals\n-                            b.writeInt(bytecode.limit());\n-                            b.writeBytes(bytecode.array(), 0, bytecode.limit());\n-                            b.writeU2(0);\/\/exception handlers\n-                            b.writeU2(0);\/\/attributes\n-                        }\n-                    }));\n-            ClassPrinter.toYaml(Classfile.parse(clb.build()).methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n+            var cc = Classfile.of();\n+            var clm = cc.parse(cc.build(cp.classEntry(thisType.sym()), cp, clb ->\n+                    clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n+                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                                @Override\n+                                public void writeBody(BufWriter b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(bytecode.limit());\n+                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }\n+                    }))));\n+            ClassPrinter.toYaml(clm.methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n@@ -934,1 +937,1 @@\n-            if (!cp.options().filterDeadLabels)\n+            if (!filterDeadLabels)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        return verify(classModel, ClassHierarchyResolver.defaultResolver(), logger);\n+        return verify(classModel, ClassHierarchyResolver.ofSystem(), logger);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * the setting of the {@link Classfile.Option#processDebug(boolean)} option.\n+ * the setting of the {@link Classfile.DebugElementsOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/CharacterRange.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * the setting of the {@link Classfile.Option#processLineNumbers(boolean)} option.\n+ * the setting of the {@link Classfile.LineNumbersOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LineNumber.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * the setting of the {@link Classfile.Option#processDebug(boolean)} option.\n+ * the setting of the {@link Classfile.DebugElementsOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LocalVariable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * the {@link Classfile.Option#processDebug(boolean)} option.\n+ * the {@link Classfile.DebugElementsOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LocalVariableType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * jdk.internal.classfile.Classfile#parse(byte[], jdk.internal.classfile.Classfile.Option[])}:\n+ * jdk.internal.classfile.Classfile#parse(byte[])}:\n@@ -39,1 +39,1 @@\n- * ClassModel cm = Classfile.parse(bytes);\n+ * ClassModel cm = Classfile.of().parse(bytes);\n@@ -167,1 +167,1 @@\n- * jdk.internal.classfile.Classfile.Option#attributeMapper(java.util.function.Function)}}\n+ * jdk.internal.classfile.Classfile.AttributeMapperOption#of(java.util.function.Function)}}\n@@ -173,3 +173,3 @@\n- * {@link jdk.internal.classfile.Classfile#parse(byte[], jdk.internal.classfile.Classfile.Option[])}\n- * accepts a list of options.  {@link jdk.internal.classfile.Classfile.Option} exports some\n- * static boolean options, as well as factories for more complex options,\n+ * {@link jdk.internal.classfile.Classfile#of(jdk.internal.classfile.Classfile.Option[])}\n+ * accepts a list of options.  {@link jdk.internal.classfile.Classfile.Option} is a base interface\n+ * for some statically enumerated options, as well as factories for more complex options,\n@@ -178,14 +178,13 @@\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#generateStackmap(boolean)}\n- * -- generate stackmaps (default is true)<\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#processDebug(boolean)}\n- * -- processing of debug information, such as local variable metadata (default is true) <\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)}\n- * -- processing of line numbers (default is true) <\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#processUnknownAttributes(boolean)}\n- * -- processing of unrecognized attributes (default is true)<\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#constantPoolSharing(boolean)}}\n- * -- share constant pool when transforming (default is true)<\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#classHierarchyResolver(jdk.internal.classfile.ClassHierarchyResolver)}\n- * -- specify a custom class hierarchy\n- * resolver used by stack map generation<\/li>\n- *   <li>{@link jdk.internal.classfile.Classfile.Option#attributeMapper(java.util.function.Function)}\n+ *   <li>{@link jdk.internal.classfile.Classfile.StackMapsOption}\n+ * -- generate stackmaps (default is {@code STACK_MAPS_WHEN_REQUIRED})<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.DebugElementsOption}\n+ * -- processing of debug information, such as local variable metadata (default is {@code PASS_DEBUG}) <\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.LineNumbersOption}\n+ * -- processing of line numbers (default is {@code PASS_LINE_NUMBERS}) <\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.UnknownAttributesOption}\n+ * -- processing of unrecognized attributes (default is {@code PASS_UNKNOWN_ATTRIBUTES})<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.ConstantPoolSharingOption}}\n+ * -- share constant pool when transforming (default is {@code SHARED_POOL})<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.ClassHierarchyResolverOption#of(jdk.internal.classfile.ClassHierarchyResolver)}\n+ * -- specify a custom class hierarchy resolver used by stack map generation<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.AttributeMapperOption#of(java.util.function.Function)}\n@@ -307,1 +306,2 @@\n- * byte[] newBytes = Classfile.parse(bytes).transform(ct);\n+ * var cc = Classfile.of();\n+ * byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n@@ -325,4 +325,5 @@\n- * byte[] newBytes = Classfile.parse(bytes)\n- *                             .transform(ClassTransform.transformingMethods(\n- *                                 MethodTransform.transformingCode(\n- *                                     fooToBar.andThen(instrumentCalls))));\n+ * var cc = Classfile.of();\n+ * byte[] newBytes = cc.transform(cc.parse(bytes),\n+ *                                ClassTransform.transformingMethods(\n+ *                                    MethodTransform.transformingCode(\n+ *                                        fooToBar.andThen(instrumentCalls))));\n@@ -344,1 +345,1 @@\n- * with the {@link jdk.internal.classfile.Classfile.Option#constantPoolSharing(boolean)} option.\n+ * with the {@link jdk.internal.classfile.Classfile.ConstantPoolSharingOption} option.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/package-info.java","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.ArrayDeque;\n@@ -65,1 +66,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = Classfile.of().parse(bytes);\n@@ -75,1 +76,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = Classfile.of().parse(bytes);\n@@ -88,1 +89,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = Classfile.of().parse(bytes);\n@@ -111,1 +112,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = Classfile.of().parse(bytes);\n@@ -129,1 +130,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Hello\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Hello\"), cb -> {\n@@ -155,2 +156,2 @@\n-        ClassModel classModel = Classfile.parse(bytes);\n-        byte[] newBytes = Classfile.build(classModel.thisClass().asSymbol(),\n+        ClassModel classModel = Classfile.of().parse(bytes);\n+        byte[] newBytes = Classfile.of().build(classModel.thisClass().asSymbol(),\n@@ -173,1 +174,2 @@\n-        byte[] newBytes = Classfile.parse(bytes).transform(ct);\n+        var cc = Classfile.of();\n+        byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n@@ -205,1 +207,1 @@\n-        byte[] newBytes = Classfile.build(classModel.thisClass().asSymbol(),\n+        byte[] newBytes = Classfile.of().build(classModel.thisClass().asSymbol(),\n@@ -237,1 +239,1 @@\n-        byte[] newBytes = classModel.transform(\n+        byte[] newBytes = Classfile.of().transform(classModel,\n@@ -247,1 +249,1 @@\n-                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElse(null)));\n+                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElseThrow()));\n@@ -251,1 +253,1 @@\n-        return target.transform(\n+        return Classfile.of().transform(target,\n@@ -269,1 +271,1 @@\n-                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                var storeStack = new ArrayDeque<StoreInstruction>();\n@@ -272,1 +274,1 @@\n-                                                    storeStack.add(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n@@ -275,1 +277,1 @@\n-                                                    storeStack.addFirst(StoreInstruction.of(tk, slot));\n+                                                    storeStack.push(StoreInstruction.of(tk, slot));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.ofInternalName(className), clb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.ofInternalName(className), clb -> {\n@@ -210,1 +210,1 @@\n-            List<VerifyError> errors = Classfile.parse(bytes).verify(null);\n+            List<VerifyError> errors = Classfile.of().parse(bytes).verify(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,1 +153,2 @@\n-        var cm = Classfile.parse(in.readAllBytes());\n+        var cc = Classfile.of();\n+        var cm = cc.parse(in.readAllBytes());\n@@ -155,1 +156,1 @@\n-        return cm.transform(ClassTransform.endHandler(clb -> {\n+        return cc.transform(cm, ClassTransform.endHandler(clb -> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-        var cm = Classfile.parse(bytes);\n+        var cm = Classfile.of().parse(bytes);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-                Classfile.parse(bytes).forEachElement(cle -> {\n+                Classfile.of().parse(bytes).forEachElement(cle -> {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jimage\/JImageTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-            return Classfile.parse(content, options);\n+            return Classfile.of(options).parse(content);\n@@ -105,1 +105,1 @@\n-            return Classfile.parse(buf, options);\n+            return Classfile.of(options).parse(buf);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AbstractPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,3 +67,4 @@\n-                        byte[] content = newClassReader(path, resource,\n-                                Classfile.Option.processDebug(false),\n-                                Classfile.Option.processLineNumbers(false)).transform(ClassTransform\n+                        var clm = newClassReader(path, resource,\n+                                Classfile.DebugElementsOption.DROP_DEBUG,\n+                                Classfile.LineNumbersOption.DROP_LINE_NUMBERS);\n+                        byte[] content = Classfile.of().transform(clm, ClassTransform\n@@ -71,5 +72,5 @@\n-                                                      || cle instanceof SourceDebugExtensionAttribute)\n-                                        .andThen(ClassTransform.transformingMethods(MethodTransform\n-                                                .dropping(me -> me instanceof MethodParametersAttribute)\n-                                                .andThen(MethodTransform\n-                                                        .transformingCode(CodeTransform.ACCEPT_ALL)))));\n+                                                            || cle instanceof SourceDebugExtensionAttribute)\n+                                              .andThen(ClassTransform.transformingMethods(MethodTransform\n+                                                    .dropping(me -> me instanceof MethodParametersAttribute)\n+                                                    .andThen(MethodTransform\n+                                                            .transformingCode(CodeTransform.ACCEPT_ALL)))));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-                return Classfile.parse(in.readAllBytes()).elementStream()\n+                return Classfile.of().parse(in.readAllBytes()).elementStream()\n@@ -582,1 +582,1 @@\n-            return Classfile.build(classDesc,\n+            return Classfile.of().build(classDesc,\n@@ -1679,1 +1679,1 @@\n-        ResourcePoolEntry e = ResourcePoolEntry.create(rn, Classfile.build(\n+        ResourcePoolEntry e = ResourcePoolEntry.create(rn, Classfile.of().build(\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -102,1 +103,2 @@\n-        return newClassReader(path, classFile).transform(ClassTransform.transformingMethodBodies(\n+        return Classfile.of().transform(newClassReader(path, classFile),\n+            ClassTransform.transformingMethodBodies(\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,2 +83,3 @@\n-        return Classfile.parse(classFile)\n-                        .transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        var cc = Classfile.of();\n+        return cc.transform(cc.parse(classFile),\n+                        ClassTransform.transformingMethodBodies((cob, coe) -> {\n@@ -92,1 +93,1 @@\n-        return new ClassBytecodes(CANCEL_CLASS, Classfile.build(CD_Cancel, clb ->\n+        return new ClassBytecodes(CANCEL_CLASS, Classfile.of().build(CD_Cancel, clb ->\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1374,1 +1374,1 @@\n-        ByteBuffer bb = ByteBuffer.wrap(Classfile.buildModule(\n+        ByteBuffer bb = ByteBuffer.wrap(Classfile.of().buildModule(\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-        ClassModel cm = Classfile.parse(testClassPath);\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(testClassPath);\n@@ -63,1 +64,1 @@\n-            byte[] newBytes = cm.transform(t);\n+            byte[] newBytes = cc.transform(cm, t);\n@@ -80,1 +81,2 @@\n-        ClassModel cm = Classfile.parse(fs.getPath(path));\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(fs.getPath(path));\n@@ -82,1 +84,1 @@\n-            byte[] newBytes = cm.transform(t);\n+            byte[] newBytes = cc.transform(cm, t);\n@@ -88,1 +90,2 @@\n-        ClassModel cm = Classfile.parse(testClassPath);\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(testClassPath);\n@@ -103,1 +106,1 @@\n-        byte[] newBytes = cm.transform(transform);\n+        byte[] newBytes = cc.transform(cm, transform);\n@@ -114,2 +117,3 @@\n-        ClassModel cm = Classfile.parse(testClassPath);\n-        byte[] newBytes = Classfile.build(cm.thisClass().asSymbol(), cb -> cm.forEachElement(cb));\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(testClassPath);\n+        byte[] newBytes = cc.build(cm.thisClass().asSymbol(), cb -> cm.forEachElement(cb));\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,2 +78,3 @@\n-            var clm = Classfile.parse(in.readAllBytes());\n-            var remapped = Classfile.parse(clm.transform((clb, cle) -> {\n+            var cc = Classfile.of();\n+            var clm = cc.parse(in.readAllBytes());\n+            var remapped = cc.parse(cc.transform(clm, (clb, cle) -> {\n@@ -116,2 +117,3 @@\n-            var clm = Classfile.parse(in.readAllBytes());\n-            var remapped = Classfile.parse(ClassRemapper.of(map).remapClass(clm));\n+            var cc = Classfile.of();\n+            var clm = cc.parse(in.readAllBytes());\n+            var remapped = cc.parse(ClassRemapper.of(map).remapClass(cc, clm));\n@@ -122,1 +124,1 @@\n-                                          .orElse(ClassHierarchyResolver.defaultResolver())\n+                                          .orElse(ClassHierarchyResolver.ofSystem())\n@@ -170,2 +172,2 @@\n-\n-        var ma = Classfile.parse(\n+        var cc = Classfile.of();\n+        var ma = cc.parse(\n@@ -173,2 +175,3 @@\n-                        Classfile.parse(\n-                                Classfile.buildModule(\n+                        cc,\n+                        cc.parse(\n+                                cc.buildModule(\n@@ -190,2 +193,2 @@\n-\n-        var remapped = Classfile.parse(\n+        var cc = Classfile.of();\n+        var remapped = cc.parse(\n@@ -193,1 +196,2 @@\n-                        Classfile.parse(\n+                        cc,\n+                        cc.parse(\n@@ -236,2 +240,3 @@\n-        var instrumentor = Classfile.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$InstrumentorClass.class\").readAllBytes());\n-        var target = Classfile.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$TargetClass.class\").readAllBytes());\n+        var cc = Classfile.of();\n+        var instrumentor = cc.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$InstrumentorClass.class\").readAllBytes());\n+        var target = cc.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$TargetClass.class\").readAllBytes());\n@@ -239,1 +244,1 @@\n-        assertEmpty(Classfile.parse(instrumentedBytes).verify(null)); \/\/System.out::print));\n+        assertEmpty(cc.parse(instrumentedBytes).verify(null)); \/\/System.out::print));\n@@ -300,1 +305,1 @@\n-        return target.transform(\n+        return Classfile.of().transform(target,\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        var model = Classfile.parse(fileBytes);\n+        var model = Classfile.of().parse(fileBytes);\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationModelTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -135,1 +136,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = cc.parse(bytes);\n@@ -175,1 +176,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -180,1 +182,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = cc.parse(bytes);\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        ClassModel cm = Classfile.parse(testClassPath);\n+        ClassModel cm = Classfile.of().parse(testClassPath);\n","filename":"test\/jdk\/jdk\/classfile\/ArrayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-        ClassModel cm = Classfile.parse(testClassPath);\n-        byte[] newBytes = cm.transform((cb, ce) -> {\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(testClassPath);\n+        byte[] newBytes = cc.transform(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,2 +60,3 @@\n-            var classModel = Classfile.parse(in.readAllBytes());\n-            Classfile.build(classModel.thisClass().asSymbol(), cb -> classModel.forEachElement(cb));\n+            var cc = Classfile.of();\n+            var classModel = cc.parse(in.readAllBytes());\n+            cc.build(classModel.thisClass().asSymbol(), cb -> classModel.forEachElement(cb));\n","filename":"test\/jdk\/jdk\/classfile\/BasicBlockTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+        var cc = Classfile.of();\n@@ -56,1 +57,1 @@\n-        byte[] raw = Classfile.build(ClassDesc.of(\"TestClass\"), builder -> {\n+        byte[] raw = cc.build(ClassDesc.of(\"TestClass\"), builder -> {\n@@ -63,1 +64,1 @@\n-        ClassModel model = Classfile.parse(raw);\n+        ClassModel model = cc.parse(raw);\n","filename":"test\/jdk\/jdk\/classfile\/BoundAttributeTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -83,1 +83,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -106,1 +106,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -125,1 +125,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -143,1 +143,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -163,1 +163,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -183,1 +183,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -202,1 +202,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -227,1 +227,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -248,1 +248,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -265,1 +265,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -286,1 +286,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        var cc = Classfile.of();\n+        cc.build(ClassDesc.of(\"Foo\"), cb -> {\n@@ -58,2 +58,1 @@\n-\n-        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+        cc.build(ClassDesc.of(\"Foo\"), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderParamTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-        boolean anyGotos = Classfile.parse(bytes).methods().stream()\n+        boolean anyGotos = Classfile.of().parse(bytes).methods().stream()\n@@ -185,1 +185,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"C\"), cb -> {\n@@ -216,1 +216,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"C\"), cb -> {\n@@ -279,1 +279,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"C\"), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+        var cc = Classfile.of();\n@@ -54,1 +55,1 @@\n-            cm = Classfile.parse(Objects.requireNonNull(in).readAllBytes());\n+            cm = cc.parse(Objects.requireNonNull(in).readAllBytes());\n@@ -63,1 +64,1 @@\n-        MethodHandles.lookup().defineClass(cm.transform(transform));\n+        MethodHandles.lookup().defineClass(cc.transform(cm, transform));\n","filename":"test\/jdk\/jdk\/classfile\/ClassBuildingTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.defaultResolver()))\n+                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.ofSystem()))\n@@ -131,2 +131,2 @@\n-        var classModel = Classfile.parse(path, Classfile.Option.classHierarchyResolver(res));\n-        byte[] newBytes = classModel.transform(\n+        var classModel = Classfile.of().parse(path);\n+        byte[] newBytes = Classfile.of(Classfile.ClassHierarchyResolverOption.of(res)).transform(classModel,\n@@ -146,1 +146,1 @@\n-        var errors = Classfile.parse(newBytes).verify(null);\n+        var errors = Classfile.of().parse(newBytes).verify(null);\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-        return Classfile.parse(Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+        var cc = Classfile.of();\n+        return cc.parse(cc.build(ClassDesc.of(\"Foo\"), clb ->\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+            var cc = Classfile.of();\n@@ -80,1 +81,1 @@\n-                    .map(bytes -> Classfile.parse(bytes))\n+                    .map(bytes -> cc.parse(bytes))\n","filename":"test\/jdk\/jdk\/classfile\/ConstantPoolCopyTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,2 @@\n-        Files.write(root.resolve(targetClassFile), Classfile.parse(root.resolve(sourceClassFile)).transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+        var cc = Classfile.of();\n+        Files.write(root.resolve(targetClassFile), cc.transform(cc.parse(root.resolve(sourceClassFile)), ClassTransform.transformingMethodBodies((cob, coe) -> {\n@@ -148,2 +149,2 @@\n-                                     ? Classfile.parse(bytes, Classfile.Option.generateStackmap(false))\n-                                                .transform(m.classTransform)\n+                                     ? Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER)\n+                                                .transform(Classfile.of().parse(bytes), m.classTransform)\n@@ -199,2 +200,2 @@\n-\n-        var classModel = Classfile.parse(bytes);\n+        var cc = Classfile.of();\n+        var classModel = cc.parse(bytes);\n@@ -204,1 +205,1 @@\n-        byte[] newBytes = Classfile.build(\n+        byte[] newBytes = cc.build(\n@@ -207,1 +208,1 @@\n-        var newModel = Classfile.parse(newBytes, Classfile.Option.generateStackmap(false));\n+        var newModel = cc.parse(newBytes);\n@@ -215,2 +216,4 @@\n-        byte[] noStackMaps = newModel.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n-        var noStackModel = Classfile.parse(noStackMaps);\n+        byte[] noStackMaps = Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER)\n+                                      .transform(newModel,\n+                                                         ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        var noStackModel = cc.parse(noStackMaps);\n@@ -246,2 +249,3 @@\n-        var cp1 = Classfile.parse(orig).constantPool();\n-        var cp2 = Classfile.parse(transformed).constantPool();\n+        var cc = Classfile.of();\n+        var cp1 = cc.parse(orig).constantPool();\n+        var cp2 = cc.parse(transformed).constantPool();\n@@ -270,1 +274,1 @@\n-        var cf = Classfile.parse(bytes);\n+        var cf = Classfile.of().parse(bytes);\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-        var bytes = Classfile.build(ClassDesc.of(testClass), clb -> clb\n+        var cc = Classfile.of();\n+        var bytes = cc.build(ClassDesc.of(testClass), clb -> clb\n@@ -67,1 +68,1 @@\n-        var c = Classfile.parse(bytes).methods().get(0).code().get();\n+        var c = cc.parse(bytes).methods().get(0).code().get();\n@@ -78,1 +79,1 @@\n-        bytes = Classfile.parse(bytes).transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n+        bytes = cc.transform(cc.parse(bytes), ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL));\n@@ -85,1 +86,1 @@\n-        var clm = Classfile.parse(bytes);\n+        var clm = cc.parse(bytes);\n@@ -88,2 +89,2 @@\n-        clm.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n-                   .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_6_VERSION, 0))));\n+        cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                 .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_6_VERSION, 0))));\n@@ -91,1 +92,1 @@\n-        \/\/test failure of stack map generation\n+        \/\/test failure of stack map generation for Java 7\n@@ -93,2 +94,7 @@\n-                clm.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n-                   .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_7_VERSION, 0)))));\n+                cc.transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                         .andThen(ClassTransform.endHandler(clb -> clb.withVersion(JAVA_7_VERSION, 0)))));\n+\n+        \/\/test failure of stack map generation when enforced to generate\n+        assertThrows(IllegalArgumentException.class, () ->\n+                Classfile.of(Classfile.StackMapsOption.STACK_MAPS_ALWAYS)\n+                         .transform(clm, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-        var code = Classfile.parse(Classfile.build(ClassDesc.of(\"cls\"), List.of(Classfile.Option.filterDeadLabels(true)), clb ->\n+        var cc = Classfile.of(Classfile.DeadLabelsOption.DROP_DEAD_LABELS);\n+        var code = cc.parse(cc.build(ClassDesc.of(\"cls\"), clb ->\n@@ -78,1 +79,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> Classfile.build(ClassDesc.of(\"cls\"), clb ->\n+        assertThrows(IllegalArgumentException.class, () -> Classfile.of().build(ClassDesc.of(\"cls\"), clb ->\n","filename":"test\/jdk\/jdk\/classfile\/FilterDeadLabelsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -78,1 +79,1 @@\n-        var model = Classfile.parse(bytes);\n+        var model = cc.parse(bytes);\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        Classfile.build(ClassDesc.of(\"BigClass\"), cb -> {\n+        Classfile.of().build(ClassDesc.of(\"BigClass\"), cb -> {\n@@ -51,1 +51,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> Classfile.build(ClassDesc.of(\"BigClass\"), cb -> {\n+        assertThrows(IllegalArgumentException.class, () -> Classfile.of().build(ClassDesc.of(\"BigClass\"), cb -> {\n@@ -60,1 +60,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> Classfile.build(ClassDesc.of(\"BigClass\"), cb -> cb.withMethodBody(\n+        assertThrows(IllegalArgumentException.class, () -> Classfile.of().build(ClassDesc.of(\"BigClass\"), cb -> cb.withMethodBody(\n@@ -71,1 +71,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> Classfile.build(ClassDesc.of(\"EmptyClass\"), cb -> cb.withMethodBody(\n+        assertThrows(IllegalArgumentException.class, () -> Classfile.of().build(ClassDesc.of(\"EmptyClass\"), cb -> cb.withMethodBody(\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,2 @@\n-        ClassModel cl = Classfile.parse(Paths.get(URI.create(LowAdaptTest.class.getResource(test + \".class\").toString())));\n+        var cc = Classfile.of();\n+        ClassModel cl = cc.parse(Paths.get(URI.create(LowAdaptTest.class.getResource(test + \".class\").toString())));\n@@ -76,1 +77,1 @@\n-        byte[] clazz = Classfile.build(ClassDesc.of(test), cb -> {\n+        byte[] clazz = cc.build(ClassDesc.of(test), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/LowAdaptTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        this.classLow = Classfile.parse(path);\n+        this.classLow = Classfile.of().parse(path);\n","filename":"test\/jdk\/jdk\/classfile\/LowJCovAttributeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            ClassModel classLow = Classfile.parse(path);\n+            ClassModel classLow = Classfile.of().parse(path);\n","filename":"test\/jdk\/jdk\/classfile\/LowModuleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        ClassModel c = Classfile.parse(fileBytes);\n+        ClassModel c = Classfile.of().parse(fileBytes);\n@@ -109,1 +109,2 @@\n-        ClassModel c = Classfile.parse(fileBytes);\n+        var cc = Classfile.of();\n+        ClassModel c = cc.parse(fileBytes);\n@@ -112,3 +113,3 @@\n-        byte[] newClass = c.transform(Transforms.threeLevelNoop);\n-        ClassRecord orig = ClassRecord.ofClassModel(Classfile.parse(fileBytes), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n-        ClassRecord transformed = ClassRecord.ofClassModel(Classfile.parse(newClass), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n+        byte[] newClass = cc.transform(c, Transforms.threeLevelNoop);\n+        ClassRecord orig = ClassRecord.ofClassModel(cc.parse(fileBytes), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n+        ClassRecord transformed = ClassRecord.ofClassModel(cc.parse(newClass), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n@@ -120,1 +121,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -175,1 +177,1 @@\n-        var c = Classfile.parse(bytes);\n+        var c = cc.parse(bytes);\n@@ -192,1 +194,1 @@\n-        ClassModel c = Classfile.parse(fileBytes);\n+        ClassModel c = Classfile.of().parse(fileBytes);\n@@ -232,1 +234,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -278,1 +281,1 @@\n-        var c = Classfile.parse(bytes);\n+        var c = cc.parse(bytes);\n@@ -304,1 +307,1 @@\n-        ClassModel c = Classfile.parse(fileBytes, Classfile.Option.processDebug(false));\n+        ClassModel c = Classfile.of(Classfile.DebugElementsOption.DROP_DEBUG).parse(fileBytes);\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        byte[] newBytes = adaptCopy(Classfile.parse(bytes));\n+        byte[] newBytes = adaptCopy(Classfile.of().parse(bytes));\n@@ -85,1 +85,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyCodeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,2 @@\n-        ClassModel cm =(Classfile.parse(bytes));\n+        var cc = Classfile.of();\n+        ClassModel cm =cc.parse(bytes);\n@@ -103,1 +104,1 @@\n-                cm.transform((cb, e) -> {\n+                cc.transform(cm, (cb, e) -> {\n@@ -128,1 +129,1 @@\n-        ClassModel rcm = Classfile.parse(resultBytes);\n+        ClassModel rcm = cc.parse(resultBytes);\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-        byte[] modInfo = Classfile.buildModule(\n+        var cc = Classfile.of();\n+        byte[] modInfo = cc.buildModule(\n@@ -91,1 +92,1 @@\n-        moduleModel = Classfile.parse(modInfo);\n+        moduleModel = cc.parse(modInfo);\n@@ -101,1 +102,2 @@\n-        byte[] modBytes = Classfile.buildModule(ModuleAttribute.of(modName, mb -> mb.moduleVersion(modVsn)));\n+        var cc = Classfile.of();\n+        byte[] modBytes = cc.buildModule(ModuleAttribute.of(modName, mb -> mb.moduleVersion(modVsn)));\n@@ -104,1 +106,1 @@\n-        var cm = Classfile.parse(modBytes);\n+        var cm = cc.parse(modBytes);\n@@ -198,1 +200,1 @@\n-        ClassModel m = Classfile.parse(Paths.get(URI.create(ModuleBuilderTest.class.getResource(\"ModuleBuilderTest.class\").toString())));\n+        ClassModel m = Classfile.of().parse(Paths.get(URI.create(ModuleBuilderTest.class.getResource(\"ModuleBuilderTest.class\").toString())));\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -110,1 +110,1 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        ClassModel cm = cc.parse(bytes);\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        Classfile.build(ClassDesc.of(\"MyClass\"),\n+        Classfile.of().build(ClassDesc.of(\"MyClass\"),\n@@ -125,1 +125,1 @@\n-        Classfile.build(ClassDesc.of(\"MyClass\"),\n+        Classfile.of().build(ClassDesc.of(\"MyClass\"),\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        Class<?> a = lookup.defineClass(Classfile.build(ape, clb -> {\n+        Class<?> a = lookup.defineClass(Classfile.of().build(ape, clb -> {\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.classfile.ClassModel;\n@@ -102,0 +103,5 @@\n+    static final Classfile\n+            CC_Fixed_Jumps = Classfile.of(Classfile.ShortJumpsOption.FIX_SHORT_JUMPS),\n+            CC_Not_Fixed_Jumps = Classfile.of(Classfile.ShortJumpsOption.FAIL_ON_SHORT_JUMPS),\n+            CC_No_Stack_No_Patch = Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER,\n+                                                        Classfile.DeadCodeOption.KEEP_DEAD_CODE);\n@@ -106,1 +112,2 @@\n-        assertFixed(sample, generateFwd(sample, true, Classfile.Option.fixShortJumps(true)));\n+        assertFixed(sample,\n+                    generateFwd(CC_Fixed_Jumps, sample, true));\n@@ -112,1 +119,2 @@\n-        assertFixed(sample, generateBack(sample, true, Classfile.Option.fixShortJumps(true)));\n+        assertFixed(sample,\n+                    generateBack(CC_Fixed_Jumps, sample, true));\n@@ -118,1 +126,2 @@\n-        assertThrows(IllegalArgumentException.class, () -> generateFwd(sample, true, Classfile.Option.fixShortJumps(false)));\n+        assertThrows(IllegalArgumentException.class, () ->\n+                     generateFwd(CC_Not_Fixed_Jumps, sample, true));\n@@ -124,1 +133,2 @@\n-        assertThrows(IllegalArgumentException.class, () -> generateBack(sample, true, Classfile.Option.fixShortJumps(false)));\n+        assertThrows(IllegalArgumentException.class, () ->\n+                     generateBack(CC_Not_Fixed_Jumps, sample, true));\n@@ -130,4 +140,4 @@\n-        assertFixed(sample, Classfile.parse(\n-                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(true))\n-                .transform(overflow()));\n+        assertFixed(sample,\n+                    CC_Fixed_Jumps.transform(\n+                            generateFwd(CC_No_Stack_No_Patch, sample, false),\n+                            overflow()));\n@@ -139,4 +149,4 @@\n-        assertFixed(sample, Classfile.parse(\n-                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(true))\n-                .transform(overflow()));\n+        assertFixed(sample,\n+                    CC_Fixed_Jumps.transform(\n+                            generateBack(CC_No_Stack_No_Patch, sample, false),\n+                            overflow()));\n@@ -149,4 +159,3 @@\n-        Classfile.parse(\n-                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(false))\n-                .transform(overflow()));\n+                     CC_Not_Fixed_Jumps.transform(\n+                            generateFwd(CC_No_Stack_No_Patch, sample, false),\n+                            overflow()));\n@@ -159,4 +168,3 @@\n-        Classfile.parse(\n-                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(false))\n-                .transform(overflow()));\n+                     CC_Not_Fixed_Jumps.transform(\n+                            generateBack(CC_No_Stack_No_Patch, sample, false),\n+                            overflow()));\n@@ -168,4 +176,4 @@\n-        assertFixed(sample, Classfile.parse(\n-                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(true))\n-                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+        assertFixed(sample,\n+                    CC_Fixed_Jumps.transform(\n+                            generateFwd(CC_No_Stack_No_Patch, sample, false),\n+                            ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n@@ -177,4 +185,4 @@\n-        assertFixed(sample, Classfile.parse(\n-                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(true))\n-                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+        assertFixed(sample,\n+                    CC_Fixed_Jumps.transform(\n+                            generateBack(CC_No_Stack_No_Patch, sample, false),\n+                            ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n@@ -187,4 +195,3 @@\n-        Classfile.parse(\n-                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(false))\n-                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+                     CC_Not_Fixed_Jumps.transform(\n+                            generateFwd(CC_No_Stack_No_Patch, sample, false),\n+                            ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n@@ -197,4 +204,3 @@\n-        Classfile.parse(\n-                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n-                Classfile.Option.fixShortJumps(false))\n-                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+                     CC_Not_Fixed_Jumps.transform(\n+                            generateBack(CC_No_Stack_No_Patch, sample, false),\n+                            ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n@@ -203,2 +209,2 @@\n-    private static byte[] generateFwd(Sample sample, boolean overflow, Classfile.Option... options) {\n-        return Classfile.build(ClassDesc.of(\"WhateverClass\"), List.of(options),\n+    private static ClassModel generateFwd(Classfile cc, Sample sample, boolean overflow) {\n+        return cc.parse(cc.build(ClassDesc.of(\"WhateverClass\"),\n@@ -215,1 +221,1 @@\n-                                })));\n+                                }))));\n@@ -218,2 +224,2 @@\n-    private static byte[] generateBack(Sample sample, boolean overflow, Classfile.Option... options) {\n-        return Classfile.build(ClassDesc.of(\"WhateverClass\"), List.of(options),\n+    private static ClassModel generateBack(Classfile cc, Sample sample, boolean overflow) {\n+        return cc.parse(cc.build(ClassDesc.of(\"WhateverClass\"),\n@@ -234,1 +240,1 @@\n-                                })));\n+                                }))));\n@@ -249,0 +255,4 @@\n+        assertFixed(sample, Classfile.of().parse(classFile));\n+    }\n+\n+    private static void assertFixed(Sample sample, ClassModel clm) {\n@@ -250,1 +260,1 @@\n-        for (var e : Classfile.parse(classFile).methods().get(0).code().get())\n+        for (var e : clm.methods().get(0).code().get())\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-                var cm = Classfile.parse(path);\n+                var cm = Classfile.of().parse(path);\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Compile Classfile API snippets\n+ * @run junit SnippetsTest\n+ *\/\n+\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class SnippetsTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java\",\n+        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"})\n+    void testSnippet(String source) throws Exception {\n+        var p = Paths.get(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while ((p = p.getParent()) != null) {\n+            var src = p.resolve(source).toFile();\n+            if (src.isFile()) {\n+                var compiler = ToolProvider.getSystemJavaCompiler();\n+                try (var fileManager = compiler.getStandardFileManager(null, null, null)) {\n+                    var compilationUnits = fileManager.getJavaFileObjectsFromFiles(List.of(src));\n+                    fileManager.setLocation(StandardLocation.CLASS_OUTPUT,\n+                            List.of(Paths.get(System.getProperty(\"test.classes\", \".\")).toFile()));\n+                    var task = compiler.getTask(null, fileManager, null, List.of(\n+                            \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+                            \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+                            \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+                            \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+                            \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\"),\n+                            null, compilationUnits);\n+                    if (task.call()) return;\n+                    throw new RuntimeException(\"Error compiling \" + source);\n+                }\n+            }\n+        }\n+        Assumptions.abort(\"Source file not found: \" + source); \/\/do not fail in source-less test environment\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SnippetsTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -57,1 +57,2 @@\n-        return Classfile.build(\n+        return Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER,\n+                                    Classfile.DeadCodeOption.KEEP_DEAD_CODE).build(\n@@ -59,1 +60,0 @@\n-                List.of(Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n@@ -100,1 +100,1 @@\n-        var error = assertThrows(IllegalArgumentException.class, () -> testTransformedStackMaps(buildDeadCode(), Classfile.Option.patchDeadCode(false)));\n+        var error = assertThrows(IllegalArgumentException.class, () -> testTransformedStackMaps(buildDeadCode(), Classfile.DeadCodeOption.KEEP_DEAD_CODE));\n@@ -175,0 +175,1 @@\n+        var cc = Classfile.of();\n@@ -176,2 +177,2 @@\n-        Classfile.parse(\n-                Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+        cc.parse(\n+                cc.build(ClassDesc.of(\"TestClass\"), clb ->\n@@ -197,1 +198,1 @@\n-        Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+        Classfile.of().build(ClassDesc.of(\"TestClass\"), clb ->\n@@ -210,1 +211,1 @@\n-        Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+        Classfile.of().build(ClassDesc.of(\"TestClass\"), clb ->\n@@ -222,1 +223,2 @@\n-        var actualVersion = Classfile.parse(StackMapsTest.class.getResourceAsStream(\"\/testdata\/Pattern1.class\").readAllBytes());\n+        var cc = Classfile.of();\n+        var actualVersion = cc.parse(StackMapsTest.class.getResourceAsStream(\"\/testdata\/Pattern1.class\").readAllBytes());\n@@ -225,3 +227,6 @@\n-        var version49 = Classfile.parse(actualVersion.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n-                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(49, 0)))));\n-        assertFalse(ClassPrinter.toTree(version49, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES).walk().anyMatch(n -> n.name().equals(\"stack map frames\")));\n+        var version49 = cc.parse(cc.transform(\n+                                    actualVersion,\n+                                    ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                                                  .andThen(ClassTransform.endHandler(clb -> clb.withVersion(49, 0)))));\n+        assertFalse(ClassPrinter.toTree(version49, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES)\n+                                .walk().anyMatch(n -> n.name().equals(\"stack map frames\")));\n@@ -230,2 +235,5 @@\n-         assertEmpty(Classfile.parse(version49.transform(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n-                .andThen(ClassTransform.endHandler(clb -> clb.withVersion(50, 0))))).verify(null));\n+         assertEmpty(cc.parse(cc.transform(\n+                                    version49,\n+                                    ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                                                  .andThen(ClassTransform.endHandler(clb -> clb.withVersion(50, 0)))))\n+                              .verify(null));\n@@ -246,2 +254,3 @@\n-        var classModel = Classfile.parse(originalBytes, options);\n-        var transformedBytes = Classfile.build(classModel.thisClass().asSymbol(), List.of(options),\n+        Classfile cc = Classfile.of(options);\n+        var classModel = cc.parse(originalBytes);\n+        var transformedBytes = cc.build(classModel.thisClass().asSymbol(),\n@@ -256,1 +265,1 @@\n-        assertEmpty(Classfile.parse(transformedBytes).verify(null));\n+        assertEmpty(cc.parse(transformedBytes).verify(null));\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), clb ->\n@@ -84,1 +84,1 @@\n-        Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+        Classfile.of().build(ClassDesc.of(\"Foo\"), clb ->\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        ClassModel cm = Classfile.parse(fileBytes);\n+        ClassModel cm = Classfile.of().parse(fileBytes);\n","filename":"test\/jdk\/jdk\/classfile\/StreamedVsListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"C\"), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/SwapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        var cc = Classfile.of();\n+        byte[] bytes = cc.build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -70,1 +71,1 @@\n-        ClassModel m = Classfile.parse(bytes);\n+        ClassModel m = cc.parse(bytes);\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(Files.readAllBytes(testClassPath));\n@@ -69,1 +70,1 @@\n-        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n@@ -75,1 +76,2 @@\n-        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(Files.readAllBytes(testClassPath));\n@@ -77,1 +79,1 @@\n-        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n@@ -83,1 +85,2 @@\n-        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(Files.readAllBytes(testClassPath));\n@@ -94,1 +97,1 @@\n-        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        ClassModel newModel = cc.parse(cc.transform(cm, xform));\n@@ -106,1 +109,1 @@\n-        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        ClassModel cm = Classfile.of().parse(Files.readAllBytes(testClassPath));\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(bytes);\n@@ -101,2 +102,2 @@\n-        assertEquals(invoke(cm.transform(transformCode(foo2foo))), \"foo\");\n-        assertEquals(invoke(cm.transform(transformCode(foo2bar))), \"bar\");\n+        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo))), \"foo\");\n+        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar))), \"bar\");\n@@ -109,1 +110,2 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(bytes);\n@@ -113,1 +115,1 @@\n-        assertEquals(invoke(cm.transform(transform)), \"baz\");\n+        assertEquals(invoke(cc.transform(cm, transform)), \"baz\");\n@@ -120,1 +122,2 @@\n-        ClassModel cm = Classfile.parse(bytes);\n+        var cc = Classfile.of();\n+        ClassModel cm = cc.parse(bytes);\n@@ -123,3 +126,3 @@\n-        assertEquals(invoke(cm.transform(transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n-        assertEquals(invoke(cm.transform(transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n-        assertEquals(invoke(cm.transform(transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n+        assertEquals(invoke(cc.transform(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n+        assertEquals(invoke(cc.transform(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        ClassModel cm = Classfile.parse(classfile);\n+        ClassModel cm = Classfile.of().parse(classfile);\n@@ -166,1 +166,1 @@\n-        ClassModel cm = Classfile.parse(classfile);\n+        ClassModel cm = Classfile.of().parse(classfile);\n@@ -200,1 +200,1 @@\n-        return Classfile.build(ClassDesc.of(\"C\"),\n+        return Classfile.of().build(ClassDesc.of(\"C\"),\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                            Classfile.parse(path).verify(null);\n+                            Classfile.of().parse(path).verify(null);\n@@ -66,1 +66,1 @@\n-        var classModel = Classfile.parse(path, Classfile.Option.classHierarchyResolver(\n+        var cc = Classfile.of(Classfile.ClassHierarchyResolverOption.of(\n@@ -68,1 +68,2 @@\n-        byte[] brokenClassBytes = classModel.transform(\n+        var classModel = cc.parse(path);\n+        byte[] brokenClassBytes = cc.transform(classModel,\n@@ -83,1 +84,1 @@\n-        if (Classfile.parse(brokenClassBytes).verify(sb::append).isEmpty()) {\n+        if (Classfile.of().parse(brokenClassBytes).verify(sb::append).isEmpty()) {\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -97,1 +97,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"MyClass\"), cb -> {\n","filename":"test\/jdk\/jdk\/classfile\/WriteTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return m.transform(ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n+        return Classfile.of().transform(m, ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n@@ -76,0 +76,1 @@\n+            var cc = Classfile.of();\n@@ -78,1 +79,1 @@\n-                    m2 = Classfile.parse(m.transform(SWAP_ANNO_TRANSFORM));\n+                    m2 = cc.parse(cc.transform(m, SWAP_ANNO_TRANSFORM));\n@@ -119,0 +120,1 @@\n+            var cc = Classfile.of();\n@@ -121,1 +123,1 @@\n-                    m2 = Classfile.parse(m.transform((cb, ce) -> {\n+                    m2 = cc.parse(cc.transform(m, (cb, ce) -> {\n@@ -147,1 +149,1 @@\n-        return m.transform(ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return Classfile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n@@ -174,1 +176,1 @@\n-        return m.transform(ClassTransform.ofStateful(() -> new ClassTransform() {\n+        return Classfile.of().transform(m, ClassTransform.ofStateful(() -> new ClassTransform() {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n@@ -76,1 +76,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n@@ -85,1 +85,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n@@ -94,1 +94,1 @@\n-        return cm.transform(ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n+        return Classfile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n@@ -98,1 +98,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n@@ -109,1 +109,1 @@\n-        return cm.transform(ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return Classfile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -138,1 +138,1 @@\n-        return cm.transform(ClassTransform.ofStateful(()  -> new ClassTransform() {\n+        return Classfile.of().transform(cm, ClassTransform.ofStateful(()  -> new ClassTransform() {\n@@ -165,1 +165,1 @@\n-        return cm.transform(ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n+        return Classfile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n@@ -169,1 +169,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n@@ -181,1 +181,1 @@\n-        return cm.transform(ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n+        return Classfile.of().transform(cm, ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n@@ -192,1 +192,1 @@\n-        return cm.transform(ClassTransform.dropping(e -> e instanceof FieldModel fm\n+        return Classfile.of().transform(cm, ClassTransform.dropping(e -> e instanceof FieldModel fm\n@@ -197,1 +197,1 @@\n-        return cm.transform(ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), Classfile.ACC_PUBLIC)));\n+        return Classfile.of().transform(cm, ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), Classfile.ACC_PUBLIC)));\n@@ -201,1 +201,1 @@\n-        return cm.transform(ClassTransform.transformingFields((fb, fe) -> {\n+        return Classfile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -210,1 +210,1 @@\n-        return cm.transform(ClassTransform.transformingFields((fb, fe) -> {\n+        return Classfile.of().transform(cm, ClassTransform.transformingFields((fb, fe) -> {\n@@ -219,1 +219,1 @@\n-        return cm.transform(ClassTransform.transformingMethods(\n+        return Classfile.of().transform(cm, ClassTransform.transformingMethods(\n@@ -263,1 +263,1 @@\n-        return cm.transform(ClassTransform.transformingMethodBodies(transform));\n+        return Classfile.of().transform(cm, ClassTransform.transformingMethodBodies(transform));\n@@ -267,1 +267,1 @@\n-        return cm.transform(ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return Classfile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n@@ -279,1 +279,1 @@\n-        return cm.transform(ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+        return Classfile.of().transform(cm, ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return cm.transform((cb, ce) -> {\n+        return Classfile.of().transform(cm, (cb, ce) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExperimentalTransformExamples.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        ClassModel cm = Classfile.parse(JRT.getPath(\"modules\/java.base\/module-info.class\"));\n+        ClassModel cm = Classfile.of().parse(JRT.getPath(\"modules\/java.base\/module-info.class\"));\n@@ -81,1 +81,2 @@\n-        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), clb -> {\n+        var cc = Classfile.of();\n+        byte[] moduleInfo = cc.buildModule(ModuleAttribute.of(moduleName, handler), clb -> {\n@@ -90,1 +91,1 @@\n-        ClassModel mm = Classfile.parse(moduleInfo);\n+        ClassModel mm = cc.parse(moduleInfo);\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -42,1 +43,1 @@\n-        return cm.transform(ClassTransform.ACCEPT_ALL);\n+        return Classfile.of().transform(cm, ClassTransform.ACCEPT_ALL);\n@@ -46,1 +47,1 @@\n-        return cm.transform((b, e) -> {\n+        return Classfile.of().transform(cm, (b, e) -> {\n@@ -53,1 +54,1 @@\n-        return cm.transform((b, e) ->\n+        return Classfile.of().transform(cm, (b, e) ->\n@@ -61,1 +62,1 @@\n-        return cm.transform((b, e) -> {\n+        return Classfile.of().transform(cm, (b, e) -> {\n@@ -68,1 +69,1 @@\n-        return cm.transform((b, e) -> {\n+        return Classfile.of().transform(cm, (b, e) -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/TransformExamples.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        return Classfile.build(clm.thisClass().asSymbol(), List.of(Classfile.Option.generateStackmap(false)), clb -> {\n+        return Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER).build(clm.thisClass().asSymbol(), clb -> {\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            return RebuildingTransformation.transform(Classfile.parse(bytes));\n+            return RebuildingTransformation.transform(Classfile.of().parse(bytes));\n@@ -132,2 +132,2 @@\n-        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.Option.generateStackmap(false)),\n-        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.Option.processDebug(false), Classfile.Option.processLineNumbers(false)),\n+        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.StackMapsOption.STACK_MAPS_NEVER),\n+        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.DebugElementsOption.DROP_DEBUG, Classfile.LineNumbersOption.DROP_LINE_NUMBERS),\n@@ -167,1 +167,1 @@\n-                ClassRemapper.of(Map.of()).remapClass(Classfile.parse(bytes)));\n+                ClassRemapper.of(Map.of()).remapClass(Classfile.of(), Classfile.of().parse(bytes)));\n@@ -174,1 +174,1 @@\n-        public final Classfile.Option[] options;\n+        public final Classfile cc;\n@@ -180,1 +180,1 @@\n-            options = new Classfile.Option[0];\n+            cc = Classfile.of();\n@@ -188,4 +188,5 @@\n-            this.options = shared\n-                           ? options\n-                           : Stream.concat(Stream.of(options), Stream.of(Classfile.Option.constantPoolSharing(false))).toArray(Classfile.Option[]::new);\n-            this.transform = bytes -> Classfile.parse(bytes, this.options).transform(classTransform);\n+            this.cc = Classfile.of(\n+                    shared\n+                    ? options\n+                    : Stream.concat(Stream.of(options), Stream.of(Classfile.ConstantPoolSharingOption.NEW_POOL)).toArray(Classfile.Option[]::new));\n+            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n@@ -196,1 +197,1 @@\n-                case ARRAYCOPY -> Optional.of(ClassRecord.ofClassModel(Classfile.parse(bytes)));\n+                case ARRAYCOPY -> Optional.of(ClassRecord.ofClassModel(Classfile.of().parse(bytes)));\n@@ -200,1 +201,1 @@\n-                        -> Optional.of(ClassRecord.ofClassModel(Classfile.parse(bytes), ClassRecord.CompatibilityFilter.By_ClassBuilder));\n+                        -> Optional.of(ClassRecord.ofClassModel(Classfile.of().parse(bytes), ClassRecord.CompatibilityFilter.By_ClassBuilder));\n@@ -214,2 +215,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform((cb, ce) -> {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, (cb, ce) -> {\n@@ -254,2 +256,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform(new ClassTransform() {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, new ClassTransform() {\n@@ -268,2 +271,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return Classfile.build(cm.thisClass().asSymbol(),\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.build(cm.thisClass().asSymbol(),\n@@ -290,2 +294,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform((builder, element) -> {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, (builder, element) -> {\n@@ -297,2 +302,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return Classfile.build(cm.thisClass().asSymbol(),\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.build(cm.thisClass().asSymbol(),\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        return Classfile.build(ClassDesc.of(\"module-info\"), clb -> {\n+        return Classfile.of().build(ClassDesc.of(\"module-info\"), clb -> {\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ModuleInfoWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+        var cc = Classfile.of();\n@@ -61,1 +62,1 @@\n-            bh.consume(Classfile.parse(bytes).transform(transform.transform));\n+            bh.consume(cc.transform(cc.parse(bytes), transform.transform));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdHocAdapt.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.classfile.impl.ClassfileImpl;\n@@ -81,0 +82,1 @@\n+    Classfile cc;\n@@ -84,0 +86,1 @@\n+        cc = Classfile.of();\n@@ -87,1 +90,1 @@\n-                var clm = Classfile.parse(p);\n+                var clm = cc.parse(p);\n@@ -123,0 +126,1 @@\n+                (ClassfileImpl)cc,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+        var cc = Classfile.of(Classfile.DebugElementsOption.DROP_DEBUG);\n@@ -45,2 +46,2 @@\n-            ClassModel cm = Classfile.parse(aClass, Classfile.Option.processDebug(false));\n-            bh.consume(cm.transform(threeLevelNoop));\n+            ClassModel cm = cc.parse(aClass);\n+            bh.consume(cc.transform(cm, threeLevelNoop));\n@@ -53,0 +54,1 @@\n+        var cc = Classfile.of(Classfile.StackMapsOption.STACK_MAPS_NEVER);\n@@ -54,2 +56,2 @@\n-            ClassModel cm = Classfile.parse(aClass, Classfile.Option.generateStackmap(false));\n-            bh.consume(cm.transform(threeLevelNoop));\n+            ClassModel cm = cc.parse(aClass);\n+            bh.consume(cc.transform(cm, threeLevelNoop));\n@@ -62,0 +64,1 @@\n+        var cc = Classfile.of(Classfile.LineNumbersOption.DROP_LINE_NUMBERS);\n@@ -63,2 +66,2 @@\n-            ClassModel cm = Classfile.parse(aClass, Classfile.Option.processLineNumbers(false));\n-            bh.consume(cm.transform(threeLevelNoop));\n+            ClassModel cm = cc.parse(aClass);\n+            bh.consume(cc.transform(cm, threeLevelNoop));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ParseOptions.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+        var cc = Classfile.of();\n@@ -104,1 +105,1 @@\n-            ClassModel cm = Classfile.parse(bytes);\n+            ClassModel cm = cc.parse(bytes);\n@@ -125,0 +126,1 @@\n+        var cc = Classfile.of();\n@@ -126,1 +128,1 @@\n-            ClassModel cm = Classfile.parse(bytes);\n+            ClassModel cm = cc.parse(bytes);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadDeep.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        var cc = Classfile.of();\n@@ -72,1 +73,1 @@\n-            bh.consume(Classfile.parse(bytes).thisClass().asInternalName());\n+            bh.consume(cc.parse(bytes).thisClass().asInternalName());\n@@ -116,0 +117,1 @@\n+        var cc = Classfile.of();\n@@ -118,1 +120,1 @@\n-            ClassModel cm = Classfile.parse(bytes);\n+            ClassModel cm = cc.parse(bytes);\n@@ -130,0 +132,1 @@\n+        var cc = Classfile.of();\n@@ -132,1 +135,1 @@\n-            ClassModel cm = Classfile.parse(bytes);\n+            ClassModel cm = cc.parse(bytes);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadMetadata.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,2 +50,3 @@\n-    List<ClassModel> shared, unshared;\n-    Iterator<ClassModel> it1, it2;\n+    Classfile shared, unshared;\n+    List<ClassModel> models;\n+    Iterator<ClassModel> it;\n@@ -55,2 +56,9 @@\n-        shared = new ArrayList<>();\n-        unshared = new ArrayList<>();\n+        shared = Classfile.of(\n+                            Classfile.ConstantPoolSharingOption.SHARED_POOL,\n+                            Classfile.DebugElementsOption.DROP_DEBUG,\n+                            Classfile.LineNumbersOption.DROP_LINE_NUMBERS);\n+        unshared = Classfile.of(\n+                            Classfile.ConstantPoolSharingOption.NEW_POOL,\n+                            Classfile.DebugElementsOption.DROP_DEBUG,\n+                            Classfile.LineNumbersOption.DROP_LINE_NUMBERS);\n+        models = new ArrayList<>();\n@@ -59,12 +67,5 @@\n-                var clm = Classfile.parse(p,\n-                        Classfile.Option.constantPoolSharing(true),\n-                        Classfile.Option.processDebug(false),\n-                        Classfile.Option.processLineNumbers(false));\n-                shared.add(clm);\n-                transform(clm); \/\/dry run to expand model and symbols\n-                clm = Classfile.parse(p,\n-                        Classfile.Option.constantPoolSharing(false),\n-                        Classfile.Option.processDebug(false),\n-                        Classfile.Option.processLineNumbers(false));\n-                unshared.add(clm);\n-                transform(clm); \/\/dry run to expand model and symbols\n+                var clm = shared.parse(p);\n+                models.add(clm);\n+                \/\/dry run to expand model and symbols\n+                transform(shared, clm);\n+                transform(unshared, clm);\n@@ -79,2 +80,2 @@\n-        if (it1 == null || !it1.hasNext())\n-            it1 = shared.iterator();\n+        if (it == null || !it.hasNext())\n+            it = models.iterator();\n@@ -82,1 +83,1 @@\n-        transform(it1.next());\n+        transform(shared, it.next());\n@@ -87,2 +88,2 @@\n-        if (it2 == null || !it2.hasNext())\n-            it2 = unshared.iterator();\n+        if (it == null || !it.hasNext())\n+            it = models.iterator();\n@@ -90,1 +91,1 @@\n-        transform(it2.next());\n+        transform(unshared, it.next());\n@@ -93,2 +94,2 @@\n-    private static void transform(ClassModel clm) {\n-        clm.transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+    private static void transform(Classfile cc, ClassModel clm) {\n+        cc.transform(clm, ClassTransform.transformingMethodBodies((cob, coe) -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+        var cc = Classfile.of();\n@@ -56,1 +57,1 @@\n-                var clm = Classfile.parse(p);\n+                var clm = cc.parse(p);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RepeatedModelTraversal.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.Option.generateStackmap(false)),\n-        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.Option.processDebug(false), Classfile.Option.processLineNumbers(false)),\n+        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.StackMapsOption.STACK_MAPS_NEVER),\n+        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.DebugElementsOption.DROP_DEBUG, Classfile.LineNumbersOption.DROP_LINE_NUMBERS),\n@@ -164,1 +164,1 @@\n-                ClassRemapper.of(Map.of()).remapClass(Classfile.parse(bytes)));\n+                ClassRemapper.of(Map.of()).remapClass(Classfile.of(), Classfile.of().parse(bytes)));\n@@ -171,1 +171,1 @@\n-        public final Classfile.Option[] options;\n+        public final Classfile cc;\n@@ -177,1 +177,1 @@\n-            options = new Classfile.Option[0];\n+            cc = Classfile.of();\n@@ -185,4 +185,5 @@\n-            this.options = shared\n-                           ? options\n-                           : Stream.concat(Stream.of(options), Stream.of(Classfile.Option.constantPoolSharing(false))).toArray(Classfile.Option[]::new);\n-            this.transform = bytes -> Classfile.parse(bytes, this.options).transform(classTransform);\n+            this.cc = Classfile.of(\n+                    shared\n+                    ? options\n+                    : Stream.concat(Stream.of(options), Stream.of(Classfile.ConstantPoolSharingOption.NEW_POOL)).toArray(Classfile.Option[]::new));\n+            this.transform = bytes -> cc.transform(cc.parse(bytes), classTransform);\n@@ -200,2 +201,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform((cb, ce) -> {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, (cb, ce) -> {\n@@ -240,2 +242,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform(new ClassTransform() {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, new ClassTransform() {\n@@ -254,2 +257,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return Classfile.build(cm.thisClass().asSymbol(),\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.build(cm.thisClass().asSymbol(),\n@@ -276,2 +280,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return cm.transform((builder, element) -> {\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.transform(cm, (builder, element) -> {\n@@ -283,2 +288,3 @@\n-            ClassModel cm = Classfile.parse(bytes);\n-            return Classfile.build(cm.thisClass().asSymbol(),\n+            var cc = Classfile.of();\n+            ClassModel cm = cc.parse(bytes);\n+            return cc.build(cm.thisClass().asSymbol(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"MyClass\"), cb -> {\n@@ -200,1 +200,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        byte[] bytes = Classfile.of().build(ClassDesc.of(\"MyClass\"), cb -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}