{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -52,5 +51,4 @@\n-     * Returns new instance of {@link ClassHierarchyResolver}\n-     * that caches {@link ClassHierarchyInfo} instances read from system\n-     * class loader with {@link ClassLoader#getSystemResourceAsStream(String)}\n-     * and falls back to reflection if a class is not found.\n-     * The returned resolver is thread-safe.\n+     * Returns a default instance of {@linkplain ClassHierarchyResolver}\n+     * that reads from system class loader with\n+     * {@link ClassLoader#getSystemResourceAsStream(String)} and falls\n+     * back to reflection if a class is not found.\n@@ -58,14 +56,2 @@\n-    static ClassHierarchyResolver ofSystem() {\n-        record Factory() implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n-            static final Factory INSTANCE = new Factory();\n-\n-            @Override\n-            public Map<ClassDesc, ClassHierarchyInfo> get() {\n-                return new ConcurrentHashMap<>();\n-            }\n-        }\n-        var sysLoader = ClassLoader.getSystemClassLoader();\n-        return ClassHierarchyResolver\n-            .ofResourceParsing(sysLoader)\n-            .orElse(ClassHierarchyResolver.ofClassLoading(sysLoader))\n-            .cached(Factory.INSTANCE);\n+    static ClassHierarchyResolver defaultResolver() {\n+        return ClassHierarchyImpl.DEFAULT_RESOLVER;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -55,0 +56,7 @@\n+    \/**\n+     * {@return a new context with default options}\n+     *\/\n+    static Classfile of() {\n+        return new ClassfileImpl();\n+    }\n+\n@@ -60,1 +68,1 @@\n-        return ClassfileImpl.of(options);\n+        return of().withOptions(options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -36,0 +37,1 @@\n+import java.util.function.Supplier;\n@@ -53,0 +55,10 @@\n+    public static final ClassHierarchyResolver DEFAULT_RESOLVER = ClassHierarchyResolver\n+            .ofResourceParsing(ResourceParsingClassHierarchyResolver.SYSTEM_STREAM_PROVIDER)\n+            .orElse(new ClassLoadingClassHierarchyResolver(ClassLoadingClassHierarchyResolver.SYSTEM_CLASS_PROVIDER))\n+            .cached(new Supplier<>() {\n+                @Override\n+                public Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> get() {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            });\n+\n@@ -116,1 +128,1 @@\n-        private final ClassHierarchyResolver delegate;\n+        private final Function<ClassDesc, ClassHierarchyInfo> delegateFunction;\n@@ -120,1 +132,7 @@\n-            this.delegate = delegate;\n+            this.delegateFunction = new Function<>() {\n+                @Override\n+                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n+                    var ret = delegate.getClassInfo(classDesc);\n+                    return ret == null ? NOPE : ret;\n+                }\n+            };\n@@ -125,6 +143,1 @@\n-            var ret = resolvedCache.get(classDesc);\n-            if (ret == null) {\n-                \/\/semi-synchronized caching, where the map is not locked during delegate call\n-                ret = delegate.getClassInfo(classDesc);\n-                resolvedCache.put(classDesc, ret == null ? NOPE : ret);\n-            }\n+            var ret = resolvedCache.computeIfAbsent(classDesc, delegateFunction);\n@@ -136,0 +149,6 @@\n+        public static final Function<ClassDesc, InputStream> SYSTEM_STREAM_PROVIDER = new Function<>() {\n+            @Override\n+            public InputStream apply(ClassDesc cd) {\n+                return ClassLoader.getSystemClassLoader().getResourceAsStream(Util.toInternalName(cd) + \".class\");\n+            }\n+        };\n@@ -201,0 +220,10 @@\n+        public static final Function<ClassDesc, Class<?>> SYSTEM_CLASS_PROVIDER = new Function<>() {\n+            @Override\n+            public Class<?> apply(ClassDesc cd) {\n+                try {\n+                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, ClassLoader.getSystemClassLoader());\n+                } catch (ClassNotFoundException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    private static final ClassfileImpl DEFAULT_STATIC_CONTEXT = new ClassfileImpl(\n-            StackMapsOption.STACK_MAPS_WHEN_REQUIRED,\n+    public ClassfileImpl() {\n+        this(StackMapsOption.STACK_MAPS_WHEN_REQUIRED,\n@@ -63,1 +63,1 @@\n-             null,\n+             new ClassHierarchyResolverOptionImpl(ClassHierarchyResolver.defaultResolver()),\n@@ -70,3 +70,0 @@\n-\n-    public static ClassfileImpl of(Option... options) {\n-        return DEFAULT_STATIC_CONTEXT.withOptions(options);\n@@ -102,3 +99,0 @@\n-        if (chro == null) {\n-            chro = ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofSystem());\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassfileImpl.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        return verify(classModel, ClassHierarchyResolver.ofSystem(), logger);\n+        return verify(classModel, ClassHierarchyResolver.defaultResolver(), logger);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                                          .orElse(ClassHierarchyResolver.ofSystem())\n+                                          .orElse(ClassHierarchyResolver.defaultResolver())\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.ofSystem()))\n+                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.defaultResolver()))\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}