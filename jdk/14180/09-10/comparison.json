{"files":[{"patch":"@@ -59,0 +59,8 @@\n+        record Factory() implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n+            static final Factory INSTANCE = new Factory();\n+\n+            @Override\n+            public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        }\n@@ -63,6 +71,1 @@\n-            .cached(new Supplier<>() {\n-                @Override\n-                public Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> get() {\n-                    return new ConcurrentHashMap<>();\n-                }\n-            });\n+            .cached(Factory.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-        private final Function<ClassDesc, ClassHierarchyInfo> delegateFunction;\n+        private final ClassHierarchyResolver delegate;\n@@ -120,7 +120,1 @@\n-            this.delegateFunction = new Function<>() {\n-                @Override\n-                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n-                    var ret = delegate.getClassInfo(classDesc);\n-                    return ret == null ? NOPE : ret;\n-                }\n-            };\n+            this.delegate = delegate;\n@@ -131,1 +125,6 @@\n-            var ret = resolvedCache.computeIfAbsent(classDesc, delegateFunction);\n+            var ret = resolvedCache.get(classDesc);\n+            if (ret == null) {\n+                \/\/semi-synchronized caching, where the map is not locked during delegate call\n+                ret = delegate.getClassInfo(classDesc);\n+                resolvedCache.put(classDesc, ret == null ? NOPE : ret);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}