{"files":[{"patch":"@@ -55,1 +55,4 @@\n-\/\/ Commit uncommitted section of the chunk.\n+\/\/ Commit space in the chunk, so that _committed_words is at least at\n+\/\/  new_committed_words.\n+\/\/  new_committed_words has to fall within the limits of the chunk and has\n+\/\/  to be larger than the current commit boundary.\n@@ -58,1 +61,59 @@\n-  \/\/ Please note:\n+\n+  assert(new_committed_words > _committed_words, \"nothing to do.\");\n+  assert(new_committed_words <= word_size(), \"parameter error\");\n+\n+  \/\/ lock protection needed since it may modify neighboring chunks.\n+  assert_lock_strong(MetaspaceExpand_lock);\n+\n+  \/\/ This function commits additional space within the Metachunk. Committing is done\n+  \/\/  for whole commit granules only.\n+  \/\/\n+  \/\/ We have two cases:\n+  \/\/\n+  \/\/ Case 1: Chunk is larger than a commit granule:\n+  \/\/\n+  \/\/  We commit additional granules as are needed to reach the requested\n+  \/\/   \"new_committed_words\" commit boundary. That may over-reach, so the\n+  \/\/   resulting commit boundary may be higher.\n+  \/\/  The commit boundary has to be at a granule border. That guarantees\n+  \/\/   that we never re-commit already committed pages (see remarks below).\n+  \/\/\n+  \/\/ Example: A chunk covering 8 granules. Before this call, we had three\n+  \/\/  granules committed and partly used. new_committed_words falls into\n+  \/\/  the fifth granule, causing us to commit  two additional granules:\n+  \/\/\n+  \/\/  granule 1    granule 2    granule 3    granule 4    granule 5    granule 6    granule 7    granule 8\n+  \/\/ +------------+------------+------------+------------+------------+------------+------------+------------+\n+  \/\/ |                                      |                         |                                      |\n+  \/\/ | <.... old committed space .........> | <.... newly committed   | <.... uncommitted .................> |\n+  \/\/ |                                      |               space ..> |                                      |\n+  \/\/ | <... live data ...........> |        |                         |                                      |\n+  \/\/ +------------+------------+---|--------+------------+------|-----+------------+------------+------------+\n+  \/\/                               |                            |\n+  \/\/ ^                             ^        ^                   |     ^                                      ^\n+  \/\/ base                          used     old                 |     new                                    chunk end\n+  \/\/                                        _committed_words    |      _committed_words\n+  \/\/                                                            |\n+  \/\/                                                           new_committed_words\n+  \/\/\n+  \/\/ Case 2: Chunk is smaller than a commit granule.\n+  \/\/\n+  \/\/  It shares a single granule with a number of neighbors. Committing this\n+  \/\/  granule will affect neighbors.\n+  \/\/\n+  \/\/ Example: calling ensure_committed() on chunk B may commit the granule, thus\n+  \/\/  committing space for chunk A and C as well.\n+  \/\/\n+  \/\/ +---------------------- one granule ----------------------------+\n+  \/\/ |                                                               |\n+  \/\/     chunk A         chunk B                 chunk C\n+  \/\/ +---------------+---------------+-------------------------------+\n+  \/\/ |               |               |                               |\n+  \/\/ | <committed    | <committed>   |  <committed as well>          |\n+  \/\/ |   as well>    |               |                               |\n+  \/\/ |               |               |                               |\n+  \/\/ +---------------+---------------+-------------------------------+\n+  \/\/                      ^\n+  \/\/                      ensure_committed()\n+  \/\/\n+  \/\/\/\/\/\/\/\n@@ -60,3 +121,3 @@\n-  \/\/ VirtualSpaceNode::ensure_range_is_committed(), when called over a range containing both committed and uncommitted parts,\n-  \/\/ will replace the whole range with a new mapping, thus erasing the existing content in the committed parts. Therefore\n-  \/\/ we must make sure never to call VirtualSpaceNode::ensure_range_is_committed() over a range containing live data.\n+  \/\/ Safety note: when committing a memory range, that range will be remapped. If that\n+  \/\/  range did contain committed pages, those are now lost. Therefore we must ensure\n+  \/\/  that we never re-commit parts of chunks which are already in use.\n@@ -64,1 +125,1 @@\n-  \/\/ Luckily, this cannot happen by design. We have two cases:\n+  \/\/ Happily this is no concern:\n@@ -66,5 +127,11 @@\n-  \/\/ 1) chunks equal or larger than a commit granule.\n-  \/\/    In this case, due to chunk geometry, the chunk should cover whole commit granules (in other words, a chunk equal or larger than\n-  \/\/    a commit granule will never share a granule with a neighbor). That means whatever we commit or uncommit here does not affect\n-  \/\/    neighboring chunks. We only have to take care not to re-commit used parts of ourself. We do this by moving the committed_words\n-  \/\/    limit in multiple of commit granules.\n+  \/\/ Chunks smaller than a granule have in-granule neighbors which we would\n+  \/\/  affect when committing\/ uncommitting the underlying granule. But:\n+  \/\/  - we never uncommit chunks smaller than a single granule.\n+  \/\/  - when committing an uncommitted small chunk, there is no problem since\n+  \/\/    all in-granule-neighbors were uncommitted and cannot contain live\n+  \/\/    data we could wipe by re-committing.\n+  \/\/\n+  \/\/ Chunks equal or larger than a commit granule occupy whole granules, so\n+  \/\/  committing them does not affect neighbors. As long as we take care to move\n+  \/\/  the commit boundary inside those chunks along granule borders, we cannot\n+  \/\/  accidentally re-commit used pages.\n@@ -72,5 +139,0 @@\n-  \/\/ 2) chunks smaller than a commit granule.\n-  \/\/    In this case, a chunk shares a single commit granule with its neighbors. But this never can be a problem:\n-  \/\/    - Either the commit granule is already committed (and maybe the neighbors contain live data). In that case calling\n-  \/\/      ensure_range_is_committed() will do nothing.\n-  \/\/    - Or the commit granule is not committed, but in this case, the neighbors are uncommitted too and cannot contain live data.\n@@ -89,1 +151,4 @@\n-    assert(_committed_words == 0 || _committed_words == word_size(), \"Sanity\");\n+    \/\/ Small chunks (< granule) are either fully committed or fully uncommitted.\n+    \/\/ Moreover, at this point they cannot be committed, since we only do this\n+    \/\/ if the new commit boundary is higher than the current one.\n+    assert(_committed_words == 0, \"Sanity\");\n@@ -93,3 +158,0 @@\n-  \/\/ We should hold the expand lock at this point.\n-  assert_lock_strong(MetaspaceExpand_lock);\n-\n@@ -111,0 +173,20 @@\n+\n+  \/\/ If this chunk was smaller than a granule we just committed, we committed the memory\n+  \/\/  underlying the in-granule neighbors as well. Lets correct their commit boundaries.\n+  \/\/ Note that this is not strictly necessary: these boundaries would silently be corrected\n+  \/\/  the first time someone were to use those chunks. But doing it now keeps statistics happy\n+  \/\/  and we save some work later on.\n+  if (word_size() < Settings::commit_granule_words()) {\n+    const MetaWord* granule_start = align_down(base(), Settings::commit_granule_bytes());\n+    const MetaWord* granule_end = granule_start + Settings::commit_granule_words();\n+    assert(granule_end >= end(), \"Sanity\");\n+    for (Metachunk* c = prev_in_vs(); c != NULL && c->base() >= granule_start; c = c->prev_in_vs()) {\n+      assert(c->committed_words() == 0, \"neighbor was already committed?\");\n+      c->_committed_words = c->word_size();\n+    }\n+    for (Metachunk* c = next_in_vs(); c != NULL && c->end() <= granule_end; c = c->next_in_vs()) {\n+      assert(c->committed_words() == 0, \"neighbor was already committed?\");\n+      c->_committed_words = c->word_size();\n+    }\n+  }\n+\n@@ -112,0 +194,1 @@\n+  DEBUG_ONLY(verify_neighborhood();)\n@@ -184,0 +267,10 @@\n+\/\/ Checks the chunk local commit watermark against the underlying commit mask.\n+void Metachunk::verify_committed_words() const {\n+  assert_lock_strong(MetaspaceExpand_lock);\n+  if (_committed_words > 0) {\n+    assert(_vsnode->is_range_fully_committed(base(), committed_words()),\n+           \"commit mismatch - Chunk: \" METACHUNK_FULL_FORMAT \".\",\n+           METACHUNK_FULL_FORMAT_ARGS(this));\n+  }\n+}\n+\n@@ -189,0 +282,1 @@\n+  verify_committed_words();\n@@ -205,0 +299,1 @@\n+      prev_in_vs()->verify_committed_words();\n@@ -213,0 +308,1 @@\n+      next_in_vs()->verify_committed_words();\n@@ -282,3 +378,19 @@\n-  \/\/ Starting address shall be aligned to chunk size.\n-  const size_t required_alignment = word_size() * sizeof(MetaWord);\n-  assert_is_aligned(base(), required_alignment);\n+  \/\/ Size shall be pow2 aligned, and starting address shall be aligned to chunk size.\n+  assert(is_power_of_2(word_size()), \"sanity\");\n+  assert_is_aligned(base(), word_size() * sizeof(MetaWord));\n+\n+  \/\/ A chunk shall not straddle the border of two granules it shares with other chunks.\n+  \/\/ (Self-evident since both chunks and granules are pow2 sizes, and start at\n+  \/\/  size aligned addresses, but lets make things explicit.)\n+  assert(is_power_of_2(Settings::commit_granule_words()), \"sanity\");\n+  if (word_size() < Settings::commit_granule_words()) {\n+    \/\/ Small chunks are contained within a single granule\n+    assert(VirtualSpaceNode::get_commit_granule_start(base()) ==\n+           VirtualSpaceNode::get_commit_granule_start(end() - 1),\n+           \"small chunk straddles granule border?\");\n+  } else {\n+    \/\/ Large chunks contain full granules only\n+    assert_is_aligned(word_size(), Settings::commit_granule_words());\n+    assert(VirtualSpaceNode::get_commit_granule_start(base()) == base(),\n+           \"large chunk starts in the middle of a granule?\");\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":135,"deletions":23,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+  \/\/ Checks the chunk local commit watermark against the underlying commit mask.\n+  DEBUG_ONLY(void verify_committed_words() const;)\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,0 +212,13 @@\n+#ifdef ASSERT\n+\/\/ Returns true if range [p, p + word_size) is fully committed.\n+bool VirtualSpaceNode::is_range_fully_committed(const MetaWord* p, size_t word_size) const {\n+  assert_lock_strong(MetaspaceExpand_lock);\n+  if (word_size == 0) {\n+    return true;\n+  }\n+  const MetaWord* p_start = align_down(p, Settings::commit_granule_bytes());\n+  const size_t s2 = align_up(word_size, Settings::commit_granule_words());\n+  return _commit_mask.get_committed_size_in_range(p_start, s2) == s2;\n+}\n+#endif\n+\n@@ -435,0 +448,5 @@\n+\/\/ Given a pointer into metaspace, return the start of the commit granule for that pointer.\n+const MetaWord* VirtualSpaceNode::get_commit_granule_start(const MetaWord* p) {\n+  return align_down(p, Settings::commit_granule_bytes());\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -263,0 +263,3 @@\n+  \/\/ Returns true if range [p, p + word_size) is fully committed.\n+  DEBUG_ONLY(bool is_range_fully_committed(const MetaWord* p, size_t word_size) const;)\n+\n@@ -277,0 +280,3 @@\n+  \/\/ Given a pointer into metaspace, return the start of the commit granule for that pointer.\n+  DEBUG_ONLY(static const MetaWord* get_commit_granule_start(const MetaWord* p);)\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,1 +208,0 @@\n-\n@@ -211,1 +210,0 @@\n-\n@@ -213,1 +211,0 @@\n-\n@@ -251,0 +248,57 @@\n+#ifdef ASSERT\n+\/\/ Test that an assert fires if commit information goes out\n+\/\/ of sync between metaspace chunk and underlying VirtualSpaceNode.\n+TEST_VM_ASSERT_MSG(metaspace, chunk_commit_mismatch, \".*commit mismatch.*\") {\n+\n+  ChunkGtestContext context;\n+\n+  \/\/ A big chunk...\n+  Metachunk* c = NULL;\n+  context.alloc_chunk_expect_success(&c, ROOT_CHUNK_LEVEL, ROOT_CHUNK_LEVEL, 0);\n+\n+  \/\/ commit fully\n+  context.commit_chunk_with_test(c, c->word_size());\n+\n+  \/\/ uncommit underlying space\n+  {\n+    MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);\n+    c->vsnode()->uncommit_range(c->base() + Settings::commit_granule_words(), Settings::commit_granule_words());\n+  }\n+\n+  {\n+    MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ This will assert (see: Metachunk::verify_committed_words())\n+    c->verify_neighborhood();\n+  }\n+\n+  ShouldNotReachHere();\n+}\n+#endif\n+\n+\/\/ Test that committing a small chunk correctly commits their in-granule-neighbors.\n+TEST_VM(metaspace, chunk_commit_in_granule_neighbors) {\n+  \/\/ For details, see comment in Metachunk::commit_up_to().\n+\n+  \/\/ Bit difficult to test since ChunkManager::get_chunk() automatically commits the returned\n+  \/\/ chunk. Here, we just test that, after requesting a single 1K chunk from the ChunkManager,\n+  \/\/ the remainder *committed space* in the ChunkManager is <commit granule size> - 1K.\n+  ChunkGtestContext context;\n+\n+  \/\/ Freelist should be empty now\n+  ASSERT_0(context.cm().calc_committed_word_size());\n+\n+  const size_t len = word_size_for_level(CHUNK_LEVEL_1K);\n+  Metachunk* c = NULL;\n+  context.alloc_chunk_expect_success(&c, CHUNK_LEVEL_1K, CHUNK_LEVEL_1K, len);\n+\n+  \/\/ A single granule should have been committed...\n+  ASSERT_EQ(context.committed_words(), Settings::commit_granule_words());\n+\n+  \/\/ ...divided into the chunk we just got and the committed splinter chunks in the freelist:\n+  ASSERT_EQ(c->committed_words(), len);\n+  ASSERT_EQ(context.cm().calc_committed_word_size(),\n+            Settings::commit_granule_words() - len);\n+\n+  context.return_chunk(c);\n+}\n+\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunk.cpp","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-  const size_t word_size = metaspace::chunklevel::MAX_CHUNK_WORD_SIZE * 10;\n+  const size_t word_size = metaspace::chunklevel::MAX_CHUNK_WORD_SIZE * 5;\n@@ -500,1 +500,1 @@\n-  CommitLimiter cl (word_size * 2); \/\/ basically, no commit limiter.\n+  CommitLimiter cl(word_size * 2); \/\/ basically, no commit limiter.\n@@ -521,1 +521,1 @@\n-  for (int i = 1; i < num_granules; i += 4) {\n+  for (int i = 1; i <= num_granules; i ++) {\n@@ -535,0 +535,17 @@\n+  \/\/ Test is_range_fully_committed\n+#ifdef ASSERT\n+  {\n+    const size_t l = 2 * Settings::commit_granule_words();\n+    MetaWord* const p1 = node->base() + l;\n+    node->uncommit_range(node->base(), node->word_size());\n+    ASSERT_TRUE(node->ensure_range_is_committed(p1, l));\n+    ASSERT_TRUE(node->is_range_fully_committed(p1, l));\n+    ASSERT_TRUE(node->is_range_fully_committed(p1, 1));\n+    ASSERT_TRUE(node->is_range_fully_committed(p1, 0));\n+    ASSERT_TRUE(node->is_range_fully_committed(p1 + l\/2, l\/2));\n+    ASSERT_FALSE(node->is_range_fully_committed(p1 + l\/2, l));\n+    ASSERT_FALSE(node->is_range_fully_committed(p1 - l\/2, l));\n+    ASSERT_FALSE(node->is_range_fully_committed(p1 - 1, 2));\n+    ASSERT_FALSE(node->is_range_fully_committed(p1 + l, 2));\n+  }\n+#endif\n@@ -592,1 +609,0 @@\n-\n","filename":"test\/hotspot\/gtest\/metaspace\/test_virtualspacenode.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"}]}