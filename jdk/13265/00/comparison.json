{"files":[{"patch":"@@ -310,9 +310,0 @@\n-    \/**\n-     * Test if the current character is a line terminator.\n-     *\n-     * @return true if current character is a line terminator.\n-     *\/\n-    private boolean isEOLN() {\n-        return isOneOf('\\n', '\\r');\n-    }\n-\n@@ -1097,1 +1088,1 @@\n-                                       new String(getRawCharacters(pos, endPos))\n+                                       getRawString(pos, endPos)\n@@ -1149,1 +1140,1 @@\n-                                + new String(getRawCharacters(pos, endPos))\n+                                + getRawString(pos, endPos)\n@@ -1153,3 +1144,1 @@\n-        char[] buf = getRawCharacters(pos, endPos);\n-\n-        return new BasicComment(style, fac, buf, pos);\n+        return new BasicComment(style,this, pos, endPos);\n@@ -1170,2 +1159,2 @@\n-                                + \",\" + endPos + \")=|\" +\n-                                new String(getRawCharacters(pos, endPos))\n+                                + \",\" + endPos + \")=|\"\n+                                + getRawString(pos, endPos)\n@@ -1185,2 +1174,2 @@\n-                                + \",\" + endPos + \")=|\" +\n-                                new String(getRawCharacters(pos, endPos))\n+                                + \",\" + endPos + \")=|\"\n+                                + getRawString(pos, endPos)\n@@ -1209,3 +1198,0 @@\n-         *   LINE starting with \/\/\n-         *   BLOCK starting with \/*\n-         *   JAVADOC starting with \/**\n@@ -1228,4 +1214,4 @@\n-         * @param cs      comment style\n-         * @param sf      Scan factory.\n-         * @param array   Array containing contents of source.\n-         * @param offset  Position offset in original source buffer.\n+         * @param cs     comment style\n+         * @param reader existing reader\n+         * @param pos    start of meaningful content in buffer.\n+         * @param endPos end of meaningful content in buffer.\n@@ -1233,2 +1219,2 @@\n-        protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n-            super(sf, array, offset);\n+        protected BasicComment(CommentStyle cs, UnicodeReader reader, int pos, int endPos) {\n+            super(reader, pos, endPos);\n@@ -1250,2 +1236,1 @@\n-         * @param pos  buffer position in comment.\n-         *\n+         * @param pos buffer position in comment.\n@@ -1260,3 +1245,0 @@\n-         *   LINE starting with \/\/\n-         *   BLOCK starting with \/*\n-         *   JAVADOC starting with \/**\n@@ -1264,1 +1246,1 @@\n-         * @return\n+         * @return style of comment.\n@@ -1276,1 +1258,1 @@\n-            if (!scanned && cs == CommentStyle.JAVADOC) {\n+            if (!scanned) {\n@@ -1279,1 +1261,0 @@\n-\n@@ -1284,1 +1265,5 @@\n-         * Scan JAVADOC comment for details.\n+         * Remove closing star(s) slash from comment.\n+         *\n+         * @param line line reader\n+         *\n+         * @return new line reader if detected otherwise original line reader.\n@@ -1286,4 +1271,3 @@\n-        protected void scanDocComment() {\n-            try {\n-                boolean deprecatedPrefix = false;\n-                accept(\"\/**\");\n+        UnicodeReader trimEndOfComment(UnicodeReader line) {\n+            int pos = line.position();\n+            boolean allWhitespace = true;\n@@ -1291,4 +1275,2 @@\n-                forEachLine:\n-                while (isAvailable()) {\n-                    \/\/ Skip optional WhiteSpace at beginning of line\n-                    skipWhitespace();\n+            while (line.isAvailable()) {\n+                int endPos = line.position();\n@@ -1296,6 +1278,7 @@\n-                    \/\/ Skip optional consecutive Stars\n-                    while (accept('*')) {\n-                        if (is('\/')) {\n-                            return;\n-                        }\n-                    }\n+                if (line.skip('*') != 0 && line.is('\/')) {\n+                    return line.lineReader(allWhitespace ? endPos : pos, endPos);\n+                } else {\n+                    allWhitespace = allWhitespace && line.isWhitespace();\n+                    line.next();\n+                }\n+            }\n@@ -1303,2 +1286,1 @@\n-                    \/\/ Skip optional WhiteSpace after Stars\n-                    skipWhitespace();\n+            line.reset(pos);\n@@ -1306,2 +1288,2 @@\n-                    \/\/ At beginning of line in the JavaDoc sense.\n-                    deprecatedPrefix = deprecatedFlag || accept(\"@deprecated\");\n+            return line;\n+        }\n@@ -1309,10 +1291,11 @@\n-                    if (deprecatedPrefix && isAvailable()) {\n-                        if (Character.isWhitespace(get())) {\n-                            deprecatedFlag = true;\n-                        } else if (accept('*')) {\n-                            if (is('\/')) {\n-                                deprecatedFlag = true;\n-                                return;\n-                            }\n-                        }\n-                    }\n+        \/**\n+         * Trim the first part of the JavaDoc comment.\n+         *\n+         * @param line line reader\n+         *\n+         * @return modified line reader\n+         *\/\n+        UnicodeReader trimJavadocComment(UnicodeReader line) {\n+            line = trimEndOfComment(line);\n+            int pos = line.position();\n+            line.skipWhitespace();\n@@ -1320,5 +1303,3 @@\n-                    \/\/ Skip rest of line\n-                    while (isAvailable()) {\n-                        switch (get()) {\n-                            case '*':\n-                                next();\n+            if (!line.isAvailable()) {\n+                return line;\n+            }\n@@ -1326,3 +1307,3 @@\n-                                if (is('\/')) {\n-                                    return;\n-                                }\n+            if (line.skip('*') == 0) {\n+                line.reset(pos);\n+            }\n@@ -1330,6 +1311,2 @@\n-                                break;\n-                            case '\\r': \/\/ (Spec 3.4)\n-                            case '\\n': \/\/ (Spec 3.4)\n-                                accept('\\r');\n-                                accept('\\n');\n-                                continue forEachLine;\n+            return line;\n+        }\n@@ -1337,8 +1314,15 @@\n-                            default:\n-                                next();\n-                                break;\n-                        }\n-                    } \/\/ rest of line\n-                } \/\/ forEachLine\n-                return;\n-            } finally {\n+        \/**\n+         * Put the line into the buffer.\n+         *\n+         * @param line line reader\n+         *\/\n+        protected void putLine(UnicodeReader line) {\n+            \/\/ ignore, overridden in subclass\n+        }\n+\n+        \/**\n+         * Scan document comment for content.\n+         *\/\n+        protected void scanDocComment() {\n+            if (!scanned) {\n+                deprecatedFlag = false;\n@@ -1346,0 +1330,32 @@\n+\n+                if (!accept(\"\/**\")) {\n+                    return;\n+                }\n+\n+                skip('*');\n+                skipWhitespace();\n+\n+                if (isEOLN()) {\n+                    accept('\\r');\n+                    accept('\\n');\n+                }\n+\n+                while (isAvailable()) {\n+                    UnicodeReader line = lineReader();\n+                    line = trimJavadocComment(line);\n+\n+                    \/\/ If standalone @deprecated tag\n+                    int pos = line.position();\n+                    line.skipWhitespace();\n+\n+                    if (line.accept(\"@deprecated\") &&\n+                            (!line.isAvailable() ||\n+                                    line.isWhitespace() ||\n+                                    line.isEOLN() ||\n+                                    line.get() == EOI)) {\n+                        deprecatedFlag = true;\n+                    }\n+\n+                    line.reset(pos);\n+                    putLine(line);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":102,"deletions":86,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -82,2 +82,1 @@\n-        char[] buf = getRawCharacters(pos, endPos);\n-        return new JavadocComment(style, fac, buf, pos);\n+        return new JavadocComment(style, this, pos, endPos);\n@@ -91,7 +90,0 @@\n-        \/**\n-         * Pattern used to detect a well formed @deprecated tag in a Javadoc\n-         * comment.\n-         *\/\n-        private static final Pattern DEPRECATED_PATTERN =\n-            Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n-\n@@ -109,0 +101,5 @@\n+        \/**\n+         * Indicates if newline is required.\n+         *\/\n+        private boolean firstLine = true;\n+\n@@ -115,2 +112,2 @@\n-        JavadocComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n-            super( cs, sf, array, offset);\n+        JavadocComment(CommentStyle cs, UnicodeReader reader, int pos, int endPos) {\n+            super(cs, reader, pos, endPos);\n@@ -121,1 +118,1 @@\n-         * Add a character to the extraction buffer.\n+         * Add current character or code point from line to the extraction buffer.\n@@ -123,1 +120,1 @@\n-         * @param ch  character to add.\n+         * @param line line reader\n@@ -125,4 +122,9 @@\n-        protected void put(char ch) {\n-            offsetMap.add(sb.length(), offsetPosition());\n-            sb.append(ch);\n-        }\n+        protected void putLine(UnicodeReader line) {\n+            if (firstLine) {\n+                firstLine = false;\n+            } else {\n+                sb.append('\\n');\n+                offsetMap.add(sb.length(), line.position());\n+            }\n+            while (line.isAvailable()) {\n+                offsetMap.add(sb.length(), line.position());\n@@ -130,9 +132,5 @@\n-        \/**\n-         * Add a code point to the extraction buffer.\n-         *\n-         * @param codePoint  code point to add.\n-         *\/\n-        protected void putCodePoint(int codePoint) {\n-            offsetMap.add(sb.length(), offsetPosition());\n-            sb.appendCodePoint(codePoint);\n-        }\n+                if (line.isSurrogate()) {\n+                    sb.appendCodePoint(line.getCodepoint());\n+                } else {\n+                    sb.append(line.get());\n+                }\n@@ -140,8 +138,1 @@\n-        \/**\n-         * Add current character or code point to the extraction buffer.\n-         *\/\n-        protected void put() {\n-            if (isSurrogate()) {\n-                putCodePoint(getCodepoint());\n-            } else {\n-                put(get());\n+                line.next();\n@@ -153,1 +144,1 @@\n-            if (!scanned && cs == CommentStyle.JAVADOC) {\n+            if (!scanned) {\n@@ -174,91 +165,2 @@\n-             try {\n-                 boolean firstLine = true;\n-\n-                 \/\/ Skip over \/*\n-                 accept(\"\/*\");\n-\n-                 \/\/ Consume any number of stars\n-                 skip('*');\n-\n-                 \/\/ Is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n-                 if (is('\/')) {\n-                     docComment = \"\";\n-                     return;\n-                 }\n-\n-                 \/\/ Skip line terminator on the first line of the comment.\n-                 if (isOneOf('\\n', '\\r')) {\n-                     accept('\\r');\n-                     accept('\\n');\n-                     firstLine = false;\n-                 }\n-\n-             outerLoop:\n-                 \/\/ The outerLoop processes the doc comment, looping once\n-                 \/\/ for each line.  For each line, it first strips off\n-                 \/\/ whitespace, then it consumes any stars, then it\n-                 \/\/ puts the rest of the line into the extraction buffer.\n-                 while (isAvailable()) {\n-                     int begin_pos = position();\n-                     \/\/ Consume  whitespace from the beginning of each line.\n-                     skipWhitespace();\n-                     \/\/ Are there stars here?  If so, consume them all\n-                     \/\/ and check for the end of comment.\n-                     if (is('*')) {\n-                         \/\/ skip all of the stars\n-                         skip('*');\n-\n-                         \/\/ check for the closing slash.\n-                         if (accept('\/')) {\n-                             \/\/ We're done with the Javadoc comment\n-                             break outerLoop;\n-                         }\n-                     } else if (!firstLine) {\n-                         \/\/ The current line does not begin with a '*' so we will\n-                         \/\/ treat it as comment\n-                         reset(begin_pos);\n-                     }\n-\n-                 textLoop:\n-                     \/\/ The textLoop processes the rest of the characters\n-                     \/\/ on the line, adding them to the extraction buffer.\n-                     while (isAvailable()) {\n-                         if (accept(\"*\/\")) {\n-                             \/\/ This is the end of the comment, return\n-                             \/\/ the contents of the extraction buffer.\n-                             break outerLoop;\n-                         } else if (isOneOf('\\n', '\\r')) {\n-                             \/\/ We've seen a newline.  Add it to our\n-                             \/\/ buffer and break out of this loop,\n-                             \/\/ starting fresh on a new line.\n-                             put('\\n');\n-                             accept('\\r');\n-                             accept('\\n');\n-                             break textLoop;\n-                         } else if (is('\\f')){\n-                             next();\n-                             break textLoop; \/\/ treat as end of line\n-\n-                         } else {\n-                             \/\/ Add the character to our buffer.\n-                             put();\n-                             next();\n-                         }\n-                     } \/\/ end textLoop\n-                     firstLine = false;\n-                 } \/\/ end outerLoop\n-\n-                 \/\/ If extraction buffer is not empty.\n-                 if (sb.length() > 0) {\n-                     \/\/ Remove trailing asterisks.\n-                     int i = sb.length() - 1;\n-                     while (i > -1 && sb.charAt(i) == '*') {\n-                         i--;\n-                     }\n-                     sb.setLength(i + 1) ;\n-\n-                     \/\/ Store the text of the doc comment\n-                    docComment = sb.toString();\n-                 } else {\n-                    docComment = \"\";\n-                }\n+            try {\n+                super.scanDocComment();\n@@ -266,6 +168,1 @@\n-                scanned = true;\n-\n-                \/\/ Check if comment contains @deprecated comment.\n-                if (docComment != null && DEPRECATED_PATTERN.matcher(docComment).matches()) {\n-                    deprecatedFlag = true;\n-                }\n+                docComment = sb.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":29,"deletions":132,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -276,3 +276,3 @@\n-            LINE,\n-            BLOCK,\n-            JAVADOC,\n+            LINE,       \/\/ Starting with \/\/\n+            BLOCK,      \/\/ starting with \/*\n+            JAVADOC,    \/\/ starting with \/**\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,0 +107,24 @@\n+        this(sf.log, array, length);\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param log     Log for error reporting.\n+     * @param array   array containing contents of source.\n+     * @param length  length of meaningful content in buffer.\n+     *\/\n+    protected UnicodeReader(Log log, char[] array, int length) {\n+        this(log, array, 0, length);\n+    }\n+\n+    \/**\n+      * Constructor.\n+      *\n+      * @param log     Log for error reporting.\n+      * @param array   array containing contents of source.\n+      * @param pos     start of meaningful content in buffer.\n+      * @param endPos  end of meaningful content in buffer.\n+      *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected UnicodeReader(Log log, char[] array, int pos, int endPos) {\n@@ -108,2 +132,2 @@\n-        this.length = length;\n-        this.position = 0;\n+        this.length = endPos;\n+        this.position = pos;\n@@ -115,1 +139,1 @@\n-        this.log = sf.log;\n+        this.log = log;\n@@ -429,0 +453,3 @@\n+    \/**\n+     * Match one of the arguments and advance if a match. Returns true if a match.\n+     *\/\n@@ -435,1 +462,0 @@\n-\n@@ -439,0 +465,28 @@\n+    \/**\n+     * Return a reader which is bracketed by the currect position\n+     * and the next line terminator.\n+     *\n+     * @return a new reader\n+     *\/\n+    protected UnicodeReader lineReader() {\n+        int pos = position;\n+        skipToEOLN();\n+        int endPos = position;\n+        accept('\\r');\n+        accept('\\n');\n+        return lineReader(pos, endPos);\n+    }\n+\n+    \/**\n+     * Return a reader which is bracketed by the {@code pos}\n+     * and {@code endPos}.\n+     *\n+     * @param pos     initial position\n+     * @param endPos  end position\n+     *\n+     * @return a new reader\n+     *\/\n+    protected UnicodeReader lineReader(int pos, int endPos) {\n+        return new UnicodeReader(log, buffer, pos, endPos);\n+    }\n+\n@@ -443,0 +497,2 @@\n+     *\n+     * @return number of characters skipped\n@@ -444,1 +500,2 @@\n-    protected void skip(char ch) {\n+    protected int skip(char ch) {\n+        int count = 0;\n@@ -446,1 +503,1 @@\n-            \/\/ next\n+            count++;\n@@ -448,0 +505,10 @@\n+        return count;\n+    }\n+\n+    \/**\n+     * Is ASCII white space character.\n+     *\n+     * @return true if is ASCII white space character\n+     *\/\n+    protected boolean isWhitespace() {\n+        return isOneOf(' ', '\\t', '\\f');\n@@ -459,0 +526,9 @@\n+    \/**\n+     * Is ASCII line terminator.\n+     *\n+     * @return true if is ASCII line terminator.\n+     *\/\n+    protected boolean isEOLN() {\n+        return isOneOf('\\r', '\\n');\n+    }\n+\n@@ -464,1 +540,1 @@\n-            if (isOneOf('\\r', '\\n')) {\n+            if (isEOLN()) {\n@@ -470,1 +546,0 @@\n-\n@@ -568,0 +643,35 @@\n+    \/**\n+     * Returns a string subset of the input buffer.\n+     * The returned string begins at the {@code beginIndex} and\n+     * extends to the character at index {@code endIndex - 1}.\n+     * Thus the length of the substring is {@code endIndex-beginIndex}.\n+     * This behavior is like\n+     * {@code String.substring(beginIndex, endIndex)}.\n+     * Unicode escape sequences are not translated.\n+     *\n+     * @param  beginIndex the beginning index, inclusive.\n+     * @param  endIndex the ending index, exclusive.\n+     *\n+     * @throws ArrayIndexOutOfBoundsException if either offset is outside of the\n+     *         array bounds\n+     *\/\n+    public String getRawString(int beginIndex, int endIndex) {\n+        return new String(buffer, beginIndex, endIndex - beginIndex);\n+    }\n+\n+    \/**\n+     * Returns a string subset of the input buffer.\n+     * The returned string begins at the {@code position} and\n+     * extends to the character at index {@code length - 1}.\n+     * Thus the length of the substring is {@code length-position}.\n+     * This behavior is like\n+     * {@code String.substring(position, length)}.\n+     * Unicode escape sequences are not translated.\n+     *\n+     * @throws ArrayIndexOutOfBoundsException if either offset is outside of the\n+     *         array bounds\n+     *\/\n+    public String getRawString() {\n+        return getRawString(position, length);\n+    }\n+\n@@ -575,5 +685,0 @@\n-        \/**\n-         * Offset from the beginning of the original reader buffer.\n-         *\/\n-        private final int offset;\n-\n@@ -588,3 +693,3 @@\n-         * @param sf      Scan factory.\n-         * @param array   Array containing contents of source.\n-         * @param offset  Position offset in original source buffer.\n+         * @param reader  existing reader\n+         * @param pos     start of meaningful content in buffer.\n+         * @param endPos  end of meaningful content in buffer.\n@@ -592,3 +697,2 @@\n-        protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {\n-            super(sf, array, array.length);\n-            this.offset = offset;\n+        protected PositionTrackingReader(UnicodeReader reader, int pos, int endPos) {\n+            super(reader.log, reader.buffer, pos, endPos);\n@@ -626,9 +730,0 @@\n-\n-        \/**\n-         * Returns position relative to the original source buffer.\n-         *\n-         * @return\n-         *\/\n-        protected int offsetPosition() {\n-            return position() + offset;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":123,"deletions":28,"binary":false,"changes":151,"status":"modified"}]}