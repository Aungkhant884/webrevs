{"files":[{"patch":"@@ -127,4 +127,4 @@\n-                \/\/ If bytes to write == BLOCK_LENGTH, then we have no\n-                \/\/ left-over data from previous updates and we can create\n-                \/\/ the IntegerModuloP directly from the input buffer.\n-                processBlock(buf, bytesToWrite);\n+                \/\/ Have at least one full block in the buf, process all full blocks\n+                int blockMultipleLength = remaining & (~(BLOCK_LENGTH-1));\n+                processMultipleBlocks(buf, blockMultipleLength);\n+                remaining -= blockMultipleLength;\n@@ -141,0 +141,1 @@\n+                remaining -= bytesToWrite;\n@@ -142,2 +143,0 @@\n-\n-            remaining -= bytesToWrite;\n@@ -258,0 +257,18 @@\n+    private void processMultipleBlocks(ByteBuffer buf, int blockMultipleLength) {\n+        if (buf.hasArray()) {\n+            byte[] input = buf.array();\n+            int offset = buf.arrayOffset() + buf.position();\n+            long[] aLimbs = a.getLimbs();\n+            long[] rLimbs = r.getLimbs();\n+\n+            processMultipleBlocksCheck(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+            processMultipleBlocks(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+            buf.position(offset + blockMultipleLength);\n+        } else {\n+            while (blockMultipleLength >= BLOCK_LENGTH) {\n+                processBlock(buf, BLOCK_LENGTH);\n+                blockMultipleLength -= BLOCK_LENGTH;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Random;\n@@ -39,1 +40,1 @@\n-                final int repeat = 100;\n+                final int repeat = 1000;\n@@ -47,1 +48,1 @@\n-                java.util.Random rnd = new java.util.Random();\n+                Random rnd = new Random();\n@@ -55,0 +56,1 @@\n+                rnd.nextBytes(message);\n@@ -65,1 +67,1 @@\n-                if (rnd.nextBoolean()) {\n+                if (rnd.nextBoolean() && message.length > 16) {\n@@ -67,3 +69,4 @@\n-                        int initDataLen = rnd.nextInt(8, 24);\n-                        authenticator.engineUpdate(message, 0, initDataLen);\n-                        slowUpdate(authenticatorSlow, message, 0, initDataLen);\n+                        int initDataLen = rnd.nextInt(1, 16);\n+                        int initDataOffset = rnd.nextInt(0, message.length - initDataLen);\n+                        fastUpdate(authenticator, rnd, message, initDataOffset, initDataLen);\n+                        slowUpdate(authenticatorSlow, message, initDataOffset, initDataLen);\n@@ -74,2 +77,3 @@\n-                        authenticator.engineUpdate(message, 0, message.length);\n-                        slowUpdate(authenticatorSlow, message, 0, message.length);\n+                        int initDataOffset = rnd.nextInt(0, message.length);\n+                        fastUpdate(authenticator, rnd, message, initDataOffset, message.length - initDataOffset);\n+                        slowUpdate(authenticatorSlow, message, initDataOffset, message.length - initDataOffset);\n@@ -78,1 +82,1 @@\n-                authenticator.engineUpdate(message, 0, message.length);\n+                fastUpdate(authenticator, rnd, message, 0, message.length);\n@@ -90,2 +94,1 @@\n-                len = Math.min(message.length, offset + len);\n-                for (int i = offset; i < len; i++) {\n+                for (int i = offset; i < offset + len; i++) {\n@@ -95,0 +98,26 @@\n+\n+        static void fastUpdate(Poly1305 authenticator, Random rnd, byte[] message, int offset, int len) {\n+                ByteBuffer buf;\n+                switch(rnd.nextInt(4)) {\n+                        case 0: \/\/ byte[]\n+                                authenticator.engineUpdate(message, offset, len);\n+                                break;\n+                        case 1: \/\/ ByteArray with backing array\n+                                buf = ByteBuffer.wrap(message, offset, len)\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                        case 2: \/\/ ByteArray with backing array (non-zero position)\n+                                buf = ByteBuffer.wrap(message, 0, len+offset)\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN)\n+                                                .position(offset);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                        case 3: \/\/ ByteArray without backing array (wont be sent to intrinsic)\n+                                buf = ByteBuffer.wrap(message, offset, len)\n+                                                .asReadOnlyBuffer()\n+                                                .order(java.nio.ByteOrder.LITTLE_ENDIAN);\n+                                authenticator.engineUpdate(buf);\n+                                break;\n+                }\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/java.base\/com\/sun\/crypto\/provider\/Poly1305IntrinsicFuzzTest.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.ByteBuffer;\n@@ -52,1 +53,1 @@\n-    private static MethodHandle polyEngineInit, polyEngineUpdate, polyEngineFinal;\n+    private static MethodHandle polyEngineInit, polyEngineUpdate, polyEngineUpdateBuf, polyEngineFinal;\n@@ -71,0 +72,4 @@\n+            m = polyClazz.getDeclaredMethod(\"engineUpdate\", ByteBuffer.class);\n+            m.setAccessible(true);\n+            polyEngineUpdateBuf = lookup.unreflect(m);\n+\n@@ -86,1 +91,1 @@\n-    public byte[] digest() {\n+    public byte[] digestBytes() {\n@@ -97,0 +102,13 @@\n+\n+    @Benchmark\n+    public byte[] digestBuffer() {\n+        try {\n+            byte[] d = data[index];\n+            index = (index +1) % SET_SIZE;\n+            polyEngineInit.invoke(polyObj, new SecretKeySpec(d, 0, 32, \"Poly1305\"), null);\n+            polyEngineUpdateBuf.invoke(polyObj, ByteBuffer.wrap(d, 0, d.length));\n+            return (byte[])polyEngineFinal.invoke(polyObj);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/Poly1305DigestBench.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}