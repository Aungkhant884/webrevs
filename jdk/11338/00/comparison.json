{"files":[{"patch":"@@ -127,4 +127,4 @@\n-                \/\/ If bytes to write == BLOCK_LENGTH, then we have no\n-                \/\/ left-over data from previous updates and we can create\n-                \/\/ the IntegerModuloP directly from the input buffer.\n-                processBlock(buf, bytesToWrite);\n+                \/\/ Have at least one full block in the buf, process all full blocks\n+                int blockMultipleLength = remaining & (~(BLOCK_LENGTH-1));\n+                processMultipleBlocks(buf, blockMultipleLength);\n+                remaining -= blockMultipleLength;\n@@ -141,0 +141,1 @@\n+                remaining -= bytesToWrite;\n@@ -142,2 +143,0 @@\n-\n-            remaining -= bytesToWrite;\n@@ -258,0 +257,17 @@\n+    private void processMultipleBlocks(ByteBuffer buf, int blockMultipleLength) {\n+        if (buf.hasArray()) {\n+            byte[] input = buf.array();\n+            int offset = buf.arrayOffset();\n+            long[] aLimbs = a.getLimbs();\n+            long[] rLimbs = r.getLimbs();\n+\n+            processMultipleBlocksCheck(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+            processMultipleBlocks(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+        } else {\n+            while (blockMultipleLength > 0) {\n+                processBlock(buf, BLOCK_LENGTH);\n+                blockMultipleLength -= BLOCK_LENGTH;\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Random;\n@@ -39,1 +40,1 @@\n-                final int repeat = 100;\n+                final int repeat = 1000;\n@@ -47,1 +48,1 @@\n-                java.util.Random rnd = new java.util.Random();\n+                Random rnd = new Random();\n@@ -68,1 +69,1 @@\n-                        authenticator.engineUpdate(message, 0, initDataLen);\n+                        fastUpdate(authenticator, rnd, message, 0, initDataLen);\n@@ -74,1 +75,1 @@\n-                        authenticator.engineUpdate(message, 0, message.length);\n+                        fastUpdate(authenticator, rnd, message, 0, message.length);\n@@ -78,1 +79,1 @@\n-                authenticator.engineUpdate(message, 0, message.length);\n+                fastUpdate(authenticator, rnd, message, 0, message.length);\n@@ -95,0 +96,14 @@\n+\n+        static void fastUpdate(Poly1305 authenticator, Random rnd, byte[] message, int offset, int len) {\n+                switch(rnd.nextInt(3)) {\n+                        case 0: \/\/ byte[]\n+                                authenticator.engineUpdate(message, offset, len);\n+                                break;\n+                        case 1: \/\/ ByteArray with backing array\n+                                authenticator.engineUpdate(ByteBuffer.wrap(message, offset, len));\n+                                break;\n+                        case 2: \/\/ ByteArray without backing array (wont be sent to intrinsic)\n+                                authenticator.engineUpdate(ByteBuffer.wrap(message, offset, len).asReadOnlyBuffer());\n+                                break;\n+                }\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/java.base\/com\/sun\/crypto\/provider\/Poly1305IntrinsicFuzzTest.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"}]}