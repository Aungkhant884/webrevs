{"files":[{"patch":"@@ -113,4 +113,2 @@\n-\/\/ For oops and Strings the size of the literal is interesting. For other types, nobody cares.\n-static int literal_size(ConstantPool*) { return 0; }\n-static int literal_size(Klass*)        { return 0; }\n-static int literal_size(nmethod*)      { return 0; }\n+\/\/ Default overload, for types that are uninteresting.\n+template<typename T> static int literal_size(T) { return 0; }\n@@ -123,3 +121,0 @@\n-  \/\/ NOTE: this would over-count if (pre-JDK8) java_lang_Class::has_offset_field() is true,\n-  \/\/ and the String.value array is shared by several Strings. However, starting from JDK8,\n-  \/\/ the String.value array is not shared anymore.\n@@ -129,0 +124,1 @@\n+    \/\/ This may overcount if String.value arrays are shared.\n@@ -238,4 +234,0 @@\n-\/\/\n-\/\/ Note: if you create a new subclass of Hashtable<MyNewType, F>, you will need to\n-\/\/ add a new function static int literal_size(MyNewType lit)\n-\/\/ because I can't get template <class T> int literal_size(T) to pick the specializations for Symbol and oop.\n@@ -321,1 +313,0 @@\n-template class Hashtable<oop, mtSymbol>;\n@@ -325,1 +316,0 @@\n-template class HashtableEntry<oop, mtSymbol>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"}]}