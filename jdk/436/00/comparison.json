{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,3 @@\n-  declare_constant(frame::interpreter_frame_last_sp_offset)         \\\n+  declare_constant(frame::interpreter_frame_last_sp_offset)\n+\n+#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n@@ -71,17 +73,16 @@\n-  declare_constant(VM_Version::CPU_AVX512CD)\n-\n-#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512BW\", CPU_AVX512BW) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512VL\", CPU_AVX512VL) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_SHA\", CPU_SHA)           \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FMA\", CPU_FMA)           \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_VZEROUPPER\", CPU_VZEROUPPER) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VPOPCNTDQ\", CPU_AVX512_VPOPCNTDQ) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VPCLMULQDQ\", CPU_AVX512_VPCLMULQDQ) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VAES\", CPU_AVX512_VAES) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VNNI\", CPU_AVX512_VNNI) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FLUSH\", CPU_FLUSH) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FLUSHOPT\", CPU_FLUSHOPT) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_CLWB\", CPU_CLWB) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VBMI2\", CPU_AVX512_VBMI2) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VBMI\", CPU_AVX512_VBMI)\n+  declare_constant(VM_Version::CPU_AVX512CD)                        \\\n+  declare_constant(VM_Version::CPU_AVX512BW)                        \\\n+  declare_constant(VM_Version::CPU_AVX512VL)                        \\\n+  declare_constant(VM_Version::CPU_SHA)                             \\\n+  declare_constant(VM_Version::CPU_FMA)                             \\\n+  declare_constant(VM_Version::CPU_VZEROUPPER)                      \\\n+  declare_constant(VM_Version::CPU_AVX512_VPOPCNTDQ)                \\\n+  declare_constant(VM_Version::CPU_AVX512_VPCLMULQDQ)               \\\n+  declare_constant(VM_Version::CPU_AVX512_VAES)                     \\\n+  declare_constant(VM_Version::CPU_AVX512_VNNI)                     \\\n+  declare_constant(VM_Version::CPU_FLUSH)                           \\\n+  declare_constant(VM_Version::CPU_FLUSHOPT)                        \\\n+  declare_constant(VM_Version::CPU_CLWB)                            \\\n+  declare_constant(VM_Version::CPU_AVX512_VBMI2)                    \\\n+  declare_constant(VM_Version::CPU_AVX512_VBMI)                     \\\n+  declare_constant(VM_Version::CPU_HV)\n","filename":"src\/hotspot\/cpu\/x86\/vmStructs_x86.hpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+const char* VM_Version::_features_names[] = { FEATURES_NAMES };\n@@ -775,59 +776,8 @@\n-  int res = jio_snprintf(buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\"\n-              \"%s%s%s%s%s%s%s%s%s%s\" \"%s%s%s%s%s%s%s%s%s%s\" \"%s%s%s%s%s%s%s%s%s%s\" \"%s%s%s%s%s%s%s%s%s%s\" \"%s%s%s%s%s%s\",\n-\n-               cores_per_cpu(), threads_per_core(),\n-               cpu_family(), _model, _stepping, os::cpu_microcode_revision(),\n-\n-               (supports_cmov() ? \", cmov\" : \"\"),\n-               (supports_cmpxchg8() ? \", cx8\" : \"\"),\n-               (supports_fxsr() ? \", fxsr\" : \"\"),\n-               (supports_mmx()  ? \", mmx\"  : \"\"),\n-               (supports_sse()  ? \", sse\"  : \"\"),\n-               (supports_sse2() ? \", sse2\" : \"\"),\n-               (supports_sse3() ? \", sse3\" : \"\"),\n-               (supports_ssse3()? \", ssse3\": \"\"),\n-               (supports_sse4_1() ? \", sse4.1\" : \"\"),\n-               (supports_sse4_2() ? \", sse4.2\" : \"\"),\n-\n-               (supports_popcnt() ? \", popcnt\" : \"\"),\n-               (supports_vzeroupper() ? \", vzeroupper\" : \"\"),\n-               (supports_avx()    ? \", avx\" : \"\"),\n-               (supports_avx2()   ? \", avx2\" : \"\"),\n-               (supports_aes()    ? \", aes\" : \"\"),\n-               (supports_clmul()  ? \", clmul\" : \"\"),\n-               (supports_erms()   ? \", erms\" : \"\"),\n-               (supports_rtm()    ? \", rtm\" : \"\"),\n-               (supports_3dnow_prefetch() ? \", 3dnowpref\" : \"\"),\n-               (supports_lzcnt()   ? \", lzcnt\": \"\"),\n-\n-               (supports_sse4a()   ? \", sse4a\": \"\"),\n-               (supports_ht() ? \", ht\": \"\"),\n-               (supports_tsc() ? \", tsc\": \"\"),\n-               (supports_tscinv_bit() ? \", tscinvbit\": \"\"),\n-               (supports_tscinv() ? \", tscinv\": \"\"),\n-               (supports_bmi1() ? \", bmi1\" : \"\"),\n-               (supports_bmi2() ? \", bmi2\" : \"\"),\n-               (supports_adx() ? \", adx\" : \"\"),\n-               (supports_evex() ? \", avx512f\" : \"\"),\n-               (supports_avx512dq() ? \", avx512dq\" : \"\"),\n-\n-               (supports_avx512pf() ? \", avx512pf\" : \"\"),\n-               (supports_avx512er() ? \", avx512er\" : \"\"),\n-               (supports_avx512cd() ? \", avx512cd\" : \"\"),\n-               (supports_avx512bw() ? \", avx512bw\" : \"\"),\n-               (supports_avx512vl() ? \", avx512vl\" : \"\"),\n-               (supports_avx512_vpopcntdq() ? \", avx512_vpopcntdq\" : \"\"),\n-               (supports_avx512_vpclmulqdq() ? \", avx512_vpclmulqdq\" : \"\"),\n-               (supports_avx512_vbmi() ? \", avx512_vbmi\" : \"\"),\n-               (supports_avx512_vbmi2() ? \", avx512_vbmi2\" : \"\"),\n-               (supports_avx512_vaes() ? \", avx512_vaes\" : \"\"),\n-\n-               (supports_avx512_vnni() ? \", avx512_vnni\" : \"\"),\n-               (supports_sha() ? \", sha\" : \"\"),\n-               (supports_fma() ? \", fma\" : \"\"),\n-               (supports_clflush() ? \", clflush\" : \"\"),\n-               (supports_clflushopt() ? \", clflushopt\" : \"\"),\n-               (supports_clwb() ? \", clwb\" : \"\"));\n-\n-  assert(res > 0, \"not enough temporary space allocated\"); \/\/ increase 'buf' size\n+  int res = jio_snprintf(\n+              buf, sizeof(buf),\n+              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+              cores_per_cpu(), threads_per_core(),\n+              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  assert(res > 0, \"not enough temporary space allocated\");\n+  assert(exact_log2(CPU_MAX_FEATURE) + 1 == sizeof(_features_names) \/ sizeof(char*), \"wrong size features_names\");\n+  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":9,"deletions":59,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -301,34 +301,62 @@\n-  enum Feature_Flag {\n-    CPU_CX8      = (1 << 0), \/\/ next bits are from cpuid 1 (EDX)\n-    CPU_CMOV     = (1 << 1),\n-    CPU_FXSR     = (1 << 2),\n-    CPU_HT       = (1 << 3),\n-    CPU_MMX      = (1 << 4),\n-    CPU_3DNOW_PREFETCH = (1 << 5), \/\/ Processor supports 3dnow prefetch and prefetchw instructions\n-                                   \/\/ may not necessarily support other 3dnow instructions\n-    CPU_SSE      = (1 << 6),\n-    CPU_SSE2     = (1 << 7),\n-    CPU_SSE3     = (1 << 8),  \/\/ SSE3 comes from cpuid 1 (ECX)\n-    CPU_SSSE3    = (1 << 9),\n-    CPU_SSE4A    = (1 << 10),\n-    CPU_SSE4_1   = (1 << 11),\n-    CPU_SSE4_2   = (1 << 12),\n-    CPU_POPCNT   = (1 << 13),\n-    CPU_LZCNT    = (1 << 14),\n-    CPU_TSC      = (1 << 15),\n-    CPU_TSCINV   = (1 << 16),\n-    CPU_AVX      = (1 << 17),\n-    CPU_AVX2     = (1 << 18),\n-    CPU_AES      = (1 << 19),\n-    CPU_ERMS     = (1 << 20), \/\/ enhanced 'rep movsb\/stosb' instructions\n-    CPU_CLMUL    = (1 << 21), \/\/ carryless multiply for CRC\n-    CPU_BMI1     = (1 << 22),\n-    CPU_BMI2     = (1 << 23),\n-    CPU_RTM      = (1 << 24), \/\/ Restricted Transactional Memory instructions\n-    CPU_ADX      = (1 << 25),\n-    CPU_AVX512F  = (1 << 26), \/\/ AVX 512bit foundation instructions\n-    CPU_AVX512DQ = (1 << 27),\n-    CPU_AVX512PF = (1 << 28),\n-    CPU_AVX512ER = (1 << 29),\n-    CPU_AVX512CD = (1 << 30)\n-    \/\/ Keeping sign bit 31 unassigned.\n+  enum Feature_Flag : uint64_t {\n+    CPU_CX8               = (1ULL << 0), \/\/ next bits are from cpuid 1 (EDX)\n+    CPU_CMOV              = (1ULL << 1),\n+    CPU_FXSR              = (1ULL << 2),\n+    CPU_HT                = (1ULL << 3),\n+\n+    CPU_MMX               = (1ULL << 4),\n+    CPU_3DNOW_PREFETCH    = (1ULL << 5), \/\/ Processor supports 3dnow prefetch and prefetchw instructions\n+                                         \/\/ may not necessarily support other 3dnow instructions\n+    CPU_SSE               = (1ULL << 6),\n+    CPU_SSE2              = (1ULL << 7),\n+\n+    CPU_SSE3              = (1ULL << 8),  \/\/ SSE3 comes from cpuid 1 (ECX)\n+    CPU_SSSE3             = (1ULL << 9),\n+    CPU_SSE4A             = (1ULL << 10),\n+    CPU_SSE4_1            = (1ULL << 11),\n+\n+    CPU_SSE4_2            = (1ULL << 12),\n+    CPU_POPCNT            = (1ULL << 13),\n+    CPU_LZCNT             = (1ULL << 14),\n+    CPU_TSC               = (1ULL << 15),\n+\n+    CPU_TSCINV_BIT        = (1ULL << 16),\n+    CPU_TSCINV            = (1ULL << 17),\n+    CPU_AVX               = (1ULL << 18),\n+    CPU_AVX2              = (1ULL << 19),\n+\n+    CPU_AES               = (1ULL << 20),\n+    CPU_ERMS              = (1ULL << 21), \/\/ enhanced 'rep movsb\/stosb' instructions\n+    CPU_CLMUL             = (1ULL << 22), \/\/ carryless multiply for CRC\n+    CPU_BMI1              = (1ULL << 23),\n+\n+    CPU_BMI2              = (1ULL << 24),\n+    CPU_RTM               = (1ULL << 25), \/\/ Restricted Transactional Memory instructions\n+    CPU_ADX               = (1ULL << 26),\n+    CPU_AVX512F           = (1ULL << 27), \/\/ AVX 512bit foundation instructions\n+\n+    CPU_AVX512DQ          = (1ULL << 28),\n+    CPU_AVX512PF          = (1ULL << 29),\n+    CPU_AVX512ER          = (1ULL << 30),\n+    CPU_AVX512CD          = (1ULL << 31),\n+\n+    CPU_AVX512BW          = (1ULL << 32), \/\/ Byte and word vector instructions\n+    CPU_AVX512VL          = (1ULL << 33), \/\/ EVEX instructions with smaller vector length\n+    CPU_SHA               = (1ULL << 34), \/\/ SHA instructions\n+    CPU_FMA               = (1ULL << 35), \/\/ FMA instructions\n+\n+    CPU_VZEROUPPER        = (1ULL << 36), \/\/ Vzeroupper instruction\n+    CPU_AVX512_VPOPCNTDQ  = (1ULL << 37), \/\/ Vector popcount\n+    CPU_AVX512_VPCLMULQDQ = (1ULL << 38), \/\/ Vector carryless multiplication\n+    CPU_AVX512_VAES       = (1ULL << 39), \/\/ Vector AES instruction\n+\n+    CPU_AVX512_VNNI       = (1ULL << 40), \/\/ Vector Neural Network Instructions\n+    CPU_FLUSH             = (1ULL << 41), \/\/ flush instruction\n+    CPU_FLUSHOPT          = (1ULL << 42), \/\/ flusopth instruction\n+    CPU_CLWB              = (1ULL << 43), \/\/ clwb instruction\n+\n+    CPU_AVX512_VBMI2      = (1ULL << 44), \/\/ VBMI2 shift left double instructions\n+    CPU_AVX512_VBMI       = (1ULL << 45), \/\/ Vector BMI instructions\n+    CPU_HV                = (1ULL << 46), \/\/ Hypervisor instructions\n+\n+    CPU_MAX_FEATURE       = CPU_HV\n@@ -337,17 +365,17 @@\n-#define CPU_AVX512BW          ((uint64_t)UCONST64(   0x100000000)) \/\/ enums are limited to 31 bit\n-#define CPU_AVX512VL          ((uint64_t)UCONST64(   0x200000000)) \/\/ EVEX instructions with smaller vector length\n-#define CPU_SHA               ((uint64_t)UCONST64(   0x400000000)) \/\/ SHA instructions\n-#define CPU_FMA               ((uint64_t)UCONST64(   0x800000000)) \/\/ FMA instructions\n-#define CPU_VZEROUPPER        ((uint64_t)UCONST64(  0x1000000000)) \/\/ Vzeroupper instruction\n-#define CPU_AVX512_VPOPCNTDQ  ((uint64_t)UCONST64(  0x2000000000)) \/\/ Vector popcount\n-#define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(  0x4000000000)) \/\/ Vector carryless multiplication\n-#define CPU_AVX512_VAES       ((uint64_t)UCONST64(  0x8000000000)) \/\/ Vector AES instructions\n-#define CPU_AVX512_VNNI       ((uint64_t)UCONST64( 0x10000000000)) \/\/ Vector Neural Network Instructions\n-#define CPU_FLUSH             ((uint64_t)UCONST64( 0x20000000000)) \/\/ flush instruction\n-#define CPU_FLUSHOPT          ((uint64_t)UCONST64( 0x40000000000)) \/\/ flushopt instruction\n-#define CPU_CLWB              ((uint64_t)UCONST64( 0x80000000000)) \/\/ clwb instruction\n-#define CPU_AVX512_VBMI2      ((uint64_t)UCONST64(0x100000000000)) \/\/ VBMI2 shift left double instructions\n-#define CPU_AVX512_VBMI       ((uint64_t)UCONST64(0x200000000000)) \/\/ Vector BMI instructions\n-#define CPU_HV_PRESENT        ((uint64_t)UCONST64(0x400000000000)) \/\/ for hypervisor detection\n-\n-\/\/ NB! When adding new CPU feature detection consider updating vmStructs_x86.hpp, vmStructs_jvmci.hpp, and VM_Version::get_processor_features().\n+#define FEATURES_NAMES \\\n+    \"cx8\",          \"cmov\",             \"fxsr\",              \"ht\",          \\\n+    \"mmx\",          \"3dnowpref\",        \"sse\",               \"sse2\",        \\\n+    \"sse3\",         \"ssse3\",            \"sse4a\",             \"sse4.1\",      \\\n+    \"sse4.2\",       \"popcnt\",           \"lzcnt\",             \"tsc\",         \\\n+    \"tscinvbit\",    \"tscinv\",           \"avx\",               \"avx2\",        \\\n+    \"aes\",          \"erms\",             \"clmul\",             \"bmi1\",        \\\n+    \"bmi2\",         \"rtm\",              \"adx\",               \"avx512f\",     \\\n+    \"avx512dq\",     \"avx512pf\",         \"avx512er\",          \"avx512cd\",    \\\n+    \"avx512bw\",     \"avx512vl\",         \"sha\",               \"fma\",         \\\n+    \"vzeroupper\",   \"avx512_vpopcntdq\", \"avx512_vpclmulqdq\", \"avx512_vaes\", \\\n+    \"avx512_vnni\",  \"clflush\",          \"clflushopt\",        \"clwb\",        \\\n+    \"avx512_vmbi2\", \"avx512_vmbi\",      \"hv\"\n+\n+  static const char* _features_names[];\n+\n+  \/\/ NB! When adding new CPU feature detection consider updating vmStructs_x86.hpp, vmStructs_jvmci.hpp, and VM_Version::get_processor_features().\n@@ -585,1 +613,1 @@\n-      result |= CPU_HV_PRESENT;\n+      result |= CPU_HV;\n@@ -591,1 +619,1 @@\n-      result |= CPU_TSCINV;\n+      result |= CPU_TSCINV_BIT;\n@@ -621,0 +649,1 @@\n+\n@@ -644,0 +673,7 @@\n+    \/\/ Composite features.\n+    if (supports_tscinv_bit() &&\n+        ((is_amd_family() && !is_amd_Barcelona()) ||\n+         is_intel_tsc_synched_at_init())) {\n+      result |= CPU_TSCINV;\n+    }\n+\n@@ -830,32 +866,32 @@\n-  static bool supports_cpuid()    { return _features  != 0; }\n-  static bool supports_cmpxchg8() { return (_features & CPU_CX8) != 0; }\n-  static bool supports_cmov()     { return (_features & CPU_CMOV) != 0; }\n-  static bool supports_fxsr()     { return (_features & CPU_FXSR) != 0; }\n-  static bool supports_ht()       { return (_features & CPU_HT) != 0; }\n-  static bool supports_mmx()      { return (_features & CPU_MMX) != 0; }\n-  static bool supports_sse()      { return (_features & CPU_SSE) != 0; }\n-  static bool supports_sse2()     { return (_features & CPU_SSE2) != 0; }\n-  static bool supports_sse3()     { return (_features & CPU_SSE3) != 0; }\n-  static bool supports_ssse3()    { return (_features & CPU_SSSE3)!= 0; }\n-  static bool supports_sse4_1()   { return (_features & CPU_SSE4_1) != 0; }\n-  static bool supports_sse4_2()   { return (_features & CPU_SSE4_2) != 0; }\n-  static bool supports_popcnt()   { return (_features & CPU_POPCNT) != 0; }\n-  static bool supports_avx()      { return (_features & CPU_AVX) != 0; }\n-  static bool supports_avx2()     { return (_features & CPU_AVX2) != 0; }\n-  static bool supports_tsc()      { return (_features & CPU_TSC)    != 0; }\n-  static bool supports_aes()      { return (_features & CPU_AES) != 0; }\n-  static bool supports_erms()     { return (_features & CPU_ERMS) != 0; }\n-  static bool supports_clmul()    { return (_features & CPU_CLMUL) != 0; }\n-  static bool supports_rtm()      { return (_features & CPU_RTM) != 0; }\n-  static bool supports_bmi1()     { return (_features & CPU_BMI1) != 0; }\n-  static bool supports_bmi2()     { return (_features & CPU_BMI2) != 0; }\n-  static bool supports_adx()      { return (_features & CPU_ADX) != 0; }\n-  static bool supports_evex()     { return (_features & CPU_AVX512F) != 0; }\n-  static bool supports_avx512dq() { return (_features & CPU_AVX512DQ) != 0; }\n-  static bool supports_avx512pf() { return (_features & CPU_AVX512PF) != 0; }\n-  static bool supports_avx512er() { return (_features & CPU_AVX512ER) != 0; }\n-  static bool supports_avx512cd() { return (_features & CPU_AVX512CD) != 0; }\n-  static bool supports_avx512bw() { return (_features & CPU_AVX512BW) != 0; }\n-  static bool supports_avx512vl() { return (_features & CPU_AVX512VL) != 0; }\n-  static bool supports_avx512vlbw() { return (supports_evex() && supports_avx512bw() && supports_avx512vl()); }\n-  static bool supports_avx512vldq() { return (supports_evex() && supports_avx512dq() && supports_avx512vl()); }\n+  static bool supports_cpuid()        { return _features  != 0; }\n+  static bool supports_cmpxchg8()     { return (_features & CPU_CX8) != 0; }\n+  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }\n+  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }\n+  static bool supports_ht()           { return (_features & CPU_HT) != 0; }\n+  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }\n+  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }\n+  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }\n+  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }\n+  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }\n+  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }\n+  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }\n+  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }\n+  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }\n+  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }\n+  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }\n+  static bool supports_aes()          { return (_features & CPU_AES) != 0; }\n+  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }\n+  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }\n+  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }\n+  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }\n+  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }\n+  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }\n+  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }\n+  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }\n+  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }\n+  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }\n+  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }\n+  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }\n+  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }\n+  static bool supports_avx512vlbw()   { return (supports_evex() && supports_avx512bw() && supports_avx512vl()); }\n+  static bool supports_avx512vldq()   { return (supports_evex() && supports_avx512dq() && supports_avx512vl()); }\n@@ -864,7 +900,7 @@\n-  static bool supports_avx512novl() { return (supports_evex() && !supports_avx512vl()); }\n-  static bool supports_avx512nobw() { return (supports_evex() && !supports_avx512bw()); }\n-  static bool supports_avx256only() { return (supports_avx2() && !supports_evex()); }\n-  static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) && !supports_evex()); }\n-  static bool supports_sha()        { return (_features & CPU_SHA) != 0; }\n-  static bool supports_fma()        { return (_features & CPU_FMA) != 0 && supports_avx(); }\n-  static bool supports_vzeroupper() { return (_features & CPU_VZEROUPPER) != 0; }\n+  static bool supports_avx512novl()   { return (supports_evex() && !supports_avx512vl()); }\n+  static bool supports_avx512nobw()   { return (supports_evex() && !supports_avx512bw()); }\n+  static bool supports_avx256only()   { return (supports_avx2() && !supports_evex()); }\n+  static bool supports_avxonly()      { return ((supports_avx2() || supports_avx()) && !supports_evex()); }\n+  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }\n+  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }\n+  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }\n@@ -873,5 +909,5 @@\n-  static bool supports_avx512_vaes()       { return (_features & CPU_AVX512_VAES) != 0; }\n-  static bool supports_avx512_vnni()       { return (_features & CPU_AVX512_VNNI) != 0; }\n-  static bool supports_avx512_vbmi()       { return (_features & CPU_AVX512_VBMI) != 0; }\n-  static bool supports_avx512_vbmi2()      { return (_features & CPU_AVX512_VBMI2) != 0; }\n-  static bool supports_hv()                { return (_features & CPU_HV_PRESENT) != 0; }\n+  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }\n+  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }\n+  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }\n+  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }\n+  static bool supports_hv()           { return (_features & CPU_HV) != 0; }\n@@ -920,1 +956,1 @@\n-    return (_features & CPU_TSCINV) != 0;\n+    return (_features & CPU_TSCINV_BIT) != 0;\n@@ -923,3 +959,1 @@\n-    return supports_tscinv_bit() &&\n-      ((is_amd_family() && !is_amd_Barcelona()) ||\n-        is_intel_tsc_synched_at_init());\n+    return (_features & CPU_TSCINV) != 0;\n@@ -1001,1 +1035,1 @@\n-  \/\/ clwb is an optional, intel-specific instruction optional which\n+  \/\/ clwb is an optional intel-specific instruction which\n@@ -1003,2 +1037,2 @@\n-  \/\/ synchronize with other memory ops. so, it also needs a preceding\n-  \/\/ and trailing StoreStore fence.\n+  \/\/ synchronize with other memory ops. so, it needs preceding\n+  \/\/ and trailing StoreStore fences.\n@@ -1020,2 +1054,0 @@\n-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }\n-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }\n@@ -1024,2 +1056,0 @@\n-  static bool supports_clflushopt() { return false; }\n-  static bool supports_clwb() { return false; }\n@@ -1027,0 +1057,3 @@\n+  \/\/ Note: CPU_FLUSHOPT and CPU_CLWB bits should always be zero for 32-bit\n+  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }\n+  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":141,"deletions":108,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-  static_field(CompilerToVM::Data,             SharedRuntime_deopt_blob_unpack_with_exception_in_tls,        address)                       \\\n+  static_field(CompilerToVM::Data,             SharedRuntime_deopt_blob_unpack_with_exception_in_tls,                                \\\n+                                                                                       address)                                      \\\n@@ -755,1 +756,3 @@\n-  declare_constant(frame::interpreter_frame_last_sp_offset)         \\\n+  declare_constant(frame::interpreter_frame_last_sp_offset)\n+\n+#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n@@ -786,17 +789,16 @@\n-  declare_constant(VM_Version::CPU_AVX512CD)\n-\n-#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512BW\", CPU_AVX512BW) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512VL\", CPU_AVX512VL) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_SHA\", CPU_SHA)           \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FMA\", CPU_FMA)           \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_VZEROUPPER\", CPU_VZEROUPPER) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VPOPCNTDQ\", CPU_AVX512_VPOPCNTDQ) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VPCLMULQDQ\", CPU_AVX512_VPCLMULQDQ) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VAES\", CPU_AVX512_VAES) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VNNI\", CPU_AVX512_VNNI) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FLUSH\", CPU_FLUSH) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_FLUSHOPT\", CPU_FLUSHOPT) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_CLWB\", CPU_CLWB) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VBMI2\", CPU_AVX512_VBMI2) \\\n-  declare_preprocessor_constant(\"VM_Version::CPU_AVX512_VBMI\", CPU_AVX512_VBMI)\n+  declare_constant(VM_Version::CPU_AVX512CD)                        \\\n+  declare_constant(VM_Version::CPU_AVX512BW)                        \\\n+  declare_constant(VM_Version::CPU_AVX512VL)                        \\\n+  declare_constant(VM_Version::CPU_SHA)                             \\\n+  declare_constant(VM_Version::CPU_FMA)                             \\\n+  declare_constant(VM_Version::CPU_VZEROUPPER)                      \\\n+  declare_constant(VM_Version::CPU_AVX512_VPOPCNTDQ)                \\\n+  declare_constant(VM_Version::CPU_AVX512_VPCLMULQDQ)               \\\n+  declare_constant(VM_Version::CPU_AVX512_VAES)                     \\\n+  declare_constant(VM_Version::CPU_AVX512_VNNI)                     \\\n+  declare_constant(VM_Version::CPU_FLUSH)                           \\\n+  declare_constant(VM_Version::CPU_FLUSHOPT)                        \\\n+  declare_constant(VM_Version::CPU_CLWB)                            \\\n+  declare_constant(VM_Version::CPU_AVX512_VBMI2)                    \\\n+  declare_constant(VM_Version::CPU_AVX512_VBMI)                     \\\n+  declare_constant(VM_Version::CPU_HV)\n@@ -825,1 +827,0 @@\n-\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -294,0 +294,16 @@\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n+  uint64_t features = _features;\n+  uint features_names_index = 0;\n+\n+  while (features != 0) {\n+    if (features & 1) {\n+      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buflen -= res;\n+    }\n+    features >>= 1;\n+    ++features_names_index;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -122,7 +122,3 @@\n-  static uint64_t features() {\n-    return _features;\n-  }\n-\n-  static const char* features_string() {\n-    return _features_string;\n-  }\n+  static uint64_t features()           { return _features; }\n+  static const char* features_string() { return _features_string; }\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}