{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -105,2 +104,2 @@\n-        private volatile Map<Class<?>, T> forward = Map.of();\n-        private volatile Map<Class<?>, T> reverse = Map.of();\n+        private Map<Class<?>, T> forward;\n+        private Map<Class<?>, T> reverse;\n@@ -109,1 +108,1 @@\n-            return forward.get(c);\n+            return get(forward, c);\n@@ -113,1 +112,1 @@\n-            return reverse.get(c);\n+            return get(reverse, c);\n@@ -116,17 +115,14 @@\n-        T compute(Map<Class<?>, T> map, final VarHandle mapHandle, final Class<?> c, final Function<Class<?>, T> compute) {\n-            if (!map.containsKey(c)) {\n-                final T value = compute.apply(c);\n-                if (value == null) {\n-                    return null;\n-                }\n-                do {\n-                    final var entries = new ArrayList<>(map.entrySet());\n-                    entries.add(Map.entry(c, value));\n-                    @SuppressWarnings(\"rawtypes\")\n-                    final var newEntries = entries.toArray(new Map.Entry[0]);\n-                    @SuppressWarnings(\"unchecked\")\n-                    final var newMap = Map.ofEntries(newEntries);\n-                    @SuppressWarnings(\"unchecked\")\n-                    final var witness = (Map<Class<?>, T>)mapHandle.compareAndExchange(this, map, newMap);\n-                    if (witness == map) {\n-                        return value;\n+        private T get(final Map<Class<?>, T> m, final Class<?> c) {\n+            return m == null ? null : m.get(c);\n+        }\n+\n+        private T compute(final VarHandle mapHandle, final Class<?> c, final Function<Class<?>, T> compute) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<Class<?>, T> map = (Map<Class<?>, T>) mapHandle.getVolatile(this);\n+            T value;\n+            T newValue = null;\n+            while ((value = get(map, c)) == null) {\n+                if (newValue == null) {\n+                    newValue = compute.apply(c);\n+                    if (newValue == null) {\n+                        break;\n@@ -134,2 +130,17 @@\n-                    map = witness;\n-                } while (!map.containsKey(c));\n+                }\n+                final Map<Class<?>, T> newMap;\n+                if (map == null) {\n+                    newMap = Map.of(c, newValue);\n+                } else {\n+                    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+                    final Map.Entry<Class<?>, T>[] entries = map.entrySet().toArray(new Map.Entry[map.size() + 1]);\n+                    entries[map.size()] = Map.entry(c, newValue);\n+                    newMap = Map.ofEntries(entries);\n+                }\n+                @SuppressWarnings(\"unchecked\")\n+                final var witness = (Map<Class<?>, T>) mapHandle.compareAndExchange(this, map, newMap);\n+                if (witness == map) {\n+                    value = newValue;\n+                    break;\n+                }\n+                map = witness;\n@@ -137,1 +148,1 @@\n-            return map.get(c);\n+            return value;\n@@ -141,1 +152,1 @@\n-            return compute(forward, FORWARD, c, compute);\n+            return compute(FORWARD, c, compute);\n@@ -145,1 +156,1 @@\n-            return compute(reverse, REVERSE, c, compute);\n+            return compute(REVERSE, c, compute);\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/BiClassValue.java","additions":38,"deletions":27,"binary":false,"changes":65,"status":"modified"}]}