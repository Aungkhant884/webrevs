{"files":[{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.dynalink;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.dynalink.internal.AccessControlContextFactory;\n+\n+import static jdk.dynalink.internal.InternalTypeUtilities.canReferenceDirectly;\n+\n+\/**\n+ * Similar to ClassValue, but lazily associates a computed value with\n+ * (potentially) every pair of types.\n+ * @param <T> the value to associate with pairs of types.\n+ *\/\n+final class BiClassValue<T> {\n+    \/**\n+     * Creates a new BiClassValue that uses the specified binary function to\n+     * compute the values.\n+     * @param compute the binary function to compute the values. Its invocation\n+     *                semantics is similar to that of {@code ConcurrentMap.computeIfAbsent}.\n+     *                Additionally, if the pair of types passed as parameters are\n+     *                from unrelated class loaders, the computed value is not\n+     *                cached at all and the function might be reinvoked with\n+     *                the same parameters in the future. A null return value is\n+     *                allowed, but not cached.\n+     * @param <T> the type of the values\n+     * @return a new BiClassValue that computes the values using the passed\n+     * function.\n+     *\/\n+    static <T> BiClassValue<T> computing(final BiFunction<Class<?>, Class<?>, T> compute) {\n+        return new BiClassValue<>(compute);\n+    }\n+\n+    \/**\n+     * A type-specific map that stores the values specific to pairs of types\n+     * which include its class in one of the positions of the pair. Internally,\n+     * it uses at most two maps named \"forward\" and \"reverse\". A BiClassValues\n+     * for class C1 can store values for (C1, Cy) in its forward map as well\n+     * as values for (Cx, C1) in its reverse map. The reason for this scheme\n+     * is to avoid creating unwanted strong references from a parent class\n+     * loader to a child class loader. If for a pair of classes (C1, C2)\n+     * either C1 and C2 are in the same class loader, or C2 is in parent of C1,\n+     * or C2 is a system class, forward map of C1's BiClassValues is used for\n+     * storing the computed value. If C1 is in parent of C2, or C1 is a system\n+     * class, reverse map of C2's BiClassValues is used for storing. If the\n+     * class loaders are unrelated, the computed value is not cached and will\n+     * be recomputed on every evaluation.\n+     * NOTE that while every instance of this class is type-specific, it does\n+     * not store a reference to the type Class object itself, only its\n+     * ClassLoader; BiClassValuesRoot create the association from a type Class\n+     * object to its BiClassValues'.\n+     * @param <T> the type of the values\n+     *\/\n+    private final static class BiClassValues<T> {\n+        \/\/ These will be used for compareAndSet on forward and reverse fields.\n+        private static final VarHandle FORWARD;\n+        private static final VarHandle REVERSE;\n+        static {\n+            final MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            try {\n+                FORWARD = lookup.findVarHandle(BiClassValues.class, \"forward\", Map.class);\n+                REVERSE = lookup.findVarHandle(BiClassValues.class, \"reverse\", Map.class);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        final ClassLoader classLoader;\n+        private volatile Map<Class<?>, T> forward;\n+        private volatile Map<Class<?>, T> reverse;\n+\n+        BiClassValues(final ClassLoader classLoader) {\n+            this.classLoader = classLoader;\n+        }\n+\n+        T getForwardValue(final Class<?> c) {\n+            return getValue(forward, c);\n+        }\n+\n+        T getReverseValue(final Class<?> c) {\n+            return getValue(reverse, c);\n+        }\n+\n+        private static <T> T getValue(Map<Class<?>, T> m, final Class<?> c) {\n+            return m != null ? m.get(c) : null;\n+        }\n+\n+        T computeForward(final Class<?> c, Function<Class<?>, T> compute) {\n+            while (forward == null) {\n+                FORWARD.compareAndSet(this, null, new ConcurrentHashMap<Class<?>, T>());\n+            }\n+            return forward.computeIfAbsent(c, compute);\n+        }\n+\n+        T computeReverse(final Class<?> c, Function<Class<?>, T> compute) {\n+            while (reverse == null) {\n+                REVERSE.compareAndSet(this, null, new ConcurrentHashMap<Class<?>, T>());\n+            }\n+            return reverse.computeIfAbsent(c, compute);\n+        }\n+    }\n+\n+    \/\/ A named class used for \"root\" field so it can be static so it doesn't\n+    \/\/ gain a synthetic this$0 reference as that'd cause a memory leak through\n+    \/\/ unwanted anchoring to a GC root when used with system classes.\n+    private static final class BiClassValuesRoot<T> extends ClassValue<BiClassValues<T>> {\n+        @Override protected BiClassValues<T> computeValue(Class<?> type) {\n+            return new BiClassValues<>(getClassLoader(type));\n+        }\n+    }\n+\n+    private final BiClassValuesRoot<T> root = new BiClassValuesRoot<>();\n+    private final BiFunction<Class<?>, Class<?>, T> compute;\n+\n+    private BiClassValue(final BiFunction<Class<?>, Class<?>, T> compute) {\n+        this.compute = Objects.requireNonNull(compute);\n+    }\n+\n+    final T get(final Class<?> c1, final Class<?> c2) {\n+        \/\/ Most likely case: it is in the forward map of c1's BiClassValues\n+        final BiClassValues<T> cv1 = root.get(c1);\n+        final T v1 = cv1.getForwardValue(c2);\n+        if (v1 != null) {\n+            return v1;\n+        }\n+\n+        \/\/ Next likely case: it is in the reverse map of c2's BiClassValues\n+        final BiClassValues<T> cv2 = root.get(c2);\n+        final T v2 = cv2.getReverseValue(c1);\n+        if (v2 != null) {\n+            return v2;\n+        }\n+\n+        \/\/ Value is uncached, compute it and cache if possible.\n+        if (canReferenceDirectly(cv1.classLoader, cv2.classLoader)) {\n+            \/\/ cl1 can see cl2, store value for (c1, c2) in cv1's forward map\n+            return cv1.computeForward(c2, cy -> compute.apply(c1, cy));\n+        } else if (canReferenceDirectly(cv2.classLoader, cv1.classLoader)) {\n+            \/\/ cl2 can see cl1, store value for (c1, c2) in cv2's reverse map\n+            return cv2.computeReverse(c1, cx -> compute.apply(cx, c2));\n+        }\n+\n+        \/\/ Class loaders are unrelated; compute and return uncached.\n+        return compute.apply(c1, c2);\n+    }\n+\n+    private static final AccessControlContext GET_CLASS_LOADER_CONTEXT =\n+        AccessControlContextFactory.createAccessControlContext(\"getClassLoader\");\n+\n+    private static ClassLoader getClassLoader(final Class<?> clazz) {\n+        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) clazz::getClassLoader, GET_CLASS_LOADER_CONTEXT);\n+    }\n+}\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/BiClassValue.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file is available under and governed by the GNU General Public\n- * License version 2 only, as published by the Free Software Foundation.\n- * However, the following notice accompanied the original version of this\n- * file, and Oracle licenses the original version of this file under the BSD\n- * license:\n- *\/\n-\/*\n-   Copyright 2009-2013 Attila Szegedi\n-\n-   Redistribution and use in source and binary forms, with or without\n-   modification, are permitted provided that the following conditions are\n-   met:\n-   * Redistributions of source code must retain the above copyright\n-     notice, this list of conditions and the following disclaimer.\n-   * Redistributions in binary form must reproduce the above copyright\n-     notice, this list of conditions and the following disclaimer in the\n-     documentation and\/or other materials provided with the distribution.\n-   * Neither the name of the copyright holder nor the names of\n-     contributors may be used to endorse or promote products derived from\n-     this software without specific prior written permission.\n-\n-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n-   IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n-   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n-   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER\n-   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n-   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n-   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n-   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n-   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n-   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n-   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*\/\n-\n-package jdk.dynalink;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import jdk.dynalink.internal.AccessControlContextFactory;\n-import jdk.dynalink.internal.InternalTypeUtilities;\n-\n-\/**\n- * A dual map that can either strongly or weakly reference a given class depending on whether the class is visible from\n- * a class loader or not.\n- *\n- * @param <T> the type of the values in the map\n- *\/\n-abstract class ClassMap<T> {\n-    private static final AccessControlContext GET_CLASS_LOADER_CONTEXT =\n-            AccessControlContextFactory.createAccessControlContext(\"getClassLoader\");\n-\n-    private final ConcurrentMap<Class<?>, T> map = new ConcurrentHashMap<>();\n-    private final Map<Class<?>, Reference<T>> weakMap = new WeakHashMap<>();\n-    private final ClassLoader classLoader;\n-\n-    \/**\n-     * Creates a new class map. It will use strong references for all keys and values where the key is a class visible\n-     * from the class loader, and will use weak keys and soft values for all other classes.\n-     *\n-     * @param classLoader the classloader that determines strong referenceability.\n-     *\/\n-    ClassMap(final ClassLoader classLoader) {\n-        this.classLoader = classLoader;\n-    }\n-\n-    \/**\n-     * Compute the value associated with the given class. It is possible that the method will be invoked several times\n-     * (or even concurrently) for the same class parameter.\n-     *\n-     * @param clazz the class to compute the value for\n-     * @return the return value. Must not be null.\n-     *\/\n-    abstract T computeValue(Class<?> clazz);\n-\n-    \/**\n-     * Returns the value associated with the class\n-     *\n-     * @param clazz the class\n-     * @return the value associated with the class\n-     *\/\n-    T get(final Class<?> clazz) {\n-        \/\/ Check in fastest first - objects we're allowed to strongly reference\n-        final T v = map.get(clazz);\n-        if(v != null) {\n-            return v;\n-        }\n-        \/\/ Check objects we're not allowed to strongly reference\n-        Reference<T> ref;\n-        synchronized(weakMap) {\n-            ref = weakMap.get(clazz);\n-        }\n-        if(ref != null) {\n-            final T refv = ref.get();\n-            if(refv != null) {\n-                return refv;\n-            }\n-        }\n-        \/\/ Not found in either place; create a new value\n-        final T newV = computeValue(clazz);\n-        assert newV != null;\n-\n-        final Boolean canReferenceDirectly = AccessController.doPrivileged(\n-            (PrivilegedAction<Boolean>) () -> InternalTypeUtilities.canReferenceDirectly(classLoader, clazz.getClassLoader()),\n-            GET_CLASS_LOADER_CONTEXT);\n-\n-        \/\/ If allowed to strongly reference, put it in the fast map\n-        if(canReferenceDirectly) {\n-            final T oldV = map.putIfAbsent(clazz, newV);\n-            return oldV != null ? oldV : newV;\n-        }\n-        \/\/ Otherwise, put it into the weak map\n-        synchronized(weakMap) {\n-            ref = weakMap.get(clazz);\n-            if(ref != null) {\n-                final T oldV = ref.get();\n-                if(oldV != null) {\n-                    return oldV;\n-                }\n-            }\n-            weakMap.put(clazz, new SoftReference<>(newV));\n-            return newV;\n-        }\n-    }\n-}\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/ClassMap.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -68,3 +68,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -74,1 +71,0 @@\n-import jdk.dynalink.internal.AccessControlContextFactory;\n@@ -89,4 +85,0 @@\n-    private static final AccessControlContext GET_CLASS_LOADER_CONTEXT =\n-            AccessControlContextFactory.createAccessControlContext(\"getClassLoader\");\n-\n-    private final GuardingTypeConverterFactory[] factories;\n@@ -96,57 +88,3 @@\n-    private final ClassValue<ClassMap<MethodHandle>> converterMap = new ClassValue<>() {\n-        @Override\n-        protected ClassMap<MethodHandle> computeValue(final Class<?> sourceType) {\n-            return new ClassMap<>(getClassLoader(sourceType)) {\n-                @Override\n-                protected MethodHandle computeValue(final Class<?> targetType) {\n-                    try {\n-                        return createConverter(sourceType, targetType);\n-                    } catch (final RuntimeException e) {\n-                        throw e;\n-                    } catch (final Exception e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            };\n-        }\n-    };\n-\n-    private final ClassValue<ClassMap<MethodHandle>> converterIdentityMap = new ClassValue<>() {\n-        @Override\n-        protected ClassMap<MethodHandle> computeValue(final Class<?> sourceType) {\n-            return new ClassMap<>(getClassLoader(sourceType)) {\n-                @Override\n-                protected MethodHandle computeValue(final Class<?> targetType) {\n-                    if(!canAutoConvert(sourceType, targetType)) {\n-                        final MethodHandle converter = getCacheableTypeConverter(sourceType, targetType);\n-                        if(converter != IDENTITY_CONVERSION) {\n-                            return converter;\n-                        }\n-                    }\n-                    return IDENTITY_CONVERSION.asType(MethodType.methodType(targetType, sourceType));\n-                }\n-            };\n-        }\n-    };\n-\n-    private final ClassValue<ClassMap<Boolean>> canConvert = new ClassValue<>() {\n-        @Override\n-        protected ClassMap<Boolean> computeValue(final Class<?> sourceType) {\n-            return new ClassMap<>(getClassLoader(sourceType)) {\n-                @Override\n-                protected Boolean computeValue(final Class<?> targetType) {\n-                    try {\n-                        return getTypeConverterNull(sourceType, targetType) != null;\n-                    } catch (final RuntimeException e) {\n-                        throw e;\n-                    } catch (final Exception e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            };\n-        }\n-    };\n-\n-    private static ClassLoader getClassLoader(final Class<?> clazz) {\n-        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) clazz::getClassLoader, GET_CLASS_LOADER_CONTEXT);\n-    }\n+    private final BiClassValue<MethodHandle> converterMap;\n+    private final BiClassValue<MethodHandle> converterIdentityMap;\n+    private final BiClassValue<Boolean> canConvert;\n@@ -184,1 +122,0 @@\n-        this.factories = l.toArray(new GuardingTypeConverterFactory[0]);\n@@ -187,0 +124,19 @@\n+\n+        final GuardingTypeConverterFactory[] afactories = l.toArray(new GuardingTypeConverterFactory[0]);\n+        final BiClassValue<MethodHandle> converterMap = BiClassValue.computing(\n+            (sourceType, targetType) -> createConverter(sourceType, targetType, afactories));\n+\n+        converterIdentityMap = BiClassValue.computing((sourceType, targetType) -> {\n+            if(!canAutoConvert(sourceType, targetType)) {\n+                final MethodHandle converter = getCacheableTypeConverter(sourceType, targetType, converterMap);\n+                if(converter != IDENTITY_CONVERSION) {\n+                    return converter;\n+                }\n+            }\n+            return IDENTITY_CONVERSION.asType(MethodType.methodType(targetType, sourceType));\n+        });\n+\n+        canConvert = BiClassValue.computing(\n+            (sourceType, targetType) -> getTypeConverterNull(sourceType, targetType, converterMap) != null);\n+\n+        this.converterMap = converterMap;\n@@ -222,1 +178,1 @@\n-                final MethodHandle converter = getTypeConverterNull(fromParamType, toParamType);\n+                final MethodHandle converter = getTypeConverterNull(fromParamType, toParamType, converterMap);\n@@ -240,1 +196,1 @@\n-                final MethodHandle converter = getTypeConverterNull(toRetType, fromRetType);\n+                final MethodHandle converter = getTypeConverterNull(toRetType, fromRetType, converterMap);\n@@ -277,1 +233,1 @@\n-        return canAutoConvert(from, to) || canConvert.get(from).get(to);\n+        return canAutoConvert(from, to) || canConvert.get(from, to);\n@@ -318,2 +274,2 @@\n-    \/*private*\/ MethodHandle getCacheableTypeConverterNull(final Class<?> sourceType, final Class<?> targetType) {\n-        final MethodHandle converter = getCacheableTypeConverter(sourceType, targetType);\n+    \/*private*\/ static MethodHandle getCacheableTypeConverterNull(final Class<?> sourceType, final Class<?> targetType, final BiClassValue<MethodHandle> converterMap) {\n+        final MethodHandle converter = getCacheableTypeConverter(sourceType, targetType, converterMap);\n@@ -323,1 +279,1 @@\n-    \/*private*\/ MethodHandle getTypeConverterNull(final Class<?> sourceType, final Class<?> targetType) {\n+    \/*private*\/ static MethodHandle getTypeConverterNull(final Class<?> sourceType, final Class<?> targetType, final BiClassValue<MethodHandle> converterMap) {\n@@ -325,1 +281,1 @@\n-            return getCacheableTypeConverterNull(sourceType, targetType);\n+            return getCacheableTypeConverterNull(sourceType, targetType, converterMap);\n@@ -331,2 +287,2 @@\n-    \/*private*\/ MethodHandle getCacheableTypeConverter(final Class<?> sourceType, final Class<?> targetType) {\n-        return converterMap.get(sourceType).get(targetType);\n+    \/*private*\/ static MethodHandle getCacheableTypeConverter(final Class<?> sourceType, final Class<?> targetType, final BiClassValue<MethodHandle> converterMap) {\n+        return converterMap.get(sourceType, targetType);\n@@ -346,1 +302,1 @@\n-            return converterIdentityMap.get(sourceType).get(targetType);\n+            return converterIdentityMap.get(sourceType, targetType);\n@@ -369,1 +325,1 @@\n-    \/*private*\/ MethodHandle createConverter(final Class<?> sourceType, final Class<?> targetType) throws Exception {\n+    \/*private*\/ static MethodHandle createConverter(final Class<?> sourceType, final Class<?> targetType, GuardingTypeConverterFactory[] factories) {\n@@ -382,0 +338,4 @@\n+        } catch (final RuntimeException e) {\n+            throw e;\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/TypeConverterFactory.java","additions":37,"deletions":77,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8198540\n+ * @summary Test TypeConverterFactory is not leaking method handles\n+ * @author Attila Szegedi\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.dynalink.DynamicLinker;\n+import jdk.dynalink.DynamicLinkerFactory;\n+import jdk.dynalink.linker.GuardedInvocation;\n+import jdk.dynalink.linker.GuardingDynamicLinker;\n+import jdk.dynalink.linker.GuardingTypeConverterFactory;\n+import jdk.dynalink.linker.LinkRequest;\n+import jdk.dynalink.linker.LinkerServices;\n+\n+\/**\n+ * Tests that converter method handles created by\n+ * jdk.dynalink.TypeConverterFactory become unreachable when the factory itself\n+ * becomes unreachable.\n+ *\/\n+public class TypeConverterFactoryMemoryLeakTest {\n+    \/\/ Usually succeeds in less than a second, but give it time\n+    private static final Duration MAX_DURATION = Duration.ofSeconds(15);\n+\n+    private static final ReferenceQueue<MethodHandle> refQueue = new ReferenceQueue<>();\n+    private static final List<Reference<MethodHandle>> refs = new ArrayList<>();\n+\n+    private static class TestLinker implements GuardingDynamicLinker, GuardingTypeConverterFactory {\n+        public GuardedInvocation getGuardedInvocation(LinkRequest linkRequest, LinkerServices linkerServices) {\n+            \/\/ We're only testing convertToType\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public GuardedInvocation convertToType(Class<?> sourceType, Class<?> targetType, Supplier<MethodHandles.Lookup> lookupSupplier) {\n+            \/\/ Never meant to be invoked, just a dummy MH that conforms to the expected type.\n+            MethodHandle result = MethodHandles.empty(MethodType.methodType(targetType, sourceType));\n+            \/\/ Keep track of its reachability\n+            refs.add(new PhantomReference<>(result, refQueue));\n+            return new GuardedInvocation(result);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        long start = System.nanoTime();\n+        long deadline = start + MAX_DURATION.toNanos();\n+        while (System.nanoTime() < deadline) {\n+            \/\/ Just create them as fast as possible without retaining.\n+            makeOne();\n+            if (refQueue.poll() != null) {\n+                \/\/ Success, a method handle became phantom reachable.\n+                return;\n+            }\n+        }\n+        \/\/ No method handles became phantom reachable before deadline.\n+        throw new AssertionError(\"Should have GCd a method handle by now\");\n+    }\n+\n+    private static void makeOne() {\n+        \/\/ Create a one-off dynamic linker that'll create one type converter.\n+        DynamicLinkerFactory f = new DynamicLinkerFactory();\n+        f.setFallbackLinkers();\n+        f.setPrioritizedLinker(new TestLinker());\n+        DynamicLinker linker = f.createLinker();\n+        \/\/ It's important the conversion is from a system class (they're GC\n+        \/\/ roots) and that it is *not* method invocation convertible (double to\n+        \/\/ int isn't.)\n+        linker.getLinkerServices().getTypeConverter(double.class, int.class);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/dynalink\/TypeConverterFactoryMemoryLeakTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8198540\n+ * @summary Test TypeConverterFactory is not leaking class loaders\n+ * @author Attila Szegedi\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.ReferenceQueue;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.dynalink.DynamicLinkerFactory;\n+import jdk.dynalink.linker.GuardedInvocation;\n+import jdk.dynalink.linker.GuardingDynamicLinker;\n+import jdk.dynalink.linker.GuardingTypeConverterFactory;\n+import jdk.dynalink.linker.LinkRequest;\n+import jdk.dynalink.linker.LinkerServices;\n+\n+\/**\n+ * Tests that jdk.dynalink.TypeConverterFactory doesn't prevent class loaders\n+ * from getting garbage collected.\n+ *\/\n+public class TypeConverterFactoryRetentionTests {\n+    \/\/ Usually succeeds in less than a second, but give it time\n+    private static final Duration MAX_DURATION = Duration.ofSeconds(15);\n+\n+    private static class TestLinker implements GuardingDynamicLinker, GuardingTypeConverterFactory {\n+        public GuardedInvocation getGuardedInvocation(LinkRequest linkRequest, LinkerServices linkerServices) {\n+            \/\/ We're only testing convertToType\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public GuardedInvocation convertToType(Class<?> sourceType, Class<?> targetType, Supplier<MethodHandles.Lookup> lookupSupplier) {\n+            \/\/ Never meant to be invoked, just a dummy MH that conforms to the expected type.\n+            MethodHandle result = MethodHandles.empty(MethodType.methodType(targetType, sourceType));\n+            return new GuardedInvocation(result);\n+        }\n+    }\n+\n+    private static class TestClassLoader extends ClassLoader {\n+        private final String name;\n+\n+        TestClassLoader(ClassLoader parent, String name) {\n+            super(parent);\n+            this.name = name;\n+            if (this.name.length() != 1) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (this.name.equals(name)) {\n+                \/\/ Base64-encoding of simplest \"public final class X { private X() {} }\"\n+                \/\/ with Java 8 class format. The single-character name is in position 63.\n+                byte[] bytes = Base64.getDecoder().decode(\n+                    \"yv66vgAAADQACgoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2Jq\" +\n+                    \"ZWN0AQAGPGluaXQ+AQADKClWBwAIAQABWAEABENvZGUAMQAHAAIA\" +\n+                    \"AAAAAAEAAgAFAAYAAQAJAAAAEQABAAEAAAAFKrcAAbEAAAAAAAA=\");\n+                assert bytes[63] == 'X';\n+                \/\/ rename\n+                bytes[63] = (byte)name.charAt(0);\n+                return defineClass(name, bytes, 0, bytes.length);\n+            }\n+            throw new ClassNotFoundException();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testSystemLoaderToOtherLoader();\n+        testParentToChildLoader();\n+        testUnrelatedLoaders();\n+    }\n+\n+    private static final LinkerServices createLinkerServices() {\n+        DynamicLinkerFactory f = new DynamicLinkerFactory();\n+        f.setFallbackLinkers();\n+        f.setPrioritizedLinker(new TestLinker());\n+        return f.createLinker().getLinkerServices();\n+    }\n+\n+    \/**\n+     * Creates converters between a system class and user-loaded classes,\n+     * tests that the user-loaded classes and their loader can be GCd\n+     * (system classes won't pin them.)\n+     *\/\n+    private static void testSystemLoaderToOtherLoader() throws ClassNotFoundException {\n+        testFromOneClassToClassLoader(double.class);\n+    }\n+\n+    \/**\n+     * Creates converters between a user-loaded classes belonging to class\n+     * loaders in parent-child relationship, tests that the classes loaded by\n+     * child loaders can be GCd (parent won't pin them.)\n+     *\/\n+    private static void testParentToChildLoader() throws ClassNotFoundException {\n+        TestClassLoader parent = new TestClassLoader(null, \"Y\");\n+        Class<?> y = Class.forName(\"Y\", true, parent);\n+\n+        testFromOneClassToClassLoader(y);\n+    }\n+\n+    private static void testFromOneClassToClassLoader(Class<?> y) throws ClassNotFoundException {\n+        ReferenceQueue<ClassLoader> refQueue = new ReferenceQueue<>();\n+        List<PhantomReference<ClassLoader>> refs = new ArrayList<>();\n+\n+        LinkerServices linkerServices = createLinkerServices();\n+\n+        long start = System.nanoTime();\n+        long deadline = start + MAX_DURATION.toNanos();\n+        while (System.nanoTime() < deadline) {\n+            TestClassLoader cl = new TestClassLoader(y.getClassLoader(), \"X\");\n+            Class<?> x = Class.forName(\"X\", true, cl);\n+            assert x.getClassLoader() == cl;\n+            linkerServices.getTypeConverter(y, x);\n+            linkerServices.getTypeConverter(x, y);\n+            refs.add(new PhantomReference<>(cl, refQueue));\n+            if (refQueue.poll() != null) {\n+                return;\n+            }\n+        }\n+        \/\/ No class loaders became phantom reachable before deadline.\n+        throw new AssertionError(\"Should have GCd a class loader by now\");\n+    }\n+\n+    \/**\n+     * Creates converters between a user-loaded classes belonging to unrelated\n+     * class loaders, tests that the classes and the loaders can be GCd\n+     * (neither side will pin the other side.)\n+     *\/\n+    private static void testUnrelatedLoaders() throws ClassNotFoundException {\n+        ReferenceQueue<ClassLoader> refQueue1 = new ReferenceQueue<>();\n+        ReferenceQueue<ClassLoader> refQueue2 = new ReferenceQueue<>();\n+        List<PhantomReference<ClassLoader>> refs = new ArrayList<>();\n+        boolean gc1 = false;\n+        boolean gc2 = false;\n+\n+        LinkerServices linkerServices = createLinkerServices();\n+\n+        long start = System.nanoTime();\n+        long deadline = start + MAX_DURATION.toNanos();\n+        while (System.nanoTime() < deadline) {\n+            TestClassLoader cl1 = new TestClassLoader(null, \"X\");\n+            Class<?> x = Class.forName(\"X\", true, cl1);\n+            assert x.getClassLoader() == cl1;\n+            TestClassLoader cl2 = new TestClassLoader(null, \"Y\");\n+            Class<?> y = Class.forName(\"Y\", true, cl2);\n+            assert y.getClassLoader() == cl2;\n+            linkerServices.getTypeConverter(y, x);\n+            linkerServices.getTypeConverter(x, y);\n+            refs.add(new PhantomReference<>(cl1, refQueue1));\n+            refs.add(new PhantomReference<>(cl2, refQueue2));\n+            if (refQueue1.poll() != null) {\n+                gc1 = true;\n+            }\n+            if (refQueue2.poll() != null) {\n+                gc2 = true;\n+            }\n+            if (gc1 && gc2) {\n+                return;\n+            }\n+        }\n+        \/\/ No class loaders from both sides became phantom reachable before deadline.\n+        throw new AssertionError(\"Should have GCd a class loader from both queues by now\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/dynalink\/TypeConverterFactoryRetentionTests.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}