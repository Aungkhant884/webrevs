{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.ArrayList;\n@@ -35,1 +36,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -50,8 +50,14 @@\n-     * compute the values.\n-     * @param compute the binary function to compute the values. Its invocation\n-     *                semantics is similar to that of {@code ConcurrentMap.computeIfAbsent}.\n-     *                Additionally, if the pair of types passed as parameters are\n-     *                from unrelated class loaders, the computed value is not\n-     *                cached at all and the function might be reinvoked with\n-     *                the same parameters in the future. A null return value is\n-     *                allowed, but not cached.\n+     * lazily compute the values.\n+     * @param compute the binary function to compute the values. Ordinarily, it\n+     *                is invoked at most once for any pair of values. However,\n+     *                it is possible for it to be invoked concurrently. It can\n+     *                even be invoked concurrently multiple times for the same\n+     *                arguments under contention. In that case, it is undefined\n+     *                which of the computed values will be retained therefore\n+     *                returning semantically equivalent values is strongly\n+     *                recommended; the function should ideally be pure.\n+     *                Additionally, if the pair of types passed as parameters\n+     *                are from unrelated class loaders, the computed value is\n+     *                not cached at all and the function might be reinvoked\n+     *                with the same parameters in the future. Finally, a null\n+     *                return value is allowed, but not cached.\n@@ -81,3 +87,2 @@\n-     * not store a reference to the type Class object itself, only its\n-     * ClassLoader; BiClassValuesRoot create the association from a type Class\n-     * object to its BiClassValues'.\n+     * not store a reference to the type Class object itself. BiClassValuesRoot\n+     * creates the association from a type Class object to its BiClassValues'.\n@@ -87,1 +92,1 @@\n-        \/\/ These will be used for compareAndSet on forward and reverse fields.\n+        \/\/ These will be used for compareAndExchange on forward and reverse fields.\n@@ -100,7 +105,2 @@\n-        final ClassLoader classLoader;\n-        private volatile Map<Class<?>, T> forward;\n-        private volatile Map<Class<?>, T> reverse;\n-\n-        BiClassValues(final ClassLoader classLoader) {\n-            this.classLoader = classLoader;\n-        }\n+        private volatile Map<Class<?>, T> forward = Map.of();\n+        private volatile Map<Class<?>, T> reverse = Map.of();\n@@ -109,1 +109,1 @@\n-            return getValue(forward, c);\n+            return forward.get(c);\n@@ -113,1 +113,1 @@\n-            return getValue(reverse, c);\n+            return reverse.get(c);\n@@ -116,2 +116,22 @@\n-        private static <T> T getValue(Map<Class<?>, T> m, final Class<?> c) {\n-            return m != null ? m.get(c) : null;\n+        T compute(Map<Class<?>, T> map, final VarHandle mapHandle, final Class<?> c, final Function<Class<?>, T> compute) {\n+            if (!map.containsKey(c)) {\n+                final T value = compute.apply(c);\n+                if (value == null) {\n+                    return null;\n+                }\n+                do {\n+                    final var entries = new ArrayList<>(map.entrySet());\n+                    entries.add(Map.entry(c, value));\n+                    @SuppressWarnings(\"rawtypes\")\n+                    final var newEntries = entries.toArray(new Map.Entry[0]);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final var newMap = Map.ofEntries(newEntries);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final var witness = (Map<Class<?>, T>)mapHandle.compareAndExchange(this, map, newMap);\n+                    if (witness == map) {\n+                        return value;\n+                    }\n+                    map = witness;\n+                } while (!map.containsKey(c));\n+            }\n+            return map.get(c);\n@@ -121,4 +141,1 @@\n-            while (forward == null) {\n-                FORWARD.compareAndSet(this, null, new ConcurrentHashMap<Class<?>, T>());\n-            }\n-            return forward.computeIfAbsent(c, compute);\n+            return compute(forward, FORWARD, c, compute);\n@@ -128,4 +145,1 @@\n-            while (reverse == null) {\n-                REVERSE.compareAndSet(this, null, new ConcurrentHashMap<Class<?>, T>());\n-            }\n-            return reverse.computeIfAbsent(c, compute);\n+            return compute(reverse, REVERSE, c, compute);\n@@ -140,1 +154,1 @@\n-            return new BiClassValues<>(getClassLoader(type));\n+            return new BiClassValues<>();\n@@ -144,0 +158,6 @@\n+    private enum ClassLoaderRelation {\n+        DESCENDANT,\n+        ANCESTOR,\n+        UNRELATED\n+    }\n+\n@@ -167,6 +187,12 @@\n-        if (canReferenceDirectly(cv1.classLoader, cv2.classLoader)) {\n-            \/\/ cl1 can see cl2, store value for (c1, c2) in cv1's forward map\n-            return cv1.computeForward(c2, cy -> compute.apply(c1, cy));\n-        } else if (canReferenceDirectly(cv2.classLoader, cv1.classLoader)) {\n-            \/\/ cl2 can see cl1, store value for (c1, c2) in cv2's reverse map\n-            return cv2.computeReverse(c1, cx -> compute.apply(cx, c2));\n+        switch (getClassLoaderRelation(c1, c2)) {\n+            case DESCENDANT:\n+                \/\/ loader of c1 can see loader of c2, store value for (c1, c2) in cv1's forward map\n+                return cv1.computeForward(c2, cy -> compute.apply(c1, cy));\n+            case ANCESTOR:\n+                \/\/ loader of c2 can see loader of c1, store value for (c1, c2) in cv2's reverse map\n+                return cv2.computeReverse(c1, cx -> compute.apply(cx, c2));\n+            case UNRELATED:\n+                \/\/ Class loaders are unrelated; compute and return uncached.\n+                return compute.apply(c1, c2);\n+            default:\n+                throw new AssertionError(); \/\/ enum values exhausted\n@@ -174,3 +200,0 @@\n-\n-        \/\/ Class loaders are unrelated; compute and return uncached.\n-        return compute.apply(c1, c2);\n@@ -182,2 +205,11 @@\n-    private static ClassLoader getClassLoader(final Class<?> clazz) {\n-        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) clazz::getClassLoader, GET_CLASS_LOADER_CONTEXT);\n+    private static ClassLoaderRelation getClassLoaderRelation(Class<?> from, Class<?> to) {\n+        return AccessController.doPrivileged((PrivilegedAction<ClassLoaderRelation>) () -> {\n+            final ClassLoader cl1 = from.getClassLoader();\n+            final ClassLoader cl2 = to.getClassLoader();\n+            if (canReferenceDirectly(cl1, cl2)) {\n+                return ClassLoaderRelation.DESCENDANT;\n+            } else if (canReferenceDirectly(cl2, cl1)) {\n+                return ClassLoaderRelation.ANCESTOR;\n+            }\n+            return ClassLoaderRelation.UNRELATED;\n+        }, GET_CLASS_LOADER_CONTEXT);\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/BiClassValue.java","additions":76,"deletions":44,"binary":false,"changes":120,"status":"modified"}]}