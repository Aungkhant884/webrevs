{"files":[{"patch":"@@ -3153,7 +3153,11 @@\n-Method* InstanceKlass::method_at_itable(Klass* holder, int index, TRAPS) {\n-  itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();\n-  int method_table_offset_in_words = ioe->offset()\/wordSize;\n-  int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())\n-                       \/ itableOffsetEntry::size();\n-\n-  for (int cnt = 0 ; ; cnt ++, ioe ++) {\n+Method* InstanceKlass::method_at_itable(InstanceKlass* holder, int index, TRAPS) {\n+  bool implements_interface; \/\/ initialized by method_at_itable_or_null\n+  Method* m = method_at_itable_or_null(holder, index,\n+                                       implements_interface); \/\/ out parameter\n+  if (m != NULL) {\n+    assert(implements_interface, \"sanity\");\n+    return m;\n+  } else if (implements_interface) {\n+    \/\/ Throw AbstractMethodError since corresponding itable slot is empty.\n+    THROW_NULL(vmSymbols::java_lang_AbstractMethodError());\n+  } else {\n@@ -3162,12 +3166,23 @@\n-    if (cnt >= nof_interfaces) {\n-      ResourceMark rm(THREAD);\n-      stringStream ss;\n-      bool same_module = (module() == holder->module());\n-      ss.print(\"Receiver class %s does not implement \"\n-               \"the interface %s defining the method to be called \"\n-               \"(%s%s%s)\",\n-               external_name(), holder->external_name(),\n-               (same_module) ? joint_in_module_of_loader(holder) : class_in_module_of_loader(),\n-               (same_module) ? \"\" : \"; \",\n-               (same_module) ? \"\" : holder->class_in_module_of_loader());\n-      THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+    ResourceMark rm(THREAD);\n+    stringStream ss;\n+    bool same_module = (module() == holder->module());\n+    ss.print(\"Receiver class %s does not implement \"\n+             \"the interface %s defining the method to be called \"\n+             \"(%s%s%s)\",\n+             external_name(), holder->external_name(),\n+             (same_module) ? joint_in_module_of_loader(holder) : class_in_module_of_loader(),\n+             (same_module) ? \"\" : \"; \",\n+             (same_module) ? \"\" : holder->class_in_module_of_loader());\n+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+  }\n+}\n+\n+Method* InstanceKlass::method_at_itable_or_null(InstanceKlass* holder, int index, bool& implements_interface) {\n+  klassItable itable(this);\n+  for (int i = 0; i < itable.size_offset_table(); i++) {\n+    itableOffsetEntry* offset_entry = itable.offset_entry(i);\n+    if (offset_entry->interface_klass() == holder) {\n+      implements_interface = true;\n+      itableMethodEntry* ime = offset_entry->first_method_entry(this);\n+      Method* m = ime[index].method();\n+      return m;\n@@ -3175,3 +3190,0 @@\n-\n-    Klass* ik = ioe->interface_klass();\n-    if (ik == holder) break;\n@@ -3179,7 +3191,2 @@\n-\n-  itableMethodEntry* ime = ioe->first_method_entry(this);\n-  Method* m = ime[index].method();\n-  if (m == NULL) {\n-    THROW_NULL(vmSymbols::java_lang_AbstractMethodError());\n-  }\n-  return m;\n+  implements_interface = false;\n+  return NULL; \/\/ offset entry not found\n@@ -3188,1 +3195,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1111,1 +1111,2 @@\n-  Method* method_at_itable(Klass* holder, int index, TRAPS);\n+  Method* method_at_itable(InstanceKlass* holder, int index, TRAPS);\n+  Method* method_at_itable_or_null(InstanceKlass* holder, int index, bool& itable_entry_found);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -909,1 +909,1 @@\n-    Klass* holder = m->method_holder();\n+    InstanceKlass* holder = m->method_holder();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}