{"files":[{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -34,6 +33,3 @@\n-public:\n-  \/\/ Each arch must define reset, save, restore\n-  \/\/ These are used by objects that only care about:\n-  \/\/  1 - initializing a new state (thread creation, javaCalls)\n-  \/\/  2 - saving a current state (javaCalls)\n-  \/\/  3 - restoring an old state (javaCalls)\n+  static ByteSize last_Java_fp_offset() {\n+    return byte_offset_of(JavaFrameAnchor, _last_Java_fp);\n+  }\n@@ -41,0 +37,1 @@\n+public:\n@@ -42,3 +39,1 @@\n-    \/\/ clearing _last_Java_sp must be first\n-    _last_Java_sp = NULL;\n-    OrderAccess::release();\n+    set_last_Java_sp(NULL);\n@@ -57,3 +52,2 @@\n-    if (_last_Java_sp != src->_last_Java_sp) {\n-      _last_Java_sp = NULL;\n-      OrderAccess::release();\n+    if (last_Java_fp() != src->_last_Java_sp) {\n+      set_last_Java_sp(NULL);\n@@ -63,2 +57,5 @@\n-    \/\/ Must be last so profiler will always see valid frame if has_last_frame() is true\n-    _last_Java_sp = src->_last_Java_sp;\n+    set_last_Java_sp(src->_last_Java_sp);\n+  }\n+\n+  bool walkable(void) {\n+    return last_Java_sp() != NULL && _last_Java_pc != NULL;\n@@ -67,1 +64,0 @@\n-  bool walkable(void)                            { return _last_Java_sp != NULL && _last_Java_pc != NULL; }\n@@ -71,3 +67,6 @@\n-  intptr_t* last_Java_sp(void) const             { return _last_Java_sp; }\n-\n-  address last_Java_pc(void)                     { return _last_Java_pc; }\n+  \/\/ last_Java_sp is acting, among other things, as the acquire\/release target:\n+  \/\/ when last_Java_sp is not NULL, has_last_frame() is true, and the rest of\n+  \/\/ the frame has to be valid. This means last_Java_sp loads should be first\n+  \/\/ and acquiring, and last_Java_sp stores should be last and releasing.\n+  \/\/ Additionally, resets of the frame should be as prompt as possible, therefore\n+  \/\/ we got to \"flush\" it with trailing fences.\n@@ -75,5 +74,3 @@\n-private:\n-\n-  static ByteSize last_Java_fp_offset()          { return byte_offset_of(JavaFrameAnchor, _last_Java_fp); }\n-\n-public:\n+  intptr_t* last_Java_sp(void) const {\n+    return Atomic::load_acquire(&_last_Java_sp);\n+  }\n@@ -81,1 +78,7 @@\n-  void set_last_Java_sp(intptr_t* sp)            { _last_Java_sp = sp; OrderAccess::release(); }\n+  void set_last_Java_sp(intptr_t* sp) {\n+    if (sp != NULL) {\n+      Atomic::release_store(&_last_Java_sp, sp);\n+    } else {\n+      Atomic::release_store_fence(&_last_Java_sp, sp);\n+    }\n+  }\n@@ -83,1 +86,2 @@\n-  intptr_t*   last_Java_fp(void)                 { return _last_Java_fp; }\n+  intptr_t* last_Java_fp(void) { return _last_Java_fp; }\n+  address last_Java_pc(void)   { return _last_Java_pc; }\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -76,1 +77,1 @@\n-  bool has_last_Java_frame() const                   { return _last_Java_sp != NULL; }\n+  bool has_last_Java_frame() const                   { return last_Java_sp() != NULL; }\n@@ -80,1 +81,1 @@\n-  void zap(void)                                     { _last_Java_sp = NULL; }\n+  void zap(void)                                     { set_last_Java_sp(NULL); }\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}