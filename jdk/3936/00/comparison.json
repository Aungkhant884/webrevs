{"files":[{"patch":"@@ -455,9 +455,9 @@\n-  \/\/ Allocate the next word_size words in the current allocation chunk.\n-  \/\/ If allocation would cross the _max boundary, insert a filler and begin\n-  \/\/ at the base of the next min_region_size'd chunk. Also advance to the next\n-  \/\/ chunk if we don't yet cross the boundary, but the remainder would be too\n-  \/\/ small to fill.\n-  HeapWord* new_top = old_top + word_size;\n-  size_t remainder = pointer_delta(_max, new_top);\n-  if ((new_top > _max) ||\n-      ((new_top < _max) && (remainder < CollectedHeap::min_fill_size()))) {\n+  \/\/ Try to allocate word_size in the current allocation chunk. Two cases\n+  \/\/ require special treatment:\n+  \/\/ 1. no enough space for word_size\n+  \/\/ 2. after allocating word_size, there's non-zero space left, but too small for the minimal filler\n+  \/\/ In both cases, we retire the current chunk and move on to the next one.\n+  size_t free_words = pointer_delta(_max, old_top);\n+  if (free_words < word_size ||\n+      ((free_words - word_size != 0) && (free_words - word_size < CollectedHeap::min_fill_size()))) {\n+    \/\/ Retiring the current chunk\n@@ -465,1 +465,2 @@\n-      size_t fill_size = pointer_delta(_max, old_top);\n+      \/\/ Non-zero space; need to insert the filler\n+      size_t fill_size = free_words;\n@@ -469,0 +470,1 @@\n+    \/\/ Set the current chunk as \"full\"\n@@ -470,1 +472,0 @@\n-    old_top = _bottom = _max;\n@@ -474,1 +475,3 @@\n-    if (_bottom != _allocation_region->end()) {\n+    if (_max != _allocation_region->end()) {\n+      \/\/ Shift to the next chunk\n+      old_top = _bottom = _max;\n@@ -483,0 +486,1 @@\n+  assert(pointer_delta(_max, old_top) >= word_size, \"enough space left\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"}]}