{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -292,0 +293,29 @@\n+\n+\/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n+\/\/ print the block. Note that since there is very low risk of memory looking\n+\/\/ accidentally like a valid malloc block header (canaries and all) this is not\n+\/\/ totally failproof. Only use this during debugging or when you can afford\n+\/\/ signals popping up, e.g. when writing an hs_err file.\n+bool MallocTracker::print_pointer_information(const void* p, outputStream* st) {\n+  assert(MemTracker::enabled(), \"NMT must be enabled\");\n+  if (CanUseSafeFetchN() && os::is_readable_pointer(p)) {\n+    const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n+    const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(const_cast<void*>(p), tracking_level);\n+    char msg[256];\n+    address p_corrupted;\n+    if (os::is_readable_pointer(mhdr) &&\n+        mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n+      st->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n+          p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n+      if (tracking_level == NMT_detail) {\n+        NativeCallStack ncs;\n+        if (mhdr->get_stack(ncs)) {\n+          ncs.print_on(st);\n+          st->cr();\n+        }\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class outputStream;\n+\n@@ -441,0 +443,8 @@\n+\n+  \/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n+  \/\/ print the block. Note that since there is very low risk of memory looking\n+  \/\/ accidentally like a valid malloc block header (canaries and all) this is not\n+  \/\/ totally failproof. Only use this during debugging or when you can afford\n+  \/\/ signals popping up, e.g. when writing an hs_err file.\n+  static bool print_pointer_information(const void* p, outputStream* st);\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-class FindAndSnapshotRegionWalker : public VirtualMemoryWalker {\n+class PrintRegionWalker : public VirtualMemoryWalker {\n@@ -677,3 +677,2 @@\n-  ReservedMemoryRegion& _region;\n-  const address         _p;\n-  bool                  _found_region;\n+  const address               _p;\n+  outputStream*               _st;\n@@ -681,2 +680,2 @@\n-  FindAndSnapshotRegionWalker(void* p, ReservedMemoryRegion& region) :\n-    _region(region), _p((address)p), _found_region(false) { }\n+  PrintRegionWalker(const void* p, outputStream* st) :\n+    _p((address)p), _st(st) { }\n@@ -686,2 +685,6 @@\n-      _region = *rgn;\n-      _found_region = true;\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n+        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+      if (MemTracker::tracking_level() == NMT_detail) {\n+        rgn->call_stack()->print_on(_st);\n+        _st->cr();\n+      }\n@@ -692,1 +695,0 @@\n-  bool found_region() const { return _found_region; }\n@@ -695,4 +697,6 @@\n-const bool VirtualMemoryTracker::snapshot_region_contains(void* p, ReservedMemoryRegion& region) {\n-  FindAndSnapshotRegionWalker walker(p, region);\n-  walk_virtual_memory(&walker);\n-  return walker.found_region();\n+\/\/ If p is contained within a known memory region, print information about it to the\n+\/\/ given stream and return true; false otherwise.\n+bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n+  PrintRegionWalker walker(p, st);\n+  return !walk_virtual_memory(&walker);\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -388,1 +388,3 @@\n-  static const bool snapshot_region_contains(void* p, ReservedMemoryRegion& region);\n+  \/\/ If p is contained within a known memory region, print information about it to the\n+  \/\/ given stream and return true; false otherwise.\n+  static bool print_containing_region(const void* p, outputStream* st);\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n@@ -486,0 +485,6 @@\n+    \/\/ Ask NMT about this pointer.\n+    \/\/ GDB note: We will be using SafeFetch to access the supposed malloc header. If the address is\n+    \/\/ not readable, this will generate a signal. That signal will trip up the debugger: gdb will\n+    \/\/ catch the signal and disable the pp() command for further use.\n+    \/\/ In order to avoid that, switch off SIGSEGV handling with \"handle SIGSEGV nostop\" before\n+    \/\/ invoking pp()\n@@ -487,10 +492,2 @@\n-      const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n-      ReservedMemoryRegion region(0, 0);\n-      \/\/ Check and snapshot a mmap'd region that contains the pointer\n-      if (VirtualMemoryTracker::snapshot_region_contains(p, region)) {\n-        tty->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n-          p2i(p), p2i(region.base()), p2i(region.base() + region.size()), region.flag_name());\n-        if (tracking_level == NMT_detail) {\n-          region.call_stack()->print_on(tty);\n-          tty->cr();\n-        }\n+      \/\/ Does it point into a known mmaped region?\n+      if (VirtualMemoryTracker::print_containing_region(p, tty)) {\n@@ -499,17 +496,3 @@\n-      \/\/ Check if it is a malloc'd memory block\n-      if (CanUseSafeFetchN() && SafeFetchN((intptr_t*)p, 0) != 0) {\n-        const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(p, tracking_level);\n-        char msg[256];\n-        address p_corrupted;\n-        if (SafeFetchN((intptr_t*)mhdr, 0) != 0 && mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n-          tty->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n-            p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n-          if (tracking_level == NMT_detail) {\n-            NativeCallStack ncs;\n-            if (mhdr->get_stack(ncs)) {\n-              ncs.print_on(tty);\n-              tty->cr();\n-            }\n-          }\n-          return;\n-        }\n+      \/\/ Does it look like the start of a malloced block?\n+      if (MallocTracker::print_pointer_information(p, tty)) {\n+        return;\n@@ -518,1 +501,1 @@\n-    tty->print(PTR_FORMAT, p2i(p));\n+    tty->print_cr(PTR_FORMAT, p2i(p));\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":12,"deletions":29,"binary":false,"changes":41,"status":"modified"}]}