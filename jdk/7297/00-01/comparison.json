{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -292,0 +293,29 @@\n+\n+\/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n+\/\/ print the block. Note that since there is very low risk of memory looking\n+\/\/ accidentally like a valid malloc block header (canaries and all) this is not\n+\/\/ totally failproof. Only use this during debugging or when you can afford\n+\/\/ signals popping up, e.g. when writing an hs_err file.\n+bool MallocTracker::print_pointer_information(const void* p, outputStream* st) {\n+  assert(MemTracker::enabled(), \"NMT must be enabled\");\n+  if (CanUseSafeFetchN() && os::is_readable_pointer(p)) {\n+    const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n+    const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(const_cast<void*>(p), tracking_level);\n+    char msg[256];\n+    address p_corrupted;\n+    if (os::is_readable_pointer(mhdr) &&\n+        mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n+      st->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n+          p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n+      if (tracking_level == NMT_detail) {\n+        NativeCallStack ncs;\n+        if (mhdr->get_stack(ncs)) {\n+          ncs.print_on(st);\n+          st->cr();\n+        }\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class outputStream;\n+\n@@ -441,0 +443,8 @@\n+\n+  \/\/ Given a pointer, if it seems to point to the start of a valid malloced block,\n+  \/\/ print the block. Note that since there is very low risk of memory looking\n+  \/\/ accidentally like a valid malloc block header (canaries and all) this is not\n+  \/\/ totally failproof. Only use this during debugging or when you can afford\n+  \/\/ signals popping up, e.g. when writing an hs_err file.\n+  static bool print_pointer_information(const void* p, outputStream* st);\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-class FindAndSnapshotRegionWalker : public VirtualMemoryWalker {\n+class PrintRegionWalker : public VirtualMemoryWalker {\n@@ -677,1 +677,0 @@\n-  const ReservedMemoryRegion* _region;\n@@ -679,0 +678,1 @@\n+  outputStream*               _st;\n@@ -680,2 +680,2 @@\n-  FindAndSnapshotRegionWalker(const void* p) :\n-    _region(NULL), _p((address)p) { }\n+  PrintRegionWalker(const void* p, outputStream* st) :\n+    _p((address)p), _st(st) { }\n@@ -685,1 +685,6 @@\n-      _region = rgn;\n+      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n+        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+      if (MemTracker::tracking_level() == NMT_detail) {\n+        rgn->call_stack()->print_on(_st);\n+        _st->cr();\n+      }\n@@ -690,3 +695,0 @@\n-  const ReservedMemoryRegion* region() const {\n-    return _region;\n-  }\n@@ -695,4 +697,6 @@\n-const ReservedMemoryRegion* VirtualMemoryTracker::find_containing_region(const void* p) {\n-  FindAndSnapshotRegionWalker walker(p);\n-  walk_virtual_memory(&walker);\n-  return walker.region();\n+\/\/ If p is contained within a known memory region, print information about it to the\n+\/\/ given stream and return true; false otherwise.\n+bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n+  PrintRegionWalker walker(p, st);\n+  return !walk_virtual_memory(&walker);\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -388,1 +388,3 @@\n-  static const ReservedMemoryRegion* find_containing_region(const void* p);\n+  \/\/ If p is contained within a known memory region, print information about it to the\n+  \/\/ given stream and return true; false otherwise.\n+  static bool print_containing_region(const void* p, outputStream* st);\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n@@ -486,0 +485,6 @@\n+    \/\/ Ask NMT about this pointer.\n+    \/\/ GDB note: We will be using SafeFetch to access the supposed malloc header. If the address is\n+    \/\/ not readable, this will generate a signal. That signal will trip up the debugger: gdb will\n+    \/\/ catch the signal and disable the pp() command for further use.\n+    \/\/ In order to avoid that, switch off SIGSEGV handling with \"handle SIGSEGV nostop\" before\n+    \/\/ invoking pp()\n@@ -487,11 +492,2 @@\n-      const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n-      \/\/ Check and snapshot a mmap'd region that contains the pointer\n-      const ReservedMemoryRegion* const region =\n-          VirtualMemoryTracker::find_containing_region(p);\n-      if (region != NULL) {\n-        tty->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n-          p2i(p), p2i(region->base()), p2i(region->base() + region->size()), region->flag_name());\n-        if (tracking_level == NMT_detail) {\n-          region->call_stack()->print_on(tty);\n-          tty->cr();\n-        }\n+      \/\/ Does it point into a known mmaped region?\n+      if (VirtualMemoryTracker::print_containing_region(p, tty)) {\n@@ -500,22 +496,3 @@\n-      \/\/ Check if it is a malloc'd memory block\n-      \/\/ GDB note: Before reading the malloc header from the assumed-to-be-malloced address, we do a basic\n-      \/\/  SafeFetch test to check if reading is safe. This will generate a signal if it isn't. That signal normally\n-      \/\/  is handled quietly by the VM, but it will trip up the debugger. gdb will catch the signal and disable\n-      \/\/  the pp() command for further use.\n-      \/\/ In order to avoid that, before invoking pp(), switch off SIGSEGV handling with \"handle SIGSEGV nostop\".\n-      if (CanUseSafeFetchN() && os::is_readable_pointer(p)) {\n-        const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(p, tracking_level);\n-        char msg[256];\n-        address p_corrupted;\n-        if (os::is_readable_pointer(mhdr) && mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n-          tty->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n-            p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n-          if (tracking_level == NMT_detail) {\n-            NativeCallStack ncs;\n-            if (mhdr->get_stack(ncs)) {\n-              ncs.print_on(tty);\n-              tty->cr();\n-            }\n-          }\n-          return;\n-        }\n+      \/\/ Does it look like the start of a malloced block?\n+      if (MallocTracker::print_pointer_information(p, tty)) {\n+        return;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":11,"deletions":34,"binary":false,"changes":45,"status":"modified"}]}