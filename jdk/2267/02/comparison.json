{"files":[{"patch":"@@ -32,8 +32,0 @@\n-\/\/ System includes\n-\n-#include <unistd.h>\n-#include <sys\/socket.h>\n-#include <poll.h>\n-#include <sys\/ioctl.h>\n-#include <netdb.h>\n-\n@@ -56,58 +48,0 @@\n-inline void os::dll_unload(void *lib) {\n-  ::dlclose(lib);\n-}\n-\n-inline jlong os::lseek(int fd, jlong offset, int whence) {\n-  return (jlong) ::lseek64(fd, offset, whence);\n-}\n-\n-inline int os::fsync(int fd) {\n-  return ::fsync(fd);\n-}\n-\n-inline int os::ftruncate(int fd, jlong length) {\n-  return ::ftruncate64(fd, length);\n-}\n-\n-\/\/ We don't have NUMA support on Aix, but we need this for compilation.\n-inline bool os::numa_has_static_binding()   { ShouldNotReachHere(); return true; }\n-inline bool os::numa_has_group_homing()     { ShouldNotReachHere(); return false;  }\n-\n-inline size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n-  size_t res;\n-  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);\n-  return res;\n-}\n-\n-inline int os::socket_close(int fd) {\n-  return ::close(fd);\n-}\n-\n-inline int os::socket(int domain, int type, int protocol) {\n-  return ::socket(domain, type, protocol);\n-}\n-\n-inline int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::raw_send(int fd, char *buf, size_t nBytes, uint flags) {\n-  return os::send(fd, buf, nBytes, flags);\n-}\n-\n-inline int os::connect(int fd, struct sockaddr *him, socklen_t len) {\n-  RESTARTABLE_RETURN_INT(::connect(fd, him, len));\n-}\n-\n-inline struct hostent* os::get_host_by_name(char* name) {\n-  return ::gethostbyname(name);\n-}\n-\n-inline void os::exit(int num) {\n-  ::exit(num);\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,7 +31,0 @@\n-\/\/ System includes\n-\n-#include <unistd.h>\n-#include <sys\/socket.h>\n-#include <poll.h>\n-#include <netdb.h>\n-\n@@ -59,57 +52,0 @@\n-inline void os::dll_unload(void *lib) {\n-  ::dlclose(lib);\n-}\n-\n-inline jlong os::lseek(int fd, jlong offset, int whence) {\n-  return (jlong) ::lseek(fd, offset, whence);\n-}\n-\n-inline int os::fsync(int fd) {\n-  return ::fsync(fd);\n-}\n-\n-inline int os::ftruncate(int fd, jlong length) {\n-  return ::ftruncate(fd, length);\n-}\n-\n-inline bool os::numa_has_static_binding()   { return true; }\n-inline bool os::numa_has_group_homing()     { return false;  }\n-\n-inline size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n-  size_t res;\n-  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);\n-  return res;\n-}\n-\n-inline int os::socket_close(int fd) {\n-  return ::close(fd);\n-}\n-\n-inline int os::socket(int domain, int type, int protocol) {\n-  return ::socket(domain, type, protocol);\n-}\n-\n-inline int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n-  return os::send(fd, buf, nBytes, flags);\n-}\n-\n-inline int os::connect(int fd, struct sockaddr* him, socklen_t len) {\n-  RESTARTABLE_RETURN_INT(::connect(fd, him, len));\n-}\n-\n-inline struct hostent* os::get_host_by_name(char* name) {\n-  return ::gethostbyname(name);\n-}\n-\n-inline void os::exit(int num) {\n-  ::exit(num);\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,7 +31,0 @@\n-\/\/ System includes\n-\n-#include <unistd.h>\n-#include <sys\/socket.h>\n-#include <poll.h>\n-#include <netdb.h>\n-\n@@ -51,57 +44,0 @@\n-inline void os::dll_unload(void *lib) {\n-  ::dlclose(lib);\n-}\n-\n-inline jlong os::lseek(int fd, jlong offset, int whence) {\n-  return (jlong) ::lseek64(fd, offset, whence);\n-}\n-\n-inline int os::fsync(int fd) {\n-  return ::fsync(fd);\n-}\n-\n-inline int os::ftruncate(int fd, jlong length) {\n-  return ::ftruncate64(fd, length);\n-}\n-\n-inline bool os::numa_has_static_binding()   { return true; }\n-inline bool os::numa_has_group_homing()     { return false;  }\n-\n-inline size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n-  size_t res;\n-  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);\n-  return res;\n-}\n-\n-inline int os::socket_close(int fd) {\n-  return ::close(fd);\n-}\n-\n-inline int os::socket(int domain, int type, int protocol) {\n-  return ::socket(domain, type, protocol);\n-}\n-\n-inline int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, flags));\n-}\n-\n-inline int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n-  return os::send(fd, buf, nBytes, flags);\n-}\n-\n-inline int os::connect(int fd, struct sockaddr* him, socklen_t len) {\n-  RESTARTABLE_RETURN_INT(::connect(fd, him, len));\n-}\n-\n-inline struct hostent* os::get_host_by_name(char* name) {\n-  return ::gethostbyname(name);\n-}\n-\n-inline void os::exit(int num) {\n-  ::exit(num);\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.inline.hpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include <sys\/socket.h>\n+#include <netdb.h>\n@@ -45,0 +47,26 @@\n+inline void os::dll_unload(void *lib) {\n+  ::dlclose(lib);\n+}\n+\n+inline jlong os::lseek(int fd, jlong offset, int whence) {\n+  return (jlong) BSD_ONLY(::lseek) NOT_BSD(::lseek64)(fd, offset, whence);\n+}\n+\n+inline int os::fsync(int fd) {\n+  return ::fsync(fd);\n+}\n+\n+inline int os::ftruncate(int fd, jlong length) {\n+   return BSD_ONLY(::ftruncate) NOT_BSD(::ftruncate64)(fd, length);\n+}\n+\n+\/\/ Aix does not have NUMA support but need these for compilation.\n+inline bool os::numa_has_static_binding()   { AIX_ONLY(ShouldNotReachHere();) return true; }\n+inline bool os::numa_has_group_homing()     { AIX_ONLY(ShouldNotReachHere();) return false;  }\n+\n+inline size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n+  size_t res;\n+  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);\n+  return res;\n+}\n+\n@@ -49,0 +77,32 @@\n+inline int os::socket_close(int fd) {\n+  return ::close(fd);\n+}\n+\n+inline int os::socket(int domain, int type, int protocol) {\n+  return ::socket(domain, type, protocol);\n+}\n+\n+inline int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n+  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, flags));\n+}\n+\n+inline int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n+  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, flags));\n+}\n+\n+inline int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n+  return os::send(fd, buf, nBytes, flags);\n+}\n+\n+inline int os::connect(int fd, struct sockaddr* him, socklen_t len) {\n+  RESTARTABLE_RETURN_INT(::connect(fd, him, len));\n+}\n+\n+inline struct hostent* os::get_host_by_name(char* name) {\n+  return ::gethostbyname(name);\n+}\n+\n+inline void os::exit(int num) {\n+  ::exit(num);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"}]}