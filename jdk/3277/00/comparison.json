{"files":[{"patch":"@@ -1035,0 +1035,4 @@\n+  \/\/ Create an array for mapping default methods to their vtable indices in\n+  \/\/ this class, since default methods vtable indices are the indices for\n+  \/\/ the defining class.\n+  klass->create_new_default_vtable_indices(new_size, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  assert(_thread->is_Java_thread(), \"non Java threads shouldn't allocate on the Heap\");\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -256,2 +256,2 @@\n-  ik->vtable().initialize_vtable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, \"cannot fail\");\n-  ik->itable().initialize_itable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, \"cannot fail\");\n+  ik->vtable().initialize_vtable();\n+  ik->itable().initialize_itable();\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {\n+static void reinitialize_vtable_of(Klass* ko) {\n@@ -518,1 +518,1 @@\n-  ko->vtable().initialize_vtable(false, CHECK);\n+  ko->vtable().initialize_vtable();\n@@ -523,1 +523,1 @@\n-      reinitialize_vtable_of(sk, CHECK);\n+      reinitialize_vtable_of(sk);\n@@ -528,1 +528,1 @@\n-void Universe::reinitialize_vtables(TRAPS) {\n+static void reinitialize_vtables() {\n@@ -533,1 +533,1 @@\n-  Universe::reinitialize_vtable_of(ok, THREAD);\n+  reinitialize_vtable_of(ok);\n@@ -537,2 +537,2 @@\n-void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {\n-  k->itable().initialize_itable(false, CHECK);\n+static void initialize_itable_for_klass(InstanceKlass* k) {\n+  k->itable().initialize_itable();\n@@ -542,3 +542,3 @@\n-void Universe::reinitialize_itables(TRAPS) {\n-  MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);\n-  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);\n+static void reinitialize_itables() {\n+  MutexLocker mcld(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass);\n@@ -949,3 +949,2 @@\n-    ResourceMark rm;\n-    Universe::reinitialize_vtables(CHECK_false);\n-    Universe::reinitialize_itables(CHECK_false);\n+    reinitialize_vtables();\n+    reinitialize_itables();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -175,3 +175,0 @@\n-  static void reinitialize_vtable_of(Klass* k, TRAPS);\n-  static void reinitialize_vtables(TRAPS);\n-  static void reinitialize_itables(TRAPS);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  k->vtable().initialize_vtable(false, CHECK);\n+  k->vtable().initialize_vtable();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -991,2 +991,2 @@\n-        vtable().initialize_vtable(true, CHECK_false);\n-        itable().initialize_itable(true, CHECK_false);\n+        vtable().initialize_vtable_and_check_constraints(CHECK_false);\n+        itable().initialize_itable_and_check_constraints(CHECK_false);\n@@ -2602,2 +2602,2 @@\n-    vtable().initialize_vtable(false, CHECK);\n-    itable().initialize_itable(false, CHECK);\n+    vtable().initialize_vtable();\n+    itable().initialize_itable();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {\n+void klassVtable::initialize_vtable(GrowableArray<InstanceKlass*>* supers) {\n@@ -168,0 +168,1 @@\n+  Thread* current = Thread::current();\n@@ -170,1 +171,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -201,1 +202,1 @@\n-      methodHandle mh(THREAD, methods->at(i));\n+      methodHandle mh(current, methods->at(i));\n@@ -203,1 +204,1 @@\n-      bool needs_new_entry = update_inherited_vtable(mh, super_vtable_len, -1, checkconstraints, CHECK);\n+      bool needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, -1, supers);\n@@ -217,7 +218,3 @@\n-        Array<int>* def_vtable_indices = NULL;\n-        if ((def_vtable_indices = ik()->default_vtable_indices()) == NULL) {\n-          assert(!is_shared, \"shared class def_vtable_indices does not exist\");\n-          def_vtable_indices = ik()->create_new_default_vtable_indices(len, CHECK);\n-        } else {\n-          assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n-        }\n+        Array<int>* def_vtable_indices = ik()->default_vtable_indices();\n+        assert(def_vtable_indices != NULL, \"should be created\");\n+        assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n@@ -230,1 +227,1 @@\n-            methodHandle mh(THREAD, default_methods->at(i));\n+            methodHandle mh(current, default_methods->at(i));\n@@ -232,1 +229,1 @@\n-            needs_new_entry = update_inherited_vtable(mh, super_vtable_len, i, checkconstraints, CHECK);\n+            needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, i, supers);\n@@ -260,1 +257,1 @@\n-      initialized = fill_in_mirandas(THREAD, initialized);\n+      initialized = fill_in_mirandas(current, initialized);\n@@ -360,2 +357,1 @@\n-                        Klass* target_klass, Method* super_method,\n-                        Thread* thread) {\n+                        Klass* target_klass, Method* super_method) {\n@@ -364,1 +360,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm;\n@@ -387,1 +383,2 @@\n-bool klassVtable::update_inherited_vtable(const methodHandle& target_method,\n+bool klassVtable::update_inherited_vtable(Thread* current,\n+                                          const methodHandle& target_method,\n@@ -389,2 +386,1 @@\n-                                          bool checkconstraints, TRAPS) {\n-  ResourceMark rm(THREAD);\n+                                          GrowableArray<InstanceKlass*>* supers) {\n@@ -463,2 +459,2 @@\n-  HandleMark hm(THREAD);\n-  Handle target_loader(THREAD, target_klass->class_loader());\n+  HandleMark hm(current);\n+  Handle target_loader(current, target_klass->class_loader());\n@@ -510,36 +506,3 @@\n-\n-        \/\/ Do not check loader constraints for overpass methods because overpass\n-        \/\/ methods are created by the jvm to throw exceptions.\n-        if (checkconstraints && !target_method->is_overpass()) {\n-          \/\/ Override vtable entry if passes loader constraint check\n-          \/\/ if loader constraint checking requested\n-          \/\/ No need to visit his super, since he and his super\n-          \/\/ have already made any needed loader constraints.\n-          \/\/ Since loader constraints are transitive, it is enough\n-          \/\/ to link to the first super, and we get all the others.\n-          Handle super_loader(THREAD, super_klass->class_loader());\n-\n-          if (target_loader() != super_loader()) {\n-            ResourceMark rm(THREAD);\n-            Symbol* failed_type_symbol =\n-              SystemDictionary::check_signature_loaders(signature, _klass,\n-                                                        target_loader, super_loader,\n-                                                        true);\n-            if (failed_type_symbol != NULL) {\n-              stringStream ss;\n-              ss.print(\"loader constraint violation for class %s: when selecting \"\n-                       \"overriding method '\", klass->external_name());\n-              target_method->print_external_name(&ss),\n-              ss.print(\"' the class loader %s of the \"\n-                       \"selected method's type %s, and the class loader %s for its super \"\n-                       \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n-                       target_klass->class_loader_data()->loader_name_and_id(),\n-                       target_klass->external_name(),\n-                       super_klass->class_loader_data()->loader_name_and_id(),\n-                       super_klass->external_name(),\n-                       failed_type_symbol->as_klass_external_name(),\n-                       target_klass->class_in_module_of_loader(false, true),\n-                       super_klass->class_in_module_of_loader(false, true));\n-              THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);\n-            }\n-          }\n+        \/\/ Save super for constraint checking.\n+        if (supers != NULL) {\n+          supers->at_put(i, super_klass);\n@@ -569,1 +532,1 @@\n-      log_vtables(i, overrides, target_method, target_klass, super_method, THREAD);\n+      log_vtables(i, overrides, target_method, target_klass, super_method);\n@@ -601,0 +564,60 @@\n+void klassVtable::check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS) {\n+  assert(supers->length() == length(), \"lengths are different\");\n+  \/\/ For each method in the vtable, check constraints against any super class\n+  \/\/ if overridden.\n+  for (int i = 0; i < length(); i++) {\n+    methodHandle target_method(THREAD, unchecked_method_at(i));\n+    InstanceKlass* super_klass = supers->at(i);\n+    if (target_method() != NULL && super_klass != NULL) {\n+      \/\/ Do not check loader constraints for overpass methods because overpass\n+      \/\/ methods are created by the jvm to throw exceptions.\n+      if (!target_method->is_overpass()) {\n+        \/\/ Override vtable entry if passes loader constraint check\n+        \/\/ if loader constraint checking requested\n+        \/\/ No need to visit his super, since he and his super\n+        \/\/ have already made any needed loader constraints.\n+        \/\/ Since loader constraints are transitive, it is enough\n+        \/\/ to link to the first super, and we get all the others.\n+        Handle super_loader(THREAD, super_klass->class_loader());\n+        InstanceKlass* target_klass = target_method->method_holder();\n+        Handle target_loader(THREAD, target_klass->class_loader());\n+\n+        if (target_loader() != super_loader()) {\n+          ResourceMark rm(THREAD);\n+          Symbol* failed_type_symbol =\n+            SystemDictionary::check_signature_loaders(target_method->signature(),\n+                                                      _klass,\n+                                                      target_loader, super_loader,\n+                                                      true);\n+          if (failed_type_symbol != NULL) {\n+            stringStream ss;\n+            ss.print(\"loader constraint violation for class %s: when selecting \"\n+                     \"overriding method '\", _klass->external_name());\n+            target_method->print_external_name(&ss),\n+            ss.print(\"' the class loader %s of the \"\n+                     \"selected method's type %s, and the class loader %s for its super \"\n+                     \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n+                     target_klass->class_loader_data()->loader_name_and_id(),\n+                     target_klass->external_name(),\n+                     super_klass->class_loader_data()->loader_name_and_id(),\n+                     super_klass->external_name(),\n+                     failed_type_symbol->as_klass_external_name(),\n+                     target_klass->class_in_module_of_loader(false, true),\n+                     super_klass->class_in_module_of_loader(false, true));\n+            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void klassVtable::initialize_vtable_and_check_constraints(TRAPS) {\n+  \/\/ Save a superclass from each vtable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, NULL);\n+  initialize_vtable(supers);\n+  check_constraints(supers, CHECK);\n+}\n+\n+\n@@ -1110,1 +1133,1 @@\n-void klassItable::initialize_itable(bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable(GrowableArray<Method*>* supers) {\n@@ -1114,1 +1137,1 @@\n-    assign_itable_indices_for_interface(THREAD, InstanceKlass::cast(_klass));\n+    assign_itable_indices_for_interface(InstanceKlass::cast(_klass));\n@@ -1127,2 +1150,3 @@\n-    ResourceMark rm(THREAD);\n-    log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n+    if (log_develop_is_enabled(Debug, itables)) {\n+      ResourceMark rm;\n+      log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n@@ -1130,1 +1154,1 @@\n-\n+    }\n@@ -1133,2 +1157,1 @@\n-    int i;\n-    for(i = 0; i < num_interfaces; i++) {\n+    for(int i = 0; i < num_interfaces; i++) {\n@@ -1136,1 +1159,0 @@\n-      HandleMark hm(THREAD);\n@@ -1139,1 +1161,2 @@\n-      initialize_itable_for_interface(ioe->offset(), interf, checkconstraints, CHECK);\n+      initialize_itable_for_interface(ioe->offset(), interf, supers,\n+                       (ioe->offset() - offset_entry(0)->offset())\/wordSize);\n@@ -1141,1 +1164,0 @@\n-\n@@ -1148,0 +1170,56 @@\n+void klassItable::check_constraints(GrowableArray<Method*>* supers, TRAPS) {\n+\n+  assert(_size_method_table == supers->length(), \"wrong size\");\n+  itableMethodEntry* ime = method_entry(0);\n+  for (int i = 0; i < _size_method_table; i++) {\n+    Method* target = ime->method();\n+    Method* interface_method = supers->at(i); \/\/ method overridden\n+\n+    if (target != NULL && interface_method != NULL) {\n+      InstanceKlass* method_holder = target->method_holder();\n+      InstanceKlass* interf = interface_method->method_holder();\n+      HandleMark hm(THREAD);\n+      Handle method_holder_loader(THREAD, method_holder->class_loader());\n+      Handle interface_loader(THREAD, interf->class_loader());\n+\n+      if (method_holder_loader() != interface_loader()) {\n+        ResourceMark rm(THREAD);\n+        Symbol* failed_type_symbol =\n+          SystemDictionary::check_signature_loaders(target->signature(),\n+                                                    _klass,\n+                                                    method_holder_loader,\n+                                                    interface_loader,\n+                                                    true);\n+        if (failed_type_symbol != NULL) {\n+          stringStream ss;\n+          ss.print(\"loader constraint violation in interface itable\"\n+                   \" initialization for class %s: when selecting method '\",\n+                   _klass->external_name());\n+          interface_method->print_external_name(&ss),\n+          ss.print(\"' the class loader %s for super interface %s, and the class\"\n+                   \" loader %s of the selected method's %s, %s have\"\n+                   \" different Class objects for the type %s used in the signature (%s; %s)\",\n+                   interf->class_loader_data()->loader_name_and_id(),\n+                   interf->external_name(),\n+                   method_holder->class_loader_data()->loader_name_and_id(),\n+                   method_holder->external_kind(),\n+                   method_holder->external_name(),\n+                   failed_type_symbol->as_klass_external_name(),\n+                   interf->class_in_module_of_loader(false, true),\n+                   method_holder->class_in_module_of_loader(false, true));\n+          THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+        }\n+      }\n+    }\n+    ime++;\n+  }\n+}\n+\n+void klassItable::initialize_itable_and_check_constraints(TRAPS) {\n+  \/\/ Save a super interface from each itable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Method*>* supers =\n+    new GrowableArray<Method*>(_size_method_table, _size_method_table, NULL);\n+  initialize_itable(supers);\n+  check_constraints(supers, CHECK);\n+}\n@@ -1160,1 +1238,1 @@\n-int klassItable::assign_itable_indices_for_interface(Thread* current, InstanceKlass* klass) {\n+int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass) {\n@@ -1162,3 +1240,6 @@\n-  ResourceMark rm(current);\n-  log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n-                             ++initialize_count, klass->name()->as_C_string());\n+  if (log_develop_is_enabled(Trace, itables)) {\n+    ResourceMark rm;\n+    log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n+                               ++initialize_count, klass->name()->as_C_string());\n+  }\n+\n@@ -1174,0 +1255,1 @@\n+        ResourceMark rm;\n@@ -1228,1 +1310,3 @@\n-void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf,\n+                                                  GrowableArray<Method*>* supers,\n+                                                  int start_offset) {\n@@ -1232,2 +1316,0 @@\n-  HandleMark hm(THREAD);\n-  Handle interface_loader (THREAD, interf->class_loader());\n@@ -1259,34 +1341,0 @@\n-      \/\/ Entry did resolve, check loader constraints before initializing\n-      \/\/ if checkconstraints requested\n-      if (checkconstraints) {\n-        Handle method_holder_loader (THREAD, target->method_holder()->class_loader());\n-        InstanceKlass* method_holder = target->method_holder();\n-        if (method_holder_loader() != interface_loader()) {\n-          ResourceMark rm(THREAD);\n-          Symbol* failed_type_symbol =\n-            SystemDictionary::check_signature_loaders(m->signature(),\n-                                                      _klass,\n-                                                      method_holder_loader,\n-                                                      interface_loader,\n-                                                      true);\n-          if (failed_type_symbol != NULL) {\n-            stringStream ss;\n-            ss.print(\"loader constraint violation in interface itable\"\n-                     \" initialization for class %s: when selecting method '\",\n-                     _klass->external_name());\n-            m->print_external_name(&ss),\n-            ss.print(\"' the class loader %s for super interface %s, and the class\"\n-                     \" loader %s of the selected method's %s, %s have\"\n-                     \" different Class objects for the type %s used in the signature (%s; %s)\",\n-                     interf->class_loader_data()->loader_name_and_id(),\n-                     interf->external_name(),\n-                     method_holder->class_loader_data()->loader_name_and_id(),\n-                     method_holder->external_kind(),\n-                     method_holder->external_name(),\n-                     failed_type_symbol->as_klass_external_name(),\n-                     interf->class_in_module_of_loader(false, true),\n-                     method_holder->class_in_module_of_loader(false, true));\n-            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n-          }\n-        }\n-      }\n@@ -1294,1 +1342,0 @@\n-      \/\/ ime may have moved during GC so recalculate address\n@@ -1297,0 +1344,7 @@\n+\n+      \/\/ Save super interface method to perform constraint checks.\n+      \/\/ The method is in the error message, that's why.\n+      if (supers != NULL) {\n+        supers->at_put(start_offset + ime_num, m);\n+      }\n+\n@@ -1299,1 +1353,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm;\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":166,"deletions":112,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+  void check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS);\n+\n@@ -66,1 +68,3 @@\n-  void initialize_vtable(bool checkconstraints, TRAPS);   \/\/ initialize vtable of a new klass\n+  \/\/ initialize vtable of a new klass\n+  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = NULL);\n+  void initialize_vtable_and_check_constraints(TRAPS);\n@@ -118,1 +122,2 @@\n-  bool update_inherited_vtable(const methodHandle& target_method,\n+  bool update_inherited_vtable(Thread* current,\n+                               const methodHandle& target_method,\n@@ -121,1 +126,1 @@\n-                               bool checkconstraints, TRAPS);\n+                               GrowableArray<InstanceKlass*>* supers);\n@@ -281,1 +286,3 @@\n-  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h, bool checkconstraints, TRAPS);\n+  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h,\n+                                       GrowableArray<Method*>* supers, int start_offset);\n+  void check_constraints(GrowableArray<Method*>* supers, TRAPS);\n@@ -294,1 +301,2 @@\n-  void initialize_itable(bool checkconstraints, TRAPS);\n+  void initialize_itable_and_check_constraints(TRAPS);\n+  void initialize_itable(GrowableArray<Method*>* supers = NULL);\n@@ -309,1 +317,1 @@\n-  static int assign_itable_indices_for_interface(Thread* current, InstanceKlass* klass);\n+  static int assign_itable_indices_for_interface(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4373,3 +4373,2 @@\n-  the_class->vtable().initialize_vtable(false, THREAD);\n-  the_class->itable().initialize_itable(false, THREAD);\n-  assert(!HAS_PENDING_EXCEPTION || (THREAD->pending_exception()->is_a(vmClasses::ThreadDeath_klass())), \"redefine exception\");\n+  the_class->vtable().initialize_vtable();\n+  the_class->itable().initialize_itable();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}