{"files":[{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -30,0 +31,4 @@\n+#ifdef LINUX\n+#include <sys\/mman.h>\n+#endif \/\/ LINUX\n+\n@@ -138,0 +143,57 @@\n+\/\/ Default value if probing is not implemented for a certain platform: 128TB\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+\/\/ Minimum value returned, if probing fails: 64GB\n+static const size_t MINIMUM_MAX_ADDRESS_BIT = 36;\n+\n+static size_t probe_valid_max_address_bit() {\n+#ifdef LINUX\n+  size_t max_address_bit = 0;\n+  const size_t page_size = os::vm_page_size();\n+  for (size_t i = DEFAULT_MAX_ADDRESS_BIT; i > MINIMUM_MAX_ADDRESS_BIT; --i) {\n+    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n+    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n+      \/\/ msync suceeded, the address is valid, and maybe even already mapped.\n+      max_address_bit = i;\n+      break;\n+    }\n+    if (errno != ENOMEM) {\n+      \/\/ Some error occured. This should never happen, but msync\n+      \/\/ has some undefined behavior, hence ignore this bit.\n+#ifdef ASSERT\n+      fatal(\"Received %s while probing the address space for the highest valid bit\", os::errno_name(errno));\n+#else \/\/ ASSERT\n+      log_warning_p(gc)(\"Received %s while probing the address space for the highest valid bit\", os::errno_name(errno));\n+#endif \/\/ ASSERT\n+      continue;\n+    }\n+    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n+    \/\/ Try to map it, to see if the address is valid.\n+    void* result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+    if (result_addr != MAP_FAILED) {\n+      munmap(result_addr, page_size);\n+    }\n+    if ((uintptr_t) result_addr == base_addr) {\n+      \/\/ address is valid\n+      max_address_bit = i;\n+      break;\n+    }\n+  }\n+  if (max_address_bit == 0) {\n+    \/\/ probing failed, allocate a very high page and take that bit as the maximum\n+    uintptr_t high_addr = ((uintptr_t) 1U) << DEFAULT_MAX_ADDRESS_BIT;\n+    void* result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+    if (result_addr != MAP_FAILED) {\n+      max_address_bit = BitsPerSize_t - count_leading_zeros((size_t) result_addr) - 1;\n+      munmap(result_addr, page_size);\n+    }\n+  }\n+  log_info_p(gc, init)(\"Probing address space for the highest valid bit: %zu\", max_address_bit);\n+  if (max_address_bit < MINIMUM_MAX_ADDRESS_BIT) {\n+    return MINIMUM_MAX_ADDRESS_BIT;\n+  }\n+  return max_address_bit;\n+#else \/\/ LINUX\n+  return DEFAULT_MAX_ADDRESS_BIT;\n+#endif \/\/ LINUX\n+}\n+\n@@ -139,2 +201,3 @@\n-  const size_t min_address_offset_bits = 42; \/\/ 4TB\n-  const size_t max_address_offset_bits = 44; \/\/ 16TB\n+  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n+  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const size_t min_address_offset_bits = max_address_offset_bits - 2;\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zGlobals_aarch64.cpp","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"}]}