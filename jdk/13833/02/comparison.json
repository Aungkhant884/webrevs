{"files":[{"patch":"@@ -91,1 +91,1 @@\n-                                               PhaseTransform* phase,\n+                                               PhaseValues* phase,\n@@ -306,1 +306,1 @@\n-                                                PhaseTransform* phase, Node* store,\n+                                                PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                                 PhaseTransform* phase,\n+                                 PhaseValues* phase,\n@@ -64,1 +64,1 @@\n-                                  PhaseTransform* phase, Node* store,\n+                                  PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -312,1 +312,1 @@\n-bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {\n+bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseValues* phase, Node* n) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -97,1 +97,1 @@\n-  static bool is_shenandoah_marking_if(PhaseTransform *phase, Node* n);\n+  static bool is_shenandoah_marking_if(PhaseValues* phase, Node* n);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Dict(Dict&&) = default;\n+\n@@ -78,0 +81,2 @@\n+\n+  NONCOPYABLE(Dict);\n","filename":"src\/hotspot\/share\/libadt\/dict.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,3 @@\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  VectorSet(VectorSet&&) = default;\n+\n@@ -113,0 +116,2 @@\n+\n+  NONCOPYABLE(VectorSet);\n","filename":"src\/hotspot\/share\/libadt\/vectset.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,\n+Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseValues* phase,\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-  static Node* Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,\n+  static Node* Ideal_base_and_offset(Node* ptr, PhaseValues* phase,\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -675,1 +675,1 @@\n-bool ArrayCopyNode::may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call) {\n+bool ArrayCopyNode::may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode* &call) {\n@@ -686,2 +686,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac) {\n-\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode* &ac) {\n@@ -728,1 +727,1 @@\n-bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {\n+bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  static bool may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call);\n+  static bool may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode* &call);\n@@ -176,1 +176,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -182,1 +182,1 @@\n-  static bool may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac);\n+  static bool may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode* &ac);\n@@ -186,1 +186,1 @@\n-  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const;\n+  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -1584,1 +1584,1 @@\n-Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {\n+Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseValues* phase, bool allow_new_nodes) {\n@@ -2198,1 +2198,1 @@\n-bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -632,1 +632,1 @@\n-  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -916,1 +916,1 @@\n-  virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) { return false;}\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) { return false;}\n@@ -925,1 +925,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase);\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase);\n@@ -930,1 +930,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase,\n@@ -934,1 +934,1 @@\n-  static Node* Ideal_klass(Node* ptr, PhaseTransform* phase) {\n+  static Node* Ideal_klass(Node* ptr, PhaseValues* phase) {\n@@ -1000,1 +1000,1 @@\n-  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseTransform *phase, bool can_create = true);\n+  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseValues* phase, bool can_create = true);\n@@ -1004,1 +1004,1 @@\n-  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseTransform* phase) {\n+  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseValues* phase) {\n@@ -1074,1 +1074,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase){ return false;}\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase){ return false;}\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-  Node_Array node_map = new Node_Array(a);\n+  Node_Array node_map;\n@@ -1461,1 +1461,1 @@\n-Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {\n+Node* PhiNode::unique_input(PhaseValues* phase, bool uncast) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,2 +218,2 @@\n-  Node* unique_input(PhaseTransform *phase, bool uncast);\n-  Node* unique_input(PhaseTransform *phase) {\n+  Node* unique_input(PhaseValues* phase, bool uncast);\n+  Node* unique_input(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List &worklist) {\n@@ -433,1 +433,2 @@\n-      worklist->push(n->unique_out());\n+      assert(useful.member(n->unique_out()), \"do not push a useless node\");\n+      worklist.push(n->unique_out());\n@@ -634,1 +635,3 @@\n-                  _for_igvn(nullptr),\n+                  _igvn_worklist(nullptr),\n+                  _type_array(nullptr),\n+                  _node_hash_table(nullptr),\n@@ -707,3 +710,0 @@\n-  \/\/ Node list that Iterative GVN will start with\n-  Unique_Node_List for_igvn(comp_arena());\n-  set_for_igvn(&for_igvn);\n@@ -714,1 +714,4 @@\n-  PhaseGVN gvn(node_arena(), estimated_size);\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _type_array = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash_table = new (comp_arena()) NodeHash(comp_arena(), estimated_size);\n+  PhaseGVN gvn;\n@@ -804,1 +807,1 @@\n-      PhaseRemoveUseless pru(initial_gvn(), &for_igvn);\n+      PhaseRemoveUseless pru(initial_gvn(), igvn_worklist());\n@@ -921,1 +924,3 @@\n-    _for_igvn(nullptr),\n+    _igvn_worklist(nullptr),\n+    _type_array(nullptr),\n+    _node_hash_table(nullptr),\n@@ -953,0 +958,3 @@\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _type_array = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash_table = new (comp_arena()) NodeHash(comp_arena(), 255);\n@@ -954,4 +962,1 @@\n-    \/\/ The following is a dummy for the sake of GraphKit::gen_stub\n-    Unique_Node_List for_igvn(comp_arena());\n-    set_for_igvn(&for_igvn);  \/\/ not used, but some GraphKit guys push on this\n-    PhaseGVN gvn(Thread::current()->resource_area(),255);\n+    PhaseGVN gvn;\n@@ -1952,1 +1957,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), igvn_worklist());\n@@ -1983,3 +1988,1 @@\n-    assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n-    for_igvn()->clear();\n-    gvn->replace_with(&igvn);\n+    igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -2048,1 +2051,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), igvn_worklist());\n@@ -2052,1 +2055,1 @@\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2095,2 +2098,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -2113,1 +2115,2 @@\n-  assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n+\n+  igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -2117,2 +2120,0 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n@@ -2140,2 +2141,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -2274,4 +2274,1 @@\n-    initial_gvn()->replace_with(&igvn);\n-    Unique_Node_List* old_worklist = for_igvn();\n-    old_worklist->clear();\n-    Unique_Node_List new_worklist(C->comp_arena());\n+    igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -2280,1 +2277,1 @@\n-      PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &new_worklist);\n+      PhaseRenumberLive prl(initial_gvn(), igvn_worklist());\n@@ -2282,3 +2279,1 @@\n-    Unique_Node_List* save_for_igvn = for_igvn();\n-    set_for_igvn(&new_worklist);\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2286,1 +2281,0 @@\n-    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2383,1 +2377,1 @@\n-    igvn = ccp;\n+    igvn.reset_from_igvn(&ccp);\n@@ -2447,0 +2441,4 @@\n+ \/\/ We will never use the NodeHash table any more. Clear it so that final_graph_reshaping does not have\n+ \/\/ to remove hashes to unlock nodes for modifications.\n+ C->node_hash_table().clear();\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+class NodeHash;\n@@ -90,0 +91,1 @@\n+class Type_Array;\n@@ -418,1 +420,10 @@\n-  Unique_Node_List*     _for_igvn;              \/\/ Initial work-list for next round of Iterative GVN\n+\n+  \/\/ Shared worklist for all IGVN rounds. Nodes can be pushed to it at any time.\n+  \/\/ If pushed outside IGVN, the Node is processed in the next IGVN round.\n+  Unique_Node_List*     _igvn_worklist;\n+\n+  \/\/ Shared type array for GVN, IGVN and CCP. It maps node ID -> Type*.\n+  Type_Array*           _type_array;\n+\n+  \/\/ Shared node hash table for GVN, IGVN and CCP.\n+  NodeHash*             _node_hash_table;\n@@ -938,1 +949,12 @@\n-  Unique_Node_List* for_igvn()                  { return _for_igvn; }\n+  Unique_Node_List& igvn_worklist() {\n+    assert(_igvn_worklist != nullptr, \"must be created in Compile::Compile\");\n+    return *_igvn_worklist;\n+  }\n+  Type_Array& type_array() {\n+    assert(_type_array != nullptr, \"must be created in Compile::Compile\");\n+    return *_type_array;\n+  }\n+  NodeHash& node_hash_table() {\n+    assert(_node_hash_table != nullptr, \"must be created in Compile::Compile\");\n+    return *_node_hash_table;\n+  }\n@@ -942,1 +964,0 @@\n-  void          set_for_igvn(Unique_Node_List *for_igvn) { _for_igvn = for_igvn; }\n@@ -951,1 +972,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List &worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1739,1 +1739,1 @@\n-int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseTransform* phase) {\n+int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseValues* phase) {\n@@ -2501,1 +2501,1 @@\n-int ConnectionGraph::address_offset(Node* adr, PhaseTransform *phase) {\n+int ConnectionGraph::address_offset(Node* adr, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  int find_init_values_null   (JavaObjectNode* ptn, PhaseTransform* phase);\n+  int find_init_values_null   (JavaObjectNode* ptn, PhaseValues* phase);\n@@ -529,1 +529,1 @@\n-  int address_offset(Node* adr, PhaseTransform *phase);\n+  int address_offset(Node* adr, PhaseValues* phase);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3920,1 +3920,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase) {\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase) {\n@@ -3947,1 +3947,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase,\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1272,1 +1272,1 @@\n-    Node_Array inputs = new Node_List();\n+    Node_Array inputs;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,2 +262,2 @@\n-  if (_nodes[n->_idx]) return;\n-  \/\/ Recursively set _nodes array to indicate where the Node goes\n+  if (_loop_ctrl[n->_idx]) return;\n+  \/\/ Recursively set _loop_ctrl array to indicate where the Node goes\n@@ -4271,2 +4271,2 @@\n-  _nodes.map(C->unique(), nullptr);\n-  memset(_nodes.adr(), 0, wordSize * C->unique());\n+  _loop_ctrl.map(C->unique(), nullptr);\n+  memset(_loop_ctrl.adr(), 0, wordSize * C->unique());\n@@ -4338,1 +4338,1 @@\n-      _nodes.clear();\n+      _loop_ctrl.clear();\n@@ -4368,1 +4368,1 @@\n-      if( !_nodes[C->root()->in(i)->_idx] ) {    \/\/ Dead path into Root?\n+      if( !_loop_ctrl[C->root()->in(i)->_idx] ) {    \/\/ Dead path into Root?\n@@ -4382,1 +4382,1 @@\n-  \/\/ node.  For CFG nodes, the _nodes array starts out and remains\n+  \/\/ node.  For CFG nodes, the _loop_ctrl array starts out and remains\n@@ -4384,1 +4384,1 @@\n-  \/\/ _nodes array holds the earliest legal controlling CFG node.\n+  \/\/ _loop_ctrl array holds the earliest legal controlling CFG node.\n@@ -4677,1 +4677,1 @@\n-    success &= verify_nodes(n, phase_verify);\n+    success &= verify_loop_ctrl(n, phase_verify);\n@@ -4722,2 +4722,2 @@\n-\/\/ Verify \"_nodes\": control and loop membership.\n-\/\/  (0) _nodes[i] == nullptr -> node not reachable.\n+\/\/ Verify \"_loop_ctrl\": control and loop membership.\n+\/\/  (0) _loop_ctrl[i] == nullptr -> node not reachable.\n@@ -4727,1 +4727,1 @@\n-bool PhaseIdealLoop::verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const {\n+bool PhaseIdealLoop::verify_loop_ctrl(Node* n, const PhaseIdealLoop* phase_verify) const {\n@@ -4732,2 +4732,2 @@\n-  if (_nodes[i] == nullptr || phase_verify->_nodes[i] == nullptr) {\n-    if (_nodes[i] != nullptr || phase_verify->_nodes[i] != nullptr) {\n+  if (_loop_ctrl[i] == nullptr || phase_verify->_loop_ctrl[i] == nullptr) {\n+    if (_loop_ctrl[i] != nullptr || phase_verify->_loop_ctrl[i] != nullptr) {\n@@ -4735,1 +4735,1 @@\n-                 _nodes[i] != nullptr, phase_verify->_nodes[i] != nullptr);\n+                 _loop_ctrl[i] != nullptr, phase_verify->_loop_ctrl[i] != nullptr);\n@@ -4764,1 +4764,1 @@\n-    if( _nodes[i] != loop_verify->_nodes[i] &&\n+    if( _loop_ctrl[i] != loop_verify->_loop_ctrl[i] &&\n@@ -4998,1 +4998,1 @@\n-      \/\/ heal _idom if it has a fwd mapping in _nodes\n+      \/\/ heal _idom if it has a fwd mapping in _loop_ctrl\n@@ -5069,1 +5069,1 @@\n-\/\/ bits.  The _nodes[] array is mapped by Node index and holds a null for\n+\/\/ bits.  The _loop_ctrl[] array is mapped by Node index and holds a null for\n@@ -5195,1 +5195,1 @@\n-      if( !_nodes[m->_idx] ) continue; \/\/ Dead code has no loop\n+      if( !_loop_ctrl[m->_idx] ) continue; \/\/ Dead code has no loop\n@@ -5422,1 +5422,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_ctrl[]->loop mapping.\n@@ -5451,1 +5451,1 @@\n-            _nodes.map(n->_idx, (Node*)(ilt->_parent) );\n+            _loop_ctrl.map(n->_idx, (Node*)(ilt->_parent) );\n@@ -5610,1 +5610,1 @@\n-    if (_nodes[c->_idx] == nullptr)\n+    if (_loop_ctrl[c->_idx] == nullptr)\n@@ -5873,1 +5873,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_ctrl[]->loop mapping.\n@@ -5883,1 +5883,1 @@\n-      assert( _nodes[n->_idx], \"no dead nodes\" );\n+      assert( _loop_ctrl[n->_idx], \"no dead nodes\" );\n@@ -5891,1 +5891,1 @@\n-        if( _nodes[use->_idx] != nullptr || use->is_top() ) { \/\/ Not dead?\n+        if( _loop_ctrl[use->_idx] != nullptr || use->is_top() ) { \/\/ Not dead?\n@@ -5962,1 +5962,1 @@\n-\/\/ Put Data nodes into some loop nest, by setting the _nodes[]->loop mapping.\n+\/\/ Put Data nodes into some loop nest, by setting the _loop_ctrl[]->loop mapping.\n@@ -6031,1 +6031,1 @@\n-      _nodes.map(n->_idx,0);    \/\/ No block setting, it's globally dead\n+      _loop_ctrl.map(n->_idx,0);    \/\/ No block setting, it's globally dead\n@@ -6046,1 +6046,1 @@\n-      assert( _nodes[n->out(i1)->_idx] == nullptr, \"all uses must also be dead\");\n+      assert( _loop_ctrl[n->out(i1)->_idx] == nullptr, \"all uses must also be dead\");\n@@ -6049,1 +6049,1 @@\n-    _nodes.map(n->_idx, 0);     \/\/ This node is useless\n+    _loop_ctrl.map(n->_idx, 0);     \/\/ This node is useless\n@@ -6325,1 +6325,1 @@\n-    if (!_nodes[n->_idx])      \/\/ Skip dead nodes\n+    if (!_loop_ctrl[n->_idx])      \/\/ Skip dead nodes\n@@ -6358,1 +6358,1 @@\n-    for (uint k = 0; k < _nodes.max(); k++) {\n+    for (uint k = 0; k < _loop_ctrl.max(); k++) {\n@@ -6360,1 +6360,1 @@\n-      if (k < C->unique() && _nodes[k] == (Node*)((intptr_t)n + 1)) {\n+      if (k < C->unique() && _loop_ctrl[k] == (Node*)((intptr_t)n + 1)) {\n@@ -6364,2 +6364,2 @@\n-            tty->print_cr(\"*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p\",\n-                          _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : nullptr);\n+            tty->print_cr(\"*** BROKEN CTRL ACCESSOR!  _loop_ctrl[k] is %p, ctrl is %p\",\n+                          _loop_ctrl[k], has_ctrl(m) ? get_ctrl_no_update(m) : nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  bool can_be_counted_loop(PhaseTransform* phase) const {\n+  bool can_be_counted_loop(PhaseValues* phase) const {\n@@ -834,0 +834,3 @@\n+  \/\/ Map loop membership for CFG nodes, and ctrl for non-CFG nodes.\n+  Node_List _loop_ctrl;\n+\n@@ -895,1 +898,1 @@\n-  bool has_ctrl(const Node* n) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n+  bool has_ctrl(const Node* n) const { return ((intptr_t)_loop_ctrl[n->_idx]) & 1; }\n@@ -974,1 +977,1 @@\n-    return _nodes[n->_idx] != nullptr;\n+    return _loop_ctrl[n->_idx] != nullptr;\n@@ -986,1 +989,1 @@\n-    _nodes.map( n->_idx, (Node*)((intptr_t)ctrl + 1) );\n+    _loop_ctrl.map( n->_idx, (Node*)((intptr_t)ctrl + 1) );\n@@ -1006,1 +1009,1 @@\n-    _nodes.map( i->_idx, (Node*)((intptr_t)n + 1) );\n+    _loop_ctrl.map( i->_idx, (Node*)((intptr_t)n + 1) );\n@@ -1025,1 +1028,1 @@\n-    return (Node*)(((intptr_t)_nodes[i->_idx]) & ~1);\n+    return (Node*)(((intptr_t)_loop_ctrl[i->_idx]) & ~1);\n@@ -1049,1 +1052,1 @@\n-    _nodes.map(n->_idx, (Node*)loop);\n+    _loop_ctrl.map(n->_idx, (Node*)loop);\n@@ -1059,1 +1062,1 @@\n-    _nodes.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n+    _loop_ctrl.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n@@ -1138,1 +1141,1 @@\n-      n = (Node*)(((intptr_t)_nodes[n->_idx]) & ~1);\n+      n = (Node*)(((intptr_t)_loop_ctrl[n->_idx]) & ~1);\n@@ -1234,1 +1237,1 @@\n-    return (IdealLoopTree*)_nodes[n->_idx];\n+    return (IdealLoopTree*)_loop_ctrl[n->_idx];\n@@ -1699,1 +1702,1 @@\n-    return _nodes[n->_idx] ? (IdealLoopTree*)_nodes[n->_idx] : _ltree_root;\n+    return _loop_ctrl[n->_idx] ? (IdealLoopTree*)_loop_ctrl[n->_idx] : _ltree_root;\n@@ -1714,1 +1717,1 @@\n-  bool verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_loop_ctrl(Node* n, const PhaseIdealLoop* phase_verify) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  _new_nodes(C->comp_arena()),\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+  Node_List   _new_nodes;\n+\n@@ -150,1 +152,0 @@\n-  \/\/ Accessors for the inherited field PhaseTransform::_nodes:\n@@ -152,1 +153,1 @@\n-    _nodes.map(idx_limit-1, nullptr);\n+    _new_nodes.map(idx_limit-1, nullptr);\n@@ -155,1 +156,1 @@\n-    return _nodes.at(n->_idx) != nullptr;\n+    return _new_nodes.at(n->_idx) != nullptr;\n@@ -159,1 +160,1 @@\n-    return _nodes.at(n->_idx);\n+    return _new_nodes.at(n->_idx);\n@@ -163,1 +164,1 @@\n-    _nodes.map(n->_idx, nn);\n+    _new_nodes.map(n->_idx, nn);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  static const Type* Value(const OverflowOp* node, PhaseTransform* phase) {\n+  static const Type* Value(const OverflowOp* node, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class PhaseTransform;\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-Node* LoadNode::find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n+Node* LoadNode::find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n@@ -611,1 +611,1 @@\n-ArrayCopyNode* MemNode::find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const {\n+ArrayCopyNode* MemNode::find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const {\n@@ -655,1 +655,1 @@\n-Node* MemNode::find_previous_store(PhaseTransform* phase) {\n+Node* MemNode::find_previous_store(PhaseValues* phase) {\n@@ -1057,1 +1057,1 @@\n-Node* MemNode::can_see_stored_value(Node* st, PhaseTransform* phase) const {\n+Node* MemNode::can_see_stored_value(Node* st, PhaseValues* phase) const {\n@@ -2850,1 +2850,1 @@\n-bool StoreNode::value_never_loaded( PhaseTransform *phase) const {\n+bool StoreNode::value_never_loaded(PhaseValues* phase) const {\n@@ -3140,1 +3140,1 @@\n-bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseTransform* phase) {\n+bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseValues* phase) {\n@@ -3692,1 +3692,1 @@\n-intptr_t InitializeNode::get_store_offset(Node* st, PhaseTransform* phase) {\n+intptr_t InitializeNode::get_store_offset(Node* st, PhaseValues* phase) {\n@@ -3886,1 +3886,1 @@\n-                                                   PhaseTransform* phase) {\n+                                                   PhaseValues* phase) {\n@@ -3940,1 +3940,1 @@\n-                                          PhaseTransform* phase) {\n+                                          PhaseValues* phase) {\n@@ -3956,1 +3956,1 @@\n-                                       PhaseTransform* phase) {\n+                                       PhaseGVN* phase) {\n@@ -4500,1 +4500,1 @@\n-bool InitializeNode::stores_are_sane(PhaseTransform* phase) {\n+bool InitializeNode::stores_are_sane(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n-  ArrayCopyNode* find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n+  ArrayCopyNode* find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const;\n@@ -149,1 +149,1 @@\n-  Node* find_previous_store(PhaseTransform* phase);\n+  Node* find_previous_store(PhaseValues* phase);\n@@ -153,1 +153,1 @@\n-  Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;\n+  Node* can_see_stored_value(Node* st, PhaseValues* phase) const;\n@@ -211,1 +211,1 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n@@ -636,1 +636,1 @@\n-  bool value_never_loaded(PhaseTransform *phase) const;\n+  bool value_never_loaded(PhaseValues* phase) const;\n@@ -1120,1 +1120,1 @@\n-  static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);\n+  static bool step_through(Node** np, uint instance_id, PhaseValues* phase);\n@@ -1357,1 +1357,1 @@\n-  bool stores_are_sane(PhaseTransform* phase);\n+  bool stores_are_sane(PhaseValues* phase);\n@@ -1371,1 +1371,1 @@\n-  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);\n+  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseValues* phase);\n@@ -1383,1 +1383,1 @@\n-                                     PhaseTransform* phase);\n+                                     PhaseValues* phase);\n@@ -1385,1 +1385,1 @@\n-  static intptr_t get_store_offset(Node* st, PhaseTransform* phase);\n+  static intptr_t get_store_offset(Node* st, PhaseValues* phase);\n@@ -1387,1 +1387,1 @@\n-  Node* make_raw_address(intptr_t offset, PhaseTransform* phase);\n+  Node* make_raw_address(intptr_t offset, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1540,0 +1540,4 @@\n+  Node_Array() : Node_Array(Thread::current()->resource_area()) {}\n+\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_Array(Node_Array&&) = default;\n@@ -1541,1 +1545,0 @@\n-  Node_Array(Node_Array* na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n@@ -1557,0 +1560,2 @@\n+\n+  NONCOPYABLE(Node_Array);\n@@ -1565,0 +1570,4 @@\n+\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_List(Node_List&&) = default;\n+\n@@ -1588,0 +1597,2 @@\n+\n+  NONCOPYABLE(Node_List);\n@@ -1599,0 +1610,3 @@\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Unique_Node_List(Unique_Node_List&&) = default;\n+\n@@ -1630,0 +1644,4 @@\n+  void ensure_empty() {\n+    assert(size() == 0, \"must be empty\");\n+    clear(); \/\/ just in case\n+  }\n@@ -1634,0 +1652,21 @@\n+  \/\/ If the idx of the Nodes change, we must recompute the VectorSet\n+  void recompute_idx_set() {\n+    _in_worklist.clear();\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      _in_worklist.set(n->_idx);\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  bool is_subset_of(Unique_Node_List &other) {\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      if (!other.member(n)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+#endif\n+\n@@ -1642,0 +1681,1 @@\n+  NONCOPYABLE(Unique_Node_List);\n@@ -1676,1 +1716,1 @@\n-  _for_igvn->push(n);\n+  _igvn_worklist->push(n);\n@@ -1681,1 +1721,1 @@\n-  _for_igvn->remove(n);\n+  _igvn_worklist->remove(n);\n@@ -1752,0 +1792,2 @@\n+\n+  NONCOPYABLE(Node_Stack);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+  NONCOPYABLE(Phase);\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,16 +46,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(uint est_max_size) :\n-  _a(Thread::current()->resource_area()),\n-  _max( round_up(est_max_size < NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),\n-  _inserts(0), _insert_limit( insert_limit() ),\n-  _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) \/\/ (Node**)_a->Amalloc(_max * sizeof(Node*)) ),\n-#ifndef PRODUCT\n-  , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),\n-  _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),\n-   _total_inserts(0), _total_insert_probes(0)\n-#endif\n-{\n-  \/\/ _sentinel must be in the current node space\n-  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n-  memset(_table,0,sizeof(Node*)*_max);\n-}\n@@ -80,15 +64,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n-void NodeHash::replace_with(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n@@ -391,12 +360,0 @@\n-\n-void NodeHash::operator=(const NodeHash& nh) {\n-  \/\/ Unlock all nodes upon replacement of table.\n-  if (&nh == this)  return;\n-  if (_table != (Node**)badAddress)  clear();\n-  memcpy((void*)this, (void*)&nh, sizeof(*this));\n-  \/\/ Do not increment hash_lock counts again.\n-  \/\/ Instead, be sure we never again use the source table.\n-  ((NodeHash*)&nh)->_table = (Node**)badAddress;\n-}\n-\n-\n@@ -409,1 +366,1 @@\n-PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List* worklist, PhaseNumber phase_num) : Phase(phase_num) {\n+PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List &worklist, PhaseNumber phase_num) : Phase(phase_num) {\n@@ -423,1 +380,1 @@\n-  worklist->remove_useless_nodes(_useful.member_set());\n+  worklist.remove_useless_nodes(_useful.member_set());\n@@ -443,3 +400,2 @@\n-\/\/ (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be\n-\/\/ processed. A new worklist (with the updated node IDs) is returned in 'new_worklist'.\n-\/\/ 'worklist' is cleared upon returning.\n+\/\/ (1) The \"worklist\" is \"C->igvn_worklist()\", which is to collect which nodes need to\n+\/\/     be processed by IGVN after removal of the useless nodes.\n@@ -447,4 +403,2 @@\n-\/\/ node ID. The mapping is updated to use the new node IDs as well. Updated type\n-\/\/ information is returned in PhaseGVN::_types.\n-\/\/\n-\/\/ The PhaseRenumberLive phase does not preserve the order of elements in the worklist.\n+\/\/     node ID. The mapping is updated to use the new node IDs as well. Updated type\n+\/\/     information is returned in PhaseGVN::_types.\n@@ -454,2 +408,1 @@\n-\/\/ values is not based on node IDs. The field PhaseGVN::_nodes is not updated either\n-\/\/ because it is empty wherever PhaseRenumberLive is used.\n+\/\/ values is not based on node IDs.\n@@ -457,1 +410,1 @@\n-                                     Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                                     Unique_Node_List &worklist,\n@@ -467,1 +420,0 @@\n-  assert(gvn->nodes_size() == 0, \"GVN must not contain any nodes at this point\");\n@@ -469,2 +421,2 @@\n-\n-  uint worklist_size = worklist->size();\n+  assert(&worklist == &C->igvn_worklist(), \"sanity\");\n+  assert(&gvn->types() == &C->type_array(), \"sanity\");\n@@ -480,0 +432,2 @@\n+  assert(worklist.is_subset_of(_useful), \"sanity\");\n+\n@@ -484,5 +438,0 @@\n-    bool in_worklist = false;\n-    if (worklist->member(n)) {\n-      in_worklist = true;\n-    }\n-\n@@ -502,4 +451,0 @@\n-    if (in_worklist) {\n-      new_worklist->push(n);\n-    }\n-\n@@ -511,1 +456,3 @@\n-  assert(worklist_size == new_worklist->size(), \"the new worklist must have the same size as the original worklist\");\n+  \/\/ VectorSet in Unique_Node_Set must be recomputed, since ID's have changed.\n+  worklist.recompute_idx_set();\n+\n@@ -523,1 +470,1 @@\n-  gvn->replace_types(_new_type_array);\n+  gvn->types().swap(_new_type_array);\n@@ -530,3 +477,0 @@\n-\n-  \/\/ Clear the original worklist\n-  worklist->clear();\n@@ -584,49 +528,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),\n-  _arena(Thread::current()->resource_area()),\n-  _nodes(_arena),\n-  _types(_arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(arena),\n-  _nodes(arena),\n-  _types(arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-\/\/ Initialize with previously generated type information\n-PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(pt->_arena),\n-  _nodes(pt->_nodes),\n-  _types(pt->_types)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-}\n-\n-void PhaseTransform::init_con_caches() {\n+void PhaseValues::init_con_caches() {\n@@ -638,1 +534,0 @@\n-\n@@ -640,1 +535,1 @@\n-const TypeInt* PhaseTransform::find_int_type(Node* n) {\n+const TypeInt* PhaseValues::find_int_type(Node* n) {\n@@ -652,1 +547,1 @@\n-const TypeLong* PhaseTransform::find_long_type(Node* n) {\n+const TypeLong* PhaseValues::find_long_type(Node* n) {\n@@ -660,61 +555,0 @@\n-\n-#ifndef PRODUCT\n-void PhaseTransform::dump_old2new_map() const {\n-  _nodes.dump();\n-}\n-\n-void PhaseTransform::dump_new( uint nidx ) const {\n-  for( uint i=0; i<_nodes.max(); i++ )\n-    if( _nodes[i] && _nodes[i]->_idx == nidx ) {\n-      _nodes[i]->dump();\n-      tty->cr();\n-      tty->print_cr(\"Old index= %d\",i);\n-      return;\n-    }\n-  tty->print_cr(\"Node %d not found in the new indices\", nidx);\n-}\n-\n-\/\/------------------------------dump_types-------------------------------------\n-void PhaseTransform::dump_types( ) const {\n-  _types.dump();\n-}\n-\n-\/\/------------------------------dump_nodes_and_types---------------------------\n-void PhaseTransform::dump_nodes_and_types(const Node* root, uint depth, bool only_ctrl) {\n-  VectorSet visited;\n-  dump_nodes_and_types_recur(root, depth, only_ctrl, visited);\n-}\n-\n-\/\/------------------------------dump_nodes_and_types_recur---------------------\n-void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited) {\n-  if( !n ) return;\n-  if( depth == 0 ) return;\n-  if( visited.test_set(n->_idx) ) return;\n-  for( uint i=0; i<n->len(); i++ ) {\n-    if( only_ctrl && !(n->is_Region()) && i != TypeFunc::Control ) continue;\n-    dump_nodes_and_types_recur( n->in(i), depth-1, only_ctrl, visited );\n-  }\n-  n->dump();\n-  if (type_or_null(n) != nullptr) {\n-    tty->print(\"      \"); type(n)->dump(); tty->cr();\n-  }\n-}\n-\n-#endif\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues( Arena *arena, uint est_max_size )\n-  : PhaseTransform(arena, GVN), _table(arena, est_max_size), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues(PhaseValues* ptv)\n-  : PhaseTransform(ptv, GVN), _table(&ptv->_table), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n@@ -724,0 +558,1 @@\n+  \/\/ Statistics for NodeHash\n@@ -725,1 +560,0 @@\n-\n@@ -740,1 +574,1 @@\n-ConNode* PhaseTransform::makecon(const Type *t) {\n+ConNode* PhaseValues::makecon(const Type *t) {\n@@ -777,1 +611,1 @@\n-ConINode* PhaseTransform::intcon(jint i) {\n+ConINode* PhaseValues::intcon(jint i) {\n@@ -793,1 +627,1 @@\n-ConLNode* PhaseTransform::longcon(jlong l) {\n+ConLNode* PhaseValues::longcon(jlong l) {\n@@ -806,1 +640,1 @@\n-ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+ConNode* PhaseValues::integercon(jlong l, BasicType bt) {\n@@ -817,1 +651,1 @@\n-ConNode* PhaseTransform::zerocon(BasicType bt) {\n+ConNode* PhaseValues::zerocon(BasicType bt) {\n@@ -974,4 +808,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : PhaseGVN(igvn),\n-                                                 _delay_transform(igvn->_delay_transform),\n-                                                 _stack(igvn->_stack ),\n-                                                 _worklist(igvn->_worklist)\n+PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : _delay_transform(igvn->_delay_transform),\n+                                                 _worklist(C->igvn_worklist())\n@@ -980,0 +812,1 @@\n+  assert(&_worklist == &igvn->_worklist, \"sanity\");\n@@ -984,8 +817,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : PhaseGVN(gvn),\n-                                            _delay_transform(false),\n-\/\/ TODO: Before incremental inlining it was allocated only once and it was fine. Now that\n-\/\/       the constructor is used in incremental inlining, this consumes too much memory:\n-\/\/                                            _stack(C->live_nodes() >> 1),\n-\/\/       So, as a band-aid, we replace this by:\n-                                            _stack(C->comp_arena(), 32),\n-                                            _worklist(*C->for_igvn())\n+PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : _delay_transform(false),\n+                                            _worklist(C->igvn_worklist())\n@@ -1471,2 +1298,3 @@\n-  assert(_stack.is_empty(), \"not empty\");\n-  _stack.push(dead, PROCESS_INPUTS);\n+  ResourceMark rm;\n+  Node_Stack stack(32);\n+  stack.push(dead, PROCESS_INPUTS);\n@@ -1474,2 +1302,2 @@\n-  while (_stack.is_nonempty()) {\n-    dead = _stack.node();\n+  while (stack.is_nonempty()) {\n+    dead = stack.node();\n@@ -1479,1 +1307,1 @@\n-    uint progress_state = _stack.index();\n+    uint progress_state = stack.index();\n@@ -1485,1 +1313,1 @@\n-      _stack.set_index(PROCESS_OUTPUTS);\n+      stack.set_index(PROCESS_OUTPUTS);\n@@ -1497,1 +1325,1 @@\n-              _stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n+              stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n@@ -1544,1 +1372,1 @@\n-      _stack.push(dead->raw_out(0), PROCESS_INPUTS);\n+      stack.push(dead->raw_out(0), PROCESS_INPUTS);\n@@ -1547,1 +1375,1 @@\n-      _stack.pop();\n+      stack.pop();\n@@ -1552,1 +1380,1 @@\n-  } \/\/ while (_stack.is_nonempty())\n+  } \/\/ while (stack.is_nonempty())\n@@ -1915,2 +1743,0 @@\n-  \/\/ Clear out _nodes from IterGVN.  Must be clear to transform call.\n-  _nodes.clear();               \/\/ Clear out from IterGVN\n@@ -2193,4 +2019,0 @@\n-  Node *new_node = _nodes[n->_idx]; \/\/ Check for transformed node\n-  if( new_node != nullptr )\n-    return new_node;                \/\/ Been there, done that, return old answer\n-\n@@ -2200,1 +2022,4 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  ResourceMark rm;\n+  \/\/ Map: old node idx -> node after CCP (or nullptr if not yet transformed or useless).\n+  Node_List node_map;\n+  \/\/ Pre-allocate to avoid frequent realloc\n@@ -2202,1 +2027,2 @@\n-  Unique_Node_List useful; \/\/ track all visited nodes, so that we can remove the complement\n+  \/\/ track all visited nodes, so that we can remove the complement\n+  Unique_Node_List useful;\n@@ -2214,1 +2040,1 @@\n-    Node* new_node = _nodes[nn->_idx];\n+    Node* new_node = node_map[nn->_idx];\n@@ -2217,1 +2043,1 @@\n-    _nodes.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n+    node_map.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n@@ -2228,1 +2054,1 @@\n-        Node *new_input = _nodes[input->_idx]; \/\/ Check for cloned input node\n+        Node *new_input = node_map[input->_idx]; \/\/ Check for cloned input node\n@@ -2231,1 +2057,1 @@\n-          _nodes.map( input->_idx, new_input );\/\/ Flag as having been cloned\n+          node_map.map( input->_idx, new_input );\/\/ Flag as having been cloned\n@@ -2254,1 +2080,1 @@\n-  C->disconnect_useless_nodes(useful, &_worklist);\n+  C->disconnect_useless_nodes(useful, _worklist);\n@@ -2256,1 +2082,1 @@\n-  Node* new_root = _nodes[n->_idx];\n+  Node* new_root = node_map[n->_idx];\n@@ -2261,1 +2087,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":53,"deletions":228,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -54,1 +55,1 @@\n-class NodeHash : public StackObj {\n+class NodeHash : public AnyObj {\n@@ -64,1 +65,0 @@\n-  NodeHash(uint est_max_size);\n@@ -66,1 +66,0 @@\n-  NodeHash(NodeHash *use_this_state);\n@@ -68,2 +67,1 @@\n-  ~NodeHash();                  \/\/ Unlock all nodes upon destruction of table.\n-  void operator=(const NodeHash&); \/\/ Unlock all nodes upon replacement of table.\n+  ~NodeHash();\n@@ -96,1 +94,0 @@\n-  void   replace_with(NodeHash* nh);\n@@ -115,0 +112,1 @@\n+  NONCOPYABLE(NodeHash);\n@@ -123,2 +121,2 @@\n-\/\/ Despite the general name, this class is customized for use by PhaseTransform.\n-class Type_Array : public StackObj {\n+\/\/ Despite the general name, this class is customized for use by PhaseValues.\n+class Type_Array : public AnyObj {\n@@ -131,1 +129,1 @@\n-  friend class PhaseTransform;\n+  friend class PhaseValues;\n@@ -134,1 +132,0 @@\n-  Type_Array(Type_Array *ta) : _a(ta->_a), _max(ta->_max), _types(ta->_types) { }\n@@ -142,0 +139,8 @@\n+  void swap(Type_Array &other) {\n+    if (this != &other) {\n+      assert(_a == other._a, \"swapping for differing arenas is probably a bad idea\");\n+      ::swap(_max, other._max);\n+      ::swap(_types, other._types);\n+    }\n+  }\n+  NONCOPYABLE(Type_Array);\n@@ -152,1 +157,1 @@\n-  PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List *worklist, PhaseNumber phase_num = Remove_Useless);\n+  PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List &worklist, PhaseNumber phase_num = Remove_Useless);\n@@ -173,1 +178,1 @@\n-                    Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                    Unique_Node_List& worklist,\n@@ -184,0 +189,38 @@\n+public:\n+  PhaseTransform(PhaseNumber pnum) : Phase(pnum) {\n+#ifndef PRODUCT\n+    clear_progress();\n+    clear_transforms();\n+    set_allow_progress(true);\n+#endif\n+  }\n+\n+  \/\/ Return a node which computes the same function as this node, but\n+  \/\/ in a faster or cheaper fashion.\n+  virtual Node *transform( Node *n ) = 0;\n+\n+  \/\/ true if CFG node d dominates CFG node n\n+  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n+\n+#ifndef PRODUCT\n+  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n+  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n+  void   clear_progress()      { _count_progress = 0; }\n+  uint   made_progress() const { return _count_progress; }\n+\n+  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n+  void   set_transforms()      { ++_count_transforms; }\n+  void   clear_transforms()    { _count_transforms = 0; }\n+  uint   made_transforms() const{ return _count_transforms; }\n+\n+  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n+  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n+  bool   allow_progress()               { return _allow_progress; }\n+#endif\n+};\n+\n+\/\/ Phase infrastructure required for Node::Value computations.\n+\/\/ 1) Type array, and accessor methods.\n+\/\/ 2) Constants cache, which requires access to the types.\n+\/\/ 3) NodeHash table, to find identical nodes (and remove\/update the hash of a node on modification).\n+class PhaseValues : public PhaseTransform {\n@@ -185,3 +228,7 @@\n-  Arena*     _arena;\n-  Node_List  _nodes;           \/\/ Map old node indices to new nodes.\n-  Type_Array _types;           \/\/ Map old node indices to Types.\n+  bool      _iterGVN;\n+\n+  \/\/ Hash table for value-numbering. Reference to \"C->node_hash_table()\",\n+  NodeHash &_table;\n+\n+  \/\/ Type array mapping node idx to Type*. Reference to \"C->type_array()\".\n+  Type_Array &_types;\n@@ -190,0 +237,2 @@\n+  \/\/ Support both int and long caches because either might be an intptr_t,\n+  \/\/ so they show up frequently in address computations.\n@@ -201,3 +250,0 @@\n-  \/\/ Support both int and long caches because either might be an intptr_t,\n-  \/\/ so they show up frequently in address computations.\n-\n@@ -205,8 +251,7 @@\n-  PhaseTransform( PhaseNumber pnum );\n-  PhaseTransform( Arena *arena, PhaseNumber pnum );\n-  PhaseTransform( PhaseTransform *phase, PhaseNumber pnum );\n-\n-  Arena*      arena()   { return _arena; }\n-  Type_Array& types()   { return _types; }\n-  void replace_types(Type_Array new_types) {\n-    _types = new_types;\n+  PhaseValues() : PhaseTransform(GVN), _iterGVN(false),\n+                  _table(C->node_hash_table()), _types(C->type_array())\n+  {\n+    NOT_PRODUCT( clear_new_values(); )\n+    \/\/ Force allocation for currently existing nodes\n+    _types.map(C->unique(), nullptr);\n+    init_con_caches();\n@@ -214,3 +259,18 @@\n-  \/\/ _nodes is used in varying ways by subclasses, which define local accessors\n-  uint nodes_size() {\n-    return _nodes.size();\n+  NOT_PRODUCT(~PhaseValues();)\n+  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n+\n+  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n+  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n+  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n+  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n+  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n+\n+  \/\/ Used after parsing to eliminate values that are no longer in program\n+  void   remove_useless_nodes(VectorSet &useful) {\n+    _table.remove_useless_nodes(useful);\n+    \/\/ this may invalidate cached cons so reset the cache\n+    init_con_caches();\n+  }\n+\n+  Type_Array& types() {\n+    return _types;\n@@ -219,1 +279,0 @@\n-public:\n@@ -225,1 +284,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -234,1 +292,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -277,2 +334,1 @@\n-  virtual ConNode* uncached_makecon(const Type* t)  \/\/ override in PhaseValues\n-  { ShouldNotCallThis(); return nullptr; }\n+  ConNode* uncached_makecon(const Type* t);\n@@ -288,4 +344,0 @@\n-  \/\/ Return a node which computes the same function as this node, but\n-  \/\/ in a faster or cheaper fashion.\n-  virtual Node *transform( Node *n ) = 0;\n-\n@@ -340,3 +392,5 @@\n-  virtual const Type* saturate(const Type* new_type, const Type* old_type,\n-                               const Type* limit_type) const\n-  { ShouldNotCallThis(); return nullptr; }\n+  virtual const Type* saturate(const Type* new_type,\n+                               const Type* old_type,\n+                               const Type* limit_type) const {\n+    return new_type;\n+  }\n@@ -347,57 +401,0 @@\n-  \/\/ true if CFG node d dominates CFG node n\n-  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n-\n-#ifndef PRODUCT\n-  void dump_old2new_map() const;\n-  void dump_new( uint new_lidx ) const;\n-  void dump_types() const;\n-  void dump_nodes_and_types(const Node *root, uint depth, bool only_ctrl = true);\n-  void dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited);\n-\n-  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n-  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n-  void   clear_progress()      { _count_progress = 0; }\n-  uint   made_progress() const { return _count_progress; }\n-\n-  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n-  void   set_transforms()      { ++_count_transforms; }\n-  void   clear_transforms()    { _count_transforms = 0; }\n-  uint   made_transforms() const{ return _count_transforms; }\n-\n-  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n-  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n-  bool   allow_progress()               { return _allow_progress; }\n-#endif\n-};\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Phase infrastructure to support values\n-class PhaseValues : public PhaseTransform {\n-protected:\n-  NodeHash  _table;             \/\/ Hash table for value-numbering\n-  bool      _iterGVN;\n-public:\n-  PhaseValues(Arena* arena, uint est_max_size);\n-  PhaseValues(PhaseValues* pt);\n-  NOT_PRODUCT(~PhaseValues();)\n-  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n-\n-  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n-  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n-  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n-  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n-  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n-\n-  \/\/ Used after parsing to eliminate values that are no longer in program\n-  void   remove_useless_nodes(VectorSet &useful) {\n-    _table.remove_useless_nodes(useful);\n-    \/\/ this may invalidate cached cons so reset the cache\n-    init_con_caches();\n-  }\n-\n-  virtual ConNode* uncached_makecon(const Type* t);  \/\/ override from PhaseTransform\n-\n-  const Type* saturate(const Type* new_type, const Type* old_type,\n-                       const Type* limit_type) const\n-  { return new_type; }\n-\n@@ -420,2 +417,1 @@\n-  PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}\n-  PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}\n+  PhaseGVN() {}\n@@ -431,5 +427,0 @@\n-  void replace_with(PhaseGVN* gvn) {\n-    _table.replace_with(&gvn->_table);\n-    _types = gvn->_types;\n-  }\n-\n@@ -462,1 +453,0 @@\n-  Node_Stack _stack;      \/\/ Stack used to avoid recursion\n@@ -464,1 +454,0 @@\n-\n@@ -474,0 +463,1 @@\n+\n@@ -477,0 +467,20 @@\n+  \/\/ Reset IGVN from GVN: call deconstructor, and placement new.\n+  \/\/ Acheives the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(gvn);\n+  void reset_from_gvn(PhaseGVN* gvn) {\n+    if (this != gvn) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(gvn);\n+    }\n+  }\n+\n+  \/\/ Reset IGVN with another: call deconstructor, and placement new.\n+  \/\/ Acheives the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(other);\n+  void reset_from_igvn(PhaseIterGVN* other) {\n+    if (this != other) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(other);\n+    }\n+  }\n+\n@@ -481,1 +491,2 @@\n-  Unique_Node_List _worklist;       \/\/ Iterative worklist\n+  \/\/ Iterative worklist. Reference to \"C->igvn_worklist()\".\n+  Unique_Node_List &_worklist;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":119,"deletions":108,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-        if (_nodes[m->_idx] == nullptr) {\n+        if (_loop_ctrl[m->_idx] == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-const Type* SubNode::Value_common(PhaseTransform *phase) const {\n+const Type* SubNode::Value_common(PhaseValues* phase) const {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  const Type* Value_common( PhaseTransform *phase ) const;\n+  const Type* Value_common(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-  C->for_igvn()->clear();\n-  C->initial_gvn()->replace_with(&_igvn);\n+  C->igvn_worklist().ensure_empty(); \/\/ should be done with igvn\n@@ -67,1 +66,1 @@\n-    PhaseRemoveUseless pru(C->initial_gvn(), C->for_igvn());\n+    PhaseRemoveUseless pru(C->initial_gvn(), C->igvn_worklist());\n@@ -72,1 +71,1 @@\n-    _igvn = PhaseIterGVN(C->initial_gvn());\n+    _igvn.reset_from_gvn(C->initial_gvn());\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1692,1 +1692,0 @@\n-  declare_c2_type(NodeHash, StackObj)                                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}