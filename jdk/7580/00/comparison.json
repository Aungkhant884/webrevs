{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -422,1 +422,1 @@\n-                        if (iterator.hasNext()) {\n+                        while (iterator.hasNext()) {\n@@ -425,1 +425,1 @@\n-                                entryNameSeparator;\n+                                    entryNameSeparator;\n@@ -427,2 +427,5 @@\n-                        } else {\n-                            return false;\n+                            if (aliases.hasMoreElements()) {\n+                                return true;\n+                            } else {\n+                                continue;\n+                            }\n@@ -430,0 +433,1 @@\n+                        return false;\n@@ -434,2 +438,0 @@\n-\n-                return aliases.hasMoreElements();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DomainKeyStore.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    private void permits(AlgorithmParameters ap, ConstraintsParameters cp)\n+    public void permits(AlgorithmParameters ap, ConstraintsParameters cp)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.security.spec.PSSParameterSpec;\n@@ -1024,0 +1025,2 @@\n+                            AlgorithmId encAlgId = si.getDigestEncryptionAlgorithmId();\n+                            AlgorithmParameters sigAlgParams = encAlgId.getParameters();\n@@ -1038,0 +1041,2 @@\n+                                AlgorithmId tsEncAlgId = tsSi.getDigestEncryptionAlgorithmId();\n+                                AlgorithmParameters tsSigAlgParams = tsEncAlgId.getParameters();\n@@ -1052,2 +1057,2 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp, null),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp, sigAlgParams),\n@@ -1057,2 +1062,2 @@\n-                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts),\n-                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts, null),\n+                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts, tsSigAlgParams),\n@@ -1066,2 +1071,2 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp, null),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp, sigAlgParams),\n@@ -1396,1 +1401,1 @@\n-        boolean tsa, JarConstraintsParameters jcp) {\n+        boolean tsa, JarConstraintsParameters jcp, AlgorithmParameters algParams) {\n@@ -1404,0 +1409,9 @@\n+        if (algParams != null) {\n+            try {\n+                JAR_DISABLED_CHECK.permits(algParams, jcp);\n+            } catch (CertPathValidatorException e) {\n+                disabledAlgFound = true;\n+                return String.format(rb.getString(\"with.disabled\"), algParams);\n+            }\n+        }\n+\n@@ -1406,1 +1420,0 @@\n-            return alg;\n@@ -1422,0 +1435,11 @@\n+        if (algParams != null) {\n+            try {\n+                LEGACY_CHECK.permits(algParams, jcp);\n+                return alg;\n+            } catch (CertPathValidatorException e) {\n+                legacyAlg |= 2;\n+                legacySigAlg = alg;\n+                return String.format(rb.getString(\"with.weak\"), algParams);\n+            }\n+        }\n+        return alg;\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265765\n+ * @summary Test DomainKeyStore with a collection of keystores that has an empty one in between\n+ *          based on the test in the bug report\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.DomainLoadStoreParameter;\n+import java.security.KeyStore;\n+import java.util.Enumeration;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.crypto.KeyGenerator;\n+\n+public class DksWithEmptyKeystore {\n+    private static void write(Path p, KeyStore keystore) throws Exception {\n+        try (OutputStream outputStream = Files.newOutputStream(p)) {\n+            keystore.store(outputStream, new char[] { 'x' });\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n+        kg.init(256);\n+\n+        \/\/ Create a keystore with one key\n+        KeyStore nonEmptyKeystore = KeyStore.getInstance(\"PKCS12\");\n+        nonEmptyKeystore.load(null, null);\n+\n+        Path nonEmptyPath = Path.of(\"non_empty.p12\");\n+        nonEmptyKeystore.setKeyEntry(\"aeskey\", kg.generateKey(), new char[] { 'a' }, null);\n+        write(nonEmptyPath, nonEmptyKeystore);\n+\n+        \/\/ Create an empty keystore\n+        KeyStore emptyKeystore = KeyStore.getInstance(\"PKCS12\");\n+        emptyKeystore.load(null, null);\n+\n+        Path emptyPath = Path.of(\"empty.p12\");\n+        write(emptyPath, emptyKeystore);\n+\n+        \/\/ Create a domain keystore with two non-empty keystores\n+        Path dksWithTwoPartsPath = Path.of(\"two-parts.dks\");\n+        var twoPartsConfiguration = \"\"\"\n+                domain Combo {\n+                    keystore a keystoreURI=\"%s\";\n+                    keystore b keystoreURI=\"%s\";\n+                };\n+                \"\"\";\n+        Files.writeString(dksWithTwoPartsPath, String.format(twoPartsConfiguration,\n+                nonEmptyPath.toUri(), nonEmptyPath.toUri()));\n+        Map<String,KeyStore.ProtectionParameter> protectionParameters = new LinkedHashMap<>();\n+\n+        KeyStore dksKeystore = KeyStore.getInstance(\"DKS\");\n+        dksKeystore.load(new DomainLoadStoreParameter(dksWithTwoPartsPath.toUri(), protectionParameters));\n+        System.out.printf(\"%s size: %d%n\", dksWithTwoPartsPath, dksKeystore.size());\n+\n+        int index = 0;\n+        for (Enumeration<String> enumeration = dksKeystore.aliases(); enumeration.hasMoreElements(); ) {\n+            System.out.printf(\"%d: %s%n\", index, enumeration.nextElement());\n+            index++;\n+        }\n+\n+        System.out.printf(\"enumerated aliases from %s: %d%n\", dksWithTwoPartsPath, index);\n+        if (index != dksKeystore.size()) {\n+            throw new Exception(\"Failed to get the number of aliases in the domain keystore \" +\n+                    \"that has two keystores.\");\n+        }\n+\n+        \/\/ Create a domain keystore with two non-empty keystores and an empty one in between\n+        Path dksWithThreePartsPath = Path.of(\"three-parts.dks\");\n+        var threePartsConfiguration = \"\"\"\n+                domain Combo {\n+                    keystore a keystoreURI=\"%s\";\n+                    keystore b keystoreURI=\"%s\";\n+                    keystore c keystoreURI=\"%s\";\n+                };\n+                \"\"\";\n+        Files.writeString(dksWithThreePartsPath, String.format(threePartsConfiguration,\n+                nonEmptyPath.toUri(), emptyPath.toUri(), nonEmptyPath.toUri()));\n+\n+        KeyStore dksKeystore1 = KeyStore.getInstance(\"DKS\");\n+        dksKeystore1.load(new DomainLoadStoreParameter(dksWithThreePartsPath.toUri(), protectionParameters));\n+        System.out.printf(\"%s size: %d%n\", dksWithThreePartsPath, dksKeystore1.size());\n+\n+        index = 0;\n+        for (Enumeration<String> enumeration = dksKeystore1.aliases(); enumeration.hasMoreElements(); ) {\n+            System.out.printf(\"%d: %s%n\", index, enumeration.nextElement());\n+            index++;\n+        }\n+\n+        System.out.printf(\"enumerated aliases from %s: %d%n\", dksWithThreePartsPath, index);\n+        if (index != dksKeystore1.size()) {\n+            throw new Exception(\"Failed to get the number of aliases in the domain keystore \" +\n+                    \"that has three keystores with an empty one in between.\");\n+        } else {\n+            System.out.printf(\"Test completed successfully\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/KeyStore\/DksWithEmptyKeystore.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277474\n+ * @summary jarsigner -verify should check if the algorithm parameters of\n+ *          its signature algorithm use disabled or legacy algorithms\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.x509\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckAlgParams {\n+    private static final String JAVA_SECURITY_FILE = \"java.security\";\n+\n+    public static void main(String[] args) throws Exception{\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg RSASSA-PSS -alias ca -dname CN=CA \" +\n+                \"-ext bc:c\")\n+                .shouldHaveExitValue(0);\n+\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"), Path.of(\"ks\"));\n+\n+        SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                \"-signedjar signeda.jar \" +\n+                \"-verbose\" +\n+                \" a.jar ca\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.jar.disabledAlgorithms=SHA256\\n\" +\n+                \"jdk.security.legacyAlgorithms=\\n\");\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldMatch(\"Digest algorithm: SHA-256.*(disabled)\")\n+                .shouldMatch(\"Signature algorithm: PSSParameterSpec.*hashAlgorithm=SHA-256.*(disabled)\")\n+                .shouldContain(\"The jar will be treated as unsigned\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.deleteIfExists(Paths.get(JAVA_SECURITY_FILE));\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.jar.disabledAlgorithms=\\n\" +\n+                \"jdk.security.legacyAlgorithms=SHA256\\n\");\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldMatch(\"Digest algorithm: SHA-256.*(weak)\")\n+                .shouldMatch(\"Signature algorithm: PSSParameterSpec.*hashAlgorithm=SHA-256.*(weak)\")\n+                .shouldNotContain(\"The jar will be treated as unsigned\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/CheckAlgParams.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}