{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -543,0 +543,2 @@\n+    DEBUG_ONLY(verify_packs();)\n+\n@@ -646,45 +648,3 @@\n-    bool create_pack = true;\n-    if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {\n-      if (vectors_should_be_aligned()) {\n-        int vw = vector_width(mem_ref);\n-        int vw_best = vector_width(best_align_to_mem_ref);\n-        if (vw > vw_best) {\n-          \/\/ Do not vectorize a memory access with more elements per vector\n-          \/\/ if unaligned memory access is not allowed because number of\n-          \/\/ iterations in pre-loop will be not enough to align it.\n-          create_pack = false;\n-        } else {\n-          SWPointer p2(best_align_to_mem_ref, this, NULL, false);\n-          if (!align_to_ref_p.invar_equals(p2)) {\n-            \/\/ Do not vectorize memory accesses with different invariants\n-            \/\/ if unaligned memory accesses are not allowed.\n-            create_pack = false;\n-          }\n-        }\n-      }\n-    } else {\n-      if (same_velt_type(mem_ref, best_align_to_mem_ref)) {\n-        \/\/ Can't allow vectorization of unaligned memory accesses with the\n-        \/\/ same type since it could be overlapped accesses to the same array.\n-        create_pack = false;\n-      } else {\n-        \/\/ Allow independent (different type) unaligned memory operations\n-        \/\/ if HW supports them.\n-        if (vectors_should_be_aligned()) {\n-          create_pack = false;\n-        } else {\n-          \/\/ Check if packs of the same memory type but\n-          \/\/ with a different alignment were created before.\n-          for (uint i = 0; i < align_to_refs.size(); i++) {\n-            MemNode* mr = align_to_refs.at(i)->as_Mem();\n-            if (mr == mem_ref) {\n-              \/\/ Skip when we are looking at same memory operation.\n-              continue;\n-            }\n-            if (same_velt_type(mr, mem_ref) &&\n-                memory_alignment(mr, iv_adjustment) != 0)\n-              create_pack = false;\n-          }\n-        }\n-      }\n-    }\n+    bool create_pack = is_mem_ref_alignment_ok(mem_ref, iv_adjustment, align_to_ref_p,\n+                                               best_align_to_mem_ref, best_iv_adjustment,\n+                                               align_to_refs);\n@@ -798,0 +758,78 @@\n+\/\/ Check if alignment of mem_ref permissible on hardware, and if it is consistent with\n+\/\/ the other packs of same velt type.\n+bool SuperWord::is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                        Node_List &align_to_refs) {\n+  bool is_aligned_with_best = memory_alignment(mem_ref, best_iv_adjustment) == 0;\n+\n+  if (vectors_should_be_aligned()) {\n+    \/\/ All vectors need to be vector length aligned. We use best_align_to_mem_ref to adjust\n+    \/\/ the pre-loop limit such that all vector memory accesses are vector aligned. Hence, we\n+    \/\/ must ensure that all mem_refs that we vectorize are aligned with best_align_to_mem_ref.\n+    \/\/ These 3 conditions must be fulfilled:\n+    \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n+    if (!is_aligned_with_best) {\n+      return false;\n+    }\n+    \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n+    int vw = vector_width(mem_ref);\n+    int vw_best = vector_width(best_align_to_mem_ref);\n+    if (vw > vw_best) {\n+      \/\/ Do not vectorize a memory access with more elements per vector\n+      \/\/ if unaligned memory access is not allowed because number of\n+      \/\/ iterations in pre-loop will be not enough to align it.\n+      return false;\n+    }\n+    \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n+    \/\/     address = base + k*iv + constant [+ invar]\n+    \/\/     memory_alignment ignores the invariant.\n+    SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n+    if (!align_to_ref_p.invar_equals(p2)) {\n+      \/\/ Do not vectorize memory accesses with different invariants\n+      \/\/ if unaligned memory accesses are not allowed.\n+      return false;\n+    }\n+    return true;\n+  } else {\n+    \/\/ Alignment is not required by the hardware. However, we still have to make sure that\n+    \/\/ the memory accesses do not form a cyclic dependency.\n+\n+    \/\/ We have a compiler hint, so do not check alignment with other packs. For now we trust\n+    \/\/ the hint. We may create cyclic dependencies (packs that are not independent). Later\n+    \/\/ we will filter out packs that are not internally independent.\n+    \/\/ This allows us to vectorize cases like this (forward read):\n+    \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n+    \/\/ And the filtering still removes non-vectorizable cases like this (forward write):\n+    \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n+    if (_do_vector_loop) {\n+      return true;\n+    }\n+\n+    \/\/ An easy way to prevent cyclic dependencies is to require all mem_refs of the same type\n+    \/\/ to be exactly aligned. This allows us to vectorize these cases:\n+    \/\/ for (int i ...) { v[i] = v[i] + 5; }      \/\/ same alignment\n+    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector size\n+    if (same_velt_type(mem_ref, best_align_to_mem_ref)) {\n+      return is_aligned_with_best;\n+    } else {\n+      return is_mem_ref_aligned_with_same_velt_type(mem_ref, iv_adjustment, align_to_refs);\n+    }\n+  }\n+}\n+\n+\/\/ Check if alignment of mem_ref is consistent with the other packs of same velt type.\n+bool SuperWord::is_mem_ref_aligned_with_same_velt_type(MemNode* mem_ref, int iv_adjustment,\n+                                                       Node_List &align_to_refs) {\n+  for (uint i = 0; i < align_to_refs.size(); i++) {\n+    MemNode* mr = align_to_refs.at(i)->as_Mem();\n+    if (mr != mem_ref &&\n+        same_velt_type(mr, mem_ref) &&\n+        memory_alignment(mr, iv_adjustment) != 0) {\n+      \/\/ mem_ref is misaligned with mr, another ref of the same velt type.\n+      return false;\n+    }\n+  }\n+  \/\/ No misalignment found.\n+  return true;\n+}\n+\n@@ -1330,0 +1368,38 @@\n+\/\/------------------------------find_dependence---------------------\n+\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ We could query independent(s1, s2) for all pairs, but that results\n+\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n+\/\/ recursively, for nodes that have at least depth min_d, which is the\n+\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n+\/\/ those nodes, and have not found another node from the pack, we know\n+\/\/ that all nodes in the pack are independent.\n+Node* SuperWord::find_dependence(Node_List* p) {\n+  if (p->at(0)->is_reduction()) {\n+    return nullptr; \/\/ ignore reductions\n+  }\n+  ResourceMark rm;\n+  Unique_Node_List worklist; \/\/ traversal queue\n+  int min_d = depth(p->at(0));\n+  visited_clear();\n+  for (uint k = 0; k < p->size(); k++) {\n+    Node* n = p->at(k);\n+    min_d = MIN2(min_d, depth(n));\n+    worklist.push(n); \/\/ start traversal at all nodes in p\n+    visited_set(n); \/\/ mark node\n+  }\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (visited_test(pred)) { \/\/ marked as in p?\n+          return pred;\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1487,1 +1563,2 @@\n-    if (!in_bb(t1) || !in_bb(t2))\n+    if (!in_bb(t1) || !in_bb(t2) || t1->is_Mem() || t2->is_Mem())  {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n@@ -1489,0 +1566,1 @@\n+    }\n@@ -1526,1 +1604,4 @@\n-    if (!in_bb(t1)) continue;\n+    if (!in_bb(t1) || t1->is_Mem()) {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+      continue;\n+    }\n@@ -1529,1 +1610,4 @@\n-      if (!in_bb(t2)) continue;\n+      if (!in_bb(t2) || t2->is_Mem()) {\n+        \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+        continue;\n+      }\n@@ -1718,1 +1802,0 @@\n-        if (i == j) continue;\n@@ -1759,0 +1842,26 @@\n+  if (_do_vector_loop) {\n+    \/\/ Since we did not enforce exact alignment of the packsets, we only know that there\n+    \/\/ is no dependence with distance 1, because we have checked independent(s1, s2) for\n+    \/\/ all adjacent memops. But there could be a dependence of a different distance.\n+    \/\/ Hence: remove the pack if there is a dependence.\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* p = _packset.at(i);\n+      if (p != nullptr) {\n+        Node* dependence = find_dependence(p);\n+        if (dependence != nullptr) {\n+#ifndef PRODUCT\n+          if (TraceSuperWord) {\n+            tty->cr();\n+            tty->print_cr(\"WARNING: Found dependency.\");\n+            tty->print_cr(\"Cannot vectorize despite compile directive Vectorize.\");\n+            dependence->dump();\n+            tty->print_cr(\"In pack[%d]\", i);\n+            print_pack(p);\n+          }\n+#endif\n+          _packset.at_put(i, nullptr);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1777,1 +1886,0 @@\n-  Node_List* rslt = NULL;\n@@ -2207,0 +2315,23 @@\n+#ifdef ASSERT\n+void SuperWord::verify_packs() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    Node* dependence = find_dependence(p);\n+    if (dependence != nullptr) {\n+      tty->print_cr(\"Other nodes in pack have dependence on:\");\n+      dependence->dump();\n+      tty->print_cr(\"The following nodes are not independent:\");\n+      for (uint k = 0; k < p->size(); k++) {\n+        Node* n = p->at(k);\n+        if (!independent(n, dependence)) {\n+          n->dump();\n+        }\n+      }\n+      tty->print_cr(\"They are all from pack[%d]\", i);\n+      print_pack(p);\n+    }\n+    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n+  }\n+}\n+#endif\n+\n@@ -4025,1 +4156,5 @@\n-    print_pack(p);\n+    if (p == nullptr) {\n+      tty->print_cr(\"  nullptr\");\n+    } else {\n+      print_pack(p);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":187,"deletions":52,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,0 +478,6 @@\n+  \/\/ Check if alignment of mem_ref permissible on hardware, and if it is consistent with the other packs of same velt type.\n+  bool is_mem_ref_alignment_ok(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                               MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                               Node_List &align_to_refs);\n+  \/\/ Check if alignment of mem_ref is consistent with the other packs of same velt type.\n+  bool is_mem_ref_aligned_with_same_velt_type(MemNode* mem_ref, int iv_adjustment, Node_List &align_to_refs);\n@@ -514,0 +520,2 @@\n+  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+  Node* find_dependence(Node_List* p);\n@@ -545,0 +553,2 @@\n+  \/\/ Verify that for every pack, all nodes are mutually independent\n+  DEBUG_ONLY(void verify_packs();)\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+    public static final String ADD_VF = PREFIX + \"ADD_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VF, \"AddVF\");\n+    }\n+\n@@ -184,0 +189,5 @@\n+    public static final String ADD_REDUCTION_VI = PREFIX + \"ADD_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VI, \"AddReductionVI\");\n+    }\n+\n@@ -702,0 +712,5 @@\n+    public static final String MUL_VI = PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VI, \"MulVI\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Writing forward on array creates cyclic dependency\n+ *          which leads to wrong result, when ignored.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver TestCyclicDependency\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestCyclicDependency {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] goldI0 = new int[RANGE];\n+    float[] goldF0 = new float[RANGE];\n+    int[] goldI1 = new int[RANGE];\n+    float[] goldF1 = new float[RANGE];\n+    int[] goldI2 = new int[RANGE];\n+    float[] goldF2 = new float[RANGE];\n+    int[] goldI3 = new int[RANGE];\n+    float[] goldF3 = new float[RANGE];\n+    int[] goldI4 = new int[RANGE];\n+    float[] goldF4 = new float[RANGE];\n+    int[] goldI5a = new int[RANGE];\n+    float[] goldF5a = new float[RANGE];\n+    int[] goldI5b = new int[RANGE];\n+    float[] goldF5b = new float[RANGE];\n+    int[] goldI6a = new int[RANGE];\n+    float[] goldF6a = new float[RANGE];\n+    int[] goldI6b = new int[RANGE];\n+    float[] goldF6b = new float[RANGE];\n+    int[] goldI7 = new int[RANGE];\n+    float[] goldF7 = new float[RANGE];\n+    int[] goldI8 = new int[RANGE];\n+    float[] goldF8 = new float[RANGE];\n+    int[] goldI9 = new int[RANGE];\n+    float[] goldF9 = new float[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\");\n+    }\n+\n+    TestCyclicDependency() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test0\n+        init(goldI0, goldF0);\n+        test0(goldI0, goldF0);\n+        \/\/ test1\n+        init(goldI1, goldF1);\n+        test1(goldI1, goldF1);\n+        \/\/ test2\n+        init(goldI2, goldF2);\n+        test2(goldI2, goldF2);\n+        \/\/ test3\n+        init(goldI3, goldF3);\n+        test3(goldI3, goldF3);\n+        \/\/ test4\n+        init(goldI4, goldF4);\n+        test4(goldI4, goldF4);\n+        \/\/ test5a\n+        init(goldI5a, goldF5a);\n+        test5a(goldI5a, goldF5a);\n+        \/\/ test5b\n+        init(goldI5b, goldF5b);\n+        test5b(goldI5b, goldF5b);\n+        \/\/ test6a\n+        init(goldI6a, goldF6a);\n+        test6a(goldI6a, goldF6a);\n+        \/\/ test6b\n+        init(goldI6b, goldF6b);\n+        test6b(goldI6b, goldF6b);\n+        \/\/ test7\n+        init(goldI7, goldF7);\n+        test7(goldI7, goldF7);\n+        \/\/ test8\n+        init(goldI8, goldF8);\n+        test8(goldI8, goldF8);\n+        \/\/ test9\n+        init(goldI9, goldF9);\n+        test9(goldI9, goldF9);\n+    }\n+\n+    @Run(test = \"test0\")\n+    @Warmup(100)\n+    public void runTest0() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test0(dataI, dataF);\n+        verifyI(\"test0\", dataI, goldI0);\n+        verifyF(\"test0\", dataF, goldF0);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test1(dataI, dataF);\n+        verifyI(\"test1\", dataI, goldI1);\n+        verifyF(\"test1\", dataF, goldF1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test2(dataI, dataF);\n+        verifyI(\"test2\", dataI, goldI2);\n+        verifyF(\"test2\", dataF, goldF2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test3(dataI, dataF);\n+        verifyI(\"test3\", dataI, goldI3);\n+        verifyF(\"test3\", dataF, goldF3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test4(dataI, dataF);\n+        verifyI(\"test4\", dataI, goldI4);\n+        verifyF(\"test4\", dataF, goldF4);\n+    }\n+\n+    @Run(test = \"test5a\")\n+    @Warmup(100)\n+    public void runTest5a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5a(dataI, dataF);\n+        verifyI(\"test5a\", dataI, goldI5a);\n+        verifyF(\"test5a\", dataF, goldF5a);\n+    }\n+\n+    @Run(test = \"test5b\")\n+    @Warmup(100)\n+    public void runTest5b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5b(dataI, dataF);\n+        verifyI(\"test5b\", dataI, goldI5b);\n+        verifyF(\"test5b\", dataF, goldF5b);\n+    }\n+\n+    @Run(test = \"test6a\")\n+    @Warmup(100)\n+    public void runTest6a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6a(dataI, dataF);\n+        verifyI(\"test6a\", dataI, goldI6a);\n+        verifyF(\"test6a\", dataF, goldF6a);\n+    }\n+\n+    @Run(test = \"test6b\")\n+    @Warmup(100)\n+    public void runTest6b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6b(dataI, dataF);\n+        verifyI(\"test6b\", dataI, goldI6b);\n+        verifyF(\"test6b\", dataF, goldF6b);\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(100)\n+    public void runTest7() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test7(dataI, dataF);\n+        verifyI(\"test7\", dataI, goldI7);\n+        verifyF(\"test7\", dataF, goldF7);\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(100)\n+    public void runTest8() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test8(dataI, dataF);\n+        verifyI(\"test8\", dataI, goldI8);\n+        verifyF(\"test8\", dataF, goldF8);\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(100)\n+    public void runTest9() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test9(dataI, dataF);\n+        verifyI(\"test9\", dataI, goldI9);\n+        verifyF(\"test9\", dataF, goldF9);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test0(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ All perfectly aligned, expect vectorization\n+            int v = dataI[i];\n+            dataI[i] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test1(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 1, cannot vectorize\n+            int v = dataI[i];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test2(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 2; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2, cannot vectorize\n+            int v = dataI[i];\n+            dataI[i + 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test3(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 3; i++) {\n+            \/\/ dataI has cyclic dependency of distance 3, cannot vectorize\n+            int v = dataI[i];\n+            dataI[i + 3] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test4(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2, cannot vectorize\n+            int v = dataI[i - 1];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test5a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            \/\/ test5a and test5b should either both vectorize, or both not\n+            int v = dataI[i];\n+            dataI[i - 1] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test5b(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            \/\/ test5a and test5b should either both vectorize, or both not\n+            int v = dataI[i];\n+            dataI[i - 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test6a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            \/\/ test6a and test6b should either both vectorize, or both not\n+            int v = dataI[i];\n+            dataI[i - 2] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.STORE_VECTOR})\n+    static void test6b(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            \/\/ test6a and test6b should either both vectorize, or both not\n+            int v = dataI[i];\n+            dataI[i - 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.ADD_VF, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test7(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 32] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 3] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\", IRNode.ADD_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test8(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 3] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 32] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_REDUCTION_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test9(int[] dataI, float[] dataF) {\n+        int sI = 666;\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ self-cycle allowed for reduction\n+            sI += dataI[i] * 2; \/\/ factor necessary to make it profitable\n+        }\n+        dataI[0] = sI; \/\/ write back\n+    }\n+\n+    public static void init(int[] dataI, float[] dataF) {\n+        for (int j = 0; j < RANGE; j++) {\n+            dataI[j] = j;\n+            dataF[j] = j * 0.5f;\n+        }\n+    }\n+\n+    static void verifyI(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataI[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,5 @@\n- * @run main compiler.vectorization.TestForEachRem test1\n- * @run main compiler.vectorization.TestForEachRem test2\n- * @run main compiler.vectorization.TestForEachRem test3\n- * @run main compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test1\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test2\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test3\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test5\n@@ -68,0 +69,6 @@\n+    static void test5(int[] data) {\n+       IntStream.range(0, RANGE - 2).forEach(j -> {\n+           data[j + 2] = data[j];\n+       });\n+    }\n+\n@@ -81,1 +88,1 @@\n-            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4\");\n+            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4, test5\");\n@@ -129,0 +136,12 @@\n+\n+        if (args[0].equals(\"test5\")) {\n+            System.out.println(\" Run test5 ...\");\n+            test1(gold); \/\/ reset\n+            test5(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test5(data);\n+            }\n+            verify(\"test5\", data, gold);\n+            System.out.println(\" Finished test5.\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestForEachRem.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Test forced vectorization, and check IR for vector instructions\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx.*\" | vm.cpu.features ~= \".*sve.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestOptionVectorizeIR\n+ *\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestOptionVectorizeIR {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] gold1 = new int[RANGE];\n+    int[] gold2 = new int[RANGE];\n+    int[] gold3 = new int[RANGE];\n+    int[] gold4 = new int[RANGE];\n+    int[] gold5 = new int[RANGE];\n+    int[] gold6 = new int[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=option,compiler.vectorization.TestOptionVectorizeIR::test*,Vectorize\");\n+    }\n+\n+    TestOptionVectorizeIR() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test1\n+        test1(gold1);\n+        \/\/ test2\n+        test1(gold2);\n+        test2(gold2);\n+        \/\/ test3\n+        test1(gold3);\n+        test3(gold3, 2, 3);\n+        \/\/ test4\n+        test1(gold4);\n+        test4(gold4);\n+        \/\/ test5\n+        test1(gold5);\n+        test5(gold5);\n+        \/\/ test6\n+        test1(gold6);\n+        test6(gold6);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        verify(\"test1\", data, gold1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test2(data);\n+        verify(\"test2\", data, gold2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test3(data, 2, 3);\n+        verify(\"test3\", data, gold3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test4(data);\n+        verify(\"test4\", data, gold4);\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(100)\n+    public void runTest5() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test5(data);\n+        verify(\"test5\", data, gold5);\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(100)\n+    public void runTest6() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test6(data);\n+        verify(\"test6\", data, gold6);\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"}, counts = {IRNode.POPULATE_INDEX, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"}, counts = {IRNode.STORE_VECTOR, \"> 0\"})\n+    static void test1(int[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           \/\/ Vectorizes even if it is not forced\n+           data[j] = j;\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\"})\n+    static void test2(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = data[j] + data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\"})\n+    @IR(counts = {IRNode.REPLICATE_I, \"> 0\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"})\n+    @IR(counts = {IRNode.MUL_VI, \"> 0\"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\"})\n+    static void test3(int[] data, int A, int B) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = A * data[j] + B * data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"= 0\"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"})\n+    static void test4(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads should detect this\n+           data[j + 1] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"= 0\"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"})\n+    static void test5(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 2] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"= 0\"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"})\n+    static void test6(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 3] = data[j];\n+       }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestOptionVectorizeIR.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}