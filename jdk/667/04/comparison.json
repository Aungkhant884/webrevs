{"files":[{"patch":"@@ -648,2 +648,3 @@\n-  uint index = (speculation >> 32) & 0xFFFFFFFF;\n-  int length = (int) speculation;\n+  jlong index = speculation >> JVMCINMethodData::SPECULATION_LENGTH_BITS;\n+  guarantee(index >= 0 && index <= max_jint, \"Encoded JVMCI speculation index is not a positive Java int: \" INTPTR_FORMAT, index);\n+  int length = speculation & JVMCINMethodData::SPECULATION_LENGTH_MASK;\n@@ -651,1 +652,1 @@\n-    fatal(INTPTR_FORMAT \"[index: %d, length: %d] out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n+    fatal(INTPTR_FORMAT \"[index: \" JLONG_FORMAT \", length: %d out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class JVMCIVMStructs;\n@@ -54,0 +55,8 @@\n+  \/\/ A speculation id is a length (low 5 bits) and an index into\n+  \/\/ a jbyte array (i.e. 31 bits for a positive Java int).\n+  enum {\n+    \/\/ Keep in sync with HotSpotSpeculationEncoding.\n+    SPECULATION_LENGTH_BITS = 5,\n+    SPECULATION_LENGTH_MASK = (1 << SPECULATION_LENGTH_BITS) - 1\n+  };\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -394,0 +394,1 @@\n+  declare_constant(JVMCINMethodData::SPECULATION_LENGTH_BITS)             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1169,1 +1169,2 @@\n-  \/\/ uniquely identify the  speculative optimization guarded by the uncommon trap\n+  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n+  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-     * Checks if this field has the {@link Stable} annotation.\n+     * Checks if this field has the {@code Stable} annotation.\n@@ -172,1 +172,1 @@\n-     * @return true if field has {@link Stable} annotation, false otherwise\n+     * @return true if field has {@code Stable} annotation, false otherwise\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -39,2 +40,2 @@\n- * total length of data exceeds the length of a SHA-1 digest and a SHA-1 digest algorithm is\n- * available, then a SHA-1 digest of the data is produced instead.\n+ * total length of data exceeds {@value HotSpotSpeculationEncoding#MAX_LENGTH}, then a SHA-1 digest\n+ * of the data is produced instead.\n@@ -44,0 +45,14 @@\n+    \/**\n+     * Number of bits used for the length of an encoded speculation. The bit size of 5 is chosen to\n+     * accommodate specifying \/\/ the length of a SHA-1 digest (i.e., 20 bytes).\n+     *\/\n+    \/\/ Also defined in C++ JVMCINMethodData class - keep in sync.\n+    static final int LENGTH_BITS = 5;\n+\n+    \/**\n+     * The maximum length of an encoded speculation.\n+     *\/\n+    static final int MAX_LENGTH = (1 << LENGTH_BITS) - 1;\n+\n+    static final int LENGTH_MASK = MAX_LENGTH;\n+\n@@ -163,1 +178,1 @@\n-    private static final int SHA1_LENGTH;\n+    private static final int SHA1_LENGTH = 20;\n@@ -174,2 +189,2 @@\n-            \/\/ compliant Java platform implementation. However, be\n-            \/\/ conservative and fall back to not using a digest.\n+            \/\/ compliant Java platform implementation.\n+            throw new JVMCIError(e);\n@@ -180,1 +195,2 @@\n-        SHA1_LENGTH = SHA1 == null ? 20 : SHA1.getDigestLength();\n+        assert SHA1.getDigestLength() == SHA1_LENGTH;\n+        assert SHA1_LENGTH < MAX_LENGTH;\n@@ -189,1 +205,1 @@\n-            if (SHA1 != null && count > SHA1_LENGTH) {\n+            if (count > MAX_LENGTH) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationEncoding.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -122,3 +123,3 @@\n-         * A speculation id is a long encoding an offset (high 32 bits) and a length (low 32 bts).\n-         * Combined, the index and length denote where the {@linkplain #encoding encoded\n-         * speculation} is in a {@linkplain HotSpotSpeculationLog#getFlattenedSpeculations\n+         * A speculation id is a long encoding a length (low 5 bits) and an index into a\n+         * {@code byte[]}. Combined, the index and length denote where the {@linkplain #encoding\n+         * encoded speculation} is in a {@linkplain HotSpotSpeculationLog#getFlattenedSpeculations\n@@ -236,1 +237,7 @@\n-        return ((long) index) << 32 | length;\n+        if (length > HotSpotSpeculationEncoding.MAX_LENGTH || length < 0) {\n+            throw new InternalError(String.format(\"Invalid encoded speculation length: %d (0x%x)\", length, length));\n+        }\n+        if (index < 0) {\n+            throw new JVMCIError(\"Encoded speculation index is negative: %d (0x%x)\", index, index);\n+        }\n+        return (index << HotSpotSpeculationEncoding.LENGTH_BITS) | length;\n@@ -240,1 +247,1 @@\n-        return (int) (indexAndLength >>> 32);\n+        return (int) (indexAndLength >>> HotSpotSpeculationEncoding.LENGTH_BITS);\n@@ -244,1 +251,1 @@\n-        return (int) indexAndLength & 0xFFFFFFFF;\n+        return (int) (indexAndLength & HotSpotSpeculationEncoding.LENGTH_MASK);\n@@ -361,1 +368,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -49,0 +50,3 @@\n+\n+        int speculationLengthBits = getConstant(\"JVMCINMethodData::SPECULATION_LENGTH_BITS\", Integer.class);\n+        JVMCIError.guarantee(HotSpotSpeculationEncoding.LENGTH_BITS == speculationLengthBits, \"%d != %d\", HotSpotSpeculationEncoding.LENGTH_BITS, speculationLengthBits);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n@@ -44,0 +45,3 @@\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n@@ -46,0 +50,1 @@\n+import jdk.vm.ci.runtime.JVMCI;\n@@ -91,0 +96,1 @@\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n@@ -101,0 +107,5 @@\n+        JavaConstant encodedS1 = metaAccess.encodeSpeculation(s1);\n+        JavaConstant encodedS2 = metaAccess.encodeSpeculation(s2);\n+        Assert.assertEquals(JavaKind.Long, encodedS1.getJavaKind());\n+        Assert.assertEquals(JavaKind.Long, encodedS2.getJavaKind());\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotSpeculationLog.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}