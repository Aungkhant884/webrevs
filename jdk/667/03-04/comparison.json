{"files":[{"patch":"@@ -648,5 +648,2 @@\n-  \/\/ This field is written directly by JVMCI compiled code. However, it should\n-  \/\/ only ever write values originating from HotSpotSpeculation. Since the latter are\n-  \/\/ 31-bit in precision, ensure only the low 31 bits are set.\n-  guarantee((speculation & 0x7FFFFFFF) == speculation, \"Encoded JVMCI speculation is larger than 31 bits: \" INTPTR_FORMAT, speculation);\n-  uint index = (uint) speculation >> JVMCINMethodData::SPECULATION_LENGTH_BITS;\n+  jlong index = speculation >> JVMCINMethodData::SPECULATION_LENGTH_BITS;\n+  guarantee(index >= 0 && index <= max_jint, \"Encoded JVMCI speculation index is not a positive Java int: \" INTPTR_FORMAT, index);\n@@ -655,1 +652,1 @@\n-    fatal(INTPTR_FORMAT \"[index: %d, length: %d] out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n+    fatal(INTPTR_FORMAT \"[index: \" JLONG_FORMAT \", length: %d out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,10 +55,2 @@\n-  \/\/ A speculation id is an index (high 26 bits) and a length (low 5 bits).\n-  \/\/ Keep in sync with HotSpotSpeculationLog.HotSpotSpeculation.\n-  \/\/ Since the offset of Thread::_pending_failed_speculation is exposed via VMStructs\n-  \/\/ but its type is not, JVMCI Java code assumes that it's a long. So even\n-  \/\/ though it could be encoded in an int, doing this would be a breaking JVMCI\n-  \/\/ API change. It's sufficient to ensure that only 31-bit encoded values (i.e. signed\n-  \/\/ ints) are produced by JVMCI. This allows JVMCI compilers to emit an efficient\n-  \/\/ instruction sequence to store a value to Thread::_pending_failed_speculation\n-  \/\/ (e.g., on x86 a MOVESLQ can write a 32 bit value sign extended to a long\n-  \/\/ into a long memory location).\n+  \/\/ A speculation id is a length (low 5 bits) and an index into\n+  \/\/ a jbyte array (i.e. 31 bits for a positive Java int).\n@@ -66,0 +58,1 @@\n+    \/\/ Keep in sync with HotSpotSpeculationEncoding.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.vm.ci.common.JVMCIError;\n@@ -39,2 +40,2 @@\n- * total length of data exceeds the length of a SHA-1 digest and a SHA-1 digest algorithm is\n- * available, then a SHA-1 digest of the data is produced instead.\n+ * total length of data exceeds {@value HotSpotSpeculationEncoding#MAX_LENGTH}, then a SHA-1 digest\n+ * of the data is produced instead.\n@@ -44,0 +45,14 @@\n+    \/**\n+     * Number of bits used for the length of an encoded speculation. The bit size of 5 is chosen to\n+     * accommodate specifying \/\/ the length of a SHA-1 digest (i.e., 20 bytes).\n+     *\/\n+    \/\/ Also defined in C++ JVMCINMethodData class - keep in sync.\n+    static final int LENGTH_BITS = 5;\n+\n+    \/**\n+     * The maximum length of an encoded speculation.\n+     *\/\n+    static final int MAX_LENGTH = (1 << LENGTH_BITS) - 1;\n+\n+    static final int LENGTH_MASK = MAX_LENGTH;\n+\n@@ -163,1 +178,1 @@\n-    private static final int SHA1_LENGTH;\n+    private static final int SHA1_LENGTH = 20;\n@@ -174,2 +189,2 @@\n-            \/\/ compliant Java platform implementation. However, be\n-            \/\/ conservative and fall back to not using a digest.\n+            \/\/ compliant Java platform implementation.\n+            throw new JVMCIError(e);\n@@ -180,1 +195,2 @@\n-        SHA1_LENGTH = SHA1 == null ? 20 : SHA1.getDigestLength();\n+        assert SHA1.getDigestLength() == SHA1_LENGTH;\n+        assert SHA1_LENGTH < MAX_LENGTH;\n@@ -189,1 +205,1 @@\n-            if (SHA1 != null && count > SHA1_LENGTH) {\n+            if (count > MAX_LENGTH) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationEncoding.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -122,9 +122,0 @@\n-        \/\/ Also defined in JVMCINMethodData C++ class - keep in sync\n-        static final int LENGTH_BITS = 5;\n-        static final int INDEX_BITS = 31 - LENGTH_BITS;\n-\n-        static final int MAX_LENGTH = (1 << LENGTH_BITS) - 1;\n-        static final int MAX_INDEX = (1 << INDEX_BITS) - 1;\n-\n-        static final int LENGTH_MASK = MAX_LENGTH;\n-\n@@ -132,3 +123,3 @@\n-         * A speculation id is a long encoding a length (low 5 bits) and an index (next 26 bits).\n-         * Combined, the index and length denote where the {@linkplain #encoding encoded\n-         * speculation} is in a {@linkplain HotSpotSpeculationLog#getFlattenedSpeculations\n+         * A speculation id is a long encoding a length (low 5 bits) and an index into a\n+         * {@code byte[]}. Combined, the index and length denote where the {@linkplain #encoding\n+         * encoded speculation} is in a {@linkplain HotSpotSpeculationLog#getFlattenedSpeculations\n@@ -246,1 +237,1 @@\n-        if (length > HotSpotSpeculation.MAX_LENGTH || length < 0) {\n+        if (length > HotSpotSpeculationEncoding.MAX_LENGTH || length < 0) {\n@@ -249,2 +240,2 @@\n-        if (index > HotSpotSpeculation.MAX_INDEX || index < 0) {\n-            throw new JVMCIError(\"Encoded speculation index is negative or too big: %d (0x%x)\", index, index);\n+        if (index < 0) {\n+            throw new JVMCIError(\"Encoded speculation index is negative: %d (0x%x)\", index, index);\n@@ -252,1 +243,1 @@\n-        return (index << HotSpotSpeculation.LENGTH_BITS) | length;\n+        return (index << HotSpotSpeculationEncoding.LENGTH_BITS) | length;\n@@ -256,1 +247,1 @@\n-        return (int) (indexAndLength >>> HotSpotSpeculation.LENGTH_BITS);\n+        return (int) (indexAndLength >>> HotSpotSpeculationEncoding.LENGTH_BITS);\n@@ -260,1 +251,1 @@\n-        return (int) (indexAndLength & HotSpotSpeculation.LENGTH_MASK);\n+        return (int) (indexAndLength & HotSpotSpeculationEncoding.LENGTH_MASK);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculation;\n@@ -53,1 +52,1 @@\n-        JVMCIError.guarantee(HotSpotSpeculation.LENGTH_BITS == speculationLengthBits, \"%d != %d\", HotSpotSpeculation.LENGTH_BITS, speculationLengthBits);\n+        JVMCIError.guarantee(HotSpotSpeculationEncoding.LENGTH_BITS == speculationLengthBits, \"%d != %d\", HotSpotSpeculationEncoding.LENGTH_BITS, speculationLengthBits);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}