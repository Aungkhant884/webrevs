{"files":[{"patch":"@@ -3501,1 +3501,1 @@\n-  uint speculation = thread->pending_failed_speculation();\n+  jlong speculation = thread->pending_failed_speculation();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -647,2 +647,6 @@\n-void JVMCINMethodData::add_failed_speculation(nmethod* nm, uint speculation) {\n-  uint index = speculation >> JVMCINMethodData::SPECULATION_LENGTH_BITS;\n+void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {\n+  \/\/ This field is written directly by JVMCI compiled code. However, it should\n+  \/\/ only ever write values originating from HotSpotSpeculation. Since the latter are\n+  \/\/ 31-bit in precision, ensure only the low 31 bits are set.\n+  guarantee((speculation & 0x7FFFFFFF) == speculation, \"Encoded JVMCI speculation is larger than 31 bits: \" INTPTR_FORMAT, speculation);\n+  uint index = (uint) speculation >> JVMCINMethodData::SPECULATION_LENGTH_BITS;\n@@ -651,1 +655,1 @@\n-    fatal(\"0x%x[index: %d, length: %d] out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n+    fatal(INTPTR_FORMAT \"[index: %d, length: %d] out of bounds wrt encoded speculations of length %u\", speculation, index, length, nm->speculations_size());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  \/\/ A speculation id is an index (high 27 bits) and a length (low 5 bits) encoded in an int.\n+  \/\/ A speculation id is an index (high 26 bits) and a length (low 5 bits).\n@@ -57,0 +57,8 @@\n+  \/\/ Since the offset of Thread::_pending_failed_speculation is exposed via VMStructs\n+  \/\/ but its type is not, JVMCI Java code assumes that it's a long. So even\n+  \/\/ though it could be encoded in an int, doing this would be a breaking JVMCI\n+  \/\/ API change. It's sufficient to ensure that only 31-bit encoded values (i.e. signed\n+  \/\/ ints) are produced by JVMCI. This allows JVMCI compilers to emit an efficient\n+  \/\/ instruction sequence to store a value to Thread::_pending_failed_speculation\n+  \/\/ (e.g., on x86 a MOVESLQ can write a 32 bit value sign extended to a long\n+  \/\/ into a long memory location).\n@@ -77,1 +85,1 @@\n-  void add_failed_speculation(nmethod* nm, uint speculation);\n+  void add_failed_speculation(nmethod* nm, jlong speculation);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1847,1 +1847,1 @@\n-    uint            speculation = thread->pending_failed_speculation();\n+    jlong           speculation = thread->pending_failed_speculation();\n@@ -1904,1 +1904,1 @@\n-          xtty->print(\" speculation='0x%x'\", speculation);\n+          xtty->print(\" speculation='\" JLONG_FORMAT \"'\", speculation);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1620,10 +1620,0 @@\n-uint JavaThread::pending_failed_speculation() const {\n-  if ((_pending_failed_speculation & 0xFFFFFFFF) != _pending_failed_speculation) {\n-    \/\/ This field is written directly by Graal compiled code. However, it should\n-    \/\/ only ever write values originating from JVMCI. Since the latter are\n-    \/\/ 32-bit in precision, ensure the high 32-bits are 0.\n-    fatal(\"Pending failed speculation is larger than an int: \" INTPTR_FORMAT, _pending_failed_speculation);\n-  }\n-  return (uint) _pending_failed_speculation;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1169,4 +1169,2 @@\n-  \/\/ uniquely identify the  speculative optimization guarded by the uncommon trap.\n-  \/\/ The id value is only 32-bits but since this field is exposed via VMStructs to\n-  \/\/ JVMCI as a jlong, it needs to be kept as a long to maintain backwards compatibility\n-  \/\/ with JVMCI based compilers that emit code to update the field directly.\n+  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n+  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n@@ -1547,1 +1545,1 @@\n-  uint pending_failed_speculation() const;\n+  jlong pending_failed_speculation() const        { return _pending_failed_speculation; }\n@@ -1551,1 +1549,1 @@\n-  void set_pending_failed_speculation(uint failed_speculation) { _pending_failed_speculation = failed_speculation; }\n+  void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }\n@@ -1612,0 +1610,1 @@\n+  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-            return JavaConstant.INT_0;\n+            return JavaConstant.LONG_0;\n@@ -156,1 +156,1 @@\n-        if (constant.equals(JavaConstant.INT_0)) {\n+        if (constant.equals(JavaConstant.LONG_0)) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMetaAccessProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-     * Checks if this field has the {@link Stable} annotation.\n+     * Checks if this field has the {@code Stable} annotation.\n@@ -172,1 +172,1 @@\n-     * @return true if field has {@link Stable} annotation, false otherwise\n+     * @return true if field has {@code Stable} annotation, false otherwise\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        static final int INDEX_BITS = 32 - LENGTH_BITS;\n+        static final int INDEX_BITS = 31 - LENGTH_BITS;\n@@ -132,1 +132,1 @@\n-         * A speculation id is an int encoding an index (high 27 bits) and a length (low 5 bits).\n+         * A speculation id is a long encoding a length (low 5 bits) and an index (next 26 bits).\n@@ -153,1 +153,1 @@\n-            int indexAndLength = id.asInt();\n+            long indexAndLength = id.asLong();\n@@ -245,1 +245,1 @@\n-    private static int encodeIndexAndLength(int index, int length) {\n+    private static long encodeIndexAndLength(int index, int length) {\n@@ -247,1 +247,1 @@\n-            throw new InternalError(String.format(\"Invalid encoded speculation length: %d\", length));\n+            throw new InternalError(String.format(\"Invalid encoded speculation length: %d (0x%x)\", length, length));\n@@ -250,1 +250,1 @@\n-            throw new JVMCIError(\"Encoded speculation index is negative or too big: %d\", index);\n+            throw new JVMCIError(\"Encoded speculation index is negative or too big: %d (0x%x)\", index, index);\n@@ -255,2 +255,2 @@\n-    private static int decodeIndex(int indexAndLength) {\n-        return (indexAndLength >>> HotSpotSpeculation.LENGTH_BITS);\n+    private static int decodeIndex(long indexAndLength) {\n+        return (int) (indexAndLength >>> HotSpotSpeculation.LENGTH_BITS);\n@@ -259,2 +259,2 @@\n-    private static int decodeLength(int indexAndLength) {\n-        return indexAndLength & HotSpotSpeculation.LENGTH_MASK;\n+    private static int decodeLength(long indexAndLength) {\n+        return (int) (indexAndLength & HotSpotSpeculation.LENGTH_MASK);\n@@ -270,1 +270,1 @@\n-            id = JavaConstant.forInt(encodeIndexAndLength(0, encoding.length));\n+            id = JavaConstant.forLong(encodeIndexAndLength(0, encoding.length));\n@@ -278,1 +278,1 @@\n-                    id = JavaConstant.forInt(encodeIndexAndLength(flattenedIndex, fs.length));\n+                    id = JavaConstant.forLong(encodeIndexAndLength(flattenedIndex, fs.length));\n@@ -284,1 +284,1 @@\n-                id = JavaConstant.forInt(encodeIndexAndLength(flattenedIndex, encoding.length));\n+                id = JavaConstant.forLong(encodeIndexAndLength(flattenedIndex, encoding.length));\n@@ -312,1 +312,1 @@\n-        int flattenedIndex = decodeIndex(constant.asInt());\n+        int flattenedIndex = decodeIndex(constant.asLong());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+\n+        int speculationLengthBits = getConstant(\"JVMCINMethodData::SPECULATION_LENGTH_BITS\", Integer.class);\n@@ -353,2 +355,0 @@\n-    final int speculationLengthBits = getConstant(\"JVMCINMethodData::SPECULATION_LENGTH_BITS\", Integer.class);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,3 +108,3 @@\n-        JavaConstant encodedS2 = metaAccess.encodeSpeculation(s1);\n-        Assert.assertEquals(JavaKind.Int, encodedS1.getJavaKind());\n-        Assert.assertEquals(JavaKind.Int, encodedS2.getJavaKind());\n+        JavaConstant encodedS2 = metaAccess.encodeSpeculation(s2);\n+        Assert.assertEquals(JavaKind.Long, encodedS1.getJavaKind());\n+        Assert.assertEquals(JavaKind.Long, encodedS2.getJavaKind());\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotSpeculationLog.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}