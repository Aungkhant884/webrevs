{"files":[{"patch":"@@ -136,0 +136,14 @@\n+class ProcessReentranceGuard {\n+  JavaThread* const _jt;\n+ public:\n+  ProcessReentranceGuard(JavaThread* jt) :\n+    _jt(jt) {\n+    assert(_jt->poll_data()->is_processing() == false, \"Must be\");\n+    _jt->poll_data()->set_is_processing(true);\n+  }\n+  ~ProcessReentranceGuard() {\n+    assert(_jt->poll_data()->is_processing() == true, \"Must be\");\n+    _jt->poll_data()->set_is_processing(false);\n+  }\n+};\n+\n@@ -137,0 +151,10 @@\n+  \/\/ Thread-local test if we are in the middle of processing a safepoint.\n+  if (thread->poll_data()->is_processing()) {\n+    \/\/ This is caused by a handshake operation reentering safepoint. We\n+    \/\/ should just return because otherwise the thread will probably block on the\n+    \/\/ reentrance of the handshake mutex. We also don't need to do anything\n+    \/\/ because the process() routine will be retried after the handshake returns.\n+    return;\n+  }\n+  ProcessReentranceGuard prg(thread);\n+\n@@ -147,0 +171,1 @@\n+  thread->poll_data()->set_is_processing(false);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+    bool _is_processing;\n@@ -74,0 +75,3 @@\n+    inline void set_is_processing(bool is_processing) { _is_processing = is_processing; }\n+    inline bool is_processing() const { return _is_processing; }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}