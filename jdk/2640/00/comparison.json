{"files":[{"patch":"@@ -219,1 +219,3 @@\n-    events->logv(thread, format, ap);\n+    if (thread != NULL) {\n+      events->logv(thread, format, ap);\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1578,77 +1578,7 @@\n-\/\/ Creates a scope where the current thread is attached and detached\n-\/\/ from HotSpot if it wasn't already attached when entering the scope.\n-extern \"C\" int jio_printf(const char *fmt, ...);\n-class AttachDetach : public StackObj {\n- public:\n-  bool _attached;\n-  AttachDetach(JNIEnv* env, JavaThread* current_thread) {\n-    if (current_thread == NULL) {\n-      extern struct JavaVM_ main_vm;\n-      JNIEnv* hotspotEnv;\n-      jint res = main_vm.AttachCurrentThread((void**)&hotspotEnv, NULL);\n-      _attached = res == JNI_OK;\n-      static volatile int report_attach_error = 0;\n-      if (res != JNI_OK && report_attach_error == 0 && Atomic::cmpxchg(&report_attach_error, 0, 1) == 0) {\n-        \/\/ Only report an attach error once\n-        jio_printf(\"Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\\n\", res);\n-      }\n-    } else {\n-      _attached = false;\n-    }\n-  }\n-  ~AttachDetach() {\n-    if (_attached && get_current_thread() != NULL) {\n-      extern struct JavaVM_ main_vm;\n-      jint res = main_vm.DetachCurrentThread();\n-      static volatile int report_detach_error = 0;\n-      if (res != JNI_OK && report_detach_error == 0 && Atomic::cmpxchg(&report_detach_error, 0, 1) == 0) {\n-        \/\/ Only report an attach error once\n-        jio_printf(\"Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\\n\", res);\n-      }\n-    }\n-  }\n-};\n-\n-C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))\n-  AttachDetach ad(env, thread);\n-  bool use_tty = true;\n-  if (thread == NULL) {\n-    if (!ad._attached) {\n-      \/\/ Can only use tty if the current thread is attached\n-      JVMCI_event_1(\"Cannot write to tty on unattached thread\");\n-      return 0;\n-    }\n-    thread = get_current_thread();\n-  }\n-  JVMCITraceMark jtm(\"writeDebugOutput\");\n-  C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))\n-  if (bytes == NULL) {\n-    if (can_throw) {\n-      JVMCI_THROW_0(NullPointerException);\n-    }\n-    return -1;\n-  }\n-  JVMCIPrimitiveArray array = JVMCIENV->wrap(bytes);\n-\n-  \/\/ Check if offset and length are non negative.\n-  if (offset < 0 || length < 0) {\n-    if (can_throw) {\n-      JVMCI_THROW_0(ArrayIndexOutOfBoundsException);\n-    }\n-    return -2;\n-  }\n-  \/\/ Check if the range is valid.\n-  int array_length = JVMCIENV->get_length(array);\n-  if ((((unsigned int) length + (unsigned int) offset) > (unsigned int) array_length)) {\n-    if (can_throw) {\n-      JVMCI_THROW_0(ArrayIndexOutOfBoundsException);\n-    }\n-    return -2;\n-  }\n-  jbyte buffer[O_BUFLEN];\n-  while (length > 0) {\n-    int copy_len = MIN2(length, (jint)O_BUFLEN);\n-    JVMCIENV->copy_bytes_to(array, buffer, offset, copy_len);\n-    tty->write((char*) buffer, copy_len);\n-    length -= O_BUFLEN;\n-    offset += O_BUFLEN;\n+\/\/ Use of tty does not require the current thread to be attached to the VM\n+\/\/ so no need for a full C2V_VMENTRY transition.\n+C2V_VMENTRY_PREFIX(void, writeDebugOutput, (JNIEnv* env, jobject, jlong buffer, jint length, bool flush))\n+  if (length <= 8) {\n+    tty->write((char*) &buffer, length);\n+  } else {\n+    tty->write((char*) buffer, length);\n@@ -1659,1 +1589,0 @@\n-  return 0;\n@@ -1662,1 +1591,3 @@\n-C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))\n+\/\/ Use of tty does not require the current thread to be attached to the VM\n+\/\/ so no need for a full C2V_VMENTRY transition.\n+C2V_VMENTRY_PREFIX(void, flushDebugOutput, (JNIEnv* env, jobject))\n@@ -2796,1 +2727,1 @@\n-  {CC \"writeDebugOutput\",                             CC \"([BIIZZ)I\",                                                                       FN_PTR(writeDebugOutput)},\n+  {CC \"writeDebugOutput\",                             CC \"(JIZ)V\",                                                                          FN_PTR(writeDebugOutput)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":80,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -615,2 +615,1 @@\n-     * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot's\n-     * log stream.\n+     * Writes {@code length} bytes from {@code buffer} to HotSpot's log stream.\n@@ -618,0 +617,3 @@\n+     * @param buffer if {@code length <= 8}, then the bytes are encoded in this value in native\n+     *            endianness order otherwise this is the address of a native memory buffer holding\n+     *            the bytes\n@@ -619,8 +621,2 @@\n-     * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}\n-     *            arguments should result in an exception or a negative return value\n-     * @return 0 on success, -1 if {@code bytes == null && !canThrow}, -2 if {@code !canThrow} and\n-     *         copying would cause access of data outside array bounds\n-     * @throws NullPointerException if {@code bytes == null}\n-     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds\n-     *\/\n-    native int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow);\n+     *\/\n+    native void writeDebugOutput(long buffer, int length, boolean flush);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -48,0 +50,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -572,1 +575,1 @@\n-            configStore.printConfig();\n+            configStore.printConfig(this);\n@@ -887,1 +890,40 @@\n-        return compilerToVm.writeDebugOutput(bytes, offset, length, flush, canThrow);\n+        return writeDebugOutput0(compilerToVm, bytes, offset, length, flush, canThrow);\n+    }\n+\n+    \/**\n+     * @see #writeDebugOutput\n+     *\/\n+    static int writeDebugOutput0(CompilerToVM vm, byte[] bytes, int offset, int length, boolean flush, boolean canThrow) {\n+        if (bytes == null) {\n+            if (!canThrow) {\n+                return -1;\n+            }\n+            throw new NullPointerException();\n+        }\n+        if (offset < 0 || length < 0 || offset + length > bytes.length) {\n+            if (!canThrow) {\n+                return -2;\n+            }\n+            throw new ArrayIndexOutOfBoundsException();\n+        }\n+        if (length <= 8) {\n+            ByteBuffer buffer = ByteBuffer.wrap(bytes, offset, length);\n+            if (length != 8) {\n+                ByteBuffer buffer8 = ByteBuffer.allocate(8);\n+                buffer8.put(buffer);\n+                buffer8.position(8);\n+                buffer = buffer8;\n+            }\n+            buffer.order(ByteOrder.nativeOrder());\n+            vm.writeDebugOutput(buffer.getLong(0), length, flush);\n+        } else {\n+            Unsafe unsafe = UnsafeAccess.UNSAFE;\n+            long buffer = unsafe.allocateMemory(length);\n+            try {\n+                unsafe.copyMemory(bytes, vm.ARRAY_BYTE_BASE_OFFSET, null, buffer, length);\n+                vm.writeDebugOutput(buffer, length, flush);\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+        }\n+        return 0;\n@@ -905,1 +947,1 @@\n-                compilerToVm.writeDebugOutput(b, off, len, false, true);\n+                writeDebugOutput(b, off, len, false, true);\n@@ -1197,1 +1239,1 @@\n-        compilerToVm.writeDebugOutput(messageBytes, 0, messageBytes.length, true, true);\n+        writeDebugOutput(messageBytes, 0, messageBytes.length, true, true);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-                    CompilerToVM.compilerToVM().writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);\n+                    HotSpotJVMCIRuntime.runtime().writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,2 +164,1 @@\n-    void printConfig() {\n-        CompilerToVM vm = compilerToVm;\n+    void printConfig(HotSpotJVMCIRuntime runtime) {\n@@ -169,1 +168,1 @@\n-                printConfigLine(vm, \"[vmconfig:instance field] %s %s {offset=%d[0x%x]}%n\", field.type, field.name, field.offset, field.offset);\n+                printConfigLine(runtime, \"[vmconfig:instance field] %s %s {offset=%d[0x%x]}%n\", field.type, field.name, field.offset, field.offset);\n@@ -172,1 +171,1 @@\n-                printConfigLine(vm, \"[vmconfig:static field] %s %s = %s {address=0x%x}%n\", field.type, field.name, value, field.address);\n+                printConfigLine(runtime, \"[vmconfig:static field] %s %s = %s {address=0x%x}%n\", field.type, field.name, value, field.address);\n@@ -177,1 +176,1 @@\n-            printConfigLine(vm, \"[vmconfig:flag] %s %s = %s%n\", flag.type, flag.name, flag.value);\n+            printConfigLine(runtime, \"[vmconfig:flag] %s %s = %s%n\", flag.type, flag.name, flag.value);\n@@ -181,1 +180,1 @@\n-            printConfigLine(vm, \"[vmconfig:address] %s = %d[0x%x]%n\", e.getKey(), e.getValue(), e.getValue());\n+            printConfigLine(runtime, \"[vmconfig:address] %s = %d[0x%x]%n\", e.getKey(), e.getValue(), e.getValue());\n@@ -185,1 +184,1 @@\n-            printConfigLine(vm, \"[vmconfig:constant] %s = %d[0x%x]%n\", e.getKey(), e.getValue(), e.getValue());\n+            printConfigLine(runtime, \"[vmconfig:constant] %s = %d[0x%x]%n\", e.getKey(), e.getValue(), e.getValue());\n@@ -188,1 +187,1 @@\n-            printConfigLine(vm, \"[vmconfig:intrinsic] %d = %s.%s %s%n\", e.id, e.declaringClass, e.name, e.descriptor);\n+            printConfigLine(runtime, \"[vmconfig:intrinsic] %d = %s.%s %s%n\", e.id, e.declaringClass, e.name, e.descriptor);\n@@ -193,1 +192,1 @@\n-    private static void printConfigLine(CompilerToVM vm, String format, Object... args) {\n+    private static void printConfigLine(HotSpotJVMCIRuntime runtime, String format, Object... args) {\n@@ -196,1 +195,1 @@\n-        vm.writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);\n+        runtime.writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigStore.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -298,4 +298,0 @@\n-    public static void writeDebugOutput(byte[] bytes, int offset, int length) {\n-        CTVM.writeDebugOutput(bytes, offset, length, true, true);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8136421\n- * @requires vm.jvmci\n- * @library \/ \/test\/lib\n- * @library ..\/common\/patches\n- * @modules java.base\/jdk.internal.misc\n- * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n- * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper\n- * @run driver compiler.jvmci.compilerToVM.DebugOutputTest\n- *\/\n-\n-package compiler.jvmci.compilerToVM;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.vm.ci.hotspot.CompilerToVMHelper;\n-\n-import java.util.Arrays;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public class DebugOutputTest {\n-    private static final String VM_CI_MODULE = \"jdk.internal.vm.ci\";\n-    public static void main(String[] args) {\n-        new DebugOutputTest().test();\n-    }\n-\n-    private void test() {\n-        for (TestCaseData testCase : TestCaseData.values()) {\n-            System.out.println(testCase);\n-            OutputAnalyzer oa;\n-            try {\n-                Path patch = Paths.get(System.getProperty(\"test.patch.path\"));\n-                Path jvmciPath = patch.resolve(VM_CI_MODULE).toAbsolutePath();\n-                if (!jvmciPath.toFile().exists()) {\n-                    throw new Error(\"TESTBUG: patch for \" + VM_CI_MODULE + \" : \"\n-                            + jvmciPath.toString() + \" does not exist\");\n-                }\n-                oa = ProcessTools.executeTestJvm(\n-                        \"-XX:+UnlockExperimentalVMOptions\",\n-                        \"-XX:+EnableJVMCI\",\n-                        \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                        \"--add-exports\", \"jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED\",\n-                        \"--patch-module\", VM_CI_MODULE + \"=\" + jvmciPath.toString(),\n-                        DebugOutputTest.Worker.class.getName(),\n-                        testCase.name());\n-               } catch (Throwable e) {\n-                e.printStackTrace();\n-                throw new Error(\"Problems running child process\", e);\n-            }\n-            if (testCase.expectedException != null) {\n-                oa.shouldHaveExitValue(1);\n-                oa.shouldContain(testCase.expectedException.getName());\n-            } else {\n-                oa.shouldHaveExitValue(0);\n-                oa.shouldContain(new String(testCase.getExpected()));\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A list of test cases that are executed in forked VM\n-     *\/\n-    private enum TestCaseData {\n-        PART_ARRAY(100, 50),\n-        FULL_ARRAY(0, 255),\n-        EMPTY(0, 0),\n-        NEGATIVE_LENGTH(0, Integer.MIN_VALUE,\n-                ArrayIndexOutOfBoundsException.class),\n-        NEGATIVE_OFFSET(-1, 255,\n-                ArrayIndexOutOfBoundsException.class),\n-        LEFT_BOUND(Integer.MIN_VALUE, 100,\n-                ArrayIndexOutOfBoundsException.class),\n-        RIGHT_BOUND(Integer.MAX_VALUE, 100,\n-                ArrayIndexOutOfBoundsException.class),\n-        BIG_LENGTH(0, Integer.MAX_VALUE,\n-                ArrayIndexOutOfBoundsException.class),\n-        NULL_POINTER(0, 0,\n-                NullPointerException.class),\n-        ;\n-\n-        private static final int SIZE = 255;\n-        private static final byte[] DATA = generate();\n-        public final int offset;\n-        public final int length;\n-        public final Class<? extends Throwable> expectedException;\n-\n-        private TestCaseData(int offset, int length,\n-                Class<? extends Throwable> expectedException) {\n-            this.offset = offset;\n-            this.length = length;\n-            this.expectedException = expectedException;\n-        }\n-\n-        private TestCaseData(int offset, int length) {\n-            this(offset, length, null);\n-        }\n-\n-        private static byte[] generate() {\n-            byte[] byteArray = new byte[SIZE];\n-            for (int i = 0; i < SIZE; i++) {\n-                byteArray[i] = (byte) (i + 1);\n-            }\n-            return byteArray;\n-        }\n-\n-        public byte[] getExpected() {\n-            if (expectedException != null) {\n-                return new byte[0];\n-            }\n-            return Arrays.copyOfRange(TestCaseData.DATA, offset,\n-                    offset + length);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CASE: \" + this.name();\n-        }\n-\n-        public byte[] getData() {\n-            if (equals(NULL_POINTER)) {\n-                return null;\n-            } else {\n-                return DATA;\n-            }\n-        }\n-    }\n-\n-    public static class Worker {\n-        public static void main(String[] args) {\n-            for (String arg : args) {\n-                TestCaseData tcase = TestCaseData.valueOf(arg);\n-                CompilerToVMHelper.writeDebugOutput(tcase.getData(),\n-                        tcase.offset, tcase.length);\n-                CompilerToVMHelper.flushDebugOutput();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/DebugOutputTest.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"}]}