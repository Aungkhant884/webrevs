{"files":[{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8285452\n+ * @summary Unit Test for a common Test API in jdk.test.lib.util.FileUtils\n+ * @library .. \/test\/lib\n+ * @run main FileUtilsTest\n+ *\/\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import jdk.test.lib.util.FileUtils;\n+\n+public class FileUtilsTest {\n+\n+    private static volatile int counter = 1;\n+\n+    public static void main(String[] args) throws Exception {\n+        String a = \"a\";\n+        String z = \"z\";\n+        String abc = \"\"\"\n+a\n+b\n+c\"\"\";\n+        \/\/ 1st line has a space character\n+        String sabc = \" \" + System.lineSeparator() + abc;\n+        String xyz = \"\"\"\n+x\n+y\n+z\"\"\";\n+        var sList = Arrays.asList(\" \");\n+        var aList = Arrays.asList(a);\n+        var abcList = abc.lines().toList();\n+        var sabcList = sabc.lines().toList();\n+        \/\/ Replace with same line\n+        test(aList, 1, 1, null, a, a);\n+        \/\/ Replace with different line\n+        test(aList, 1, 1, null, z, z);\n+        \/\/ Replace with same line based on line match\n+        test(aList, 1, 1, a, a, a);\n+        \/\/ Replace with different line based on line match\n+        test(aList, 1, 1, a, z, z);\n+        \/\/ Replace single line with multiple lines\n+        test(aList, 1, 1, null, xyz, \"xyz\");\n+        \/\/ Replace single line with multiple lines based on lines match\n+        test(aList, 1, 1, a, xyz, \"xyz\");\n+        \/\/ Replace all lines\n+        test(abcList, 1, 3, null, xyz, \"xyz\");\n+        \/\/ Replace all lines based on lines match\n+        test(abcList, 1, 3, abc, xyz, \"xyz\");\n+        \/\/ Replace all lines with single line based on lines match\n+        test(abcList, 1, 3, abc, z, z);\n+        \/\/ Replace single line\n+        test(abcList, 1, 1, null, z, \"zbc\");\n+        \/\/ Replace single line based on line match\n+        test(abcList, 1, 1, a, z, \"zbc\");\n+        \/\/ Replace multiple lines\n+        test(abcList, 1, 2, null, z, \"zc\");\n+        \/\/ Replace multiple lines based on line match\n+        test(abcList, 1, 2, \"ab\", z, \"zc\");\n+        \/\/ Replace multiple lines based on line match\n+        test(abcList, 1, 2, \"ab\", xyz, \"xyzc\");\n+\n+        \/\/ Test with space characters\n+        \/\/ Replace with same space line\n+        test(sList, 1, 1, null, \" \", \" \");\n+        \/\/ Replace with same line based on line match\n+        test(sList, 1, 1, \" \", a, a);\n+        \/\/ Replace with same space line\n+        test(sabcList, 1, 1, null, a, \"aabc\");\n+        \/\/ Replace space line with different line based on line match\n+        test(sabcList, 1, 1, \" \", a, \"aabc\");\n+        \/\/ Replace range of lines with space to different lines based on line match\n+        test(sabcList, 1, 2, \" a\", xyz, \"xyzbc\");\n+\n+        \/\/ Mismatched range with \"replace\" lines Tests\n+        \/\/ Replace all lines with mismatched line\n+        test(aList, 1, 1, z, z, z);\n+        \/\/ Replace all lines with mismatched lines\n+        test(abcList, 1, 3, xyz, xyz, \"xyz\");\n+        \/\/ Replace single line with mismatched line\n+        test(abcList, 1, 1, z, z, \"zbc\");\n+        \/\/ Replace a range of lines with mismatched lines\n+        test(abcList, 1, 3, \"ab\", xyz, \"xyz\");\n+    }\n+\n+    private static List<String> toList(String str) {\n+        return str.chars().mapToObj(c -> String.valueOf((char) c)).collect(Collectors.toList());\n+    }\n+\n+    private static void test(List<String> content, int from, int to, String replace,\n+            String replaceTo, String expected) throws IOException {\n+        Path path = Files.write(Paths.get(\"Test-\" + counter++), content);\n+        try {\n+            FileUtils.patch(path, from, to, replace, replaceTo);\n+        } catch (IOException e) {\n+            if (e.getMessage().equals(\"Removed not the same\")) {\n+                System.out.printf(\"Expected failure: Lines %s-%s, don't match with lines to replace '%s'%n\",\n+                        from, to, replace);\n+                return;\n+            }\n+            throw e;\n+        }\n+        var lines = Files.readAllLines(path);\n+        System.out.printf(\"Content:%s, Resulted Lines: %s, Expected: %s%n\", content, lines, toList(expected));\n+        if (!lines.equals(toList(expected))) {\n+            throw new IOException(\"Unmatched result\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/FileUtilsTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-\n+import java.util.stream.Collectors;\n@@ -380,0 +380,29 @@\n+    \/**\n+     * Patches a part of a file.\n+     * @param path of file\n+     * @param fromLine the first line to patch. This is the number you see in an editor, 1-based, inclusive.\n+     * @param toLine the last line to patch. This is the number you see in an editor, inclusive.\n+     * @param from the lines to remove, used to ensure the correct lines are removed. Ignored if null.\n+     * @param to the newly added line, can be multiple lines or empty. Cannot be null.\n+     * @throws IOException\n+     *\/\n+    public static void patch(Path path, int fromLine, int toLine, String from, String to) throws IOException {\n+        var lines = Files.readAllLines(path);\n+        if (from != null) {\n+            var removed = \"\";\n+            for (int i = fromLine; i <= toLine; i++) {\n+                removed += lines.remove(fromLine - 1).trim();\n+            }\n+            var froms = from.lines()\n+                    .map(String::trim)\n+                    .collect(Collectors.joining());\n+            if (!removed.equals(froms)) {\n+                throw new IOException(\"Removed not the same\");\n+            }\n+        } else {\n+            lines.subList(fromLine - 1, toLine).clear();\n+        }\n+        lines.addAll(fromLine - 1, to.lines().toList());\n+        Files.write(path, lines);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"}]}