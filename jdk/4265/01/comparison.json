{"files":[{"patch":"@@ -2050,0 +2050,10 @@\n+\n+    \/\/ Populate the open archive regions' G1BlockOffsetTableParts. That ensures\n+    \/\/ fast G1BlockOffsetTablePart::block_start operations for any given address\n+    \/\/ within the open archive regions when trying to find start of an object\n+    \/\/ (e.g. during card table scanning).\n+    \/\/\n+    \/\/ This is only needed for open archive regions, but not the closed archive\n+    \/\/ regions, because objects in closed archive regions are 'immutable'.\n+    G1CollectedHeap::heap()->populate_archive_regions_bot_part(open_archive_heap_ranges,\n+                                                               num_open_archive_heap_ranges);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,0 +85,13 @@\n+void G1BlockOffsetTablePart::update() {\n+  HeapWord* next_addr = _hr->bottom();\n+  HeapWord* const limit = _hr->top();\n+\n+  HeapWord* prev_addr;\n+  while (next_addr < limit) {\n+    prev_addr = next_addr;\n+    next_addr  = prev_addr + block_size(prev_addr);\n+    alloc_block(prev_addr, next_addr);\n+  }\n+  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -188,0 +188,2 @@\n+  void update();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -715,0 +715,21 @@\n+void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion* ranges, size_t count) {\n+  assert(!is_init_completed(), \"Expect to be called at JVM init time\");\n+  assert(ranges != NULL, \"MemRegion array NULL\");\n+  assert(count != 0, \"No MemRegions provided\");\n+\n+  HeapWord* st = ranges[0].start();\n+  HeapWord* last = ranges[count-1].last();\n+  HeapRegion* hr_st = _hrm.addr_to_region(st);\n+  HeapRegion* hr_last = _hrm.addr_to_region(last);\n+\n+  HeapRegion* hr_curr = hr_st;\n+  while (hr_curr != NULL) {\n+    hr_curr->update_bot();\n+    if (hr_curr != hr_last) {\n+      hr_curr = _hrm.next_region_in_heap(hr_curr);\n+    } else {\n+      hr_curr = NULL;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -743,0 +743,4 @@\n+  \/\/ Populate the G1BlockOffsetTablePart for archived regions with the given\n+  \/\/ memory ranges.\n+  void populate_archive_regions_bot_part(MemRegion* range, size_t count);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        update_bot(hr);\n+        hr->update_bot();\n@@ -149,16 +149,0 @@\n-void G1FullGCPrepareTask::G1CalculatePointersClosure::update_bot(HeapRegion* hr) {\n-  HeapWord* const limit = hr->top();\n-  HeapWord* next_addr = hr->bottom();\n-  HeapWord* threshold = hr->initialize_threshold();\n-  HeapWord* prev_addr;\n-  while (next_addr < limit) {\n-    prev_addr = next_addr;\n-    next_addr = _bitmap->get_next_marked_addr(next_addr + 1, limit);\n-\n-    if (next_addr > threshold) {\n-      threshold = hr->cross_threshold(prev_addr, next_addr);\n-    }\n-  }\n-  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-    void update_bot(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -195,0 +195,4 @@\n+  }\n+\n+  void update_bot() {\n+    _bot_part.update();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}