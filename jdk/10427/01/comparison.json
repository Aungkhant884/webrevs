{"files":[{"patch":"@@ -27,1 +27,1 @@\n- * @summary Basic tests of virtual threads doing blocking I\/O with java.net sockets\n+ * @summary Test virtual threads doing blocking I\/O on java.net sockets\n@@ -34,2 +34,3 @@\n- * @test id=indirect-register\n- * @summary Basic tests of virtual threads doing blocking I\/O with java.net sockets\n+ * @test id=direct-register\n+ * @summary Test virtual threads doing blocking I\/O on java.net sockets and with\n+ *    the I\/O poller configured to use direct registration\n@@ -69,2 +70,0 @@\n-    private static final long DELAY = 2000;\n-\n@@ -116,3 +115,3 @@\n-                \/\/ schedule write\n-                byte[] ba = \"XXX\".getBytes(\"UTF-8\");\n-                ScheduledWriter.schedule(s1, ba, DELAY);\n+                \/\/ delayed write from sc1\n+                byte[] ba1 = \"XXX\".getBytes(\"UTF-8\");\n+                runAfterParkedAsync(() -> s1.getOutputStream().write(ba1));\n@@ -120,1 +119,1 @@\n-                \/\/ read should block\n+                \/\/ read from sc2 should block\n@@ -122,1 +121,0 @@\n-                    assert timeout > DELAY;\n@@ -125,2 +123,2 @@\n-                ba = new byte[10];\n-                int n = s2.getInputStream().read(ba);\n+                byte[] ba2 = new byte[10];\n+                int n = s2.getInputStream().read(ba2);\n@@ -128,1 +126,1 @@\n-                assertTrue(ba[0] == 'X');\n+                assertTrue(ba2[0] == 'X');\n@@ -143,2 +141,4 @@\n-                \/\/ schedule thread to read to EOF\n-                ScheduledReader.schedule(s2, true, DELAY);\n+                \/\/ delayed read from s2 to EOF\n+                InputStream in = s2.getInputStream();\n+                Thread reader = runAfterParkedAsync(() ->\n+                        in.transferTo(OutputStream.nullOutputStream()));\n@@ -148,3 +148,4 @@\n-                OutputStream out = s1.getOutputStream();\n-                for (int i=0; i<1000; i++) {\n-                    out.write(ba);\n+                try (OutputStream out = s1.getOutputStream()) {\n+                    for (int i = 0; i < 1000; i++) {\n+                        out.write(ba);\n+                    }\n@@ -152,0 +153,3 @@\n+\n+                \/\/ wait for reader to finish\n+                reader.join();\n@@ -157,1 +161,1 @@\n-     * Virtual thread blocks in read, peer closes connection.\n+     * Virtual thread blocks in read, peer closes connection gracefully.\n@@ -166,1 +170,2 @@\n-                ScheduledCloser.schedule(s2, DELAY);\n+                \/\/ delayed close of s2\n+                runAfterParkedAsync(s2::close);\n@@ -168,0 +173,1 @@\n+                \/\/ read from s1 should block, then read -1\n@@ -184,0 +190,1 @@\n+                \/\/ delayed abrupt close of s2\n@@ -185,1 +192,1 @@\n-                ScheduledCloser.schedule(s2, DELAY);\n+                runAfterParkedAsync(s2::close);\n@@ -187,0 +194,1 @@\n+                \/\/ read from s1 should block, then throw\n@@ -188,2 +196,2 @@\n-                    s1.getInputStream().read();\n-                    fail();\n+                    int n = s1.getInputStream().read();\n+                    fail(\"read \" + n);\n@@ -217,1 +225,8 @@\n-                ScheduledCloser.schedule(s, DELAY);\n+\n+                \/\/ delayed close of s\n+                runAfterParkedAsync(s::close);\n+\n+                \/\/ read from s should block, then throw\n+                if (timeout > 0) {\n+                    s.setSoTimeout(timeout);\n+                }\n@@ -219,4 +234,0 @@\n-                    if (timeout > 0) {\n-                        assert timeout > DELAY;\n-                        s.setSoTimeout(timeout);\n-                    }\n@@ -224,1 +235,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read \" + n);\n@@ -250,1 +261,10 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n+                \/\/ read from s should block, then throw\n+                if (timeout > 0) {\n+                    s.setSoTimeout(timeout);\n+                }\n@@ -252,4 +272,0 @@\n-                    if (timeout > 0) {\n-                        assert timeout > DELAY;\n-                        s.setSoTimeout(timeout);\n-                    }\n@@ -257,1 +273,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read \" + n);\n@@ -274,1 +290,5 @@\n-                ScheduledCloser.schedule(s, DELAY);\n+\n+                \/\/ delayedclose of s\n+                runAfterParkedAsync(s::close);\n+\n+                \/\/ write to s should block, then throw\n@@ -287,1 +307,1 @@\n-     * Virtual thread interrupted while blocked in Socket write\n+     * Virtual thread interrupted while blocked in Socket write.\n@@ -294,1 +314,6 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n+                \/\/ write to s should block, then throw\n@@ -320,1 +345,3 @@\n-                ScheduledUrgentData.scheduleUrgentData(s2, 'X', DELAY);\n+                runAfterParkedAsync(() -> s2.sendUrgentData('X'));\n+\n+                \/\/ read should block, then read the OOB byte\n@@ -345,2 +372,7 @@\n-            try (var listener = new ServerSocket(0)) {\n-                var socket1 = new Socket(listener.getInetAddress(), listener.getLocalPort());\n+            try (var listener = new ServerSocket()) {\n+                InetAddress loopback = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(loopback, 0));\n+\n+                \/\/ establish connection\n+                var socket1 = new Socket(loopback, listener.getLocalPort());\n+\n@@ -373,1 +405,5 @@\n-            try (var listener = new ServerSocket(0)) {\n+            try (var listener = new ServerSocket()) {\n+                InetAddress loopback = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(loopback, 0));\n+\n+                \/\/ schedule connect\n@@ -375,2 +411,4 @@\n-                ScheduledConnector.schedule(socket1, listener.getLocalSocketAddress(), DELAY);\n-                \/\/ accept will block\n+                SocketAddress remote = listener.getLocalSocketAddress();\n+                runAfterParkedAsync(() -> socket1.connect(remote));\n+\n+                \/\/ accept should block\n@@ -378,1 +416,0 @@\n-                    assert timeout > DELAY;\n@@ -406,2 +443,8 @@\n-            try (var listener = new ServerSocket(0)) {\n-                ScheduledCloser.schedule(listener, DELAY);\n+            try (var listener = new ServerSocket()) {\n+                InetAddress loopback = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(loopback, 0));\n+\n+                \/\/ delayed close of listener\n+                runAfterParkedAsync(listener::close);\n+\n+                \/\/ accept should block, then throw\n@@ -409,1 +452,0 @@\n-                    assert timeout > DELAY;\n@@ -414,1 +456,1 @@\n-                    throw new RuntimeException(\"connection accepted???\");\n+                    fail(\"connection accepted???\");\n@@ -421,1 +463,1 @@\n-     * Virtual thread interrupted while blocked in ServerSocket accept\n+     * Virtual thread interrupted while blocked in ServerSocket accept.\n@@ -429,1 +471,1 @@\n-     * Virtual thread interrupted while blocked in ServerSocket accept with timeout\n+     * Virtual thread interrupted while blocked in ServerSocket accept with timeout.\n@@ -438,2 +480,9 @@\n-            try (var listener = new ServerSocket(0)) {\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+            try (var listener = new ServerSocket()) {\n+                InetAddress loopback = InetAddress.getLoopbackAddress();\n+                listener.bind(new InetSocketAddress(loopback, 0));\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n+                \/\/ accept should block, then throw\n@@ -441,1 +490,0 @@\n-                    assert timeout > DELAY;\n@@ -446,1 +494,1 @@\n-                    throw new RuntimeException(\"connection accepted???\");\n+                    fail(\"connection accepted???\");\n@@ -485,1 +533,1 @@\n-     * Virtual thread blocks in DatagramSocket receive\n+     * Virtual thread blocks in DatagramSocket receive.\n@@ -493,1 +541,1 @@\n-     * Virtual thread blocks in DatagramSocket receive with timeout\n+     * Virtual thread blocks in DatagramSocket receive with timeout.\n@@ -509,1 +557,1 @@\n-                \/\/ schedule send\n+                \/\/ delayed send\n@@ -513,1 +561,1 @@\n-                ScheduledSender.schedule(s1, p1, DELAY);\n+                runAfterParkedAsync(() -> s1.send(p1));\n@@ -517,1 +565,0 @@\n-                    assert timeout > DELAY;\n@@ -530,1 +577,1 @@\n-     * Virtual thread blocks in DatagramSocket receive that times out\n+     * Virtual thread blocks in DatagramSocket receive that times out.\n@@ -538,1 +585,1 @@\n-                s.setSoTimeout(2000);\n+                s.setSoTimeout(500);\n@@ -571,2 +618,2 @@\n-                \/\/ schedule close\n-                ScheduledCloser.schedule(s, DELAY);\n+                \/\/ delayed close of s\n+                runAfterParkedAsync(s::close);\n@@ -574,1 +621,1 @@\n-                \/\/ receive\n+                \/\/ receive should block, then throw\n@@ -576,1 +623,0 @@\n-                    assert timeout > DELAY;\n@@ -598,1 +644,1 @@\n-     * Virtual thread interrupted while blocked in DatagramSocket receive with timeout\n+     * Virtual thread interrupted while blocked in DatagramSocket receive with timeout.\n@@ -610,0 +656,6 @@\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n+                \/\/ receive should block, then throw\n@@ -611,1 +663,0 @@\n-                    assert timeout > DELAY;\n@@ -614,5 +665,0 @@\n-\n-                \/\/ schedule interrupt\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n-\n-                \/\/ receive\n@@ -632,2 +678,0 @@\n-    \/\/ -- supporting classes --\n-\n@@ -671,20 +715,3 @@\n-    \/**\n-     * Closes a socket after a delay\n-     *\/\n-    static class ScheduledCloser implements Runnable {\n-        private final Closeable c;\n-        private final long delay;\n-        ScheduledCloser(Closeable c, long delay) {\n-            this.c = c;\n-            this.delay = delay;\n-        }\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                c.close();\n-            } catch (Exception e) { }\n-        }\n-        static void schedule(Closeable c, long delay) {\n-            new Thread(new ScheduledCloser(c, delay)).start();\n-        }\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n@@ -694,1 +721,3 @@\n-     * Interrupts a thread after a delay\n+     * Runs the given task asynchronously after the current virtual thread has\n+     * parked, or after a max wait time, whichever is first.\n+     * @return the thread started to run the task\n@@ -696,11 +725,5 @@\n-    static class ScheduledInterrupter implements Runnable {\n-        private final Thread thread;\n-        private final long delay;\n-\n-        ScheduledInterrupter(Thread thread, long delay) {\n-            this.thread = thread;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n+    static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+        Thread target = Thread.currentThread();\n+        if (!target.isVirtual())\n+            throw new WrongThreadException();\n+        return Thread.ofPlatform().daemon().start(() -> {\n@@ -708,34 +731,5 @@\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(Thread thread, long delay) {\n-            new Thread(new ScheduledInterrupter(thread, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Reads from a socket, and to EOF, after a delay\n-     *\/\n-    static class ScheduledReader implements Runnable {\n-        private final Socket s;\n-        private final boolean readAll;\n-        private final long delay;\n-\n-        ScheduledReader(Socket s, boolean readAll, long delay) {\n-            this.s = s;\n-            this.readAll = readAll;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                byte[] ba = new byte[8192];\n-                InputStream in = s.getInputStream();\n-                for (;;) {\n-                    int n = in.read(ba);\n-                    if (n == -1 || !readAll)\n-                        break;\n+                Thread.State state = target.getState();\n+                while (state != Thread.State.WAITING\n+                        && state != Thread.State.TIMED_WAITING) {\n+                    Thread.sleep(20);\n+                    state = target.getState();\n@@ -743,114 +737,6 @@\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(Socket s, boolean readAll, long delay) {\n-            new Thread(new ScheduledReader(s, readAll, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Writes to a socket after a delay\n-     *\/\n-    static class ScheduledWriter implements Runnable {\n-        private final Socket s;\n-        private final byte[] ba;\n-        private final long delay;\n-\n-        ScheduledWriter(Socket s, byte[] ba, long delay) {\n-            this.s = s;\n-            this.ba = ba.clone();\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                s.getOutputStream().write(ba);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(Socket s, byte[] ba, long delay) {\n-            new Thread(new ScheduledWriter(s, ba, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Establish a connection to a socket address after a delay\n-     *\/\n-    static class ScheduledConnector implements Runnable {\n-        private final Socket socket;\n-        private final SocketAddress address;\n-        private final long delay;\n-\n-        ScheduledConnector(Socket socket, SocketAddress address, long delay) {\n-            this.socket = socket;\n-            this.address = address;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                socket.connect(address);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(Socket socket, SocketAddress address, long delay) {\n-            new Thread(new ScheduledConnector(socket, address, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Sends a datagram to a target address after a delay\n-     *\/\n-    static class ScheduledSender implements Runnable {\n-        private final DatagramSocket socket;\n-        private final DatagramPacket packet;\n-        private final long delay;\n-\n-        ScheduledSender(DatagramSocket socket, DatagramPacket packet, long delay) {\n-            this.socket = socket;\n-            this.packet = packet;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                socket.send(packet);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(DatagramSocket socket, DatagramPacket packet, long delay) {\n-            new Thread(new ScheduledSender(socket, packet, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Sends urgent data after a delay\n-     *\/\n-    static class ScheduledUrgentData implements Runnable {\n-        private final Socket s;\n-        private final int data;\n-        private final long delay;\n-\n-        ScheduledUrgentData(Socket s, int data, long delay) {\n-            this.s = s;\n-            this.data = data;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                s.sendUrgentData(data);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void scheduleUrgentData(Socket s, int data, long delay) {\n-            new Thread(new ScheduledUrgentData(s, data, delay)).start();\n-        }\n+                Thread.sleep(20);  \/\/ give a bit more time to release carrier\n+                task.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n","filename":"test\/jdk\/java\/net\/vthread\/BlockingSocketOps.java","additions":141,"deletions":255,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Basic tests of virtual threads doing blocking I\/O with NIO channels\n+ * @summary Test virtual threads doing blocking I\/O on NIO channels\n@@ -34,2 +34,3 @@\n- * @test id=indirect-register\n- * @summary Basic tests of virtual threads doing blocking I\/O with NIO channels\n+ * @test id=direct-register\n+ * @summary Test virtual threads doing blocking I\/O on NIO channels and with\n+ *    the I\/O poller configured to use direct registration\n@@ -60,0 +61,1 @@\n+import java.nio.channels.ClosedChannelException;\n@@ -67,0 +69,1 @@\n+import jdk.test.lib.Platform;\n@@ -72,1 +75,0 @@\n-    private static final long DELAY = 4000;\n@@ -84,1 +86,1 @@\n-                \/\/ write should not block\n+                \/\/ write to sc1\n@@ -89,1 +91,1 @@\n-                \/\/ read should not block\n+                \/\/ read from sc2 should not block\n@@ -108,3 +110,3 @@\n-                \/\/ schedule write\n-                ByteBuffer bb = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n-                ScheduledWriter.schedule(sc1, bb, DELAY);\n+                \/\/ delayed write to sc1\n+                ByteBuffer bb1 = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n+                runAfterParkedAsync(() -> sc1.write(bb1));\n@@ -112,3 +114,3 @@\n-                \/\/ read should block\n-                bb = ByteBuffer.allocate(10);\n-                int n = sc2.read(bb);\n+                \/\/ read from sc2 should block\n+                ByteBuffer bb2 = ByteBuffer.allocate(10);\n+                int n = sc2.read(bb2);\n@@ -116,1 +118,1 @@\n-                assertTrue(bb.get(0) == 'X');\n+                assertTrue(bb2.get(0) == 'X');\n@@ -131,2 +133,2 @@\n-                \/\/ schedule thread to read to EOF\n-                ScheduledReader.schedule(sc2, true, DELAY);\n+                \/\/ delayed read from sc2 to EOF\n+                Thread reader = runAfterParkedAsync(() -> readToEOF(sc2));\n@@ -134,1 +136,1 @@\n-                \/\/ write should block\n+                \/\/ write to sc1 should block\n@@ -141,0 +143,4 @@\n+                sc1.close();\n+\n+                \/\/ wait for reader to finish\n+                reader.join();\n@@ -153,1 +159,1 @@\n-                ScheduledCloser.schedule(sc, DELAY);\n+                runAfterParkedAsync(sc::close);\n@@ -156,1 +162,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read returned \" + n);\n@@ -170,1 +176,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -173,1 +183,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read returned \" + n);\n@@ -189,1 +199,1 @@\n-                ScheduledCloser.schedule(sc, DELAY);\n+                runAfterParkedAsync(sc::close);\n@@ -197,1 +207,6 @@\n-                } catch (AsynchronousCloseException expected) { }\n+                } catch (AsynchronousCloseException e) {\n+                    \/\/ expected\n+                } catch (ClosedChannelException e) {\n+                    \/\/ on macOS the write loop may block more than once\n+                    if (!Platform.isOSX()) throw e;\n+                }\n@@ -210,1 +225,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -218,1 +237,1 @@\n-                } catch (ClosedByInterruptException expected) {\n+                } catch (ClosedByInterruptException e) {\n@@ -220,0 +239,3 @@\n+                } catch (ClosedChannelException e) {\n+                    \/\/ on macOS the write loop may block more than once\n+                    if (!Platform.isOSX()) throw e;\n@@ -247,1 +269,1 @@\n-                \/\/ schedule write\n+                \/\/ delayed write to sc1\n@@ -249,1 +271,1 @@\n-                ScheduledWriter.schedule(sc1, bb, DELAY);\n+                runAfterParkedAsync(() -> sc1.write(bb));\n@@ -251,1 +273,2 @@\n-                \/\/ read should block\n+                \/\/ read from sc2 should block\n+                byte[] array = new byte[100];\n@@ -254,2 +277,0 @@\n-\n-                byte[] array = new byte[100];\n@@ -289,2 +310,5 @@\n-                ScheduledConnector.schedule(sc1, ssc.getLocalAddress(), DELAY);\n-                \/\/ accept will block\n+\n+                \/\/ delayed connect\n+                runAfterParkedAsync(() -> sc1.connect(ssc.getLocalAddress()));\n+\n+                \/\/ accept should block\n@@ -307,1 +331,1 @@\n-                ScheduledCloser.schedule(ssc, DELAY);\n+                runAfterParkedAsync(ssc::close);\n@@ -311,1 +335,1 @@\n-                    throw new RuntimeException(\"connection accepted???\");\n+                    fail(\"connection accepted???\");\n@@ -326,1 +350,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -330,1 +358,1 @@\n-                    throw new RuntimeException(\"connection accepted???\");\n+                    fail(\"connection accepted???\");\n@@ -358,2 +386,1 @@\n-                var sc1 = SocketChannel.open();\n-                ScheduledConnector.schedule(sc1, ssc.getLocalAddress(), DELAY);\n+                var sc = SocketChannel.open();\n@@ -361,0 +388,4 @@\n+                \/\/ delayed connect\n+                runAfterParkedAsync(() -> sc.connect(ssc.getLocalAddress()));\n+\n+                \/\/ accept should block\n@@ -363,2 +394,0 @@\n-\n-                \/\/ accept will block\n@@ -366,1 +395,1 @@\n-                sc1.close();\n+                sc.close();\n@@ -409,3 +438,3 @@\n-                \/\/ schedule send\n-                ByteBuffer bb = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n-                ScheduledSender.schedule(dc1, bb, dc2.getLocalAddress(), DELAY);\n+                \/\/ delayed send from sc1\n+                ByteBuffer bb1 = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n+                runAfterParkedAsync(() -> dc1.send(bb1, dc2.getLocalAddress()));\n@@ -413,4 +442,4 @@\n-                \/\/ read should block\n-                bb = ByteBuffer.allocate(10);\n-                dc2.receive(bb);\n-                assertTrue(bb.get(0) == 'X');\n+                \/\/ read from dc2 should block\n+                ByteBuffer bb2 = ByteBuffer.allocate(10);\n+                dc2.receive(bb2);\n+                assertTrue(bb2.get(0) == 'X');\n@@ -430,1 +459,1 @@\n-                ScheduledCloser.schedule(dc, DELAY);\n+                runAfterParkedAsync(dc::close);\n@@ -433,1 +462,1 @@\n-                    throw new RuntimeException(\"receive returned\");\n+                    fail(\"receive returned\");\n@@ -448,1 +477,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -451,1 +484,1 @@\n-                    throw new RuntimeException(\"receive returned\");\n+                    fail(\"receive returned\");\n@@ -483,1 +516,1 @@\n-                \/\/ schedule send\n+                \/\/ delayed send from dc2\n@@ -485,1 +518,1 @@\n-                ScheduledSender.schedule(dc1, bb, dc2.getLocalAddress(), DELAY);\n+                runAfterParkedAsync(() -> dc1.send(bb, dc2.getLocalAddress()));\n@@ -526,2 +559,3 @@\n-                \/\/ schedule channel\/socket to be asynchronously closed\n-                ScheduledCloser.schedule(dc, DELAY);\n+                \/\/ delayed close of channel\/socket\n+                runAfterParkedAsync(dc::close);\n+\n@@ -561,2 +595,4 @@\n-                \/\/ receive should block\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -607,3 +643,3 @@\n-                \/\/ schedule write\n-                ByteBuffer bb = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n-                ScheduledWriter.schedule(sink, bb, DELAY);\n+                \/\/ delayed write from sink\n+                ByteBuffer bb1 = ByteBuffer.wrap(\"XXX\".getBytes(\"UTF-8\"));\n+                runAfterParkedAsync(() -> sink.write(bb1));\n@@ -612,2 +648,2 @@\n-                bb = ByteBuffer.allocate(10);\n-                int n = source.read(bb);\n+                ByteBuffer bb2 = ByteBuffer.allocate(10);\n+                int n = source.read(bb2);\n@@ -615,1 +651,1 @@\n-                assertTrue(bb.get(0) == 'X');\n+                assertTrue(bb2.get(0) == 'X');\n@@ -630,2 +666,2 @@\n-                \/\/ schedule thread to read to EOF\n-                ScheduledReader.schedule(source, true, DELAY);\n+                \/\/ delayed read from source to EOF\n+                Thread reader = runAfterParkedAsync(() -> readToEOF(source));\n@@ -633,1 +669,1 @@\n-                \/\/ write should block\n+                \/\/ write to sink should block\n@@ -640,0 +676,4 @@\n+                sink.close();\n+\n+                \/\/ wait for reader to finish\n+                reader.join();\n@@ -652,1 +692,1 @@\n-                ScheduledCloser.schedule(source, DELAY);\n+                runAfterParkedAsync(source::close);\n@@ -655,1 +695,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read returned \" + n);\n@@ -669,1 +709,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -672,1 +716,1 @@\n-                    throw new RuntimeException(\"read returned \" + n);\n+                    fail(\"read returned \" + n);\n@@ -688,1 +732,1 @@\n-                ScheduledCloser.schedule(sink, DELAY);\n+                runAfterParkedAsync(sink::close);\n@@ -709,1 +753,5 @@\n-                ScheduledInterrupter.schedule(Thread.currentThread(), DELAY);\n+\n+                \/\/ delayed interrupt of current thread\n+                Thread thisThread = Thread.currentThread();\n+                runAfterParkedAsync(thisThread::interrupt);\n+\n@@ -724,2 +772,0 @@\n-    \/\/ -- supporting classes --\n-\n@@ -763,1 +809,1 @@\n-     * Closes a channel after a delay\n+     * Read from a channel until all bytes have been read or an I\/O error occurs.\n@@ -765,16 +811,5 @@\n-    static class ScheduledCloser implements Runnable {\n-        private final Closeable c;\n-        private final long delay;\n-        ScheduledCloser(Closeable c, long delay) {\n-            this.c = c;\n-            this.delay = delay;\n-        }\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                c.close();\n-            } catch (Exception e) { }\n-        }\n-        static void schedule(Closeable c, long delay) {\n-            new Thread(new ScheduledCloser(c, delay)).start();\n+    static void readToEOF(ReadableByteChannel rbc) throws IOException {\n+        ByteBuffer bb = ByteBuffer.allocate(16*1024);\n+        int n;\n+        while ((n = rbc.read(bb)) > 0) {\n+            bb.clear();\n@@ -784,23 +819,3 @@\n-    \/**\n-     * Interrupts a thread after a delay\n-     *\/\n-    static class ScheduledInterrupter implements Runnable {\n-        private final Thread thread;\n-        private final long delay;\n-\n-        ScheduledInterrupter(Thread thread, long delay) {\n-            this.thread = thread;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(Thread thread, long delay) {\n-            new Thread(new ScheduledInterrupter(thread, delay)).start();\n-        }\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n@@ -810,1 +825,3 @@\n-     * Establish a connection to a socket address after a delay\n+     * Runs the given task asynchronously after the current virtual thread has\n+     * parked, or after a max wait time, whichever is first.\n+     * @return the thread started to run the task\n@@ -812,13 +829,5 @@\n-    static class ScheduledConnector implements Runnable {\n-        private final SocketChannel sc;\n-        private final SocketAddress address;\n-        private final long delay;\n-\n-        ScheduledConnector(SocketChannel sc, SocketAddress address, long delay) {\n-            this.sc = sc;\n-            this.address = address;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n+    static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+        Thread target = Thread.currentThread();\n+        if (!target.isVirtual())\n+            throw new WrongThreadException();\n+        return Thread.ofPlatform().daemon().start(() -> {\n@@ -826,34 +835,5 @@\n-                Thread.sleep(delay);\n-                sc.connect(address);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(SocketChannel sc, SocketAddress address, long delay) {\n-            new Thread(new ScheduledConnector(sc, address, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Reads from a connection, and to EOF, after a delay\n-     *\/\n-    static class ScheduledReader implements Runnable {\n-        private final ReadableByteChannel rbc;\n-        private final boolean readAll;\n-        private final long delay;\n-\n-        ScheduledReader(ReadableByteChannel rbc, boolean readAll, long delay) {\n-            this.rbc = rbc;\n-            this.readAll = readAll;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                ByteBuffer bb = ByteBuffer.allocate(100*1024);\n-                for (;;) {\n-                    int n = rbc.read(bb);\n-                    if (n == -1 || !readAll)\n-                        break;\n-                    bb.clear();\n+                Thread.State state = target.getState();\n+                while (state != Thread.State.WAITING\n+                        && state != Thread.State.TIMED_WAITING) {\n+                    Thread.sleep(20);\n+                    state = target.getState();\n@@ -861,63 +841,6 @@\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(ReadableByteChannel rbc, boolean readAll, long delay) {\n-            new Thread(new ScheduledReader(rbc, readAll, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Writes to a connection after a delay\n-     *\/\n-    static class ScheduledWriter implements Runnable {\n-        private final WritableByteChannel wbc;\n-        private final ByteBuffer buf;\n-        private final long delay;\n-\n-        ScheduledWriter(WritableByteChannel wbc, ByteBuffer buf, long delay) {\n-            this.wbc = wbc;\n-            this.buf = buf;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                wbc.write(buf);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(WritableByteChannel wbc, ByteBuffer buf, long delay) {\n-            new Thread(new ScheduledWriter(wbc, buf, delay)).start();\n-        }\n-    }\n-\n-    \/**\n-     * Sends a datagram to a target address after a delay\n-     *\/\n-    static class ScheduledSender implements Runnable {\n-        private final DatagramChannel dc;\n-        private final ByteBuffer buf;\n-        private final SocketAddress address;\n-        private final long delay;\n-\n-        ScheduledSender(DatagramChannel dc, ByteBuffer buf, SocketAddress address, long delay) {\n-            this.dc = dc;\n-            this.buf = buf;\n-            this.address = address;\n-            this.delay = delay;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                Thread.sleep(delay);\n-                dc.send(buf, address);\n-            } catch (Exception e) { }\n-        }\n-\n-        static void schedule(DatagramChannel dc, ByteBuffer buf,\n-                             SocketAddress address, long delay) {\n-            new Thread(new ScheduledSender(dc, buf, address, delay)).start();\n-        }\n+                Thread.sleep(20);  \/\/ give a bit more time to release carrier\n+                task.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":148,"deletions":225,"binary":false,"changes":373,"status":"modified"}]}