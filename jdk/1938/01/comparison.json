{"files":[{"patch":"@@ -296,0 +296,2 @@\n+#define REWRITE_AT_PC(val) \\\n+    *pc = val;\n@@ -392,0 +394,75 @@\n+#define MAYBE_POST_FIELD_ACCESS(obj) {                              \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM. *\/              \\\n+    count_addr = (int*)JvmtiExport::get_field_access_count_addr();  \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_access(THREAD,         \\\n+                                  target, cache),                   \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+#define MAYBE_POST_FIELD_MODIFICATION(obj) {                        \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM.            *\/   \\\n+    count_addr = (int*)JvmtiExport::get_field_modification_count_addr(); \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_modification(THREAD,   \\\n+                                  target, cache,                    \\\n+                                  (jvalue*)STACK_SLOT(-1)),         \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+static inline int fast_get_type(TosState tos) {\n+  switch (tos) {\n+    case ztos:\n+    case btos: return Bytecodes::_fast_bgetfield;\n+    case ctos: return Bytecodes::_fast_cgetfield;\n+    case stos: return Bytecodes::_fast_sgetfield;\n+    case itos: return Bytecodes::_fast_igetfield;\n+    case ltos: return Bytecodes::_fast_lgetfield;\n+    case ftos: return Bytecodes::_fast_fgetfield;\n+    case dtos: return Bytecodes::_fast_dgetfield;\n+    case atos: return Bytecodes::_fast_agetfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n+static inline int fast_put_type(TosState tos) {\n+  switch (tos) {\n+    case ztos: return Bytecodes::_fast_zputfield;\n+    case btos: return Bytecodes::_fast_bputfield;\n+    case ctos: return Bytecodes::_fast_cputfield;\n+    case stos: return Bytecodes::_fast_sputfield;\n+    case itos: return Bytecodes::_fast_iputfield;\n+    case ltos: return Bytecodes::_fast_lputfield;\n+    case ftos: return Bytecodes::_fast_fputfield;\n+    case dtos: return Bytecodes::_fast_dputfield;\n+    case atos: return Bytecodes::_fast_aputfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n@@ -512,2 +589,2 @@\n-\/* 0xC8 *\/ &&opc_goto_w,      &&opc_jsr_w,          &&opc_breakpoint,   &&opc_default,\n-\/* 0xCC *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n+\/* 0xC8 *\/ &&opc_goto_w,      &&opc_jsr_w,          &&opc_breakpoint,   &&opc_fast_agetfield,\n+\/* 0xCC *\/ &&opc_fast_bgetfield,     &&opc_fast_cgetfield,        &&opc_fast_dgetfield,      &&opc_fast_fgetfield,\n@@ -515,4 +592,4 @@\n-\/* 0xD0 *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n-\/* 0xD4 *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n-\/* 0xD8 *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n-\/* 0xDC *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n+\/* 0xD0 *\/ &&opc_fast_igetfield,     &&opc_fast_lgetfield,        &&opc_fast_sgetfield,      &&opc_fast_aputfield,\n+\/* 0xD4 *\/ &&opc_fast_bputfield,     &&opc_fast_zputfield,        &&opc_fast_cputfield,      &&opc_fast_dputfield,\n+\/* 0xD8 *\/ &&opc_fast_fputfield,     &&opc_fast_iputfield,        &&opc_fast_lputfield,      &&opc_fast_sputfield,\n+\/* 0xDC *\/ &&opc_fast_aload_0,       &&opc_fast_iaccess_0,        &&opc_fast_aaccess_0,      &&opc_fast_faccess_0,\n@@ -520,1 +597,1 @@\n-\/* 0xE0 *\/ &&opc_default,     &&opc_default,        &&opc_default,         &&opc_default,\n+\/* 0xE0 *\/ &&opc_fast_iload,  &&opc_fast_iload2,    &&opc_fast_icaload, &&opc_fast_invokevfinal,\n@@ -522,3 +599,2 @@\n-\/* 0xE8 *\/ &&opc_return_register_finalizer,\n-                              &&opc_invokehandle,   &&opc_default,      &&opc_default,\n-\/* 0xEC *\/ &&opc_default,     &&opc_default,        &&opc_default,         &&opc_default,\n+\/* 0xE8 *\/ &&opc_return_register_finalizer,         &&opc_invokehandle, &&opc_default,   &&opc_default,\n+\/* 0xEC *\/ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,\n@@ -787,0 +863,25 @@\n+      {\n+        \/\/ Attempt to rewrite iload, iload -> fast_iload2\n+        \/\/                    iload, caload -> fast_icaload\n+        \/\/ Normal iloads will be rewritten to fast_iload to avoid checking again.\n+        Bytecodes::Code next = (Bytecodes::Code) * (pc + 2);\n+        switch (next) {\n+          case Bytecodes::_fast_iload:\n+            REWRITE_AT_PC(Bytecodes::_fast_iload2);\n+            break;\n+          case Bytecodes::_caload:\n+            REWRITE_AT_PC(Bytecodes::_fast_icaload);\n+            break;\n+          case Bytecodes::_iload:\n+            \/\/ Wait until rewritten to _fast_iload.\n+            break;\n+          default:\n+            \/\/ Last iload in a (potential) series, don't check again.\n+            REWRITE_AT_PC(Bytecodes::_fast_iload);\n+        }\n+        \/\/ Normal iload handling.\n+        SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);\n+      }\n+\n+      CASE(_fast_iload):\n@@ -791,0 +892,5 @@\n+      CASE(_fast_iload2):\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[3]), 1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(4, 2);\n+\n@@ -801,5 +907,0 @@\n-      CASE(_aload_##num):                                               \\\n-          VERIFY_OOP(LOCALS_OBJECT(num));                               \\\n-          SET_STACK_OBJECT(LOCALS_OBJECT(num), 0);                      \\\n-          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n-                                                                        \\\n@@ -818,4 +919,45 @@\n-          OPC_LOAD_n(0);\n-          OPC_LOAD_n(1);\n-          OPC_LOAD_n(2);\n-          OPC_LOAD_n(3);\n+      OPC_LOAD_n(0);\n+      OPC_LOAD_n(1);\n+      OPC_LOAD_n(2);\n+      OPC_LOAD_n(3);\n+\n+#undef  OPC_ALOAD_n\n+#define OPC_ALOAD_n(num)                                                \\\n+      CASE(_aload_##num): {                                             \\\n+          oop obj = LOCALS_OBJECT(num);                                 \\\n+          VERIFY_OOP(obj);                                              \\\n+          SET_STACK_OBJECT(obj, 0);                                     \\\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n+      }\n+\n+      CASE(_aload_0):\n+      {\n+        \/* Maybe rewrite if following bytecode is one of the supported _fast_Xgetfield bytecodes. *\/\n+        switch (*(pc + 1)) {\n+          case Bytecodes::_fast_agetfield:\n+            REWRITE_AT_PC(Bytecodes::_fast_aaccess_0);\n+            break;\n+          case Bytecodes::_fast_fgetfield:\n+            REWRITE_AT_PC(Bytecodes::_fast_faccess_0);\n+            break;\n+          case Bytecodes::_fast_igetfield:\n+            REWRITE_AT_PC(Bytecodes::_fast_iaccess_0);\n+            break;\n+          case Bytecodes::_getfield: {\n+            \/* Otherwise, do nothing here, wait until it gets rewritten to _fast_Xgetfield.\n+             * Unfortunately, this punishes volatile field access, because it never gets\n+             * rewritten. *\/\n+            break;\n+          }\n+          default:\n+            REWRITE_AT_PC(Bytecodes::_fast_aload_0);\n+            break;\n+        }\n+        VERIFY_OOP(LOCALS_OBJECT(0));\n+        SET_STACK_OBJECT(LOCALS_OBJECT(0), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      OPC_ALOAD_n(1);\n+      OPC_ALOAD_n(2);\n+      OPC_ALOAD_n(3);\n@@ -1353,5 +1495,1 @@\n-      \/* Every array access byte-code starts out like this *\/\n-\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n-#define ARRAY_INTRO(arrayOff)                                                  \\\n-      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n-      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+#define ARRAY_INDEX_CHECK(arrObj, index)                                       \\\n@@ -1369,0 +1507,7 @@\n+      \/* Every array access byte-code starts out like this *\/\n+\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n+#define ARRAY_INTRO(arrayOff)                                                  \\\n+      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n+      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+      ARRAY_INDEX_CHECK(arrObj, index)\n+\n@@ -1408,0 +1553,9 @@\n+      CASE(_fast_icaload): {\n+          \/\/ Custom fast access for iload,caload pair.\n+          arrayOop arrObj = (arrayOop) STACK_OBJECT(-1);\n+          jint index = LOCALS_INT(pc[1]);\n+          ARRAY_INDEX_CHECK(arrObj, index);\n+          SET_STACK_INT(*(jchar *)(((address) arrObj->base(T_CHAR)) + index * sizeof(jchar)), -1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 0);\n+      }\n+\n@@ -1577,20 +1731,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_access_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {\n-                obj = NULL;\n-              } else {\n-                obj = STACK_OBJECT(-1);\n-                VERIFY_OOP(obj);\n-              }\n-              CALL_VM(InterpreterRuntime::post_field_access(THREAD,\n-                                          obj,\n-                                          cache),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1605,0 +1739,5 @@\n+            \/\/ Check if we can rewrite non-volatile _getfield to one of the _fast_Xgetfield.\n+            if (!cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xgetfield.\n+              REWRITE_AT_PC(fast_get_type(cache->flag_state()));\n+            }\n@@ -1607,0 +1746,2 @@\n+          MAYBE_POST_FIELD_ACCESS(obj);\n+\n@@ -1701,27 +1842,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_modification_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {\n-                obj = NULL;\n-              }\n-              else {\n-                if (cache->is_long() || cache->is_double()) {\n-                  obj = STACK_OBJECT(-3);\n-                } else {\n-                  obj = STACK_OBJECT(-2);\n-                }\n-                VERIFY_OOP(obj);\n-              }\n-\n-              CALL_VM(InterpreterRuntime::post_field_modification(THREAD,\n-                                          obj,\n-                                          cache,\n-                                          (jvalue *)STACK_SLOT(-1)),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1746,0 +1860,6 @@\n+\n+            \/\/ Check if we can rewrite non-volatile _putfield to one of the _fast_Xputfield.\n+            if (!cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xputfield.\n+              REWRITE_AT_PC(fast_put_type(cache->flag_state()));\n+            }\n@@ -1748,0 +1868,2 @@\n+          MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n@@ -2306,0 +2428,2 @@\n+              \/\/ Rewrite to _fast_invokevfinal.\n+              REWRITE_AT_PC(Bytecodes::_fast_invokevfinal);\n@@ -2440,0 +2564,323 @@\n+      CASE(_fast_agetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_bgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->byte_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_cgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->char_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_dgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_DOUBLE(obj->double_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_fgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_igetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_lgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_LONG(obj->long_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_sgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->short_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_aputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->obj_field_put(field_offset, STACK_OBJECT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_bputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_zputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, (STACK_INT(-1) & 1)); \/\/ only store LSB\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_cputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->char_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_dputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->double_field_put(field_offset, STACK_DOUBLE(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_fputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->float_field_put(field_offset, STACK_FLOAT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_iputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->int_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_lputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->long_field_put(field_offset, STACK_LONG(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_sputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->short_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_aload_0): {\n+        oop obj = LOCALS_OBJECT(0);\n+        VERIFY_OOP(obj);\n+        SET_STACK_OBJECT(obj, 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      CASE(_fast_aaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_faccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_iaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_invokevfinal): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        assert(cache->is_resolved(Bytecodes::_invokevirtual), \"Should be resolved before rewriting\");\n+\n+        istate->set_msg(call_method);\n+\n+        CHECK_NULL(STACK_OBJECT(-(cache->parameter_size())));\n+        Method* callee = cache->f2_as_vfinal_method();\n+        istate->set_callee(callee);\n+        if (JVMTI_ENABLED && THREAD->is_interp_only_mode()) {\n+          istate->set_callee_entry_point(callee->interpreter_entry());\n+        } else {\n+          istate->set_callee_entry_point(callee->from_interpreted_entry());\n+        }\n+        istate->set_bcp_advance(3);\n+        UPDATE_PC_AND_RETURN(0);\n+      }\n+\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":518,"deletions":71,"binary":false,"changes":589,"status":"modified"}]}