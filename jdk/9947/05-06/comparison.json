{"files":[{"patch":"@@ -2285,8 +2285,1 @@\n-  emit_int16(0xF7, (0xF8 | encode));\n-}\n-\n-void Assembler::divl(Address src) { \/\/ Unsigned\n-  InstructionMark im(this);\n-  prefix(src);\n-  emit_int8(0xF7);\n-  emit_operand(as_Register(6), src, 0);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n@@ -2297,1 +2290,1 @@\n-  emit_int16(0xF7, (0xF0 | encode));\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n@@ -12913,8 +12906,1 @@\n-  emit_int16(0xF7, (0xF8 | encode));\n-}\n-\n-void Assembler::divq(Address src) { \/\/ Unsigned\n-  InstructionMark im(this);\n-  prefixq(src);\n-  emit_int8(0xF7);\n-  emit_operand(as_Register(6), src, 0);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n@@ -12925,1 +12911,1 @@\n-  emit_int16(0xF7, (0xF0 | encode));\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1387,1 +1387,0 @@\n-  void divl(Address src);\n@@ -1392,1 +1391,0 @@\n-  void divq(Address src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5457,0 +5457,81 @@\n+void C2_MacroAssembler::udivI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movl(rdx, rax);\n+  subl(rdx, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rdx, rax);\n+  } else {\n+    notl(rdx);\n+    andl(rax, rdx);\n+  }\n+  shrl(rax, 31);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rax, rdx);\n+  } else {\n+    notl(rax);\n+    andl(rax, rdx);\n+  }\n+  sarl(rax, 31);\n+  andl(rax, divisor);\n+  subl(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodI(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rax, rdx);\n+  } else {\n+    notl(rax);\n+    andl(rax, rdx);\n+  }\n+  movl(tmp, rax);\n+  shrl(rax, 31); \/\/ quotient\n+  sarl(tmp, 31);\n+  andl(tmp, divisor);\n+  subl(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n+\n@@ -5541,0 +5622,80 @@\n+\n+void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divq(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movq(rdx, rax);\n+  subq(rdx, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rdx, rax);\n+  } else {\n+    notq(rdx);\n+    andq(rax, rdx);\n+  }\n+  shrq(rax, 63);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rax, rdx);\n+  } else {\n+    notq(rax);\n+    andq(rax, rdx);\n+  }\n+  sarq(rax, 63);\n+  andq(rax, divisor);\n+  subq(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodL(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rax, rdx);\n+  } else {\n+    notq(rax);\n+    andq(rax, rdx);\n+  }\n+  movq(tmp, rax);\n+  shrq(rax, 63); \/\/ quotient\n+  sarq(tmp, 63);\n+  andq(tmp, divisor);\n+  subq(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n@@ -5588,0 +5749,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -351,0 +351,5 @@\n+#endif \/\/ _LP64\n+\n+  void udivI(Register rax, Register divisor, Register rdx);\n+  void umodI(Register rax, Register divisor, Register rdx);\n+  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n@@ -352,0 +357,1 @@\n+#ifdef _LP64\n@@ -356,0 +362,3 @@\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n+  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7805,15 +7805,0 @@\n-\/\/ Integer UDIV with Register\n-instruct udivI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n-  match(Set rax (UDivI rax div));\n-  effect(KILL rdx, KILL cr);\n-  size(4);\n-  ins_cost(300);\n-  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n-            \"DIV    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -7839,15 +7824,0 @@\n-\/\/ Integer UDIVMOD with Register\n-instruct udivModI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n-  match(UDivModI rax div);\n-  effect(KILL cr);\n-  size(4);\n-  ins_cost(300);\n-  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n-            \"DIV    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -7883,15 +7853,0 @@\n-\/\/ Integer UMOD with Register\n-instruct umodI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n-  match(Set rdx (UModI rax div));\n-  effect(KILL rax, KILL cr);\n-  size(4);\n-  ins_cost(300);\n-  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n-            \"DIV    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -341,1 +341,0 @@\n-extern RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -343,1 +342,0 @@\n-extern RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -347,1 +345,0 @@\n-inline const RegMask& STACK_OR_LONG_NO_RAX_RDX_REG_mask() { return _STACK_OR_LONG_NO_RAX_RDX_REG_mask; }\n@@ -349,1 +346,0 @@\n-inline const RegMask& STACK_OR_INT_NO_RAX_RDX_REG_mask() { return _STACK_OR_INT_NO_RAX_RDX_REG_mask; }\n@@ -375,1 +371,0 @@\n-RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -377,1 +372,0 @@\n-RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -427,2 +421,0 @@\n-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask = _LONG_NO_RAX_RDX_REG_mask;\n-  _STACK_OR_LONG_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -454,2 +446,0 @@\n-  _STACK_OR_INT_NO_RAX_RDX_REG_mask = _INT_NO_RAX_RDX_REG_mask;\n-  _STACK_OR_INT_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -8853,2 +8843,1 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n+  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n@@ -8856,2 +8845,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n+    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -8859,16 +8847,1 @@\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct udivI_mem(rax_RegI rax, rdx_RegI rdx, memory div, rFlagsReg cr)\n-%{\n-  match(Set rax (UDivI rax (LoadI div)));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -8883,17 +8856,1 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct udivL_mem(rax_RegL rax, rdx_RegL rdx, memory div, rFlagsReg cr)\n-%{\n-  match(Set rax (UDivL rax (LoadL div)));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n+  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n@@ -8901,2 +8858,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Address);\n+     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -8904,1 +8860,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -8949,1 +8905,1 @@\n-instruct udivModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx,\n+instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI tmp, rdx_RegI rdx,\n@@ -8953,1 +8909,1 @@\n-  effect(KILL cr);\n+  effect(TEMP tmp, KILL cr);\n@@ -8956,19 +8912,3 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Unsigned integer DIVMOD with Memory, both quotient and mod results\n-instruct udivModI_mem_divmod(rax_RegI rax, rdx_RegI rdx,\n-                             memory div, rFlagsReg cr)\n-%{\n-  match(UDivModI rax (LoadI div));\n-  effect(KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n+  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n+            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n+          %}\n@@ -8976,2 +8916,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Address);\n+    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n@@ -8983,1 +8922,1 @@\n-instruct udivModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx,\n+instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,\n@@ -8987,1 +8926,1 @@\n-  effect(KILL cr);\n+  effect(TEMP tmp, KILL cr);\n@@ -8990,19 +8929,3 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Unsigned long DIVMOD with Memory, both quotient and mod results\n-instruct udivModL_mem_divmod(rax_RegL rax, rdx_RegL rdx,\n-                             memory div, rFlagsReg cr)\n-%{\n-  match(UDivModL rax (LoadL div));\n-  effect(KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n+  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n+            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n+          %}\n@@ -9010,2 +8933,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Address);\n+    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n@@ -9061,17 +8983,1 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct umodI_mem(rdx_RegI rdx, rax_RegI rax, memory div, rFlagsReg cr)\n-%{\n-  match(Set rdx (UModI rax (LoadI div)));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divl    $div\" %}\n+  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n@@ -9079,2 +8985,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divl($div$$Address);\n+    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -9082,1 +8987,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg_reg_alu0);\n@@ -9091,2 +8996,1 @@\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n+  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n@@ -9094,2 +8998,1 @@\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Register);\n+    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -9097,16 +9000,1 @@\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct umodL_mem(rdx_RegL rdx, rax_RegL rax, memory div, rFlagsReg cr)\n-%{\n-  match(Set rdx (UModL rax (LoadL div)));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(375);\n-  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n-            \"divq    $div\" %}\n-  ins_encode %{\n-    __ xorl($rdx$$Register, $rdx$$Register);\n-    __ divq($div$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n+  ins_pipe(ialu_reg_reg_alu0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":24,"deletions":136,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-   do_name(     divideUnsigned_name,                             \"divideUnsigned0\")                                     \\\n+   do_name(     divideUnsigned_name,                             \"divideUnsigned\")                                      \\\n@@ -234,1 +234,1 @@\n-   do_name(     remainderUnsigned_name,                          \"remainderUnsigned0\")                                  \\\n+   do_name(     remainderUnsigned_name,                          \"remainderUnsigned\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1130,1 +1130,1 @@\n-  const TypeInt *ti = t->isa_int();\n+  const TypeInt* ti = t->isa_int();\n@@ -1661,1 +1661,1 @@\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* UModLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -1672,1 +1672,1 @@\n-  const Type *t = phase->type(in(2));\n+  const Type* t = phase->type(in(2));\n@@ -1676,1 +1676,1 @@\n-  const TypeLong *ti = t->is_long();\n+  const TypeLong* ti = t->is_long();\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1547,10 +1547,0 @@\n-    public static int divideUnsigned(int dividend, int divisor) {\n-        if (divisor > 0) {\n-            return divideUnsigned0(dividend, divisor);\n-        } else if (divisor < 0) {\n-            return compareUnsigned(dividend, divisor) >= 0 ? 1 : 0;\n-        } else {\n-            throw new ArithmeticException(\"\/ by zero\");\n-        }\n-    }\n-\n@@ -1558,1 +1548,1 @@\n-    private static int divideUnsigned0(int dividend, int divisor) {\n+    public static int divideUnsigned(int dividend, int divisor) {\n@@ -1575,12 +1565,0 @@\n-    public static int remainderUnsigned(int dividend, int divisor) {\n-        if (divisor > 0) {\n-            return remainderUnsigned0(dividend, divisor);\n-        } else if (divisor < 0) {\n-            return compareUnsigned(dividend, divisor) >= 0\n-                    ? (dividend - divisor)\n-                    : dividend;\n-        } else {\n-            throw new ArithmeticException(\"\/ by zero\");\n-        }\n-    }\n-\n@@ -1588,1 +1566,1 @@\n-    private static int remainderUnsigned0(int dividend, int divisor) {\n+    public static int remainderUnsigned(int dividend, int divisor) {\n@@ -1593,0 +1571,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1668,10 +1668,0 @@\n-    public static long divideUnsigned(long dividend, long divisor) {\n-        if (divisor > 0) {\n-            return divideUnsigned0(dividend, divisor);\n-        } else if (divisor < 0) {\n-            return compareUnsigned(dividend, divisor) >= 0 ? 1 : 0;\n-        } else {\n-            throw new ArithmeticException(\"\/ by zero\");\n-        }\n-    }\n-\n@@ -1679,1 +1669,1 @@\n-    private static long divideUnsigned0(long dividend, long divisor) {\n+    public static long divideUnsigned(long dividend, long divisor) {\n@@ -1701,12 +1691,0 @@\n-    public static long remainderUnsigned(long dividend, long divisor) {\n-        if (divisor > 0) {\n-            return remainderUnsigned0(dividend, divisor);\n-        } else if (divisor < 0) {\n-            return compareUnsigned(dividend, divisor) >= 0\n-                    ? (dividend - divisor)\n-                    : dividend;\n-        } else {\n-            throw new ArithmeticException(\"\/ by zero\");\n-        }\n-    }\n-\n@@ -1714,1 +1692,1 @@\n-    private static long remainderUnsigned0(long dividend, long divisor) {\n+    public static long remainderUnsigned(long dividend, long divisor) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n@@ -140,1 +140,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n@@ -149,1 +149,1 @@\n-                  IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n@@ -204,1 +204,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n@@ -141,1 +141,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n@@ -150,1 +150,1 @@\n-                  IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n@@ -202,1 +202,1 @@\n-    @IR(counts = {IRNode.ALLOC_OF, \"java\/lang\/ArithmeticException\", \"1\"})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}