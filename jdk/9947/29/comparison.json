{"files":[{"patch":"@@ -26,0 +26,2 @@\n+#include <limits>\n+#include <type_traits>\n@@ -39,0 +41,1 @@\n+\n@@ -41,41 +44,5 @@\n-\/\/ Optimization - Graph Style\n-\n-#include <math.h>\n-\n-\/\/----------------------magic_int_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.\n-static bool magic_int_divide_constants(jint d, jint &M, jint &s) {\n-  int32_t p;\n-  uint32_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint32_t two31 = 0x80000000L;     \/\/ 2**31.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two31 + ((uint32_t)d >> 31);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 31;                 \/\/ Init. p.\n-  q1 = two31\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two31 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two31\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two31 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n-    }\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n+template <class T>\n+static T max_unsigned_from_signed_bounds(T slo, T shi) {\n+  static_assert(std::is_unsigned<T>::value, \"must be\");\n+  return slo <= shi ? shi : std::numeric_limits<T>::max();\n+}\n@@ -83,3 +50,5 @@\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 32;             \/\/ shift amount to return.\n+static bool jint_mul_no_ovf(jint lo, jint hi, juint c) {\n+  jlong prod_lo = jlong(lo) * jlong(c);\n+  jlong prod_hi = jlong(hi) * jlong(c);\n+  return jlong(jint(prod_lo)) == prod_lo && jlong(jint(prod_hi)) == prod_hi;\n+}\n@@ -87,1 +56,3 @@\n-  return true;\n+static bool juint_mul_no_ovf(juint hi, juint c) {\n+  julong prod_hi = julong(hi) * julong(c);\n+  return julong(juint(prod_hi)) == prod_hi;\n@@ -90,4 +61,23 @@\n-\/\/--------------------------transform_int_divide-------------------------------\n-\/\/ Convert a division by constant divisor into an alternate Ideal graph.\n-\/\/ Return null if no transformation occurs.\n-static Node *transform_int_divide( PhaseGVN *phase, Node *dividend, jint divisor ) {\n+static bool jlong_mul_no_ovf(jlong lo, jlong hi, julong c) {\n+  if (jlong(c) < 0) {\n+    return lo == 0 && hi == 0;\n+  }\n+\n+  jlong prod_lo_hi = multiply_high_signed(lo, c);\n+  jlong prod_lo_lo = java_multiply(lo, c);\n+  jlong prod_hi_hi = multiply_high_signed(hi, c);\n+  jlong prod_hi_lo = java_multiply(hi, c);\n+  return ((prod_lo_hi == 0 && prod_lo_lo >= 0) || (prod_lo_hi == -1 && prod_lo_lo < 0)) &&\n+      ((prod_hi_hi == 0 && prod_hi_lo >= 0) || (prod_hi_hi == -1 && prod_hi_lo < 0));\n+}\n+\n+static bool julong_mul_no_ovf(julong hi, julong c) {\n+  julong prod_hi_hi = multiply_high_unsigned(hi, c);\n+  return prod_hi_hi == 0;\n+}\n+\n+static bool uint128_t_mul_no_ovf(julong hi, julong c_wrapped) {\n+  julong mul_hi_c_wrapped = multiply_high_unsigned(hi, c_wrapped);\n+  julong mul_hi_wrapped = mul_hi_c_wrapped + hi;\n+  return mul_hi_wrapped >= mul_hi_c_wrapped;\n+}\n@@ -95,0 +85,10 @@\n+\/*\n+magic_divide_constants in utilities\/javaArithmetic.hpp calculates the constant c, s\n+such that division(x \/ d) = floor(x * c \/ m) + (x < 0 ? 1 : 0) for every integer x in\n+the input range. The functions in this file try to derive from the formula in real\n+arithmetic to arrive at a formula in int\/long arithmetic. More details can be found in\n+each individual function.\n+*\/\n+\n+\/\/ Convert a division by constant divisor into an alternate Ideal graph.\n+static Node* transform_int_divide(PhaseGVN* phase, Node* dividend, jint divisor) {\n@@ -96,2 +96,5 @@\n-  assert( divisor != 0 && divisor != min_jint,\n-          \"bad divisor for transforming to long multiply\" );\n+  assert(divisor != 0 && divisor != 1,\n+         \"bad divisor for transforming to long multiply\");\n+  if (divisor == -1) {\n+    return new SubINode(phase->intcon(0), dividend);\n+  }\n@@ -100,5 +103,8 @@\n-  jint d = d_pos ? divisor : -divisor;\n-  const int N = 32;\n-\n-  \/\/ Result\n-  Node *q = nullptr;\n+  juint d = ABS<jint>(divisor);\n+  constexpr int N = 32;\n+  const TypeInt* dti = phase->type(dividend)->is_int();\n+  juint min_neg = dti->_lo < 0 ? -juint(dti->_lo) : 0;\n+  juint max_pos = dti->_hi > 0 ? juint(dti->_hi) : 0;\n+  if (min_neg < d && max_pos < d) {\n+    return new ConINode(TypeInt::ZERO);\n+  }\n@@ -106,7 +112,1 @@\n-  if (d == 1) {\n-    \/\/ division by +\/- 1\n-    if (!d_pos) {\n-      \/\/ Just negate the value\n-      q = new SubINode(phase->intcon(0), dividend);\n-    }\n-  } else if ( is_power_of_2(d) ) {\n+  if (is_power_of_2(d)) {\n@@ -114,0 +114,1 @@\n+    juint l = log2i_exact(d);\n@@ -117,3 +118,1 @@\n-    const Type *dt = phase->type(dividend);\n-    const TypeInt *dti = dt->isa_int();\n-    if (dti && dti->_lo >= 0) {\n+    if (dti->_lo >= 0) {\n@@ -122,1 +121,1 @@\n-    } else if( dividend->Opcode() == Op_AndI ) {\n+    } else if (dividend->Opcode() == Op_AndI) {\n@@ -125,5 +124,6 @@\n-      const TypeInt *andconi_t = phase->type( dividend->in(2) )->isa_int();\n-      if( andconi_t && andconi_t->is_con() ) {\n-        jint andconi = andconi_t->get_con();\n-        if( andconi < 0 && is_power_of_2(-andconi) && (-andconi) >= d ) {\n-          if( (-andconi) == d ) \/\/ Remove AND if it clears bits which will be shifted\n+      const TypeInt* andconi_t = phase->type(dividend->in(2))->isa_int();\n+      if (andconi_t && andconi_t->is_con()) {\n+        juint andconi = andconi_t->get_con();\n+        if (count_trailing_zeros(andconi) >= l) {\n+          if (-andconi == d) {\n+            \/\/ Remove AND if it clears bits which will be shifted\n@@ -131,0 +131,1 @@\n+          }\n@@ -136,2 +137,0 @@\n-    \/\/ Add rounding to the shift to handle the sign bit\n-    int l = log2i_graceful(d - 1) + 1;\n@@ -147,1 +146,1 @@\n-      Node *sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n+      Node* sign = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n@@ -149,1 +148,1 @@\n-      Node *round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n+      Node* round = phase->transform(new URShiftINode(sign, phase->intcon(N - l)));\n@@ -155,2 +154,1 @@\n-    q = new RShiftINode(dividend, phase->intcon(l));\n-\n+    Node* q = new RShiftINode(dividend, phase->intcon(l));\n@@ -160,0 +158,19 @@\n+\n+    return q;\n+  }\n+\n+  juint magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<juint>(d, min_neg, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+  assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+\n+  \/\/ x is an i32 and c is a u32, the value of x * c will always lie in the range\n+  \/\/ of an i64, so we can just perform the calculation directly.\n+  Node* addend0;\n+  if (jint_mul_no_ovf(dti->_lo, dti->_hi, magic_const)) {\n+    \/\/ If x * c can fit into an i32, we do int multiplication, this may help\n+    \/\/ auto vectorization\n+    Node* magic = phase->intcon(magic_const);\n+    Node* mul = phase->transform(new MulINode(dividend, magic));\n+    addend0 = phase->transform(new RShiftINode(mul, phase->intcon(shift_const)));\n@@ -161,32 +178,6 @@\n-    \/\/ Attempt the jint constant divide -> multiply transform found in\n-    \/\/   \"Division by Invariant Integers using Multiplication\"\n-    \/\/     by Granlund and Montgomery\n-    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n-\n-    jint magic_const;\n-    jint shift_const;\n-    if (magic_int_divide_constants(d, magic_const, shift_const)) {\n-      Node *magic = phase->longcon(magic_const);\n-      Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n-\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n-\n-      if (magic_const < 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-\n-        \/\/ The magic multiplier is too large for a 32 bit constant. We've adjusted\n-        \/\/ it down by 2^32, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddINode(dividend, mul_hi));\n-\n-        \/\/ Shift over the (adjusted) mulhi\n-        if (shift_const != 0) {\n-          mul_hi = phase->transform(new RShiftINode(mul_hi, phase->intcon(shift_const)));\n-        }\n-      } else {\n-        \/\/ No add is required, we can merge the shifts together.\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-      }\n+    Node* magic = phase->longcon(magic_const);\n+    Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    Node* mul = phase->transform(new MulLNode(dividend_long, magic));\n+    addend0 = phase->transform(new RShiftLNode(mul, phase->intcon(shift_const)));\n+    addend0 = phase->transform(new ConvL2INode(addend0));\n+  }\n@@ -194,3 +185,2 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+  \/\/ q = (x * c) >> s + (x < 0 ? 1 : 0) = (x * c) >> s - (x >> (W - 1))\n+  Node* addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N - 1)));\n@@ -198,5 +188,7 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n-      }\n+  \/\/ If the divisor is negative, swap the order of the input addends;\n+  \/\/ this has the effect of negating the quotient\n+  if (!d_pos) {\n+    swap(addend0, addend1);\n+  }\n+  return new SubINode(addend0, addend1);\n+}\n@@ -204,4 +196,9 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubINode(addend0, addend1);\n-    }\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+static Node* transform_int_udivide(PhaseGVN* phase, Node* dividend, juint divisor) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  constexpr int N = 32;\n+  const TypeInt* i1 = phase->type(dividend)->is_int();\n+  juint max_pos = max_unsigned_from_signed_bounds<juint>(i1->_lo, i1->_hi);\n+\n+  if (max_pos < divisor) {\n+    return new ConINode(TypeInt::ZERO);\n@@ -210,2 +207,5 @@\n-  return q;\n-}\n+  \/\/ Result\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    return new URShiftINode(dividend, phase->intcon(l));\n+  }\n@@ -213,34 +213,22 @@\n-\/\/---------------------magic_long_divide_constants-----------------------------\n-\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n-\/\/\n-\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n-\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n-static bool magic_long_divide_constants(jlong d, jlong &M, jint &s) {\n-  int64_t p;\n-  uint64_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint64_t two63 = UCONST64(0x8000000000000000);     \/\/ 2**63.\n-\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two63 + ((uint64_t)d >> 63);\n-  anc = t - 1 - t%ad;     \/\/ Absolute value of nc.\n-  p = 63;                 \/\/ Init. p.\n-  q1 = two63\/anc;         \/\/ Init. q1 = 2**p\/|nc|.\n-  r1 = two63 - q1*anc;    \/\/ Init. r1 = rem(2**p, |nc|).\n-  q2 = two63\/ad;          \/\/ Init. q2 = 2**p\/|d|.\n-  r2 = two63 - q2*ad;     \/\/ Init. r2 = rem(2**p, |d|).\n-  do {\n-    p = p + 1;\n-    q1 = 2*q1;            \/\/ Update q1 = 2**p\/|nc|.\n-    r1 = 2*r1;            \/\/ Update r1 = rem(2**p, |nc|).\n-    if (r1 >= anc) {      \/\/ (Must be an unsigned\n-      q1 = q1 + 1;        \/\/ comparison here).\n-      r1 = r1 - anc;\n-    }\n-    q2 = 2*q2;            \/\/ Update q2 = 2**p\/|d|.\n-    r2 = 2*r2;            \/\/ Update r2 = rem(2**p, |d|).\n-    if (r2 >= ad) {       \/\/ (Must be an unsigned\n-      q2 = q2 + 1;        \/\/ comparison here).\n-      r2 = r2 - ad;\n+  juint magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<juint>(divisor, 0, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+\n+  if (!magic_const_ovf && juint_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ If x * c can fit into a u32, use int multiplication\n+    Node* mul = phase->transform(new MulINode(dividend, phase->intcon(magic_const)));\n+    return new URShiftINode(mul, phase->intcon(shift_const));\n+  }\n+\n+  julong magic_const_long = julong(magic_const) + (magic_const_ovf ? julong(max_juint) + 1 : 0);\n+  \/\/ Unsigned extension of dividend\n+  Node* dividend_long = phase->transform(new ConvI2LNode(dividend));\n+  dividend_long = phase->transform(new AndLNode(dividend_long, phase->longcon(max_juint)));\n+\n+  if (julong_mul_no_ovf(julong(max_pos), magic_const_long)) {\n+    \/\/ If x * c can fit into a u64, use long multiplication\n+\n+    \/\/ Java shifts are modular so we need this special case\n+    if (shift_const == N * 2) {\n+      return new ConINode(TypeInt::ZERO);\n@@ -248,2 +236,0 @@\n-    delta = ad - r2;\n-  } while (q1 < delta || (q1 == delta && r1 == 0));\n@@ -251,3 +237,10 @@\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n-  s = p - 64;             \/\/ shift amount to return.\n+    \/\/ q = (x * c) >> s\n+    Node* mul = phase->transform(new MulLNode(dividend_long, phase->longcon(magic_const_long)));\n+    Node* q = phase->transform(new URShiftLNode(mul, phase->intcon(shift_const)));\n+    return new ConvL2INode(q);\n+  }\n+\n+  \/\/ Original plan fails, rounding up of 1\/divisor does not work, change\n+  \/\/ to rounding down, now it is guaranteed to be correct, according to\n+  \/\/ N-Bit Unsigned Division Via N-Bit Multiply-Add by Arch D. Robison\n+  magic_divide_constants_round_down(divisor, magic_const, shift_const);\n@@ -255,1 +248,5 @@\n-  return true;\n+  \/\/ q = ((x + 1) * c) >> s, use long arithmetic\n+  Node* mul = phase->transform(new AddLNode(dividend_long, phase->longcon(1)));\n+  mul = phase->transform(new MulLNode(mul, phase->longcon(magic_const)));\n+  Node* q = phase->transform(new URShiftLNode(mul, phase->intcon(shift_const)));\n+  return new ConvL2INode(q);\n@@ -258,1 +255,0 @@\n-\/\/---------------------long_by_long_mulhi--------------------------------------\n@@ -334,2 +330,0 @@\n-\n-\/\/--------------------------transform_long_divide------------------------------\n@@ -338,1 +332,1 @@\n-static Node *transform_long_divide( PhaseGVN *phase, Node *dividend, jlong divisor ) {\n+static Node* transform_long_divide(PhaseGVN* phase, Node* dividend, jlong divisor) {\n@@ -340,2 +334,5 @@\n-  assert( divisor != 0L && divisor != min_jlong,\n-          \"bad divisor for transforming to long multiply\" );\n+  assert(divisor != 0L && divisor != 1L,\n+         \"bad divisor for transforming to long multiply\");\n+  if (divisor == -1L) {\n+    return new SubLNode(phase->longcon(0), dividend);\n+  }\n@@ -344,13 +341,8 @@\n-  jlong d = d_pos ? divisor : -divisor;\n-  const int N = 64;\n-\n-  \/\/ Result\n-  Node *q = nullptr;\n-\n-  if (d == 1) {\n-    \/\/ division by +\/- 1\n-    if (!d_pos) {\n-      \/\/ Just negate the value\n-      q = new SubLNode(phase->longcon(0), dividend);\n-    }\n-  } else if ( is_power_of_2(d) ) {\n+  julong d = ABS<jlong>(divisor);\n+  constexpr int N = 64;\n+  const TypeLong* dtl = phase->type(dividend)->is_long();\n+  julong min_neg = dtl->_lo < 0 ? -julong(dtl->_lo) : 0;\n+  julong max_pos = dtl->_hi > 0 ? julong(dtl->_hi) : 0;\n+  if (min_neg < d && max_pos < d) {\n+    return new ConLNode(TypeLong::ZERO);\n+  }\n@@ -358,0 +350,1 @@\n+  if (is_power_of_2(d)) {\n@@ -359,0 +352,1 @@\n+    juint l = log2i_exact(d);\n@@ -362,4 +356,1 @@\n-    const Type *dt = phase->type(dividend);\n-    const TypeLong *dtl = dt->isa_long();\n-\n-    if (dtl && dtl->_lo > 0) {\n+    if (dtl->_lo > 0) {\n@@ -368,1 +359,1 @@\n-    } else if( dividend->Opcode() == Op_AndL ) {\n+    } else if (dividend->Opcode() == Op_AndL) {\n@@ -371,5 +362,6 @@\n-      const TypeLong *andconl_t = phase->type( dividend->in(2) )->isa_long();\n-      if( andconl_t && andconl_t->is_con() ) {\n-        jlong andconl = andconl_t->get_con();\n-        if( andconl < 0 && is_power_of_2(-andconl) && (-andconl) >= d ) {\n-          if( (-andconl) == d ) \/\/ Remove AND if it clears bits which will be shifted\n+      const TypeLong* andconl_t = phase->type(dividend->in(2))->isa_long();\n+      if (andconl_t && andconl_t->is_con()) {\n+        julong andconl = andconl_t->get_con();\n+        if (count_trailing_zeros(andconl) >= l) {\n+          if (-andconl == d) {\n+            \/\/ Remove AND if it clears bits which will be shifted\n@@ -377,0 +369,1 @@\n+          }\n@@ -382,2 +375,0 @@\n-    \/\/ Add rounding to the shift to handle the sign bit\n-    int l = log2i_graceful(d - 1) + 1;\n@@ -393,1 +384,1 @@\n-      Node *sign = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n+      Node* sign = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n@@ -395,1 +386,1 @@\n-      Node *round = phase->transform(new URShiftLNode(sign, phase->intcon(N - l)));\n+      Node* round = phase->transform(new URShiftLNode(sign, phase->intcon(N - l)));\n@@ -401,2 +392,1 @@\n-    q = new RShiftLNode(dividend, phase->intcon(l));\n-\n+    Node* q = new RShiftLNode(dividend, phase->intcon(l));\n@@ -406,20 +396,2 @@\n-  } else if ( !Matcher::use_asm_for_ldiv_by_con(d) ) { \/\/ Use hardware DIV instruction when\n-                                                       \/\/ it is faster than code generated below.\n-    \/\/ Attempt the jlong constant divide -> multiply transform found in\n-    \/\/   \"Division by Invariant Integers using Multiplication\"\n-    \/\/     by Granlund and Montgomery\n-    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n-\n-    jlong magic_const;\n-    jint shift_const;\n-    if (magic_long_divide_constants(d, magic_const, shift_const)) {\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n-\n-      \/\/ The high half of the 128-bit multiply is computed.\n-      if (magic_const < 0) {\n-        \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n-        \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n-      }\n+    return q;\n+  }\n@@ -427,4 +399,5 @@\n-      \/\/ Shift over the (adjusted) mulhi\n-      if (shift_const != 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n-      }\n+  if (Matcher::use_asm_for_ldiv_by_con(divisor)) {\n+    \/\/ Use hardware DIV instruction when\n+    \/\/ it is faster than code generated below.\n+    return nullptr;\n+  }\n@@ -432,3 +405,18 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n+  julong magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<julong>(d, min_neg, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+  assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+\n+  Node* addend0;\n+  if (jlong_mul_no_ovf(dtl->_lo, dtl->_hi, magic_const)) {\n+    \/\/ If c * m can fit into an i64, do the multiplication directly\n+    Node* mul = phase->transform(new MulLNode(dividend, phase->longcon(magic_const)));\n+    addend0 = phase->transform(new RShiftLNode(mul, phase->intcon(shift_const)));\n+  } else {\n+    if (shift_const < N) {\n+      \/\/ We need i128 arithmetic here, if s < 64 we need to combine the high and low half of the full\n+      \/\/ product, force s to be >= 64 so we only need to use the high half\n+      magic_divide_constants<julong>(d, min_neg, max_pos, N, magic_const, magic_const_ovf, shift_const);\n+      assert(!magic_const_ovf, \"signed magic constant cannot overflow\");\n+    }\n@@ -436,5 +424,12 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n-      }\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    \/\/ (x * c) >> s = ((x * c) >> 64) >> (s - 64) = mul_hi(x, c) >> (s - 64)\n+    Node* mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n+    if (jlong(magic_const) < 0) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n+    }\n+\n+    \/\/ Shift over the (adjusted) mulhi\n+    addend0 = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const - N)));\n+  }\n@@ -442,3 +437,61 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubLNode(addend0, addend1);\n+  \/\/ q = mul_hi(x, c) >> (s - 64) + (x < 0 ? 1 : 0) = mul_hi(x, c) >> (x - 64) - (x >> 63)\n+  Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N - 1)));\n+\n+  \/\/ If the divisor is negative, swap the order of the input addends;\n+  \/\/ this has the effect of negating the quotient.\n+  if (!d_pos) {\n+    swap(addend0, addend1);\n+  }\n+  return new SubLNode(addend0, addend1);\n+}\n+\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return null if no transformation occurs.\n+static Node* transform_long_udivide(PhaseGVN* phase, Node* dividend, julong divisor) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  constexpr int N = 64;\n+  const TypeLong* i1 = phase->type(dividend)->is_long();\n+  julong max_pos = max_unsigned_from_signed_bounds<julong>(i1->_lo, i1->_hi);\n+\n+  if (max_pos < divisor) {\n+    return new ConLNode(TypeLong::ZERO);\n+  }\n+\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    return new URShiftLNode(dividend, phase->intcon(l));\n+  }\n+\n+  if (!Matcher::match_rule_supported(Op_UMulHiL)) {\n+    return nullptr; \/\/ Don't bother\n+  }\n+\n+  julong magic_const;\n+  bool magic_const_ovf;\n+  juint shift_const;\n+  magic_divide_constants<julong>(divisor, 0, max_pos, 0, magic_const, magic_const_ovf, shift_const);\n+\n+  if (!magic_const_ovf && julong_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ If x * c can fit into a u64, use long arithmetic\n+    Node* mul = phase->transform(new MulLNode(dividend, phase->longcon(magic_const)));\n+    return new URShiftLNode(mul, phase->intcon(shift_const));\n+  }\n+\n+  if (shift_const < N) {\n+    \/\/ We need i128 arithmetic here, if s < 64 we need to combine the high and low half of the full\n+    \/\/ product, force s to be >= 64 so we only need to use the high half\n+    magic_divide_constants<julong>(divisor, 0, max_pos, N, magic_const, magic_const_ovf, shift_const);\n+  }\n+\n+  if (!magic_const_ovf || uint128_t_mul_no_ovf(max_pos, magic_const)) {\n+    \/\/ Java shifts are modular so we need this special case\n+    if (shift_const == N * 2) {\n+      return new ConLNode(TypeLong::ZERO);\n+    }\n+\n+    \/\/ q = (x * c) >> s = ((x * c) >> 64) >> (s - 64) = umul_hi(x, c) >> (s - 64)\n+    Node* mul_hi = phase->transform(new UMulHiLNode(dividend, phase->longcon(magic_const)));\n+    if (magic_const_ovf) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n@@ -446,0 +499,1 @@\n+    return new URShiftLNode(mul_hi, phase->intcon(shift_const - N));\n@@ -448,1 +502,52 @@\n-  return q;\n+  if ((divisor & 1) == 0) {\n+    \/\/ x \/ (2 * d) = (x \/ 2) \/ d. This helps decrease the upper bound of the dividend,\n+    \/\/ guarantee that the product of the new dividend and the new magic constant does not\n+    \/\/ overflow\n+    juint ctz = count_trailing_zeros(divisor);\n+    dividend = phase->transform(new URShiftLNode(dividend, phase->intcon(ctz)));\n+    return new UDivLNode(nullptr, dividend, phase->longcon(divisor >> ctz));\n+  }\n+\n+  \/\/ q = floor((x * c) \/ 2**(s + 64))) = floor(((x * (c - 2**64)) \/ 2**64 + x) \/ 2**s)\n+  \/\/\n+  \/\/ Given: floor((x \/ s + y) \/ n) = floor((floor(x \/ s) + y) \/ n), we have\n+  \/\/ q = floor((floor((x * (c - 2**64)) \/ 2**64) + x) \/ 2**s)\n+  \/\/   = floor((mul_hi + x) \/ 2**s)\n+  \/\/ Let p = floor((mul_hi + x) \/ 2)\n+  \/\/       = floor((x - mul_hi) \/ 2 + mul_hi)\n+  \/\/       = floor((x - mul_hi) \/ 2) + mul_hi\n+  \/\/ Since x > mul_hi, this operation can be done precisely using Z\/2**64Z arithmetic\n+  Node* mul_hi = phase->transform(new UMulHiLNode(dividend, phase->longcon(magic_const)));\n+  Node* diff = phase->transform(new SubLNode(dividend, mul_hi));\n+  diff = phase->transform(new URShiftLNode(diff, phase->intcon(1)));\n+  Node* p = phase->transform(new AddLNode(diff, mul_hi));\n+  return new URShiftLNode(p, phase->intcon(shift_const - N - 1));\n+}\n+\n+static Node* divModIdealCommon(Node* n, BasicType bt, PhaseGVN* phase, bool need_const_divisor) {\n+  \/\/ Don't bother trying to transform a dead node\n+  if (n->in(0) != nullptr && n->in(0)->is_top()) {\n+    return nullptr;\n+  }\n+  const Type* t2 = phase->type(n->in(2));\n+  if (phase->type(n->in(1)) == Type::TOP || t2 == Type::TOP) {\n+    return nullptr;\n+  }\n+\n+  const TypeInteger* i2 = t2->is_integer(bt);\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (n->in(0) != nullptr && (i2->lo_as_long() > 0L || i2->hi_as_long() < 0L)) {\n+    n->set_req(0, nullptr);\n+    return n;\n+  }\n+\n+  if (i2->is_con()) {\n+    jlong i2_con = i2->get_con_as_long(bt);\n+    if (i2_con == 0) {\n+      return nullptr;\n+    }\n+    return NodeSentinel;\n+  }\n+\n+  return need_const_divisor ? nullptr : NodeSentinel;\n@@ -460,16 +565,2 @@\n-Node *DivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  const Type *t = phase->type( in(2) );\n-  if( t == TypeInt::ONE )      \/\/ Identity?\n-    return nullptr;            \/\/ Skip it\n-\n-  const TypeInt *ti = t->isa_int();\n-  if( !ti ) return nullptr;\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding div-zero case\n-  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n-    set_req(0, nullptr);           \/\/ Yank control input\n+Node* DivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -479,2 +570,4 @@\n-  if( !ti->is_con() ) return nullptr;\n-  jint i = ti->get_con();       \/\/ Get divisor\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -482,1 +575,1 @@\n-  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  jint i2_con = phase->type(in(2))->is_int()->get_con();\n@@ -484,2 +577,3 @@\n-  \/\/ Dividing by MININT does not optimize as a power-of-2 shift.\n-  if( i == min_jint ) return nullptr;\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n@@ -487,1 +581,3 @@\n-  return transform_int_divide( phase, in(1), i );\n+  q = transform_int_divide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  return q;\n@@ -566,16 +662,2 @@\n-Node *DivLNode::Ideal( PhaseGVN *phase, bool can_reshape) {\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  const Type *t = phase->type( in(2) );\n-  if( t == TypeLong::ONE )      \/\/ Identity?\n-    return nullptr;             \/\/ Skip it\n-\n-  const TypeLong *tl = t->isa_long();\n-  if( !tl ) return nullptr;\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding div-zero case\n-  if (in(0) && (tl->_hi < 0 || tl->_lo > 0)) {\n-    set_req(0, nullptr);         \/\/ Yank control input\n+Node* DivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -585,2 +667,4 @@\n-  if( !tl->is_con() ) return nullptr;\n-  jlong l = tl->get_con();      \/\/ Get divisor\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -588,1 +672,1 @@\n-  if (l == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+  jlong i2_con = phase->type(in(2))->is_long()->get_con();\n@@ -590,2 +674,3 @@\n-  \/\/ Dividing by MINLONG does not optimize as a power-of-2 shift.\n-  if( l == min_jlong ) return nullptr;\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n@@ -593,1 +678,3 @@\n-  return transform_long_divide( phase, in(1), l );\n+  q = transform_long_divide(phase, in(1), i2_con);\n+  assert(q != nullptr || Matcher::use_asm_for_ldiv_by_con(i2_con), \"sanity\");\n+  return q;\n@@ -662,0 +749,126 @@\n+Node* UDivINode::Identity(PhaseGVN* phase) {\n+  return (phase->type(in(2))->higher_equal(TypeInt::ONE)) ? in(1) : this;\n+}\n+\n+Node* UDivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_INT, phase, false);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  const TypeInt* i2 = phase->type(in(2))->is_int();\n+  \/\/ Divisor very large, constant 2**31 can be transform to a shift\n+  if (i2->_hi <= 0 && i2->_hi > min_jint) {\n+    Node* cmp = phase->transform(new CmpUNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveINode(bol, phase->intcon(0), phase->intcon(1), TypeInt::BOOL);\n+  }\n+\n+  if (!i2->is_con()) {\n+    return nullptr;\n+  }\n+  juint i2_con = i2->get_con();\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n+  if (phase->type(in(1))->is_int()->is_con()) {\n+    \/\/ Don't transform a constant-foldable\n+    return nullptr;\n+  }\n+\n+  q = transform_int_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  return q;\n+}\n+\n+const Type* UDivINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeInt::ONE;\n+  }\n+\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) \/ juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+Node* UDivLNode::Identity(PhaseGVN* phase) {\n+  return (phase->type(in(2))->higher_equal(TypeLong::ONE)) ? in(1) : this;\n+}\n+\n+Node* UDivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_LONG, phase, false);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  const TypeLong* i2 = phase->type(in(2))->is_long();\n+  \/\/ Divisor very large, constant 2**63 can be transform to a shift\n+  if (i2->_hi <= 0 && i2->_hi > min_jlong) {\n+    Node* cmp = phase->transform(new CmpULNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveLNode(bol, phase->longcon(0), phase->longcon(1), TypeLong::make(0, 1, Type::WidenMin));\n+  }\n+\n+  if (!i2->is_con()) {\n+    return nullptr;\n+  }\n+  julong i2_con = i2->get_con();\n+  if (i2_con == 1) {\n+    return nullptr;\n+  }\n+  if (phase->type(in(1))->is_long()->is_con()) {\n+    \/\/ Don't transform a constant-foldable\n+    return nullptr;\n+  }\n+\n+  q = transform_long_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr || !Matcher::match_rule_supported(Op_UMulHiL), \"sanity\");\n+  return q;\n+}\n+\n+const Type* UDivLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeLong::ONE;\n+  }\n+\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) \/ julong(i2->get_con()));\n+  }\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeLong::LONG;\n+}\n@@ -844,72 +1057,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If the divisor is 1, we are an identity on the dividend.\n-Node* UDivINode::Identity(PhaseGVN* phase) {\n-  return (phase->type( in(2) )->higher_equal(TypeInt::ONE)) ? in(1) : this;\n-}\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A UDivINode divides its inputs.  The third input is a Control input, used to\n-\/\/ prevent hoisting the divide above an unsafe test.\n-const Type* UDivINode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n-  if (in(1) == in(2)) {\n-    return TypeInt::ONE;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeInt::INT;\n-}\n-\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n-}\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If the divisor is 1, we are an identity on the dividend.\n-Node* UDivLNode::Identity(PhaseGVN* phase) {\n-  return (phase->type( in(2) )->higher_equal(TypeLong::ONE)) ? in(1) : this;\n-}\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A UDivLNode divides its inputs.  The third input is a Control input, used to\n-\/\/ prevent hoisting the divide above an unsafe test.\n-const Type* UDivLNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n-  if (in(1) == in(2)) {\n-    return TypeLong::ONE;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeLong::LONG;\n-}\n-\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -917,22 +1059,1 @@\n-  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n-  return nullptr;\n-}\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *ModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  \/\/ Get the modulus\n-  const Type *t = phase->type( in(2) );\n-  if( t == Type::TOP ) return nullptr;\n-  const TypeInt *ti = t->is_int();\n-\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding mod-zero case\n-  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n-    set_req(0, nullptr);        \/\/ Yank control input\n+  if(in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n@@ -942,3 +1063,4 @@\n-  \/\/ See if we are MOD'ing by 2^k or 2^k-1.\n-  if( !ti->is_con() ) return nullptr;\n-  jint con = ti->get_con();\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n@@ -946,0 +1068,1 @@\n+  jint con = phase->type(in(2))->is_int()->get_con();\n@@ -947,1 +1070,0 @@\n-\n@@ -1086,8 +1208,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n@@ -1099,7 +1213,0 @@\n-  \/\/ Don't bother trying to transform a dead node\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n-\n-  \/\/ Get the modulus\n-  const Type *t = phase->type( in(2) );\n-  if( t == Type::TOP ) return nullptr;\n-  const TypeLong *tl = t->is_long();\n@@ -1107,5 +1214,3 @@\n-  \/\/ Check for useless control input\n-  \/\/ Check for excluding mod-zero case\n-  if (in(0) && (tl->_hi < 0 || tl->_lo > 0)) {\n-    set_req(0, nullptr);        \/\/ Yank control input\n-    return this;\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n@@ -1114,4 +1219,1 @@\n-  \/\/ See if we are MOD'ing by 2^k or 2^k-1.\n-  if( !tl->is_con() ) return nullptr;\n-  jlong con = tl->get_con();\n-\n+  jlong con = phase->type(in(2))->is_long()->get_con();\n@@ -1119,1 +1221,0 @@\n-\n@@ -1260,0 +1361,104 @@\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  Node* q = divModIdealCommon(this, T_INT, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  if (phase->type(in(1))->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  juint i2_con = phase->type(in(2))->is_int()->get_con();\n+  if (is_power_of_2(i2_con)) {\n+    return new AndINode(in(1), phase->intcon(i2_con - 1));\n+  }\n+\n+  \/\/ TODO: This can be calculated directly, see https:\/\/arxiv.org\/abs\/1902.01961\n+  q = transform_int_udivide(phase, in(1), i2_con);\n+  assert(q != nullptr, \"sanity\");\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulINode(q, phase->intcon(i2_con)));\n+  return new SubINode(in(1), mul);\n+}\n+\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeInt::ONE) {\n+    return TypeInt::ZERO;\n+  }\n+\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) % juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+Node* UModLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  Node* q = divModIdealCommon(this, T_LONG, phase, true);\n+  if (q != NodeSentinel) {\n+    return q;\n+  }\n+\n+  if (phase->type(in(1))->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  julong i2_con = phase->type(in(2))->is_long()->get_con();\n+  if (is_power_of_2(i2_con)) {\n+    return new AndLNode(in(1), phase->longcon(i2_con - 1));\n+  }\n+\n+  q = transform_long_udivide(phase, in(1), i2_con);\n+  if (q == nullptr) {\n+    assert(!Matcher::match_rule_supported(Op_UMulHiL), \"sanity\");\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulLNode(q, phase->longcon(i2_con)));\n+  return new SubLNode(in(1), mul);\n+}\n+\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeLong::ONE) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) % julong(i2->get_con()));\n+  }\n+\n+  return TypeLong::LONG;\n+}\n@@ -1304,9 +1509,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return nullptr;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":607,"deletions":411,"binary":false,"changes":1018,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModINode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -171,2 +171,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -180,1 +181,1 @@\n-  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModLNode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -182,2 +183,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/javaArithmetic.hpp\"\n@@ -306,10 +307,0 @@\n-const jlong min_jlong = CONST64(0x8000000000000000);\n-const jlong max_jlong = CONST64(0x7fffffffffffffff);\n-\n-\/\/-------------------------------------------\n-\/\/ Constant for jdouble\n-const jlong min_jlongDouble = CONST64(0x0000000000000001);\n-const jdouble min_jdouble = jdouble_cast(min_jlongDouble);\n-const jlong max_jlongDouble = CONST64(0x7fefffffffffffff);\n-const jdouble max_jdouble = jdouble_cast(max_jlongDouble);\n-\n@@ -441,2 +432,0 @@\n-typedef unsigned int uint;   NEEDS_CLEANUP\n-\n@@ -509,7 +498,0 @@\n-\/\/ Additional Java basic types\n-\n-typedef uint8_t  jubyte;\n-typedef uint16_t jushort;\n-typedef uint32_t juint;\n-typedef uint64_t julong;\n-\n@@ -526,5 +508,0 @@\n-const jubyte  max_jubyte  = (jubyte)-1;  \/\/ 0xFF       largest jubyte\n-const jushort max_jushort = (jushort)-1; \/\/ 0xFFFF     largest jushort\n-const juint   max_juint   = (juint)-1;   \/\/ 0xFFFFFFFF largest juint\n-const julong  max_julong  = (julong)-1;  \/\/ 0xFF....FF largest julong\n-\n@@ -536,13 +513,0 @@\n-const jbyte min_jbyte = -(1 << 7);       \/\/ smallest jbyte\n-const jbyte max_jbyte = (1 << 7) - 1;    \/\/ largest jbyte\n-const jshort min_jshort = -(1 << 15);    \/\/ smallest jshort\n-const jshort max_jshort = (1 << 15) - 1; \/\/ largest jshort\n-\n-const jint min_jint = (jint)1 << (sizeof(jint)*BitsPerByte-1); \/\/ 0x80000000 == smallest jint\n-const jint max_jint = (juint)min_jint - 1;                     \/\/ 0x7FFFFFFF == largest jint\n-\n-const jint min_jintFloat = (jint)(0x00000001);\n-const jfloat min_jfloat = jfloat_cast(min_jintFloat);\n-const jint max_jintFloat = (jint)(0x7f7fffff);\n-const jfloat max_jfloat = jfloat_cast(max_jintFloat);\n-\n@@ -1105,1 +1069,4 @@\n-template<class T> inline T ABS(T x)                 { return (x > 0) ? x : -x; }\n+template<class T> constexpr inline T ABS(T x) {\n+  using U = std::make_unsigned_t<T>;\n+  return (x >= 0) ? x : U(0) - U(x);\n+}\n@@ -1172,125 +1139,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Sum and product which can never overflow: they wrap, just like the\n-\/\/ Java operations.  Note that we don't intend these to be used for\n-\/\/ general-purpose arithmetic: their purpose is to emulate Java\n-\/\/ operations.\n-\n-\/\/ The goal of this code to avoid undefined or implementation-defined\n-\/\/ behavior.  The use of an lvalue to reference cast is explicitly\n-\/\/ permitted by Lvalues and rvalues [basic.lval].  [Section 3.10 Para\n-\/\/ 15 in C++03]\n-#define JAVA_INTEGER_OP(OP, NAME, TYPE, UNSIGNED_TYPE)  \\\n-inline TYPE NAME (TYPE in1, TYPE in2) {                 \\\n-  UNSIGNED_TYPE ures = static_cast<UNSIGNED_TYPE>(in1); \\\n-  ures OP ## = static_cast<UNSIGNED_TYPE>(in2);         \\\n-  return reinterpret_cast<TYPE&>(ures);                 \\\n-}\n-\n-JAVA_INTEGER_OP(+, java_add, jint, juint)\n-JAVA_INTEGER_OP(-, java_subtract, jint, juint)\n-JAVA_INTEGER_OP(*, java_multiply, jint, juint)\n-JAVA_INTEGER_OP(+, java_add, jlong, julong)\n-JAVA_INTEGER_OP(-, java_subtract, jlong, julong)\n-JAVA_INTEGER_OP(*, java_multiply, jlong, julong)\n-\n-inline jint  java_negate(jint  v) { return java_subtract((jint) 0, v); }\n-inline jlong java_negate(jlong v) { return java_subtract((jlong)0, v); }\n-\n-#undef JAVA_INTEGER_OP\n-\n-\/\/ Provide integer shift operations with Java semantics.  No overflow\n-\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n-\/\/ behavior for large or negative shift quantities; instead the actual\n-\/\/ shift distance is the argument modulo the lhs value's size in bits.\n-\/\/ No undefined or implementation defined behavior for shifting negative\n-\/\/ values; left shift discards bits, right shift sign extends.  We use\n-\/\/ the same safe conversion technique as above for java_add and friends.\n-#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)    \\\n-inline TYPE NAME (TYPE lhs, jint rhs) {                 \\\n-  const uint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n-  STATIC_ASSERT(rhs_mask == 31 || rhs_mask == 63);      \\\n-  XTYPE xres = static_cast<XTYPE>(lhs);                 \\\n-  xres OP ## = (rhs & rhs_mask);                        \\\n-  return reinterpret_cast<TYPE&>(xres);                 \\\n-}\n-\n-JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n-JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n-\n-\/\/ For signed shift right, assume C++ implementation >> sign extends.\n-\/\/\n-\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n-\/\/ and a negative value, the resulting value is implementation-defined.\"\n-\/\/\n-\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n-\/\/ requiring two's-complement behavior.\n-\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n-\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n-\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n-\/\/ arithmetic right shift, which performs sign-extension.\"\n-\/\/\n-\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n-\/\/ already behave that way. And it is unlikely any would go off and do something\n-\/\/ different now, with C++20 tightening things up.\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n-\/\/ For >>> use C++ unsigned >>.\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n-JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n-\n-#undef JAVA_INTEGER_SHIFT_OP\n-\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ The goal of this code is to provide saturating operations for int\/uint.\n-\/\/ Checks overflow conditions and saturates the result to min_jint\/max_jint.\n-#define SATURATED_INTEGER_OP(OP, NAME, TYPE1, TYPE2) \\\n-inline int NAME (TYPE1 in1, TYPE2 in2) {             \\\n-  jlong res = static_cast<jlong>(in1);               \\\n-  res OP ## = static_cast<jlong>(in2);               \\\n-  if (res > max_jint) {                              \\\n-    res = max_jint;                                  \\\n-  } else if (res < min_jint) {                       \\\n-    res = min_jint;                                  \\\n-  }                                                  \\\n-  return static_cast<int>(res);                      \\\n-}\n-\n-SATURATED_INTEGER_OP(+, saturated_add, int, int)\n-SATURATED_INTEGER_OP(+, saturated_add, int, uint)\n-SATURATED_INTEGER_OP(+, saturated_add, uint, int)\n-SATURATED_INTEGER_OP(+, saturated_add, uint, uint)\n-\n-#undef SATURATED_INTEGER_OP\n-\n-\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n-inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n-  const uint64_t x1 = x >> 32u;\n-  const uint64_t x2 = x & 0xFFFFFFFF;\n-  const uint64_t y1 = y >> 32u;\n-  const uint64_t y2 = y & 0xFFFFFFFF;\n-  const uint64_t z2 = x2 * y2;\n-  const uint64_t t = x1 * y2 + (z2 >> 32u);\n-  uint64_t z1 = t & 0xFFFFFFFF;\n-  const uint64_t z0 = t >> 32u;\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + (z1 >> 32u);\n-}\n-\n-\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n-\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n-inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n-  const jlong x1 = java_shift_right((jlong)x, 32);\n-  const jlong x2 = x & 0xFFFFFFFF;\n-  const jlong y1 = java_shift_right((jlong)y, 32);\n-  const jlong y2 = y & 0xFFFFFFFF;\n-\n-  const uint64_t z2 = (uint64_t)x2 * y2;\n-  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n-  int64_t z1 = t & 0xFFFFFFFF;\n-  const int64_t z0 = java_shift_right((jlong)t, 32);\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":163,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include <limits>\n+#include <type_traits>\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+\/*\n+Compute magic multiplier and shift constant for converting a 32\/64 bit\n+division by constant into a multiply\/shift series.\n+\n+(1) Theory:\n+Motivated by Henry S. Warren. 2012. Hacker's Delight (2nd. ed.). Addison-Wesley Professional.\n+\n+Given positive integers d <= N, call v the largest integer not larger than\n+N such that v + 1 is divisible by d.\n+\n+(a) For positive values c, m such that:\n+\n+m <= c * d < m + m \/ v\n+\n+We have:\n+\n+floor(x \/ d) = floor(x * c \/ m) for every integer x in [0, N]\n+\n+(b) For positive values c, m such that:\n+\n+m < c * d <= m + m \/ v\n+\n+We have:\n+\n+ceil(x \/ d) = floor(x * c \/ m) + 1 for every integer x in [-N, 0)\n+\n+(2) Proof:\n+\n+(a) The conclusion is trivial for x = 0\n+\n+For 0 < x <= v\n+\n+Since 1 \/ d <= c \/ m < (1 \/ d) * ((v + 1) \/ v)\n+\n+We have x \/ d <= x * c \/ m < (x * ((v + 1) \/ v)) \/ d\n+\n+As a result, since x * ((v + 1) \/ v) <= x * ((x + 1) \/ x) = x + 1\n+\n+x \/ d <= x * c \/ m < (x + 1) \/ d, which implies floor(x \/ d) = floor(x * c \/ m) since\n+there can be no integer in (x \/ d, (x + 1) \/ d)\n+\n+For v + 1 <= x <= v + d - 1, since v >= d - 1, we have x <= 2v\n+As a result, x * ((v + 1) \/ v) <= x * ((x + 2) \/ x)\n+\n+floor(x \/ d) = (v + 1) \/ d\n+floor(x * ((v + 1) \/ v) \/ d) <= floor(x * ((x + 2) \/ x) \/ d) = floor((x + 2) \/ d)\n+                             <= floor((v + d - 1 + 2) \/ d) = (v + 1) \/ d + 1\n+Which means (v + 1) \/ d <= floor(x * c \/ m) < (v + 1) \/ d + 1 with (v + 1) \/ d being an integer\n+This implies floor(x \/ d) = floor(x * c \/ m) for v + 1 <= x <= v + d - 1\n+\n+Combining all the cases gives us the conclusion.\n+\n+(b) Since ceil(a \/ b) = floor((a - 1) \/ b) + 1, we need to prove:\n+\n+floor((x - 1) \/ d) = floor(x * c \/ m)\n+\n+For 0 > x >= -v\n+\n+Since 1 \/ d < c \/ m <= (1 \/ d) * ((v + 1) \/ v)\n+\n+We have x \/ d > x * c \/ m >= (x \/ d) * ((v + 1) \/ v)\n+\n+since x * ((v + 1) \/ v) >= x * ((x - 1) \/ x) = x - 1\n+x \/ d > x * c \/ m >= (x - 1) \/ d, which implies floor((x - 1) \/ d) = floor(x * c \/ m) since\n+there can be no integer in ((x - 1) \/ d, x \/ d)\n+\n+For -v - d + 1 <= x <= -v - 1, since v >= d - 1, we have x >= -2v\n+As a result, x * ((v + 1) \/ v) >= x * ((x - 2) \/ x) = x - 2\n+\n+x \/ d <= (-v - 1) \/ d\n+floor((x - 1) \/ d) = (-v - 1) \/ d - 1\n+floor(x * ((v + 1) \/ v) \/ d) >= floor((x - 2) \/ d) >= (-v - d + 1 - 2) \/ d = (-v - 1) \/ d - 1\n+which means (-v - 1) \/ d >= x \/ d > x * c \/ m >= floor(x * c \/ m) >= (-v - 1) \/ d - 1\n+This implies floor((x - 1) \/ d) = floor(x * c \/ m) for -v - 1 >= x >= -v - d + 1\n+\n+Combining all the cases gives us the conclusion.\n+\n+(3) Discussion:\n+\n+Let x be v, v - d + 1, -v, -v + d - 1, it can be seen that these bounds are indeed optimal\n+\n+(4) Implementation:\n+\n+For computation efficiency, we only consider the values m = 2**s.\n+This function does not handle the cases d being a power of 2, which means\n+that c * d is never equal to m.\n+\n+We find the value of c, m such that it satisfies the bounds for both the nonnegative\n+and negative ranges of x. This can be done by finding v_neg and v_pos and the bounds of\n+c * d - m is the intersection of (0, m \/ v_neg] and (0, m \/ v_pos). Which is (0, m \/ v_pos)\n+if v_pos >= v_neg and (0, m \/ v_neg] otherwise.\n+\n+Given v = max(v_neg, v_pos). The function inductively calculates c, rc, qv, rv such that:\n+\n+c * d - rc = 2**s with 0 < rc <= d\n+qv * v + rv = 2**s with 0 <= rv < v\n+*\/\n+template <class T>\n+void magic_divide_constants(T d, T N_neg, T N_pos, juint min_s, T& c, bool& c_ovf, juint& s) {\n+  static_assert(std::is_unsigned<T>::value, \"calculations must be done in the unsigned domain\");\n+  assert(!is_power_of_2(d), \"this case should be handled separately\");\n+  assert(d <= N_neg || d <= N_pos, \"this should just be idealized to 0\");\n+  constexpr T min_signed = std::numeric_limits<std::make_signed_t<T>>::min();\n+  T v_neg = N_neg < d - 1 ? 0 : N_neg - ((N_neg - d + 1) % d);\n+  T v_pos = N_pos < d - 1 ? 0 : N_pos - ((N_pos - d + 1) % d);\n+  T v = MAX2(v_neg, v_pos);\n+  bool tolerate_equal = v_neg > v_pos;\n+\n+  \/\/ base case, s = 0\n+  s = 0;\n+  c_ovf = false;\n+  c = 1;\n+  T rc = d - 1;\n+  bool qv_ovf = false;\n+  T qv = 0;\n+  T rv = 1;\n+\n+  while (true) {\n+    if (s >= min_s) {\n+      if (qv_ovf || rc < qv || (rc == qv && (tolerate_equal || rv > 0))) {\n+        break;\n+      }\n+    }\n+    assert(!c_ovf, \"must be\");\n+    s++;\n+\n+    T new_rc = rc * 2;\n+    if (new_rc < rc || new_rc > d) {\n+      c_ovf = c > min_signed;\n+      c = c * 2 - 1;\n+      rc = new_rc - d;\n+    } else {\n+      c_ovf = c >= min_signed;\n+      c = c * 2;\n+      rc = new_rc;\n+    }\n+\n+    T new_rv = rv * 2;\n+    if (new_rv < rv || new_rv >= v) {\n+      qv_ovf = qv >= min_signed;\n+      qv = qv * 2 + 1;\n+      rv = new_rv - v;\n+    } else {\n+      qv_ovf = qv >= min_signed;\n+      qv = qv * 2;\n+      rv = new_rv;\n+    }\n+  }\n+}\n+template void magic_divide_constants<juint>(juint, juint, juint, juint, juint&, bool&, juint&);\n+template void magic_divide_constants<julong>(julong, julong, julong, juint, julong&, bool&, juint&);\n+\n+\/\/ The constant of a W-bit signed division lies in the range of W-bit unsigned\n+\/\/ integers. As a result, the product of the dividend and the magic constant cannot\n+\/\/ overflow a 2W-bit signed integer.\n+\/\/\n+\/\/ For unsigned division however, the magic constant may lie outside the range\n+\/\/ of W-bit unsigned integers, which means the product of it and the dividend can\n+\/\/ overflow a 2W-bit unsigned integer. In those cases, we use another algorithm.\n+\/\/\n+\/\/ Given s = floor(log2(d)) + W, c = floor(2**s \/ d) we have\n+\/\/\n+\/\/ floor(x \/ d) = floor((x + 1) * c \/ 2**s) for every integer x in [0, 2**W).\n+\/\/\n+\/\/ The proof can be found at: Robison, A.D.. (2005). N-bit unsigned division via\n+\/\/ N-bit multiply-add. Proceedings - Symposium on Computer Arithmetic. 131- 139.\n+\/\/ 10.1109\/ARITH.2005.31.\n+\/\/\n+\/\/ This is called round down because we round 1 \/ d down to c \/ 2**s\n+void magic_divide_constants_round_down(juint d, juint& c, juint& s) {\n+  assert(!is_power_of_2(d), \"this case should be handled separately\");\n+  constexpr juint W = 32;\n+\n+  s = log2i_graceful(d) + W;\n+  julong t = (julong(1) << s) \/ julong(d);\n+  c = t;\n+#ifdef ASSERT\n+  julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+  assert(r > (julong(1) << (s - W)), \"Should call up first since it is more efficient\");\n+#endif\n+}\n","filename":"src\/hotspot\/share\/utilities\/javaArithmetic.cpp","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_JAVAARITHMETIC_HPP\n+#define SHARE_UTILITIES_JAVAARITHMETIC_HPP\n+\n+#include <cstdint>\n+#include <limits>\n+#include \"jni.h\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ Basic types' bounds\n+constexpr jbyte  min_jbyte  = std::numeric_limits<jbyte>::min();\n+constexpr jbyte  max_jbyte  = std::numeric_limits<jbyte>::max();\n+constexpr jshort min_jshort = std::numeric_limits<jshort>::min();\n+constexpr jshort max_jshort = std::numeric_limits<jshort>::max();\n+constexpr jint   min_jint   = std::numeric_limits<jint>::min();\n+constexpr jint   max_jint   = std::numeric_limits<jint>::max();\n+constexpr jlong  min_jlong  = std::numeric_limits<jlong>::min();\n+constexpr jlong  max_jlong  = std::numeric_limits<jlong>::max();\n+\n+constexpr jfloat  min_jfloat      = std::numeric_limits<jfloat>::min();\n+constexpr jint    min_jintFloat   = 0x00000001;\n+constexpr jfloat  max_jfloat      = std::numeric_limits<jfloat>::max();\n+constexpr jint    max_jintFloat   = 0x7f7fffff;\n+constexpr jdouble min_jdouble     = std::numeric_limits<jdouble>::min();\n+constexpr jlong   min_jlongDouble = 0x0000000000000001;\n+constexpr jdouble max_jdouble     = std::numeric_limits<jdouble>::max();\n+constexpr jlong   max_jlongDouble = 0x7fefffffffffffff;\n+\n+\/\/ Additional Java basic types\n+using jubyte  = uint8_t;\n+using jushort = uint16_t;\n+using juint   = uint32_t;\n+using julong  = uint64_t;\n+\n+constexpr jubyte  max_jubyte  = std::numeric_limits<jubyte>::max();\n+constexpr jushort max_jushort = std::numeric_limits<jushort>::max();\n+constexpr juint   max_juint   = std::numeric_limits<juint>::max();\n+constexpr julong  max_julong  = std::numeric_limits<julong>::max();\n+\n+using uint = unsigned int; NEEDS_CLEANUP\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Sum and product which can never overflow: they wrap, just like the\n+\/\/ Java operations.  Note that we don't intend these to be used for\n+\/\/ general-purpose arithmetic: their purpose is to emulate Java\n+\/\/ operations.\n+\n+\/\/ The goal of this code to avoid undefined or implementation-defined\n+\/\/ behavior.\n+#define JAVA_INTEGER_OP(OP, NAME, TYPE, UNSIGNED_TYPE)  \\\n+inline constexpr TYPE NAME (TYPE in1, TYPE in2) {       \\\n+  UNSIGNED_TYPE ures = static_cast<UNSIGNED_TYPE>(in1); \\\n+  ures OP ## = static_cast<UNSIGNED_TYPE>(in2);         \\\n+  return ures;                                          \\\n+}\n+\n+JAVA_INTEGER_OP(+, java_add, jint, juint)\n+JAVA_INTEGER_OP(-, java_subtract, jint, juint)\n+JAVA_INTEGER_OP(*, java_multiply, jint, juint)\n+JAVA_INTEGER_OP(+, java_add, jlong, julong)\n+JAVA_INTEGER_OP(-, java_subtract, jlong, julong)\n+JAVA_INTEGER_OP(*, java_multiply, jlong, julong)\n+\n+#undef JAVA_INTEGER_OP\n+\n+inline jint  java_negate(jint  v) { return java_subtract((jint) 0, v); }\n+inline jlong java_negate(jlong v) { return java_subtract((jlong)0, v); }\n+\n+\/\/ Provide integer shift operations with Java semantics.  No overflow\n+\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n+\/\/ behavior for large or negative shift quantities; instead the actual\n+\/\/ shift distance is the argument modulo the lhs value's size in bits.\n+\/\/ No undefined or implementation defined behavior for shifting negative\n+\/\/ values; left shift discards bits, right shift sign extends.  We use\n+\/\/ the same safe conversion technique as above for java_add and friends.\n+#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)         \\\n+inline constexpr TYPE NAME (TYPE lhs, jint rhs) {            \\\n+  constexpr juint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n+  static_assert(rhs_mask == 31 || rhs_mask == 63, \"sanity\"); \\\n+  XTYPE xres = static_cast<XTYPE>(lhs);                      \\\n+  xres OP ## = (rhs & rhs_mask);                             \\\n+  return xres;                                               \\\n+}\n+\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n+\n+\/\/ For signed shift right, assume C++ implementation >> sign extends.\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n+\n+\/\/ For >>> use C++ unsigned >>.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n+\n+#undef JAVA_INTEGER_SHIFT_OP\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ The goal of this code is to provide saturating operations for int\/uint.\n+\/\/ Checks overflow conditions and saturates the result to min_jint\/max_jint.\n+#define SATURATED_INTEGER_OP(OP, NAME, TYPE1, TYPE2) \\\n+inline constexpr int NAME (TYPE1 in1, TYPE2 in2) {   \\\n+  jlong res = static_cast<jlong>(in1);               \\\n+  res OP ## = static_cast<jlong>(in2);               \\\n+  if (res > max_jint) {                              \\\n+    res = max_jint;                                  \\\n+  } else if (res < min_jint) {                       \\\n+    res = min_jint;                                  \\\n+  }                                                  \\\n+  return res;                                        \\\n+}\n+\n+SATURATED_INTEGER_OP(+, saturated_add, int, int)\n+SATURATED_INTEGER_OP(+, saturated_add, int, uint)\n+SATURATED_INTEGER_OP(+, saturated_add, uint, int)\n+SATURATED_INTEGER_OP(+, saturated_add, uint, uint)\n+\n+#undef SATURATED_INTEGER_OP\n+\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline constexpr uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const julong x1 = java_shift_right_unsigned(jlong(x), 32);\n+  const julong x2 = juint(x);\n+  const julong y1 = java_shift_right_unsigned(jlong(y), 32);\n+  const julong y2 = juint(y);\n+  const julong z2 = x2 * y2;\n+  const julong t = x1 * y2 + java_shift_right_unsigned(jlong(z2), 32);\n+  julong z1 = juint(t);\n+  const julong z0 = java_shift_right_unsigned(jlong(t), 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right_unsigned(jlong(z1), 32);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline constexpr int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right((jlong)x, 32);\n+  const jlong x2 = juint(x);\n+  const jlong y1 = java_shift_right((jlong)y, 32);\n+  const jlong y2 = juint(y);\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + java_shift_right_unsigned(jlong(z2), 32); \/\/ Unsigned shift\n+  int64_t z1 = juint(t);\n+  const int64_t z0 = java_shift_right((jlong)t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Provide methods to calculate the magic constants in transforming divisions\n+\/\/ by constants into series of multiplications and shifts.\n+template <class T>\n+void magic_divide_constants(T d, T N_neg, T N_pos, juint min_s, T& c, bool& c_ovf, juint& s);\n+\n+void magic_divide_constants_round_down(juint d, juint& c, juint& s);\n+\n+#endif \/\/ SHARE_UTILITIES_JAVAARITHMETIC_HPP\n","filename":"src\/hotspot\/share\/utilities\/javaArithmetic.hpp","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include <random>\n+#include <type_traits>\n+#include <vector>\n+#include \"utilities\/javaArithmetic.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <class T, class U>\n+static void test_division(T d, T N_neg, T N_pos, juint min_s) {\n+  constexpr juint W = sizeof(T) * 8;\n+\n+  if ((N_neg < d && N_pos < d) || (d & (d - 1)) == 0) {\n+    return;\n+  }\n+\n+  T c;\n+  bool c_ovf;\n+  juint s;\n+  magic_divide_constants(d, N_neg, N_pos, min_s, c, c_ovf, s);\n+\n+  U lo = -U(N_neg);\n+  U hi = N_pos;\n+  U d_long = d;\n+  U c_long = c;\n+\n+  auto test = [&](U l) {\n+    if (l < lo || l > hi) {\n+      return;\n+    }\n+\n+    U expected = l \/ d;\n+    U actual;\n+    if (!c_ovf) {\n+      actual = ((l * U(c)) >> s) + (l < 0 ? U(1) : U(0));\n+    } else {\n+      ASSERT_EQ(N_neg, T(0));\n+      if (sizeof(U) > sizeof(T) * 2) {\n+        constexpr U wrap_amount = U(T(-1)) + 1;\n+        actual = (l * (U(c) + wrap_amount)) >> s;\n+      } else {\n+        U mul_hi = (l * U(c)) >> W;\n+        actual = (((l - mul_hi) >> 1) + mul_hi) >> (s - 1 - W);\n+      }\n+    }\n+    ASSERT_EQ(expected, actual);\n+  };\n+\n+  test(0);\n+  if (hi >= d_long) {\n+    test(d_long);\n+    test(hi - (hi + 1) % d_long);\n+  }\n+  if (N_neg >= d_long) {\n+    test(-d_long);\n+    test(lo - (lo - 1) % d_long);\n+  }\n+}\n+\n+template <class T, class U>\n+static void test_division_random() {\n+  constexpr int ITER = 10000;\n+  using UT = std::conditional_t<std::is_same<T, jlong>::value, julong, std::make_unsigned_t<T>>;\n+  std::random_device rd;\n+  std::minstd_rand rng(rd());\n+  std::uniform_int_distribution<UT> N_dist(0, std::numeric_limits<T>::max());\n+  std::uniform_int_distribution<UT> d_dist(0, std::numeric_limits<T>::max());\n+  std::uniform_int_distribution<juint> min_s_dist(0, sizeof(T) * 8);\n+  for (int i = 0; i < ITER; i++) {\n+    UT d = d_dist(rng);\n+    UT N_neg = std::is_signed<T>::value ? N_dist(rng) + 1 : 0;\n+    UT N_pos = N_dist(rng);\n+    juint min_s = min_s_dist(rng);\n+    test_division<UT, U>(d, N_neg, N_pos, min_s);\n+  }\n+}\n+\n+template <class T, class U>\n+static void test_division_fixed(const std::vector<julong>& values) {\n+  using UT = std::conditional_t<std::is_same<T, jlong>::value, julong, std::make_unsigned_t<T>>;\n+  for (julong N_neg : values) {\n+    if (N_neg > UT(std::numeric_limits<T>::min())) {\n+      continue;\n+    }\n+    for (julong N_pos : values) {\n+      if (N_pos > UT(std::numeric_limits<T>::max())) {\n+        continue;\n+      }\n+      for (julong d : values) {\n+        for (juint min_s = 0; min_s <= sizeof(T) * 8; min_s++) {\n+          test_division<UT, U>(d, N_neg, N_pos, min_s);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+TEST(opto, divide_by_constants) {\n+  std::vector<julong> values{0, 1, 2, 3, 5, 6, 7, 8, 11, 14, 15, 19, 29, 60, 101, 1000, 9999, 1000000,\n+    max_jint - 10, max_jint - 1, max_jint, julong(max_jint) + 1, julong(max_jint) + 2, julong(max_jint) + 11,\n+    max_juint - 10, max_juint - 1, max_juint, julong(max_juint) + 1, julong(max_juint) + 2, julong(max_juint) + 11,\n+    max_jlong - 10, max_jlong - 1, max_jlong, julong(max_jlong) + 1, julong(max_jlong) + 2, julong(max_jlong) + 11,\n+    max_julong - 10, max_julong - 1, max_julong};\n+\n+#ifdef __SIZEOF_INT128__\n+  test_division_fixed<jint, __int128>(values);\n+  test_division_fixed<juint, __int128>(values);\n+  test_division_fixed<jlong, __int128>(values);\n+  test_division_fixed<julong, unsigned __int128>(values);\n+  test_division_random<jint, __int128>();\n+  test_division_random<juint, __int128>();\n+  test_division_random<jlong, __int128>();\n+  test_division_random<julong, unsigned __int128>();\n+#else\n+  test_division_fixed<jint, jlong>(values);\n+  test_division_fixed<juint, julong>(values);\n+  test_division_random<jint, jlong>();\n+  test_division_random<juint, julong>();\n+#endif \/\/ __SIZEOF_INT128__\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_constant_division.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n-                 \"magicDiv\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\", \"divByMin\",\n+                 \"magicDiv13\", \"magicDiv7\", \"magicDiv7Bounded\"})\n@@ -85,1 +85,1 @@\n-        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ 1, identity(a));\n@@ -87,6 +87,10 @@\n-        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n-        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n-        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n-        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n-        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n-        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+        Asserts.assertEQ(a \/ -1, divByNegOne(a));\n+        Asserts.assertEQ((a & -6) \/ 2, divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2, divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8, divByPow2(a));\n+        Asserts.assertEQ(a \/ -8, divByNegPow2(a));\n+        Asserts.assertEquals(a \/ Integer.MIN_VALUE, divByMin(a));\n+        Asserts.assertEquals(1, divByMin(Integer.MIN_VALUE));\n+        Asserts.assertEQ(a \/ 13, magicDiv13(a));\n+        Asserts.assertEQ(a \/ 7, magicDiv7(a));\n+        Asserts.assertEQ((short)a \/ 7, magicDiv7Bounded(a));\n@@ -151,1 +155,1 @@\n-        return (x & -4) \/ 2;\n+        return (x & -6) \/ 2;\n@@ -193,2 +197,15 @@\n-    @IR(counts = {IRNode.SUB, \"1\",\n-                  IRNode.MUL, \"1\",\n+    @IR(counts = {IRNode.URSHIFT_I, \"2\",\n+                  IRNode.RSHIFT_I, \"1\",\n+                  IRNode.ADD_I, \"1\"\n+                 })\n+\n+    \/\/ Similar to above, 0 - (v >> 31) = v >>> 31\n+    public int divByMin(int x) {\n+        return x \/ Integer.MIN_VALUE;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n@@ -199,4 +216,2 @@\n-    \/\/ More tests can be made to cover the specific cases for differences in the\n-    \/\/ graph that depend upon different values for the \"magic constant\" and the\n-    \/\/ \"shift constant\"\n-    public int magicDiv(int x) {\n+    \/\/ The constant derived from 13 lies inside the limit of an i32\n+    public int magicDiv13(int x) {\n@@ -205,0 +220,28 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an i32 but inside the limit\n+    \/\/ of a u32\n+    public int magicDiv7(int x) {\n+        return x \/ 7;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.RSHIFT_I, \"3\"\n+                  })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ i64 arithmetic\n+    public int magicDiv7Bounded(int x) {\n+        return (short)x \/ 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\", \"divByMin\",\n+                 \"magicDiv19\", \"magicDiv15\", \"magicDiv15Bounded\"})\n@@ -84,1 +85,1 @@\n-        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ 1, identity(a));\n@@ -86,5 +87,10 @@\n-        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n-        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n-        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n-        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n-        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+        Asserts.assertEQ(a \/ -1, divByNegOne(a));\n+        Asserts.assertEQ((a & -6) \/ 2, divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2, divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8, divByPow2(a));\n+        Asserts.assertEQ(a \/ -8, divByNegPow2(a));\n+        Asserts.assertEQ(a \/ Long.MIN_VALUE, divByMin(a));\n+        Asserts.assertEQ(1L, divByMin(Long.MIN_VALUE));\n+        Asserts.assertEQ(a \/ 19, magicDiv19(a));\n+        Asserts.assertEQ(a \/ 15, magicDiv15(a));\n+        Asserts.assertEQ((int)a \/ 15L, magicDiv15Bounded(a));\n@@ -150,1 +156,1 @@\n-        return (x & -4L) \/ 2L;\n+        return (x & -6L) \/ 2L;\n@@ -190,0 +196,50 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 })\n+    \/\/ Similar to above\n+    public long divByMin(long x) {\n+        return x \/ Long.MIN_VALUE;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.MUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an i64\n+    public long magicDiv19(long x) {\n+        return x \/ 19L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\",\n+                  IRNode.MUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 15 lies outside the limit of an i64 but inside the limit\n+    \/\/ of a u64\n+    public long magicDiv15(long x) {\n+        return x \/ 15L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L}, applyIfPlatform = {\"64-bit\", \"true\"})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\"\n+                 }, applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ i128 arithmetic\n+    public long magicDiv15Bounded(long x) {\n+        return (int)x \/ 15L;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":65,"deletions":9,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivINode and UModINode are\n+ * being performed as expected.\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisorCon\", \"largeDivisorVar\",\n+                 \"magicDiv13\", \"magicDiv7\", \"magicDiv13Bounded\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod13\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public int udiv(int a, int b) {\n+        return Integer.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public int umod(int a, int b) {\n+        return Integer.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(1, constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(0, constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a, identity(a));\n+        Asserts.assertEQ(a, identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8), divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7), largeDivisorCon(a));\n+        Asserts.assertEQ(udiv(a, Math.min(b, -1)), largeDivisorVar(a, b));\n+        Asserts.assertEQ(udiv(a, 13), magicDiv13(a));\n+        Asserts.assertEQ(udiv(a, 7), magicDiv7(a));\n+        Asserts.assertEQ(udiv((char)a, 13), magicDiv13Bounded(a));\n+        Asserts.assertEQ(umod(a, 1), constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8), modByPow2(a));\n+        Asserts.assertEQ(umod(a, 13), magicMod13(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constantDiv(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.UDIV_I, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVE_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisorCon(int x) {\n+        return Integer.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVE_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisorVar(int x, int y) {\n+        return Integer.divideUnsigned(x, Math.min(y, -1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicDiv13(int x) {\n+        return Integer.divideUnsigned(x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u32 but inside the limit\n+    \/\/ of a u33\n+    public int magicDiv7(int x) {\n+        return Integer.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.URSHIFT_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ u64 arithmetic\n+    public int magicDiv13Bounded(int x) {\n+        return Integer.divideUnsigned((char)x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constantMod(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantModAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.AND_I, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public int modByPow2(int x) {\n+        return Integer.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.SUB_I, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicMod13(int x) {\n+        return Integer.remainderUnsigned(x, 13);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivLNode and UModLNode are\n+ * being performed as expected.\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisorCon\", \"largeDivisorVar\",\n+                 \"magicDiv19\", \"magicDiv7\", \"magicDiv28\", \"magicDiv13Bounded\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod19\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public long udiv(long a, long b) {\n+        return Long.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public long umod(long a, long b) {\n+        return Long.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(udiv(a, a), constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(umod(a, a), constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a, identity(a));\n+        Asserts.assertEQ(a, identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8), divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7), largeDivisorCon(a));\n+        Asserts.assertEQ(udiv(a, Math.min((int)b, -1)), largeDivisorVar(a, b));\n+        Asserts.assertEQ(udiv(a, 19), magicDiv19(a));\n+        Asserts.assertEQ(udiv(a, 7), magicDiv7(a));\n+        Asserts.assertEQ(udiv(a, 28), magicDiv28(a));\n+        Asserts.assertEQ(udiv(Integer.toUnsignedLong((int)a), 13), magicDiv13Bounded(a));\n+        Asserts.assertEQ(umod(a, 1), constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8), modByPow2(a));\n+        Asserts.assertEQ(umod(a, 19), magicMod19(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constantDiv(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.UDIV_L, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVE_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisorCon(long x) {\n+        return Long.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVE_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisorVar(long x, long y) {\n+        return Long.divideUnsigned(x, Math.min((int)y, -1));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of a u64\n+    public long magicDiv19(long x) {\n+        return Long.divideUnsigned(x, 19);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u64 but inside the limit\n+    \/\/ of a u65\n+    public long magicDiv7(long x) {\n+        return Long.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 28 lies outside the limit of a u64 but we can transform\n+    \/\/ x \/ 28 into (x \/ 4) \/ 7\n+    public long magicDiv28(long x) {\n+        return Long.divideUnsigned(x, 28);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.MUL_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ When the dividend is bounded, we can use smaller constant and do not need to use\n+    \/\/ u128 arithmetic\n+    public long magicDiv13Bounded(long x) {\n+        return Long.divideUnsigned(Integer.toUnsignedLong((int)x), 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constantMod(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantModAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.AND_L, \"1\"}, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public long modByPow2(long x) {\n+        return Long.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L}, applyIfPlatform = {\"x64\", \"true\"})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 }, applyIfPlatform = {\"x64\", \"true\"})\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of a u64\n+    public long magicMod19(long x) {\n+        return Long.remainderUnsigned(x, 19);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.integerArithmetic;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of division nodes provide correct\n+ * result.\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.integerArithmetic.DivisionByConstant\n+ *\/\n+public class DivisionByConstant {\n+    private static final int TRIALS = 10;\n+    private static final int INVOCATIONS = 100;\n+\n+    private static final int I_DIV;\n+    private static final int I_1;\n+    private static final int I_2;\n+    private static final long L_DIV;\n+    private static final long L_1;;\n+    private static final long L_2;\n+\n+    static {\n+        int iDiv = 0;\n+        int i1 = 0;\n+        int i2 = 0;\n+        long lDiv = 0;\n+        long l1 = 0;\n+        long l2 = 0;\n+        try {\n+            iDiv = Integer.parseUnsignedInt(System.getProperty(\"iDiv\"));\n+            i1 = Integer.parseUnsignedInt(System.getProperty(\"i1\"));\n+            i2 = Integer.parseUnsignedInt(System.getProperty(\"i2\"));\n+            lDiv = Long.parseUnsignedLong(System.getProperty(\"lDiv\"));\n+            l1 = Long.parseUnsignedLong(System.getProperty(\"l1\"));\n+            l2 = Long.parseUnsignedLong(System.getProperty(\"l2\"));\n+        } catch (Exception e) {}\n+\n+        I_DIV = iDiv;\n+        I_1 = i1;\n+        I_2 = i2;\n+        L_DIV = lDiv;\n+        L_1 = l1;\n+        L_2 = l2;\n+    }\n+    private static final int I_LO = Math.min(I_1, I_2);\n+    private static final int I_HI = Math.max(I_1, I_2);\n+    private static final int I_UHI = I_1;\n+    private static final long L_LO = Math.min(L_1, L_2);\n+    private static final long L_HI = Math.max(L_1, L_2);\n+    private static final long L_UHI = L_1;\n+\n+    public static void main(String[] args) {\n+        Random r = Utils.getRandomInstance();\n+        for (int i = 0; i < TRIALS; i++) {\n+            String iDiv = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String i1 = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String i2 = Long.toUnsignedString(logRandom(r, Integer.SIZE));\n+            String lDiv = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+            String l1 = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+            String l2 = Long.toUnsignedString(logRandom(r, Long.SIZE));\n+\n+            var test = new TestFramework(DivisionByConstant.class);\n+            test.setDefaultWarmup(1);\n+            test.addFlags(\"-DiDiv=\" + iDiv, \"-Di1=\" + i1, \"-Di2=\" + i2,\n+                    \"-DlDiv=\" + lDiv, \"-Dl1=\" + l1, \"-Dl2=\" + l2);\n+            test.start();\n+        }\n+    }\n+\n+    static long logRandom(Random r, int bits) {\n+        int highestBit = r.nextInt(bits);\n+        long res = r.nextLong() & (-1L >>> (Long.SIZE - 1 - highestBit));\n+        return res == 0 ? 1 : res;\n+    }\n+\n+    @Run(test = {\"sDivInt\", \"uDivInt\", \"sDivLong\", \"uDivLong\"})\n+    public void run() {\n+        Random r = Utils.getRandomInstance();\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            {\n+                int x;\n+                if (I_HI != Integer.MAX_VALUE) {\n+                    x = r.nextInt(I_LO, I_HI + 1);\n+                } else if (I_LO != Integer.MIN_VALUE) {\n+                    x = r.nextInt(I_LO - 1, I_HI) + 1;\n+                } else {\n+                    x = r.nextInt();\n+                }\n+                Asserts.assertEQ(sDiv(x, I_DIV), sDivInt(x));\n+            }\n+            {\n+                int x;\n+                if (I_UHI >= 0) {\n+                    x = r.nextInt(-1, I_UHI) + 1;\n+                } else {\n+                    x = r.nextInt(Integer.MIN_VALUE, I_UHI + 1);\n+                }\n+                Asserts.assertEQ(uDiv(x, I_DIV), uDivInt(x));\n+            }\n+            {\n+                long y; int x;\n+                if (L_LO >= Integer.MIN_VALUE && L_HI <= Integer.MAX_VALUE) {\n+                    y = r.nextLong(L_LO, L_HI + 1);\n+                    x = (int)y;\n+                } else {\n+                    x = r.nextInt();\n+                    if (x > 0) {\n+                        y = L_LO - 1 + x;\n+                    } else {\n+                        y = L_HI + x;\n+                    }\n+                }\n+                Asserts.assertEQ(sDiv(y, L_DIV), sDivLong(x));\n+            }\n+            {\n+                long y; int x;\n+                if (L_UHI >= 0 && L_UHI <= Integer.MAX_VALUE) {\n+                    y = r.nextLong(L_UHI + 1);\n+                    x = (int)y;\n+                } else {\n+                    x = r.nextInt();\n+                    if (x > 0) {\n+                        y = x;\n+                    } else {\n+                        y = L_UHI + x;\n+                    }\n+                }\n+                Asserts.assertEQ(uDiv(y, L_DIV), uDivLong(x));\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    static int sDiv(int x, int y) {\n+        return x \/ y;\n+    }\n+\n+    @DontCompile\n+    static int uDiv(int x, int y) {\n+        return Integer.divideUnsigned(x, y);\n+    }\n+\n+    @DontCompile\n+    static long sDiv(long x, long y) {\n+        return x \/ y;\n+    }\n+\n+    @DontCompile\n+    static long uDiv(long x, long y) {\n+        return Long.divideUnsigned(x, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.DIV)\n+    public int sDivInt(int x) {\n+        int dividend = Math.min(I_HI, Math.max(I_LO, x));\n+        return dividend \/ I_DIV;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.UDIV_I, applyIfPlatform = {\"x64\", \"true\"})\n+    static int uDivInt(int x) {\n+        int dividend = I_UHI < 0\n+                ? Math.min(I_UHI, x)\n+                : Math.min(I_UHI, Math.max(0, x));\n+        return Integer.divideUnsigned(dividend, I_DIV);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.DIV_L, applyIfPlatform = {\"64-bit\", \"true\"})\n+    static long sDivLong(int x) {\n+        long dividend;\n+        if (L_LO >= Integer.MIN_VALUE && L_HI <= Integer.MAX_VALUE) {\n+            dividend = Math.min((int)L_HI, Math.max((int)L_LO, x));\n+        } else if (x > 0) {\n+            dividend = L_LO - 1 + x;\n+        } else {\n+            dividend = L_HI + x;\n+        }\n+        return dividend \/ L_DIV;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.UDIV_L, applyIfPlatform = {\"x64\", \"true\"})\n+    static long uDivLong(int x) {\n+        long dividend;\n+        if (L_UHI >= 0 && L_UHI <= Integer.MAX_VALUE) {\n+            dividend = Math.min((int)L_UHI, Math.max(0, x));\n+        } else if (x > 0) {\n+            dividend = x;\n+        } else {\n+            dividend = L_UHI + x;\n+        }\n+        return Long.divideUnsigned(dividend, L_DIV);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/integerArithmetic\/DivisionByConstant.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -405,0 +405,15 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+    }\n+\n+    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VD, \"CMoveVD\");\n+    }\n+\n+    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n+    static {\n+        superWordNodes(CMOVE_VF, \"CMoveVF\");\n+    }\n+\n@@ -945,0 +960,10 @@\n+    public static final String MUL_HI_L = PREFIX + \"MUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HI_L, \"MulHiL\");\n+    }\n+\n+    public static final String UMUL_HI_L = PREFIX + \"UMUL_HI_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(UMUL_HI_L, \"UMulHiL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Integer.MIN_VALUE) {\n+                    divisor = Integer.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,11 @@\n-            divmod(dividends[i], divisors[i], i);\n+            int dividend = dividends[i];\n+            int divisor = divisors[i];\n+            quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+            remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ 7;\n@@ -97,3 +114,5 @@\n-    public void divmod(int dividend, int divisor, int i) {\n-        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n-        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], 7);\n+        }\n@@ -102,0 +121,6 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -103,3 +128,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGeneratorFactory;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,3 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n@@ -58,0 +54,1 @@\n+\n@@ -66,1 +63,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGeneratorFactory.getDefault().create(0);\n@@ -70,2 +67,12 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisor = divisor == 0 ? 1 : divisor;\n+            if (divisorType.equals(\"positive\")) {\n+                if (divisor == Long.MIN_VALUE) {\n+                    divisor = Long.MAX_VALUE;\n+                } else if (divisor < 0) {\n+                    divisor = -divisor;\n+                }\n+            } else if (divisorType.equals(\"negative\")) {\n+                if (divisor > 0) {\n+                    divisor = -divisor;\n+                }\n+            }\n@@ -93,1 +100,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            long dividend = dividends[i];\n+            long divisor = divisors[i];\n+            quotients[i] = Long.divideUnsigned(dividend, divisor);\n+            remainders[i] = Long.remainderUnsigned(dividend, divisor);\n@@ -97,3 +107,5 @@\n-    public void divmod(long dividend, long divisor, int i) {\n-        quotients[i] = Long.divideUnsigned(dividend, divisor);\n-        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], 7);\n+        }\n@@ -102,0 +114,6 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -103,3 +121,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"}]}