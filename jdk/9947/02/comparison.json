{"files":[{"patch":"@@ -2279,0 +2279,7 @@\n+void Assembler::divl(Address src) { \/\/ Unsigned\n+  InstructionMark im(this);\n+  prefix(src);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(6), src);\n+}\n+\n@@ -12892,0 +12899,7 @@\n+void Assembler::divq(Address src) { \/\/ Unsigned\n+  InstructionMark im(this);\n+  prefixq(src);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(6), src);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1380,0 +1380,1 @@\n+  void divl(Address src);\n@@ -1384,0 +1385,1 @@\n+  void divq(Address src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5436,81 +5436,0 @@\n-void C2_MacroAssembler::udivI(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpl(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorl(rdx, rdx);\n-  divl(divisor);\n-  jmpb(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath for divisor < 0:\n-  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n-  movl(rdx, rax);\n-  subl(rdx, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnl(rax, rdx, rax);\n-  } else {\n-    notl(rdx);\n-    andl(rax, rdx);\n-  }\n-  shrl(rax, 31);\n-  bind(done);\n-}\n-\n-void C2_MacroAssembler::umodI(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpl(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorl(rdx, rdx);\n-  divl(divisor);\n-  jmpb(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath when divisor < 0:\n-  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n-  movl(rdx, rax);\n-  subl(rax, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnl(rax, rax, rdx);\n-  } else {\n-    notl(rax);\n-    andl(rax, rdx);\n-  }\n-  sarl(rax, 31);\n-  andl(rax, divisor);\n-  subl(rdx, rax);\n-  bind(done);\n-}\n-\n-void C2_MacroAssembler::udivmodI(Register rax, Register divisor, Register rdx, Register tmp) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-\n-  cmpl(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorl(rdx, rdx);\n-  divl(divisor);\n-  jmpb(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath for divisor < 0:\n-  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n-  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n-  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n-  movl(rdx, rax);\n-  subl(rax, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnl(rax, rax, rdx);\n-  } else {\n-    notl(rax);\n-    andl(rax, rdx);\n-  }\n-  movl(tmp, rax);\n-  shrl(rax, 31); \/\/ quotient\n-  sarl(tmp, 31);\n-  andl(tmp, divisor);\n-  subl(rdx, tmp); \/\/ remainder\n-  bind(done);\n-}\n-\n@@ -5601,80 +5520,0 @@\n-\n-void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpq(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorl(rdx, rdx);\n-  divq(divisor);\n-  jmpb(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath for divisor < 0:\n-  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n-  movq(rdx, rax);\n-  subq(rdx, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnq(rax, rdx, rax);\n-  } else {\n-    notq(rdx);\n-    andq(rax, rdx);\n-  }\n-  shrq(rax, 63);\n-  bind(done);\n-}\n-\n-void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpq(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorq(rdx, rdx);\n-  divq(divisor);\n-  jmp(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath when divisor < 0:\n-  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n-  movq(rdx, rax);\n-  subq(rax, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnq(rax, rax, rdx);\n-  } else {\n-    notq(rax);\n-    andq(rax, rdx);\n-  }\n-  sarq(rax, 63);\n-  andq(rax, divisor);\n-  subq(rdx, rax);\n-  bind(done);\n-}\n-\n-void C2_MacroAssembler::udivmodL(Register rax, Register divisor, Register rdx, Register tmp) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpq(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorq(rdx, rdx);\n-  divq(divisor);\n-  jmp(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath for divisor < 0:\n-  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n-  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n-  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n-  movq(rdx, rax);\n-  subq(rax, divisor);\n-  if (VM_Version::supports_bmi1()) {\n-    andnq(rax, rax, rdx);\n-  } else {\n-    notq(rax);\n-    andq(rax, rdx);\n-  }\n-  movq(tmp, rax);\n-  shrq(rax, 63); \/\/ quotient\n-  sarq(tmp, 63);\n-  andq(tmp, divisor);\n-  subq(rdx, tmp); \/\/ remainder\n-  bind(done);\n-}\n@@ -5728,1 +5567,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":162,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -365,7 +365,0 @@\n-#endif\n-\n-  void udivI(Register rax, Register divisor, Register rdx);\n-  void umodI(Register rax, Register divisor, Register rdx);\n-  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n-\n-#ifdef _LP64\n@@ -376,3 +369,0 @@\n-  void udivL(Register rax, Register divisor, Register rdx);\n-  void umodL(Register rax, Register divisor, Register rdx);\n-  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7805,0 +7805,15 @@\n+\/\/ Integer UDIV with Register\n+instruct udivI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n+  match(Set rax (UDivI rax div));\n+  effect(KILL rdx, KILL cr);\n+  size(4);\n+  ins_cost(300);\n+  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n+            \"DIV    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7824,0 +7839,15 @@\n+\/\/ Integer UDIVMOD with Register\n+instruct udivModI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n+  match(UDivModI rax div);\n+  effect(KILL cr);\n+  size(4);\n+  ins_cost(300);\n+  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n+            \"DIV    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7853,0 +7883,15 @@\n+\/\/ Integer UMOD with Register\n+instruct umodI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{\n+  match(Set rdx (UModI rax div));\n+  effect(KILL rax, KILL cr);\n+  size(4);\n+  ins_cost(300);\n+  format %{ \"XOR    $rdx, $rdx\\n\\t\"\n+            \"DIV    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+extern RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -342,0 +343,1 @@\n+extern RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -345,0 +347,1 @@\n+inline const RegMask& STACK_OR_LONG_NO_RAX_RDX_REG_mask() { return _STACK_OR_LONG_NO_RAX_RDX_REG_mask; }\n@@ -346,0 +349,1 @@\n+inline const RegMask& STACK_OR_INT_NO_RAX_RDX_REG_mask() { return _STACK_OR_INT_NO_RAX_RDX_REG_mask; }\n@@ -371,0 +375,1 @@\n+RegMask _STACK_OR_LONG_NO_RAX_RDX_REG_mask;\n@@ -372,0 +377,1 @@\n+RegMask _STACK_OR_INT_NO_RAX_RDX_REG_mask;\n@@ -421,0 +427,2 @@\n+  _STACK_OR_LONG_NO_RAX_RDX_REG_mask = _LONG_NO_RAX_RDX_REG_mask;\n+  _STACK_OR_LONG_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -446,0 +454,2 @@\n+  _STACK_OR_INT_NO_RAX_RDX_REG_mask = _INT_NO_RAX_RDX_REG_mask;\n+  _STACK_OR_INT_NO_RAX_RDX_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -8904,1 +8914,2 @@\n-  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n@@ -8906,1 +8917,2 @@\n-    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n@@ -8908,1 +8920,16 @@\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct udivI_mem(rax_RegI rax, rdx_RegI rdx, memory div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivI rax (LoadI div)));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -8917,1 +8944,2 @@\n-  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n@@ -8919,1 +8947,2 @@\n-     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Register);\n@@ -8921,1 +8950,16 @@\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct udivL_mem(rax_RegL rax, rdx_RegL rdx, memory div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivL rax (LoadL div)));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -8966,1 +9010,1 @@\n-instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI tmp, rdx_RegI rdx,\n+instruct udivModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx,\n@@ -8970,1 +9014,1 @@\n-  effect(TEMP tmp, KILL cr);\n+  effect(KILL cr);\n@@ -8973,3 +9017,19 @@\n-  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n-            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n-          %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Unsigned integer DIVMOD with Memory, both quotient and mod results\n+instruct udivModI_mem_divmod(rax_RegI rax, rdx_RegI rdx,\n+                             memory div, rFlagsReg cr)\n+%{\n+  match(UDivModI rax (LoadI div));\n+  effect(KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n@@ -8977,1 +9037,2 @@\n-    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Address);\n@@ -8983,1 +9044,1 @@\n-instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,\n+instruct udivModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx,\n@@ -8987,1 +9048,1 @@\n-  effect(TEMP tmp, KILL cr);\n+  effect(KILL cr);\n@@ -8990,3 +9051,2 @@\n-  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n-            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n-          %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n@@ -8994,1 +9054,2 @@\n-    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Register);\n@@ -8999,0 +9060,16 @@\n+\/\/ Unsigned long DIVMOD with Memory, both quotient and mod results\n+instruct udivModL_mem_divmod(rax_RegL rax, rdx_RegL rdx,\n+                             memory div, rFlagsReg cr)\n+%{\n+  match(UDivModL rax (LoadL div));\n+  effect(KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -9109,1 +9186,2 @@\n-  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n@@ -9111,1 +9189,2 @@\n-    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Register);\n@@ -9113,1 +9192,16 @@\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct umodI_mem(rdx_RegI rdx, rax_RegI rax, memory div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModI rax (LoadI div)));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divl    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divl($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n@@ -9122,1 +9216,2 @@\n-  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n@@ -9124,1 +9219,2 @@\n-    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Register);\n@@ -9126,1 +9222,16 @@\n-  ins_pipe(ialu_reg_reg_alu0);\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct umodL_mem(rdx_RegL rdx, rax_RegL rax, memory div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModL rax (LoadL div)));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(375);\n+  format %{ \"xorl    $rdx, $rdx\\n\\t\"\n+            \"divq    $div\" %}\n+  ins_encode %{\n+    __ xorl($rdx$$Register, $rdx$$Register);\n+    __ divq($div$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":135,"deletions":24,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-\/\/ by constant into a multiply\/shift\/add series. Return false if calculations\n-\/\/ fail.\n+\/\/ by constant into a multiply\/shift series.\n@@ -52,1 +51,3 @@\n-static bool magic_int_divide_constants(jint d, jint &M, jint &s) {\n+\n+static void magic_int_divide_constants(jint d, jlong &M, jint &s) {\n+  assert(d > 1, \"sanity\");\n@@ -54,2 +55,2 @@\n-  uint32_t ad, anc, delta, q1, r1, q2, r2, t;\n-  const uint32_t two31 = 0x80000000L;     \/\/ 2**31.\n+  jlong ad, anc, delta, q1, r1, q2, r2, t;\n+  const jlong two31 = 0x80000000L; \/\/ 2**31.\n@@ -57,3 +58,2 @@\n-  ad = ABS(d);\n-  if (d == 0 || d == 1) return false;\n-  t = two31 + ((uint32_t)d >> 31);\n+  ad = jlong(d);\n+  t = two31;\n@@ -83,2 +83,1 @@\n-  M = q2 + 1;\n-  if (d < 0) M = -M;      \/\/ Magic number and\n+  M = q2 + 1;             \/\/ Magic number and\n@@ -86,0 +85,1 @@\n+}\n@@ -87,1 +87,63 @@\n-  return true;\n+\/\/---------------magic_int_unsigned_divide_constants_down----------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n+\/\/ by constant into a multiply\/add\/shift series. Return false if calculations\n+\/\/ fail.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.\n+static void magic_int_unsigned_divide_constants_down(juint d, jlong &M, jint &s) {\n+  assert(d > 1, \"sanity\");\n+  jlong two31 = jlong(juint(min_jint));\n+  jlong two31m1 = jlong(juint(max_jint));\n+\n+  jint p;\n+  jlong nc, delta, q1, r1, q2, r2;\n+\n+  jlong ad = jlong(d);\n+  nc = jlong(max_juint) - (two31 * 2 - ad)%ad;\n+  p = 31;                  \/\/ Init. p.\n+  q1 = two31\/nc;           \/\/ Init. q1 = 2**p\/nc.\n+  r1 = two31 - q1*nc;      \/\/ Init. r1 = rem(2**p, nc).\n+  q2 = two31m1\/ad;         \/\/ Init. q2 = (2**p - 1)\/d.\n+  r2 = two31m1 - q2*ad;    \/\/ Init. r2 = rem(2**p - 1, d).\n+  do {\n+    p = p + 1;\n+    if (r1 >= nc - r1) {\n+      q1 = 2*q1 + 1;       \/\/ Update q1.\n+      r1 = 2*r1 - nc;      \/\/ Update r1.\n+    } else {\n+      q1 = 2*q1;\n+      r1 = 2*r1;\n+    }\n+    if (r2 + 1 >= ad - r2) {\n+      q2 = 2*q2 + 1;       \/\/ Update q2.\n+      r2 = 2*r2 + 1 - ad;  \/\/ Update r2.\n+    } else {\n+      q2 = 2*q2;\n+      r2 = 2*r2 + 1;\n+    }\n+    delta = ad - 1 - r2;\n+  } while (p < 64 && (q1 < delta || (q1 == delta && r1 == 0)));\n+  M = q2 + 1; \/\/ Magic number\n+  s = p - 32; \/\/ and shift amount to return\n+}\n+\n+\/\/-----------------magic_int_unsigned_divide_constants_up----------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 32 bit divide\n+\/\/ by constant into a multiply\/add\/shift series. Return false if calculations\n+\/\/ fail.\n+\/\/\n+\/\/ Borrowed almost verbatim from N-Bit Unsigned Division Via N-Bit Multiply-Add\n+\/\/ by Arch D. Robison\n+\/\/\n+\/\/ Call this up since we do this after failing with the down attempt\n+static void magic_int_unsigned_divide_constants_up(juint d, jlong &M, jint &s) {\n+  assert(d > 1, \"sanity\");\n+  jint N = 32;\n+  s = log2i_graceful(d);\n+  julong t = (julong(1) << (s + N)) \/ julong(d);\n+  M = t;\n+#ifdef ASSERT\n+  julong r = ((t + 1) * julong(d)) & julong(max_juint);\n+  assert(r > (julong(1) << s), \"Should call down first since it is more efficient\");\n+#endif\n@@ -165,0 +227,3 @@\n+    \/\/\n+    \/\/ Some modifications are made since we multiply high by performing\n+    \/\/ long multiplication\n@@ -166,1 +231,1 @@\n-    jint magic_const;\n+    jlong magic_const;\n@@ -168,3 +233,22 @@\n-    if (magic_int_divide_constants(d, magic_const, shift_const)) {\n-      Node *magic = phase->longcon(magic_const);\n-      Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    magic_int_divide_constants(juint(d), magic_const, shift_const);\n+    \/\/ magic_const should be a u32\n+    assert(magic_const >= jlong(0) && magic_const <= jlong(max_juint), \"sanity\");\n+    Node *magic = phase->longcon(magic_const);\n+    Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n+\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n+    \/\/ i32 * u32 <: i64 so there should be no overflow\n+    \/\/ No add is required, we can merge the shifts together.\n+    mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+    mul_hi = phase->transform(new ConvL2INode(mul_hi));\n+\n+    \/\/ Get a 0 or -1 from the sign of the dividend.\n+    Node *addend0 = mul_hi;\n+    Node *addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+\n+    \/\/ If the divisor is negative, swap the order of the input addends;\n+    \/\/ this has the effect of negating the quotient.\n+    if (!d_pos) {\n+      Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+    }\n@@ -172,2 +256,4 @@\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n+    \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n+    \/\/ from the mul_hi.\n+    q = new SubINode(addend0, addend1);\n+  }\n@@ -175,3 +261,2 @@\n-      if (magic_const < 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n+  return q;\n+}\n@@ -179,4 +264,6 @@\n-        \/\/ The magic multiplier is too large for a 32 bit constant. We've adjusted\n-        \/\/ it down by 2^32, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddINode(dividend, mul_hi));\n+\/\/--------------------------transform_int_udivide------------------------------\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return NULL if no transformation occurs.\n+static Node *transform_int_udivide( PhaseGVN *phase, Node *dividend, juint divisor ) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  const int N = 32;\n@@ -184,9 +271,10 @@\n-        \/\/ Shift over the (adjusted) mulhi\n-        if (shift_const != 0) {\n-          mul_hi = phase->transform(new RShiftINode(mul_hi, phase->intcon(shift_const)));\n-        }\n-      } else {\n-        \/\/ No add is required, we can merge the shifts together.\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n-        mul_hi = phase->transform(new ConvL2INode(mul_hi));\n-      }\n+  \/\/ Result\n+  Node *q = NULL;\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    q = new URShiftINode(dividend, phase->intcon(l));\n+  } else {\n+    \/\/ Attempt the juint constant divide -> multiply transform found in\n+    \/\/   \"Division by Invariant Integers using Multiplication\"\n+    \/\/     by Granlund and Montgomery\n+    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n@@ -194,3 +282,3 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftINode(dividend, phase->intcon(N-1)));\n+    \/\/ Unsigned extension of dividend\n+    Node *dividend_long = phase->transform(new ConvI2LNode(dividend));\n+    dividend_long = phase->transform(new AndLNode(dividend_long, phase->longcon(max_juint)));\n@@ -198,5 +286,16 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n-      }\n+    jlong magic_const;\n+    jint shift_const;\n+    magic_int_unsigned_divide_constants_down(divisor, magic_const, shift_const);\n+    assert(magic_const >= 0 && magic_const <= 0x1FFFFFFFFL, \"sanity\");\n+\n+    \/\/ magic_const is u33, max_abs_dividend is u32, so we must check for overflow\n+    const TypeInt* dividend_type = phase->type(dividend)->is_int();\n+    julong max_dividend;\n+    if (dividend_type->_hi < 0 || dividend_type->_lo >= 0) {\n+      max_dividend = julong(juint(dividend_type->_hi));\n+    } else {\n+      max_dividend = max_juint;\n+    }\n+    if (julong(magic_const) <= max_julong \/ max_dividend) {\n+      \/\/ No overflow here, just do the transformation\n+      Node *magic = phase->longcon(magic_const);\n@@ -204,3 +303,21 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubINode(addend0, addend1);\n+      \/\/ Compute the high half of the dividend x magic multiplication\n+      Node *mul_hi = phase->transform(new MulLNode(dividend_long, magic));\n+\n+      \/\/ Merge the shifts together.\n+      mul_hi = phase->transform(new URShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+      q = new ConvL2INode(mul_hi);\n+    } else {\n+      \/\/ Original plan fails, rounding down of 1\/divisor does not work, change\n+      \/\/ to rounding up, now it is guaranteed to not overflow, according to\n+      \/\/ N-Bit Unsigned Division Via N-Bit Multiply-Add by Arch D. Robison\n+      magic_int_unsigned_divide_constants_up(divisor, magic_const, shift_const);\n+      assert(magic_const >= 0 && magic_const <= jlong(max_juint), \"sanity\");\n+      Node* magic = phase->longcon(magic_const);\n+\n+      \/\/ Compute the high half of the dividend x magic multiplication\n+      Node *mul_hi = phase->transform(new AddLNode(dividend_long, phase->longcon(1)));\n+      mul_hi = phase->transform(new MulLNode(mul_hi, magic));\n+\n+      \/\/ Merge the shifts together.\n+      mul_hi = phase->transform(new URShiftLNode(mul_hi, phase->intcon(N + shift_const)));\n+      q = new ConvL2INode(mul_hi);\n@@ -220,1 +337,3 @@\n-static bool magic_long_divide_constants(jlong d, jlong &M, jint &s) {\n+static void magic_long_divide_constants(jlong d, jlong &M, jint &s) {\n+  assert(d > 1, \"sanity\");\n+\n@@ -226,2 +345,1 @@\n-  if (d == 0 || d == 1) return false;\n-  t = two63 + ((uint64_t)d >> 63);\n+  t = two63;\n@@ -252,1 +370,0 @@\n-  if (d < 0) M = -M;      \/\/ Magic number and\n@@ -254,0 +371,1 @@\n+}\n@@ -255,1 +373,47 @@\n-  return true;\n+\/\/-----------------magic_long_unsigned_divide_constants------------------------\n+\/\/ Compute magic multiplier and shift constant for converting a 64 bit divide\n+\/\/ by constant into a multiply\/shift\/add series.\n+\/\/\n+\/\/ Borrowed almost verbatim from Hacker's Delight by Henry S. Warren, Jr. with\n+\/\/ minor type name and parameter changes.  Adjusted to 64 bit word width.\n+static void magic_long_unsigned_divide_constants(julong d, jlong &M, jint &s, bool& magic_const_ovf) {\n+  assert(d > 1, \"sanity\");\n+  julong two63 = julong(min_jlong);\n+  julong two63m1 = julong(max_jlong);\n+\n+  jint p;\n+  julong nc, delta, q1, r1, q2, r2;\n+\n+  nc = -1 - (-d)%d;       \/\/ Unsigned arithmetic here.\n+  p = 63;                 \/\/ Init. p.\n+  q1 = two63\/nc;          \/\/ Init. q1 = 2**p\/nc.\n+  r1 = two63 - q1*nc;     \/\/ Init. r1 = rem(2**p, nc).\n+  q2 = two63m1\/d;         \/\/ Init. q2 = (2**p - 1)\/d.\n+  r2 = two63m1 - q2*d;    \/\/ Init. r2 = rem(2**p - 1, d).\n+  magic_const_ovf = false;\n+  do {\n+    p = p + 1;\n+    if (r1 >= nc - r1) {\n+      q1 = 2*q1 + 1;      \/\/ Update q1.\n+      r1 = 2*r1 - nc;     \/\/ Update r1.\n+    } else {\n+      q1 = 2*q1;\n+      r1 = 2*r1;\n+    }\n+    if (r2 + 1 >= d - r2) {\n+      if (q2 >= two63m1) {\n+        magic_const_ovf = true;\n+      }\n+      q2 = 2*q2 + 1;      \/\/ Update q2.\n+      r2 = 2*r2 + 1 - d;  \/\/ Update r2.\n+    } else {\n+      if (q2 >= two63) {\n+        magic_const_ovf = true;\n+      }\n+      q2 = 2*q2;\n+      r2 = 2*r2 + 1;\n+    }\n+    delta = d - 1 - r2;\n+  } while (p < 128 && (q1 < delta || (q1 == delta && r1 == 0)));\n+  M = q2 + 1;             \/\/ Magic number\n+  s = p - 64;             \/\/ and shift amount to return\n@@ -415,11 +579,11 @@\n-    if (magic_long_divide_constants(d, magic_const, shift_const)) {\n-      \/\/ Compute the high half of the dividend x magic multiplication\n-      Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n-\n-      \/\/ The high half of the 128-bit multiply is computed.\n-      if (magic_const < 0) {\n-        \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n-        \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n-        \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n-        mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n-      }\n+    magic_long_divide_constants(d, magic_const, shift_const);\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    Node *mul_hi = phase->transform(long_by_long_mulhi(phase, dividend, magic_const));\n+\n+    \/\/ The high half of the 128-bit multiply is computed.\n+    if (magic_const < 0) {\n+      \/\/ The magic multiplier is too large for a 64 bit constant. We've adjusted\n+      \/\/ it down by 2^64, but have to add 1 dividend back in after the multiplication.\n+      \/\/ This handles the \"overflow\" case described by Granlund and Montgomery.\n+      mul_hi = phase->transform(new AddLNode(dividend, mul_hi));\n+    }\n@@ -427,4 +591,29 @@\n-      \/\/ Shift over the (adjusted) mulhi\n-      if (shift_const != 0) {\n-        mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n-      }\n+    \/\/ Shift over the (adjusted) mulhi\n+    if (shift_const != 0) {\n+      mul_hi = phase->transform(new RShiftLNode(mul_hi, phase->intcon(shift_const)));\n+    }\n+\n+    \/\/ Get a 0 or -1 from the sign of the dividend.\n+    Node *addend0 = mul_hi;\n+    Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n+\n+    \/\/ If the divisor is negative, swap the order of the input addends;\n+    \/\/ this has the effect of negating the quotient.\n+    if (!d_pos) {\n+      Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+    }\n+\n+    \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n+    \/\/ from the mul_hi.\n+    q = new SubLNode(addend0, addend1);\n+  }\n+\n+  return q;\n+}\n+\n+\/\/--------------------------transform_long_udivide-----------------------------\n+\/\/ Convert an unsigned division by constant divisor into an alternate Ideal graph.\n+\/\/ Return NULL if no transformation occurs.\n+static Node *transform_long_udivide( PhaseGVN *phase, Node *dividend, julong divisor ) {\n+  assert(divisor > 1, \"invalid constant divisor\");\n+  const int N = 32;\n@@ -432,3 +621,14 @@\n-      \/\/ Get a 0 or -1 from the sign of the dividend.\n-      Node *addend0 = mul_hi;\n-      Node *addend1 = phase->transform(new RShiftLNode(dividend, phase->intcon(N-1)));\n+  \/\/ Result\n+  Node *q = NULL;\n+  if (is_power_of_2(divisor)) {\n+    int l = log2i_exact(divisor);\n+    q = new URShiftLNode(dividend, phase->intcon(l));\n+  } else {\n+    if (!Matcher::match_rule_supported(Op_UMulHiL)) {\n+      return nullptr; \/\/ Don't bother\n+    }\n+\n+    \/\/ Attempt the julong constant divide -> multiply transform found in\n+    \/\/   \"Division by Invariant Integers using Multiplication\"\n+    \/\/     by Granlund and Montgomery\n+    \/\/ See also \"Hacker's Delight\", chapter 10 by Warren.\n@@ -436,4 +636,22 @@\n-      \/\/ If the divisor is negative, swap the order of the input addends;\n-      \/\/ this has the effect of negating the quotient.\n-      if (!d_pos) {\n-        Node *temp = addend0; addend0 = addend1; addend1 = temp;\n+    \/\/ Unsigned extension of dividend\n+    jlong magic_const;\n+    jint shift_const;\n+    bool magic_const_ovf;\n+    magic_long_unsigned_divide_constants(divisor, magic_const, shift_const, magic_const_ovf);\n+\n+    Node *magic = phase->longcon(magic_const);\n+    \/\/ Compute the high half of the dividend x magic multiplication\n+    Node *mul_hi = phase->transform(new UMulHiLNode(dividend, magic));\n+\n+    if (!magic_const_ovf) {\n+      \/\/ No overflow here, just shift the result\n+      q = new URShiftLNode(mul_hi, phase->intcon(shift_const));\n+    } else {\n+      \/\/ If the multiplication does not overflow 128-bit unsigned int, we can\n+      \/\/ do the addition right after\n+      const TypeLong* dividend_type = phase->type(dividend)->is_long();\n+      julong max_dividend;\n+      if (dividend_type->_hi < 0 || dividend_type->_lo >= 0) {\n+        max_dividend = julong(dividend_type->_hi);\n+      } else {\n+        max_dividend = max_julong;\n@@ -442,3 +660,21 @@\n-      \/\/ Adjust the final quotient by subtracting -1 (adding 1)\n-      \/\/ from the mul_hi.\n-      q = new SubLNode(addend0, addend1);\n+      \/\/ Just do the minimum for now\n+      if (max_dividend <= julong(min_jlong) || shift_const == 0) {\n+        \/\/ Add back the dividend\n+        mul_hi = phase->transform(new AddLNode(mul_hi, dividend));\n+        \/\/ Shift the result\n+        q = new URShiftLNode(mul_hi, phase->intcon(shift_const));\n+      } else {\n+        \/\/ q = floor((x * c) \/ 2**(64 + m)) = floor(((x * (c - 2**64)) \/ 2**64 + x) \/ 2**m)\n+        \/\/\n+        \/\/ Given: floor((x \/ m + y) \/ n) = floor((floor(x \/ m) + y) \/ n), we have\n+        \/\/ q = floor((floor((x * (c - 2**64)) \/ 2**64) + x) \/ 2**m)\n+        \/\/   = floor((mul_hi + x) \/ 2**m)\n+        \/\/ Let p = floor((mul_hi + x) \/ 2)\n+        \/\/       = floor((x - mul_hi) \/ 2 + mul_hi)\n+        \/\/       = floor((x - mul_hi) \/ 2) + mul_hi\n+        \/\/ Since x > mul_hi, this operation can be done precisely using Z\/2**64Z arithmetic\n+        Node* diff = phase->transform(new SubLNode(dividend, mul_hi));\n+        diff = phase->transform(new URShiftLNode(diff, phase->intcon(1)));\n+        Node* p = phase->transform(new AddLNode(diff, mul_hi));\n+        q = new URShiftLNode(p, phase->intcon(shift_const - 1));\n+      }\n@@ -855,2 +1091,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n@@ -865,5 +1101,7 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeInt* i1 = t1->isa_int();\n+  const TypeInt* i2 = t2->isa_int();\n+  assert(i1 != nullptr && i2 != nullptr, \"\");\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) \/ juint(i2->get_con()));\n+  }\n@@ -876,1 +1114,1 @@\n-Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* UDivINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -879,1 +1117,36 @@\n-  return NULL;\n+  \/\/ Don't bother trying to transform a dead node\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n+\n+  const Type* t = phase->type( in(2) );\n+  if( t == TypeInt::ONE )       \/\/ Identity?\n+    return nullptr;             \/\/ Skip it\n+\n+  const TypeInt *ti = t->isa_int();\n+  if( !ti ) return nullptr;\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);           \/\/ Yank control input\n+    return this;\n+  }\n+\n+  \/\/ Divisor very large, constant 2**31 can be transform to a shift\n+  if (ti->_hi <= 0 && ti->_hi > min_jint) {\n+    Node* cmp = phase->transform(new CmpUNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveINode(bol, phase->intcon(0), phase->intcon(1), TypeInt::BOOL);\n+  }\n+\n+  if( !ti->is_con() ) return nullptr;\n+  juint i = ti->get_con();       \/\/ Get divisor\n+\n+  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+\n+  \/\/ Don't transform a constant-foldable\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_int() || u->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  return transform_int_udivide( phase, in(1), i );\n@@ -894,2 +1167,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n@@ -904,5 +1177,7 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  \/\/ TODO: Improve Value inference of both signed and unsigned division\n+  const TypeLong* i1 = t1->isa_long();\n+  const TypeLong* i2 = t2->isa_long();\n+  assert(i1 != nullptr && i2 != nullptr, \"\");\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) \/ julong(i2->get_con()));\n+  }\n@@ -915,1 +1190,1 @@\n-Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* UDivLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -918,2 +1193,16 @@\n-  return NULL;\n-}\n+  \/\/ Don't bother trying to transform a dead node\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n+\n+  const Type* t = phase->type( in(2) );\n+  if( t == TypeLong::ONE )       \/\/ Identity?\n+    return nullptr;             \/\/ Skip it\n+\n+  const TypeLong* ti = t->isa_long();\n+  if( !ti ) return nullptr;\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding div-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);           \/\/ Yank control input\n+    return this;\n+  }\n@@ -921,0 +1210,20 @@\n+  \/\/ Divisor very large, constant 2**63 can be transform to a shift\n+  if (ti->_hi <= 0 && ti->_hi > min_jlong) {\n+    Node* cmp = phase->transform(new CmpULNode(in(1), in(2)));\n+    Node* bol = phase->transform(new BoolNode(cmp, BoolTest::ge));\n+    return new CMoveLNode(bol, phase->longcon(0), phase->longcon(1), TypeLong::make(0, 1, Type::WidenMin));\n+  }\n+\n+  if( !ti->is_con() ) return nullptr;\n+  julong i = ti->get_con();       \/\/ Get divisor\n+\n+  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n+\n+  \/\/ Don't transform a constant-foldable\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_long() || u->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  return transform_long_udivide( phase, in(1), i );\n+}\n@@ -1086,8 +1395,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return NULL;\n-}\n-\n@@ -1260,0 +1561,127 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node* UModINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n+\n+  \/\/ Get the modulus\n+  const Type* t = phase->type( in(2) );\n+  if( t == Type::TOP ) return nullptr;\n+  const TypeInt* ti = t->is_int();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);        \/\/ Yank control input\n+    return this;\n+  }\n+\n+  if( !ti->is_con() ) return nullptr;\n+  juint con = ti->get_con();\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_int() || u->is_int()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ See if we are MOD'ing by 2^k\n+  if (is_power_of_2(con)) {\n+    return new AndINode(in(1), phase->intcon(con - 1));\n+  }\n+  Node* q = transform_int_udivide(phase, in(1), con);\n+  if (q == nullptr) {\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulINode(q, phase->intcon(con)));\n+  return new SubINode(in(1), mul);\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* UModINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeInt::ONE) {\n+    return TypeInt::ZERO;\n+  }\n+\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeInt::make(juint(i1->get_con()) % juint(i2->get_con()));\n+  }\n+\n+  return TypeInt::INT;\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n+\n+  \/\/ Get the modulus\n+  const Type *t = phase->type( in(2) );\n+  if( t == Type::TOP ) return nullptr;\n+  const TypeLong *ti = t->is_long();\n+\n+  \/\/ Check for useless control input\n+  \/\/ Check for excluding mod-zero case\n+  if (in(0) && (ti->_hi < 0 || ti->_lo > 0)) {\n+    set_req(0, nullptr);        \/\/ Yank control input\n+    return this;\n+  }\n+\n+  if( !ti->is_con() ) return nullptr;\n+  julong con = ti->get_con();\n+  const Type* u = phase->type(in(1));\n+  if (!u->isa_long() || u->is_long()->is_con()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ See if we are MOD'ing by 2^k\n+  if (is_power_of_2(con)) {\n+    return new AndLNode(in(1), phase->longcon(con - 1));\n+  }\n+  Node* q = transform_long_udivide(phase, in(1), con);\n+  if (q == nullptr) {\n+    return nullptr;\n+  }\n+  q = phase->transform(q);\n+  Node* mul = phase->transform(new MulLNode(q, phase->longcon(con)));\n+  return new SubLNode(in(1), mul);\n+}\n+\n+\/\/------------------------------Value------------------------------------------\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type( in(1) );\n+  const Type* t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x % x = 0, x % 1 = 0\n+  if (in(1) == in(2) || t2 == TypeLong::ONE) {\n+    return TypeLong::ZERO;\n+  }\n+\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n+\n+  \/\/ constant fold\n+  if (i1->is_con() && i2->is_con()) {\n+    return TypeLong::make(julong(i1->get_con()) % julong(i2->get_con()));\n+  }\n+\n+  return TypeLong::LONG;\n+}\n@@ -1304,9 +1732,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  \/\/ Check for dead control input\n-  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n-  return NULL;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":529,"deletions":110,"binary":false,"changes":639,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModINode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -171,2 +171,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n@@ -180,1 +181,1 @@\n-  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  UModLNode( Node* c, Node* in1, Node* in2 ) : Node(c, in1, in2) {}\n@@ -182,2 +183,3 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                 \"magicDiv\"})\n+                 \"magicDiv13\", \"magicDiv7\"})\n@@ -92,1 +92,2 @@\n-        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+        Asserts.assertEQ(a \/ 13       , magicDiv13(a));\n+        Asserts.assertEQ(a \/ 7        , magicDiv7(a));\n@@ -199,4 +200,2 @@\n-    \/\/ More tests can be made to cover the specific cases for differences in the\n-    \/\/ graph that depend upon different values for the \"magic constant\" and the\n-    \/\/ \"shift constant\"\n-    public int magicDiv(int x) {\n+    \/\/ The constant derived from 13 lies inside the limit of an i32\n+    public int magicDiv13(int x) {\n@@ -205,0 +204,14 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an i32 but inside the limit\n+    \/\/ of a u32\n+    public int magicDiv7(int x) {\n+        return x \/ 7;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.bits == 64\n@@ -42,1 +43,2 @@\n-                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n+                 \"magicDiv19\", \"magicDiv15\"})\n@@ -91,0 +93,2 @@\n+        Asserts.assertEQ(a \/ 19       , magicDiv19(a));\n+        Asserts.assertEQ(a \/ 15       , magicDiv15(a));\n@@ -190,0 +194,26 @@\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"1\",\n+                  IRNode.MUL_HI_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an i64\n+    public long magicDiv19(long x) {\n+        return x \/ 19L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\",\n+                  IRNode.RSHIFT_L, \"2\",\n+                  IRNode.MUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 15 lies outside the limit of an i64 but inside the limit\n+    \/\/ of a u64\n+    public long magicDiv15(long x) {\n+        return x \/ 15L;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivINode and UModINode are\n+ * being performed as expected.\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivINodeIdealizationTests\n+ *\/\n+public class UDivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisor\",\n+                 \"magicDiv13\", \"magicDiv7\",\n+                \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod13\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public int udiv(int a, int b) {\n+        return Integer.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public int umod(int a, int b) {\n+        return Integer.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(1, constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(0, constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a           , identity(a));\n+        Asserts.assertEQ(a           , identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8) , divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7) , largeDivisor(a));\n+        Asserts.assertEQ(udiv(a, 13), magicDiv13(a));\n+        Asserts.assertEQ(udiv(a, 7) , magicDiv7(a));\n+        Asserts.assertEQ(umod(a, 1) , constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8) , modByPow2(a));\n+        Asserts.assertEQ(umod(a, 13), magicMod13(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constantDiv(int x) {\n+        return Integer.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return Integer.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return Integer.divideUnsigned(x, Integer.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_I, \"1\",\n+                  IRNode.UDIV_I, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return Integer.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public int divByPow2(int x) {\n+        return Integer.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.CMP_U, \"1\",\n+                  IRNode.CMOVEI, \"1\"\n+                 })\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public int largeDivisor(int x) {\n+        return Integer.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of a u32\n+    public int magicDiv13(int x) {\n+        return Integer.divideUnsigned(x, 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of a u32 but inside the limit\n+    \/\/ of a u33\n+    public int magicDiv7(int x) {\n+        return Integer.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public int constantMod(int x) {\n+        return Integer.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    \/\/ Checks x % 1 => 0\n+    public int constantModAgain(int x) {\n+        return Integer.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.AND_I, \"1\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public int modByPow2(int x) {\n+        return Integer.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_I})\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.URSHIFT_L, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                  IRNode.MUL_I, \"1\",\n+                  IRNode.SUB_I, \"1\"\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 13 lies inside the limit of an u32\n+    public int magicMod13(int x) {\n+        return Integer.remainderUnsigned(x, 13);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivINodeIdealizationTests.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282365\n+ * @summary Test that Ideal transformations of UDivLNode and UModLNode are\n+ * being performed as expected.\n+ *\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.UDivLNodeIdealizationTests\n+ *\/\n+public class UDivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constantDiv\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByPow2\", \"largeDivisor\",\n+                 \"magicDiv19\", \"magicDiv7\",\n+                 \"constantMod\", \"constantModAgain\", \"modByPow2\", \"magicMod19\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public long udiv(long a, long b) {\n+        return Long.divideUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public long umod(long a, long b) {\n+        return Long.remainderUnsigned(a, b);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(udiv(a, a), constantDiv(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(udiv(a * b, b), retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a, identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(umod(a, a), constantMod(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a           , identity(a));\n+        Asserts.assertEQ(a           , identityAgain(a));\n+        Asserts.assertEQ(udiv(a, 8) , divByPow2(a));\n+        Asserts.assertEQ(udiv(a, -7) , largeDivisor(a));\n+        Asserts.assertEQ(udiv(a, 19), magicDiv19(a));\n+        Asserts.assertEQ(udiv(a, 7) , magicDiv7(a));\n+        Asserts.assertEQ(umod(a, 1) , constantModAgain(a));\n+        Asserts.assertEQ(umod(a, 8) , modByPow2(a));\n+        Asserts.assertEQ(umod(a, 19), magicMod19(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constantDiv(long x) {\n+        return Long.divideUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return Long.divideUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(13, 13));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return Long.divideUnsigned(x, Long.divideUnsigned(y, y));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.UDIV_L, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return Long.divideUnsigned(x * y, y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"})\n+    \/\/ Checks x \/ 2^c0 => x >>> c0\n+    public long divByPow2(long x) {\n+        return Long.divideUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.CMP_UL, \"1\",\n+                  IRNode.CMOVEL, \"1\"\n+                 })\n+    \/\/ Checks x \/ d => x u>= d ? 1 : 0 for large d\n+    public long largeDivisor(long x) {\n+        return Long.divideUnsigned(x, -7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an u64\n+    public long magicDiv19(long x) {\n+        return Long.divideUnsigned(x, 19);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UDIV_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"2\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.ADD_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 7 lies outside the limit of an u64 but inside the limit\n+    \/\/ of a u65\n+    public long magicDiv7(long x) {\n+        return Long.divideUnsigned(x, 7);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x % x => 0\n+    public long constantMod(long x) {\n+        return Long.remainderUnsigned(x, x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    \/\/ Checks x % 1 => 0\n+    public long constantModAgain(long x) {\n+        return Long.remainderUnsigned(x, 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.AND_L, \"1\"})\n+    \/\/ Checks x % 2^c0 => x & (2^c0 - 1)\n+    public long modByPow2(long x) {\n+        return Long.remainderUnsigned(x, 8);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.UMOD_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\",\n+                  IRNode.UMUL_HI_L, \"1\",\n+                  IRNode.MUL_L, \"1\",\n+                  IRNode.SUB_L, \"1\"\n+                 })\n+    \/\/ Checks magic long division occurs in general when dividing by a non power of 2.\n+    \/\/ The constant derived from 19 lies inside the limit of an u64\n+    public long magicMod19(long x) {\n+        return Long.remainderUnsigned(x, 19);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/UDivLNodeIdealizationTests.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -145,0 +145,1 @@\n+    public static final String CMOVEL = START + \"CMoveL\" + MID + END;\n@@ -183,0 +184,2 @@\n+    public static final String MUL_HI_L = START + \"MulHiL\" + MID + END;\n+    public static final String UMUL_HI_L = START + \"UMulHiL\" + MID + END;\n@@ -185,0 +188,4 @@\n+    public static final String UDIV_I = START + \"UDivI\" + MID + END;\n+    public static final String UDIV_L = START + \"UDivL\" + MID + END;\n+    public static final String UMOD_I = START + \"UModI\" + MID + END;\n+    public static final String UMOD_L = START + \"UModL\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,5 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n-    @Param({\"mixed\", \"positive\", \"negative\"})\n-    String divisorType;\n@@ -66,1 +60,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGenerator.getDefault();\n@@ -70,3 +64,1 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n-            divisors[i] = divisor;\n+            divisors[i] = divisor == 0 ? 1 : divisor;\n@@ -93,1 +85,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            int dividend = dividends[i];\n+            int divisor = divisors[i];\n+            quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+            remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n@@ -97,3 +92,5 @@\n-    public void divmod(int dividend, int divisor, int i) {\n-        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n-        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = dividends[i] \/ 7;\n+        }\n@@ -102,3 +99,6 @@\n-}\n-\n-\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -106,0 +106,7 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.util.random.RandomGenerator;\n+import java.util.concurrent.TimeUnit;\n+\n@@ -37,4 +40,0 @@\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-import java.util.concurrent.TimeUnit;\n-\n@@ -51,5 +50,0 @@\n-\n-    RandomGenerator randomGenerator;\n-\n-    @Param({\"mixed\", \"positive\", \"negative\"})\n-    String divisorType;\n@@ -66,1 +60,1 @@\n-        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        var rng = RandomGenerator.getDefault();\n@@ -70,3 +64,1 @@\n-            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n-            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n-            divisors[i] = divisor;\n+            divisors[i] = divisor == 0 ? 1 : divisor;\n@@ -93,1 +85,4 @@\n-            divmod(dividends[i], divisors[i], i);\n+            long dividend = dividends[i];\n+            long divisor = divisors[i];\n+            quotients[i] = Long.divideUnsigned(dividend, divisor);\n+            remainders[i] = Long.remainderUnsigned(dividend, divisor);\n@@ -97,3 +92,5 @@\n-    public void divmod(long dividend, long divisor, int i) {\n-        quotients[i] = Long.divideUnsigned(dividend, divisor);\n-        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    @Benchmark\n+    public void testDivideUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], 7);\n+        }\n@@ -102,0 +99,6 @@\n+    @Benchmark\n+    public void testRemainderUnsignedConstant() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], 7);\n+        }\n+    }\n@@ -103,3 +106,0 @@\n-\n-\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"}]}