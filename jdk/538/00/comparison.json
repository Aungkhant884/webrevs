{"files":[{"patch":"@@ -2912,0 +2912,10 @@\n+operand immU7()\n+%{\n+  predicate((0 <= n->get_int()) && (n->get_int() <= 0x7F));\n+  match(ConI);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -11746,1 +11756,1 @@\n-instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)\n+instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU7 imm, immI0 zero)\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- * @bug 8204479\n- * @summary Bitwise AND on byte value sometimes produces wrong result\n+ * @bug 8204479 8253191\n@@ -29,3 +28,4 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation\n- *      -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -Xcomp -XX:-Inline\n- *      compiler.c2.TestUnsignedByteCompare\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation compiler.c2.TestUnsignedByteCompare\n@@ -33,1 +33,0 @@\n-\n@@ -36,0 +35,4 @@\n+import java.lang.invoke.*;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.test.lib.Asserts;\n+\n@@ -38,1 +41,6 @@\n-    static int p, n;\n+    @DontInline static boolean testByteGT0(byte[] val) { return (val[0] & mask()) >  0; }\n+    @DontInline static boolean testByteGE0(byte[] val) { return (val[0] & mask()) >= 0; }\n+    @DontInline static boolean testByteEQ0(byte[] val) { return (val[0] & mask()) == 0; }\n+    @DontInline static boolean testByteNE0(byte[] val) { return (val[0] & mask()) != 0; }\n+    @DontInline static boolean testByteLE0(byte[] val) { return (val[0] & mask()) <= 0; }\n+    @DontInline static boolean testByteLT0(byte[] val) { return (val[0] & mask()) <  0; }\n@@ -40,3 +48,8 @@\n-    static void report(byte[] ba, int i, boolean failed) {\n-        \/\/ Enable for debugging:\n-        \/\/ System.out.println((failed ? \"Failed\" : \"Passed\") + \" with: \" + ba[i] + \" at \" + i);\n+    static void testValue(byte b) {\n+        byte[] bs = new byte[] { b };\n+        Asserts.assertEquals(((b & mask()) >  0), testByteGT0(bs), errorMessage(b, \"GT0\"));\n+        Asserts.assertEquals(((b & mask()) >= 0), testByteGE0(bs), errorMessage(b, \"GE0\"));\n+        Asserts.assertEquals(((b & mask()) == 0), testByteEQ0(bs), errorMessage(b, \"EQ0\"));\n+        Asserts.assertEquals(((b & mask()) != 0), testByteNE0(bs), errorMessage(b, \"NE0\"));\n+        Asserts.assertEquals(((b & mask()) <= 0), testByteLE0(bs), errorMessage(b, \"LE0\"));\n+        Asserts.assertEquals(((b & mask()) <  0), testByteLT0(bs), errorMessage(b, \"LT0\"));\n@@ -45,8 +58,5 @@\n-    static void m1(byte[] ba) {\n-        for (int i = 0; i < ba.length; i++) {\n-            if ((ba[i] & 0xFF) < 0x10) {\n-               p++;\n-               report(ba, i, true);\n-            } else {\n-               n++;\n-               report(ba, i, false);\n+    public static void main(String[] args) {\n+        for (int mask = 0; mask <= 0xFF; mask++) {\n+            setMask(mask);\n+            for (int i = 0; i < 20_000; i++) {\n+                testValue((byte) i);\n@@ -55,0 +65,1 @@\n+        System.out.println(\"TEST PASSED\");\n@@ -57,10 +68,2 @@\n-    static void m2(byte[] ba) {\n-        for (int i = 0; i < ba.length; i++) {\n-            if (((ba[i] & 0xFF) & 0x80) < 0) {\n-               p++;\n-               report(ba, i, true);\n-            } else {\n-               n++;\n-               report(ba, i, false);\n-            }\n-        }\n+    static String errorMessage(byte b, String type) {\n+        return String.format(\"%s: val=0x%x mask=0x%x\", type, b, mask());\n@@ -69,3 +72,1 @@\n-    static public void main(String[] args) {\n-        final int tries = 1_000;\n-        final int count = 1_000;\n+    \/\/ Mutable mask as a compile-time constant.\n@@ -73,1 +74,2 @@\n-        byte[] ba = new byte[count];\n+    private static final CallSite     MASK_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle MASK_MH = MASK_CS.dynamicInvoker();\n@@ -75,10 +77,5 @@\n-        for (int i = 0; i < count; i++) {\n-            int v = -(i % 126 + 1);\n-            ba[i] = (byte)v;\n-        }\n-\n-        for (int t = 0; t < tries; t++) {\n-            m1(ba);\n-            if (p != 0) {\n-                throw new IllegalStateException(\"m1 error: p = \" + p + \", n = \" + n);\n-            }\n+    static int mask() {\n+        try {\n+            return (int) MASK_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n@@ -86,0 +83,1 @@\n+    }\n@@ -87,6 +85,3 @@\n-        for (int t = 0; t < tries; t++) {\n-            m2(ba);\n-            if (p != 0) {\n-                throw new IllegalStateException(\"m2 error: p = \" + p + \", n = \" + n);\n-            }\n-        }\n+    static void setMask(int mask) {\n+        MethodHandle constant = MethodHandles.constant(int.class, mask);\n+        MASK_CS.setTarget(constant);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnsignedByteCompare.java","additions":44,"deletions":49,"binary":false,"changes":93,"status":"modified"}]}