{"files":[{"patch":"@@ -368,5 +368,26 @@\n- * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n- * list or with an empty formal parameter list) are not supported directly by the native linker. However, it is still possible\n- * to link a variadic function by using a <em>specialized<\/em> function descriptor, together with a\n- * {@linkplain Linker.Option#firstVariadicArg(int) a linker option} which indicates the position of the first variadic argument\n- * in that specialized descriptor.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n+ * <ol>\n+ * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n+ * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n+ * <\/ol>\n+ * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n+ * <em>variadic arguments<\/em>.\n+ * <p>\n+ * The native linker does not support linking variadic functions in a way where it is possible to pass an arbitrary set\n+ * of variadic arguments to the resulting method handle, since the linker needs to know the memory layouts of all the arguments\n+ * up front in order to complete the linking process. However, it is still possible to link a variadic function by using\n+ * a <em>specialized<\/em> function descriptor. A specialized function descriptor describes a variadic function with a fixed\n+ * number and type(s) of variadic arguments. The index of the first variadic argument in the argument list should be indicated\n+ * using the {@link Linker.Option#firstVariadicArg(int)} linker option. The corresponding argument layout, and all following\n+ * argument layouts in the specialized function descriptor, are called <em>variadic argument layouts<\/em>. For a\n+ * prototype-less function, the index passed to {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * <p>\n+ * It should be noted that values passed as variadic arguments undergo default argument promotion in C. Each value of\n+ * type {@code float} is converted to {@code double}, and each value of an integral type undergoes integer promotion (which\n+ * is discussed in detail in the C specification). The native linker will automatically apply argument conversions when needed.\n+ * Exactly which variadic arguments the conversions are applied to is platform-dependent. As an example, on Linux\/x64 the\n+ * following conversions are applied:\n+ * <ul>\n+ * <li>arguments with a Java type of {@code boolean}, {@code byte}, {@code char}, or {@code short}, are converted to {@code int}<\/li>\n+ * <li>arguments with a Java type of {@code float}, are converted to {@code double}<\/li>\n+ * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n@@ -92,0 +95,2 @@\n+        FunctionDescriptor unPromotedDesc = function;\n+        function = promoteVariadicArgs(function, firstVariadicArgIndex(options)); \/\/ the erased version can be shared\n@@ -94,1 +99,1 @@\n-        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n+        MethodHandle mh = DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n@@ -101,0 +106,2 @@\n+\n+        return unpromoteVariadicArgs(mh, unPromotedDesc, optionSet);\n@@ -185,0 +192,1 @@\n+\n@@ -192,1 +200,0 @@\n-\n@@ -195,0 +202,1 @@\n+\n@@ -203,1 +211,0 @@\n-\n@@ -241,0 +248,86 @@\n+\n+    private static int firstVariadicArgIndex(Option[] options) {\n+        for (Option option : options) {\n+            if (option instanceof LinkerOptions.FirstVariadicArg fva) {\n+                return fva.index();\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    private static FunctionDescriptor promoteVariadicArgs(FunctionDescriptor function, int firstVariadicArgIndex) {\n+        if (firstVariadicArgIndex != -1) {\n+            MemoryLayout[] promotedLayouts = function.argumentLayouts().toArray(MemoryLayout[]::new);\n+\n+            for (int i = firstVariadicArgIndex; i < promotedLayouts.length; i++) {\n+                MemoryLayout variadicLayout = promotedLayouts[i];\n+\n+                if (variadicLayout instanceof ValueLayout vl) {\n+                    if (requiresVariadicIntPromotion(vl)) {\n+                        promotedLayouts[i] = JAVA_INT;\n+                    } else if (requiresVariadicFloatPromotion(vl)) {\n+                        promotedLayouts[i] = JAVA_DOUBLE;\n+                    }\n+                }\n+            }\n+\n+            function = function.returnLayout()\n+                    .map(rl -> FunctionDescriptor.of(rl, promotedLayouts))\n+                    .orElseGet(() -> FunctionDescriptor.ofVoid(promotedLayouts));\n+        }\n+\n+        return function;\n+    }\n+\n+    private static MethodHandle unpromoteVariadicArgs(MethodHandle mh, FunctionDescriptor unPromotedDesc, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            Class<?>[] unpromotedParams = mh.type().parameterArray();\n+            List<MemoryLayout> unpromotedLayouts = unPromotedDesc.argumentLayouts();\n+            int numPrefixArgs = downcallNumPrefixArgs(unPromotedDesc, optionSet);\n+            assert unpromotedLayouts.size() + numPrefixArgs == unpromotedParams.length;\n+\n+            for (int i = optionSet.firstVariadicArgIndex(); i < unpromotedLayouts.size(); i++) {\n+                MemoryLayout variadicLayout = unpromotedLayouts.get(i);\n+                if (variadicLayout instanceof ValueLayout vl) {\n+                    if (requiresVariadicPromotion(vl)) {\n+                        unpromotedParams[numPrefixArgs + i] = vl.carrier();\n+                    }\n+                }\n+            }\n+\n+            MethodType unpromotedType = MethodType.methodType(mh.type().returnType(), unpromotedParams);\n+            mh = mh.asType(unpromotedType);\n+        }\n+\n+        return mh;\n+    }\n+\n+    private static int downcallNumPrefixArgs(FunctionDescriptor descriptor, LinkerOptions options) {\n+        int result = 1; \/\/ target address\n+        if (SharedUtils.returnsGroupLayout(descriptor)) {\n+            result++; \/\/ SegmentAllocator\n+        }\n+        if (options.hasCapturedCallState()) {\n+            result++;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ For now all of these are the same for every implementation\n+    \/\/ in the future we might need to make one of them abstract\n+    \/\/ and implement on a per-linker basis.\n+    private static boolean requiresVariadicIntPromotion(ValueLayout vl) {\n+        return vl.carrier() == boolean.class || vl.carrier() == byte.class\n+                    || vl.carrier() == char.class || vl.carrier() == short.class;\n+    }\n+\n+    private static boolean requiresVariadicFloatPromotion(ValueLayout vl) {\n+        return vl.carrier() == float.class;\n+    }\n+\n+    private static boolean requiresVariadicPromotion(ValueLayout vl) {\n+        return requiresVariadicIntPromotion(vl) || requiresVariadicFloatPromotion(vl);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":96,"deletions":3,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+    public int firstVariadicArgIndex() {\n+        return getOption(FirstVariadicArg.class).index();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -338,0 +338,4 @@\n+    public static boolean returnsGroupLayout(FunctionDescriptor descriptor) {\n+        return descriptor.returnLayout().isPresent() && (descriptor.returnLayout().get() instanceof GroupLayout);\n+    }\n+\n@@ -339,1 +343,1 @@\n-        if (descriptor.returnLayout().isEmpty() || !(descriptor.returnLayout().get() instanceof GroupLayout)) {\n+        if (!returnsGroupLayout(descriptor)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(inferredMethodType, function, options, Arena.ofAuto());\n@@ -110,1 +110,1 @@\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(targetType, function, options, Arena.ofAuto());\n@@ -126,1 +126,3 @@\n-    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, LinkerOptions options, Arena scope) {\n+        FFIABI abi = FFIABI.DEFAULT;\n+\n@@ -137,1 +139,8 @@\n-        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+\n+        if (options.isVariadicFunction()) {\n+            int numFixedArgs = options.firstVariadicArgIndex();\n+            int numTotalArgs = argLayouts.size();\n+            return LibFallback.prepCifVar(returnType, numFixedArgs, numTotalArgs, argTypes, abi, scope);\n+        } else {\n+            return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+        }\n@@ -247,1 +256,1 @@\n-            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -107,0 +107,21 @@\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif_var}. The variadic version of prep_cif\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numFixedArgs the number of fixed arguments\n+     * @param numTotalArgs the number of total arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCifVar(MemorySegment returnType, int numFixedArgs, int numTotalArgs, MemorySegment paramTypes, FFIABI abi,\n+                                    Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(NativeConstants.SIZEOF_CIF);\n+        checkStatus(ffi_prep_cif_var(cif.address(), abi.value(), numFixedArgs, numTotalArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n@@ -180,0 +201,1 @@\n+    private static native int ffi_prep_cif_var(long cif, int abi, int nfixedargs, int ntotalargs, long rtype, long atypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif_1var(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nfixedargs, jint ntotalargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif_var(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nfixedargs, (unsigned int) ntotalargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -164,0 +165,6 @@\n+            \/\/ the test value would be automatically promoted to double\n+            \/\/ so it would not match the value we get back from native.\n+            \/\/ promote manually here to avoid that issue\n+            if (layout instanceof ValueLayout.OfFloat) {\n+                layout = C_DOUBLE; \/\/ promote to double, per C spec\n+            }\n@@ -235,1 +242,0 @@\n-            FLOAT,\n@@ -328,2 +334,1 @@\n-                    case \"float\" -> \"FLOAT\";\n-                    case \"double\" -> \"DOUBLE\";\n+                    case \"float\", \"double\" -> \"DOUBLE\"; \/\/ float is promoted\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    T_FLOAT,\n@@ -144,1 +143,0 @@\n-            CASE(T_FLOAT, double) \/\/ vararg float is promoted to double per C spec\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}