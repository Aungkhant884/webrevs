{"files":[{"patch":"@@ -368,5 +368,22 @@\n- * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n- * list or with an empty formal parameter list) are not supported directly by the native linker. However, it is still possible\n- * to link a variadic function by using a <em>specialized<\/em> function descriptor, together with a\n- * {@linkplain Linker.Option#firstVariadicArg(int) a linker option} which indicates the position of the first variadic argument\n- * in that specialized descriptor.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n+ * <ol>\n+ * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n+ * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n+ * <\/ol>\n+ * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n+ * <em>variadic arguments<\/em>.\n+ * <p>\n+ * The native linker does not support linking variadic functions in a way where it is possible to pass an arbitrary set\n+ * of variadic arguments to the resulting method handle, since the linker needs to know the memory layouts of all the arguments\n+ * up front in order to complete the linking process. However, it is still possible to link a variadic function by using\n+ * a <em>specialized<\/em> function descriptor. A specialized function descriptor describes a variadic function with a fixed\n+ * number and type(s) of variadic arguments. The index of the first variadic argument in the argument list should be indicated\n+ * using the {@link Linker.Option#firstVariadicArg(int)} linker option. The corresponding argument layout, and all following\n+ * argument layouts in the specialized function descriptor, are called <em>variadic argument layouts<\/em>. For a\n+ * prototype-less function, the index passed to {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * <p>\n+ * It should be noted that values passed as variadic arguments undergo default argument promotion in C. Each value of\n+ * type {@code float} is converted to {@code double}, and each integral type smaller than {@code int} is converted to\n+ * {@code int}. As such, the native linker will reject attempts to link function descriptors with certain variadic argument\n+ * layouts. Namely, {@linkplain ValueLayout value layouts} that have a carrier type of {@code boolean}, {@code byte},\n+ * {@code char}, {@code short}, or {@code float}, are not allowed to be used as variadic argument layouts.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        validateVariadicLayouts(function, optionSet);\n@@ -137,0 +138,21 @@\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    private void validateVariadicLayouts(FunctionDescriptor function, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            List<MemoryLayout> argumentLayouts = function.argumentLayouts();\n+            List<MemoryLayout> variadicLayouts = argumentLayouts.subList(optionSet.firstVariadicArgIndex(), argumentLayouts.size());\n+\n+            for (MemoryLayout variadicLayout : variadicLayouts) {\n+                if (variadicLayout instanceof ValueLayout vl\n+                        && (vl.carrier() == boolean.class\n+                            || vl.carrier() == byte.class\n+                            || vl.carrier() == char.class\n+                            || vl.carrier() == short.class\n+                            || vl.carrier() == float.class)) {\n+                    throw new IllegalArgumentException(\"Invalid variadic argument layout: \" + variadicLayout);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+    public int firstVariadicArgIndex() {\n+        return getOption(FirstVariadicArg.class).index();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(inferredMethodType, function, options, Arena.ofAuto());\n@@ -110,1 +110,1 @@\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(targetType, function, options, Arena.ofAuto());\n@@ -126,1 +126,3 @@\n-    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, LinkerOptions options, Arena scope) {\n+        FFIABI abi = FFIABI.DEFAULT;\n+\n@@ -137,1 +139,8 @@\n-        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+\n+        if (options.isVariadicFunction()) {\n+            int numFixedArgs = options.firstVariadicArgIndex();\n+            int numTotalArgs = argLayouts.size();\n+            return LibFallback.prepCifVar(returnType, numFixedArgs, numTotalArgs, argTypes, abi, scope);\n+        } else {\n+            return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -107,0 +107,21 @@\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif_var}. The variadic version of prep_cif\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numFixedArgs the number of fixed arguments\n+     * @param numTotalArgs the number of total arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCifVar(MemorySegment returnType, int numFixedArgs, int numTotalArgs, MemorySegment paramTypes, FFIABI abi,\n+                                    Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(NativeConstants.SIZEOF_CIF);\n+        checkStatus(ffi_prep_cif_var(cif.address(), abi.value(), numFixedArgs, numTotalArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n@@ -180,0 +201,1 @@\n+    private static native int ffi_prep_cif_var(long cif, int abi, int nfixedargs, int ntotalargs, long rtype, long atypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif_1var(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nfixedargs, jint ntotalargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif_var(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nfixedargs, (unsigned int) ntotalargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,7 +381,4 @@\n-\n-        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> {\n-            return arena.allocateUtf8String(\"str\");\n-        }, \"str\"),\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n+        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.function.BiConsumer;\n@@ -63,1 +64,1 @@\n-    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, Linker.Option[] options, String expectedExceptionMessage) {\n@@ -65,1 +66,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc, options);\n@@ -111,0 +112,1 @@\n+        Linker.Option[] NO_OPTIONS = new Linker.Option[0];\n@@ -114,0 +116,1 @@\n+                    NO_OPTIONS,\n@@ -118,0 +121,1 @@\n+                    NO_OPTIONS,\n@@ -122,0 +126,1 @@\n+                    NO_OPTIONS,\n@@ -126,0 +131,1 @@\n+                    NO_OPTIONS,\n@@ -130,0 +136,1 @@\n+                    NO_OPTIONS,\n@@ -138,0 +145,1 @@\n+                    NO_OPTIONS,\n@@ -147,0 +155,1 @@\n+                    NO_OPTIONS,\n@@ -154,0 +163,1 @@\n+                    NO_OPTIONS,\n@@ -161,0 +171,1 @@\n+                    NO_OPTIONS,\n@@ -165,0 +176,1 @@\n+                    NO_OPTIONS,\n@@ -169,0 +181,1 @@\n+                    NO_OPTIONS,\n@@ -173,0 +186,1 @@\n+                    NO_OPTIONS,\n@@ -179,0 +193,1 @@\n+                    NO_OPTIONS,\n@@ -185,0 +200,1 @@\n+                    NO_OPTIONS,\n@@ -189,0 +205,8 @@\n+        for (ValueLayout illegalLayout : List.of(C_CHAR, ValueLayout.JAVA_CHAR, C_BOOL, C_SHORT, C_FLOAT)) {\n+            cases.add(new Object[]{\n+                FunctionDescriptor.ofVoid(C_INT, illegalLayout),\n+                new Linker.Option[]{Linker.Option.firstVariadicArg(1)},\n+                \"Invalid variadic argument layout\"\n+            });\n+        }\n+\n@@ -195,0 +219,1 @@\n+                    NO_OPTIONS,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n+                                                                 C_DOUBLE, C_INT, C_DOUBLE, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3D, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -164,0 +165,3 @@\n+            if (layout instanceof ValueLayout.OfFloat) {\n+                layout = C_DOUBLE; \/\/ promote to double, per C spec\n+            }\n@@ -235,1 +239,0 @@\n-            FLOAT,\n@@ -328,1 +331,1 @@\n-                    case \"float\" -> \"FLOAT\";\n+                    case \"float\" -> \"DOUBLE\"; \/\/ promote\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    T_FLOAT,\n@@ -144,1 +143,0 @@\n-            CASE(T_FLOAT, double) \/\/ vararg float is promoted to double per C spec\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}