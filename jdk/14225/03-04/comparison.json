{"files":[{"patch":"@@ -386,4 +386,8 @@\n- * type {@code float} is converted to {@code double}, and each integral type smaller than {@code int} is converted to\n- * {@code int}. As such, the native linker will reject attempts to link function descriptors with certain variadic argument\n- * layouts. Namely, {@linkplain ValueLayout value layouts} that have a carrier type of {@code boolean}, {@code byte},\n- * {@code char}, {@code short}, or {@code float}, are not allowed to be used as variadic argument layouts.\n+ * type {@code float} is converted to {@code double}, and each value of an integral type undergoes integer promotion (which\n+ * is discussed in detail in the C specification). The native linker will automatically apply argument conversions when needed.\n+ * Exactly which variadic arguments the conversions are applied to is platform-dependent. As an example, on Linux\/x64 the\n+ * following conversions are applied:\n+ * <ul>\n+ * <li>arguments with a Java type of {@code boolean}, {@code byte}, {@code char}, or {@code short}, are converted to {@code int}<\/li>\n+ * <li>arguments with a Java type of {@code float}, are converted to {@code double}<\/li>\n+ * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n@@ -92,0 +95,2 @@\n+        FunctionDescriptor unPromotedDesc = function;\n+        function = promoteVariadicArgs(function, firstVariadicArgIndex(options)); \/\/ the erased version can be shared\n@@ -93,1 +98,0 @@\n-        validateVariadicLayouts(function, optionSet);\n@@ -95,1 +99,1 @@\n-        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n+        MethodHandle mh = DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n@@ -102,0 +106,2 @@\n+\n+        return unpromoteVariadicArgs(mh, unPromotedDesc, optionSet);\n@@ -138,21 +144,0 @@\n-    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n-    \/\/ and float is promoted to double\n-    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n-    private void validateVariadicLayouts(FunctionDescriptor function, LinkerOptions optionSet) {\n-        if (optionSet.isVariadicFunction()) {\n-            List<MemoryLayout> argumentLayouts = function.argumentLayouts();\n-            List<MemoryLayout> variadicLayouts = argumentLayouts.subList(optionSet.firstVariadicArgIndex(), argumentLayouts.size());\n-\n-            for (MemoryLayout variadicLayout : variadicLayouts) {\n-                if (variadicLayout instanceof ValueLayout vl\n-                        && (vl.carrier() == boolean.class\n-                            || vl.carrier() == byte.class\n-                            || vl.carrier() == char.class\n-                            || vl.carrier() == short.class\n-                            || vl.carrier() == float.class)) {\n-                    throw new IllegalArgumentException(\"Invalid variadic argument layout: \" + variadicLayout);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -207,0 +192,1 @@\n+\n@@ -214,1 +200,0 @@\n-\n@@ -217,0 +202,1 @@\n+\n@@ -225,1 +211,0 @@\n-\n@@ -263,0 +248,86 @@\n+\n+    private static int firstVariadicArgIndex(Option[] options) {\n+        for (Option option : options) {\n+            if (option instanceof LinkerOptions.FirstVariadicArg fva) {\n+                return fva.index();\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    private static FunctionDescriptor promoteVariadicArgs(FunctionDescriptor function, int firstVariadicArgIndex) {\n+        if (firstVariadicArgIndex != -1) {\n+            MemoryLayout[] promotedLayouts = function.argumentLayouts().toArray(MemoryLayout[]::new);\n+\n+            for (int i = firstVariadicArgIndex; i < promotedLayouts.length; i++) {\n+                MemoryLayout variadicLayout = promotedLayouts[i];\n+\n+                if (variadicLayout instanceof ValueLayout vl) {\n+                    if (requiresVariadicIntPromotion(vl)) {\n+                        promotedLayouts[i] = JAVA_INT;\n+                    } else if (requiresVariadicFloatPromotion(vl)) {\n+                        promotedLayouts[i] = JAVA_DOUBLE;\n+                    }\n+                }\n+            }\n+\n+            function = function.returnLayout()\n+                    .map(rl -> FunctionDescriptor.of(rl, promotedLayouts))\n+                    .orElseGet(() -> FunctionDescriptor.ofVoid(promotedLayouts));\n+        }\n+\n+        return function;\n+    }\n+\n+    private static MethodHandle unpromoteVariadicArgs(MethodHandle mh, FunctionDescriptor unPromotedDesc, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            Class<?>[] unpromotedParams = mh.type().parameterArray();\n+            List<MemoryLayout> unpromotedLayouts = unPromotedDesc.argumentLayouts();\n+            int numPrefixArgs = downcallNumPrefixArgs(unPromotedDesc, optionSet);\n+            assert unpromotedLayouts.size() + numPrefixArgs == unpromotedParams.length;\n+\n+            for (int i = optionSet.firstVariadicArgIndex(); i < unpromotedLayouts.size(); i++) {\n+                MemoryLayout variadicLayout = unpromotedLayouts.get(i);\n+                if (variadicLayout instanceof ValueLayout vl) {\n+                    if (requiresVariadicPromotion(vl)) {\n+                        unpromotedParams[numPrefixArgs + i] = vl.carrier();\n+                    }\n+                }\n+            }\n+\n+            MethodType unpromotedType = MethodType.methodType(mh.type().returnType(), unpromotedParams);\n+            mh = mh.asType(unpromotedType);\n+        }\n+\n+        return mh;\n+    }\n+\n+    private static int downcallNumPrefixArgs(FunctionDescriptor descriptor, LinkerOptions options) {\n+        int result = 1; \/\/ target address\n+        if (SharedUtils.returnsGroupLayout(descriptor)) {\n+            result++; \/\/ SegmentAllocator\n+        }\n+        if (options.hasCapturedCallState()) {\n+            result++;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ For now all of these are the same for every implementation\n+    \/\/ in the future we might need to make one of them abstract\n+    \/\/ and implement on a per-linker basis.\n+    private static boolean requiresVariadicIntPromotion(ValueLayout vl) {\n+        return vl.carrier() == boolean.class || vl.carrier() == byte.class\n+                    || vl.carrier() == char.class || vl.carrier() == short.class;\n+    }\n+\n+    private static boolean requiresVariadicFloatPromotion(ValueLayout vl) {\n+        return vl.carrier() == float.class;\n+    }\n+\n+    private static boolean requiresVariadicPromotion(ValueLayout vl) {\n+        return requiresVariadicIntPromotion(vl) || requiresVariadicFloatPromotion(vl);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":96,"deletions":25,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -338,0 +338,4 @@\n+    public static boolean returnsGroupLayout(FunctionDescriptor descriptor) {\n+        return descriptor.returnLayout().isPresent() && (descriptor.returnLayout().get() instanceof GroupLayout);\n+    }\n+\n@@ -339,1 +343,1 @@\n-        if (descriptor.returnLayout().isEmpty() || !(descriptor.returnLayout().get() instanceof GroupLayout)) {\n+        if (!returnsGroupLayout(descriptor)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,4 +381,7 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+\n+        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> {\n+            return arena.allocateUtf8String(\"str\");\n+        }, \"str\"),\n+        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import java.util.function.BiConsumer;\n@@ -64,1 +63,1 @@\n-    public void testIllegalLayouts(FunctionDescriptor desc, Linker.Option[] options, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -66,1 +65,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, desc, options);\n+            ABI.downcallHandle(DUMMY_TARGET, desc);\n@@ -112,1 +111,0 @@\n-        Linker.Option[] NO_OPTIONS = new Linker.Option[0];\n@@ -116,1 +114,0 @@\n-                    NO_OPTIONS,\n@@ -121,1 +118,0 @@\n-                    NO_OPTIONS,\n@@ -126,1 +122,0 @@\n-                    NO_OPTIONS,\n@@ -131,1 +126,0 @@\n-                    NO_OPTIONS,\n@@ -136,1 +130,0 @@\n-                    NO_OPTIONS,\n@@ -145,1 +138,0 @@\n-                    NO_OPTIONS,\n@@ -155,1 +147,0 @@\n-                    NO_OPTIONS,\n@@ -163,1 +154,0 @@\n-                    NO_OPTIONS,\n@@ -171,1 +161,0 @@\n-                    NO_OPTIONS,\n@@ -176,1 +165,0 @@\n-                    NO_OPTIONS,\n@@ -181,1 +169,0 @@\n-                    NO_OPTIONS,\n@@ -186,1 +173,0 @@\n-                    NO_OPTIONS,\n@@ -193,1 +179,0 @@\n-                    NO_OPTIONS,\n@@ -200,1 +185,0 @@\n-                    NO_OPTIONS,\n@@ -205,8 +189,0 @@\n-        for (ValueLayout illegalLayout : List.of(C_CHAR, ValueLayout.JAVA_CHAR, C_BOOL, C_SHORT, C_FLOAT)) {\n-            cases.add(new Object[]{\n-                FunctionDescriptor.ofVoid(C_INT, illegalLayout),\n-                new Linker.Option[]{Linker.Option.firstVariadicArg(1)},\n-                \"Invalid variadic argument layout\"\n-            });\n-        }\n-\n@@ -219,1 +195,0 @@\n-                    NO_OPTIONS,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-                                                                 C_DOUBLE, C_INT, C_DOUBLE, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3D, 4L);\n+                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -43,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -165,0 +165,3 @@\n+            \/\/ the test value would be automatically promoted to double\n+            \/\/ so it would not match the value we get back from native.\n+            \/\/ promote manually here to avoid that issue\n@@ -331,2 +334,1 @@\n-                    case \"float\" -> \"DOUBLE\"; \/\/ promote\n-                    case \"double\" -> \"DOUBLE\";\n+                    case \"float\", \"double\" -> \"DOUBLE\"; \/\/ float is promoted\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}