{"files":[{"patch":"@@ -412,0 +412,6 @@\n+ * <p>\n+ * It should be noted that values passed as variadic arguments undergo default argument promotion in C. Each value of\n+ * type {@code float} is converted to {@code double}, and each integral type smaller than {@code int} is converted to\n+ * {@code int}. As such, the native linker will reject attempts to link a function with variadic parameters which have\n+ * a carrier type of {@code float}, or an integral type smaller than {@code int} (including {@code boolean} and {@code char}).\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        validateVariadicLayouts(function, optionSet);\n@@ -137,0 +138,20 @@\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    private void validateVariadicLayouts(FunctionDescriptor function, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            List<MemoryLayout> argumentLayouts = function.argumentLayouts();\n+            List<MemoryLayout> variadicLayouts = argumentLayouts.subList(optionSet.firstVariadicArgIndex(), argumentLayouts.size());\n+\n+            for (MemoryLayout variadicLayout : variadicLayouts) {\n+                if (variadicLayout instanceof ValueLayout vl\n+                        && (vl.carrier() != long.class\n+                            && vl.carrier() != int.class\n+                            && vl.carrier() != double.class\n+                            && vl.carrier() != MemorySegment.class)) {\n+                    throw new IllegalArgumentException(\"Invalid variadic layout: \" + variadicLayout);\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+    public int firstVariadicArgIndex() {\n+        return getOption(FirstVariadicArg.class).index();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(inferredMethodType, function, options, Arena.ofAuto());\n@@ -110,1 +110,1 @@\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+        MemorySegment cif = makeCif(targetType, function, options, Arena.ofAuto());\n@@ -126,1 +126,3 @@\n-    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, LinkerOptions options, Arena scope) {\n+        FFIABI abi = FFIABI.DEFAULT;\n+\n@@ -137,1 +139,8 @@\n-        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+\n+        if (options.isVariadicFunction()) {\n+            int numFixedArgs = options.firstVariadicArgIndex();\n+            int numTotalArgs = argLayouts.size();\n+            return LibFallback.prepCifVar(returnType, numFixedArgs, numTotalArgs, argTypes, abi, scope);\n+        } else {\n+            return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -107,0 +107,21 @@\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif_var}. The variadic version of prep_cif\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numFixedArgs the number of fixed arguments\n+     * @param numTotalArgs the number of total arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCifVar(MemorySegment returnType, int numFixedArgs, int numTotalArgs, MemorySegment paramTypes, FFIABI abi,\n+                                    Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(NativeConstants.SIZEOF_CIF);\n+        checkStatus(ffi_prep_cif_var(cif.address(), abi.value(), numFixedArgs, numTotalArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n@@ -180,0 +201,1 @@\n+    private static native int ffi_prep_cif_var(long cif, int abi, int nfixedargs, int ntotalargs, long rtype, long atypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif_1var(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nfixedargs, jint ntotalargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif_var(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nfixedargs, (unsigned int) ntotalargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n+        CHAR(int.class, C_INT, \"%c\", arena -> (int) 'h', (int) 'h'), \/\/ promote to int, per C spec\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.function.BiConsumer;\n@@ -63,1 +64,1 @@\n-    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, Linker.Option[] options, String expectedExceptionMessage) {\n@@ -65,1 +66,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc, options);\n@@ -111,0 +112,1 @@\n+        Linker.Option[] NO_OPTIONS = new Linker.Option[0];\n@@ -114,0 +116,1 @@\n+                    NO_OPTIONS,\n@@ -118,0 +121,1 @@\n+                    NO_OPTIONS,\n@@ -122,0 +126,1 @@\n+                    NO_OPTIONS,\n@@ -126,0 +131,1 @@\n+                    NO_OPTIONS,\n@@ -130,0 +136,1 @@\n+                    NO_OPTIONS,\n@@ -138,0 +145,1 @@\n+                    NO_OPTIONS,\n@@ -147,0 +155,1 @@\n+                    NO_OPTIONS,\n@@ -154,0 +163,1 @@\n+                    NO_OPTIONS,\n@@ -161,0 +171,1 @@\n+                    NO_OPTIONS,\n@@ -165,0 +176,1 @@\n+                    NO_OPTIONS,\n@@ -169,0 +181,1 @@\n+                    NO_OPTIONS,\n@@ -173,0 +186,1 @@\n+                    NO_OPTIONS,\n@@ -179,0 +193,1 @@\n+                    NO_OPTIONS,\n@@ -185,0 +200,1 @@\n+                    NO_OPTIONS,\n@@ -189,0 +205,8 @@\n+        for (ValueLayout illegalLayout : List.of(C_CHAR, ValueLayout.JAVA_CHAR, C_BOOL, C_SHORT, C_FLOAT)) {\n+            cases.add(new Object[]{\n+                FunctionDescriptor.ofVoid(C_INT, illegalLayout),\n+                new Linker.Option[]{Linker.Option.firstVariadicArg(1)},\n+                \"Invalid variadic layout\"\n+            });\n+        }\n+\n@@ -195,0 +219,1 @@\n+                    NO_OPTIONS,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n+                                                                 C_DOUBLE, C_INT, C_DOUBLE, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3D, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -164,0 +165,3 @@\n+            if (layout instanceof ValueLayout.OfFloat) {\n+                layout = C_DOUBLE; \/\/ promote to double, per C spec\n+            }\n@@ -235,1 +239,0 @@\n-            FLOAT,\n@@ -328,1 +331,1 @@\n-                    case \"float\" -> \"FLOAT\";\n+                    case \"float\" -> \"DOUBLE\"; \/\/ promote\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    T_FLOAT,\n@@ -144,1 +143,0 @@\n-            CASE(T_FLOAT, double) \/\/ vararg float is promoted to double per C spec\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}