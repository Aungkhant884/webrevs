{"files":[{"patch":"@@ -374,1 +374,3 @@\n- * <em>variadic arguments<\/em>.\n+ * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n+ * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n+ * of a fixed number and type.\n@@ -376,14 +378,2 @@\n- * The native linker does not support linking variadic functions in a way where it is possible to pass an arbitrary set\n- * of variadic arguments to the resulting method handle, since the linker needs to know the memory layouts of all the arguments\n- * up front in order to complete the linking process. However, it is still possible to link a variadic function by using\n- * a <em>specialized<\/em> function descriptor. A specialized function descriptor describes a variadic function with a fixed\n- * number and type(s) of variadic arguments. The index of the first variadic argument in the argument list should be indicated\n- * using the {@link Linker.Option#firstVariadicArg(int)} linker option. The corresponding argument layout, and all following\n- * argument layouts in the specialized function descriptor, are called <em>variadic argument layouts<\/em>. For a\n- * prototype-less function, the index passed to {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n- * <p>\n- * It should be noted that values passed as variadic arguments undergo default argument promotion in C. Each value of\n- * type {@code float} is converted to {@code double}, and each value of an integral type undergoes integer promotion (which\n- * is discussed in detail in the C specification). The native linker will automatically apply argument conversions when needed.\n- * Exactly which variadic arguments the conversions are applied to is platform-dependent. As an example, on Linux\/x64 the\n- * following conversions are applied:\n+ * It should be noted that values passed as variadic arguments undergo default argument promotion in C. For instance, the\n+ * following argument promotions are applied:\n@@ -391,2 +381,4 @@\n- * <li>arguments with a Java type of {@code boolean}, {@code byte}, {@code char}, or {@code short}, are converted to {@code int}<\/li>\n- * <li>arguments with a Java type of {@code float}, are converted to {@code double}<\/li>\n+ * <li>{@code _Bool} -> {@code unsigned int}<\/li>\n+ * <li>{@code [signed] char} -> {@code [signed] int}<\/li>\n+ * <li>{@code [signed] short} -> {@code [signed] int}<\/li>\n+ * <li>{@code float} -> {@code double}<\/li>\n@@ -394,0 +386,17 @@\n+ * whereby the signed-ness of the source type corresponds to the signed-ness of the promoted type. The complete process\n+ * of default argument promotion is described in the C specification. In effect these promotions place limits on the\n+ * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n+ * type.\n+ * <p>\n+ * The native linker only supports linking the specialized form of a variadic function. A variadic function in its specialized\n+ * form can be linked using a function descriptor describing the specialized form. Additionally, the\n+ * {@link Linker.Option#firstVariadicArg(int)} linker option must be provided to indicate the first variadic parameter in\n+ * the parameter list. The corresponding argument layout, and all following argument layouts in the specialized function\n+ * descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n+ * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * <p>\n+ * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n+ * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n+ * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n+ * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n+ * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-\n@@ -95,2 +92,0 @@\n-        FunctionDescriptor unPromotedDesc = function;\n-        function = promoteVariadicArgs(function, firstVariadicArgIndex(options)); \/\/ the erased version can be shared\n@@ -98,0 +93,1 @@\n+        validateVariadicLayouts(function, optionSet);\n@@ -99,1 +95,1 @@\n-        MethodHandle mh = DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n+        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n@@ -106,2 +102,0 @@\n-\n-        return unpromoteVariadicArgs(mh, unPromotedDesc, optionSet);\n@@ -144,0 +138,22 @@\n+    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n+    \/\/ and float is promoted to double\n+    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n+    \/\/ We reject the corresponding layouts here, to avoid issues where unsigned values\n+    \/\/ are sign extended when promoted. (as we don't have a way to unambiguously represent signed-ness atm).\n+    private void validateVariadicLayouts(FunctionDescriptor function, LinkerOptions optionSet) {\n+        if (optionSet.isVariadicFunction()) {\n+            List<MemoryLayout> argumentLayouts = function.argumentLayouts();\n+            List<MemoryLayout> variadicLayouts = argumentLayouts.subList(optionSet.firstVariadicArgIndex(), argumentLayouts.size());\n+\n+            for (MemoryLayout variadicLayout : variadicLayouts) {\n+                if (variadicLayout.equals(ValueLayout.JAVA_BOOLEAN)\n+                    || variadicLayout.equals(ValueLayout.JAVA_BYTE)\n+                    || variadicLayout.equals(ValueLayout.JAVA_CHAR)\n+                    || variadicLayout.equals(ValueLayout.JAVA_SHORT)\n+                    || variadicLayout.equals(ValueLayout.JAVA_FLOAT)) {\n+                    throw new IllegalArgumentException(\"Invalid variadic argument layout: \" + variadicLayout);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -248,86 +264,0 @@\n-\n-    private static int firstVariadicArgIndex(Option[] options) {\n-        for (Option option : options) {\n-            if (option instanceof LinkerOptions.FirstVariadicArg fva) {\n-                return fva.index();\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    \/\/ C spec mandates that variadic arguments smaller than int are promoted to int,\n-    \/\/ and float is promoted to double\n-    \/\/ See: https:\/\/en.cppreference.com\/w\/c\/language\/conversion#Default_argument_promotions\n-    private static FunctionDescriptor promoteVariadicArgs(FunctionDescriptor function, int firstVariadicArgIndex) {\n-        if (firstVariadicArgIndex != -1) {\n-            MemoryLayout[] promotedLayouts = function.argumentLayouts().toArray(MemoryLayout[]::new);\n-\n-            for (int i = firstVariadicArgIndex; i < promotedLayouts.length; i++) {\n-                MemoryLayout variadicLayout = promotedLayouts[i];\n-\n-                if (variadicLayout instanceof ValueLayout vl) {\n-                    if (requiresVariadicIntPromotion(vl)) {\n-                        promotedLayouts[i] = JAVA_INT;\n-                    } else if (requiresVariadicDoublePromotion(vl)) {\n-                        promotedLayouts[i] = JAVA_DOUBLE;\n-                    }\n-                }\n-            }\n-\n-            function = function.returnLayout()\n-                    .map(rl -> FunctionDescriptor.of(rl, promotedLayouts))\n-                    .orElseGet(() -> FunctionDescriptor.ofVoid(promotedLayouts));\n-        }\n-\n-        return function;\n-    }\n-\n-    private static MethodHandle unpromoteVariadicArgs(MethodHandle mh, FunctionDescriptor unPromotedDesc, LinkerOptions optionSet) {\n-        if (optionSet.isVariadicFunction()) {\n-            Class<?>[] unpromotedParams = mh.type().parameterArray();\n-            List<MemoryLayout> unpromotedLayouts = unPromotedDesc.argumentLayouts();\n-            int numPrefixArgs = downcallNumPrefixArgs(unPromotedDesc, optionSet);\n-            assert unpromotedLayouts.size() + numPrefixArgs == unpromotedParams.length;\n-\n-            for (int i = optionSet.firstVariadicArgIndex(); i < unpromotedLayouts.size(); i++) {\n-                MemoryLayout variadicLayout = unpromotedLayouts.get(i);\n-                if (variadicLayout instanceof ValueLayout vl) {\n-                    if (requiresVariadicPromotion(vl)) {\n-                        unpromotedParams[numPrefixArgs + i] = vl.carrier();\n-                    }\n-                }\n-            }\n-\n-            MethodType unpromotedType = MethodType.methodType(mh.type().returnType(), unpromotedParams);\n-            mh = mh.asType(unpromotedType);\n-        }\n-\n-        return mh;\n-    }\n-\n-    private static int downcallNumPrefixArgs(FunctionDescriptor descriptor, LinkerOptions options) {\n-        int result = 1; \/\/ target address\n-        if (SharedUtils.returnsGroupLayout(descriptor)) {\n-            result++; \/\/ SegmentAllocator\n-        }\n-        if (options.hasCapturedCallState()) {\n-            result++;\n-        }\n-        return result;\n-    }\n-\n-    \/\/ For now all of these are the same for every implementation\n-    \/\/ in the future we might need to make one of them abstract\n-    \/\/ and implement on a per-linker basis.\n-    private static boolean requiresVariadicIntPromotion(ValueLayout vl) {\n-        return vl.carrier() == boolean.class || vl.carrier() == byte.class\n-                    || vl.carrier() == char.class || vl.carrier() == short.class;\n-    }\n-\n-    private static boolean requiresVariadicDoublePromotion(ValueLayout vl) {\n-        return vl.carrier() == float.class;\n-    }\n-\n-    private static boolean requiresVariadicPromotion(ValueLayout vl) {\n-        return requiresVariadicIntPromotion(vl) || requiresVariadicDoublePromotion(vl);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":24,"deletions":94,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -338,4 +338,0 @@\n-    public static boolean returnsGroupLayout(FunctionDescriptor descriptor) {\n-        return descriptor.returnLayout().isPresent() && (descriptor.returnLayout().get() instanceof GroupLayout);\n-    }\n-\n@@ -343,1 +339,1 @@\n-        if (!returnsGroupLayout(descriptor)) {\n+        if (descriptor.returnLayout().isEmpty() || !(descriptor.returnLayout().get() instanceof GroupLayout)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -381,7 +381,4 @@\n-\n-        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> {\n-            return arena.allocateUtf8String(\"str\");\n-        }, \"str\"),\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n+        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, Linker.Option[] options, String expectedExceptionMessage) {\n@@ -65,1 +65,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc, options);\n@@ -111,0 +111,1 @@\n+        Linker.Option[] NO_OPTIONS = new Linker.Option[0];\n@@ -114,0 +115,1 @@\n+                    NO_OPTIONS,\n@@ -118,0 +120,1 @@\n+                    NO_OPTIONS,\n@@ -122,0 +125,1 @@\n+                    NO_OPTIONS,\n@@ -126,0 +130,1 @@\n+                    NO_OPTIONS,\n@@ -130,0 +135,1 @@\n+                    NO_OPTIONS,\n@@ -138,0 +144,1 @@\n+                    NO_OPTIONS,\n@@ -147,0 +154,1 @@\n+                    NO_OPTIONS,\n@@ -154,0 +162,1 @@\n+                    NO_OPTIONS,\n@@ -161,0 +170,1 @@\n+                    NO_OPTIONS,\n@@ -165,0 +175,1 @@\n+                    NO_OPTIONS,\n@@ -169,0 +180,1 @@\n+                    NO_OPTIONS,\n@@ -173,0 +185,1 @@\n+                    NO_OPTIONS,\n@@ -179,0 +192,1 @@\n+                    NO_OPTIONS,\n@@ -185,0 +199,1 @@\n+                    NO_OPTIONS,\n@@ -189,0 +204,8 @@\n+        for (ValueLayout illegalLayout : List.of(C_CHAR, ValueLayout.JAVA_CHAR, C_BOOL, C_SHORT, C_FLOAT)) {\n+            cases.add(new Object[]{\n+                FunctionDescriptor.ofVoid(C_INT, illegalLayout),\n+                new Linker.Option[]{Linker.Option.firstVariadicArg(1)},\n+                \"Invalid variadic argument layout\"\n+            });\n+        }\n+\n@@ -195,0 +218,1 @@\n+                    NO_OPTIONS,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n+                                                                 C_DOUBLE, C_INT, C_DOUBLE, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3D, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -165,3 +165,0 @@\n-            \/\/ the test value would be automatically promoted to double\n-            \/\/ so it would not match the value we get back from native.\n-            \/\/ promote manually here to avoid that issue\n@@ -334,1 +331,2 @@\n-                    case \"float\", \"double\" -> \"DOUBLE\"; \/\/ float is promoted\n+                    case \"float\" -> \"DOUBLE\"; \/\/ promote\n+                    case \"double\" -> \"DOUBLE\";\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}