{"files":[{"patch":"@@ -40,0 +40,1 @@\n+\/\/ HierarchicalFieldStream allows to also iterate over fields of supertypes.\n@@ -138,1 +139,1 @@\n-\/\/ Iterate over only the internal fields\n+\/\/ Iterate over only the Java fields\n@@ -182,0 +183,100 @@\n+\/\/ Iterate over fields including the ones declared in supertypes\n+template<typename FieldStreamType>\n+class HierarchicalFieldStream : public StackObj  {\n+ private:\n+  const Array<InstanceKlass*>* _interfaces;\n+  InstanceKlass* _next_klass; \/\/ null indicates no more type to visit\n+  FieldStreamType _current_stream;\n+  int _interface_index;\n+\n+  void prepare() {\n+    _next_klass = next_klass_with_fields();\n+    \/\/ special case: the base klass has no fields. If any supertype has any fields, use that directly.\n+    \/\/ if no such supertype exists, done() will return false already.\n+    next_stream_if_done();\n+  }\n+\n+  InstanceKlass* next_klass_with_fields() {\n+    assert(_next_klass != nullptr, \"reached end of types already\");\n+    InstanceKlass* result = _next_klass;\n+    do  {\n+      if (!result->is_interface() && result->super() != nullptr) {\n+        result = result->java_super();\n+      } else if (_interface_index > 0) {\n+        result = _interfaces->at(--_interface_index);\n+      } else {\n+        return nullptr; \/\/ we did not find any more supertypes with fields\n+      }\n+    } while (FieldStreamType(result).done());\n+    return result;\n+  }\n+\n+  \/\/ sets _current_stream to the next if the current is done and any more is available\n+  void next_stream_if_done() {\n+    if (_next_klass != nullptr && _current_stream.done()) {\n+      _current_stream = FieldStreamType(_next_klass);\n+      assert(!_current_stream.done(), \"created empty stream\");\n+      _next_klass = next_klass_with_fields();\n+    }\n+  }\n+\n+ public:\n+  HierarchicalFieldStream(InstanceKlass* klass) :\n+    _interfaces(klass->transitive_interfaces()),\n+    _next_klass(klass),\n+    _current_stream(FieldStreamType(klass)),\n+    _interface_index(_interfaces->length()) {\n+      prepare();\n+  }\n+\n+  void next() {\n+    _current_stream.next();\n+    next_stream_if_done();\n+  }\n+\n+  bool done() const { return _next_klass == nullptr && _current_stream.done(); }\n+\n+  \/\/ bridge functions from FieldStreamBase\n+\n+  AccessFlags access_flags() const {\n+    return _current_stream.access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return _current_stream.field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return _current_stream.name();\n+  }\n+\n+  Symbol* signature() const {\n+    return _current_stream.signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return _current_stream.generic_signature();\n+  }\n+\n+  int offset() const {\n+    return _current_stream.offset();\n+  }\n+\n+  bool is_contended() const {\n+    return _current_stream.is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return _current_stream.contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return _current_stream.to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return _current_stream.field_descriptor();\n+  }\n+\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -53,1 +54,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -938,1 +938,1 @@\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -950,1 +950,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -984,1 +984,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n@@ -1018,1 +1018,1 @@\n-  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n@@ -1030,1 +1030,1 @@\n-  for (FieldStream fldc(ik, true, true); !fldc.eos(); fldc.next()) {\n+  for (JavaFieldStream fldc(ik); !fldc.done(); fldc.next()) {\n@@ -1042,1 +1042,1 @@\n-  for (FieldStream fld(ik, true, true); !fld.eos(); fld.next()) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next()) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.JavaObject;\n+import jdk.test.lib.hprof.model.JavaThing;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/*\n+ * @test\n+ * @bug 8317692\n+ * @summary Verifies heap dump contains all fields of an instance\n+ * @library \/test\/lib\n+ * @run driver FieldsInInstanceTest\n+ *\/\n+class FieldsInInstanceTarg extends LingeredApp {\n+\n+    public static void main(String[] args) {\n+        B b = new B();\n+        LingeredApp.main(args);\n+        Reference.reachabilityFence(b);\n+    }\n+\n+    interface I {\n+            int i = -10;\n+    }\n+    static abstract class A implements I {\n+        static boolean b;\n+        int a = 3;\n+        String s = \"Field\";\n+    }\n+    static class B extends A {\n+        static String f = null;\n+        int a = 7;\n+        double s = 0.5d;\n+    }\n+}\n+\n+public class FieldsInInstanceTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile, args);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile, String[] extraOptions) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new FieldsInInstanceTarg();\n+\n+            List<String> extraVMArgs = new ArrayList<>();\n+            extraVMArgs.addAll(Arrays.asList(extraOptions));\n+            LingeredApp.startApp(theApp, extraVMArgs.toArray(new String[0]));\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            Iterable<JavaHeapObject> objects = snapshot.getThings()::asIterator;\n+            for (JavaHeapObject heapObj : objects) {\n+                if (heapObj instanceof JavaObject javaObj) {\n+                    if (javaObj.getClazz().getName().endsWith(\"$B\")) {\n+                        List<JavaThing> fields = Arrays.asList(javaObj.getFields());\n+                        \/\/ B has 2 instance fields, A has 2 instance fields\n+                        Asserts.assertEquals(fields.size(), 4);\n+                        \/\/ JavaObject reverses the order of fields, so fields of B are at the end.\n+                        \/\/ Order is only specified for supertypes, so we check if values are *anywhere* in their range\n+                        \/\/ by using the toString output.\n+                        String asString = fields.subList(2, 4).toString();\n+                        Asserts.assertTrue(asString.contains(\"0.5\"), \"value for field B.s not found\");\n+                        Asserts.assertTrue(asString.contains(\"7\"), \"value for field B.a not found\");\n+                        asString = fields.subList(0, 2).toString();\n+                        Asserts.assertTrue(asString.contains(\"3\"), \"value for field A.a not found\");\n+                        Asserts.assertTrue(asString.contains(\"Field\"), \"value for field A.s not found\");\n+                        System.out.println(fields);\n+                        return; \/\/ we found our object\n+                    }\n+                }\n+            }\n+            \/\/ we didn't find our object\n+            Asserts.fail(\"Object of type B not found.\");\n+        }\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/FieldsInInstanceTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}