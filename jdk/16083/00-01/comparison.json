{"files":[{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.JavaObject;\n+import jdk.test.lib.hprof.model.JavaThing;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/*\n+ * @test\n+ * @bug 8317692\n+ * @summary Verifies heap dump contains all fields of an instance\n+ * @library \/test\/lib\n+ * @run driver FieldsInInstanceTest\n+ *\/\n+class FieldsInInstanceTarg extends LingeredApp {\n+\n+    public static void main(String[] args) {\n+        B b = new B();\n+        LingeredApp.main(args);\n+        Reference.reachabilityFence(b);\n+    }\n+\n+    interface I {\n+            int i = -10;\n+    }\n+    static abstract class A implements I {\n+        static boolean b;\n+        int a = 3;\n+        String s = \"Field\";\n+    }\n+    static class B extends A {\n+        static String f = null;\n+        int a = 7;\n+        double s = 0.5d;\n+    }\n+}\n+\n+public class FieldsInInstanceTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile, args);\n+        verifyDump(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile, String[] extraOptions) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new FieldsInInstanceTarg();\n+\n+            List<String> extraVMArgs = new ArrayList<>();\n+            extraVMArgs.addAll(Arrays.asList(extraOptions));\n+            LingeredApp.startApp(theApp, extraVMArgs.toArray(new String[0]));\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM.\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void verifyDump(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            Iterable<JavaHeapObject> objects = snapshot.getThings()::asIterator;\n+            for (JavaHeapObject heapObj : objects) {\n+                if (heapObj instanceof JavaObject javaObj) {\n+                    if (javaObj.getClazz().getName().endsWith(\"$B\")) {\n+                        List<JavaThing> fields = Arrays.asList(javaObj.getFields());\n+                        \/\/ B has 2 instance fields, A has 2 instance fields\n+                        Asserts.assertEquals(fields.size(), 4);\n+                        \/\/ JavaObject reverses the order of fields, so fields of B are at the end.\n+                        \/\/ Order is only specified for supertypes, so we check if values are *anywhere* in their range\n+                        \/\/ by using the toString output.\n+                        String asString = fields.subList(2, 4).toString();\n+                        Asserts.assertTrue(asString.contains(\"0.5\"), \"value for field B.s not found\");\n+                        Asserts.assertTrue(asString.contains(\"7\"), \"value for field B.a not found\");\n+                        asString = fields.subList(0, 2).toString();\n+                        Asserts.assertTrue(asString.contains(\"3\"), \"value for field A.a not found\");\n+                        Asserts.assertTrue(asString.contains(\"Field\"), \"value for field A.s not found\");\n+                        System.out.println(fields);\n+                        return; \/\/ we found our object\n+                    }\n+                }\n+            }\n+            \/\/ we didn't find our object\n+            Asserts.fail(\"Object of type B not found.\");\n+        }\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/FieldsInInstanceTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}