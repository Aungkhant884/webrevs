{"files":[{"patch":"@@ -304,1 +304,1 @@\n-            JLI_ReportErrorMessageSys(\"error locating main entrypoint\\n\");\n+            JLI_ReportErrorMessageSys(\"error locating main entrypoint\");\n@@ -349,1 +349,1 @@\n-        JLI_ReportErrorMessageSys(\"Could not create main thread: %s\\n\", strerror(errno));\n+        JLI_ReportErrorMessageSys(\"Could not create main thread\");\n@@ -353,1 +353,1 @@\n-        JLI_ReportErrorMessageSys(\"pthread_detach() failed: %s\\n\", strerror(errno));\n+        JLI_ReportErrorMessageSys(\"pthread_detach() failed\");\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -139,1 +139,4 @@\n-\/* Reports a system error message to stderr or a window *\/\n+\/*\n+ * Just like JLI_ReportErrorMessage, except that it concatenates the system\n+ * error message if any, similarly to std::perror.\n+ *\/\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,10 +203,0 @@\n-    char *emsg;\n-\n-    \/*\n-     * TODO: its safer to use strerror_r but is not available on\n-     * Solaris 8. Until then....\n-     *\/\n-    emsg = strerror(errno);\n-    if (emsg != NULL) {\n-        fprintf(stderr, \"%s\\n\", emsg);\n-    }\n@@ -216,0 +206,14 @@\n+\n+    if (errno != 0) {\n+        \/*\n+         * Buffer size of 1024 copied from typical POSIX size used\n+         * in strerror_r\n+         *\/\n+        char error[1024];\n+        if(strerror_r(errno, error, sizeof error) == 0) {\n+            fprintf(stderr, \": %s\", error);\n+        } else {\n+            fprintf(stderr, \": Java could not determine the underlying error\");\n+        }\n+        errno = 0;\n+    }\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_common.c","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -608,5 +608,0 @@\n-\/*\n- * Just like JLI_ReportErrorMessage, except that it concatenates the system\n- * error message if any, it's up to the calling routine to correctly\n- * format the separation of the messages.\n- *\/\n@@ -614,1 +609,1 @@\n-JLI_ReportErrorMessageSys(const char *fmt, ...)\n+JLI_ReportErrorMessageWin32(const char *fmt, ...)\n@@ -618,1 +613,0 @@\n-    int save_errno = errno;\n@@ -620,1 +614,0 @@\n-    jboolean freeit = JNI_FALSE;\n@@ -624,2 +617,2 @@\n-\n-    if ((errval = GetLastError()) != 0) {               \/* Platform SDK \/ DOS Error *\/\n+    \/* Platform SDK \/ DOS Error *\/\n+    if((errval = GetLastError()) != 0) {\n@@ -630,1 +623,1 @@\n-            errtext = \"\";\n+            errtext = \"Java could not determine the native Windows error\";\n@@ -633,1 +626,0 @@\n-            freeit = JNI_TRUE;\n@@ -640,2 +632,0 @@\n-    } else {   \/* C runtime error that has no corresponding DOS error code *\/\n-        errtext = strerror(save_errno);\n@@ -649,2 +639,2 @@\n-        if (freeit) {\n-           mlen += (int)JLI_StrLen(errtext);\n+        if (errtext != NULL) {\n+           mlen += 1 + (int)JLI_StrLen(errtext);\n@@ -655,1 +645,0 @@\n-        message[len]='\\0';\n@@ -657,2 +646,6 @@\n-        if (freeit) {\n-           JLI_StrCat(message, errtext);\n+        if (errtext != NULL) {\n+            message[len] = ':';\n+            message[len + 1] = ' ';\n+            JLI_StrCat(message, errtext);\n+        } else {\n+            message[len]='\\0';\n@@ -667,2 +660,2 @@\n-        if (freeit) {\n-           fprintf(stderr, \"%s\", errtext);\n+        if (errtext != NULL) {\n+           fprintf(stderr, \": %s\", errtext);\n@@ -670,0 +663,1 @@\n+        fprintf(stderr, \"\\n\");\n@@ -671,1 +665,1 @@\n-    if (freeit) {\n+    if (errtext != NULL) {\n@@ -677,0 +671,44 @@\n+JNIEXPORT void JNICALL\n+JLI_ReportErrorMessageSys(const char *fmt, ...)\n+{\n+    va_list vl;\n+\n+    \/* C runtime error that has no corresponding DOS error code *\/\n+    char  *errtext = strerror(errno);\n+\n+    va_start(vl, fmt);\n+\n+    if (IsJavaw()) {\n+        char *message;\n+        int mlen;\n+        \/* get the length of the string we need *\/\n+        int len = mlen =  _vscprintf(fmt, vl) + 1;\n+        if (errtext != NULL) {\n+           mlen += 1 + (int)JLI_StrLen(errtext);\n+        }\n+\n+        message = (char *)JLI_MemAlloc(mlen);\n+        _vsnprintf(message, len, fmt, vl);\n+\n+        if (errtext != NULL) {\n+            message[len] = ':';\n+            message[len + 1] = ' ';\n+            JLI_StrCat(message, errtext);\n+        } else {\n+            message[len]='\\0';\n+        }\n+\n+        MessageBox(NULL, message, \"Java Virtual Machine Launcher\",\n+            (MB_OK|MB_ICONSTOP|MB_APPLMODAL));\n+\n+        JLI_MemFree(message);\n+    } else {\n+        vfprintf(stderr, fmt, vl);\n+        if (errtext != NULL) {\n+           fprintf(stderr, \": %s\", errtext);\n+        }\n+        fprintf(stderr, \"\\n\");\n+    }\n+    va_end(vl);\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.c","additions":60,"deletions":22,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -50,0 +50,6 @@\n+\/*\n+ * Windows API calls are entirely separate from the regular errors that errno can\n+ * record\n+ *\/\n+JNIEXPORT void JNICALL JLI_ReportErrorMessageWin32(const char *fmt, ...);\n+\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}