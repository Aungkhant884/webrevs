{"files":[{"patch":"@@ -284,1 +284,1 @@\n-            if (!capturedParamType.equals(implParamType)) {\n+            if (!canConvert(capturedParamType, implParamType)) {\n@@ -286,1 +286,1 @@\n-                        String.format(\"Type mismatch in captured lambda parameter %d: expecting %s, found %s\",\n+                        String.format(\"Type mismatch in captured lambda parameter %d: %s is not convertible to %s\",\n@@ -294,1 +294,1 @@\n-            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n+            if (!canConvert(dynamicParamType, implParamType)) {\n@@ -304,1 +304,1 @@\n-        if (!isAdaptableToAsReturn(actualReturnType, expectedType)) {\n+        if (!canConvert(actualReturnType, expectedType)) {\n@@ -322,1 +322,1 @@\n-            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n+            if (!canConvert(dynamicParamType, descriptorParamType)) {\n@@ -331,1 +331,1 @@\n-        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n+        if (!canConvert(dynamicReturnType, descriptorReturnType)) {\n@@ -338,0 +338,52 @@\n+    private static boolean canConvert(Class<?> src, Class<?> dst) {\n+        \/\/ short-circuit a few cases:\n+        if (src == dst || src == Object.class || dst == Object.class)  return true;\n+        \/\/ the remainder of this logic is documented in MethodHandle.asType\n+        if (src.isPrimitive()) {\n+            \/\/ can force void to an explicit null, a la reflect.Method.invoke\n+            \/\/ can also force void to a primitive zero, by analogy\n+            if (src == void.class)  return true;  \/\/or !dst.isPrimitive()?\n+            Wrapper sw = Wrapper.forPrimitiveType(src);\n+            if (dst.isPrimitive()) {\n+                \/\/ P->P must widen\n+                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);\n+            } else {\n+                \/\/ P->R must box and widen\n+                return dst.isAssignableFrom(sw.wrapperType());\n+            }\n+        } else if (dst.isPrimitive()) {\n+            \/\/ any value can be dropped\n+            if (dst == void.class)  return true;\n+            Wrapper dw = Wrapper.forPrimitiveType(dst);\n+            \/\/ R->P must be able to unbox (from a dynamically chosen type) and widen\n+            \/\/ For example:\n+            \/\/   Byte\/Number\/Comparable\/Object -> dw:Byte -> byte.\n+            \/\/   Character\/Comparable\/Object -> dw:Character -> char\n+            \/\/   Boolean\/Comparable\/Object -> dw:Boolean -> boolean\n+            \/\/ This means that dw must be cast-compatible with src.\n+            if (src.isAssignableFrom(dw.wrapperType())) {\n+                return true;\n+            }\n+            \/\/ The above does not work if the source reference is strongly typed\n+            \/\/ to a wrapper whose primitive must be widened.  For example:\n+            \/\/   Byte -> unbox:byte -> short\/int\/long\/float\/double\n+            \/\/   Character -> unbox:char -> int\/long\/float\/double\n+            if (Wrapper.isWrapperType(src) &&\n+                    dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {\n+                \/\/ can unbox from src and then widen to dst\n+                return true;\n+            }\n+            \/\/ We have already covered cases which arise due to runtime unboxing\n+            \/\/ of a reference type which covers several wrapper types:\n+            \/\/   Object -> cast:Integer -> unbox:int -> long\/float\/double\n+            \/\/   Serializable -> cast:Byte -> unbox:byte -> byte\/short\/int\/long\/float\/double\n+            \/\/ An marginal case is Number -> dw:Character -> char, which would be OK if there were a\n+            \/\/ subclass of Number which wraps a value that can convert to char.\n+            \/\/ Since there is none, we don't need an extra check here to cover char or boolean.\n+            return false;\n+        } else {\n+            \/\/ R->R always works, since null is always valid dynamically\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":58,"deletions":6,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8035776 8173587\n+ * @bug 8035776 8173587 8269121\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/sun.invoke.util\n@@ -29,0 +30,3 @@\n+\n+import sun.invoke.util.Wrapper;\n+\n@@ -30,0 +34,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -40,2 +46,0 @@\n-    public interface I {}\n-\n@@ -55,0 +59,4 @@\n+        public static I m_I(String arg) { return new I() {}; }\n+        public static J m_J(String arg) { return new J() {}; }\n+        public static CC m_CC(String arg) { return new CC(); }\n+        public static FF m_FF(String arg) { return new FF(); }\n@@ -67,0 +75,4 @@\n+        public static String n_I(I arg) { return \"\"; }\n+        public static String n_J(J arg) { return \"\"; }\n+        public static String n_CC(CC arg) { return \"\"; }\n+        public static String n_FF(FF arg) { return \"\"; }\n@@ -92,1 +104,2 @@\n-                         String.class, Integer.class, Object.class };\n+                         String.class, Integer.class, Object.class,\n+                         I.class, J.class, CC.class, FF.class};\n@@ -98,1 +111,2 @@\n-                boolean correctRet = t[j].isAssignableFrom(t[i]) || conversions.contains(t[i], t[j]);\n+                \/\/if (i == j) continue;\n+                boolean correctRet = canConvert(t[i], t[j]) || conversions.contains(t[i], t[j]);\n@@ -106,1 +120,3 @@\n-                    boolean correctParam = t[j].isAssignableFrom(t[i]);\n+                    \/\/boolean correctParam = t[j].isAssignableFrom(t[i]) || sideCastExists(t[i], t[j]);\n+                    boolean correctParam = canConvert(t[i], t[j]);\n+                    System.out.println(\"testing correctParam = \" + correctParam + \" t[i] = \" + t[i] + \" t[j] = \" + t[j]);\n@@ -129,0 +145,4 @@\n+            System.err.println(\"invoking metafactory:\" +\n+                    \" impl=\" + mh +\n+                    \", inst=\" + instMT +\n+                    \", sam=\" + samMT);\n@@ -269,0 +289,59 @@\n+    private static boolean canConvert(Class<?> src, Class<?> dst) {\n+        \/\/ short-circuit a few cases:\n+        if (src == dst || src == Object.class || dst == Object.class)  return true;\n+        \/\/ the remainder of this logic is documented in MethodHandle.asType\n+        if (src.isPrimitive()) {\n+            \/\/ can force void to an explicit null, a la reflect.Method.invoke\n+            \/\/ can also force void to a primitive zero, by analogy\n+            if (src == void.class)  return true;  \/\/or !dst.isPrimitive()?\n+            Wrapper sw = Wrapper.forPrimitiveType(src);\n+            if (dst.isPrimitive()) {\n+                \/\/ P->P must widen\n+                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);\n+            } else {\n+                \/\/ P->R must box and widen\n+                return dst.isAssignableFrom(sw.wrapperType());\n+            }\n+        } else if (dst.isPrimitive()) {\n+            \/\/ any value can be dropped\n+            if (dst == void.class)  return true;\n+            Wrapper dw = Wrapper.forPrimitiveType(dst);\n+            \/\/ R->P must be able to unbox (from a dynamically chosen type) and widen\n+            \/\/ For example:\n+            \/\/   Byte\/Number\/Comparable\/Object -> dw:Byte -> byte.\n+            \/\/   Character\/Comparable\/Object -> dw:Character -> char\n+            \/\/   Boolean\/Comparable\/Object -> dw:Boolean -> boolean\n+            \/\/ This means that dw must be cast-compatible with src.\n+            if (src.isAssignableFrom(dw.wrapperType())) {\n+                return true;\n+            }\n+            \/\/ The above does not work if the source reference is strongly typed\n+            \/\/ to a wrapper whose primitive must be widened.  For example:\n+            \/\/   Byte -> unbox:byte -> short\/int\/long\/float\/double\n+            \/\/   Character -> unbox:char -> int\/long\/float\/double\n+            if (Wrapper.isWrapperType(src) &&\n+                    dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {\n+                \/\/ can unbox from src and then widen to dst\n+                return true;\n+            }\n+            \/\/ We have already covered cases which arise due to runtime unboxing\n+            \/\/ of a reference type which covers several wrapper types:\n+            \/\/   Object -> cast:Integer -> unbox:int -> long\/float\/double\n+            \/\/   Serializable -> cast:Byte -> unbox:byte -> byte\/short\/int\/long\/float\/double\n+            \/\/ An marginal case is Number -> dw:Character -> char, which would be OK if there were a\n+            \/\/ subclass of Number which wraps a value that can convert to char.\n+            \/\/ Since there is none, we don't need an extra check here to cover char or boolean.\n+            return false;\n+        } else {\n+            \/\/ R->R always works, since null is always valid dynamically\n+            return true;\n+        }\n+    }\n+\n+    public interface I {}\n+\n+    public interface J {}\n+\n+    public static class CC {}\n+\n+    public static final class FF {}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryDescriptorTest.java","additions":85,"deletions":6,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8269121\n+ * @summary Type inference bug with method references\n+ *\/\n+\n+public class MethodReferenceIntersection5 {\n+    interface StringLiteral {}\n+\n+    interface Variable {}\n+\n+    class MyFact {\n+        static Object make (StringLiteral v) { return null; }\n+    }\n+\n+    interface OneVariableQuery<VarType extends Variable> {\n+        Object query(VarType var1);\n+    }\n+\n+    static class Interpreter {\n+        <VarType extends Variable> Object query(OneVariableQuery<VarType> query) { return null; }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Interpreter().query(MyFact::make);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceIntersection5.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}