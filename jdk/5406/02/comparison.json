{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -294,1 +296,1 @@\n-            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true, true)) {\n@@ -322,3 +324,5 @@\n-            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n-                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n-                                           i, dynamicParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType) &&\n+                    (descriptorParamType.isPrimitive() || dynamicParamType.isPrimitive() ||\n+                            !sideCastExists(descriptorParamType, dynamicParamType))) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not convertible to %s\",\n+                        i, dynamicParamType, descriptorParamType);\n@@ -346,0 +350,12 @@\n+        return isAdaptableTo(fromType, toType, strict, false);\n+    }\n+\n+    \/**\n+     * Check type adaptability for parameter types.\n+     * @param fromType Type to convert from\n+     * @param toType Type to convert to\n+     * @param strict If true, do strict checks, else allow that fromType may be parameterized\n+     * @param allowSideCast If true, then sicasts are allowed\n+     * @return True if 'fromType' can be passed to an argument of 'toType'\n+     *\/\n+    private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict, boolean allowSideCast) {\n@@ -372,2 +388,3 @@\n-                \/\/ both are reference types: fromType should be a superclass of toType.\n-                return !strict || toType.isAssignableFrom(fromType);\n+                \/\/ both are reference types: fromType should be a superclass of toType or there should exist\n+                \/\/ a sidecast from fromType to toType\n+                return !strict || toType.isAssignableFrom(fromType) || (allowSideCast && sideCastExists(fromType, toType));\n@@ -378,0 +395,19 @@\n+    \/**\n+     * Check if a sidecas exist\n+     * @param fromType Type to convert from\n+     * @param toType Type to convert to\n+     * @return True if a sidecast exists from 'fromType' to 'toType'\n+     *\/\n+    private boolean sideCastExists(Class<?> fromType, Class<?> toType) {\n+        if (toType.isInterface() && fromType.isInterface()) {\n+            return true;\n+        } else if (toType.isInterface()) {\n+            return ((fromType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (fromType.isInterface()) {\n+            return ((toType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (toType.isArray() && fromType.isArray()) {\n+            return sideCastExists(fromType.getComponentType(), toType.getComponentType());\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -30,0 +31,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -40,2 +43,0 @@\n-    public interface I {}\n-\n@@ -55,0 +56,4 @@\n+        public static I m_I(String arg) { return new I() {}; }\n+        public static J m_J(String arg) { return new J() {}; }\n+        public static CC m_CC(String arg) { return new CC(); }\n+        public static FF m_FF(String arg) { return new FF(); }\n@@ -67,0 +72,4 @@\n+        public static String n_I(I arg) { return \"\"; }\n+        public static String n_J(J arg) { return \"\"; }\n+        public static String n_CC(CC arg) { return \"\"; }\n+        public static String n_FF(FF arg) { return \"\"; }\n@@ -92,1 +101,2 @@\n-                         String.class, Integer.class, Object.class };\n+                         String.class, Integer.class, Object.class,\n+                         I.class, J.class, CC.class, FF.class};\n@@ -98,0 +108,1 @@\n+                \/\/if (i == j) continue;\n@@ -106,1 +117,4 @@\n-                    boolean correctParam = t[j].isAssignableFrom(t[i]);\n+                    \/\/boolean correctParam = t[j].isAssignableFrom(t[i]) || sideCastExists(t[i], t[j]);\n+                    boolean correctParam = t[j].isAssignableFrom(t[i]) ||\n+                            (!t[j].isPrimitive() && !t[i].isPrimitive() && sideCastExists(t[j], t[i]));\n+                    System.out.println(\"testing correctParam = \" + correctParam + \" t[i] = \" + t[i] + \" t[j] = \" + t[j]);\n@@ -269,0 +283,24 @@\n+    \/\/ test if a sidecast exist from fromType to toType\n+    static boolean sideCastExists(Class<?> fromType, Class<?> toType) {\n+        if (fromType.isPrimitive() || toType.isPrimitive()) {\n+            return false;\n+        }\n+        if (toType.isInterface() && fromType.isInterface()) {\n+            return true;\n+        } else if (toType.isInterface()) {\n+            return ((fromType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (fromType.isInterface()) {\n+            return ((toType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (toType.isArray() && fromType.isArray()) {\n+            return sideCastExists(fromType.getComponentType(), toType.getComponentType());\n+        }\n+        return false;\n+    }\n+\n+    public interface I {}\n+\n+    public interface J {}\n+\n+    public static class CC {}\n+\n+    public static final class FF {}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryDescriptorTest.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8269121\n+ * @summary Type inference bug with method references\n+ *\/\n+\n+public class MethodReferenceIntersection5 {\n+    interface StringLiteral {}\n+\n+    interface Variable {}\n+\n+    class MyFact {\n+        static Object make (StringLiteral v) { return null; }\n+    }\n+\n+    interface OneVariableQuery<VarType extends Variable> {\n+        Object query(VarType var1);\n+    }\n+\n+    static class Interpreter {\n+        <VarType extends Variable> Object query(OneVariableQuery<VarType> query) { return null; }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Interpreter().query(MyFact::make);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceIntersection5.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}