{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -294,1 +296,1 @@\n-            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true, true)) {\n@@ -322,3 +324,5 @@\n-            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n-                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n-                                           i, dynamicParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType) &&\n+                    (descriptorParamType.isPrimitive() || dynamicParamType.isPrimitive() ||\n+                            !sideCastExists(descriptorParamType, dynamicParamType))) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not convertible to %s\",\n+                        i, dynamicParamType, descriptorParamType);\n@@ -346,0 +350,12 @@\n+        return isAdaptableTo(fromType, toType, strict, false);\n+    }\n+\n+    \/**\n+     * Check type adaptability for parameter types.\n+     * @param fromType Type to convert from\n+     * @param toType Type to convert to\n+     * @param strict If true, do strict checks, else allow that fromType may be parameterized\n+     * @param allowSideCast If true, then sicasts are allowed\n+     * @return True if 'fromType' can be passed to an argument of 'toType'\n+     *\/\n+    private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict, boolean allowSideCast) {\n@@ -372,2 +388,3 @@\n-                \/\/ both are reference types: fromType should be a superclass of toType.\n-                return !strict || toType.isAssignableFrom(fromType);\n+                \/\/ both are reference types: fromType should be a superclass of toType or there should exist\n+                \/\/ a sidecast from fromType to toType\n+                return !strict || toType.isAssignableFrom(fromType) || (allowSideCast && sideCastExists(fromType, toType));\n@@ -378,0 +395,19 @@\n+    \/**\n+     * Check if a sidecas exist\n+     * @param fromType Type to convert from\n+     * @param toType Type to convert to\n+     * @return True if a sidecast exists from 'fromType' to 'toType'\n+     *\/\n+    private boolean sideCastExists(Class<?> fromType, Class<?> toType) {\n+        if (toType.isInterface() && fromType.isInterface()) {\n+            return true;\n+        } else if (toType.isInterface()) {\n+            return ((fromType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (fromType.isInterface()) {\n+            return ((toType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (toType.isArray() && fromType.isArray()) {\n+            return sideCastExists(fromType.getComponentType(), toType.getComponentType());\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import com.sun.tools.javac.code.Type.IntersectionClassType;\n@@ -1088,4 +1087,0 @@\n-        return typeToMethodType(mt, null);\n-    }\n-\n-    private MethodType typeToMethodType(Type mt, MethodType interfaceMethodType) {\n@@ -1093,49 +1088,4 @@\n-        List<Type> adaptedParams = List.nil();\n-        if (interfaceMethodType != null && !areParametersAssignable(type, interfaceMethodType)) {\n-            adaptedParams = adaptParameters(mt, interfaceMethodType);\n-        }\n-        return new MethodType(\n-                adaptedParams.isEmpty() ? type.getParameterTypes() : adaptedParams,\n-                type.getReturnType(),\n-                type.getThrownTypes(),\n-                syms.methodClass);\n-    }\n-\n-    boolean areParametersAssignable(Type erasedMT, MethodType interfaceMethodType) {\n-        List<Type> interfaceMParams = interfaceMethodType.getParameterTypes();\n-        for (Type paramType : erasedMT.getParameterTypes()) {\n-            if (!types.isAssignable(paramType, interfaceMParams.head)) {\n-                return false;\n-            }\n-            interfaceMParams = interfaceMParams.tail;\n-        }\n-        return true;\n-    }\n-\n-    List<Type> adaptParameters(Type mt, MethodType interfaceMethodType) {\n-        ListBuffer<Type> parameterTypes = new ListBuffer<>();\n-        if (mt.getParameterTypes().stream().anyMatch(Type::isIntersection)) {\n-            List<Type> interfaceParamTypes = interfaceMethodType.getParameterTypes();\n-            for (Type paramType : mt.getParameterTypes()) {\n-                if (paramType.isIntersection()) {\n-                    parameterTypes.add(selectIntersectionComponent((IntersectionClassType) paramType, interfaceParamTypes.head));\n-                } else {\n-                    parameterTypes.add(types.erasure(paramType));\n-                }\n-                interfaceParamTypes = interfaceParamTypes.tail;\n-            }\n-        }\n-        return parameterTypes.toList();\n-    }\n-\n-    private Type selectIntersectionComponent(IntersectionClassType intersection, Type interfaceParamType) {\n-        for (Type component : intersection.getComponents()) {\n-            \/\/ skip object\n-            if (component.tsym == syms.objectType.tsym) { continue; }\n-            Type erasedComponent = types.erasure(component);\n-            if (types.isAssignable(erasedComponent, interfaceParamType)) {\n-                return erasedComponent;\n-            }\n-        }\n-        \/\/ bail out\n-        return types.erasure(intersection);\n+        return new MethodType(type.getParameterTypes(),\n+                        type.getReturnType(),\n+                        type.getThrownTypes(),\n+                        syms.methodClass);\n@@ -1152,1 +1102,0 @@\n-        MethodType intMethodType = typeToMethodType(samSym.type);\n@@ -1154,1 +1103,1 @@\n-                intMethodType,\n+                typeToMethodType(samSym.type),\n@@ -1156,1 +1105,1 @@\n-                typeToMethodType(tree.getDescriptorType(types), intMethodType));\n+                typeToMethodType(tree.getDescriptorType(types)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":57,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -30,0 +31,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -40,2 +43,0 @@\n-    public interface I {}\n-\n@@ -55,0 +56,4 @@\n+        public static I m_I(String arg) { return new I() {}; }\n+        public static J m_J(String arg) { return new J() {}; }\n+        public static CC m_CC(String arg) { return new CC(); }\n+        public static FF m_FF(String arg) { return new FF(); }\n@@ -67,0 +72,4 @@\n+        public static String n_I(I arg) { return \"\"; }\n+        public static String n_J(J arg) { return \"\"; }\n+        public static String n_CC(CC arg) { return \"\"; }\n+        public static String n_FF(FF arg) { return \"\"; }\n@@ -92,1 +101,2 @@\n-                         String.class, Integer.class, Object.class };\n+                         String.class, Integer.class, Object.class,\n+                         I.class, J.class, CC.class, FF.class};\n@@ -98,0 +108,1 @@\n+                \/\/if (i == j) continue;\n@@ -106,1 +117,4 @@\n-                    boolean correctParam = t[j].isAssignableFrom(t[i]);\n+                    \/\/boolean correctParam = t[j].isAssignableFrom(t[i]) || sideCastExists(t[i], t[j]);\n+                    boolean correctParam = t[j].isAssignableFrom(t[i]) ||\n+                            (!t[j].isPrimitive() && !t[i].isPrimitive() && sideCastExists(t[j], t[i]));\n+                    System.out.println(\"testing correctParam = \" + correctParam + \" t[i] = \" + t[i] + \" t[j] = \" + t[j]);\n@@ -269,0 +283,24 @@\n+    \/\/ test if a sidecast exist from fromType to toType\n+    static boolean sideCastExists(Class<?> fromType, Class<?> toType) {\n+        if (fromType.isPrimitive() || toType.isPrimitive()) {\n+            return false;\n+        }\n+        if (toType.isInterface() && fromType.isInterface()) {\n+            return true;\n+        } else if (toType.isInterface()) {\n+            return ((fromType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (fromType.isInterface()) {\n+            return ((toType.getModifiers() & Modifier.FINAL) == 0);\n+        } else if (toType.isArray() && fromType.isArray()) {\n+            return sideCastExists(fromType.getComponentType(), toType.getComponentType());\n+        }\n+        return false;\n+    }\n+\n+    public interface I {}\n+\n+    public interface J {}\n+\n+    public static class CC {}\n+\n+    public static final class FF {}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryDescriptorTest.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"}]}