{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.reflect.Modifier;\n-\n@@ -286,1 +284,1 @@\n-            if (!capturedParamType.equals(implParamType)) {\n+            if (!canConvert(capturedParamType, implParamType)) {\n@@ -288,1 +286,1 @@\n-                        String.format(\"Type mismatch in captured lambda parameter %d: expecting %s, found %s\",\n+                        String.format(\"Type mismatch in captured lambda parameter %d: %s is not convertible to %s\",\n@@ -296,1 +294,1 @@\n-            if (!isAdaptableTo(dynamicParamType, implParamType, true, true)) {\n+            if (!canConvert(dynamicParamType, implParamType)) {\n@@ -306,1 +304,1 @@\n-        if (!isAdaptableToAsReturn(actualReturnType, expectedType)) {\n+        if (!canConvert(actualReturnType, expectedType)) {\n@@ -324,5 +322,3 @@\n-            if (!descriptorParamType.isAssignableFrom(dynamicParamType) &&\n-                    (descriptorParamType.isPrimitive() || dynamicParamType.isPrimitive() ||\n-                            !sideCastExists(descriptorParamType, dynamicParamType))) {\n-                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not convertible to %s\",\n-                        i, dynamicParamType, descriptorParamType);\n+            if (!canConvert(dynamicParamType, descriptorParamType)) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n+                                           i, dynamicParamType, descriptorParamType);\n@@ -335,1 +331,1 @@\n-        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n+        if (!canConvert(dynamicReturnType, descriptorReturnType)) {\n@@ -342,9 +338,50 @@\n-    \/**\n-     * Check type adaptability for parameter types.\n-     * @param fromType Type to convert from\n-     * @param toType Type to convert to\n-     * @param strict If true, do strict checks, else allow that fromType may be parameterized\n-     * @return True if 'fromType' can be passed to an argument of 'toType'\n-     *\/\n-    private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict) {\n-        return isAdaptableTo(fromType, toType, strict, false);\n+    private static boolean canConvert(Class<?> src, Class<?> dst) {\n+        \/\/ short-circuit a few cases:\n+        if (src == dst || src == Object.class || dst == Object.class)  return true;\n+        \/\/ the remainder of this logic is documented in MethodHandle.asType\n+        if (src.isPrimitive()) {\n+            \/\/ can force void to an explicit null, a la reflect.Method.invoke\n+            \/\/ can also force void to a primitive zero, by analogy\n+            if (src == void.class)  return true;  \/\/or !dst.isPrimitive()?\n+            Wrapper sw = Wrapper.forPrimitiveType(src);\n+            if (dst.isPrimitive()) {\n+                \/\/ P->P must widen\n+                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);\n+            } else {\n+                \/\/ P->R must box and widen\n+                return dst.isAssignableFrom(sw.wrapperType());\n+            }\n+        } else if (dst.isPrimitive()) {\n+            \/\/ any value can be dropped\n+            if (dst == void.class)  return true;\n+            Wrapper dw = Wrapper.forPrimitiveType(dst);\n+            \/\/ R->P must be able to unbox (from a dynamically chosen type) and widen\n+            \/\/ For example:\n+            \/\/   Byte\/Number\/Comparable\/Object -> dw:Byte -> byte.\n+            \/\/   Character\/Comparable\/Object -> dw:Character -> char\n+            \/\/   Boolean\/Comparable\/Object -> dw:Boolean -> boolean\n+            \/\/ This means that dw must be cast-compatible with src.\n+            if (src.isAssignableFrom(dw.wrapperType())) {\n+                return true;\n+            }\n+            \/\/ The above does not work if the source reference is strongly typed\n+            \/\/ to a wrapper whose primitive must be widened.  For example:\n+            \/\/   Byte -> unbox:byte -> short\/int\/long\/float\/double\n+            \/\/   Character -> unbox:char -> int\/long\/float\/double\n+            if (Wrapper.isWrapperType(src) &&\n+                    dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {\n+                \/\/ can unbox from src and then widen to dst\n+                return true;\n+            }\n+            \/\/ We have already covered cases which arise due to runtime unboxing\n+            \/\/ of a reference type which covers several wrapper types:\n+            \/\/   Object -> cast:Integer -> unbox:int -> long\/float\/double\n+            \/\/   Serializable -> cast:Byte -> unbox:byte -> byte\/short\/int\/long\/float\/double\n+            \/\/ An marginal case is Number -> dw:Character -> char, which would be OK if there were a\n+            \/\/ subclass of Number which wraps a value that can convert to char.\n+            \/\/ Since there is none, we don't need an extra check here to cover char or boolean.\n+            return false;\n+        } else {\n+            \/\/ R->R always works, since null is always valid dynamically\n+            return true;\n+        }\n@@ -358,1 +395,0 @@\n-     * @param allowSideCast If true, then sicasts are allowed\n@@ -361,1 +397,1 @@\n-    private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict, boolean allowSideCast) {\n+    private boolean isAdaptableTo(Class<?> fromType, Class<?> toType, boolean strict) {\n@@ -388,35 +424,2 @@\n-                \/\/ both are reference types: fromType should be a superclass of toType or there should exist\n-                \/\/ a sidecast from fromType to toType\n-                return !strict || toType.isAssignableFrom(fromType) || (allowSideCast && sideCastExists(fromType, toType));\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Check if a sidecas exist\n-     * @param aType first type\n-     * @param anotherType second type\n-     * @return True if 'aType' is not disjoint from 'anotherType'\n-     *\/\n-    private boolean sideCastExists(Class<?> aType, Class<?> anotherType) {\n-        if (aType.isAssignableFrom(anotherType)) {\n-            return true;\n-        }\n-        \/\/ if non is sealed\n-        if (!anotherType.isSealed() && !aType.isSealed()) {\n-            if (anotherType.isInterface() && aType.isInterface()) {\n-                return true;\n-            } else if (anotherType.isInterface()) {\n-                return ((aType.getModifiers() & Modifier.FINAL) == 0);\n-            } else if (aType.isInterface()) {\n-                return ((anotherType.getModifiers() & Modifier.FINAL) == 0);\n-            } else if (anotherType.isArray() && aType.isArray()) {\n-                return sideCastExists(aType.getComponentType(), anotherType.getComponentType());\n-            }\n-        } else {\n-            Class<?> sealedOne = aType.isSealed() ? aType : anotherType;\n-            Class<?> other = sealedOne == aType ? anotherType : aType;\n-            for (Class<?> subclass : sealedOne.getPermittedSubclasses()) {\n-                if (sideCastExists(subclass, other)) {\n-                    return true;\n-                }\n+                \/\/ both are reference types: fromType should be a superclass of toType.\n+                return !strict || toType.isAssignableFrom(fromType);\n@@ -425,1 +428,0 @@\n-        return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":61,"deletions":59,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8035776 8173587\n+ * @bug 8035776 8173587 8269121\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/sun.invoke.util\n@@ -30,0 +31,2 @@\n+import sun.invoke.util.Wrapper;\n+\n@@ -109,1 +112,1 @@\n-                boolean correctRet = t[j].isAssignableFrom(t[i]) || conversions.contains(t[i], t[j]);\n+                boolean correctRet = canConvert(t[i], t[j]) || conversions.contains(t[i], t[j]);\n@@ -118,2 +121,1 @@\n-                    boolean correctParam = t[j].isAssignableFrom(t[i]) ||\n-                            (!t[j].isPrimitive() && !t[i].isPrimitive() && sideCastExists(t[j], t[i]));\n+                    boolean correctParam = canConvert(t[i], t[j]);\n@@ -143,0 +145,4 @@\n+            System.err.println(\"invoking metafactory:\" +\n+                    \" impl=\" + mh +\n+                    \", inst=\" + instMT +\n+                    \", sam=\" + samMT);\n@@ -283,3 +289,45 @@\n-    \/\/ test if a sidecast exist from fromType to toType\n-    static boolean sideCastExists(Class<?> fromType, Class<?> toType) {\n-        if (fromType.isPrimitive() || toType.isPrimitive()) {\n+    private static boolean canConvert(Class<?> src, Class<?> dst) {\n+        \/\/ short-circuit a few cases:\n+        if (src == dst || src == Object.class || dst == Object.class)  return true;\n+        \/\/ the remainder of this logic is documented in MethodHandle.asType\n+        if (src.isPrimitive()) {\n+            \/\/ can force void to an explicit null, a la reflect.Method.invoke\n+            \/\/ can also force void to a primitive zero, by analogy\n+            if (src == void.class)  return true;  \/\/or !dst.isPrimitive()?\n+            Wrapper sw = Wrapper.forPrimitiveType(src);\n+            if (dst.isPrimitive()) {\n+                \/\/ P->P must widen\n+                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);\n+            } else {\n+                \/\/ P->R must box and widen\n+                return dst.isAssignableFrom(sw.wrapperType());\n+            }\n+        } else if (dst.isPrimitive()) {\n+            \/\/ any value can be dropped\n+            if (dst == void.class)  return true;\n+            Wrapper dw = Wrapper.forPrimitiveType(dst);\n+            \/\/ R->P must be able to unbox (from a dynamically chosen type) and widen\n+            \/\/ For example:\n+            \/\/   Byte\/Number\/Comparable\/Object -> dw:Byte -> byte.\n+            \/\/   Character\/Comparable\/Object -> dw:Character -> char\n+            \/\/   Boolean\/Comparable\/Object -> dw:Boolean -> boolean\n+            \/\/ This means that dw must be cast-compatible with src.\n+            if (src.isAssignableFrom(dw.wrapperType())) {\n+                return true;\n+            }\n+            \/\/ The above does not work if the source reference is strongly typed\n+            \/\/ to a wrapper whose primitive must be widened.  For example:\n+            \/\/   Byte -> unbox:byte -> short\/int\/long\/float\/double\n+            \/\/   Character -> unbox:char -> int\/long\/float\/double\n+            if (Wrapper.isWrapperType(src) &&\n+                    dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {\n+                \/\/ can unbox from src and then widen to dst\n+                return true;\n+            }\n+            \/\/ We have already covered cases which arise due to runtime unboxing\n+            \/\/ of a reference type which covers several wrapper types:\n+            \/\/   Object -> cast:Integer -> unbox:int -> long\/float\/double\n+            \/\/   Serializable -> cast:Byte -> unbox:byte -> byte\/short\/int\/long\/float\/double\n+            \/\/ An marginal case is Number -> dw:Character -> char, which would be OK if there were a\n+            \/\/ subclass of Number which wraps a value that can convert to char.\n+            \/\/ Since there is none, we don't need an extra check here to cover char or boolean.\n@@ -287,2 +335,2 @@\n-        }\n-        if (toType.isInterface() && fromType.isInterface()) {\n+        } else {\n+            \/\/ R->R always works, since null is always valid dynamically\n@@ -290,6 +338,0 @@\n-        } else if (toType.isInterface()) {\n-            return ((fromType.getModifiers() & Modifier.FINAL) == 0);\n-        } else if (fromType.isInterface()) {\n-            return ((toType.getModifiers() & Modifier.FINAL) == 0);\n-        } else if (toType.isArray() && fromType.isArray()) {\n-            return sideCastExists(fromType.getComponentType(), toType.getComponentType());\n@@ -297,1 +339,0 @@\n-        return false;\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryDescriptorTest.java","additions":57,"deletions":16,"binary":false,"changes":73,"status":"modified"}]}