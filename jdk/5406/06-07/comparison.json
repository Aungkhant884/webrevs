{"files":[{"patch":"@@ -284,1 +284,1 @@\n-            if (!canConvert(capturedParamType, implParamType)) {\n+            if (!MethodType.canConvert(capturedParamType, implParamType)) {\n@@ -294,1 +294,1 @@\n-            if (!canConvert(dynamicParamType, implParamType)) {\n+            if (!MethodType.canConvert(dynamicParamType, implParamType)) {\n@@ -304,1 +304,1 @@\n-        if (!canConvert(actualReturnType, expectedType)) {\n+        if (!MethodType.canConvert(actualReturnType, expectedType)) {\n@@ -322,1 +322,1 @@\n-            if (!canConvert(dynamicParamType, descriptorParamType)) {\n+            if (!MethodType.canConvert(dynamicParamType, descriptorParamType)) {\n@@ -331,1 +331,1 @@\n-        if (!canConvert(dynamicReturnType, descriptorReturnType)) {\n+        if (!MethodType.canConvert(dynamicReturnType, descriptorReturnType)) {\n@@ -338,52 +338,0 @@\n-    private static boolean canConvert(Class<?> src, Class<?> dst) {\n-        \/\/ short-circuit a few cases:\n-        if (src == dst || src == Object.class || dst == Object.class)  return true;\n-        \/\/ the remainder of this logic is documented in MethodHandle.asType\n-        if (src.isPrimitive()) {\n-            \/\/ can force void to an explicit null, a la reflect.Method.invoke\n-            \/\/ can also force void to a primitive zero, by analogy\n-            if (src == void.class)  return true;  \/\/or !dst.isPrimitive()?\n-            Wrapper sw = Wrapper.forPrimitiveType(src);\n-            if (dst.isPrimitive()) {\n-                \/\/ P->P must widen\n-                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);\n-            } else {\n-                \/\/ P->R must box and widen\n-                return dst.isAssignableFrom(sw.wrapperType());\n-            }\n-        } else if (dst.isPrimitive()) {\n-            \/\/ any value can be dropped\n-            if (dst == void.class)  return true;\n-            Wrapper dw = Wrapper.forPrimitiveType(dst);\n-            \/\/ R->P must be able to unbox (from a dynamically chosen type) and widen\n-            \/\/ For example:\n-            \/\/   Byte\/Number\/Comparable\/Object -> dw:Byte -> byte.\n-            \/\/   Character\/Comparable\/Object -> dw:Character -> char\n-            \/\/   Boolean\/Comparable\/Object -> dw:Boolean -> boolean\n-            \/\/ This means that dw must be cast-compatible with src.\n-            if (src.isAssignableFrom(dw.wrapperType())) {\n-                return true;\n-            }\n-            \/\/ The above does not work if the source reference is strongly typed\n-            \/\/ to a wrapper whose primitive must be widened.  For example:\n-            \/\/   Byte -> unbox:byte -> short\/int\/long\/float\/double\n-            \/\/   Character -> unbox:char -> int\/long\/float\/double\n-            if (Wrapper.isWrapperType(src) &&\n-                    dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {\n-                \/\/ can unbox from src and then widen to dst\n-                return true;\n-            }\n-            \/\/ We have already covered cases which arise due to runtime unboxing\n-            \/\/ of a reference type which covers several wrapper types:\n-            \/\/   Object -> cast:Integer -> unbox:int -> long\/float\/double\n-            \/\/   Serializable -> cast:Byte -> unbox:byte -> byte\/short\/int\/long\/float\/double\n-            \/\/ An marginal case is Number -> dw:Character -> char, which would be OK if there were a\n-            \/\/ subclass of Number which wraps a value that can convert to char.\n-            \/\/ Since there is none, we don't need an extra check here to cover char or boolean.\n-            return false;\n-        } else {\n-            \/\/ R->R always works, since null is always valid dynamically\n-            return true;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":5,"deletions":57,"binary":false,"changes":62,"status":"modified"}]}