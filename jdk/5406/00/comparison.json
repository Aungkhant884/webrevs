{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.code.Type.IntersectionClassType;\n@@ -1087,0 +1088,4 @@\n+        return typeToMethodType(mt, null);\n+    }\n+\n+    private MethodType typeToMethodType(Type mt, MethodType interfaceMethodType) {\n@@ -1088,4 +1093,31 @@\n-        return new MethodType(type.getParameterTypes(),\n-                        type.getReturnType(),\n-                        type.getThrownTypes(),\n-                        syms.methodClass);\n+        ListBuffer<Type> parameterTypes = new ListBuffer<>();\n+        if (interfaceMethodType != null && mt.getParameterTypes().stream().anyMatch(Type::isIntersection)) {\n+            \/\/ we need to make sure that we are selecting the right component of the intersection to erase to\n+            List<Type> interfaceParamTypes = interfaceMethodType.getParameterTypes();\n+            for (Type paramType : mt.getParameterTypes()) {\n+                if (paramType.isIntersection()) {\n+                    parameterTypes.add(selectIntersectionComponent((IntersectionClassType)paramType, interfaceParamTypes.head));\n+                } else {\n+                    parameterTypes.add(types.erasure(paramType));\n+                }\n+                interfaceParamTypes = interfaceParamTypes.tail;\n+            }\n+        }\n+        return new MethodType(\n+                parameterTypes.isEmpty() ? type.getParameterTypes() : parameterTypes.toList(),\n+                type.getReturnType(),\n+                type.getThrownTypes(),\n+                syms.methodClass);\n+    }\n+\n+    private Type selectIntersectionComponent(IntersectionClassType intersection, Type interfaceParamType) {\n+        for (Type component : intersection.getComponents()) {\n+            \/\/ skip object\n+            if (component.tsym == syms.objectType.tsym) { continue; }\n+            Type erasedComponent = types.erasure(component);\n+            if (types.isAssignable(erasedComponent, interfaceParamType)) {\n+                return erasedComponent;\n+            }\n+        }\n+        \/\/ bail out\n+        return types.erasure(intersection);\n@@ -1102,0 +1134,1 @@\n+        MethodType intMethodType = typeToMethodType(samSym.type);\n@@ -1103,1 +1136,1 @@\n-                typeToMethodType(samSym.type),\n+                intMethodType,\n@@ -1105,1 +1138,1 @@\n-                typeToMethodType(tree.getDescriptorType(types)));\n+                typeToMethodType(tree.getDescriptorType(types), intMethodType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8269121\n+ * @summary Type inference bug with method references\n+ *\/\n+\n+public class MethodReferenceIntersection5 {\n+    interface StringLiteral {}\n+\n+    interface Variable {}\n+\n+    class MyFact {\n+        static Object make (StringLiteral v) { return null; }\n+    }\n+\n+    interface OneVariableQuery<VarType extends Variable> {\n+        Object query(VarType var1);\n+    }\n+\n+    static class Interpreter {\n+        <VarType extends Variable> Object query(OneVariableQuery<VarType> query) { return null; }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Interpreter().query(MyFact::make);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceIntersection5.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}