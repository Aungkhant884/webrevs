{"files":[{"patch":"@@ -900,14 +900,8 @@\n-    abstract sealed class AbstractIterator<T> implements Iterator<T> {\n-\n-        protected final Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-        @Override\n-        public boolean hasNext() {\n-            return i.hasNext();\n-        }\n-\n-        @Override\n-        public void remove() {\n-            i.remove();\n-        }\n-\n+    \/\/ Iterator implementations.\n+    \/\/ Here, we avoid polymorphism to ensure full VM optimization capabilities.\n+\n+    final class KeyIterator implements Iterator<K> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public K next() { return i.next().getKey(); }\n@@ -916,16 +910,5 @@\n-    final class KeyIterator extends AbstractIterator<K> {\n-\n-        @Override\n-        public K next() {\n-            return i.next().getKey();\n-        }\n-\n-    }\n-\n-    final class ValueIterator extends AbstractIterator<V> {\n-\n-        @Override\n-        public V next() {\n-            return i.next().getValue();\n-        }\n-\n+    final class ValueIterator implements Iterator<V> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public V next() { return i.next().getValue(); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":13,"deletions":30,"binary":false,"changes":43,"status":"modified"}]}