{"files":[{"patch":"@@ -353,1 +353,1 @@\n-            ks = new AbstractSet<K>() {\n+            ks = new AbstractSet<>() {\n@@ -355,15 +355,1 @@\n-                    return new Iterator<K>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public K next() {\n-                            return i.next().getKey();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new KeyIterator();\n@@ -412,1 +398,1 @@\n-            vals = new AbstractCollection<V>() {\n+            vals = new AbstractCollection<>() {\n@@ -414,15 +400,1 @@\n-                    return new Iterator<V>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public V next() {\n-                            return i.next().getValue();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n+                    return new ValueIterator();\n@@ -927,0 +899,17 @@\n+\n+    \/\/ Iterator implementations.\n+    \/\/ Here, we avoid polymorphism to ensure full VM optimization capabilities.\n+\n+    final class KeyIterator implements Iterator<K> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public K next() { return i.next().getKey(); }\n+    }\n+\n+    final class ValueIterator implements Iterator<V> {\n+        private final Iterator<Entry<K,V>> i = entrySet().iterator();\n+        public boolean hasNext() { return i.hasNext(); }\n+        public void remove() { i.remove(); }\n+        public V next() { return i.next().getValue(); }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"}]}