{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,4 @@\n+    static boolean isPrimitiveArray(String referenceTypeDescriptorString) {\n+        return referenceTypeDescriptorString.charAt(referenceTypeDescriptorString.length() - 1) != ';';\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-import static java.lang.constant.ConstantUtils.dropFirstAndLastChar;\n-import static java.lang.constant.ConstantUtils.internalToBinary;\n+import static java.lang.constant.ConstantUtils.*;\n@@ -43,1 +42,1 @@\n-     * interface type\n+     * interface type or an array type.\n@@ -67,9 +66,8 @@\n-        ClassDesc c = this;\n-        int depth = ConstantUtils.arrayDepth(descriptorString());\n-        for (int i=0; i<depth; i++)\n-            c = c.componentType();\n-\n-        if (c.isPrimitive())\n-            return lookup.findClass(descriptorString());\n-        else {\n-            Class<?> clazz = lookup.findClass(internalToBinary(dropFirstAndLastChar(c.descriptorString())));\n+        var desc = descriptor;\n+        if (isArray()) {\n+            if (isPrimitiveArray(desc)) {\n+                return lookup.findClass(desc);\n+            }\n+            \/\/ Class.forName is slow on class or interface arrays\n+            int depth = ConstantUtils.arrayDepth(desc);\n+            Class<?> clazz = lookup.findClass(internalToBinary(desc.substring(depth + 1, desc.length() - 1)));\n@@ -80,0 +78,1 @@\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(desc)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ReferenceClassDescImpl.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Compare array clone with equivalent System.arraycopy-based routines\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class MethodTypeDescResolve {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    public enum Kind {\n+        GENERIC(CD_Object, CD_Object, CD_Object),\n+        VOID(CD_void),\n+        NO_PARAM(CD_Class.arrayType()),\n+        ARBITRARY(CD_int, CD_String, CD_String.arrayType(), CD_double.arrayType());\n+\n+        final MethodTypeDesc desc;\n+\n+        Kind(ClassDesc ret, ClassDesc... args) {\n+            this.desc = MethodTypeDesc.of(ret, args);\n+        }\n+    }\n+\n+    public enum Implementation {\n+        OLD {\n+            @Override\n+            MethodType call(MethodHandles.Lookup lookup, MethodTypeDesc mtd) throws ReflectiveOperationException {\n+                return MethodType.fromMethodDescriptorString(mtd.descriptorString(),\n+                        lookup.lookupClass().getClassLoader());\n+            }\n+        },\n+        NEW {\n+            @Override\n+            MethodType call(MethodHandles.Lookup lookup, MethodTypeDesc mtd) throws ReflectiveOperationException {\n+                Class<?> returnType = ReferenceClassDescResolve.resolve(lookup, mtd.returnType());\n+                if (mtd.parameterCount() == 0) {\n+                    return MethodType.methodType(returnType);\n+                }\n+                Class<?>[] parameterTypes = new Class<?>[mtd.parameterCount()];\n+                for (int i = 0; i < parameterTypes.length; i++) {\n+                    parameterTypes[i] = ReferenceClassDescResolve.resolve(lookup, mtd.parameterType(i));\n+                }\n+                return MethodType.methodType(returnType, parameterTypes);\n+            }\n+        },\n+        REFERENCE {\n+            @Override\n+            MethodType call(MethodHandles.Lookup lookup, MethodTypeDesc mtd) throws ReflectiveOperationException {\n+                return (MethodType) mtd.resolveConstantDesc(lookup);\n+            }\n+        };\n+\n+        abstract MethodType call(MethodHandles.Lookup lookup, MethodTypeDesc mtd) throws ReflectiveOperationException;\n+    }\n+\n+    @Param\n+    public Kind kind;\n+    @Param\n+    public Implementation implementation;\n+\n+    @Benchmark\n+    public MethodType bench() throws ReflectiveOperationException {\n+        return implementation.call(LOOKUP, kind.desc);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescResolve.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Compare array clone with equivalent System.arraycopy-based routines\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class ReferenceClassDescResolve {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    static Class<?> resolve(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException {\n+        if (cd.isPrimitive()) {\n+            return (Class<?>) cd.resolveConstantDesc(lookup);\n+        }\n+        return resolveReference(lookup, cd);\n+    }\n+\n+    static Class<?> resolveReference(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException {\n+        if (cd.isArray()) {\n+            var desc = cd.descriptorString();\n+            if (desc.charAt(desc.length() - 1) != ';') {\n+                \/\/ Primitive arrays\n+                return lookup.findClass(desc);\n+            }\n+            int depth = 0;\n+            while (desc.charAt(depth) == '[') {\n+                depth++;\n+            }\n+            Class<?> clazz = lookup.findClass(desc.substring(depth + 1, desc.length() - 1).replace('\/', '.'));\n+            for (int i = 0; i < depth; i++)\n+                clazz = clazz.arrayType();\n+            return clazz;\n+        }\n+        var desc = cd.descriptorString();\n+        return lookup.findClass(desc.substring(1, desc.length() - 1).replace('\/', '.'));\n+    }\n+\n+    public enum Kind {\n+        CLASS(String.class),\n+        CLASS_ARRAY(Integer[][].class),\n+        PRIMITIVE_ARRAY(long[][][].class);\n+\n+        final ClassDesc desc;\n+\n+        Kind(Class<?> clz) {\n+            this.desc = clz.describeConstable().orElseThrow();\n+        }\n+    }\n+\n+    public enum Implementation {\n+        OLD {\n+            @Override\n+            Class<?> call(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException {\n+                ClassDesc c = cd;\n+                var desc = c.descriptorString();\n+                int depth = 0;\n+                while (desc.charAt(depth) == '[') {\n+                    depth++;\n+                }\n+                for (int i = 0; i < depth; i++)\n+                    c = c.componentType();\n+\n+                if (c.isPrimitive())\n+                    return lookup.findClass(desc);\n+                else {\n+                    desc = c.descriptorString();\n+                    Class<?> clazz = lookup.findClass(desc.substring(1, desc.length() - 1).replace('\/', '.'));\n+                    for (int i = 0; i < depth; i++)\n+                        clazz = clazz.arrayType();\n+                    return clazz;\n+                }\n+            }\n+        },\n+        NEW {\n+            @Override\n+            Class<?> call(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException {\n+                return resolveReference(lookup, cd);\n+            }\n+        },\n+        REFERENCE {\n+            @Override\n+            Class<?> call(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException {\n+                return (Class<?>) cd.resolveConstantDesc(lookup);\n+            }\n+        };\n+\n+        abstract Class<?> call(MethodHandles.Lookup lookup, ClassDesc cd) throws ReflectiveOperationException;\n+    }\n+\n+    @Param\n+    public Kind kind;\n+    @Param\n+    public Implementation implementation;\n+\n+    @Benchmark\n+    public Class<?> bench() throws ReflectiveOperationException {\n+        return implementation.call(LOOKUP, kind.desc);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ReferenceClassDescResolve.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}