{"files":[{"patch":"@@ -877,1 +877,1 @@\n-    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c\n+    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c\n@@ -1515,0 +1515,1 @@\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCompleteExit += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3942,1 +3942,1 @@\n-    Label cas_failed;\n+    Label no_count;\n@@ -3978,3 +3978,0 @@\n-      __ bind(cas_failed);\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n@@ -4025,0 +4022,5 @@\n+    __ br(Assembler::NE, no_count);\n+\n+    __ incrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+    __ bind(no_count);\n@@ -4035,0 +4037,1 @@\n+    Label no_count;\n@@ -4093,0 +4096,5 @@\n+    __ br(Assembler::NE, no_count);\n+\n+    __ decrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+    __ bind(no_count);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -440,1 +440,0 @@\n-    __ dec_held_monitor_count(rthread);\n@@ -2576,7 +2575,0 @@\n-  if (op->code() == lir_lock) {\n-    \/\/ If deoptimization happens in Runtime1::monitorenter, inc_held_monitor_count after backing from slowpath\n-    \/\/ will be skipped. Solution is:\n-    \/\/ 1. Increase only in fastpath\n-    \/\/ 2. Runtime1::monitorenter increase count after locking\n-    __ inc_held_monitor_count(rthread);\n-  }\n@@ -2584,4 +2576,0 @@\n-  if (op->code() == lir_unlock) {\n-    \/\/ unlock in slowpath is JRT_Leaf stub, no deoptimization can happen\n-    __ dec_held_monitor_count(rthread);\n-  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  incrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -150,0 +151,1 @@\n+  decrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -609,1 +609,0 @@\n-  dec_held_monitor_count(rthread);\n@@ -652,1 +651,0 @@\n-      dec_held_monitor_count(rthread);\n@@ -735,1 +733,1 @@\n-    Label done;\n+    Label count, done;\n@@ -769,1 +767,1 @@\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n@@ -806,1 +804,1 @@\n-    br(Assembler::EQ, done);\n+    br(Assembler::EQ, count);\n@@ -814,0 +812,4 @@\n+    b(done);\n+\n+    bind(count);\n+    incrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -838,1 +840,1 @@\n-    Label done;\n+    Label count, done;\n@@ -861,1 +863,1 @@\n-    cbz(header_reg, done);\n+    cbz(header_reg, count);\n@@ -864,1 +866,1 @@\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, done, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n@@ -869,0 +871,1 @@\n+    b(done);\n@@ -870,1 +873,2 @@\n-    bind(done);\n+    bind(count);\n+    decrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -872,0 +876,1 @@\n+    bind(done);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -349,14 +349,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register java_thread) {\n-  if (!Continuations::enabled()) return;\n-  incrementw(Address(java_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register java_thread) {\n-  if (!Continuations::enabled()) return;\n-  decrementw(Address(java_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-void MacroAssembler::reset_held_monitor_count(Register java_thread) {\n-  strw(zr, Address(java_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -900,3 +900,0 @@\n-  void inc_held_monitor_count(Register java_thread);\n-  void dec_held_monitor_count(Register java_thread);\n-  void reset_held_monitor_count(Register java_thread);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1569,1 +1569,1 @@\n-\n+    Label count;\n@@ -1591,3 +1591,1 @@\n-      { Label here;\n-        __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, \/*fallthrough*\/NULL);\n-      }\n+      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/NULL);\n@@ -1616,0 +1614,2 @@\n+    __ bind(count);\n+    __ incrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -1717,1 +1717,1 @@\n-    Label done;\n+    Label done, not_recursive;\n@@ -1722,1 +1722,3 @@\n-      __ cbz(rscratch1, done);\n+      __ cbnz(rscratch1, not_recursive);\n+      __ decrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n+      __ b(done);\n@@ -1725,0 +1727,2 @@\n+    __ bind(not_recursive);\n+\n@@ -1737,3 +1741,4 @@\n-      Label succeed;\n-      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &slow_path_unlock);\n-      __ bind(succeed);\n+      Label count;\n+      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, count, &slow_path_unlock);\n+      __ bind(count);\n+      __ decrementw(Address(rthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -8099,1 +8099,1 @@\n-  __ reset_held_monitor_count(rthread);\n+  __ strw(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -791,1 +791,0 @@\n-  __ inc_held_monitor_count(rthread);\n@@ -1508,1 +1507,0 @@\n-      __ dec_held_monitor_count(rthread);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3865,3 +3865,0 @@\n-  \/\/ The object is stored so counter should be increased even if stackoverflow is generated\n-  __ inc_held_monitor_count(rthread);\n-\n@@ -3926,1 +3923,0 @@\n-  __ dec_held_monitor_count(rthread);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,1 +463,0 @@\n-    __ dec_held_monitor_count();\n@@ -3513,7 +3512,0 @@\n-  if (op->code() == lir_lock) {\n-    \/\/ If deoptimization happens in Runtime1::monitorenter, inc_held_monitor_count after backing from slowpath\n-    \/\/ will be skipped. Solution is\n-    \/\/ 1. Increase only in fastpath\n-    \/\/ 2. Runtime1::monitorenter increase count after locking\n-    __ inc_held_monitor_count();\n-  }\n@@ -3521,4 +3513,0 @@\n-  if (op->code() == lir_unlock) {\n-    \/\/ unlock in slowpath is JRT_Leaf stub, no deoptimization can happen\n-    __ dec_held_monitor_count();\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+\n+  inc_held_monitor_count();\n+\n@@ -101,1 +104,0 @@\n-\n@@ -129,0 +131,2 @@\n+\n+  dec_held_monitor_count();\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-  Label IsInflated, DONE_LABEL;\n+  Label IsInflated, DONE_LABEL, NO_COUNT, COUNT;\n@@ -491,1 +491,1 @@\n-    jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n+    jcc(Assembler::equal, COUNT);           \/\/ Success\n@@ -547,1 +547,1 @@\n-  jccb  (Assembler::notZero, DONE_LABEL);\n+  jccb  (Assembler::notZero, NO_COUNT);\n@@ -570,1 +570,1 @@\n-  jcc(Assembler::equal, DONE_LABEL);           \/\/ CAS above succeeded; propagate ZF = 1 (success)\n+  jccb(Assembler::equal, COUNT);          \/\/ CAS above succeeded; propagate ZF = 1 (success)\n@@ -572,2 +572,2 @@\n-  cmpptr(r15_thread, rax);                     \/\/ Check if we are already the owner (recursive lock)\n-  jcc(Assembler::notEqual, DONE_LABEL);        \/\/ If not recursive, ZF = 0 at this point (fail)\n+  cmpptr(r15_thread, rax);                \/\/ Check if we are already the owner (recursive lock)\n+  jccb(Assembler::notEqual, NO_COUNT);    \/\/ If not recursive, ZF = 0 at this point (fail)\n@@ -587,1 +587,14 @@\n-  \/\/ At DONE_LABEL the icc ZFlag is set as follows ...\n+  \/\/ ZFlag == 1 count in fast path\n+  \/\/ ZFlag == 0 count in slow path\n+  jccb(Assembler::notZero, NO_COUNT); \/\/ jump if ZFlag == 0\n+\n+  bind(COUNT);\n+  \/\/ Count monitors in fast path\n+  Register thread = NOT_LP64(tmpReg) LP64_ONLY(r15_thread);\n+  NOT_LP64(get_thread(thread);)\n+  incrementl(Address(thread, JavaThread::held_monitor_count_offset()));\n+  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n+\n+  bind(NO_COUNT);\n+\n+  \/\/ At NO_COUNT the icc ZFlag is set as follows ...\n@@ -629,1 +642,1 @@\n-  Label DONE_LABEL, Stacked, CheckSucc;\n+  Label DONE_LABEL, Stacked, CheckSucc, COUNT, NO_COUNT;\n@@ -647,1 +660,1 @@\n-    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+    jcc   (Assembler::zero, COUNT);                                   \/\/ 0 indicates recursive stack-lock\n@@ -649,1 +662,1 @@\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Examine the object's markword\n+  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));   \/\/ Examine the object's markword\n@@ -652,1 +665,1 @@\n-    jccb  (Assembler::zero, Stacked);\n+    jccb   (Assembler::zero, Stacked);\n@@ -803,0 +816,13 @@\n+\n+  \/\/ ZFlag == 1 count in fast path\n+  \/\/ ZFlag == 0 count in slow path\n+  jccb(Assembler::notZero, NO_COUNT);\n+\n+  bind(COUNT);\n+  \/\/ Count monitors in fast path\n+  Register thread = NOT_LP64(tmpReg) LP64_ONLY(r15_thread);\n+  NOT_LP64(get_thread(thread);)\n+  decrementl(Address(thread, JavaThread::held_monitor_count_offset()));\n+  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n+\n+  bind(NO_COUNT);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1067,2 +1067,0 @@\n-  dec_held_monitor_count();\n-\n@@ -1113,1 +1111,0 @@\n-      dec_held_monitor_count();\n@@ -1208,1 +1205,1 @@\n-    Label done;\n+    Label count_locking, done, slow_case;\n@@ -1220,2 +1217,0 @@\n-    Label slow_case;\n-\n@@ -1246,1 +1241,1 @@\n-    jcc(Assembler::zero, done);\n+    jcc(Assembler::zero, count_locking);\n@@ -1282,1 +1277,5 @@\n-    jcc(Assembler::zero, done);\n+    jcc(Assembler::notZero, slow_case);\n+\n+    bind(count_locking);\n+    inc_held_monitor_count();\n+    jmp(done);\n@@ -1315,1 +1314,1 @@\n-    Label done;\n+    Label count_locking, done, slow_case;\n@@ -1341,1 +1340,1 @@\n-    jcc(Assembler::zero, done);\n+    jcc(Assembler::zero, count_locking);\n@@ -1348,1 +1347,1 @@\n-    jcc(Assembler::zero, done);\n+    jcc(Assembler::notZero, slow_case);\n@@ -1350,0 +1349,3 @@\n+    bind(count_locking);\n+    dec_held_monitor_count();\n+    jmp(done);\n@@ -1351,0 +1353,1 @@\n+    bind(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2901,2 +2901,0 @@\n-  if (!Continuations::enabled()) return;\n-\n@@ -2919,2 +2917,0 @@\n-  if (!Continuations::enabled()) return;\n-\n@@ -2936,18 +2932,0 @@\n-void MacroAssembler::reset_held_monitor_count() {\n-  if (!Continuations::enabled()) return;\n-\n-#ifndef _LP64\n-  Register thread = rax;\n-  push(thread);\n-  get_thread(thread);\n-#else\n-  Register thread = r15_thread;\n-#endif\n-\n-  movl(Address(thread, JavaThread::held_monitor_count_offset()), (int32_t)0);\n-\n-#ifndef _LP64\n-  pop(thread);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -529,0 +529,1 @@\n+\n@@ -531,1 +532,1 @@\n-  void reset_held_monitor_count();\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1695,0 +1695,1 @@\n+    Label count_mon;\n@@ -1722,1 +1723,1 @@\n-      __ jcc(Assembler::equal, lock_done);\n+      __ jcc(Assembler::equal, count_mon);\n@@ -1742,0 +1743,2 @@\n+    __ bind(count_mon);\n+    __ inc_held_monitor_count();\n@@ -1855,1 +1858,1 @@\n-    Label done;\n+    Label fast_done;\n@@ -1861,0 +1864,1 @@\n+      Label not_recur;\n@@ -1862,1 +1866,0 @@\n-\n@@ -1864,1 +1867,4 @@\n-      __ jcc(Assembler::equal, done);\n+      __ jcc(Assembler::notEqual, not_recur);\n+      __ dec_held_monitor_count();\n+      __ jmpb(fast_done);\n+      __ bind(not_recur);\n@@ -1885,0 +1891,1 @@\n+      __ dec_held_monitor_count();\n@@ -1895,2 +1902,1 @@\n-    __ bind(done);\n-\n+    __ bind(fast_done);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1894,0 +1894,1 @@\n+    Label count_mon;\n@@ -1908,0 +1909,1 @@\n+\n@@ -1920,1 +1922,1 @@\n-      __ jcc(Assembler::equal, lock_done);\n+      __ jcc(Assembler::equal, count_mon);\n@@ -1942,0 +1944,2 @@\n+    __ bind(count_mon);\n+    __ inc_held_monitor_count();\n@@ -2039,1 +2043,0 @@\n-  Label unlock_done;\n@@ -2041,0 +2044,1 @@\n+  Label unlock_done;\n@@ -2043,0 +2047,2 @@\n+    Label fast_done;\n+\n@@ -2046,2 +2052,0 @@\n-    Label done;\n-\n@@ -2049,0 +2053,1 @@\n+      Label not_recur;\n@@ -2051,1 +2056,4 @@\n-      __ jcc(Assembler::equal, done);\n+      __ jcc(Assembler::notEqual, not_recur);\n+      __ dec_held_monitor_count();\n+      __ jmpb(fast_done);\n+      __ bind(not_recur);\n@@ -2059,1 +2067,0 @@\n-\n@@ -2070,0 +2077,1 @@\n+      __ dec_held_monitor_count();\n@@ -2080,1 +2088,1 @@\n-    __ bind(done);\n+    __ bind(fast_done);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -8341,1 +8341,1 @@\n-  __ reset_held_monitor_count();\n+  __ movl(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -607,2 +607,0 @@\n-\n-  __ inc_held_monitor_count();\n@@ -1267,1 +1265,0 @@\n-      __ dec_held_monitor_count();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4366,3 +4366,0 @@\n-  \/\/ The object is stored so counter should be increased even if stackoverflow is generated\n-  __ inc_held_monitor_count();\n-\n@@ -4427,3 +4424,0 @@\n-\n-  __ dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,0 +337,1 @@\n+    bool inc_mont_count = true;\n@@ -342,0 +343,1 @@\n+        inc_mont_count = false;\n@@ -347,0 +349,3 @@\n+    if (inc_mont_count) {\n+      THREAD->inc_held_monitor_count();\n+    }\n@@ -482,0 +487,1 @@\n+    bool dec_mont_count = true;\n@@ -486,0 +492,1 @@\n+        dec_mont_count = false;\n@@ -489,0 +496,3 @@\n+    if (dec_mont_count) {\n+      THREAD->dec_held_monitor_count();\n+    }\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -745,1 +745,0 @@\n-  current->inc_held_monitor_count();\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -629,0 +629,1 @@\n+        bool inc_mon_count = true;\n@@ -634,0 +635,1 @@\n+            inc_mon_count = false;\n@@ -637,0 +639,3 @@\n+        if (inc_mon_count) {\n+          THREAD->inc_held_monitor_count();\n+        }\n@@ -723,0 +728,1 @@\n+      bool inc_mon_count = true;\n@@ -728,0 +734,1 @@\n+          inc_mon_count = false;\n@@ -731,0 +738,3 @@\n+      if (inc_mon_count) {\n+        THREAD->inc_held_monitor_count();\n+      }\n@@ -1631,0 +1641,1 @@\n+          bool inc_mon_count = true;\n@@ -1636,0 +1647,1 @@\n+              inc_mon_count = false;\n@@ -1639,0 +1651,3 @@\n+          if (inc_mon_count) {\n+            THREAD->inc_held_monitor_count();\n+          }\n@@ -1660,0 +1675,1 @@\n+            bool dec_mont_count = true;\n@@ -1666,0 +1682,1 @@\n+                dec_mont_count = false;\n@@ -1669,0 +1686,3 @@\n+            if (dec_mont_count) {\n+              THREAD->dec_held_monitor_count();\n+            }\n@@ -3084,0 +3104,1 @@\n+          bool dec_mont_count = true;\n@@ -3089,0 +3110,1 @@\n+              dec_mont_count = false;\n@@ -3092,0 +3114,3 @@\n+          if (dec_mont_count) {\n+            THREAD->dec_held_monitor_count();\n+          }\n@@ -3150,0 +3175,1 @@\n+            bool dec_mont_count = true;\n@@ -3155,0 +3181,1 @@\n+                dec_mont_count = false;\n@@ -3162,0 +3189,3 @@\n+            if (dec_mont_count) {\n+              THREAD->dec_held_monitor_count();\n+            }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  nonstatic_field(JavaThread,                  _held_monitor_count,                           int)                                   \\\n+  nonstatic_field(JavaThread,                  _held_monitor_count,                           int32_t)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2217,12 +2217,1 @@\n-  Node* thread = transform_later(new ThreadLocalNode());\n-  if (Continuations::enabled()) {\n-    \/\/ held_monitor_count increased in slowpath (complete_monitor_locking_C_inc_held_monitor_count), need compensate a decreament here\n-    \/\/ this minimizes control flow changes here and add redundant count updates only in slowpath\n-    Node* dec_count = make_load(slow_ctrl, memproj, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* new_dec_count = transform_later(new SubINode(dec_count, intcon(1)));\n-    Node *compensate_dec = make_store(slow_ctrl, memproj, thread, in_bytes(JavaThread::held_monitor_count_offset()), new_dec_count, T_INT);\n-    mem_phi->init_req(1, compensate_dec);\n-  } else {\n-    mem_phi->init_req(1, memproj);\n-  }\n-  transform_later(mem_phi);\n+  mem_phi->init_req(1, memproj);\n@@ -2230,5 +2219,1 @@\n-  if (Continuations::enabled()) {\n-    \/\/ held_monitor_count increases in all path's post-dominate\n-    Node* inc_count = make_load(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* new_inc_count = transform_later(new AddINode(inc_count, intcon(1)));\n-    Node *store = make_store(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), new_inc_count, T_INT);\n+  transform_later(mem_phi);\n@@ -2236,4 +2221,1 @@\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, store);\n-  } else {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n-  }\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n@@ -2294,9 +2276,1 @@\n-  if (Continuations::enabled()) {\n-    Node* count = make_load(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* newcount = transform_later(new SubINode(count, intcon(1)));\n-    Node *store = make_store(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), newcount, T_INT);\n-\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, store);\n-  } else {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n-  }\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":30,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C_inc_held_monitor_count, 0, false, false);\n+  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2721,6 +2721,1 @@\n-  if (!Continuation::pin(thread)) {\n-    ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));\n-    THROW_(vmSymbols::java_lang_VirtualMachineError(), JNI_ERR);\n-  }\n-  ret = JNI_OK;\n-  return ret;\n+  return JNI_OK;\n@@ -2744,5 +2739,1 @@\n-  if (!Continuation::unpin(thread)) {\n-    ShouldNotReachHere();\n-  }\n-  ret = JNI_OK;\n-  return ret;\n+  return JNI_OK;\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1408,1 +1408,2 @@\n-  assert(monitors_on_stack(current) == (current->held_monitor_count() > 0), \"\");\n+  assert(monitors_on_stack(current) == ((current->held_monitor_count() - current->jni_monitor_count()) > 0),\n+         \"Held monitor count and locks on stack invariant: \" INT32_FORMAT \" JNI: \" INT32_FORMAT, current->held_monitor_count(), current->jni_monitor_count());\n@@ -2245,1 +2246,1 @@\n-  thread->reset_held_monitor_count();\n+  assert(thread->held_monitor_count() == 0, \"Must be\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1525,1 +1525,0 @@\n-        deoptee_thread->inc_held_monitor_count();\n@@ -1600,1 +1599,0 @@\n-          thread->dec_held_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1634,2 +1634,4 @@\n-  _recursions = save      \/\/ restore the old recursion count\n-                + JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(current); \/\/  increased by the deferred relock count\n+  int relock_count = JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(current);\n+  _recursions =   save          \/\/ restore the old recursion count\n+                + relock_count; \/\/  increased by the deferred relock count\n+  current->inc_held_monitor_count(relock_count); \/\/ Deopt never entered these counts.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2137,1 +2137,3 @@\n-    if (ObjectSynchronizer::quick_enter(obj, current, lock)) return;\n+    if (ObjectSynchronizer::quick_enter(obj, current, lock)) {\n+      return;\n+    }\n@@ -2155,5 +2157,0 @@\n-JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C_inc_held_monitor_count(oopDesc* obj, BasicLock* lock, JavaThread* current))\n-  SharedRuntime::monitor_enter_helper(obj, lock, current);\n-  current->inc_held_monitor_count();\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -490,1 +490,0 @@\n-  static void complete_monitor_locking_C_inc_held_monitor_count(oopDesc* obj, BasicLock* lock, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -377,0 +377,1 @@\n+      current->inc_held_monitor_count();\n@@ -393,0 +394,1 @@\n+      current->inc_held_monitor_count();\n@@ -474,0 +476,2 @@\n+  current->inc_held_monitor_count();\n+\n@@ -513,0 +517,2 @@\n+  current->dec_held_monitor_count();\n+\n@@ -581,2 +587,3 @@\n-  intptr_t ret_code = monitor->complete_exit(current);\n-  return ret_code;\n+  intx recur_count = monitor->complete_exit(current);\n+  current->dec_held_monitor_count(recur_count + 1);\n+  return recur_count;\n@@ -594,0 +601,1 @@\n+      current->inc_held_monitor_count(recursions + 1);\n@@ -615,0 +623,1 @@\n+      current->inc_held_monitor_count(1, true);\n@@ -633,0 +642,1 @@\n+    current->dec_held_monitor_count(1, true);\n@@ -1579,1 +1589,2 @@\n-    (void)mid->complete_exit(_thread);\n+    intx rec = mid->complete_exit(_thread);\n+    _thread->dec_held_monitor_count(rec + 1);\n@@ -1605,0 +1616,3 @@\n+  assert(current->held_monitor_count() == 0, \"Should not be possible\");\n+  \/\/ All monitors (including entered via JNI) have been unlocked above, so we need to clear jni count.\n+  current->clear_jni_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1088,0 +1088,1 @@\n+  _jni_monitor_count(0),\n@@ -1482,1 +1483,12 @@\n-  assert(!Continuations::enabled() || this->held_monitor_count() == 0, \"held monitor count should be zero\");\n+  \/\/ Since above code may not release JNI monitors and if someone forgot to do an\n+  \/\/ JNI monitorexit, held count should be equal jni count.\n+  \/\/ Consider scan all object monitor for this owner if JNI count > 0 (at least on detach).\n+  assert(this->held_monitor_count() == this->jni_monitor_count(),\n+         \"held monitor count should be equal to jni: \" UINT32_FORMAT \" != \" INT32_FORMAT,\n+         this->held_monitor_count(), this->jni_monitor_count());\n+  if (CheckJNICalls && this->jni_monitor_count() > 0) {\n+    \/\/ We would like a fatal here, but due to we never checked this before there\n+    \/\/ is a lot of tests which breaks, even with an error log.\n+    log_debug(jni)(\"JavaThread %s (tid: \" UINTX_FORMAT \") with Objects still locked by JNI MonitorEnter.\",\n+      exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n+  }\n@@ -2450,3 +2462,7 @@\n-void JavaThread::inc_held_monitor_count() {\n-  if (!Continuations::enabled()) {\n-    return;\n+void JavaThread::inc_held_monitor_count(int32_t i, bool jni) {\n+#ifdef SUPPORT_MONITOR_COUNT\n+  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INT32_FORMAT, _held_monitor_count);\n+  _held_monitor_count += i;\n+  if (jni) {\n+    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INT32_FORMAT, _jni_monitor_count);\n+    _jni_monitor_count += i;\n@@ -2454,1 +2470,1 @@\n-  _held_monitor_count++;\n+#endif\n@@ -2457,3 +2473,7 @@\n-void JavaThread::dec_held_monitor_count() {\n-  if (!Continuations::enabled()) {\n-    return;\n+void JavaThread::dec_held_monitor_count(int32_t i, bool jni) {\n+#ifdef SUPPORT_MONITOR_COUNT\n+  _held_monitor_count -= i;\n+  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INT32_FORMAT, _held_monitor_count);\n+  if (jni) {\n+    _jni_monitor_count -= i;\n+    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INT32_FORMAT, _jni_monitor_count);\n@@ -2461,2 +2481,1 @@\n-  assert(_held_monitor_count > 0, \"\");\n-  _held_monitor_count--;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1062,1 +1062,3 @@\n-  int _held_monitor_count;  \/\/ used by continuations for fast lock detection\n+  \/\/ It's signed for error detection.\n+  int32_t _held_monitor_count;  \/\/ used by continuations for fast lock detection\n+  int32_t _jni_monitor_count;\n@@ -1208,4 +1210,5 @@\n-  int held_monitor_count()        { return _held_monitor_count; }\n-  void reset_held_monitor_count() { _held_monitor_count = 0; }\n-  void inc_held_monitor_count();\n-  void dec_held_monitor_count();\n+  void inc_held_monitor_count(int32_t i = 1, bool jni = false);\n+  void dec_held_monitor_count(int32_t i = 1, bool jni = false);\n+  int32_t held_monitor_count() { return _held_monitor_count; }\n+  int32_t jni_monitor_count()  { return _jni_monitor_count;  }\n+  void clear_jni_monitor_count() { _jni_monitor_count = 0;   }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test CompleteExit\n+ * @summary This does a sanity test of the poll in the native wrapper.\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/test\/lib\n+ * @build CompleteExit\n+ * @run main\/native CompleteExit\n+ *\/\n+\n+public class CompleteExit {\n+    public static native void testIt(Object o1, Object o2);\n+\n+    static volatile Object o1 = new Object();\n+    static volatile Object o2 = new Object();\n+\n+    static {\n+        System.loadLibrary(\"CompleteExit\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testIt(o1, o2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/CompleteExit.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+\n+#define die(x) do { printf(\"%s:%s\\n\",x , __func__); perror(x); exit(EXIT_FAILURE); } while (0)\n+\n+#ifndef _Included_CompleteExit\n+#define _Included_CompleteExit\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static JavaVM* jvm;\n+static pthread_t attacher;\n+\n+static jobject t1, t2;\n+\n+static void* do_test() {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  if ((*env)->MonitorEnter(env, t1) != 0) die(\"MonitorEnter\");\n+  if ((*env)->MonitorEnter(env, t2) != 0) die(\"MonitorEnter\");\n+\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+  pthread_exit(NULL);\n+\n+  return NULL;\n+}\n+\n+\/*\n+ * Class:     CompleteExit\n+ * Method:    startThread\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_CompleteExit_testIt(JNIEnv* env, jclass jc, jobject o1, jobject o2) {\n+    void* ret;\n+    pthread_attr_t attr;\n+\n+    (*env)->GetJavaVM(env, &jvm);\n+\n+    t1 = (*env)->NewGlobalRef(env, o1);\n+    t2 = (*env)->NewGlobalRef(env, o2);\n+\n+    if (pthread_attr_init(&attr) != 0) die(\"pthread_attr_init\");\n+    if (pthread_create(&attacher, &attr, do_test, NULL) != 0) die(\"pthread_create\");\n+    if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/libCompleteExit.c","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}