{"files":[{"patch":"@@ -926,1 +926,1 @@\n-      CompileTask::print(st, this, msg, \/*short_form:*\/ false);\n+      CompileTask::print(st, this, msg, \/*short_form:*\/ false, \/* cr *\/ true, \/* timestamp *\/ false);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                             const char* msg, bool short_form, bool cr,\n+                             const char* msg, bool short_form, bool cr, bool timestamp,\n@@ -242,2 +242,4 @@\n-    \/\/ Print current time\n-    st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    if (timestamp) {\n+      \/\/ Print current time\n+      st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n+                                      const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true,\n@@ -196,1 +196,1 @@\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true) {\n@@ -199,1 +199,1 @@\n-                           msg, short_form, cr);\n+                           msg, short_form, cr, timestamp);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+bool              VMError::_print_native_stack_used = false;\n@@ -245,4 +246,3 @@\n- * Determines if the code unit denoted by `owner` should be printed.\n- * If this method returns true, then `owner` has been added to `printed`.\n- * If `owner` was already in `printed`, this methods returns false.\n-\n+ * Adds `value` to `list` iff it's not already present and there is sufficient\n+ * capacity (i.e. length(list) < `list_capacity`). The length of the list\n+ * is the index of the first nullptr entry.\n@@ -250,3 +250,1 @@\n- * @param owner a CodeBlob*, InterpreterCodelet* or StubCodeDesc* value\n- * @param printed array of owners that have already been printed (delimited by NULL entry)\n- * @param printed_len the length of `printed`\n+ * @ return true if the value was added, false otherwise\n@@ -254,3 +252,3 @@\n-static bool should_print_code(address owner, address* printed, int printed_len) {\n-  for (int i = 0; i < printed_len; i++) {\n-    if (printed[i] == owner) {\n+static bool add_if_absent(address value, address* list, int list_capacity) {\n+  for (int i = 0; i < list_capacity; i++) {\n+    if (list[i] == value) {\n@@ -259,2 +257,5 @@\n-    if (printed[i] == 0) {\n-      printed[i] = owner;\n+    if (list[i] == nullptr) {\n+      list[i] = value;\n+      if (i + 1 < list_capacity) {\n+        list[i + 1] = nullptr;\n+      }\n@@ -264,1 +265,0 @@\n-  \/\/ Beyond limit of code units to be printed\n@@ -274,1 +274,2 @@\n- * @param printed_len the length of `printed`\n+ * @param printed_capacity the capacity of `printed`\n+ * @return true if the code unit was printed, false otherwise\n@@ -277,1 +278,1 @@\n-                            address* printed, int printed_len) {\n+                       address* printed, int printed_capacity) {\n@@ -282,2 +283,2 @@\n-      if (codelet != NULL) {\n-        if (should_print_code((address) codelet, printed, printed_len)) {\n+      if (codelet != nullptr) {\n+        if (add_if_absent((address) codelet, printed, printed_capacity)) {\n@@ -292,1 +293,1 @@\n-    if (desc != NULL) {\n+    if (desc != nullptr) {\n@@ -294,1 +295,1 @@\n-        if (should_print_code((address) desc, printed, printed_len)) {\n+        if (add_if_absent((address) desc, printed, printed_capacity)) {\n@@ -300,1 +301,1 @@\n-    } else if (thread != NULL) {\n+    } else if (thread != nullptr) {\n@@ -302,1 +303,1 @@\n-      if (cb != NULL && should_print_code((address) cb, printed, printed_len)) {\n+      if (cb != nullptr && add_if_absent((address) cb, printed, printed_capacity)) {\n@@ -834,0 +835,1 @@\n+       _print_native_stack_used = true;\n@@ -911,10 +913,19 @@\n-       \/\/ The first 10 unique code units on the stack should be sufficient\n-       \/\/ for investigating crashes.\n-       int printed_len = 10;\n-       address printed[printed_len];\n-       memset(printed, 0, sizeof(address) * printed_len);\n-\n-       frame fr = os::fetch_frame_from_context(_context);\n-       for (int count = 0; count < printed_len && fr.pc() != nullptr; ) {\n-         if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_len)) {\n-           count++;\n+       if (!_print_native_stack_used) {\n+         \/\/ Only try print code of the crashing frame since\n+         \/\/ we cannot walk the native stack using next_frame.\n+         const int printed_capacity = 1;\n+         address printed_singleton = nullptr;\n+         address* printed = &printed_singleton;\n+         print_code(st, _thread, _pc, true, printed, 1);\n+       } else {\n+         \/\/ Print up to the first 5 unique code units on the stack\n+         const int printed_capacity = 5;\n+         address printed[printed_capacity];\n+         printed[0] = nullptr; \/\/ length(list) == index of first nullptr\n+\n+         frame fr = os::fetch_frame_from_context(_context);\n+         for (int count = 0; count < printed_capacity && fr.pc() != nullptr; ) {\n+           if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+             count++;\n+           }\n+           fr = next_frame(fr, _thread);\n@@ -922,1 +933,0 @@\n-         fr = next_frame(fr, _thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+  \/\/ records if VMError::print_native_stack was used to\n+  \/\/ print the native stack instead of os::platform_print_native_stack\n+  static bool        _print_native_stack_used;\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.compiler2.enabled\n@@ -39,2 +40,2 @@\n-import java.util.Set;\n-import java.util.HashSet;\n+import java.util.List;\n+import java.util.ArrayList;\n@@ -54,0 +55,3 @@\n+        \/\/ Need to make unsafe a compile-time constant so that\n+        \/\/ C2 intrinsifies the call to Unsafe.getLong in method3.\n+        private static final Unsafe unsafe = Unsafe.getUnsafe();\n@@ -55,1 +59,1 @@\n-            method1(0);\n+            method1(10);\n@@ -68,25 +72,4 @@\n-            method4(address);\n-        }\n-        static void method4(long address) {\n-            System.out.println(\"in method4\");\n-            method5(address);\n-        }\n-        static void method5(long address) {\n-            System.out.println(\"in method5\");\n-            method6(address);\n-        }\n-        static void method6(long address) {\n-            System.out.println(\"in method6\");\n-            method7(address);\n-        }\n-        static void method7(long address) {\n-            System.out.println(\"in method7\");\n-            method8(address);\n-        }\n-        static void method8(long address) {\n-            System.out.println(\"in method8\");\n-            method9(address);\n-        }\n-        static void method9(long address) {\n-            System.out.println(\"in method9\");\n-            Unsafe.getUnsafe().getInt(address);\n+            \/\/ Keep chasing pointers until we crash\n+            while (true) {\n+                address = unsafe.getLong(address);\n+            }\n@@ -97,3 +80,3 @@\n-     * Runs Crasher and forces each method in Crasher to be compiled. The inner\n-     * most method (i.e. method9) crashes the VM by reading from 0. The resulting\n-     * hs-err log is expected to have a MachCode section for each method in Crasher.\n+     * Runs Crasher and tries to force compile the methods in Crasher. The inner\n+     * most method crashes the VM with Unsafe. The resulting hs-err log is\n+     * expected to have a min number of MachCode sections.\n@@ -106,2 +89,3 @@\n-            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.*\",\n-            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.*\",\n+            \"-XX:-TieredCompilation\", \/\/ ensure C2 compiles Crasher.method3\n+            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.m*\",\n+            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.m*\",\n@@ -114,1 +98,3 @@\n-            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\");\n+            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\" +\n+                                       \"stderr:\\n\" + output.getStderr() + \"\\n\" +\n+                                       \"stdout:\\n\" + output.getStdout());\n@@ -116,4 +102,7 @@\n-\n-        Path f = Paths.get(hs_err_file);\n-        if (!Files.exists(f)) {\n-            throw new RuntimeException(\"hs_err_pid file missing at \" + f + \".\\n\");\n+        Path hsErrPath = Paths.get(hs_err_file);\n+        if (!Files.exists(hsErrPath)) {\n+            throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath + \".\\n\");\n+        }\n+        String hsErr = Files.readString(hsErrPath);\n+        if (!crashedInCrasherMethod(hsErr)) {\n+            return;\n@@ -121,2 +110,3 @@\n-        String hsErr = Files.readString(Paths.get(hs_err_file));\n-        System.out.println(hsErr);\n+        List<String> nativeFrames = extractNativeFrames(hsErr);\n+        int compiledJavaFrames = (int) nativeFrames.stream().filter(f -> f.startsWith(\"J \")).count();\n+\n@@ -124,5 +114,55 @@\n-        Set<String> expect = Stream.of(Crasher.class.getDeclaredMethods()).map(method -> method.getName()).collect(Collectors.toSet());\n-        Set<String> actual = new HashSet<>();\n-        matcher.results().forEach(mr -> {\n-            if (mr.group(3).equals(Crasher.class.getName())) {\n-                actual.add(mr.group(1));\n+        List<String> machCodeHeaders = matcher.results().map(mr -> String.format(\"'%s' '%s' in '%s'\", mr.group(1), mr.group(2), mr.group(3))).collect(Collectors.toList());\n+        String message = \"Mach code headers: \" + machCodeHeaders +\n+                         \"\\n\\nExtracted MachCode:\\n\" + extractMachCode(hsErr) +\n+                         \"\\n\\nExtracted native frames:\\n\" + String.join(\"\\n\", nativeFrames);\n+        int minExpectedMachCodeSections = Math.max(1, compiledJavaFrames);\n+        Asserts.assertTrue(machCodeHeaders.size() >= minExpectedMachCodeSections, message);\n+    }\n+\n+    \/**\n+     * Checks whether the crashing frame is in {@code Crasher.method3}.\n+     *\/\n+    private static boolean crashedInCrasherMethod(String hsErr) {\n+        boolean checkProblematicFrame = false;\n+        for (String line : hsErr.split(System.lineSeparator())) {\n+            if (line.startsWith(\"# Problematic frame:\")) {\n+                checkProblematicFrame = true;\n+            } else if (checkProblematicFrame) {\n+                String crasherMethod = Crasher.class.getSimpleName() + \".method3\";\n+                if (!line.contains(crasherMethod)) {\n+                    \/\/ There's any number of things that can subvert the attempt\n+                    \/\/ to crash in the expected method.\n+                    System.out.println(\"Crashed in method other than \" + crasherMethod + \"\\n\\n\" + line + \"\\n\\nSkipping rest of test.\");\n+                    return false;\n+                }\n+                return true;\n+            }\n+        }\n+        throw new RuntimeException(\"\\\"# Problematic frame:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n+    }\n+\n+    \/**\n+     * Gets the lines in {@code hsErr} below the line starting with \"Native frames:\" up to the next blank line.\n+     *\/\n+    private static List<String> extractNativeFrames(String hsErr) {\n+        List<String> res = new ArrayList<>();\n+        boolean inNativeFrames = false;\n+        for (String line : hsErr.split(System.lineSeparator())) {\n+            if (line.startsWith(\"Native frames: \")) {\n+                inNativeFrames = true;\n+            } else if (inNativeFrames) {\n+                if (line.trim().isEmpty()) {\n+                    return res;\n+                }\n+                res.add(line);\n+            }\n+        }\n+        throw new RuntimeException(\"\\\"Native frames:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n+    }\n+\n+    private static String extractMachCode(String hsErr) {\n+        int start = hsErr.indexOf(\"[MachCode]\");\n+        if (start != -1) {\n+            int end = hsErr.lastIndexOf(\"[\/MachCode]\");\n+            if (end != -1) {\n+                return hsErr.substring(start, end + \"[\/MachCode]\".length());\n@@ -130,2 +170,3 @@\n-        });\n-        Asserts.assertEquals(expect, actual);\n+            return hsErr.substring(start);\n+        }\n+        return null;\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":88,"deletions":47,"binary":false,"changes":135,"status":"modified"}]}