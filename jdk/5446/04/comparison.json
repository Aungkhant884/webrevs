{"files":[{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -926,1 +927,1 @@\n-      CompileTask::print(st, this, msg, \/*short_form:*\/ false);\n+      CompileTask::print(st, this, msg, \/*short_form:*\/ false, \/* cr *\/ true, \/* timestamp *\/ false);\n@@ -2531,1 +2532,1 @@\n-  print_on(tty, NULL);\n+  print_on(st, NULL);\n@@ -2882,0 +2883,3 @@\n+  \/\/ Decoding an nmethod can write to a PcDescCache (see PcDescCache::add_pc_desc)\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                             const char* msg, bool short_form, bool cr,\n+                             const char* msg, bool short_form, bool cr, bool timestamp,\n@@ -242,2 +242,4 @@\n-    \/\/ Print current time\n-    st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    if (timestamp) {\n+      \/\/ Print current time\n+      st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n+                                      const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true,\n@@ -196,1 +196,1 @@\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true) {\n@@ -199,1 +199,1 @@\n-                           msg, short_form, cr);\n+                           msg, short_form, cr, timestamp);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-    decode((nmethod*)cb, st);\n+    ((nmethod*)cb)->decode2(st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+bool              VMError::_print_native_stack_used = false;\n@@ -244,0 +245,101 @@\n+\/**\n+ * Adds `value` to `list` iff it's not already present and there is sufficient\n+ * capacity (i.e. length(list) < `list_capacity`). The length of the list\n+ * is the index of the first nullptr entry.\n+ *\n+ * @ return true if the value was added, false otherwise\n+ *\/\n+static bool add_if_absent(address value, address* list, int list_capacity) {\n+  for (int i = 0; i < list_capacity; i++) {\n+    if (list[i] == value) {\n+      return false;\n+    }\n+    if (list[i] == nullptr) {\n+      list[i] = value;\n+      if (i + 1 < list_capacity) {\n+        list[i + 1] = nullptr;\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * Prints the VM generated code unit, if any, containing `pc` if it has not already\n+ * been printed. If the code unit is an InterpreterCodelet or StubCodeDesc, it is\n+ * only printed if `is_crash_pc` is true.\n+ *\n+ * @param printed array of code units that have already been printed (delimited by NULL entry)\n+ * @param printed_capacity the capacity of `printed`\n+ * @return true if the code unit was printed, false otherwise\n+ *\/\n+static bool print_code(outputStream* st, Thread* thread, address pc, bool is_crash_pc,\n+                       address* printed, int printed_capacity) {\n+  if (Interpreter::contains(pc)) {\n+    if (is_crash_pc) {\n+      \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n+      InterpreterCodelet* codelet = Interpreter::codelet_containing(pc);\n+      if (codelet != nullptr) {\n+        if (add_if_absent((address) codelet, printed, printed_capacity)) {\n+          codelet->print_on(st);\n+          Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n+    StubCodeDesc* desc = StubCodeDesc::desc_for(pc);\n+    if (desc != nullptr) {\n+      if (is_crash_pc) {\n+        if (add_if_absent((address) desc, printed, printed_capacity)) {\n+          desc->print_on(st);\n+          Disassembler::decode(desc->begin(), desc->end(), st);\n+          return true;\n+        }\n+      }\n+    } else if (thread != nullptr) {\n+      CodeBlob* cb = CodeCache::find_blob(pc);\n+      if (cb != nullptr && add_if_absent((address) cb, printed, printed_capacity)) {\n+        \/\/ Disassembling nmethod will incur resource memory allocation,\n+        \/\/ only do so when thread is valid.\n+        ResourceMark rm(thread);\n+        Disassembler::decode(cb, st);\n+        st->cr();\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * Gets the caller frame of `fr`.\n+ *\n+ * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n+ *\/\n+static frame next_frame(frame fr, Thread* t) {\n+  \/\/ Compiled code may use EBP register on x86 so it looks like\n+  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n+  frame invalid;\n+  if (t != nullptr && t->is_Java_thread()) {\n+    \/\/ Catch very first native frame by using stack address.\n+    \/\/ For JavaThread stack_base and stack_size should be set.\n+    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n+      return invalid;\n+    }\n+    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+      RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n+      return fr.sender(&map);\n+    } else {\n+      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n+      \/\/ it will pass if java compiled code has a pointer in EBP.\n+      if (os::is_first_C_frame(&fr)) return invalid;\n+      return os::get_sender_for_C_frame(&fr);\n+    }\n+  } else {\n+    if (os::is_first_C_frame(&fr)) return invalid;\n+    return os::get_sender_for_C_frame(&fr);\n+  }\n+}\n+\n@@ -261,20 +363,3 @@\n-      \/\/ Compiled code may use EBP register on x86 so it looks like\n-      \/\/ non-walkable C frame. Use frame.sender() for java frames.\n-      if (t && t->is_Java_thread()) {\n-        \/\/ Catch very first native frame by using stack address.\n-        \/\/ For JavaThread stack_base and stack_size should be set.\n-        if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n-          break;\n-        }\n-        if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n-          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n-          fr = fr.sender(&map);\n-        } else {\n-          \/\/ is_first_C_frame() does only simple checks for frame pointer,\n-          \/\/ it will pass if java compiled code has a pointer in EBP.\n-          if (os::is_first_C_frame(&fr)) break;\n-          fr = os::get_sender_for_C_frame(&fr);\n-        }\n-      } else {\n-        if (os::is_first_C_frame(&fr)) break;\n-        fr = os::get_sender_for_C_frame(&fr);\n+      fr = next_frame(fr, t);\n+      if (fr.pc() == nullptr) {\n+        break;\n@@ -750,0 +835,1 @@\n+       _print_native_stack_used = true;\n@@ -824,1 +910,1 @@\n-  STEP(\"printing code blob if possible\")\n+  STEP(\"printing code blobs if possible\")\n@@ -827,20 +913,17 @@\n-       CodeBlob* cb = CodeCache::find_blob(_pc);\n-       if (cb != NULL) {\n-         if (Interpreter::contains(_pc)) {\n-           \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n-           InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);\n-           if (codelet != NULL) {\n-             codelet->print_on(st);\n-             Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n-           }\n-         } else {\n-           StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);\n-           if (desc != NULL) {\n-             desc->print_on(st);\n-             Disassembler::decode(desc->begin(), desc->end(), st);\n-           } else if (_thread != NULL) {\n-             \/\/ Disassembling nmethod will incur resource memory allocation,\n-             \/\/ only do so when thread is valid.\n-             ResourceMark rm(_thread);\n-             Disassembler::decode(cb, st);\n-             st->cr();\n+       if (!_print_native_stack_used) {\n+         \/\/ Only try print code of the crashing frame since\n+         \/\/ we cannot walk the native stack using next_frame.\n+         const int printed_capacity = 1;\n+         address printed_singleton = nullptr;\n+         address* printed = &printed_singleton;\n+         print_code(st, _thread, _pc, true, printed, 1);\n+       } else {\n+         \/\/ Print up to the first 5 unique code units on the stack\n+         const int printed_capacity = 5;\n+         address printed[printed_capacity];\n+         printed[0] = nullptr; \/\/ length(list) == index of first nullptr\n+\n+         frame fr = os::fetch_frame_from_context(_context);\n+         for (int count = 0; count < printed_capacity && fr.pc() != nullptr; ) {\n+           if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+             count++;\n@@ -848,0 +931,1 @@\n+           fr = next_frame(fr, _thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":125,"deletions":41,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+  \/\/ records if VMError::print_native_stack was used to\n+  \/\/ print the native stack instead of os::platform_print_native_stack\n+  static bool        _print_native_stack_used;\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8272586\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that abstract machine code is dumped for the top frames in a hs-err log\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run driver MachCodeFramesInErrorFile\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class MachCodeFramesInErrorFile {\n+    private static class Crasher {\n+        \/\/ Need to make unsafe a compile-time constant so that\n+        \/\/ C2 intrinsifies the call to Unsafe.getLong in method3.\n+        private static final Unsafe unsafe = Unsafe.getUnsafe();\n+        public static void main(String[] args) {\n+            method1(10);\n+        }\n+\n+        static void method1(long address) {\n+            System.out.println(\"in method1\");\n+            method2(address);\n+        }\n+        static void method2(long address) {\n+            System.out.println(\"in method2\");\n+            method3(address);\n+        }\n+        static void method3(long address) {\n+            System.out.println(\"in method3\");\n+            \/\/ Keep chasing pointers until we crash\n+            while (true) {\n+                address = unsafe.getLong(address);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs Crasher and tries to force compile the methods in Crasher. The inner\n+     * most method crashes the VM with Unsafe. The resulting hs-err log is\n+     * expected to have a min number of MachCode sections.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx64m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-Xcomp\",\n+            \"-XX:-TieredCompilation\", \/\/ ensure C2 compiles Crasher.method3\n+            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.m*\",\n+            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.m*\",\n+            Crasher.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Extract hs_err_pid file.\n+        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\" +\n+                                       \"stderr:\\n\" + output.getStderr() + \"\\n\" +\n+                                       \"stdout:\\n\" + output.getStdout());\n+        }\n+        Path hsErrPath = Paths.get(hs_err_file);\n+        if (!Files.exists(hsErrPath)) {\n+            throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath + \".\\n\");\n+        }\n+        String hsErr = Files.readString(hsErrPath);\n+        if (!crashedInCrasherMethod(hsErr)) {\n+            return;\n+        }\n+        List<String> nativeFrames = extractNativeFrames(hsErr);\n+        int compiledJavaFrames = (int) nativeFrames.stream().filter(f -> f.startsWith(\"J \")).count();\n+\n+        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n+        List<String> machCodeHeaders = matcher.results().map(mr -> String.format(\"'%s' '%s' in '%s'\", mr.group(1), mr.group(2), mr.group(3))).collect(Collectors.toList());\n+        String message = \"Mach code headers: \" + machCodeHeaders +\n+                         \"\\n\\nExtracted MachCode:\\n\" + extractMachCode(hsErr) +\n+                         \"\\n\\nExtracted native frames:\\n\" + String.join(\"\\n\", nativeFrames);\n+        int minExpectedMachCodeSections = Math.max(1, compiledJavaFrames);\n+        Asserts.assertTrue(machCodeHeaders.size() >= minExpectedMachCodeSections, message);\n+    }\n+\n+    \/**\n+     * Checks whether the crashing frame is in {@code Crasher.method3}.\n+     *\/\n+    private static boolean crashedInCrasherMethod(String hsErr) {\n+        boolean checkProblematicFrame = false;\n+        for (String line : hsErr.split(System.lineSeparator())) {\n+            if (line.startsWith(\"# Problematic frame:\")) {\n+                checkProblematicFrame = true;\n+            } else if (checkProblematicFrame) {\n+                String crasherMethod = Crasher.class.getSimpleName() + \".method3\";\n+                if (!line.contains(crasherMethod)) {\n+                    \/\/ There's any number of things that can subvert the attempt\n+                    \/\/ to crash in the expected method.\n+                    System.out.println(\"Crashed in method other than \" + crasherMethod + \"\\n\\n\" + line + \"\\n\\nSkipping rest of test.\");\n+                    return false;\n+                }\n+                return true;\n+            }\n+        }\n+        throw new RuntimeException(\"\\\"# Problematic frame:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n+    }\n+\n+    \/**\n+     * Gets the lines in {@code hsErr} below the line starting with \"Native frames:\" up to the next blank line.\n+     *\/\n+    private static List<String> extractNativeFrames(String hsErr) {\n+        List<String> res = new ArrayList<>();\n+        boolean inNativeFrames = false;\n+        for (String line : hsErr.split(System.lineSeparator())) {\n+            if (line.startsWith(\"Native frames: \")) {\n+                inNativeFrames = true;\n+            } else if (inNativeFrames) {\n+                if (line.trim().isEmpty()) {\n+                    return res;\n+                }\n+                res.add(line);\n+            }\n+        }\n+        throw new RuntimeException(\"\\\"Native frames:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n+    }\n+\n+    private static String extractMachCode(String hsErr) {\n+        int start = hsErr.indexOf(\"[MachCode]\");\n+        if (start != -1) {\n+            int end = hsErr.lastIndexOf(\"[\/MachCode]\");\n+            if (end != -1) {\n+                return hsErr.substring(start, end + \"[\/MachCode]\".length());\n+            }\n+            return hsErr.substring(start);\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"}]}