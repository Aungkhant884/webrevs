{"files":[{"patch":"@@ -2531,1 +2531,1 @@\n-  print_on(tty, NULL);\n+  print_on(st, NULL);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-    decode((nmethod*)cb, st);\n+    ((nmethod*)cb)->decode2(st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,0 +244,101 @@\n+\/**\n+ * Determines if the code unit denoted by `owner` should be printed.\n+ * If this method returns true, then `owner` has been added to `printed`.\n+ * If `owner` was already in `printed`, this methods returns false.\n+\n+ *\n+ * @param owner a CodeBlob*, InterpreterCodelet* or StubCodeDesc* value\n+ * @param printed array of owners that have already been printed (delimited by NULL entry)\n+ * @param printed_len the length of `printed`\n+ *\/\n+static bool should_print_code(address owner, address* printed, int printed_len) {\n+  for (int i = 0; i < printed_len; i++) {\n+    if (printed[i] == owner) {\n+      return false;\n+    }\n+    if (printed[i] == 0) {\n+      printed[i] = owner;\n+      return true;\n+    }\n+  }\n+  \/\/ Beyond limit of code units to be printed\n+  return false;\n+}\n+\n+\/**\n+ * Prints the VM generated code unit, if any, containing `pc` if it has not already\n+ * been printed. If the code unit is an InterpreterCodelet or StubCodeDesc, it is\n+ * only printed if `is_crash_pc` is true.\n+ *\n+ * @param printed array of code units that have already been printed (delimited by NULL entry)\n+ * @param printed_len the length of `printed`\n+ *\/\n+static bool print_code(outputStream* st, Thread* thread, address pc, bool is_crash_pc,\n+                            address* printed, int printed_len) {\n+  if (Interpreter::contains(pc)) {\n+    if (is_crash_pc) {\n+      \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n+      InterpreterCodelet* codelet = Interpreter::codelet_containing(pc);\n+      if (codelet != NULL) {\n+        if (should_print_code((address) codelet, printed, printed_len)) {\n+          codelet->print_on(st);\n+          Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n+    StubCodeDesc* desc = StubCodeDesc::desc_for(pc);\n+    if (desc != NULL) {\n+      if (is_crash_pc) {\n+        if (should_print_code((address) desc, printed, printed_len)) {\n+          desc->print_on(st);\n+          Disassembler::decode(desc->begin(), desc->end(), st);\n+          return true;\n+        }\n+      }\n+    } else if (thread != NULL) {\n+      CodeBlob* cb = CodeCache::find_blob(pc);\n+      if (cb != NULL && should_print_code((address) cb, printed, printed_len)) {\n+        \/\/ Disassembling nmethod will incur resource memory allocation,\n+        \/\/ only do so when thread is valid.\n+        ResourceMark rm(thread);\n+        Disassembler::decode(cb, st);\n+        st->cr();\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * Gets the caller frame of `fr`.\n+ *\n+ * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n+ *\/\n+static frame next_frame(frame fr, Thread* t) {\n+  \/\/ Compiled code may use EBP register on x86 so it looks like\n+  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n+  frame invalid;\n+  if (t != nullptr && t->is_Java_thread()) {\n+    \/\/ Catch very first native frame by using stack address.\n+    \/\/ For JavaThread stack_base and stack_size should be set.\n+    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n+      return invalid;\n+    }\n+    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+      RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n+      return fr.sender(&map);\n+    } else {\n+      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n+      \/\/ it will pass if java compiled code has a pointer in EBP.\n+      if (os::is_first_C_frame(&fr)) return invalid;\n+      return os::get_sender_for_C_frame(&fr);\n+    }\n+  } else {\n+    if (os::is_first_C_frame(&fr)) return invalid;\n+    return os::get_sender_for_C_frame(&fr);\n+  }\n+}\n+\n@@ -261,20 +362,3 @@\n-      \/\/ Compiled code may use EBP register on x86 so it looks like\n-      \/\/ non-walkable C frame. Use frame.sender() for java frames.\n-      if (t && t->is_Java_thread()) {\n-        \/\/ Catch very first native frame by using stack address.\n-        \/\/ For JavaThread stack_base and stack_size should be set.\n-        if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n-          break;\n-        }\n-        if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n-          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n-          fr = fr.sender(&map);\n-        } else {\n-          \/\/ is_first_C_frame() does only simple checks for frame pointer,\n-          \/\/ it will pass if java compiled code has a pointer in EBP.\n-          if (os::is_first_C_frame(&fr)) break;\n-          fr = os::get_sender_for_C_frame(&fr);\n-        }\n-      } else {\n-        if (os::is_first_C_frame(&fr)) break;\n-        fr = os::get_sender_for_C_frame(&fr);\n+      fr = next_frame(fr, t);\n+      if (fr.pc() == nullptr) {\n+        break;\n@@ -824,1 +908,1 @@\n-  STEP(\"printing code blob if possible\")\n+  STEP(\"printing code blobs if possible\")\n@@ -827,21 +911,10 @@\n-       CodeBlob* cb = CodeCache::find_blob(_pc);\n-       if (cb != NULL) {\n-         if (Interpreter::contains(_pc)) {\n-           \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n-           InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);\n-           if (codelet != NULL) {\n-             codelet->print_on(st);\n-             Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n-           }\n-         } else {\n-           StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);\n-           if (desc != NULL) {\n-             desc->print_on(st);\n-             Disassembler::decode(desc->begin(), desc->end(), st);\n-           } else if (_thread != NULL) {\n-             \/\/ Disassembling nmethod will incur resource memory allocation,\n-             \/\/ only do so when thread is valid.\n-             ResourceMark rm(_thread);\n-             Disassembler::decode(cb, st);\n-             st->cr();\n-           }\n+       \/\/ The first 10 unique code units on the stack should be sufficient\n+       \/\/ for investigating crashes.\n+       int printed_len = 10;\n+       address printed[printed_len];\n+       memset(printed, 0, sizeof(address) * printed_len);\n+\n+       frame fr = os::fetch_frame_from_context(_context);\n+       for (int count = 0; count < printed_len && fr.pc() != nullptr; ) {\n+         if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_len)) {\n+           count++;\n@@ -849,0 +922,1 @@\n+         fr = next_frame(fr, _thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8272586\n+ * @summary Test that abstract machine code is dumped for the top frames in a hs-err log\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run driver MachCodeFramesInErrorFile\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class MachCodeFramesInErrorFile {\n+    private static class Crasher {\n+        public static void main(String[] args) {\n+            method1(0);\n+        }\n+\n+        static void method1(long address) {\n+            System.out.println(\"in method1\");\n+            method2(address);\n+        }\n+        static void method2(long address) {\n+            System.out.println(\"in method2\");\n+            method3(address);\n+        }\n+        static void method3(long address) {\n+            System.out.println(\"in method3\");\n+            method4(address);\n+        }\n+        static void method4(long address) {\n+            System.out.println(\"in method4\");\n+            method5(address);\n+        }\n+        static void method5(long address) {\n+            System.out.println(\"in method5\");\n+            method6(address);\n+        }\n+        static void method6(long address) {\n+            System.out.println(\"in method6\");\n+            method7(address);\n+        }\n+        static void method7(long address) {\n+            System.out.println(\"in method7\");\n+            method8(address);\n+        }\n+        static void method8(long address) {\n+            System.out.println(\"in method8\");\n+            method9(address);\n+        }\n+        static void method9(long address) {\n+            System.out.println(\"in method9\");\n+            Unsafe.getUnsafe().getInt(address);\n+        }\n+    }\n+\n+    \/**\n+     * Runs Crasher and forces each method in Crasher to be compiled. The inner\n+     * most method (i.e. method9) crashes the VM by reading from 0. The resulting\n+     * hs-err log is expected to have a MachCode section for each method in Crasher.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx64m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-Xcomp\",\n+            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.*\",\n+            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.*\",\n+            Crasher.class.getName());\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Extract hs_err_pid file.\n+        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\");\n+        }\n+\n+        Path f = Paths.get(hs_err_file);\n+        if (!Files.exists(f)) {\n+            throw new RuntimeException(\"hs_err_pid file missing at \" + f + \".\\n\");\n+        }\n+        String hsErr = Files.readString(Paths.get(hs_err_file));\n+        System.out.println(hsErr);\n+        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n+        Set<String> expect = Stream.of(Crasher.class.getDeclaredMethods()).map(method -> method.getName()).collect(Collectors.toSet());\n+        Set<String> actual = new HashSet<>();\n+        matcher.results().forEach(mr -> {\n+            if (mr.group(3).equals(Crasher.class.getName())) {\n+                actual.add(mr.group(1));\n+            }\n+        });\n+        Asserts.assertEquals(expect, actual);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}