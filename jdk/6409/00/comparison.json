{"files":[{"patch":"@@ -32,0 +32,6 @@\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -36,0 +42,1 @@\n+import java.io.Serial;\n@@ -39,0 +46,1 @@\n+import java.util.concurrent.RecursiveTask;\n@@ -41,6 +49,0 @@\n-import jdk.internal.math.DoubleConsts;\n-import jdk.internal.math.FloatConsts;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -1068,1 +1070,1 @@\n-            v2 = v.square().add(d.multiply(u.square())).mod(n);\n+            v2 = v.square(false).add(d.multiply(u.square(false))).mod(n);\n@@ -1584,1 +1586,16 @@\n-        return multiply(val, false);\n+        return multiply(val, false, false);\n+    }\n+\n+    \/**\n+     * Returns a BigInteger whose value is {@code (this * val)}.\n+     * When both {@code this} and {@code val} are large, typically\n+     * in the thousands of bits, parallel multiply might be used.\n+     *\n+     * @implNote An implementation may offer better algorithmic\n+     * performance when {@code val == this}.\n+     *\n+     * @param  val value to be multiplied by this BigInteger.\n+     * @return {@code this * val}\n+     *\/\n+    public BigInteger parallelMultiply(BigInteger val) {\n+        return multiply(val, false, true);\n@@ -1593,0 +1610,1 @@\n+     * @param  parallel whether the multiply should be done in parallel\n@@ -1595,1 +1613,1 @@\n-    private BigInteger multiply(BigInteger val, boolean isRecursion) {\n+    private BigInteger multiply(BigInteger val, boolean isRecursion, boolean parallel) {\n@@ -1602,1 +1620,1 @@\n-            return square();\n+            return square(parallel);\n@@ -1680,1 +1698,1 @@\n-                return multiplyToomCook3(this, val);\n+                return multiplyToomCook3(this, val, parallel);\n@@ -1847,0 +1865,27 @@\n+    private static final class RecursiveMultiply extends RecursiveTask<BigInteger> {\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n+        private final BigInteger a;\n+        private final BigInteger b;\n+        private final boolean isRecursive;\n+        private final boolean parallel;\n+\n+        private RecursiveMultiply(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n+            this.a = a;\n+            this.b = b;\n+            this.isRecursive = isRecursive;\n+            this.parallel = parallel;\n+        }\n+\n+        @Override\n+        protected BigInteger compute() {\n+            return a.multiply(b, isRecursive, parallel);\n+        }\n+\n+        public static RecursiveMultiply create(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n+            var result = new RecursiveMultiply(a, b, isRecursive, parallel);\n+            if (parallel) result.fork(); else result.invoke();\n+            return result;\n+        }\n+    }\n+\n@@ -1875,1 +1920,1 @@\n-    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {\n+    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b, boolean parallel) {\n@@ -1899,1 +1944,2 @@\n-        v0 = a0.multiply(b0, true);\n+        var v0_task = RecursiveMultiply.create(a0, b0, true, parallel);\n+\/\/        v0 = a0.multiply(b0, true, parallel);\n@@ -1902,1 +1948,2 @@\n-        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);\n+        var vm1_task = RecursiveMultiply.create(da1.subtract(a1), db1.subtract(b1), true, parallel);\n+\/\/        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true, parallel);\n@@ -1905,1 +1952,2 @@\n-        v1 = da1.multiply(db1, true);\n+        var v1_task = RecursiveMultiply.create(da1, db1, true, parallel);\n+\/\/        v1 = da1.multiply(db1, true, parallel);\n@@ -1907,2 +1955,5 @@\n-             db1.add(b2).shiftLeft(1).subtract(b0), true);\n-        vinf = a2.multiply(b2, true);\n+             db1.add(b2).shiftLeft(1).subtract(b0), true, parallel);\n+        vinf = a2.multiply(b2, true, parallel);\n+        v0 = v0_task.join();\n+        vm1 = vm1_task.join();\n+        v1 = v1_task.join();\n@@ -2073,2 +2124,2 @@\n-    private BigInteger square() {\n-        return square(false);\n+    private BigInteger square(boolean parallel) {\n+        return square(false, parallel);\n@@ -2084,1 +2135,1 @@\n-    private BigInteger square(boolean isRecursion) {\n+    private BigInteger square(boolean isRecursion, boolean parallel) {\n@@ -2106,1 +2157,1 @@\n-                return squareToomCook3();\n+                return squareToomCook3(parallel);\n@@ -2226,2 +2277,2 @@\n-        BigInteger xhs = xh.square();  \/\/ xhs = xh^2\n-        BigInteger xls = xl.square();  \/\/ xls = xl^2\n+        BigInteger xhs = xh.square(false);  \/\/ xhs = xh^2\n+        BigInteger xls = xl.square(false);  \/\/ xls = xl^2\n@@ -2230,1 +2281,26 @@\n-        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n+        return xhs.shiftLeft(half*32).add(xl.add(xh).square(false).subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n+    }\n+\n+    private static final class RecursiveSquare extends RecursiveTask<BigInteger> {\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n+        private final BigInteger num;\n+        private final boolean isRecursive;\n+        private final boolean parallel;\n+\n+        private RecursiveSquare(BigInteger a, boolean isRecursive, boolean parallel) {\n+            this.num = a;\n+            this.isRecursive = isRecursive;\n+            this.parallel = parallel;\n+        }\n+\n+        @Override\n+        protected BigInteger compute() {\n+            return num.square(isRecursive, parallel);\n+        }\n+\n+        public static RecursiveSquare create(BigInteger a, boolean isRecursive, boolean parallel) {\n+            var result = new RecursiveSquare(a, isRecursive, parallel);\n+            if (parallel) result.fork(); else result.invoke();\n+            return result;\n+        }\n@@ -2240,1 +2316,1 @@\n-    private BigInteger squareToomCook3() {\n+    private BigInteger squareToomCook3(boolean parallel) {\n@@ -2257,1 +2333,2 @@\n-        v0 = a0.square(true);\n+        var v0_fork = RecursiveSquare.create(a0, true, parallel);\n+\/\/        v0 = a0.square(true, parallel);\n@@ -2259,1 +2336,2 @@\n-        vm1 = da1.subtract(a1).square(true);\n+        var vm1_fork = RecursiveSquare.create(da1.subtract(a1), true, parallel);\n+\/\/        vm1 = da1.subtract(a1).square(true, parallel);\n@@ -2261,3 +2339,7 @@\n-        v1 = da1.square(true);\n-        vinf = a2.square(true);\n-        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);\n+        var v1_fork = RecursiveSquare.create(da1, true, parallel);\n+\/\/        v1 = da1.square(true, parallel);\n+        vinf = a2.square(true, parallel);\n+        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true, parallel);\n+        v0 = v0_fork.join();\n+        vm1 = vm1_fork.join();\n+        v1 = v1_fork.join();\n@@ -2518,1 +2600,1 @@\n-                    partToSquare = partToSquare.square();\n+                    partToSquare = partToSquare.square(false);\n@@ -2577,1 +2659,1 @@\n-        BigInteger r = this.subtract(s.square());\n+        BigInteger r = this.subtract(s.square(false));\n@@ -3253,1 +3335,1 @@\n-                baseToPow2 = baseToPow2.square().mod2(p);\n+                baseToPow2 = baseToPow2.square(false).mod2(p);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":115,"deletions":33,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main BigIntegerParallelMultiplyTest\n+ * @summary tests parallelMultiply() method in BigInteger\n+ * @author Heinz Kabutz heinz@javaspecialists.eu\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * This is a simple test class created to ensure that the results\n+ * of multiply() are the same as multiplyParallel(). We calculate\n+ * the Fibonacci numbers using Dijkstra's sum of squares to get\n+ * very large numbers (hundreds of thousands of bits).\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+public class BigIntegerParallelMultiplyTest {\n+    public static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int n = 0; n <= 10; n++) {\n+            BigInteger fib = fibonacci(n, BigInteger::multiply);\n+            System.out.printf(\"fibonacci(%d) = %d%n\", n, fib);\n+        }\n+\n+        compare(1000, 324);\n+        compare(10_000, 3473);\n+        compare(100_000, 34883);\n+        compare(1_000_000, 347084);\n+    }\n+\n+    private static void compare(int n, int expectedBitCount) {\n+        BigInteger multiplyResult = fibonacci(n, BigInteger::multiply);\n+        BigInteger parallelMultiplyResult = fibonacci(n, BigInteger::parallelMultiply);\n+        checkBitCount(n, expectedBitCount, multiplyResult);\n+        checkBitCount(n, expectedBitCount, parallelMultiplyResult);\n+        if (!multiplyResult.equals(parallelMultiplyResult))\n+            throw new AssertionError(\"multiply() and parallelMultiply() give different results\");\n+    }\n+\n+    private static void checkBitCount(int n, int expectedBitCount, BigInteger number) {\n+        if (number.bitCount() != expectedBitCount)\n+            throw new AssertionError(\n+                    \"bitCount of fibonacci(\" + n + \") was expected to be \" + expectedBitCount\n+                            + \" but was \" + number.bitCount());\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * Benchmark for checking performance difference between\n+ * sequential and parallel multiply methods in BigInteger,\n+ * using a large Fibonacci calculation of up to n = 100 million.\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 2, jvmArgsAppend = {\"-XX:+UseParallelGC\", \"-Xmx16g\", \"-Xms16g\", \"-XX:+AlwaysPreTouch\", \"-XX:NewRatio=1\", \"-XX:SurvivorRatio=1\"})\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 2) \/\/ only 2 iterations because each one takes very long\n+@State(Scope.Thread)\n+public class BigIntegerParallelMultiply {\n+    private static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    @Param({\"1000000\", \"10000000\", \"100000000\"})\n+    private int n;\n+\n+    @Benchmark\n+    public void multiply() {\n+        fibonacci(n, BigInteger::multiply);\n+    }\n+\n+    @Benchmark\n+    public void parallelMultiply() {\n+        fibonacci(n, BigInteger::parallelMultiply);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerParallelMultiply.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}