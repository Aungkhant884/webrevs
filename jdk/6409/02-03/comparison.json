{"files":[{"patch":"@@ -1070,1 +1070,1 @@\n-            v2 = v.square(false).add(d.multiply(u.square(false))).mod(n);\n+            v2 = v.square().add(d.multiply(u.square())).mod(n);\n@@ -1586,1 +1586,1 @@\n-        return multiply(val, false, false);\n+        return multiply(val, false, false, 0);\n@@ -1601,1 +1601,1 @@\n-        return multiply(val, false, true);\n+        return multiply(val, false, true, 0);\n@@ -1613,1 +1613,1 @@\n-    private BigInteger multiply(BigInteger val, boolean isRecursion, boolean parallel) {\n+    private BigInteger multiply(BigInteger val, boolean isRecursion, boolean parallel, int depth) {\n@@ -1620,1 +1620,1 @@\n-            return square(parallel);\n+            return square(true, parallel, depth);\n@@ -1698,1 +1698,1 @@\n-                return multiplyToomCook3(this, val, parallel);\n+                return multiplyToomCook3(this, val, parallel, depth);\n@@ -1865,1 +1865,12 @@\n-    private static final class RecursiveMultiply extends RecursiveTask<BigInteger> {\n+    private abstract static sealed class RecursiveOp extends RecursiveTask<BigInteger> {\n+        \/**\n+         * The threshold until when we should continue forking recursive ops\n+         * if parallel is true. By default we use the Math.ceil() of\n+         * log2(availableProcessors). Can be overridden with the system\n+         * property -Djava.math.BigInteger.parallelForkThreshold=num. This\n+         * threshold is only relevant for Toom Cook 3 multiply and square.\n+         *\/\n+        private static final int PARALLEL_FORK_THRESHOLD = Integer.getInteger(\n+                \"java.math.BigInteger.parallelForkThreshold\",\n+                (int) Math.ceil(Math.log(Runtime.getRuntime().availableProcessors()) \/ Math.log(2)));\n+\n@@ -1868,3 +1879,1 @@\n-        private final BigInteger a;\n-        private final BigInteger b;\n-        private final boolean isRecursive;\n+\n@@ -1872,0 +1881,1 @@\n+        private final int depth;\n@@ -1873,4 +1883,1 @@\n-        private RecursiveMultiply(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n-            this.a = a;\n-            this.b = b;\n-            this.isRecursive = isRecursive;\n+        private RecursiveOp(boolean parallel, int depth) {\n@@ -1878,0 +1885,1 @@\n+            this.depth = depth;\n@@ -1880,3 +1888,4 @@\n-        @Override\n-        protected BigInteger compute() {\n-            return a.multiply(b, isRecursive, parallel);\n+        private RecursiveTask<BigInteger> forkOrInvoke() {\n+            if (parallel && depth <= PARALLEL_FORK_THRESHOLD) fork();\n+            else invoke();\n+            return this;\n@@ -1885,4 +1894,48 @@\n-        public static RecursiveMultiply create(BigInteger a, BigInteger b, boolean isRecursive, boolean parallel) {\n-            var result = new RecursiveMultiply(a, b, isRecursive, parallel);\n-            if (parallel) result.fork(); else result.invoke();\n-            return result;\n+        private static final class RecursiveMultiply extends RecursiveOp {\n+            @Serial\n+            private static final long serialVersionUID = 0L;\n+\n+            private final BigInteger a;\n+            private final BigInteger b;\n+\n+            public RecursiveMultiply(BigInteger a, BigInteger b, boolean parallel, int depth) {\n+                super(parallel, depth);\n+                this.a = a;\n+                this.b = b;\n+            }\n+\n+            @Override\n+            public BigInteger compute() {\n+                return a.multiply(b, true, super.parallel, super.depth);\n+            }\n+        }\n+\n+        private static final class RecursiveSquare extends RecursiveOp {\n+            @Serial\n+            private static final long serialVersionUID = 0L;\n+\n+            private final BigInteger a;\n+\n+            public RecursiveSquare(BigInteger a, boolean parallel, int depth) {\n+                super(parallel, depth);\n+                this.a = a;\n+            }\n+\n+            @Override\n+            public BigInteger compute() {\n+                return a.square(true, super.parallel, super.depth);\n+            }\n+        }\n+\n+        private static RecursiveTask<BigInteger> exec(RecursiveOp op) {\n+            if (op.parallel && op.depth <= PARALLEL_FORK_THRESHOLD) op.fork();\n+            else op.invoke();\n+            return op;\n+        }\n+\n+        private static RecursiveTask<BigInteger> multiply(BigInteger a, BigInteger b, boolean parallel, int depth) {\n+            return new RecursiveMultiply(a, b, parallel, depth).forkOrInvoke();\n+        }\n+\n+        private static RecursiveTask<BigInteger> square(BigInteger a, boolean parallel, int depth) {\n+            return new RecursiveSquare(a, parallel, depth).forkOrInvoke();\n@@ -1920,1 +1973,1 @@\n-    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b, boolean parallel) {\n+    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b, boolean parallel, int depth) {\n@@ -1944,2 +1997,1 @@\n-        var v0_task = RecursiveMultiply.create(a0, b0, true, parallel);\n-\/\/        v0 = a0.multiply(b0, true, parallel);\n+        var v0_task = RecursiveOp.multiply(a0, b0, parallel, depth + 1);\n@@ -1948,2 +2000,1 @@\n-        var vm1_task = RecursiveMultiply.create(da1.subtract(a1), db1.subtract(b1), true, parallel);\n-\/\/        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true, parallel);\n+        var vm1_task = RecursiveOp.multiply(da1.subtract(a1), db1.subtract(b1), parallel, depth + 1);\n@@ -1952,2 +2003,1 @@\n-        var v1_task = RecursiveMultiply.create(da1, db1, true, parallel);\n-\/\/        v1 = da1.multiply(db1, true, parallel);\n+        var v1_task = RecursiveOp.multiply(da1, db1, parallel, depth + 1);\n@@ -1955,2 +2005,2 @@\n-             db1.add(b2).shiftLeft(1).subtract(b0), true, parallel);\n-        vinf = a2.multiply(b2, true, parallel);\n+             db1.add(b2).shiftLeft(1).subtract(b0), true, parallel, depth + 1);\n+        vinf = a2.multiply(b2, true, parallel, depth + 1);\n@@ -2124,2 +2174,2 @@\n-    private BigInteger square(boolean parallel) {\n-        return square(false, parallel);\n+    private BigInteger square() {\n+        return square(false, false, 0);\n@@ -2135,1 +2185,1 @@\n-    private BigInteger square(boolean isRecursion, boolean parallel) {\n+    private BigInteger square(boolean isRecursion, boolean parallel, int depth) {\n@@ -2157,1 +2207,1 @@\n-                return squareToomCook3(parallel);\n+                return squareToomCook3(parallel, depth);\n@@ -2277,2 +2327,2 @@\n-        BigInteger xhs = xh.square(false);  \/\/ xhs = xh^2\n-        BigInteger xls = xl.square(false);  \/\/ xls = xl^2\n+        BigInteger xhs = xh.square();  \/\/ xhs = xh^2\n+        BigInteger xls = xl.square();  \/\/ xls = xl^2\n@@ -2281,26 +2331,1 @@\n-        return xhs.shiftLeft(half*32).add(xl.add(xh).square(false).subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n-    }\n-\n-    private static final class RecursiveSquare extends RecursiveTask<BigInteger> {\n-        @Serial\n-        private static final long serialVersionUID = 0L;\n-        private final BigInteger num;\n-        private final boolean isRecursive;\n-        private final boolean parallel;\n-\n-        private RecursiveSquare(BigInteger a, boolean isRecursive, boolean parallel) {\n-            this.num = a;\n-            this.isRecursive = isRecursive;\n-            this.parallel = parallel;\n-        }\n-\n-        @Override\n-        protected BigInteger compute() {\n-            return num.square(isRecursive, parallel);\n-        }\n-\n-        public static RecursiveSquare create(BigInteger a, boolean isRecursive, boolean parallel) {\n-            var result = new RecursiveSquare(a, isRecursive, parallel);\n-            if (parallel) result.fork(); else result.invoke();\n-            return result;\n-        }\n+        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);\n@@ -2316,1 +2341,1 @@\n-    private BigInteger squareToomCook3(boolean parallel) {\n+    private BigInteger squareToomCook3(boolean parallel, int depth) {\n@@ -2333,2 +2358,1 @@\n-        var v0_fork = RecursiveSquare.create(a0, true, parallel);\n-\/\/        v0 = a0.square(true, parallel);\n+        var v0_fork = RecursiveOp.square(a0, parallel, depth + 1);\n@@ -2336,2 +2360,1 @@\n-        var vm1_fork = RecursiveSquare.create(da1.subtract(a1), true, parallel);\n-\/\/        vm1 = da1.subtract(a1).square(true, parallel);\n+        var vm1_fork = RecursiveOp.square(da1.subtract(a1), parallel, depth + 1);\n@@ -2339,4 +2362,3 @@\n-        var v1_fork = RecursiveSquare.create(da1, true, parallel);\n-\/\/        v1 = da1.square(true, parallel);\n-        vinf = a2.square(true, parallel);\n-        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true, parallel);\n+        var v1_fork = RecursiveOp.square(da1, parallel, depth + 1);\n+        vinf = a2.square(true, parallel, depth + 1);\n+        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true, parallel, depth + 1);\n@@ -2600,1 +2622,1 @@\n-                    partToSquare = partToSquare.square(false);\n+                    partToSquare = partToSquare.square();\n@@ -2659,1 +2681,1 @@\n-        BigInteger r = this.subtract(s.square(false));\n+        BigInteger r = this.subtract(s.square());\n@@ -3335,1 +3357,1 @@\n-                baseToPow2 = baseToPow2.square(false).mod2(p);\n+                baseToPow2 = baseToPow2.square().mod2(p);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":96,"deletions":74,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -70,0 +70,11 @@\n+        for (int n = 1_000; n <= 10_000_000; n *= 10) {\n+            System.out.println();\n+            long time = System.nanoTime();\n+            try {\n+                var fib = fibonacci(n, BigInteger::parallelMultiply);\n+                System.out.print(\"fibonacci(\" + n + \") \" + fib.bitLength());\n+            } finally {\n+                time = System.nanoTime() - time;\n+                System.out.printf(\" took %dms%n\", (time \/ 1_000_000));\n+            }\n+        }\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}