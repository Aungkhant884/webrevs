{"files":[{"patch":"@@ -39,0 +39,3 @@\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.RecursiveTask;\n@@ -1584,1 +1587,16 @@\n-        return multiply(val, false);\n+        return multiply(val, false, false, 0);\n+    }\n+\n+    \/**\n+     * Returns a BigInteger whose value is {@code (this * val)}.\n+     * When both {@code this} and {@code val} are large, typically\n+     * in the thousands of bits, parallel multiply might be used.\n+     *\n+     * @implNote An implementation may offer better algorithmic\n+     * performance when {@code val == this}.\n+     *\n+     * @param  val value to be multiplied by this BigInteger.\n+     * @return {@code this * val}\n+     *\/\n+    public BigInteger parallelMultiply(BigInteger val) {\n+        return multiply(val, false, true, 0);\n@@ -1593,0 +1611,1 @@\n+     * @param  parallel whether the multiply should be done in parallel\n@@ -1595,1 +1614,1 @@\n-    private BigInteger multiply(BigInteger val, boolean isRecursion) {\n+    private BigInteger multiply(BigInteger val, boolean isRecursion, boolean parallel, int depth) {\n@@ -1602,1 +1621,1 @@\n-            return square();\n+            return square(true, parallel, depth);\n@@ -1680,1 +1699,1 @@\n-                return multiplyToomCook3(this, val);\n+                return multiplyToomCook3(this, val, parallel, depth);\n@@ -1847,0 +1866,82 @@\n+    @SuppressWarnings(\"serial\")\n+    private abstract static sealed class RecursiveOp extends RecursiveTask<BigInteger> {\n+        \/**\n+         * The threshold until when we should continue forking recursive ops\n+         * if parallel is true. This threshold is only relevant for Toom Cook 3\n+         * multiply and square.\n+         *\/\n+        private static final int PARALLEL_FORK_DEPTH_THRESHOLD =\n+                calculateMaximumDepth(ForkJoinPool.getCommonPoolParallelism());\n+\n+        private static final int calculateMaximumDepth(int parallelism) {\n+            return 32 - Integer.numberOfLeadingZeros(parallelism);\n+        }\n+\n+        final boolean parallel;\n+        \/**\n+         * The current recursing depth. Since it is a logarithmic algorithm,\n+         * we do not need an int to hold the number.\n+         *\/\n+        final byte depth;\n+\n+        private RecursiveOp(boolean parallel, int depth) {\n+            this.parallel = parallel;\n+            this.depth = (byte) depth;\n+        }\n+\n+        private static int getParallelForkDepthThreshold() {\n+            if (Thread.currentThread() instanceof ForkJoinWorkerThread fjwt) {\n+                return calculateMaximumDepth(fjwt.getPool().getParallelism());\n+            }\n+            else {\n+                return PARALLEL_FORK_DEPTH_THRESHOLD;\n+            }\n+        }\n+\n+        protected RecursiveTask<BigInteger> forkOrInvoke() {\n+            if (parallel && depth <= getParallelForkDepthThreshold()) fork();\n+            else invoke();\n+            return this;\n+        }\n+\n+        @SuppressWarnings(\"serial\")\n+        private static final class RecursiveMultiply extends RecursiveOp {\n+            private final BigInteger a;\n+            private final BigInteger b;\n+\n+            public RecursiveMultiply(BigInteger a, BigInteger b, boolean parallel, int depth) {\n+                super(parallel, depth);\n+                this.a = a;\n+                this.b = b;\n+            }\n+\n+            @Override\n+            public BigInteger compute() {\n+                return a.multiply(b, true, parallel, depth);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"serial\")\n+        private static final class RecursiveSquare extends RecursiveOp {\n+            private final BigInteger a;\n+\n+            public RecursiveSquare(BigInteger a, boolean parallel, int depth) {\n+                super(parallel, depth);\n+                this.a = a;\n+            }\n+\n+            @Override\n+            public BigInteger compute() {\n+                return a.square(true, parallel, depth);\n+            }\n+        }\n+\n+        private static RecursiveTask<BigInteger> multiply(BigInteger a, BigInteger b, boolean parallel, int depth) {\n+            return new RecursiveMultiply(a, b, parallel, depth).forkOrInvoke();\n+        }\n+\n+        private static RecursiveTask<BigInteger> square(BigInteger a, boolean parallel, int depth) {\n+            return new RecursiveSquare(a, parallel, depth).forkOrInvoke();\n+        }\n+    }\n+\n@@ -1875,1 +1976,1 @@\n-    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {\n+    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b, boolean parallel, int depth) {\n@@ -1899,1 +2000,2 @@\n-        v0 = a0.multiply(b0, true);\n+        depth++;\n+        var v0_task = RecursiveOp.multiply(a0, b0, parallel, depth);\n@@ -1902,1 +2004,1 @@\n-        vm1 = da1.subtract(a1).multiply(db1.subtract(b1), true);\n+        var vm1_task = RecursiveOp.multiply(da1.subtract(a1), db1.subtract(b1), parallel, depth);\n@@ -1905,1 +2007,1 @@\n-        v1 = da1.multiply(db1, true);\n+        var v1_task = RecursiveOp.multiply(da1, db1, parallel, depth);\n@@ -1907,2 +2009,5 @@\n-             db1.add(b2).shiftLeft(1).subtract(b0), true);\n-        vinf = a2.multiply(b2, true);\n+             db1.add(b2).shiftLeft(1).subtract(b0), true, parallel, depth);\n+        vinf = a2.multiply(b2, true, parallel, depth);\n+        v0 = v0_task.join();\n+        vm1 = vm1_task.join();\n+        v1 = v1_task.join();\n@@ -2074,1 +2179,1 @@\n-        return square(false);\n+        return square(false, false, 0);\n@@ -2084,1 +2189,1 @@\n-    private BigInteger square(boolean isRecursion) {\n+    private BigInteger square(boolean isRecursion, boolean parallel, int depth) {\n@@ -2106,1 +2211,1 @@\n-                return squareToomCook3();\n+                return squareToomCook3(parallel, depth);\n@@ -2240,1 +2345,1 @@\n-    private BigInteger squareToomCook3() {\n+    private BigInteger squareToomCook3(boolean parallel, int depth) {\n@@ -2257,1 +2362,2 @@\n-        v0 = a0.square(true);\n+        depth++;\n+        var v0_fork = RecursiveOp.square(a0, parallel, depth);\n@@ -2259,1 +2365,1 @@\n-        vm1 = da1.subtract(a1).square(true);\n+        var vm1_fork = RecursiveOp.square(da1.subtract(a1), parallel, depth);\n@@ -2261,3 +2367,6 @@\n-        v1 = da1.square(true);\n-        vinf = a2.square(true);\n-        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true);\n+        var v1_fork = RecursiveOp.square(da1, parallel, depth);\n+        vinf = a2.square(true, parallel, depth);\n+        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square(true, parallel, depth);\n+        v0 = v0_fork.join();\n+        vm1 = vm1_fork.join();\n+        v1 = v1_fork.join();\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":128,"deletions":19,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main BigIntegerParallelMultiplyTest\n+ * @summary tests parallelMultiply() method in BigInteger\n+ * @author Heinz Kabutz heinz@javaspecialists.eu\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * This is a simple test class created to ensure that the results\n+ * of multiply() are the same as multiplyParallel(). We calculate\n+ * the Fibonacci numbers using Dijkstra's sum of squares to get\n+ * very large numbers (hundreds of thousands of bits).\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+public class BigIntegerParallelMultiplyTest {\n+    public static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        compare(1000, 324);\n+        compare(10_000, 3473);\n+        compare(100_000, 34883);\n+        compare(1_000_000, 347084);\n+    }\n+\n+    private static void compare(int n, int expectedBitCount) {\n+        BigInteger multiplyResult = fibonacci(n, BigInteger::multiply);\n+        BigInteger parallelMultiplyResult = fibonacci(n, BigInteger::parallelMultiply);\n+        checkBitCount(n, expectedBitCount, multiplyResult);\n+        checkBitCount(n, expectedBitCount, parallelMultiplyResult);\n+        if (!multiplyResult.equals(parallelMultiplyResult))\n+            throw new AssertionError(\"multiply() and parallelMultiply() give different results\");\n+    }\n+\n+    private static void checkBitCount(int n, int expectedBitCount, BigInteger number) {\n+        if (number.bitCount() != expectedBitCount)\n+            throw new AssertionError(\n+                    \"bitCount of fibonacci(\" + n + \") was expected to be \" + expectedBitCount\n+                            + \" but was \" + number.bitCount());\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerParallelMultiplyTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,322 @@\n+package org.openjdk.bench.java.math;\n+\n+import javax.management.MBeanServer;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.LongSummaryStatistics;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BinaryOperator;\n+import java.util.function.LongUnaryOperator;\n+import java.util.stream.Collectors;\n+\n+import static java.util.concurrent.ForkJoinPool.defaultForkJoinWorkerThreadFactory;\n+\n+\/**\n+ * Benchmark for checking performance difference between sequential and parallel\n+ * multiply of very large Mersenne primes using BigInteger. We want to measure\n+ * real time, user time, system time and the amount of memory allocated. To\n+ * calculate this, we create our own thread factory for the common ForkJoinPool\n+ * and then use that to measure user time, cpu time and bytes allocated.\n+ * <p>\n+ * We use reflection to discover all methods that match \"*ultiply\", and use them\n+ * to multiply two very large Mersenne primes together.\n+ * <p>\n+ * <h3>Results on a 1-6-2 machine running Ubuntu linux<\/h3>\n+ * <p>\n+ * Memory allocation increased from 83.9GB to 84GB, for both the sequential and\n+ * parallel versions. This is an increase of just 0.1%. On this machine, the\n+ * parallel version was 3.8x faster in latency (real time), but it used 2.7x\n+ * more CPU resources.\n+ * <p>\n+ * Testing multiplying Mersenne primes of 2^57885161-1 and 2^82589933-1\n+ * <p>\n+ * <pre>\n+ * openjdk version \"18-internal\" 2022-03-15\n+ * BigInteger.parallelMultiply()\n+ * real  0m6.288s\n+ * user  1m3.010s\n+ * sys   0m0.027s\n+ * mem   84.0GB\n+ * BigInteger.multiply()\n+ * real  0m23.682s\n+ * user  0m23.530s\n+ * sys   0m0.004s\n+ * mem   84.0GB\n+ *\n+ * openjdk version \"1.8.0_302\"\n+ * BigInteger.multiply()\n+ * real  0m25.657s\n+ * user  0m25.390s\n+ * sys   0m0.001s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"9.0.7.1\"\n+ * BigInteger.multiply()\n+ * real  0m24.907s\n+ * user  0m24.700s\n+ * sys   0m0.001s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"10.0.2\" 2018-07-17\n+ * BigInteger.multiply()\n+ * real  0m24.632s\n+ * user  0m24.380s\n+ * sys   0m0.004s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"11.0.12\" 2021-07-20 LTS\n+ * BigInteger.multiply()\n+ * real  0m22.114s\n+ * user  0m21.930s\n+ * sys   0m0.001s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"12.0.2\" 2019-07-16\n+ * BigInteger.multiply()\n+ * real  0m23.015s\n+ * user  0m22.830s\n+ * sys   0m0.000s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"13.0.9\" 2021-10-19\n+ * BigInteger.multiply()\n+ * real  0m23.548s\n+ * user  0m23.350s\n+ * sys   0m0.005s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"14.0.2\" 2020-07-14\n+ * BigInteger.multiply()\n+ * real  0m22.918s\n+ * user  0m22.530s\n+ * sys   0m0.131s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"15.0.5\" 2021-10-19\n+ * BigInteger.multiply()\n+ * real  0m22.038s\n+ * user  0m21.750s\n+ * sys   0m0.003s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"16.0.2\" 2021-07-20\n+ * BigInteger.multiply()\n+ * real  0m23.049s\n+ * user  0m22.760s\n+ * sys   0m0.006s\n+ * mem   83.9GB\n+ *\n+ * openjdk version \"17\" 2021-09-14\n+ * BigInteger.multiply()\n+ * real  0m22.580s\n+ * user  0m22.310s\n+ * sys   0m0.001s\n+ * mem   83.9GB\n+ *<\/pre>\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+public class BigIntegerMersennePrimeMultiply implements ForkJoinPool.ForkJoinWorkerThreadFactory {\n+    \/\/ Large Mersenne prime discovered by Curtis Cooper in 2013\n+    private static final int EXPONENT_1 = 57885161;\n+    private static final BigInteger MERSENNE_1 =\n+            BigInteger.ONE.shiftLeft(EXPONENT_1).subtract(BigInteger.ONE);\n+    \/\/ Largest Mersenne prime number discovered by Patrick Laroche in 2018\n+    private static final int EXPONENT_2 = 82589933;\n+    private static final BigInteger MERSENNE_2 =\n+            BigInteger.ONE.shiftLeft(EXPONENT_2).subtract(BigInteger.ONE);\n+    private static boolean DEBUG = false;\n+\n+    public static void main(String... args) {\n+        System.setProperty(\"java.util.concurrent.ForkJoinPool.common.threadFactory\",\n+                BigIntegerMersennePrimeMultiply.class.getName());\n+        System.out.println(\"Testing multiplying Mersenne primes of \" +\n+                \"2^\" + EXPONENT_1 + \"-1 and 2^\" + EXPONENT_2 + \"-1\");\n+        addCounters(Thread.currentThread());\n+        System.out.println(\"Using the following multiply methods:\");\n+        List<Method> methods = Arrays.stream(BigInteger.class.getMethods())\n+                .filter(method -> method.getName().endsWith(\"ultiply\") &&\n+                        method.getParameterCount() == 1 &&\n+                        method.getParameterTypes()[0] == BigInteger.class)\n+                .peek(method -> System.out.println(\"    \" + method))\n+                .collect(Collectors.toList());\n+\n+        for (int i = 0; i < 3; i++) {\n+            System.out.println();\n+            methods.forEach(BigIntegerMersennePrimeMultiply::test);\n+        }\n+    }\n+\n+    private static void test(Method method) {\n+        BinaryOperator<BigInteger> multiplyOperator = (a, b) -> {\n+            try {\n+                return (BigInteger) method.invoke(a, b);\n+            } catch (IllegalAccessException e) {\n+                throw new AssertionError(e);\n+            } catch (InvocationTargetException e) {\n+                throw new AssertionError(e.getCause());\n+            }\n+        };\n+        test(method.getName(), multiplyOperator);\n+    }\n+\n+    private static void test(String description,\n+                             BinaryOperator<BigInteger> multiplyOperator) {\n+        System.out.println(\"BigInteger.\" + description + \"()\");\n+        resetAllCounters();\n+        long elapsedTimeInNanos = System.nanoTime();\n+        try {\n+            BigInteger result1 = multiplyOperator.apply(MERSENNE_1, MERSENNE_2);\n+            BigInteger result2 = multiplyOperator.apply(MERSENNE_2, MERSENNE_1);\n+            if (result1.bitLength() != 140475094)\n+                throw new AssertionError(\"Expected bitLength: 140475094, \" +\n+                        \"but was \" + result1.bitLength());\n+            if (result2.bitLength() != 140475094)\n+                throw new AssertionError(\"Expected bitLength: 140475094, \" +\n+                        \"but was \" + result1.bitLength());\n+        } finally {\n+            elapsedTimeInNanos = System.nanoTime() - elapsedTimeInNanos;\n+        }\n+\n+        LongSummaryStatistics userTimeStatistics = getStatistics(userTime);\n+        LongSummaryStatistics cpuTimeStatistics = getStatistics(cpuTime);\n+        LongSummaryStatistics memoryAllocationStatistics = getStatistics(bytes);\n+        System.out.println(\"real  \" + formatTime(elapsedTimeInNanos));\n+        System.out.println(\"user  \" + formatTime(userTimeStatistics.getSum()));\n+        System.out.println(\"sys   \" +\n+                formatTime(cpuTimeStatistics.getSum() - userTimeStatistics.getSum()));\n+        System.out.println(\"mem   \" + formatMemory(memoryAllocationStatistics.getSum(), 1));\n+    }\n+\n+    private static LongSummaryStatistics getStatistics(Map<Thread, AtomicLong> timeMap) {\n+        return timeMap.entrySet()\n+                .stream()\n+                .peek(entry -> {\n+                    long timeInMs = (counterExtractorMap.get(timeMap)\n+                            .applyAsLong(entry.getKey().getId())\n+                            - entry.getValue().get());\n+                    entry.getValue().set(timeInMs);\n+                })\n+                .peek(BigIntegerMersennePrimeMultiply::printTime)\n+                .map(Map.Entry::getValue)\n+                .mapToLong(AtomicLong::get)\n+                .summaryStatistics();\n+    }\n+\n+    private static void printTime(Map.Entry<Thread, AtomicLong> threadCounter) {\n+        if (DEBUG)\n+            System.out.printf(\"%s %d%n\", threadCounter.getKey(), threadCounter.getValue()\n+                    .get());\n+    }\n+\n+    private static void addCounters(Thread thread) {\n+        counterExtractorMap.forEach((map, timeExtractor) -> add(map, thread, timeExtractor));\n+    }\n+\n+    private static void add(Map<Thread, AtomicLong> time, Thread thread,\n+                            LongUnaryOperator timeExtractor) {\n+        time.put(thread, new AtomicLong(timeExtractor.applyAsLong(thread.getId())));\n+    }\n+\n+    private static void resetAllCounters() {\n+        counterExtractorMap.forEach(BigIntegerMersennePrimeMultiply::resetTimes);\n+    }\n+\n+    private static void resetTimes(Map<Thread, AtomicLong> timeMap, LongUnaryOperator timeMethod) {\n+        timeMap.forEach((thread, time) ->\n+                time.set(timeMethod.applyAsLong(thread.getId())));\n+    }\n+\n+    private static final Map<Thread, AtomicLong> userTime =\n+            new ConcurrentHashMap<>();\n+    private static final Map<Thread, AtomicLong> cpuTime =\n+            new ConcurrentHashMap<>();\n+    private static final Map<Thread, AtomicLong> bytes =\n+            new ConcurrentHashMap<>();\n+    private static final ThreadMXBean tmb = ManagementFactory.getThreadMXBean();\n+\n+    private static final Map<Map<Thread, AtomicLong>, LongUnaryOperator> counterExtractorMap =\n+            new IdentityHashMap<>();\n+\n+    static {\n+        counterExtractorMap.put(userTime, tmb::getThreadUserTime);\n+        counterExtractorMap.put(cpuTime, tmb::getThreadCpuTime);\n+        counterExtractorMap.put(bytes, BigIntegerMersennePrimeMultiply::threadAllocatedBytes);\n+    }\n+\n+    public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n+        ForkJoinWorkerThread thread = defaultForkJoinWorkerThreadFactory.newThread(pool);\n+        addCounters(thread);\n+        return thread;\n+    }\n+\n+    private static final String[] SIGNATURE = new String[]{long.class.getName()};\n+    private static final MBeanServer mBeanServer;\n+    private static final ObjectName name;\n+\n+    static {\n+        try {\n+            name = new ObjectName(ManagementFactory.THREAD_MXBEAN_NAME);\n+            mBeanServer = ManagementFactory.getPlatformMBeanServer();\n+        } catch (MalformedObjectNameException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static long threadAllocatedBytes(long threadId) {\n+        try {\n+            return (long) mBeanServer.invoke(\n+                    name,\n+                    \"getThreadAllocatedBytes\",\n+                    new Object[]{threadId},\n+                    SIGNATURE\n+            );\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    public static String formatMemory(double bytes, int decimals) {\n+        double val;\n+        String unitStr;\n+        if (bytes < 1024) {\n+            val = bytes;\n+            unitStr = \"B\";\n+        } else if (bytes < 1024 * 1024) {\n+            val = bytes \/ 1024;\n+            unitStr = \"KB\";\n+        } else if (bytes < 1024 * 1024 * 1024) {\n+            val = bytes \/ (1024 * 1024);\n+            unitStr = \"MB\";\n+        } else if (bytes < 1024 * 1024 * 1024 * 1024L) {\n+            val = bytes \/ (1024 * 1024 * 1024L);\n+            unitStr = \"GB\";\n+        } else {\n+            val = bytes \/ (1024 * 1024 * 1024 * 1024L);\n+            unitStr = \"TB\";\n+        }\n+        return String.format(Locale.US, \"%.\" + decimals + \"f%s\", val, unitStr);\n+    }\n+\n+    public static String formatTime(long nanos) {\n+        if (nanos < 0) nanos = 0;\n+        long timeInMs = TimeUnit.NANOSECONDS.toMillis(nanos);\n+        long minutes = timeInMs \/ 60_000;\n+        double remainingMs = (timeInMs % 60_000) \/ 1000.0;\n+        return String.format(Locale.US, \"%dm%.3fs\", minutes, remainingMs);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerMersennePrimeMultiply.java","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BinaryOperator;\n+\n+\/**\n+ * Benchmark for checking performance difference between\n+ * sequential and parallel multiply methods in BigInteger,\n+ * using a large Fibonacci calculation of up to n = 100 million.\n+ *\n+ * @author Heinz Kabutz, heinz@javaspecialists.eu\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 2)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 2) \/\/ only 2 iterations because each one takes very long\n+@State(Scope.Thread)\n+public class BigIntegerParallelMultiply {\n+    private static BigInteger fibonacci(int n, BinaryOperator<BigInteger> multiplyOperator) {\n+        if (n == 0) return BigInteger.ZERO;\n+        if (n == 1) return BigInteger.ONE;\n+\n+        int half = (n + 1) \/ 2;\n+        BigInteger f0 = fibonacci(half - 1, multiplyOperator);\n+        BigInteger f1 = fibonacci(half, multiplyOperator);\n+        if (n % 2 == 1) {\n+            BigInteger b0 = multiplyOperator.apply(f0, f0);\n+            BigInteger b1 = multiplyOperator.apply(f1, f1);\n+            return b0.add(b1);\n+        } else {\n+            BigInteger b0 = f0.shiftLeft(1).add(f1);\n+            return multiplyOperator.apply(b0, f1);\n+        }\n+    }\n+\n+    @Param({\"1000000\", \"10000000\", \"100000000\"})\n+    private int n;\n+\n+    @Benchmark\n+    public void multiply() {\n+        fibonacci(n, BigInteger::multiply);\n+    }\n+\n+    @Benchmark\n+    public void parallelMultiply() {\n+        fibonacci(n, BigInteger::parallelMultiply);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerParallelMultiply.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}