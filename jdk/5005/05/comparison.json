{"files":[{"patch":"@@ -1739,0 +1739,3 @@\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1563,0 +1563,9 @@\n+    case Op_CopySignD:\n+    case Op_CopySignF:\n+      if (UseAVX < 3 || !is_LP64)  {\n+        return false;\n+      }\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -5776,1 +5785,1 @@\n-\/\/ --------------------------------- Signum ---------------------------\n+\/\/ --------------------------------- Signum\/CopySign ---------------------------\n@@ -5800,0 +5809,47 @@\n+\/\/ ---------------------------------------\n+\/\/ For copySign use 0xE4 as writemask for vpternlog\n+\/\/ Desired Truth Table: A -> xmm0 bit, B -> xmm1 bit, C -> xmm2 bit\n+\/\/ C (xmm2) is set to 0x7FFFFFFF\n+\/\/ Wherever xmm2 is 0, we want to pick from B (sign)\n+\/\/ Wherever xmm2 is 1, we want to pick from A (src)\n+\/\/\n+\/\/ A B C Result\n+\/\/ 0 0 0 0\n+\/\/ 0 0 1 0\n+\/\/ 0 1 0 1\n+\/\/ 0 1 1 0\n+\/\/ 1 0 0 0\n+\/\/ 1 0 1 1\n+\/\/ 1 1 0 1\n+\/\/ 1 1 1 1\n+\/\/\n+\/\/ Result going from high bit to low bit is 0x11100100 = 0xe4\n+\/\/ ---------------------------------------\n+\n+#ifdef _LP64\n+instruct copySignF_reg(regF dst, regF src, regF tmp1, rRegI tmp2) %{\n+  match(Set dst (CopySignF dst src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignF $dst, $src\\t! using $tmp1 and $tmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ movl($tmp2$$Register, 0x7FFFFFFF);\n+    __ movdl($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogd($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct copySignD_imm(regD dst, regD src, regD tmp1, rRegL tmp2, immD zero) %{\n+  match(Set dst (CopySignD dst (Binary src zero)));\n+  ins_cost(100);\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignD  $dst, $src\\t! using $tmp1 and $tmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ mov64($tmp2$$Register, 0x7FFFFFFFFFFFFFFF);\n+    __ movq($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogq($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -103,0 +103,10 @@\n+    private static double Copysign_Kernel(double data, double sign)\n+    {\n+        return Math.copySign(data, sign);\n+    }\n+\n+    private static float Copysign_Kernel(float data, float sign)\n+    {\n+        return Math.copySign(data, sign);\n+    }\n+\n@@ -142,0 +152,41 @@\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _5_copySignFloatTest(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (float f : float_values) {\n+                bh.consume(Copysign_Kernel(floatValue, f));\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _6_overheadCopySignFloat(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (float f : float_values) {\n+                bh.consume(f);\n+            }\n+       }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _7_copySignDoubleTest(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (double d : double_values) {\n+                bh.consume(Copysign_Kernel(doubleValue, d));\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _8_overheadCopySignDouble(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (double d : double_values) {\n+                bh.consume(d);\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/Signum.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}