{"files":[{"patch":"@@ -2732,0 +2732,15 @@\n+void Assembler::vmovd(XMMRegister dst, Register src) {\n+  assert(UseAVX > 0, \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovq(XMMRegister dst, Register src) {\n+  assert(UseAVX > 0, \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1511,0 +1511,3 @@\n+  void vmovd(XMMRegister dst, Register src);\n+  void vmovq(XMMRegister dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1739,0 +1739,3 @@\n+  if (FLAG_IS_DEFAULT(UseCopySignIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseCopySignIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1684,0 +1684,9 @@\n+    case Op_CopySignD:\n+    case Op_CopySignF:\n+      if (UseAVX < 3)  {\n+        return false;\n+      }\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -5800,0 +5809,41 @@\n+instruct copySignF_reg(regF dst, regF src, regF tmp1, rRegL tmp2) %{\n+  predicate(UseAVX >= 3 && VM_Version::supports_avx512vl());\n+  match(Set dst (CopySignF dst src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignF $dst, $src\" %}\n+  ins_encode %{\n+    __ movl($tmp2$$Register, 0x7FFFFFFF);\n+    __ vmovd($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogd($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct copySignD_reg(regD dst, regD src, regD tmp1, rRegL tmp2, regD zero) %{\n+  predicate(UseAVX >= 3 && VM_Version::supports_avx512vl());\n+  match(Set dst (CopySignD dst (Binary src zero)));\n+  ins_cost(125);\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignD $dst, $src\" %}\n+  ins_encode %{\n+    __ mov64($tmp2$$Register, 0x7FFFFFFFFFFFFFFF);\n+    __ vmovq($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogq($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct copySignD_imm(regD dst, regD src, regD tmp1, rRegL tmp2, immD zero) %{\n+  predicate(UseAVX >= 3 && VM_Version::supports_avx512vl());\n+  match(Set dst (CopySignD dst (Binary src zero)));\n+  ins_cost(100);\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"CopySignD $dst, $src\" %}\n+  ins_encode %{\n+    __ mov64($tmp2$$Register, 0x7FFFFFFFFFFFFFFF);\n+    __ vmovq($tmp1$$XMMRegister, $tmp2$$Register);\n+    __ vpternlogq($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $tmp1$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -103,0 +103,10 @@\n+    private static double Copysign_Kernel(double data, double sign)\n+    {\n+        return Math.copySign(data, sign);\n+    }\n+\n+    private static float Copysign_Kernel(float data, float sign)\n+    {\n+        return Math.copySign(data, sign);\n+    }\n+\n@@ -142,0 +152,41 @@\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _5_copySignFloatTest(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (float f : float_values) {\n+                bh.consume(Copysign_Kernel(floatValue, f));\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _6_overheadCopySignFloat(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (float f : float_values) {\n+                bh.consume(f);\n+            }\n+       }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _7_copySignDoubleTest(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (double d : double_values) {\n+                bh.consume(Copysign_Kernel(doubleValue, d));\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(ITERATIONS * 17)\n+    public void _8_overheadCopySignDouble(Blackhole bh) {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            for (double d : double_values) {\n+                bh.consume(d);\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/Signum.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}