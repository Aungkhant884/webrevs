{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.module.ModuleReference;\n@@ -47,0 +48,1 @@\n+import java.nio.file.Path;\n@@ -48,0 +50,1 @@\n+import java.util.Arrays;\n@@ -145,4 +148,17 @@\n-    byte[] compileJavaFileByName(String name) throws Fault {\n-        var firstDollarSign = name.indexOf('$'); \/\/ [package . ] name [ $ enclosed ]\n-        var container = firstDollarSign == -1 ? name : name.substring(0, firstDollarSign);\n-        var path = container.replace('.', '\/') + \".java\";\n+    \/**\n+     * Determines a source file from the given class name and compiles it.\n+     * Any messages generated during compilation will be written to the stream\n+     * provided when this object was created.\n+     * <p>\n+     * This method is passed a reference to an instance of {@link MemoryClassLoader},\n+     * that uses it to compile a source file on demand.\n+     *\n+     * @param name the name of the class to be compiled.\n+     * @return the byte code of the compiled class or {@code null}\n+     *         if no source file was found for the given name\n+     *\/\n+    byte[] compileJavaFileByName(String name) {\n+        \/\/ Determine source file from class name.\n+        var firstDollarSign = name.indexOf('$'); \/\/ [package . ] name [ $ enclosed [$ deeper] ]\n+        var packageAndClassName = firstDollarSign == -1 ? name : name.substring(0, firstDollarSign);\n+        var path = packageAndClassName.replace('.', '\/') + \".java\";\n@@ -150,0 +166,2 @@\n+\n+        \/\/ Trivial case: no matching source file exists\n@@ -152,0 +170,1 @@\n+        \/\/ Compile source file (unit) with similar options as the program.\n@@ -159,1 +178,1 @@\n-            \/\/ don't throw fault - fail fast!\n+            \/\/ Don't throw fault - fail fast!\n@@ -163,0 +182,2 @@\n+\n+        \/\/ The memory file manager stored bytes in the context map, indexed by the class names.\n@@ -166,1 +187,10 @@\n-    Class<?> loadMainClass(ClassLoader parent, String mainClassName) throws ClassNotFoundException, Fault {\n+    \/**\n+     * Load main entry-point class.\n+     *\n+     * @param parent the class loader to be used as the parent loader\n+     * @param mainClassName the fully-qualified name of the application class to load\n+     * @return class object representing the desired class\n+     * @throws ClassNotFoundException if the class cannot be located\n+     * @throws Fault if a modular application class is in the unnamed package\n+     *\/\n+    Class<?> loadApplicationClass(ClassLoader parent, String mainClassName) throws ClassNotFoundException, Fault {\n@@ -169,0 +199,1 @@\n+            \/\/ Trivial case: no compiled module descriptor available, no extra module layer required\n@@ -173,0 +204,1 @@\n+        \/\/ Ensure main class resides in a named package.\n@@ -177,1 +209,0 @@\n-        var mainClassNamePackageName = mainClassName.substring(0, lastDotInMainClassName);\n@@ -179,2 +210,21 @@\n-        var moduleDesc = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes), descriptor::computePackageNames);\n-        var moduleName = moduleDesc.name();\n+        var bootLayer = ModuleLayer.boot();\n+        var parentLayer = bootLayer;\n+        var parentLoader = parent;\n+\n+        \/\/ Optionally create module layer for all modules on the module path.\n+        var modulePathFinder = createModuleFinderFromModulePath();\n+        var modulePathModules = modulePathFinder.findAll().stream().map(ModuleReference::descriptor).map(ModuleDescriptor::name).toList();\n+        if (!modulePathModules.isEmpty()) {\n+            var modulePathConfiguration = bootLayer.configuration().resolveAndBind(modulePathFinder, ModuleFinder.of(), Set.copyOf(modulePathModules));\n+            var modulePathLayer = ModuleLayer.defineModulesWithOneLoader(modulePathConfiguration, List.of(bootLayer), parent).layer();\n+            parentLayer = modulePathLayer;\n+            parentLoader = modulePathLayer.findLoader(modulePathModules.getFirst());\n+        }\n+\n+        \/\/ Create in-memory module layer for the modular application.\n+        var applicationModule = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes), descriptor::computePackageNames);\n+        var memoryFinder = new MemoryModuleFinder(inMemoryClasses, applicationModule, descriptor);\n+        var memoryConfig = parentLayer.configuration().resolveAndBind(memoryFinder, ModuleFinder.of(), Set.of(applicationModule.name()));\n+        var memoryClassLoader = new MemoryClassLoader(inMemoryClasses, parentLoader, applicationModule, descriptor, this::compileJavaFileByName);\n+        var memoryController = ModuleLayer.defineModules(memoryConfig, List.of(parentLayer), __ -> memoryClassLoader);\n+        var memoryLayer = memoryController.layer();\n@@ -182,6 +232,4 @@\n-        var finder = new MemoryModuleFinder(inMemoryClasses, moduleDesc, descriptor);\n-        var boot = ModuleLayer.boot();\n-        var configuration = boot.configuration().resolve(finder, ModuleFinder.of(), Set.of(moduleName));\n-        var memoryClassLoader = new MemoryClassLoader(inMemoryClasses, parent, moduleDesc, descriptor, this::compileJavaFileByName);\n-        var controller = ModuleLayer.defineModules(configuration, List.of(boot), mn -> memoryClassLoader);\n-        var layer = controller.layer();\n+        \/\/ Make application class accessible from the calling (unnamed) module, that loaded this class.\n+        var module = memoryLayer.findModule(applicationModule.name()).orElseThrow();\n+        var mainClassNamePackageName = mainClassName.substring(0, lastDotInMainClassName);\n+        memoryController.addOpens(module, mainClassNamePackageName, getClass().getModule());\n@@ -189,2 +237,2 @@\n-        var module = layer.findModule(moduleName).orElseThrow();\n-        controller.addOpens(module, mainClassNamePackageName, getClass().getModule());\n+        return memoryLayer.findLoader(applicationModule.name()).loadClass(mainClassName);\n+    }\n@@ -192,1 +240,7 @@\n-        return layer.findLoader(moduleName).loadClass(mainClassName);\n+    private static ModuleFinder createModuleFinderFromModulePath() {\n+        var elements = System.getProperty(\"jdk.module.path\");\n+        if (elements == null) {\n+            return ModuleFinder.of();\n+        }\n+        var paths = Arrays.stream(elements.split(File.pathSeparator)).map(Path::of);\n+        return ModuleFinder.of(paths.toArray(Path[]::new));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":72,"deletions":18,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.File;\n@@ -103,2 +104,1 @@\n-                  .map(string -> string.replace('\/', '.'))\n-                  .map(string -> string.replace('\\\\', '.'))\n+                  .map(string -> string.replace(File.separatorChar, '.'))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramDescriptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-            appClass = context.loadMainClass(parentLoader, mainClassName);\n+            appClass = context.loadApplicationClass(parentLoader, mainClassName);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}