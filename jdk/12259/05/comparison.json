{"files":[{"patch":"@@ -64,1 +64,1 @@\n-import jdk.internal.math.FormattedFloatingDecimal;\n+import jdk.internal.math.FormattedFPDecimal;\n@@ -1263,0 +1263,3 @@\n+ *     <p> A {@code float} or {@link Float} argument is first converted to\n+ *     {@code double} or {@link Double}, without loss of precision.\n+ *\n@@ -1294,2 +1297,2 @@\n- *     the string returned by {@link Float#toString(float)} or {@link\n- *     Double#toString(double)} respectively, then the value will be rounded\n+ *     the string returned by {@link\n+ *     Double#toString(double)}, then the value will be rounded\n@@ -1345,0 +1348,3 @@\n+ *     <p> A {@code float} or {@link Float} argument is first converted to\n+ *     {@code double} or {@link Double}, without loss of precision.\n+ *\n@@ -1363,2 +1369,2 @@\n- *     the string returned by {@link Float#toString(float)} or {@link\n- *     Double#toString(double)} respectively, then the value will be rounded\n+ *     the string returned by {@link\n+ *     Double#toString(double)}, then the value will be rounded\n@@ -3515,1 +3521,1 @@\n-        \/\/ !Double.isInfinite(value) && !Double.isNaN(value)\n+        \/\/ !Double.isInfinite(value) && !Double.isNaN(value) && value sign bit is 0\n@@ -3517,3 +3523,1 @@\n-                           int flags, char c, int precision, boolean neg)\n-            throws IOException\n-        {\n+                           int flags, char c, int precision, boolean neg) {\n@@ -3521,1 +3525,1 @@\n-                \/\/ Create a new FormattedFloatingDecimal with the desired\n+                \/\/ Create a new FormattedFPDecimal with the desired\n@@ -3525,3 +3529,2 @@\n-                FormattedFloatingDecimal fd\n-                        = FormattedFloatingDecimal.valueOf(value, prec,\n-                          FormattedFloatingDecimal.Form.SCIENTIFIC);\n+                FormattedFPDecimal fd = FormattedFPDecimal.valueOf(\n+                        value, prec, FormattedFPDecimal.SCIENTIFIC);\n@@ -3555,1 +3558,1 @@\n-                \/\/ Create a new FormattedFloatingDecimal with the desired\n+                \/\/ Create a new FormattedFPDecimal with the desired\n@@ -3559,3 +3562,2 @@\n-                FormattedFloatingDecimal fd\n-                        = FormattedFloatingDecimal.valueOf(value, prec,\n-                          FormattedFloatingDecimal.Form.DECIMAL_FLOAT);\n+                FormattedFPDecimal fd = FormattedFPDecimal.valueOf(\n+                        value, prec, FormattedFPDecimal.PLAIN);\n@@ -3590,3 +3592,2 @@\n-                    FormattedFloatingDecimal fd\n-                        = FormattedFloatingDecimal.valueOf(value, prec,\n-                          FormattedFloatingDecimal.Form.GENERAL);\n+                    FormattedFPDecimal fd = FormattedFPDecimal.valueOf(\n+                            value, prec, FormattedFPDecimal.GENERAL);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-final public class DoubleToDecimal {\n+public final class DoubleToDecimal {\n@@ -113,1 +113,1 @@\n-    private final byte[] bytes = new byte[MAX_CHARS];\n+    private final byte[] bytes;\n@@ -118,1 +118,2 @@\n-    private DoubleToDecimal() {\n+    private DoubleToDecimal(boolean noChars) {\n+        bytes = noChars ? null : new byte[MAX_CHARS];\n@@ -130,1 +131,22 @@\n-        return new DoubleToDecimal().toDecimalString(v);\n+        return new DoubleToDecimal(false).toDecimalString(v);\n+    }\n+\n+    \/**\n+     * Splits the decimal <i>d<\/i> described in\n+     * {@link Double#toString(double)} in integers <i>f<\/i> and <i>e<\/i>\n+     * such that <i>d<\/i> = <i>f<\/i> 10<sup><i>e<\/i><\/sup>.\n+     *\n+     * <p>Further, determines integer <i>n<\/i> such that <i>n<\/i> = 0 when\n+     * <i>f<\/i> = 0, and\n+     * 10<sup><i>n<\/i>-1<\/sup> &le; <i>f<\/i> &lt; 10<sup><i>n<\/i><\/sup>\n+     * otherwise.\n+     *\n+     * <p>The argument {@code v} is assumed to be a positive finite value or\n+     * positive zero.\n+     * Further, {@code fd} must not be {@code null}.\n+     *\n+     * @param v     the finite {@code double} to be split.\n+     * @param fd    the object that will carry <i>f<\/i>, <i>e<\/i>, and <i>n<\/i>.\n+     *\/\n+    public static void split(double v, FormattedFPDecimal fd) {\n+        new DoubleToDecimal(true).toDecimal(v, fd);\n@@ -146,1 +168,1 @@\n-        return new DoubleToDecimal().appendDecimalTo(v, app);\n+        return new DoubleToDecimal(false).appendDecimalTo(v, app);\n@@ -150,1 +172,1 @@\n-        return switch (toDecimal(v)) {\n+        return switch (toDecimal(v, null)) {\n@@ -162,1 +184,1 @@\n-        switch (toDecimal(v)) {\n+        switch (toDecimal(v, null)) {\n@@ -194,1 +216,1 @@\n-    private int toDecimal(double v) {\n+    private int toDecimal(double v, FormattedFPDecimal fd) {\n@@ -210,0 +232,4 @@\n+                \/*\n+                 * fd != null implies bytes == null and bits >= 0\n+                 * Thus, when fd != null, control never reaches here.\n+                 *\/\n@@ -220,1 +246,1 @@\n-                        return toChars(f, 0);\n+                        return toChars(f, 0, fd);\n@@ -223,1 +249,1 @@\n-                return toDecimal(-mq, c, 0);\n+                return toDecimal(-mq, c, 0, fd);\n@@ -228,2 +254,2 @@\n-                       ? toDecimal(Q_MIN, 10 * t, -1)\n-                       : toDecimal(Q_MIN, t, 0);\n+                       ? toDecimal(Q_MIN, 10 * t, -1, fd)\n+                       : toDecimal(Q_MIN, t, 0, fd);\n@@ -239,1 +265,1 @@\n-    private int toDecimal(int q, long c, int dk) {\n+    private int toDecimal(int q, long c, int dk, FormattedFPDecimal fd) {\n@@ -304,1 +330,1 @@\n-                return toChars(upin ? sp10 : tp10, k);\n+                return toChars(upin ? sp10 : tp10, k, fd);\n@@ -319,1 +345,1 @@\n-            return toChars(uin ? s : t, k + dk);\n+            return toChars(uin ? s : t, k + dk, fd);\n@@ -326,1 +352,1 @@\n-        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n@@ -345,1 +371,1 @@\n-    private int toChars(long f, int e) {\n+    private int toChars(long f, int e, FormattedFPDecimal fd) {\n@@ -356,0 +382,4 @@\n+        if (fd != null) {\n+            fd.set(f, e, len);\n+            return NON_SPECIAL;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+public final class FormattedFPDecimal {\n+\n+    public static final char SCIENTIFIC = 'e';\n+    public static final char PLAIN      = 'f';\n+    public static final char GENERAL    = 'g';\n+\n+    private long f;\n+    private int e;  \/\/ normalized to 0 when f = 0\n+    private int n;\n+    private char[] digits;  \/\/ ... and often the decimal separator as well\n+    private char[] exp;  \/\/ [+-][e]ee, that is, sign and minimum 2 digits\n+\n+    private FormattedFPDecimal() {\n+    }\n+\n+    public static FormattedFPDecimal valueOf(double v, int prec, char form) {\n+        FormattedFPDecimal fd = new FormattedFPDecimal();\n+        DoubleToDecimal.split(v, fd);\n+        return switch (form) {\n+            case SCIENTIFIC -> fd.scientific(prec);\n+            case PLAIN      -> fd.plain(prec);\n+            case GENERAL    -> fd.general(prec);\n+            default         -> throw new IllegalArgumentException(\n+                    String.format(\"unsupported form '%c'\", form)\n+            );\n+        };\n+    }\n+\n+    public void set(long f, int e, int n) {\n+        \/* Initially, n = 0 if f = 0, and 10^{n-1} <= f < 10^n if f != 0 *\/\n+        this.f = f;\n+        this.e = e;\n+        this.n = n;\n+    }\n+\n+    public char[] getExponent() {\n+        return exp;\n+    }\n+\n+    public char[] getMantissa() {\n+        return digits;\n+    }\n+\n+    public int getExponentRounded() {\n+        return n + e - 1;\n+    }\n+\n+    private FormattedFPDecimal plain(int prec) {\n+        \/*\n+         * Rounding d = f 10^e to prec digits in plain mode means the same\n+         * as rounding it to the p = n + e + prec most significand digits of d,\n+         * with the understanding that p < 0 cuts off all its digits.\n+         *\/\n+        round(n + e + (long) prec);  \/\/ n + e is well inside the int range\n+        return plainChars();\n+    }\n+\n+    private FormattedFPDecimal plainChars() {\n+        if (e >= 0) {\n+            plainCharsPureInteger();\n+        } else if (n + e > 0) {\n+            plainCharsMixed();\n+        } else {\n+            plainCharsPureFraction();\n+        }\n+        return this;\n+    }\n+\n+    private void plainCharsPureInteger() {\n+        digits = new char[n + e];\n+        fillWithZeros(n, n + e);\n+        fillWithDigits(f, 0, n);\n+    }\n+\n+    private void plainCharsMixed() {\n+        digits = new char[n + 1];\n+        long x = fillWithDigits(f, n + 1 + e, n + 1);\n+        digits[n + e] = '.';\n+        fillWithDigits(x, 0, n + e);\n+    }\n+\n+    private void plainCharsPureFraction() {\n+        digits = new char[2 - e];\n+        long x = f;\n+        fillWithDigits(x, 2 - e - n, 2 - e);\n+        fillWithZeros(0, 2 - e - n);\n+        digits[1] = '.';\n+    }\n+\n+    private FormattedFPDecimal scientific(int prec) {\n+        \/*\n+         * Rounding d = f 10^e to prec digits in scientific mode means the same\n+         * as rounding it to the p = prec + 1 most significand digits of d.\n+         *\/\n+        round(prec + 1L);\n+        return scientificChars(prec);\n+    }\n+\n+    private FormattedFPDecimal scientificChars(int prec) {\n+        if (prec != 0) {\n+            scientificCharsWithFraction();\n+        } else {\n+            scientificCharsNoFraction();\n+        }\n+        expChars();\n+        return this;\n+    }\n+\n+    private void scientificCharsWithFraction() {\n+        digits = new char[1 + n];  \/\/ room for leading digit and for '.'\n+        long x = fillWithDigits(f, 2, 1 + n);\n+        digits[1] = '.';\n+        digits[0] = toDigit(x);\n+    }\n+\n+    private void scientificCharsNoFraction() {\n+        digits = new char[1];\n+        digits[0] = toDigit(f);\n+    }\n+\n+    private FormattedFPDecimal general(int prec) {\n+        \/*\n+         * Rounding d = f 10^e to prec digits in general mode means the same\n+         * as rounding it to the p = prec most significand digits of d, and then\n+         * deciding whether to format it in plain or scientific mode, depending\n+         * on the rounded value.\n+         *\/\n+        round(prec);\n+        int er = getExponentRounded();\n+        if (-4 <= er && er < prec) {\n+            plainChars();\n+        } else {\n+            scientificChars(prec - 1);\n+        }\n+        return this;\n+    }\n+\n+    private void expChars() {\n+        int er = getExponentRounded();\n+        int aer = Math.abs(er);\n+        exp = new char[aer >= 100 ? 4 : 3];\n+        int q;\n+        if (aer >= 100) {\n+            q = aer \/ 10;\n+            exp[3] = toDigit(aer - 10 * q);\n+            aer = q;\n+        }\n+        q = aer \/ 10;\n+        exp[2] = toDigit(aer - 10 * q);\n+        exp[1] = toDigit(q);\n+        exp[0] = er >= 0 ? '+' : '-';\n+    }\n+\n+    private void round(long pp) {\n+        \/*\n+         * Let d = f 10^e, and let p shorten pp.\n+         * This method rounds d to the p most significant digits.\n+         * It does so by possibly modifying f, e and n.\n+         * When f becomes 0, e and n are normalized to 0 and 1, resp.\n+         *\n+         * For any real x let\n+         *      r(x) = floor(x + 1\/2)\n+         * which is rounding to the closest integer, with ties rounded toward\n+         * positive infinity.\n+         *\n+         * When f = 0 there's not much to say, except that this holds iff n = 0.\n+         *\n+         * Otherwise, since\n+         *      10^{n-1} <= f < 10^n\n+         * it follows that\n+         *      10^{e+n-1} <= d < 10^{e+n}\n+         * To round d to the most significant p digits, first scale d to the\n+         * range [10^{p-1}, 10^p), cutoff the fractional digits by applying r,\n+         * and finally scale back.\n+         * To this end, first define\n+         *      ds = d 10^{p-e-n}\n+         * which ensures\n+         *      10^{p-1} <= ds < 10^p\n+         *\n+         * Now, if p < 0 (that is, if p <= -1) then\n+         *      ds < 10^p <= 10^{-1} < 1\/2\n+         * so that\n+         *      r(ds) = 0\n+         * Thus, rounding d to p < 0 digits leads to 0.\n+         *\/\n+        if (n == 0 || pp < 0) {\n+            f = 0;\n+            e = 0;\n+            n = 1;\n+            return;\n+        }\n+\n+        \/*\n+         * Further, if p >= n then\n+         *      ds = f 10^e 10^{p-e-n} = f 10^{p-n}\n+         * which shows that ds is an integer, so r(ds) = ds. That is,\n+         * rounding to p >= n digits leads to a result equal to d.\n+         *\/\n+        if (pp >= n) {  \/\/ no rounding needed\n+            return;\n+        }\n+\n+        \/*\n+         * Finally, 0 <= p < n. When p = 0 it follows that\n+         *      10^{-1} <= ds < 1\n+         *      0 <= f' = r(ds) <= 1\n+         * that is, f' is either 0 or 1.\n+         *\n+         * Otherwise\n+         *      10^{p-1} <= ds < 10^p\n+         *      1 <= 10^{p-1} <= f' = r(ds) <= 10^p\n+         * Note that f' = 10^p is a possible outcome.\n+         *\n+         * Scale back, where e' = e + n - p\n+         *      d' = f' 10^{e+n-p} = f' 10^e', with 10^{e+n-1} <= d' <= 10^{e+n}\n+         *\n+         * Since n > p, f' can be computed in integer arithmetic as follows,\n+         * where \/ denotes division in the real numbers:\n+         *      f' = r(ds) = r(f 10^{p-n}) = r(f \/ 10^{n-p})\n+         *          = floor(f \/ 10^{n-p} + 1\/2)\n+         *          = floor((f + 10^{n-p}\/2) \/ 10^{n-p})\n+         *\/\n+        int p = (int) pp;  \/\/ 0 <= pp < n, safe cast\n+        e += n - p;  \/\/ new e is well inside the int range\n+        long pow10 = MathUtils.pow10(n - p);\n+        f = (f + (pow10 >> 1)) \/ pow10;\n+        if (p == 0) {\n+            n = 1;\n+            if (f == 0) {\n+                e = 0;\n+            }\n+            return;\n+        }\n+\n+        n = p;\n+        if (f == MathUtils.pow10(p)) {\n+            \/*\n+             * f is n + 1 digits long.\n+             * Absorb one trailing zero into e and reduce f accordingly.\n+             *\/\n+            f \/= 10;\n+            e += 1;\n+        }\n+    }\n+\n+    \/*\n+     * Fills the digits section with indices in [from, to) with the lower\n+     * to - from digits of x (as chars), while stripping them away from x.\n+     * Returns the stripped x.\n+     *\/\n+    private long fillWithDigits(long x, int from, int to) {\n+        while (to > from) {\n+            long q = x \/ 10;\n+            digits[--to] = toDigit(x - q * 10);\n+            x = q;\n+        }\n+        return x;\n+    }\n+\n+    \/*\n+     * Fills the digits section with indices in [from, to) with '0'.\n+     *\/\n+    private void fillWithZeros(int from, int to) {\n+        while (to > from) {\n+            digits[--to] = '0';\n+        }\n+    }\n+\n+    private static char toDigit(long d) {\n+        return toDigit((int) d);\n+    }\n+\n+    private static char toDigit(int d) {\n+        return (char) (d + '0');\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -1,367 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.math;\n-\n-import java.util.Arrays;\n-\n-public class FormattedFloatingDecimal{\n-\n-    public enum Form { SCIENTIFIC, COMPATIBLE, DECIMAL_FLOAT, GENERAL };\n-\n-\n-    public static FormattedFloatingDecimal valueOf(double d, int precision, Form form){\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n-                FloatingDecimal.getBinaryToASCIIConverter(d, form == Form.COMPATIBLE);\n-        return new FormattedFloatingDecimal(precision,form, fdConverter);\n-    }\n-\n-    private int decExponentRounded;\n-    private char[] mantissa;\n-    private char[] exponent;\n-\n-    private static final ThreadLocal<Object> threadLocalCharBuffer =\n-            new ThreadLocal<Object>() {\n-                @Override\n-                protected Object initialValue() {\n-                    return new char[20];\n-                }\n-            };\n-\n-    private static char[] getBuffer(){\n-        return (char[]) threadLocalCharBuffer.get();\n-    }\n-\n-    private FormattedFloatingDecimal(int precision, Form form, FloatingDecimal.BinaryToASCIIConverter fdConverter) {\n-        if (fdConverter.isExceptional()) {\n-            this.mantissa = fdConverter.toJavaFormatString().toCharArray();\n-            this.exponent = null;\n-            return;\n-        }\n-        char[] digits = getBuffer();\n-        int nDigits = fdConverter.getDigits(digits);\n-        int decExp = fdConverter.getDecimalExponent();\n-        int exp;\n-        boolean isNegative = fdConverter.isNegative();\n-        switch (form) {\n-            case COMPATIBLE:\n-                exp = decExp;\n-                this.decExponentRounded = exp;\n-                fillCompatible(precision, digits, nDigits, exp, isNegative);\n-                break;\n-            case DECIMAL_FLOAT:\n-                exp = applyPrecision(decExp, digits, nDigits, decExp + precision);\n-                fillDecimal(precision, digits, nDigits, exp, isNegative);\n-                this.decExponentRounded = exp;\n-                break;\n-            case SCIENTIFIC:\n-                exp = applyPrecision(decExp, digits, nDigits, precision + 1);\n-                fillScientific(precision, digits, nDigits, exp, isNegative);\n-                this.decExponentRounded = exp;\n-                break;\n-            case GENERAL:\n-                exp = applyPrecision(decExp, digits, nDigits, precision);\n-                \/\/ adjust precision to be the number of digits to right of decimal\n-                \/\/ the real exponent to be output is actually exp - 1, not exp\n-                if (exp - 1 < -4 || exp - 1 >= precision) {\n-                    \/\/ form = Form.SCIENTIFIC;\n-                    precision--;\n-                    fillScientific(precision, digits, nDigits, exp, isNegative);\n-                } else {\n-                    \/\/ form = Form.DECIMAL_FLOAT;\n-                    precision = precision - exp;\n-                    fillDecimal(precision, digits, nDigits, exp, isNegative);\n-                }\n-                this.decExponentRounded = exp;\n-                break;\n-            default:\n-                assert false;\n-        }\n-    }\n-\n-    \/\/ returns the exponent after rounding has been done by applyPrecision\n-    public int getExponentRounded() {\n-        return decExponentRounded - 1;\n-    }\n-\n-    \/**\n-     * Returns the mantissa as a {@code char[]}.  Note that the returned value\n-     * is a reference to the internal {@code char[]} containing the mantissa,\n-     * therefore code invoking this method should not pass the return value to\n-     * external code but should in that case make a copy.\n-     *\n-     * @return a reference to the internal {@code char[]} representing the\n-     *         mantissa.\n-     *\/\n-    public char[] getMantissa(){\n-        return mantissa;\n-    }\n-\n-    \/**\n-     * Returns the exponent as a {@code char[]}.  Note that the returned value\n-     * is a reference to the internal {@code char[]} containing the exponent,\n-     * therefore code invoking this method should not pass the return value to\n-     * external code but should in that case make a copy.\n-     *\n-     * @return a reference to the internal {@code char[]} representing the\n-     *         exponent.\n-     *\/\n-    public char[] getExponent(){\n-        return exponent;\n-    }\n-\n-    \/**\n-     * Returns new decExp in case of overflow.\n-     *\/\n-    private static int applyPrecision(int decExp, char[] digits, int nDigits, int prec) {\n-        if (prec >= nDigits || prec < 0) {\n-            \/\/ no rounding necessary\n-            return decExp;\n-        }\n-        if (prec == 0) {\n-            \/\/ only one digit (0 or 1) is returned because the precision\n-            \/\/ excludes all significant digits\n-            if (digits[0] >= '5') {\n-                digits[0] = '1';\n-                Arrays.fill(digits, 1, nDigits, '0');\n-                return decExp + 1;\n-            } else {\n-                Arrays.fill(digits, 0, nDigits, '0');\n-                return decExp;\n-            }\n-        }\n-        int q = digits[prec];\n-        if (q >= '5') {\n-            int i = prec;\n-            q = digits[--i];\n-            if ( q == '9' ) {\n-                while ( q == '9' && i > 0 ){\n-                    q = digits[--i];\n-                }\n-                if ( q == '9' ){\n-                    \/\/ carryout! High-order 1, rest 0s, larger exp.\n-                    digits[0] = '1';\n-                    Arrays.fill(digits, 1, nDigits, '0');\n-                    return decExp+1;\n-                }\n-            }\n-            digits[i] = (char)(q + 1);\n-            Arrays.fill(digits, i+1, nDigits, '0');\n-        } else {\n-            Arrays.fill(digits, prec, nDigits, '0');\n-        }\n-        return decExp;\n-    }\n-\n-    \/**\n-     * Fills mantissa and exponent char arrays for compatible format.\n-     *\/\n-    private void fillCompatible(int precision, char[] digits, int nDigits, int exp, boolean isNegative) {\n-        int startIndex = isNegative ? 1 : 0;\n-        if (exp > 0 && exp < 8) {\n-            \/\/ print digits.digits.\n-            if (nDigits < exp) {\n-                int extraZeros = exp - nDigits;\n-                mantissa = create(isNegative, nDigits + extraZeros + 2);\n-                System.arraycopy(digits, 0, mantissa, startIndex, nDigits);\n-                Arrays.fill(mantissa, startIndex + nDigits, startIndex + nDigits + extraZeros, '0');\n-                mantissa[startIndex + nDigits + extraZeros] = '.';\n-                mantissa[startIndex + nDigits + extraZeros+1] = '0';\n-            } else if (exp < nDigits) {\n-                int t = Math.min(nDigits - exp, precision);\n-                mantissa = create(isNegative, exp + 1 + t);\n-                System.arraycopy(digits, 0, mantissa, startIndex, exp);\n-                mantissa[startIndex + exp ] = '.';\n-                System.arraycopy(digits, exp, mantissa, startIndex+exp+1, t);\n-            } else { \/\/ exp == digits.length\n-                mantissa = create(isNegative, nDigits + 2);\n-                System.arraycopy(digits, 0, mantissa, startIndex, nDigits);\n-                mantissa[startIndex + nDigits ] = '.';\n-                mantissa[startIndex + nDigits +1] = '0';\n-            }\n-        } else if (exp <= 0 && exp > -3) {\n-            int zeros = Math.max(0, Math.min(-exp, precision));\n-            int t = Math.max(0, Math.min(nDigits, precision + exp));\n-            \/\/ write '0' s before the significant digits\n-            if (zeros > 0) {\n-                mantissa = create(isNegative, zeros + 2 + t);\n-                mantissa[startIndex] = '0';\n-                mantissa[startIndex+1] = '.';\n-                Arrays.fill(mantissa, startIndex + 2, startIndex + 2 + zeros, '0');\n-                if (t > 0) {\n-                    \/\/ copy only when significant digits are within the precision\n-                    System.arraycopy(digits, 0, mantissa, startIndex + 2 + zeros, t);\n-                }\n-            } else if (t > 0) {\n-                mantissa = create(isNegative, zeros + 2 + t);\n-                mantissa[startIndex] = '0';\n-                mantissa[startIndex + 1] = '.';\n-                \/\/ copy only when significant digits are within the precision\n-                System.arraycopy(digits, 0, mantissa, startIndex + 2, t);\n-            } else {\n-                this.mantissa = create(isNegative, 1);\n-                this.mantissa[startIndex] = '0';\n-            }\n-        } else {\n-            if (nDigits > 1) {\n-                mantissa = create(isNegative, nDigits + 1);\n-                mantissa[startIndex] = digits[0];\n-                mantissa[startIndex + 1] = '.';\n-                System.arraycopy(digits, 1, mantissa, startIndex + 2, nDigits - 1);\n-            } else {\n-                mantissa = create(isNegative, 3);\n-                mantissa[startIndex] = digits[0];\n-                mantissa[startIndex + 1] = '.';\n-                mantissa[startIndex + 2] = '0';\n-            }\n-            int e, expStartIntex;\n-            boolean isNegExp = (exp <= 0);\n-            if (isNegExp) {\n-                e = -exp + 1;\n-                expStartIntex = 1;\n-            } else {\n-                e = exp - 1;\n-                expStartIntex = 0;\n-            }\n-            \/\/ decExponent has 1, 2, or 3, digits\n-            if (e <= 9) {\n-                exponent = create(isNegExp,1);\n-                exponent[expStartIntex] = (char) (e + '0');\n-            } else if (e <= 99) {\n-                exponent = create(isNegExp,2);\n-                exponent[expStartIntex] = (char) (e \/ 10 + '0');\n-                exponent[expStartIntex+1] = (char) (e % 10 + '0');\n-            } else {\n-                exponent = create(isNegExp,3);\n-                exponent[expStartIntex] = (char) (e \/ 100 + '0');\n-                e %= 100;\n-                exponent[expStartIntex+1] = (char) (e \/ 10 + '0');\n-                exponent[expStartIntex+2] = (char) (e % 10 + '0');\n-            }\n-        }\n-    }\n-\n-    private static char[] create(boolean isNegative, int size) {\n-        if(isNegative) {\n-            char[] r = new char[size +1];\n-            r[0] = '-';\n-            return r;\n-        } else {\n-            return new char[size];\n-        }\n-    }\n-\n-    \/*\n-     * Fills mantissa char arrays for DECIMAL_FLOAT format.\n-     * Exponent should be equal to null.\n-     *\/\n-    private void fillDecimal(int precision, char[] digits, int nDigits, int exp, boolean isNegative) {\n-        int startIndex = isNegative ? 1 : 0;\n-        if (exp > 0) {\n-            \/\/ print digits.digits.\n-            if (nDigits < exp) {\n-                mantissa = create(isNegative,exp);\n-                System.arraycopy(digits, 0, mantissa, startIndex, nDigits);\n-                Arrays.fill(mantissa, startIndex + nDigits, startIndex + exp, '0');\n-                \/\/ Do not append \".0\" for formatted floats since the user\n-                \/\/ may request that it be omitted. It is added as necessary\n-                \/\/ by the Formatter.\n-            } else {\n-                int t = Math.min(nDigits - exp, precision);\n-                mantissa = create(isNegative, exp + (t > 0 ? (t + 1) : 0));\n-                System.arraycopy(digits, 0, mantissa, startIndex, exp);\n-                \/\/ Do not append \".0\" for formatted floats since the user\n-                \/\/ may request that it be omitted. It is added as necessary\n-                \/\/ by the Formatter.\n-                if (t > 0) {\n-                    mantissa[startIndex + exp] = '.';\n-                    System.arraycopy(digits, exp, mantissa, startIndex + exp + 1, t);\n-                }\n-            }\n-        } else if (exp <= 0) {\n-            int zeros = Math.max(0, Math.min(-exp, precision));\n-            int t = Math.max(0, Math.min(nDigits, precision + exp));\n-            \/\/ write '0' s before the significant digits\n-            if (zeros > 0) {\n-                mantissa = create(isNegative, zeros + 2 + t);\n-                mantissa[startIndex] = '0';\n-                mantissa[startIndex+1] = '.';\n-                Arrays.fill(mantissa, startIndex + 2, startIndex + 2 + zeros, '0');\n-                if (t > 0) {\n-                    \/\/ copy only when significant digits are within the precision\n-                    System.arraycopy(digits, 0, mantissa, startIndex + 2 + zeros, t);\n-                }\n-            } else if (t > 0) {\n-                mantissa = create(isNegative, zeros + 2 + t);\n-                mantissa[startIndex] = '0';\n-                mantissa[startIndex + 1] = '.';\n-                \/\/ copy only when significant digits are within the precision\n-                System.arraycopy(digits, 0, mantissa, startIndex + 2, t);\n-            } else {\n-                this.mantissa = create(isNegative, 1);\n-                this.mantissa[startIndex] = '0';\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Fills mantissa and exponent char arrays for SCIENTIFIC format.\n-     *\/\n-    private void fillScientific(int precision, char[] digits, int nDigits, int exp, boolean isNegative) {\n-        int startIndex = isNegative ? 1 : 0;\n-        int t = Math.max(0, Math.min(nDigits - 1, precision));\n-        if (t > 0) {\n-            mantissa = create(isNegative, t + 2);\n-            mantissa[startIndex] = digits[0];\n-            mantissa[startIndex + 1] = '.';\n-            System.arraycopy(digits, 1, mantissa, startIndex + 2, t);\n-        } else {\n-            mantissa = create(isNegative, 1);\n-            mantissa[startIndex] = digits[0];\n-        }\n-        char expSign;\n-        int e;\n-        if (exp <= 0) {\n-            expSign = '-';\n-            e = -exp + 1;\n-        } else {\n-            expSign = '+' ;\n-            e = exp - 1;\n-        }\n-        \/\/ decExponent has 1, 2, or 3, digits\n-        if (e <= 9) {\n-            exponent = new char[] { expSign,\n-                    '0', (char) (e + '0') };\n-        } else if (e <= 99) {\n-            exponent = new char[] { expSign,\n-                    (char) (e \/ 10 + '0'), (char) (e % 10 + '0') };\n-        } else {\n-            char hiExpChar = (char) (e \/ 100 + '0');\n-            e %= 100;\n-            exponent = new char[] { expSign,\n-                    hiExpChar, (char) (e \/ 10 + '0'), (char) (e % 10 + '0') };\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFloatingDecimal.java","additions":0,"deletions":367,"binary":false,"changes":367,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -934,0 +934,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -994,0 +1004,8 @@\n+\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n@@ -1190,0 +1208,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/Basic-X.java.template","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -420,0 +430,8 @@\n+\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n@@ -594,0 +612,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/BasicBigDecimal.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,0 +332,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -393,0 +403,8 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n+\n@@ -490,0 +508,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/BasicDouble.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -392,0 +402,8 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n+\n@@ -489,0 +507,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/BasicDoubleObject.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -392,0 +402,8 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n+\n@@ -492,0 +510,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/BasicFloat.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,0 +331,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %e - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.1e\", \"9.9e-324\", 1e-323);\n+        test(\"%.1e\", \"9.9e-323\", 1e-322);\n+        test(\"%.15e\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.15e\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.16e\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.16e\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n@@ -392,0 +402,8 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %f - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.0f\", \"738790000000000000000\", 7.3879e20);\n+        test(\"%.0f\", \"100000000000000000000000\", 1e23);\n+        test(\"%.0f\", \"200000000000000000000000\", 2e23);\n+        test(\"%.0f\", \"19400994884341945000000000\", 1.9400994884341945E25);\n+\n@@ -477,0 +495,10 @@\n+        \/\/---------------------------------------------------------------------\n+        \/\/ %g - adoption of Double.toString(double) algorithm (8300869)\n+        \/\/---------------------------------------------------------------------\n+        test(\"%.2g\", \"9.9e-324\", 1e-323);\n+        test(\"%.2g\", \"9.9e-323\", 1e-322);\n+        test(\"%.16g\", \"7.387900000000000e+20\", 7.3879e20);\n+        test(\"%.16g\", \"1.000000000000000e+23\", 1e23);\n+        test(\"%.17g\", \"2.0000000000000000e+23\", 2e23);\n+        test(\"%.17g\", \"1.9400994884341945e+25\", 1.9400994884341945E25);\n+\n","filename":"test\/jdk\/java\/util\/Formatter\/BasicFloatObject.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}