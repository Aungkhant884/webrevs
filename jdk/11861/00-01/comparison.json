{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,2 @@\n+  _stable_values = new (_arena) GrowableArray<StableValue>(_arena, 0, 0, StableValue());\n+\n@@ -295,0 +297,2 @@\n+  _stable_values = nullptr;\n+\n@@ -1297,0 +1301,14 @@\n+\/\/ Cache stable value lookups to ensure that consistent values are observed during compilation.\n+ciConstant ciEnv::check_stable_value(const ciObject* obj, int off, ciConstant val) {\n+  assert(FoldStableValues && _stable_values != nullptr, \"Must be enabled and initialized\");\n+  assert(obj != nullptr, \"Value must have a holder\");\n+  for (int i = 0; i < _stable_values->length(); ++i) {\n+    StableValue cached_val = _stable_values->at(i);\n+    if (cached_val.obj() == obj && cached_val.off() == off) {\n+      return cached_val.value();\n+    }\n+  }\n+  _stable_values->append(StableValue(obj, off, val));\n+  return val;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -469,0 +470,22 @@\n+  \/\/ FoldStableValues support\n+private:\n+  class StableValue {\n+    private:\n+      const ciObject* _obj;\n+      int _off;\n+      ciConstant _value;\n+\n+    public:\n+      StableValue() : _obj(NULL), _off(0), _value(ciConstant()) { }\n+      StableValue(const ciObject* obj, int off, ciConstant value) : _obj(obj), _off(off), _value(value) { }\n+\n+      const ciObject* obj() const { return _obj; }\n+      int off() const { return _off; }\n+      ciConstant value() const { return _value; }\n+  };\n+\n+  GrowableArray<StableValue>* _stable_values; \/\/ Cache of stable values\n+\n+public:\n+  ciConstant check_stable_value(const ciObject* obj, int off, ciConstant val);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4174,0 +4174,2 @@\n+    } else {\n+      return nullptr; \/\/ Holder not constant\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1763,9 +1763,0 @@\n-  \/\/ Skip verification when folding loads from stable fields because the field\n-  \/\/ may be (re-)initialized during CCP and the different types violate monotonicity.\n-  const TypePtr* adr_type = n->adr_type();\n-  Compile::AliasType* atp = C->alias_type(adr_type);\n-  if (FoldStableValues && n->is_Load() &&\n-      ((atp->field() != NULL && atp->field()->is_stable()) ||\n-       (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_stable()))) {\n-    return;\n-  }\n@@ -1778,2 +1769,2 @@\n-  assert(!told->isa_int() || !tnew->isa_int() || told->isa_int()->_widen <= tnew->isa_int()->_widen, \"widen increases\");\n-  assert(!told->isa_long() || !tnew->isa_long() || told->isa_long()->_widen <= tnew->isa_long()->_widen, \"widen increases\");\n+  assert(!told->isa_int() || !tnew->isa_int() || told->is_int()->_widen <= tnew->is_int()->_widen, \"widen increases\");\n+  assert(!told->isa_long() || !tnew->isa_long() || told->is_long()->_widen <= tnew->is_long()->_widen, \"widen increases\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -319,0 +319,1 @@\n+  element_value = ciEnv::current()->check_stable_value(array, off, element_value);\n@@ -364,0 +365,4 @@\n+  if (FoldStableValues && field->is_stable()) {\n+    holder = field->is_static() ? field->holder()->java_mirror() : holder;\n+    field_value = ciEnv::current()->check_stable_value(holder, field->offset(), field_value);\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    static @Stable Integer[] stableArray = new Integer[1];\n+    static @Stable Integer[] stableArray0 = new Integer[1];\n+    static @Stable Integer[][] stableArray1 = new Integer[1][1];\n@@ -78,3 +79,13 @@\n-                stableArray[0] = null;\n-                stableArray[0] = 42;\n-                stableArray[0] = 43;\n+                stableArray0[0] = null;\n+                stableArray0[0] = 42;\n+                stableArray0[0] = 43;\n+                stableArray1[0] = null;\n+                Integer[] tmp1 = {null};\n+                stableArray1[0] = tmp1;\n+                Integer[] tmp2 = {42};\n+                stableArray1[0] = tmp2;\n+                Integer[] tmp3 = {43};\n+                stableArray1[0] = tmp3;\n+                stableArray1[0][0] = null;\n+                stableArray1[0][0] = 42;\n+                stableArray1[0][0] = 43;\n@@ -106,2 +117,2 @@\n-    static Object testArray() {\n-        Integer val = stableArray[0];\n+    static Object testArray0() {\n+        Integer val = stableArray0[0];\n@@ -114,0 +125,10 @@\n+    static Object testArray1() {\n+        Integer[] val = stableArray1[0];\n+        if (val == null) {\n+            val = null;\n+        } else {\n+            return val[0];\n+        }\n+        return val;\n+    }\n+\n@@ -127,1 +148,2 @@\n-        Method testArray = TestUnstableStable.class.getDeclaredMethod(\"testArray\");\n+        Method testArray0 = TestUnstableStable.class.getDeclaredMethod(\"testArray0\");\n+        Method testArray1 = TestUnstableStable.class.getDeclaredMethod(\"testArray1\");\n@@ -135,2 +157,4 @@\n-            WHITE_BOX.deoptimizeMethod(testArray, false);\n-            WHITE_BOX.enqueueMethodForCompilation(testArray, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray0, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray0, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray1, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray1, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n","filename":"test\/hotspot\/jtreg\/compiler\/stable\/TestUnstableStable.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"}]}