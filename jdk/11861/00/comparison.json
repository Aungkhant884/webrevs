{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1762,11 +1762,9 @@\n-static bool ccp_type_widens(const Type* t, const Type* t0) {\n-  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n-  switch (t->base() == t0->base() ? t->base() : Type::Top) {\n-  case Type::Int:\n-    assert(t0->isa_int()->_widen <= t->isa_int()->_widen, \"widen increases\");\n-    break;\n-  case Type::Long:\n-    assert(t0->isa_long()->_widen <= t->isa_long()->_widen, \"widen increases\");\n-    break;\n-  default:\n-    break;\n+void PhaseCCP::verify_type(Node* n, const Type* tnew, const Type* told) {\n+  \/\/ Skip verification when folding loads from stable fields because the field\n+  \/\/ may be (re-)initialized during CCP and the different types violate monotonicity.\n+  const TypePtr* adr_type = n->adr_type();\n+  Compile::AliasType* atp = C->alias_type(adr_type);\n+  if (FoldStableValues && n->is_Load() &&\n+      ((atp->field() != NULL && atp->field()->is_stable()) ||\n+       (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_stable()))) {\n+    return;\n@@ -1774,1 +1772,8 @@\n-  return true;\n+  if (tnew->meet(told) != tnew->remove_speculative()) {\n+    n->dump(1);\n+    tty->print(\"told = \"); told->dump(); tty->cr();\n+    tty->print(\"tnew = \"); tnew->dump(); tty->cr();\n+    fatal(\"Not monotonic\");\n+  }\n+  assert(!told->isa_int() || !tnew->isa_int() || told->isa_int()->_widen <= tnew->isa_int()->_widen, \"widen increases\");\n+  assert(!told->isa_long() || !tnew->isa_long() || told->isa_long()->_widen <= tnew->isa_long()->_widen, \"widen increases\");\n@@ -1809,1 +1814,1 @@\n-      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n@@ -1828,0 +1833,1 @@\n+      DEBUG_ONLY(verify_type(n, tnew, told);)\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,0 +608,1 @@\n+  void verify_type(Node* n, const Type* tnew, const Type* told);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3197,1 +3197,0 @@\n-      ciField* field = NULL;\n@@ -3229,1 +3228,1 @@\n-          field = ik->get_field_by_offset(_offset, false);\n+          ciField* field = ik->get_field_by_offset(_offset, false);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295486\n+ * @summary Verify that constant folding of field loads observes consistent values during compilation.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/bootclasspath\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                                 -XX:-TieredCompilation -Xbatch -XX:PerMethodRecompilationCutoff=-1\n+ *                                 -XX:CompileCommand=compileonly,compiler.stable.TestUnstableStable::test*\n+ *                                 compiler.stable.TestUnstableStable\n+ *\/\n+\n+package compiler.stable;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestUnstableStable {\n+    static final Unsafe U = Unsafe.getUnsafe();\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final TestUnstableStable HOLDER = new TestUnstableStable();\n+\n+    @Stable Integer stableField = null;\n+    static @Stable Integer staticStableField = null;\n+    static @Stable Integer[] stableArray = new Integer[1];\n+\n+    static final Integer finalField = 43;\n+\n+    static final long FIELD_OFFSET;\n+    static {\n+        try {\n+            FIELD_OFFSET = U.staticFieldOffset(TestUnstableStable.class.getDeclaredField(\"finalField\"));\n+        } catch (NoSuchFieldException e) {\n+            throw new RuntimeException(\"Field not found\", e);\n+        }\n+    }\n+\n+    static class Writer implements Runnable {\n+        public void run() {\n+            while (true) {\n+                HOLDER.stableField = null;\n+                HOLDER.stableField = 42;\n+                HOLDER.stableField = 43;\n+                staticStableField = null;\n+                staticStableField = 42;\n+                staticStableField = 43;\n+                stableArray[0] = null;\n+                stableArray[0] = 42;\n+                stableArray[0] = 43;\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, null);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 42);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 43);\n+            }\n+        }\n+    }\n+\n+    static Object testNonStatic() {\n+        \/\/ Trigger PhaseCCP and LoadNode::Value -> Type::make_constant_from_field\n+        \/\/ which may observe different values of the stable field when invoked twice.\n+        Integer val = HOLDER.stableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testStatic() {\n+        Integer val = staticStableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testArray() {\n+        Integer val = stableArray[0];\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testFinal() {\n+        Integer val = finalField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread t = new Thread(new Writer());\n+        t.start();\n+        Method testNonStatic = TestUnstableStable.class.getDeclaredMethod(\"testNonStatic\");\n+        Method testStatic = TestUnstableStable.class.getDeclaredMethod(\"testStatic\");\n+        Method testArray = TestUnstableStable.class.getDeclaredMethod(\"testArray\");\n+        Method testFinal = TestUnstableStable.class.getDeclaredMethod(\"testFinal\");\n+        testFinal();\n+        for (int i = 0; i < 1000; ++i) {\n+            WHITE_BOX.deoptimizeMethod(testNonStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testNonStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testFinal, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testFinal, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/stable\/TestUnstableStable.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}