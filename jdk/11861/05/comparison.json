{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,3 +66,1 @@\n-      ciEnv* env = CURRENT_ENV;\n-      ciObject* box = env->get_object(elem);\n-      return ciConstant(T_OBJECT, box);\n+      return ciConstant(elembt, CURRENT_ENV->get_object(elem));\n@@ -97,0 +95,4 @@\n+  ciConstant value = check_constant_value_cache(index, elembt);\n+  if (value.is_valid()) {\n+    return value;\n+  }\n@@ -98,1 +100,1 @@\n-    return element_value_impl(elembt, get_arrayOop(), index);\n+    value = element_value_impl(elembt, get_arrayOop(), index);\n@@ -100,0 +102,2 @@\n+  add_to_constant_value_cache(index, value);\n+  return value;\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,29 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciConstant::is_null_or_zero\n+bool ciConstant::is_null_or_zero() const {\n+  if (!is_java_primitive(basic_type())) {\n+    return as_object()->is_null_object();\n+  } else if (type2size[basic_type()] == 1) {\n+    \/\/ treat float bits as int, to avoid comparison with -0 and NaN\n+    return (_value._int == 0);\n+  } else if (type2size[basic_type()] == 2) {\n+    \/\/ treat double bits as long, to avoid comparison with -0 and NaN\n+    return (_value._long == 0);\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciConstant::is_loaded\n+bool ciConstant::is_loaded() const {\n+  if (is_valid()) {\n+    if (is_reference_type(basic_type())) {\n+      return as_object()->is_loaded();\n+    } else {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciConstant.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"ci\/ciNullObject.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -113,13 +113,1 @@\n-  bool      is_null_or_zero() const {\n-    if (!is_java_primitive(basic_type())) {\n-      return as_object()->is_null_object();\n-    } else if (type2size[basic_type()] == 1) {\n-      \/\/ treat float bits as int, to avoid comparison with -0 and NaN\n-      return (_value._int == 0);\n-    } else if (type2size[basic_type()] == 2) {\n-      \/\/ treat double bits as long, to avoid comparison with -0 and NaN\n-      return (_value._long == 0);\n-    } else {\n-      return false;\n-    }\n-  }\n+  bool is_null_or_zero() const;\n@@ -131,10 +119,2 @@\n-  bool is_loaded() const {\n-    if (is_valid()) {\n-      if (is_reference_type(basic_type())) {\n-        return as_object()->is_loaded();\n-      } else {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n+  bool is_loaded() const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciConstant.hpp","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -314,2 +314,1 @@\n-    VM_ENTRY_MARK;\n-    ciInstance* mirror = CURRENT_ENV->get_instance(_holder->get_Klass()->java_mirror());\n+    ciInstance* mirror = _holder->java_mirror();\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"ci\/ciNullObject.hpp\"\n@@ -62,0 +63,5 @@\n+  ciConstant value = check_constant_value_cache(offset, field_btype);\n+  if (value.is_valid()) {\n+    return value;\n+  }\n+  VM_ENTRY_MARK;\n@@ -65,8 +71,8 @@\n-    case T_BYTE:    return ciConstant(field_btype, obj->byte_field(offset));\n-    case T_CHAR:    return ciConstant(field_btype, obj->char_field(offset));\n-    case T_SHORT:   return ciConstant(field_btype, obj->short_field(offset));\n-    case T_BOOLEAN: return ciConstant(field_btype, obj->bool_field(offset));\n-    case T_INT:     return ciConstant(field_btype, obj->int_field(offset));\n-    case T_FLOAT:   return ciConstant(obj->float_field(offset));\n-    case T_DOUBLE:  return ciConstant(obj->double_field(offset));\n-    case T_LONG:    return ciConstant(obj->long_field(offset));\n+    case T_BYTE:    value = ciConstant(field_btype, obj->byte_field(offset)); break;\n+    case T_CHAR:    value = ciConstant(field_btype, obj->char_field(offset)); break;\n+    case T_SHORT:   value = ciConstant(field_btype, obj->short_field(offset)); break;\n+    case T_BOOLEAN: value = ciConstant(field_btype, obj->bool_field(offset)); break;\n+    case T_INT:     value = ciConstant(field_btype, obj->int_field(offset)); break;\n+    case T_FLOAT:   value = ciConstant(obj->float_field(offset)); break;\n+    case T_DOUBLE:  value = ciConstant(obj->double_field(offset)); break;\n+    case T_LONG:    value = ciConstant(obj->long_field(offset)); break;\n@@ -85,1 +91,1 @@\n-        return ciConstant(field_btype, ciNullObject::make());\n+        value = ciConstant(field_btype, ciNullObject::make());\n@@ -87,1 +93,1 @@\n-        return ciConstant(field_btype, CURRENT_ENV->get_object(o));\n+        value = ciConstant(field_btype, CURRENT_ENV->get_object(o));\n@@ -89,0 +95,1 @@\n+      break;\n@@ -92,1 +99,0 @@\n-      return ciConstant();\n@@ -94,0 +100,2 @@\n+  add_to_constant_value_cache(offset, value);\n+  return value;\n@@ -104,2 +112,1 @@\n-\n-  GUARDED_VM_ENTRY(return field_value_impl(field->type()->basic_type(), field->offset());)\n+  return field_value_impl(field->type()->basic_type(), field->offset());\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,31 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciObject::check_constant_value_cache()\n+\/\/\n+\/\/ Cache constant value lookups to ensure that consistent values are observed\n+\/\/ during compilation because fields may be (re-)initialized concurrently.\n+ciConstant ciObject::check_constant_value_cache(int off, BasicType bt) {\n+  if (_constant_values != nullptr) {\n+    for (int i = 0; i < _constant_values->length(); ++i) {\n+      ConstantValue cached_val = _constant_values->at(i);\n+      if (cached_val.off() == off) {\n+        assert(cached_val.value().basic_type() == bt, \"unexpected type\");\n+        return cached_val.value();\n+      }\n+    }\n+  }\n+  return ciConstant();\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciObject::add_to_constant_value_cache()\n+\/\/\n+\/\/ Add a constant value to the cache.\n+void ciObject::add_to_constant_value_cache(int off, ciConstant val) {\n+  assert(val.is_valid(), \"value must be valid\");\n+  if (_constant_values == nullptr) {\n+    Arena* arena = CURRENT_ENV->arena();\n+    _constant_values = new (arena) GrowableArray<ConstantValue>(arena, 0, 0, ConstantValue());\n+  }\n+  _constant_values->append(ConstantValue(off, val));\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciObject.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -60,0 +62,16 @@\n+  \/\/ Cache constant value lookups to ensure that consistent values are observed during compilation.\n+  class ConstantValue {\n+    private:\n+      int _off;\n+      ciConstant _value;\n+\n+    public:\n+      ConstantValue() : _off(0), _value(ciConstant()) { }\n+      ConstantValue(int off, ciConstant value) : _off(off), _value(value) { }\n+\n+      int off() const { return _off; }\n+      ciConstant value() const { return _value; }\n+  };\n+\n+  GrowableArray<ConstantValue>* _constant_values = nullptr;\n+\n@@ -97,0 +115,4 @@\n+  \/\/ Access to the constant value cache\n+  ciConstant check_constant_value_cache(int off, BasicType bt);\n+  void add_to_constant_value_cache(int off, ciConstant val);\n+\n","filename":"src\/hotspot\/share\/ci\/ciObject.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1762,11 +1762,6 @@\n-static bool ccp_type_widens(const Type* t, const Type* t0) {\n-  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n-  switch (t->base() == t0->base() ? t->base() : Type::Top) {\n-  case Type::Int:\n-    assert(t0->isa_int()->_widen <= t->isa_int()->_widen, \"widen increases\");\n-    break;\n-  case Type::Long:\n-    assert(t0->isa_long()->_widen <= t->isa_long()->_widen, \"widen increases\");\n-    break;\n-  default:\n-    break;\n+void PhaseCCP::verify_type(Node* n, const Type* tnew, const Type* told) {\n+  if (tnew->meet(told) != tnew->remove_speculative()) {\n+    n->dump(1);\n+    tty->print(\"told = \"); told->dump(); tty->cr();\n+    tty->print(\"tnew = \"); tnew->dump(); tty->cr();\n+    fatal(\"Not monotonic\");\n@@ -1774,1 +1769,2 @@\n-  return true;\n+  assert(!told->isa_int() || !tnew->isa_int() || told->is_int()->_widen <= tnew->is_int()->_widen, \"widen increases\");\n+  assert(!told->isa_long() || !tnew->isa_long() || told->is_long()->_widen <= tnew->is_long()->_widen, \"widen increases\");\n@@ -1809,1 +1805,1 @@\n-      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n@@ -1837,1 +1833,1 @@\n-      if (n->is_Load()) {\n+      if (n->is_Load() && !told->singleton()) {\n@@ -1843,0 +1839,1 @@\n+      verify_type(n, tnew, told);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,0 +608,1 @@\n+  void verify_type(Node* n, const Type* tnew, const Type* told);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3373,1 +3373,0 @@\n-      ciField* field = NULL;\n@@ -3405,1 +3404,1 @@\n-          field = ik->get_field_by_offset(_offset, false);\n+          ciField* field = ik->get_field_by_offset(_offset, false);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295486\n+ * @summary Verify that constant folding of field loads observes consistent values during compilation.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/bootclasspath\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                                 -XX:-TieredCompilation -Xbatch -XX:PerMethodRecompilationCutoff=-1\n+ *                                 -XX:CompileCommand=compileonly,compiler.stable.TestUnstableStable::test*\n+ *                                 compiler.stable.TestUnstableStable\n+ *\/\n+\n+package compiler.stable;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestUnstableStable {\n+    static final Unsafe U = Unsafe.getUnsafe();\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final TestUnstableStable HOLDER = new TestUnstableStable();\n+\n+    @Stable Integer stableField = null;\n+    static @Stable Integer staticStableField = null;\n+    static @Stable Integer[] stableArray0 = new Integer[1];\n+    static @Stable Integer[][] stableArray1 = new Integer[1][1];\n+\n+    static final Integer finalField = 43;\n+\n+    static final long FIELD_OFFSET;\n+    static {\n+        try {\n+            FIELD_OFFSET = U.staticFieldOffset(TestUnstableStable.class.getDeclaredField(\"finalField\"));\n+        } catch (NoSuchFieldException e) {\n+            throw new RuntimeException(\"Field not found\", e);\n+        }\n+    }\n+\n+    static class Writer implements Runnable {\n+        public void run() {\n+            while (true) {\n+                HOLDER.stableField = null;\n+                HOLDER.stableField = 42;\n+                HOLDER.stableField = 43;\n+                staticStableField = null;\n+                staticStableField = 42;\n+                staticStableField = 43;\n+                stableArray0[0] = null;\n+                stableArray0[0] = 42;\n+                stableArray0[0] = 43;\n+                stableArray1[0] = null;\n+                Integer[] tmp1 = {null};\n+                stableArray1[0] = tmp1;\n+                Integer[] tmp2 = {42};\n+                stableArray1[0] = tmp2;\n+                Integer[] tmp3 = {43};\n+                stableArray1[0] = tmp3;\n+                stableArray1[0][0] = null;\n+                stableArray1[0][0] = 42;\n+                stableArray1[0][0] = 43;\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, null);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 42);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 43);\n+            }\n+        }\n+    }\n+\n+    static Object testNonStatic() {\n+        \/\/ Trigger PhaseCCP and LoadNode::Value -> Type::make_constant_from_field\n+        \/\/ which may observe different values of the stable field when invoked twice.\n+        Integer val = HOLDER.stableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testStatic() {\n+        Integer val = staticStableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testArray0() {\n+        Integer val = stableArray0[0];\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testArray1() {\n+        Integer[] val = stableArray1[0];\n+        if (val == null) {\n+            val = null;\n+        } else {\n+            return val[0];\n+        }\n+        return val;\n+    }\n+\n+    static Object testFinal() {\n+        Integer val = finalField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread t = new Thread(new Writer());\n+        t.start();\n+        Method testNonStatic = TestUnstableStable.class.getDeclaredMethod(\"testNonStatic\");\n+        Method testStatic = TestUnstableStable.class.getDeclaredMethod(\"testStatic\");\n+        Method testArray0 = TestUnstableStable.class.getDeclaredMethod(\"testArray0\");\n+        Method testArray1 = TestUnstableStable.class.getDeclaredMethod(\"testArray1\");\n+        Method testFinal = TestUnstableStable.class.getDeclaredMethod(\"testFinal\");\n+        testFinal();\n+        for (int i = 0; i < 1000; ++i) {\n+            WHITE_BOX.deoptimizeMethod(testNonStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testNonStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray0, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray0, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray1, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray1, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testFinal, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testFinal, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/stable\/TestUnstableStable.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}