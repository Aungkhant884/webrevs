{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,2 @@\n+  _stable_values = new (_arena) GrowableArray<StableValue>(_arena, 0, 0, StableValue());\n+\n@@ -295,0 +297,2 @@\n+  _stable_values = nullptr;\n+\n@@ -1297,0 +1301,14 @@\n+\/\/ Cache stable value lookups to ensure that consistent values are observed during compilation.\n+ciConstant ciEnv::check_stable_value(const ciObject* obj, int off, ciConstant val) {\n+  assert(FoldStableValues && _stable_values != nullptr, \"Must be enabled and initialized\");\n+  assert(obj != nullptr, \"Value must have a holder\");\n+  for (int i = 0; i < _stable_values->length(); ++i) {\n+    StableValue cached_val = _stable_values->at(i);\n+    if (cached_val.obj() == obj && cached_val.off() == off) {\n+      return cached_val.value();\n+    }\n+  }\n+  _stable_values->append(StableValue(obj, off, val));\n+  return val;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"ci\/ciConstant.hpp\"\n@@ -469,0 +470,22 @@\n+  \/\/ FoldStableValues support\n+private:\n+  class StableValue {\n+    private:\n+      const ciObject* _obj;\n+      int _off;\n+      ciConstant _value;\n+\n+    public:\n+      StableValue() : _obj(NULL), _off(0), _value(ciConstant()) { }\n+      StableValue(const ciObject* obj, int off, ciConstant value) : _obj(obj), _off(off), _value(value) { }\n+\n+      const ciObject* obj() const { return _obj; }\n+      int off() const { return _off; }\n+      ciConstant value() const { return _value; }\n+  };\n+\n+  GrowableArray<StableValue>* _stable_values; \/\/ Cache of stable values\n+\n+public:\n+  ciConstant check_stable_value(const ciObject* obj, int off, ciConstant val);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4174,0 +4174,2 @@\n+    } else {\n+      return nullptr; \/\/ Holder not constant\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1762,11 +1762,6 @@\n-static bool ccp_type_widens(const Type* t, const Type* t0) {\n-  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n-  switch (t->base() == t0->base() ? t->base() : Type::Top) {\n-  case Type::Int:\n-    assert(t0->isa_int()->_widen <= t->isa_int()->_widen, \"widen increases\");\n-    break;\n-  case Type::Long:\n-    assert(t0->isa_long()->_widen <= t->isa_long()->_widen, \"widen increases\");\n-    break;\n-  default:\n-    break;\n+void PhaseCCP::verify_type(Node* n, const Type* tnew, const Type* told) {\n+  if (tnew->meet(told) != tnew->remove_speculative()) {\n+    n->dump(1);\n+    tty->print(\"told = \"); told->dump(); tty->cr();\n+    tty->print(\"tnew = \"); tnew->dump(); tty->cr();\n+    fatal(\"Not monotonic\");\n@@ -1774,1 +1769,2 @@\n-  return true;\n+  assert(!told->isa_int() || !tnew->isa_int() || told->is_int()->_widen <= tnew->is_int()->_widen, \"widen increases\");\n+  assert(!told->isa_long() || !tnew->isa_long() || told->is_long()->_widen <= tnew->is_long()->_widen, \"widen increases\");\n@@ -1809,1 +1805,1 @@\n-      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n@@ -1828,0 +1824,1 @@\n+      DEBUG_ONLY(verify_type(n, tnew, told);)\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,0 +608,1 @@\n+  void verify_type(Node* n, const Type* tnew, const Type* told);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,1 @@\n+  element_value = ciEnv::current()->check_stable_value(array, off, element_value);\n@@ -364,0 +365,4 @@\n+  if (FoldStableValues && field->is_stable()) {\n+    holder = field->is_static() ? field->holder()->java_mirror() : holder;\n+    field_value = ciEnv::current()->check_stable_value(holder, field->offset(), field_value);\n+  }\n@@ -3197,1 +3202,0 @@\n-      ciField* field = NULL;\n@@ -3229,1 +3233,1 @@\n-          field = ik->get_field_by_offset(_offset, false);\n+          ciField* field = ik->get_field_by_offset(_offset, false);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295486\n+ * @summary Verify that constant folding of field loads observes consistent values during compilation.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/bootclasspath\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                                 -XX:-TieredCompilation -Xbatch -XX:PerMethodRecompilationCutoff=-1\n+ *                                 -XX:CompileCommand=compileonly,compiler.stable.TestUnstableStable::test*\n+ *                                 compiler.stable.TestUnstableStable\n+ *\/\n+\n+package compiler.stable;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestUnstableStable {\n+    static final Unsafe U = Unsafe.getUnsafe();\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final TestUnstableStable HOLDER = new TestUnstableStable();\n+\n+    @Stable Integer stableField = null;\n+    static @Stable Integer staticStableField = null;\n+    static @Stable Integer[] stableArray0 = new Integer[1];\n+    static @Stable Integer[][] stableArray1 = new Integer[1][1];\n+\n+    static final Integer finalField = 43;\n+\n+    static final long FIELD_OFFSET;\n+    static {\n+        try {\n+            FIELD_OFFSET = U.staticFieldOffset(TestUnstableStable.class.getDeclaredField(\"finalField\"));\n+        } catch (NoSuchFieldException e) {\n+            throw new RuntimeException(\"Field not found\", e);\n+        }\n+    }\n+\n+    static class Writer implements Runnable {\n+        public void run() {\n+            while (true) {\n+                HOLDER.stableField = null;\n+                HOLDER.stableField = 42;\n+                HOLDER.stableField = 43;\n+                staticStableField = null;\n+                staticStableField = 42;\n+                staticStableField = 43;\n+                stableArray0[0] = null;\n+                stableArray0[0] = 42;\n+                stableArray0[0] = 43;\n+                stableArray1[0] = null;\n+                Integer[] tmp1 = {null};\n+                stableArray1[0] = tmp1;\n+                Integer[] tmp2 = {42};\n+                stableArray1[0] = tmp2;\n+                Integer[] tmp3 = {43};\n+                stableArray1[0] = tmp3;\n+                stableArray1[0][0] = null;\n+                stableArray1[0][0] = 42;\n+                stableArray1[0][0] = 43;\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, null);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 42);\n+                U.putObject(TestUnstableStable.class, FIELD_OFFSET, 43);\n+            }\n+        }\n+    }\n+\n+    static Object testNonStatic() {\n+        \/\/ Trigger PhaseCCP and LoadNode::Value -> Type::make_constant_from_field\n+        \/\/ which may observe different values of the stable field when invoked twice.\n+        Integer val = HOLDER.stableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testStatic() {\n+        Integer val = staticStableField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testArray0() {\n+        Integer val = stableArray0[0];\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    static Object testArray1() {\n+        Integer[] val = stableArray1[0];\n+        if (val == null) {\n+            val = null;\n+        } else {\n+            return val[0];\n+        }\n+        return val;\n+    }\n+\n+    static Object testFinal() {\n+        Integer val = finalField;\n+        if (val == null) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread t = new Thread(new Writer());\n+        t.start();\n+        Method testNonStatic = TestUnstableStable.class.getDeclaredMethod(\"testNonStatic\");\n+        Method testStatic = TestUnstableStable.class.getDeclaredMethod(\"testStatic\");\n+        Method testArray0 = TestUnstableStable.class.getDeclaredMethod(\"testArray0\");\n+        Method testArray1 = TestUnstableStable.class.getDeclaredMethod(\"testArray1\");\n+        Method testFinal = TestUnstableStable.class.getDeclaredMethod(\"testFinal\");\n+        testFinal();\n+        for (int i = 0; i < 1000; ++i) {\n+            WHITE_BOX.deoptimizeMethod(testNonStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testNonStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testStatic, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testStatic, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray0, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray0, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testArray1, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testArray1, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            WHITE_BOX.deoptimizeMethod(testFinal, false);\n+            WHITE_BOX.enqueueMethodForCompilation(testFinal, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/stable\/TestUnstableStable.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}