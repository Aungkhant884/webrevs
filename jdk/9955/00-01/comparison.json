{"files":[{"patch":"@@ -353,0 +353,15 @@\n+\n+  \/\/ Install BREAK_SIGNAL's handler in early initialization phase, in\n+  \/\/ order to reduce the risk that an attach client accidentally forces\n+  \/\/ HotSpot to quit prematurely.\n+  \/\/ The actual work for handling BREAK_SIGNAL is performed by the Signal\n+  \/\/ Dispatcher thread, which is created and started at a much later point,\n+  \/\/ see os::initialize_jdk_signal_support(). Any BREAK_SIGNAL received\n+  \/\/ before the Signal Dispatcher thread is started is queued up via the\n+  \/\/ pending_signals[BREAK_SIGNAL] counter, and will be processed by the\n+  \/\/ Signal Dispatcher thread in a delayed fashion.\n+  \/\/\n+  \/\/ Also note that HotSpot does NOT support signal chaining for BREAK_SIGNAL.\n+  \/\/ Applications that require a custom BREAK_SIGNAL handler should run with\n+  \/\/ -XX:+ReduceSignalUsage.\n+  os::signal(BREAK_SIGNAL, os::user_handler());\n@@ -686,6 +701,0 @@\n-\/\/ Signal handler for BREAK_SIGNAL during early initialization phase.\n-\/\/ Late initialization will overwrite BREAK_SIGNAL's handler to UserHandler.\n-static void DummySIGBREAKHandler(int sig, void *siginfo, void *context) {\n-  assert(!ReduceSignalUsage, \"Should not happen with -Xrs\/-XX:+ReduceSignalUsage\");\n-}\n-\n@@ -1336,15 +1345,0 @@\n-  if (!ReduceSignalUsage) {\n-    \/\/ This is just for early initialization phase. Intercepting the signal here\n-    \/\/ reduces the risk that an attach client accidentally forces HotSpot to quit\n-    \/\/ prematurely. Late initialization will overwrite BREAK_SIGNAL's handler to\n-    \/\/ UserHandler.\n-    \/\/ Note that HotSpot does NOT support signal chaining for BREAK_SIGNAL.\n-    \/\/ We have to set it outside the window bounded by libjsig's\n-    \/\/ JVM_begin_signal_setting and JVM_end_signal_setting above, because the\n-    \/\/ window is intended for signals that support chaining. Otherwise libjsig\n-    \/\/ would prevent us from overwriting BREAK_SIGNAL's handler to UserHandler.\n-    \/\/ We also use os::signal() and a dummy handler to avoid special-casing\n-    \/\/ set_signal_handler() and JVM_HANDLE_XXX_SIGNAL().\n-    os::signal(BREAK_SIGNAL, CAST_FROM_FN_PTR(void*, DummySIGBREAKHandler));\n-  }\n-\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2245,0 +2245,9 @@\n+\n+  \/\/ Add a CTRL-BREAK handler.\n+  \/\/ The actual work for handling CTRL-BREAK is performed by the Signal\n+  \/\/ Dispatcher thread, which is created and started at a much later point,\n+  \/\/ see os::initialize_jdk_signal_support(). Any CTRL-BREAK received\n+  \/\/ before the Signal Dispatcher thread is started is queued up via the\n+  \/\/ pending_signals[SIGBREAK] counter, and will be processed by the\n+  \/\/ Signal Dispatcher thread in a delayed fashion.\n+  os::signal(SIGBREAK, os::user_handler());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -477,3 +477,0 @@\n-\n-    \/\/ Handle ^BREAK\n-    os::signal(SIGBREAK, os::user_handler());\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}