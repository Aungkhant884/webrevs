{"files":[{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n+#define CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -204,0 +204,6 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  \/\/ Fast path depends on !PreserveFramePointer. See can_thaw_fast().\n+  assert(!PreserveFramePointer, \"Frame pointers need to be fixed\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n+#define CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/continuationEntry_arm.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-    n_int_register_parameters_j = 8,\n-    n_float_register_parameters_j = 13\n+    n_int_register_parameters_j   = 8,  \/\/ duplicates num_java_iarg_registers\n+    n_float_register_parameters_j = 13, \/\/ num_java_farg_registers\n@@ -1375,1 +1375,1 @@\n-  static inline bool is_illtrap(int x);\n+  static inline bool is_illtrap(address instr_addr);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-inline bool Assembler::is_illtrap(int x) { return x == 0; }\n+inline bool Assembler::is_illtrap(address instr_addr) { return *(uint32_t*)instr_addr == 0u; }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+  __ post_call_nop();\n@@ -695,0 +696,1 @@\n+  __ post_call_nop();\n@@ -2879,0 +2881,1 @@\n+    __ post_call_nop();\n@@ -2886,0 +2889,1 @@\n+  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+\n+  inc_held_monitor_count(Rmark \/*tmp*\/);\n@@ -163,1 +165,1 @@\n-  \/\/ Test first it it is a fast recursive unlock.\n+  \/\/ Test first if it is a fast recursive unlock.\n@@ -189,0 +191,2 @@\n+\n+  dec_held_monitor_count(Rmark \/*tmp*\/);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n+#define CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n+\n+#include \"runtime\/frame.hpp\"\n+\n+class ContinuationEntryPD {\n+  \/\/ This is needed to position the ContinuationEntry at the unextended sp of the entry frame\n+  frame::abi_reg_args _abi;\n+};\n+\n+#endif \/\/ CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -30,1 +30,4 @@\n-\/\/ TODO: Implement\n+#include \"oops\/method.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -33,2 +36,4 @@\n-  Unimplemented();\n-  return frame();\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  return frame(entry_sp(), entry_pc(), entry_sp(), entry_fp(), cb);\n@@ -38,2 +43,1 @@\n-  Unimplemented();\n-  return nullptr;\n+  return (intptr_t*)((address)this + size());\n@@ -43,1 +47,1 @@\n-  Unimplemented();\n+\/\/ Nothing to do (no non-volatile registers in java calling convention)\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.inline.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+inline void patch_callee_link(const frame& f, intptr_t* fp) {\n+  *ContinuationHelper::Frame::callee_link_address(f) = fp;\n+}\n@@ -33,2 +36,12 @@\n-inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n-  Unimplemented();\n+inline void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n+  intptr_t* la = (intptr_t*)ContinuationHelper::Frame::callee_link_address(f);\n+  intptr_t new_value = fp - la;\n+  *la = new_value;\n+}\n+\n+\/\/\/\/\/\/ Freeze\n+\n+\/\/ Fast path\n+\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+  \/\/ Nothing to do. The backchain is reconstructed when thawing (see Thaw<ConfigT>::patch_caller_links())\n@@ -37,0 +50,2 @@\n+\/\/ Slow path\n+\n@@ -39,3 +54,8 @@\n-  Unimplemented();\n-  return frame();\n-}\n+  assert(FKind::is_instance(f), \"\");\n+  if (FKind::interpreted) {\n+    return frame(f.sender_sp(), f.sender_pc(), f.interpreter_frame_sender_sp());\n+  }\n+\n+  intptr_t* sender_sp = f.sender_sp();\n+  address sender_pc = f.sender_pc();\n+  assert(sender_sp != f.sp(), \"must have changed\");\n@@ -43,3 +63,5 @@\n-template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n-  Unimplemented();\n-  return frame();\n+  int slot = 0;\n+  CodeBlob* sender_cb = CodeCache::find_blob_and_oopmap(sender_pc, slot);\n+  return sender_cb != nullptr\n+    ? frame(sender_sp, sender_sp, nullptr, sender_pc, sender_cb, slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc))\n+    : frame(sender_sp, sender_pc, sender_sp);\n@@ -49,1 +71,8 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n+}\n+\n+static inline void relativize_one(intptr_t* const vfp, intptr_t* const hfp, int offset) {\n+  assert(*(hfp + offset) == *(vfp + offset), \"\");\n+  intptr_t* addr = hfp + offset;\n+  intptr_t value = *(intptr_t**)addr - vfp;\n+  *addr = value;\n@@ -53,1 +82,225 @@\n-  Unimplemented();\n+  intptr_t* vfp = f.fp();\n+  intptr_t* hfp = hf.fp();\n+  assert(f.fp() > (intptr_t*)f.interpreter_frame_esp(), \"\");\n+\n+  \/\/ There is alignment padding between vfp and f's locals array in the original\n+  \/\/ frame, therefore we cannot use it to relativize the locals pointer.\n+  *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + f.interpreter_frame_method()->max_locals() - 1;\n+  relativize_one(vfp, hfp, ijava_idx(monitors));\n+  relativize_one(vfp, hfp, ijava_idx(esp));\n+  relativize_one(vfp, hfp, ijava_idx(top_frame_sp));\n+\n+  \/\/ hfp == hf.sp() + (f.fp() - f.sp()) is not true on ppc because the stack frame has room for\n+  \/\/ the maximal expression stack and the expression stack in the heap frame is trimmed.\n+  assert(hf.fp() == hf.interpreter_frame_esp() + (f.fp() - f.interpreter_frame_esp()), \"\");\n+  assert(hf.fp()                 <= (intptr_t*)hf.at(ijava_idx(locals)), \"\");\n+}\n+\n+inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n+  stackChunkOop chunk = _cont.tail();\n+  assert(chunk->is_in_chunk(hf.sp()), \"hf.sp()=\" PTR_FORMAT, p2i(hf.sp()));\n+\n+  hf.own_abi()->lr = (uint64_t)hf.pc();\n+  if (hf.is_interpreted_frame()) {\n+    patch_callee_link_relative(hf, hf.fp());\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ See also FreezeBase::patch_pd()\n+    patch_callee_link(hf, (intptr_t*)badAddress);\n+  }\n+#endif\n+}\n+\n+\/\/\n+\/\/ Heap frames differ from stack frames in the following aspects\n+\/\/\n+\/\/ - they are just word aligned\n+\/\/ - the unextended sp of interpreted frames is set such that\n+\/\/   unextended sp + frame::metadata_words_at_top + 1 points to the last call parameter\n+\/\/   (the comment at the file end explains the unextended sp for interpreted frames on the stack)\n+\/\/\n+\/\/ The difference in respect to the unextended sp is required to comply with shared code.\n+\/\/ Furthermore fast frozen and compiled frames have invalid back links (see\n+\/\/ Thaw<ConfigT>::patch_caller_links() and FreezeBase::patch_pd())\n+\/\/\n+\/\/ === New Interpreted Frame ==========================================================================================\n+\/\/\n+\/\/ ### Interpreted Caller: Overlap new frame with Caller\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     |                        |<- FP of caller           | Caller's SP            |<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     | ijava_state            |                          | ijava_state            |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                  -----   |------------------------|\n+\/\/     | P0                     |                    ^     | L0 aka P0              |\n+\/\/     | :                      |                    |     | :      :               |\n+\/\/     | Pn                     |<- unext. SP        |     | :      Pn              |<- unext. SP\n+\/\/     |------------------------|   + metadata     overlap | :                      |   + metadata\n+\/\/     | frame::abi_minframe    |                    |     | Lm                     |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP  v     |------------------------|<- unextended SP of caller (1)\n+\/\/     ==========================   of caller      -----   | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/      overlap = stack_argsize(f)                         ==========================       ^\n+\/\/                + frame::metadata_words_at_top           | ijava_state            |       |\n+\/\/                                                         |                        |       |\n+\/\/      Where f is the frame to be relocated on the heap.  |------------------------|       |\n+\/\/      See also StackChunkFrameStream::frame_size().      | Expressions            |   FP - esp of f\n+\/\/                                                         | P0                     |       |\n+\/\/                                                         | :                      |       |\n+\/\/                            |  Growth  |                 | Pi                     |       v\n+\/\/                            v          v                 |------------------------|      ---\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- unextended SP \/\n+\/\/                                                         ==========================   SP of new frame\n+\/\/ ### Compiled Caller: No Overlap\n+\/\/\n+\/\/     The caller is resized to accomodate the callee's locals and abi but there is _no_ overlap with\n+\/\/     the original caller frame.\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | Caller's SP            |<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     |                        |                          |                        |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                          |------------------------|\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP        | (metadata_words_at_top)|<- unext. SP of caller\n+\/\/     ==========================   of caller              |------------------------|\n+\/\/                                                         | L0 aka P0              |\n+\/\/                                                         | :      :               |\n+\/\/                                                         | :      Pn              |\n+\/\/      overlap = 0                                        | Lm                     |\n+\/\/                                                         |------------------------|\n+\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/                                                         ==========================       ^\n+\/\/                                                         | ijava_state            |       |\n+\/\/                             |  Growth  |                |                        |       |\n+\/\/                             v          v                |------------------------|       |\n+\/\/                                                         | Expressions            |   FP - esp of f\n+\/\/                                                         | P0                     |       |\n+\/\/                                                         | :                      |       |\n+\/\/                                                         | Pi                     |       v\n+\/\/                                                         |------------------------|      ---\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- unextended SP \/\n+\/\/                                                         ==========================   SP of new frame\n+\/\/\n+\/\/ (1) Caller's unextended SP is preserved in callee's frame::ijava_state::sender_sp\n+\/\/     (See ContinuationHelper::InterpretedFrame::patch_sender_sp). This is required\n+\/\/     by StackChunkFrameStream<frame_kind>::next_for_interpreter_frame().\n+\/\/\n+\/\/ === New Compiled Frame =============================================================================================\n+\/\/\n+\/\/ ### Interpreted Caller: No Overlap\n+\/\/\n+\/\/     The caller is resized to accomodate the callee's stack arguments and abi but there is _no_ overlap with\n+\/\/     the original caller frame.\n+\/\/\n+\/\/     Note: a new ABI is added to the caller even if there are no stackargs.\n+\/\/     This is necessary to comply with shared code.\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | (metadata_words_at_top)|<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     | ijava_state            |                          | ijava_state            |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                          |------------------------|\n+\/\/     | P0                     |                          | P0                     |\n+\/\/     | :                      |                          | :                      |\n+\/\/     | Pn                     |<- unext. SP              | Pn                     |<- unext. SP\n+\/\/     |------------------------|   + metadata             |------------------------|   + metadata\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP        | (metadata_words_at_top)|<- unextended SP of caller (1)\n+\/\/     ==========================   of caller              |------------------------|\n+\/\/                                                         | Stack Args             |\n+\/\/      overlap = 0                                        | (if any)               |\n+\/\/                                                         |------------------------|\n+\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/                                                         ==========================\n+\/\/                                                         |                        |\n+\/\/                             |  Growth  |                |                        |\n+\/\/                             v          v                |------------------------|\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- SP == unext. SP of new frame\n+\/\/                                                         ==========================\n+\/\/\n+\/\/ ### Compiled Caller: Stackargs + ABI Overlap\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | (metadata_words_at_top)|<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     |                        |                          |                        |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                   -----  |------------------------|\n+\/\/     | Stack Args             |                     ^    | Stack Args             |\n+\/\/     | (if any)               |                     |    | (if any)               |\n+\/\/     |------------------------|                  overlap |------------------------|\n+\/\/     | frame::abi_minframe    |                     |    | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP   v    | (metadata_words_at_top)|<- SP == unext. SP of caller\n+\/\/     ==========================   of caller       -----  ==========================   \/ FP of new frame\n+\/\/                                                         |                        |\n+\/\/      overlap = stack_argsize(f)                         |                        |\n+\/\/                + frame::metadata_words_at_top           |------------------------|\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/      Where f is the frame to be relocated on the heap.  | (metadata_words_at_top)|<- SP == unext. SP of new frame\n+\/\/      See also StackChunkFrameStream::frame_size().      ==========================\n+\/\/\n+template<typename FKind>\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+  assert(FKind::is_instance(f), \"\");\n+\n+  intptr_t *sp, *fp;\n+  if (FKind::interpreted) {\n+    int locals = f.interpreter_frame_method()->max_locals();\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n+    \/\/ See also comment on StackChunkFrameStream<frame_kind>::interpreter_frame_size()\n+    int overlap =\n+        (caller.is_interpreted_frame() || caller.is_empty())\n+        ? ContinuationHelper::InterpretedFrame::stack_argsize(f) + frame::metadata_words_at_top\n+        : 0;\n+    fp = caller.unextended_sp() + overlap - locals - frame::metadata_words_at_top;\n+    \/\/ esp points one slot below the last argument\n+    intptr_t* x86_64_like_unextended_sp = f.interpreter_frame_esp() + 1 - frame::metadata_words_at_top;\n+    sp = fp - (f.fp() - x86_64_like_unextended_sp);\n+\n+    assert (sp <= fp && (fp <= caller.unextended_sp() || caller.is_interpreted_frame()),\n+            \"sp=\" PTR_FORMAT \" fp=\" PTR_FORMAT \" caller.unextended_sp()=\" PTR_FORMAT \" caller.is_interpreted_frame()=%d\",\n+            p2i(sp), p2i(fp), p2i(caller.unextended_sp()), caller.is_interpreted_frame());\n+    caller.set_sp(fp);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+    \/\/ frame_top() and frame_bottom() read these before relativize_interpreted_frame_metadata() is called\n+    *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + locals - 1;\n+    *hf.addr_at(ijava_idx(esp))    = f.interpreter_frame_esp() - f.fp();\n+    return hf;\n+  } else {\n+    int fsize = FKind::size(f);\n+    sp = caller.unextended_sp() - fsize;\n+    if (caller.is_interpreted_frame()) {\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n+      int argsize = FKind::stack_argsize(f);\n+      sp -= argsize + frame::metadata_words_at_top;\n+    }\n+    fp = sp + fsize;\n+    caller.set_sp(fp);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+  }\n@@ -57,1 +310,21 @@\n-  Unimplemented();\n+  if (caller.is_interpreted_frame()) {\n+    assert(!caller.is_empty(), \"\");\n+    patch_callee_link_relative(caller, caller.fp());\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ For compiled frames the back link is actually redundant. It gets computed\n+    \/\/ as unextended_sp + frame_size.\n+\n+    \/\/ Note the difference on x86_64: the link is not made relative if the caller\n+    \/\/ is a compiled frame because there rbp is used as a non-volatile register by\n+    \/\/ c1\/c2 so it could be a computed value local to the caller.\n+\n+    \/\/ See also:\n+    \/\/ - FreezeBase::set_top_frame_metadata_pd\n+    \/\/ - StackChunkFrameStream<frame_kind>::fp()\n+    \/\/ - UseContinuationFastPath: compiled frames are copied in a batch w\/o patching the back link.\n+    \/\/   The backlinks are restored when thawing (see Thaw<ConfigT>::patch_caller_links())\n+    patch_callee_link(hf, (intptr_t*)badAddress);\n+  }\n+#endif\n@@ -60,2 +333,8 @@\n-inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n-  Unimplemented();\n+\/\/\/\/\/\/\/\/ Thaw\n+\n+\/\/ Fast path\n+\n+inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n+  size <<= LogBytesPerWord;\n+  Prefetch::read(start, size);\n+  Prefetch::read(start, size - 64);\n@@ -64,0 +343,22 @@\n+\/\/ Set back chain links of fast thawed frames such that *sp == callers_sp.\n+\/\/ See https:\/\/refspecs.linuxfoundation.org\/ELF\/ppc64\/PPC-elf64abi.html#STACK\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  for (intptr_t* callers_sp; sp < bottom; sp = callers_sp) {\n+    address pc = (address)((frame::abi_minframe*) sp)->lr;\n+    assert(pc != nullptr, \"\");\n+    \/\/ see ThawBase::patch_return() which gets called just before\n+    bool is_entry_frame = pc == StubRoutines::cont_returnBarrier() || pc == _cont.entryPC();\n+    if (is_entry_frame) {\n+      callers_sp = _cont.entryFP();\n+    } else {\n+      CodeBlob* cb = CodeCache::find_blob(pc);\n+      callers_sp = sp + cb->frame_size();\n+    }\n+    \/\/ set the back link\n+    ((frame::abi_minframe*) sp)->callers_sp = (intptr_t) callers_sp;\n+  }\n+}\n+\n+\/\/ Slow path\n+\n@@ -65,2 +366,2 @@\n-  Unimplemented();\n-  return frame();\n+  intptr_t* sp = _cont.entrySP();\n+  return frame(sp, _cont.entryPC(), sp, _cont.entryFP());\n@@ -69,0 +370,112 @@\n+\/\/ === New Interpreted Frame ================================================================================================================\n+\/\/\n+\/\/ ### Non-Interpreted Caller (compiled, enterSpecial): No Overlap\n+\/\/\n+\/\/     Heap Frame `hf`                                   `hf` gets copied to stack _without_ overlapping the caller\n+\/\/\n+\/\/     |                      |                            Non-Interpreted |                      |\n+\/\/     |                      |<- bottom                   Caller          |----------------------|\n+\/\/     |----------------------|    ^                                       | frame::abi_minframe  |<- unextended SP\n+\/\/     | L0 aka P0            |    |                                   --- ========================\n+\/\/     | :      :             |    |                                    ^  | L0 aka P0            |\n+\/\/     | :      Pn            |    |                                    |  | :      :             | Parameters do\n+\/\/     | :                    |    |                                    |  | :      Pn            | not overlap with\n+\/\/     | Lm                   |    |                                    |  | :                    | caller!\n+\/\/     |----------------------| `fsize`                                 |  | :                    |\n+\/\/     | frame::abi_minframe  |    |                                       | :                    |\n+\/\/     ========================    |                     `fsize` + padding | Lm                   |\n+\/\/     |                      |    |                                       |----------------------|\n+\/\/     | ijava_state          |    |                                    |  | Opt. Align. Padding  |\n+\/\/     |                      |    |                                    |  |----------------------|\n+\/\/     |----------------------|    |                                    |  | frame::abi_minframe  |<- new SP of caller\n+\/\/     | L0 aka P0            |    |                                    |  ========================   \/ FP of new frame\n+\/\/     | :      :             |    |                                    |  |                      |   (aligned)\n+\/\/     | :      Pn            |<- unext. SP + metadata                  |  | ijava_state          |\n+\/\/     | :                    |    |                                    |  |                      |\n+\/\/     | Lm                   |    |                                    |  |----------------------|\n+\/\/     |----------------------|    v                                    |  | P0                   |\n+\/\/     | frame::abi_minframe  |<- SP \/ unextended SP                    |  | :                    |\n+\/\/     ========================                                         |  | Pi                   |<- unextended SP + metadata\n+\/\/                                                                      |  |----------------------|\n+\/\/                                           | Growth |                 v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                           v        v                --- ========================   (not yet aligned(1))\n+\/\/\n+\/\/\n+\/\/ ### Interpreted Caller: Overlap with Caller\n+\/\/\n+\/\/     Caller                                                              New frame with resized\/aligned Caller\n+\/\/\n+\/\/     |                      |                                            |                      |\n+\/\/     | ijava_state          |                                            | ijava_state          |\n+\/\/     |----------------------|                                            |----------------------|\n+\/\/     | non param. expr.     |                                     bottom | non param. expr.     |\n+\/\/     | - - - - - - - - - -  |                           ---           ^  | - - - - - - - - - -  |\n+\/\/     | P0                   |                            ^            |  | L0 aka P0            |\n+\/\/     | :                    |                            |            |  | :      :             |\n+\/\/     | Pn                   |<- unextended SP           overlap       |  | :      Pn            |<- unextended SP\n+\/\/     |----------------------|   + metadata_words_at_top  |            |  | :                    |   + metadata_words_at_top\n+\/\/     | frame::abi_minframe  |<- unextended SP            v            |  | :                    |   (unaligned)\n+\/\/     ========================   \/ SP of new frame       ---           |  | :                    |   of caller\n+\/\/                                (not yet aligned(1))                  |  | Lm                   |\n+\/\/                                                                `fsize`  |----------------------|\n+\/\/       overlap = stack_argsize(hf)                              + padding| Opt. Align. Padding  |\n+\/\/                 + frame::metadata_words_at_top                       |  |----------------------|\n+\/\/                                                                      |  | frame::abi_minframe  |<- new SP of caller\n+\/\/                                                                      |  ========================   \/ FP of new frame\n+\/\/                                                                      |  |                      |   (aligned)\n+\/\/                                  | Growth |                          |  | ijava_state          |\n+\/\/                                  v        v                          |  |                      |\n+\/\/                                                                      |  |----------------------|\n+\/\/                                                                      |  | P0                   |\n+\/\/                                                                      |  | :                    |\n+\/\/                                                                      |  | Pi                   |<- unextended SP\n+\/\/                                                                      |  |----------------------|    + metadata_words_at_top\n+\/\/                                                                      v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                                                     --- ========================   (not yet aligned(1))\n+\/\/\n+\/\/\n+\/\/  (1) The SP \/ unextended SP of the new interpreted frame is not aligned. It\n+\/\/      gets aligned when its callee is pushed on stack or in finish_thaw() if\n+\/\/      it is the top frame. This allows addressing parameters: unextended SP + metadata_words_at_top\n+\/\/\n+\/\/  (2) If caller is interpreted then its ijava_state::top_frame_sp will be used as sender sp\n+\/\/      of the new frame (see ContinuationHelper::InterpretedFrame::patch_sender_sp() and diagram at the end of this file)\n+\/\/\n+\/\/  (3) The size of alignment padding required when thawing frames is accounted for\n+\/\/      in FreezeBase::_align_size.\n+\/\/\n+\/\/ === New Compiled Frame ===================================================================================================================\n+\/\/\n+\/\/        Compiled Caller                              Interpreted Caller\n+\/\/\n+\/\/        - stackargs+abi overlap with caller          - gets resized for stackargs\n+\/\/        - no alignment padding                       - SP gets aligned\n+\/\/                                                     - no overlap with orig.\n+\/\/                                                       caller\n+\/\/   O C\n+\/\/   r a  |                      |                     |                      |\n+\/\/   i l  |                      |                     |                      |\n+\/\/   g l  |----------------------|                     |                      |\n+\/\/   i e  | Stack Args           |                     |                      |\n+\/\/   n r  | (if any)             |                     |----------------------|\n+\/\/   a    |----------------------|                     | frame::abi_minframe  |\n+\/\/   l    | frame::abi_minframe  |<- unext. SP \/ SP    | (unused)             |<- unal.unext.SP\n+\/\/  - - - ======================== - - - - - - - - - - |----------------------|- - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\/\/    N   |                      |                     | Opt. Align. Padding  |\n+\/\/    e   |                      |                     |----------------------|\n+\/\/    w   |----------------------|                     | Stack Args           |\n+\/\/        | frame::abi_minframe  |<- unext. SP \/ SP    | (if any)             |\n+\/\/    F   ========================                     |----------------------|\n+\/\/    r                                                | frame::abi_minframe  |<- caller's SP\n+\/\/    a                                                ======================== \/ new frame's FP\n+\/\/    m                                                |                      |   (aligned)\n+\/\/    e                                                |                      |\n+\/\/                                                     |----------------------|\n+\/\/                                                     | frame::abi_minframe  |<- unext. SP \/ SP\n+\/\/                                                     ========================\n+\/\/\n+\/\/  If the new frame is at the bottom just above the ContinuationEntry frame then the stackargs\n+\/\/  don't overlap the caller either even though it is compiled because the size is not\n+\/\/  limited\/known. In contrast to the interpreted caller case the abi overlaps with the caller\n+\/\/  if there are no stackargs. This is to comply with shared code (see e.g. StackChunkFrameStream::frame_size())\n+\/\/\n@@ -70,3 +483,1 @@\n-  Unimplemented();\n-  return frame();\n-}\n+  assert(FKind::is_instance(hf), \"\");\n@@ -74,3 +485,16 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n+  assert(is_aligned(caller.fp(), frame::frame_alignment), \"\");\n+  assert(is_aligned(caller.sp(), frame::frame_alignment), \"\");\n+  if (FKind::interpreted) {\n+    \/\/ Note: we have to overlap with the caller, at least if it is interpreted, to match the\n+    \/\/ max_thawing_size calculation during freeze. See also comment above.\n+    intptr_t* heap_sp = hf.unextended_sp();\n+    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp();\n+    const int overlap = !caller.is_interpreted_frame() ? 0\n+                        : ContinuationHelper::InterpretedFrame::stack_argsize(hf) + frame::metadata_words_at_top;\n+    intptr_t* frame_sp = caller.unextended_sp() + overlap - fsize;\n+    intptr_t* fp = frame_sp + (hf.fp() - heap_sp);\n+    \/\/ align fp\n+    int padding  = fp - align_down(fp, frame::frame_alignment);\n+    fp  -= padding;\n+    \/\/ alignment of sp is done by callee or in finish_thaw()\n+    frame_sp -= padding;\n@@ -78,2 +502,28 @@\n-inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n-  Unimplemented();\n+    \/\/ On ppc esp points to the next free slot on the expression stack and sp + metadata points to the last parameter\n+    DEBUG_ONLY(intptr_t* esp = fp + *hf.addr_at(ijava_idx(esp));)\n+    assert(frame_sp + frame::metadata_words_at_top == esp+1, \" frame_sp=\" PTR_FORMAT \" esp=\" PTR_FORMAT, p2i(frame_sp), p2i(esp));\n+    caller.set_sp(fp);\n+    frame f(frame_sp, hf.pc(), frame_sp, fp);\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n+    intptr_t offset = *hf.addr_at(ijava_idx(locals)) + padding;\n+    assert((int)offset == hf.interpreter_frame_method()->max_locals() + frame::metadata_words_at_top + padding - 1, \"\");\n+    *(intptr_t**)f.addr_at(ijava_idx(locals)) = fp + offset;\n+\n+    return f;\n+  } else {\n+    int fsize = FKind::size(hf);\n+    int argsize = hf.compiled_frame_stack_argsize();\n+    intptr_t* frame_sp = caller.sp() - fsize;\n+\n+    if ((bottom && argsize > 0) || caller.is_interpreted_frame()) {\n+      frame_sp   -= argsize + frame::metadata_words_at_top;\n+      frame_sp = align_down(frame_sp, frame::alignment_in_bytes);\n+      caller.set_sp(frame_sp + fsize);\n+    }\n+\n+    assert(hf.cb() != nullptr, \"\");\n+    assert(hf.oop_map() != nullptr, \"\");\n+    intptr_t* fp = frame_sp + fsize;\n+    return frame(frame_sp, frame_sp, fp, hf.pc(), hf.cb(), hf.oop_map(), false);\n+  }\n@@ -83,1 +533,1 @@\n-  Unimplemented();\n+  \/\/ Unused. Alignment is done directly in new_stack_frame() \/ finish_thaw().\n@@ -87,2 +537,11 @@\n-inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n-  Unimplemented();\n+static inline void derelativize_one(intptr_t* const fp, int offset) {\n+  intptr_t* addr = fp + offset;\n+  *addr = (intptr_t)(fp + *addr);\n+}\n+\n+inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  intptr_t* vfp = f.fp();\n+\n+  derelativize_one(vfp, ijava_idx(monitors));\n+  derelativize_one(vfp, ijava_idx(esp));\n+  derelativize_one(vfp, ijava_idx(top_frame_sp));\n@@ -91,2 +550,2 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n+inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  *(intptr_t**)f.addr_at(ijava_idx(locals)) = bottom - 1;\n@@ -95,2 +554,2 @@\n-inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n-  Unimplemented();\n+inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n+  patch_callee_link(caller, caller.fp());\n@@ -99,0 +558,69 @@\n+\/\/\n+\/\/ Interpreter Calling Procedure on PPC\n+\/\/\n+\/\/ Caller                                   Resized Caller before the Call                New Callee Frame\n+\/\/\n+\/\/   - SP\/FP are 16 byte aligned.           - The unused part of the expression stack     - The caller's original SP is passed as\n+\/\/     Padding is added as necessary.         is removed                                    sender SP (in R21_sender_SP) also by\n+\/\/   - SP is _not_ used as esp              - Slots for the callee's nonparameter locals    compiled callers. It is saved in the\n+\/\/     (expression stack pointer)             are added.                                    ijava_state::sender_sp slot and\n+\/\/   - Has reserved slots for the           - The large ABI is replaced with a minimal      restored when returning.\n+\/\/     maximal expression stack               ABI.                                          This removes a c2i extension if there\n+\/\/   - Has a larger ABI section on          - The original SP was saved in                  is one.\n+\/\/     top that is required to call           ijava_state::top_frame_sp slot.             - ijava_state::sender_sp will be set\n+\/\/     C++ code                               From there it is restored as SP _after_       as the caller's unextended sp when\n+\/\/                                            returning from a call. This reverts the       iterating stack frames\n+\/\/                                            resizing described above. It is also          (see frame::unextended_sp() and\n+\/\/                                            required to undo potential i2c extensions     frame::sender_for_interpreter_frame())\n+\/\/                                            if the calle should be compiled.\n+\/\/                                          - Note that unextended SP < SP\n+\/\/                                            is possible on ppc.\n+\/\/\n+\/\/ | Minimal ABI          |                 | Minimal ABI          |                      | Minimal ABI          |\n+\/\/ | (frame::abi_minframe)|                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ | 4 words              |                 | 4 words              |                      | 4 words              |\n+\/\/ | Caller's SP          |<- FP of caller  | Caller's SP          |<- FP of caller       | Caller's SP          |<- FP of caller\n+\/\/ ========================   (aligned)     ========================                      ========================\n+\/\/ | frame::              |                 | frame::              |                      | frame::              |\n+\/\/ | ijava_state          |                 | ijava_state          |                      | ijava_state          |\n+\/\/ |                      |                 |                      |                      |                      |\n+\/\/ |----------------------|                 |----------------------|                      |----------------------|\n+\/\/ | P0                   |                 | L0 aka P0            |                      | L0 aka P0            |\n+\/\/ |                      |                 | :                    |                      | :                    |\n+\/\/ | Pn                   |                 | :      Pn            |                      | :      Pn            |\n+\/\/ |----------------------|                 | :                    |                      | :                    |\n+\/\/ |                      |                 | Lm                   |                      | Lm                   |\n+\/\/ | Reserved Expr. Stack |                 |----------------------|                      |----------------------|\n+\/\/ |                      |                 | Opt. Alignm. Padding |                      | Opt. Alignm. Padding |\n+\/\/ |                      |<- ConstMethod   |----------------------|                      |----------------------|\n+\/\/ |----------------------|   ::_max_stack  | Minimal ABI          |                      | Minimal ABI          |\n+\/\/ | Opt. Alignm. Padding |                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ |----------------------|                 | 4 words              |                      | 4 words              |\n+\/\/ | Large ABI            |                 | Caller's SP          |<- new SP of caller   | Caller's SP          |<- SP of caller \/\n+\/\/ | for C++ calls        |                 ========================   (aligned)          ========================   FP of callee\n+\/\/ | (frame::abi_reg_args)|                                                               | frame::              |   (aligned)\n+\/\/ |                      |                                                               | ijava_state          |\n+\/\/ |                      |                                                               |                      |\n+\/\/ |                      |                                                               |----------------------|\n+\/\/ |                      |                                                               |                      |\n+\/\/ | Caller's SP          |<- SP of caller                          <- unextended SP      | Reserved Expr. Stack |<- unextended SP\n+\/\/ ========================   (aligned)                                of caller          |                      |   of caller\n+\/\/                                                                     (aligned)          |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |<- ConstMethod\n+\/\/                                                                                        |----------------------|   ::_max_stack\n+\/\/                         Resize Caller                    Push new Callee Frame         | Opt. Alignm. Padding |\n+\/\/                     -------------------->              ------------------------>       |----------------------|\n+\/\/                     (ABI, expressions, locals)                                         | Large ABI            |\n+\/\/                                                                                        | for C++ calls        |\n+\/\/                                                                                        | (frame::abi_reg_args)|\n+\/\/                                                                                        |                      |\n+\/\/                                                |  Growth  |                            |                      |\n+\/\/                                                v          v                            |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        | Caller's SP          |<- SP of callee\n+\/\/                                                                                        ========================   (aligned)\n+\/\/\n+\/\/\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":558,"deletions":30,"binary":false,"changes":588,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-  Unimplemented();\n-  return 0;\n+  return size & 1;\n@@ -41,3 +40,2 @@\n-inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* sp) {\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* p) {\n+  return align_down(p, frame::frame_alignment);\n@@ -56,1 +54,1 @@\n-  Unimplemented();\n+  f.own_abi()->callers_sp = (uint64_t)f.fp();\n@@ -61,1 +59,1 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n@@ -66,1 +64,1 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n@@ -70,2 +68,6 @@\n-  Unimplemented();\n-  return false;\n+  intptr_t* sp = f.sp();\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  intptr_t* fp = (intptr_t*)f.own_abi()->callers_sp;\n+  assert(f.raw_pc() == pc, \"f.ra_pc: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.raw_pc()), p2i(pc));\n+  assert(f.fp() == fp, \"f.fp: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.fp()), p2i(fp));\n+  return f.raw_pc() == pc && f.fp() == fp;\n@@ -76,8 +78,1 @@\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template<typename FKind>\n-static inline intptr_t* real_fp(const frame& f) {\n-  Unimplemented();\n-  return NULL;\n+  return (intptr_t**)&f.own_abi()->callers_sp;\n@@ -87,2 +82,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)&f.callers_abi()->lr;\n@@ -91,2 +85,10 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n-  Unimplemented();\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n+  if (!f.is_heap_frame() && caller.is_interpreted_frame()) {\n+    \/\/ See diagram \"Interpreter Calling Procedure on PPC\" at the end of continuationFreezeThaw_ppc.inline.hpp\n+    sp = (intptr_t*)caller.at(ijava_idx(top_frame_sp));\n+  }\n+  assert(f.is_interpreted_frame(), \"\");\n+  assert(f.is_heap_frame() || is_aligned(sp, frame::alignment_in_bytes), \"\");\n+  intptr_t* la = f.addr_at(ijava_idx(sender_sp));\n+  *la = f.is_heap_frame() ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n@@ -96,2 +98,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)&f.callers_abi()->lr;\n@@ -101,2 +102,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address)f.own_abi()->lr;\n@@ -106,3 +106,54 @@\n-  Unimplemented();\n-}\n-\n+  f.own_abi()->lr = (uint64_t)pc;\n+}\n+\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- FP of f's caller\n+\/\/                     |======================|\n+\/\/                     |                      |                                 Frame of f's caller\n+\/\/                     |                      |\n+\/\/ frame_bottom of f ->|                      |\n+\/\/                     |----------------------|\n+\/\/                     | L0 aka P0            |\n+\/\/                     | :                    |\n+\/\/                     | :      Pn            |\n+\/\/                     | :                    |\n+\/\/                     | Lm                   |\n+\/\/                     |----------------------|\n+\/\/                     | SP alignment (opt.)  |\n+\/\/                     |----------------------|\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- SP of f's caller \/ FP of f\n+\/\/                     |======================|\n+\/\/                     |ijava_state (metadata)|                                 Frame of f\n+\/\/                     |                      |\n+\/\/                     |                      |\n+\/\/                     |----------------------|\n+\/\/                     | Expression stack     |\n+\/\/                     |                      |\n+\/\/    frame_top of f ->|                      |\n+\/\/   if callee interp. |......................|\n+\/\/                     | L0 aka P0            |<- ijava_state.esp + callee_argsize\n+\/\/                     | :                    |\n+\/\/    frame_top of f ->| :      Pn            |\n+\/\/  + metadata_words   | :                    |<- ijava_state.esp (1 slot below Pn)\n+\/\/    if callee comp.  | Lm                   |\n+\/\/                     |----------------------|\n+\/\/                     | SP alignment (opt.)  |\n+\/\/                     |----------------------|\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- SP of f \/ FP of f's callee\n+\/\/                     |======================|\n+\/\/                     |ijava_state (metadata)|                                 Frame of f's callee\n+\/\/                     |                      |\n+\/\/\n+\/\/                           |  Growth  |\n+\/\/                           v          v\n+\/\/\n+\/\/ See also diagram at the end of continuation_ppc.inline.hpp\n+\/\/\n@@ -110,2 +161,9 @@\n-  Unimplemented();\n-  return NULL;\n+  int expression_stack_sz = expression_stack_size(f, mask);\n+  intptr_t* res = (intptr_t*)f.interpreter_frame_monitor_end() - expression_stack_sz;\n+  assert(res <= (intptr_t*)f.get_ijava_state() - expression_stack_sz,\n+         \"res=\" PTR_FORMAT \" f.get_ijava_state()=\" PTR_FORMAT \" expression_stack_sz=%d\",\n+         p2i(res), p2i(f.get_ijava_state()), expression_stack_sz);\n+  assert(res >= f.unextended_sp(),\n+         \"res: \" INTPTR_FORMAT \" ijava_state: \" INTPTR_FORMAT \" esp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" expression_stack_size: %d\",\n+         p2i(res), p2i(f.get_ijava_state()), f.get_ijava_state()->esp, p2i(f.unextended_sp()), expression_stack_sz);\n+  return res;\n@@ -114,3 +172,2 @@\n-inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) {\n+  return (intptr_t*)f.at(ijava_idx(locals)) + 1; \/\/ exclusive (will not be copied), so we add 1 word\n@@ -119,3 +176,3 @@\n-inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize_incl_metadata, bool callee_interpreted) {\n+  intptr_t* pseudo_unextended_sp = f.interpreter_frame_esp() + 1 - frame::metadata_words_at_top;\n+  return pseudo_unextended_sp + (callee_interpreted ? callee_argsize_incl_metadata : 0);\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":94,"deletions":37,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  if (is_heap_frame()) {\n+    return true;\n+  }\n@@ -82,1 +85,1 @@\n-  if (_cb != NULL ){\n+  if (_cb != NULL) {\n@@ -121,0 +124,7 @@\n+    if (Continuation::is_return_barrier_entry(sender_pc)) {\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n+    }\n+\n@@ -178,4 +188,0 @@\n-bool frame::is_interpreted_frame() const  {\n-  return Interpreter::contains(pc());\n-}\n-\n@@ -213,2 +219,17 @@\n-  \/\/ Pass callers initial_caller_sp as unextended_sp.\n-  return frame(sender_sp(), sender_pc(), (intptr_t*)get_ijava_state()->sender_sp);\n+  \/\/ This is the sp before any possible extension (adapter\/locals).\n+  intptr_t* unextended_sp = interpreter_frame_sender_sp();\n+  address sender_pc = this->sender_pc();\n+  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp());\n+    }\n+  }\n+\n+  return frame(sender_sp(), sender_pc, unextended_sp);\n+}\n+\n+intptr_t* frame::interpreter_frame_sender_sp() const {\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  return (intptr_t*)at(ijava_idx(sender_sp));\n@@ -382,0 +403,7 @@\n+\n+  if (is_java_frame() || Continuation::is_continuation_enterSpecial(*this)) {\n+    intptr_t* ret_pc_loc = (intptr_t*)&own_abi()->lr;\n+    address ret_pc = *(address*)ret_pc_loc;\n+    values.describe(frame_no, ret_pc_loc,\n+      Continuation::is_return_barrier_entry(ret_pc) ? \"return address (return barrier)\" : \"return address\");\n+  }\n@@ -398,1 +426,5 @@\n-  return (BasicObjectLock*) get_ijava_state()->monitors;\n+  BasicObjectLock* result = (BasicObjectLock*) at(ijava_idx(monitors));\n+  \/\/ make sure the pointer points inside the frame\n+  assert(sp() <= (intptr_t*) result, \"monitor end should be above the stack pointer\");\n+  assert((intptr_t*) result < fp(),  \"monitor end should be strictly below the frame pointer: result: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(result), p2i(fp()));\n+  return result;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+\/\/ Byte offset relative to fp\n@@ -274,0 +275,4 @@\n+\/\/ Frame slot index relative to fp\n+#define ijava_idx(_component) \\\n+        (_ijava_state_neg(_component) >> LogBytesPerWord)\n+\n@@ -359,1 +364,4 @@\n-  intptr_t* _unextended_sp;\n+  union {\n+    intptr_t* _unextended_sp;\n+    int _offset_unextended_sp; \/\/ for use in stack-chunk frames\n+  };\n@@ -361,2 +369,4 @@\n-  \/\/ frame pointer for this frame\n-  intptr_t* _fp;\n+  union {\n+    intptr_t*  _fp; \/\/ frame pointer\n+    int _offset_fp; \/\/ relative frame pointer for use in stack-chunk frames\n+  };\n@@ -367,1 +377,4 @@\n-  intptr_t* fp() const { return _fp; }\n+  intptr_t* fp() const { assert_absolute(); return _fp; }\n+  void set_fp(intptr_t* newfp)  { _fp = newfp; }\n+  int offset_fp() const         { assert_offset();  return _offset_fp; }\n+  void set_offset_fp(int value) { assert_on_heap(); _offset_fp = value; }\n@@ -383,0 +396,1 @@\n+  inline frame(intptr_t* sp, intptr_t* fp, address pc);\n@@ -384,0 +398,2 @@\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap);\n@@ -414,3 +430,14 @@\n-    pc_return_offset = 0,\n-    metadata_words   = 0,\n-    frame_alignment  = 16,\n+    pc_return_offset                       = 0,\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                         = sizeof(abi_minframe) >> LogBytesPerWord,\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom               = 0,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                  = sizeof(abi_minframe) >> LogBytesPerWord,\n+    \/\/ size, in words, of frame metadata at the frame top that needs\n+    \/\/ to be reserved for callee functions in the runtime\n+    frame_alignment                        = 16,\n+    frame_alignment_in_words               = frame_alignment >> LogBytesPerWord,\n@@ -418,1 +445,1 @@\n-    align_wiggle     =  1\n+    align_wiggle                           =  1\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"code\/codeCache.hpp\"\n+#include \"code\/codeBlob.inline.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n@@ -47,4 +48,0 @@\n-  if (_fp == nullptr) {\n-    _fp = (intptr_t*)own_abi()->callers_sp;\n-  }\n-\n@@ -55,3 +52,11 @@\n-  \/\/ When thawing continuation frames the _unextended_sp passed to the constructor is not aligend\n-  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) && is_aligned(_fp, alignment_in_bytes)),\n-         \"invalid alignment sp:\" PTR_FORMAT \" unextended_sp:\" PTR_FORMAT \" fp:\" PTR_FORMAT, p2i(_sp), p2i(_unextended_sp), p2i(_fp));\n+  if (_fp == nullptr) {\n+    \/\/ The back link for compiled frames on the heap is not valid\n+    if (is_heap_frame()) {\n+      \/\/ fp for interpreted frames should have been derelativized and passed to the constructor\n+      assert(is_compiled_frame(), \"\");\n+      \/\/ The back link for compiled frames on the heap is invalid.\n+      _fp = _unextended_sp + _cb->frame_size();\n+    } else {\n+      _fp = (intptr_t*)own_abi()->callers_sp;\n+    }\n+  }\n@@ -73,1 +78,4 @@\n-  assert(_on_heap || is_aligned(_sp, frame::frame_alignment), \"SP must be 16-byte aligned\");\n+  \/\/ Continuation frames on the java heap are not aligned.\n+  \/\/ When thawing interpreted frames the sp can be unaligned (see new_stack_frame()).\n+  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) && is_aligned(_fp, alignment_in_bytes),\n+         \"invalid alignment sp:\" PTR_FORMAT \" unextended_sp:\" PTR_FORMAT \" fp:\" PTR_FORMAT, p2i(_sp), p2i(_unextended_sp), p2i(_fp));\n@@ -82,0 +90,4 @@\n+inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+\n+inline frame::frame(intptr_t* sp, intptr_t* fp, address pc) : frame(sp, pc, nullptr, fp, nullptr) {}\n+\n@@ -88,1 +100,24 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map)\n+  : _sp(sp), _pc(pc), _cb(cb), _oop_map(oop_map),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  setup();\n+}\n+\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb,\n+                    const ImmutableOopMap* oop_map, bool on_heap)\n+                    : _sp(sp), _pc(pc), _cb(cb), _oop_map(oop_map), _deopt_state(not_deoptimized),\n+                      _on_heap(on_heap), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  \/\/ In thaw, non-heap frames use this constructor to pass oop_map.  I don't know why.\n+  assert(_on_heap || _cb != nullptr, \"these frames are always heap frames\");\n+  if (cb != NULL) {\n+    setup();\n+  }\n+#ifdef ASSERT\n+  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run,\n+  \/\/ which is not *in* a continuation and therefore does not clear the _cont_fastpath flag, but this\n+  \/\/ is benign even in fast mode (see Freeze::setup_jump)\n+  \/\/ We might freeze deoptimized frame in slow mode\n+  \/\/ assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n+#endif\n+}\n@@ -114,5 +149,8 @@\n-\/\/ c2i adapter. This is needed by deoptimization for ignoring c2i adapter\n-\/\/ frames.\n-inline intptr_t* frame::unextended_sp() const {\n-  return _unextended_sp;\n-}\n+\/\/ c2i adapter.\n+\/\/ i2c adapters also modify the frame they are applied on but shared code\n+\/\/ must never use an interpreted frames unextended sp directly as the value\n+\/\/ is platform dependent.\n+inline intptr_t* frame::unextended_sp() const          { assert_absolute(); return _unextended_sp; }\n+inline void frame::set_unextended_sp(intptr_t* value)  { _unextended_sp = value; }\n+inline int  frame::offset_unextended_sp() const        { assert_offset();   return _offset_unextended_sp; }\n+inline void frame::set_offset_unextended_sp(int value) { assert_on_heap();  _offset_unextended_sp = value; }\n@@ -153,1 +191,1 @@\n-  return (intptr_t**) &(get_ijava_state()->locals);\n+  return (intptr_t**)addr_at(ijava_idx(locals));\n@@ -186,1 +224,1 @@\n-  return (intptr_t*) get_ijava_state()->esp;\n+  return (intptr_t*) at(ijava_idx(esp));\n@@ -197,1 +235,2 @@\n-  return (intptr_t*)interpreter_frame_monitor_end() - 1;\n+  intptr_t* monitor_end = (intptr_t*) interpreter_frame_monitor_end();\n+  return monitor_end-1;\n@@ -202,1 +241,1 @@\n-  return ((intptr_t*) get_ijava_state()->esp) + Interpreter::stackElementWords;\n+  return (intptr_t*)at(ijava_idx(esp)) + Interpreter::stackElementWords;\n@@ -229,2 +268,2 @@\n-inline oop frame::saved_oop_result(RegisterMap* map) const {\n-  return *((oop*)map->location(R3->as_VMReg(), nullptr));\n+inline bool frame::is_interpreted_frame() const  {\n+  return Interpreter::contains(pc());\n@@ -233,3 +272,4 @@\n-inline void frame::set_saved_oop_result(RegisterMap* map, oop obj) {\n-  *((oop*)map->location(R3->as_VMReg(), nullptr)) = obj;\n-}\n+inline frame frame::sender_raw(RegisterMap* map) const {\n+  \/\/ Default is we do have to follow them. The sender_for_xxx will\n+  \/\/ update it accordingly.\n+  map->set_include_argument_oops(false);\n@@ -237,10 +277,2 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != NULL && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n+  if (map->in_cont()) { \/\/ already in an h-stack\n+    return map->stack_chunk()->sender(*this, map);\n@@ -248,2 +280,0 @@\n-  return NULL;\n-}\n@@ -251,4 +281,2 @@\n-inline int frame::compiled_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n+  if (is_entry_frame())           return sender_for_entry_frame(map);\n+  if (is_interpreted_frame())     return sender_for_interpreter_frame(map);\n@@ -256,17 +284,2 @@\n-inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n-  Unimplemented();\n-}\n-\n-inline int frame::sender_sp_ret_address_offset() {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void frame::set_unextended_sp(intptr_t* value) {\n-  Unimplemented();\n-}\n-\n-inline int frame::offset_unextended_sp() const {\n-  Unimplemented();\n-  return 0;\n-}\n+  assert(_cb == CodeCache::find_blob(pc()), \"Must be the same\");\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -274,2 +287,3 @@\n-inline void frame::set_offset_unextended_sp(int value) {\n-  Unimplemented();\n+  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+  \/\/ methods that exists in the core system.\n+  return frame(sender_sp(), sender_pc());\n@@ -278,4 +292,1 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender\n-\n-frame frame::sender(RegisterMap* map) const {\n+inline frame frame::sender(RegisterMap* map) const {\n@@ -284,1 +295,1 @@\n-  if (map->process_frames()) {\n+  if (map->process_frames() && !map->in_cont()) {\n@@ -291,16 +302,0 @@\n-inline frame frame::sender_raw(RegisterMap* map) const {\n-  \/\/ Default is we do have to follow them. The sender_for_xxx will\n-  \/\/ update it accordingly.\n-  map->set_include_argument_oops(false);\n-\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n-  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n-\n-  if (_cb != nullptr) return sender_for_compiled_frame(map);\n-\n-  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n-  \/\/ methods that exists in the core system.\n-  return frame(sender_sp(), sender_pc());\n-}\n-\n@@ -313,1 +308,0 @@\n-  \/\/ Now adjust the map.\n@@ -316,3 +310,21 @@\n-    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n-    if (_cb->oop_maps() != nullptr) {\n-      OopMapSet::update_register_map(this, map);\n+    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n+    \/\/ outside of update_register_map.\n+    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+      map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+      if (oop_map() != nullptr) {\n+        _oop_map->update_register_map(this, map);\n+      }\n+    } else {\n+      assert(!_cb->caller_must_gc_arguments(map->thread()), \"\");\n+      assert(!map->include_argument_oops(), \"\");\n+      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+    }\n+  }\n+\n+  assert(sender_sp != sp(), \"must have changed\");\n+\n+  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n@@ -325,0 +337,43 @@\n+inline oop frame::saved_oop_result(RegisterMap* map) const {\n+  oop* result_adr = (oop *)map->location(R3->as_VMReg(), sp());\n+  guarantee(result_adr != NULL, \"bad register save location\");\n+  return *result_adr;\n+}\n+\n+inline void frame::set_saved_oop_result(RegisterMap* map, oop obj) {\n+  oop* result_adr = (oop *)map->location(R3->as_VMReg(), sp());\n+  guarantee(result_adr != NULL, \"bad register save location\");\n+\n+  *result_adr = obj;\n+}\n+\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  if (_cb == NULL) return NULL;\n+  if (_cb->oop_maps() != NULL) {\n+    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+    if (nop != NULL && nop->displacement() != 0) {\n+      int slot = ((nop->displacement() >> 24) & 0xff);\n+      return _cb->oop_map_for_slot(slot, _pc);\n+    }\n+    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+    return oop_map;\n+  }\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  assert(cb()->is_compiled(), \"\");\n+  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  assert(mask != NULL, \"\");\n+  Method* m = interpreter_frame_method();\n+  int   bci = interpreter_frame_bci();\n+  m->mask_for(bci, mask); \/\/ OopMapCache::compute_one_oop_map(m, bci, mask);\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  return -(int)(_abi0(lr) >> LogBytesPerWord); \/\/ offset in words\n+}\n+\n@@ -327,1 +382,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do.\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":140,"deletions":85,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-define_pd_global(bool,  VMContinuations, false);\n+define_pd_global(bool,  VMContinuations, true);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false);\n+  void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false, bool restore_top_frame_sp = false);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+  pop_cont_fastpath();\n@@ -930,1 +931,1 @@\n-    Label done;\n+    Label count_locking, done;\n@@ -975,1 +976,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -997,1 +998,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -1007,0 +1008,1 @@\n+    b(done);\n@@ -1009,0 +1011,2 @@\n+    bind(count_locking);\n+    inc_held_monitor_count(current_header \/*tmp*\/);\n@@ -1098,0 +1102,1 @@\n+    dec_held_monitor_count(current_header \/*tmp*\/);\n@@ -2167,1 +2172,1 @@\n-void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only) {\n+void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only, bool restore_top_frame_sp) {\n@@ -2169,0 +2174,9 @@\n+  if (restore_top_frame_sp) {\n+    \/\/ After thawing the top frame of a continuation we reach here with frame::abi_minframe.\n+    \/\/ therefore we have to restore top_frame_sp before the assertion below.\n+    assert(!bcp_and_mdx_only, \"chose other registers\");\n+    Register tfsp = R18_locals;\n+    Register scratch2 = R26_monitor;\n+    ld(tfsp, _ijava_state_neg(top_frame_sp), scratch);\n+    resize_frame_absolute(tfsp, scratch2, R0);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1183,0 +1183,8 @@\n+void MacroAssembler::post_call_nop() {\n+  \/\/ Make inline again when loom is always enabled.\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  nop();\n+}\n+\n@@ -2627,0 +2635,1 @@\n+  Label success, failure;\n@@ -2635,1 +2644,1 @@\n-    bne(flag, cont);\n+    bne(flag, failure);\n@@ -2673,0 +2682,3 @@\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object and we have now locked it.\n+    b(success);\n@@ -2676,0 +2688,1 @@\n+    b(failure);\n@@ -2678,4 +2691,0 @@\n-  \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-  \/\/ object and we have now locked it.\n-  b(cont);\n-\n@@ -2696,1 +2705,0 @@\n-  \/\/ Handle existing monitor.\n@@ -2699,0 +2707,1 @@\n+  \/\/ Handle existing monitor.\n@@ -2723,1 +2732,1 @@\n-  beq(flag, cont);\n+  beq(flag, success);\n@@ -2727,1 +2736,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2740,1 +2749,1 @@\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, increment held monitor count\n@@ -2742,0 +2751,4 @@\n+  bne(flag, failure);\n+  bind(success);\n+  inc_held_monitor_count(temp);\n+  bind(failure);\n@@ -2749,1 +2762,2 @@\n-  Label cont, object_has_monitor, notRecursive;\n+  Label object_has_monitor, notRecursive;\n+  Label success, failure;\n@@ -2759,1 +2773,1 @@\n-    b(cont);                                                    \/\/ ... and we're done\n+    b(success);                                                 \/\/ ... and we're done\n@@ -2770,1 +2784,1 @@\n-    beq(flag, cont);\n+    beq(flag, success);\n@@ -2792,1 +2806,1 @@\n-             &cont);\n+             &failure);\n@@ -2794,0 +2808,1 @@\n+    b(success);\n@@ -2797,0 +2812,1 @@\n+    b(failure);\n@@ -2800,2 +2816,0 @@\n-  b(cont);\n-\n@@ -2815,1 +2829,1 @@\n-    b(cont);\n+    b(success);\n@@ -2823,1 +2837,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2828,1 +2842,1 @@\n-  b(cont); \/\/ flag is already EQ here.\n+  b(success); \/\/ flag is already EQ here.\n@@ -2835,1 +2849,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2839,2 +2853,1 @@\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, decrement held monitor count\n@@ -2842,0 +2855,3 @@\n+  bind(success);\n+  dec_held_monitor_count(temp);\n+  bind(failure);\n@@ -4373,0 +4389,45 @@\n+\n+void MacroAssembler::push_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  st_ptr(R1_SP, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::pop_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  li(R0, 0);\n+  st_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::inc_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bge_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is negativ at increment\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, 1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n+\n+void MacroAssembler::dec_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bgt_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is <= 0 at decrement\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, -1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":82,"deletions":21,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class OopMap;\n@@ -419,0 +420,2 @@\n+  void post_call_nop();\n+\n@@ -602,0 +605,5 @@\n+  void push_cont_fastpath();\n+  void pop_cont_fastpath();\n+  void inc_held_monitor_count(Register tmp);\n+  void dec_held_monitor_count(Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  if (*(int*)addr != 0 \/*illtrap*\/) return false;\n+  if (!Assembler::is_illtrap(addr)) return false;\n@@ -427,0 +427,30 @@\n+\n+void NativePostCallNop::make_deopt() {\n+  NativeDeoptInstruction::insert(addr_at(0));\n+}\n+\n+void NativePostCallNop::patch(jint diff) {\n+  \/\/ unsupported for now\n+}\n+\n+void NativeDeoptInstruction::verify() {\n+}\n+\n+bool NativeDeoptInstruction::is_deopt_at(address code_pos) {\n+  if (!Assembler::is_illtrap(code_pos)) return false;\n+  CodeBlob* cb = CodeCache::find_blob(code_pos);\n+  if (cb == NULL || !cb->is_compiled()) return false;\n+  nmethod *nm = (nmethod *)cb;\n+  \/\/ see NativeInstruction::is_sigill_not_entrant_at()\n+  return nm->verified_entry_point() != code_pos;\n+}\n+\n+\/\/ Inserts an undefined instruction at a given pc\n+void NativeDeoptInstruction::insert(address code_pos) {\n+  ResourceMark rm;\n+  int code_size = 1 * BytesPerInstWord;\n+  CodeBuffer cb(code_pos, code_size + 1);\n+  MacroAssembler* a = new MacroAssembler(&cb);\n+  a->illtrap();\n+  ICache::ppc64_flush_icache_bytes(code_pos, code_size);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -54,1 +54,3 @@\n-  bool is_jump() { return Assembler::is_b(long_at(0)); } \/\/ See NativeGeneralJump.\n+  bool is_nop() const { return Assembler::is_nop(long_at(0)); }\n+\n+  bool is_jump() const { return Assembler::is_b(long_at(0)); } \/\/ See NativeGeneralJump.\n@@ -508,1 +510,1 @@\n-  bool check() const { Unimplemented(); return false; }\n+  bool check() const { return is_nop(); }\n@@ -510,2 +512,2 @@\n-  void patch(jint diff) { Unimplemented(); }\n-  void make_deopt() { Unimplemented(); }\n+  void patch(jint diff);\n+  void make_deopt();\n@@ -515,1 +517,4 @@\n-  \/\/ Unimplemented();\n+  NativePostCallNop* nop = (NativePostCallNop*) address;\n+  if (nop->check()) {\n+    return nop;\n+  }\n@@ -520,3 +525,5 @@\n-public:\n-  address instruction_address() const       { Unimplemented(); return NULL; }\n-  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+ public:\n+  enum {\n+    instruction_size            =    4,\n+    instruction_offset          =    0,\n+  };\n@@ -524,1 +531,2 @@\n-  void  verify() { Unimplemented(); }\n+  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address next_instruction_address() const  { return addr_at(instruction_size); }\n@@ -526,4 +534,3 @@\n-  static bool is_deopt_at(address instr) {\n-    \/\/ Unimplemented();\n-    return false;\n-  }\n+  void  verify();\n+\n+  static bool is_deopt_at(address code_pos);\n@@ -532,3 +539,1 @@\n-  static void insert(address code_pos) {\n-    Unimplemented();\n-  }\n+  static void insert(address code_pos);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3450,0 +3450,1 @@\n+    __ post_call_nop();\n@@ -3490,0 +3491,1 @@\n+    __ post_call_nop();\n@@ -3604,0 +3606,1 @@\n+    __ post_call_nop();\n@@ -3615,0 +3618,1 @@\n+    __ post_call_nop();\n@@ -3630,0 +3634,1 @@\n+    __ post_call_nop();\n@@ -14381,1 +14386,1 @@\n-  size(4);\n+  size(8);\n@@ -14402,1 +14407,1 @@\n-  size(4);\n+  size(8);\n@@ -14480,1 +14485,1 @@\n-  size(4);\n+  size(8);\n@@ -14483,0 +14488,1 @@\n+    __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-REGISTER_DECLARATION(Register, R15_esp,        R15);\n+REGISTER_DECLARATION(Register, R15_esp,        R15);      \/\/ slot below top of expression stack for ld\/st with update\n@@ -758,1 +758,1 @@\n-REGISTER_DECLARATION(Register, R17_tos,        R17);      \/\/ address of Java tos (prepushed).\n+REGISTER_DECLARATION(Register, R17_tos,        R17);      \/\/ The interpreter's top of (expression) stack cache register\n","filename":"src\/hotspot\/cpu\/ppc\/register_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -40,0 +41,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -629,0 +632,3 @@\n+STATIC_ASSERT(num_java_iarg_registers == Argument::n_int_register_parameters_j);\n+STATIC_ASSERT(num_java_farg_registers == Argument::n_float_register_parameters_j);\n+\n@@ -1177,0 +1183,2 @@\n+  __ push_cont_fastpath(); \/\/ Set JavaThread::_cont_fastpath to the sp of the oldest interpreted frame we know about\n+\n@@ -1621,0 +1629,372 @@\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Frame setup.\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   R1_SP: pointer to blank ContinuationEntry in the pushed frame.\n+\/\/\n+\/\/ Kills:\n+\/\/   R0, R20\n+\/\/\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& framesize_words) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  const int frame_size_in_bytes = (int)ContinuationEntry::size();\n+  assert(is_aligned(frame_size_in_bytes, frame::alignment_in_bytes), \"alignment error\");\n+\n+  framesize_words = frame_size_in_bytes \/ wordSize;\n+\n+  DEBUG_ONLY(__ block_comment(\"setup {\"));\n+  \/\/ Save return pc and push entry frame\n+  const Register return_pc = R20;\n+  __ mflr(return_pc);\n+  __ std(return_pc, _abi0(lr), R1_SP);     \/\/ SP->lr = return_pc\n+  __ push_frame(frame_size_in_bytes , R0); \/\/ SP -= frame_size_in_bytes\n+\n+  OopMap* map = new OopMap((int)frame_size_in_bytes \/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ ld_ptr(R0, JavaThread::cont_entry_offset(), R16_thread);\n+  __ st_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+  __ st_ptr(R0, ContinuationEntry::parent_offset(), R1_SP);\n+  DEBUG_ONLY(__ block_comment(\"} setup\"));\n+\n+  return map;\n+}\n+\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Initialize the new ContinuationEntry.\n+\/\/\n+\/\/ Arguments:\n+\/\/   R1_SP: pointer to blank Continuation entry\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n+\/\/\n+\/\/ Results:\n+\/\/   R1_SP: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/\n+static void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(reg_cont_obj, reg_flags);\n+  Register zero = R8_ARG6;\n+  Register tmp2 = R9_ARG7;\n+  Register tmp3 = R10_ARG8;\n+\n+  DEBUG_ONLY(__ block_comment(\"fill {\"));\n+#ifdef ASSERT\n+  __ load_const_optimized(tmp2, 0x1234);\n+  __ stw(tmp2, in_bytes(ContinuationEntry::cookie_offset()), R1_SP);\n+#endif \/\/ASSERT\n+\n+  __ li(zero, 0);\n+  __ st_ptr(reg_cont_obj, ContinuationEntry::cont_offset(), R1_SP);\n+  __ stw(reg_flags, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+  __ st_ptr(zero, ContinuationEntry::chunk_offset(), R1_SP);\n+  __ stw(zero, in_bytes(ContinuationEntry::argsize_offset()), R1_SP);\n+  __ stw(zero, in_bytes(ContinuationEntry::pin_count_offset()), R1_SP);\n+\n+  __ ld_ptr(tmp2, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ ld(tmp3, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  __ st_ptr(tmp2, ContinuationEntry::parent_cont_fastpath_offset(), R1_SP);\n+  __ std(tmp3, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n+\n+  __ st_ptr(zero, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ std(zero, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  DEBUG_ONLY(__ block_comment(\"} fill\"));\n+}\n+\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Copy corresponding attributes from the top ContinuationEntry to the JavaThread\n+\/\/ before deleting it.\n+\/\/\n+\/\/ Arguments:\n+\/\/   R1_SP: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   None.\n+\/\/\n+\/\/ Kills:\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n+  Register tmp1 = R8_ARG6;\n+  Register tmp2 = R9_ARG7;\n+  Register tmp3 = R10_ARG8;\n+\n+#ifdef ASSERT\n+  __ block_comment(\"clean {\");\n+  __ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread);\n+  __ cmpd(CCR0, R1_SP, tmp1);\n+  __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+  __ ld_ptr(tmp1, ContinuationEntry::parent_cont_fastpath_offset(), R1_SP);\n+  __ ld(tmp2, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n+  __ ld_ptr(tmp3, ContinuationEntry::parent_offset(), R1_SP);\n+  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ std(tmp2, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  __ st_ptr(tmp3, JavaThread::cont_entry_offset(), R16_thread);\n+  DEBUG_ONLY(__ block_comment(\"} clean\"));\n+}\n+\n+static void check_continuation_enter_argument(VMReg actual_vmreg,\n+                                              Register expected_reg,\n+                                              const char* name) {\n+  assert(!actual_vmreg->is_stack(), \"%s cannot be on stack\", name);\n+  assert(actual_vmreg->as_Register() == expected_reg,\n+         \"%s is in unexpected register: %s instead of %s\",\n+         name, actual_vmreg->as_Register()->name(), expected_reg->name());\n+}\n+\n+static void gen_continuation_enter(MacroAssembler* masm,\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& framesize_words,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n+\n+  \/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n+  int pos_cont_obj   = 0;\n+  int pos_is_cont    = 1;\n+  int pos_is_virtual = 2;\n+\n+  \/\/ The platform-specific calling convention may present the arguments in various registers.\n+  \/\/ To simplify the rest of the code, we expect the arguments to reside at these known\n+  \/\/ registers, and we additionally check the placement here in case calling convention ever\n+  \/\/ changes.\n+  Register reg_cont_obj   = R3_ARG1;\n+  Register reg_is_cont    = R4_ARG2;\n+  Register reg_is_virtual = R5_ARG3;\n+\n+  check_continuation_enter_argument(regs[pos_cont_obj].first(),   reg_cont_obj,   \"Continuation object\");\n+  check_continuation_enter_argument(regs[pos_is_cont].first(),    reg_is_cont,    \"isContinue\");\n+  check_continuation_enter_argument(regs[pos_is_virtual].first(), reg_is_virtual, \"isVirtualThread\");\n+\n+  address resolve_static_call = SharedRuntime::get_resolve_static_call_stub();\n+\n+  address start = __ pc();\n+\n+  Label L_thaw, L_exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ lwz(R0, in_bytes(JavaThread::interp_only_mode_offset()), R16_thread);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ bne(CCR0, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ld(reg_cont_obj,   Interpreter::stackElementSize*3, R15_esp);\n+    __ lwz(reg_is_cont,    Interpreter::stackElementSize*2, R15_esp);\n+    __ lwz(reg_is_virtual, Interpreter::stackElementSize*1, R15_esp);\n+\n+    __ push_cont_fastpath();\n+\n+    OopMap* map = continuation_enter_setup(masm, framesize_words);\n+\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+    \/\/ If isContinue, call to thaw. Otherwise, call Continuation.enter(Continuation c, boolean isContinue)\n+    __ cmpwi(CCR0, reg_is_cont, 0);\n+    __ bne(CCR0, L_thaw);\n+\n+    \/\/ --- call Continuation.enter(Continuation c, boolean isContinue)\n+\n+    \/\/ Emit compiled static call. The call will be always resolved to the c2i\n+    \/\/ entry of Continuation.enter(Continuation c, boolean isContinue).\n+    \/\/ There are special cases in SharedRuntime::resolve_static_call_C() and\n+    \/\/ SharedRuntime::resolve_sub_helper_internal() to achieve this\n+    \/\/ See also corresponding call below.\n+    address c2i_call_pc = __ pc();\n+    int start_offset = __ offset();\n+    \/\/ Put the entry point as a constant into the constant pool.\n+    const address entry_point_toc_addr   = __ address_constant(resolve_static_call, RelocationHolder::none);\n+    const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);\n+    guarantee(entry_point_toc_addr != nullptr, \"const section overflow\");\n+\n+    \/\/ Emit the trampoline stub which will be related to the branch-and-link below.\n+    address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset);\n+    guarantee(stub != nullptr, \"no space for trampoline stub\");\n+\n+    __ relocate(relocInfo::static_call_type);\n+    \/\/ Note: At this point we do not have the address of the trampoline\n+    \/\/ stub, and the entry point might be too far away for bl, so __ pc()\n+    \/\/ serves as dummy and the bl will be patched later.\n+    __ bl(__ pc());\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ b(L_exit);\n+\n+    \/\/ static stub for the call above\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, c2i_call_pc);\n+    guarantee(stub != nullptr, \"no space for static stub\");\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  OopMap* map = continuation_enter_setup(masm, framesize_words);\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+  frame_complete =__ pc() - start;\n+\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+  \/\/ If isContinue, call to thaw. Otherwise, call Continuation.enter(Continuation c, boolean isContinue)\n+  __ cmpwi(CCR0, reg_is_cont, 0);\n+  __ bne(CCR0, L_thaw);\n+\n+  \/\/ --- call Continuation.enter(Continuation c, boolean isContinue)\n+\n+  \/\/ Emit compiled static call\n+  \/\/ The call needs to be resolved. There's a special case for this in\n+  \/\/ SharedRuntime::find_callee_info_helper() which calls\n+  \/\/ LinkResolver::resolve_continuation_enter() which resolves the call to\n+  \/\/ Continuation.enter(Continuation c, boolean isContinue).\n+  address call_pc = __ pc();\n+  int start_offset = __ offset();\n+  \/\/ Put the entry point as a constant into the constant pool.\n+  const address entry_point_toc_addr   = __ address_constant(resolve_static_call, RelocationHolder::none);\n+  const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);\n+  guarantee(entry_point_toc_addr != nullptr, \"const section overflow\");\n+\n+  \/\/ Emit the trampoline stub which will be related to the branch-and-link below.\n+  address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset);\n+  guarantee(stub != nullptr, \"no space for trampoline stub\");\n+\n+  __ relocate(relocInfo::static_call_type);\n+  \/\/ Note: At this point we do not have the address of the trampoline\n+  \/\/ stub, and the entry point might be too far away for bl, so __ pc()\n+  \/\/ serves as dummy and the bl will be patched later.\n+  __ bl(__ pc());\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+  __ post_call_nop();\n+\n+  __ b(L_exit);\n+\n+  \/\/ --- Thawing path\n+\n+  __ bind(L_thaw);\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(StubRoutines::cont_thaw()));\n+  __ mtctr(R0);\n+  __ bctrl();\n+  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n+  ContinuationEntry::_return_pc_offset = __ pc() - start;\n+  __ post_call_nop();\n+\n+  \/\/ --- Normal exit (resolve\/thawing)\n+\n+  __ bind(L_exit);\n+  continuation_enter_cleanup(masm);\n+\n+  \/\/ Pop frame and return\n+  DEBUG_ONLY(__ ld_ptr(R0, 0, R1_SP));\n+  __ addi(R1_SP, R1_SP, framesize_words*wordSize);\n+  DEBUG_ONLY(__ cmpd(CCR0, R0, R1_SP));\n+  __ asm_assert_eq(FILE_AND_LINE \": inconsistent frame size\");\n+  __ ld(R0, _abi0(lr), R1_SP); \/\/ Return pc\n+  __ mtlr(R0);\n+  __ blr();\n+\n+  \/\/ --- Exception handling path\n+\n+  exception_offset = __ pc() - start;\n+\n+  continuation_enter_cleanup(masm);\n+  Register ex_pc  = R17_tos;   \/\/ nonvolatile register\n+  Register ex_oop = R15_esp;   \/\/ nonvolatile register\n+  __ ld(ex_pc, _abi0(callers_sp), R1_SP); \/\/ Load caller's return pc\n+  __ ld(ex_pc, _abi0(lr), ex_pc);\n+  __ mr(ex_oop, R3_RET);                  \/\/ save return value containing the exception oop\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, ex_pc);\n+  __ mtlr(R3_RET);                        \/\/ the exception handler\n+  __ ld(R1_SP, _abi0(callers_sp), R1_SP); \/\/ remove enterSpecial frame\n+\n+  \/\/ Continue at exception handler\n+  \/\/ See OptoRuntime::generate_exception_blob for register arguments\n+  __ mr(R3_ARG1, ex_oop); \/\/ pass exception oop\n+  __ mr(R4_ARG2, ex_pc);  \/\/ pass exception pc\n+  __ blr();\n+\n+  \/\/ static stub for the call above\n+  CodeBuffer* cbuf = masm->code_section()->outer();\n+  stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, call_pc);\n+  guarantee(stub != nullptr, \"no space for static stub\");\n+}\n+\n+static void gen_continuation_yield(MacroAssembler* masm,\n+                                   const VMRegPair* regs,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& framesize_words,\n+                                   int& compiled_entry_offset) {\n+  Register tmp = R10_ARG8;\n+\n+  const int framesize_bytes = (int)align_up((int)frame::abi_reg_args_size, frame::alignment_in_bytes);\n+  framesize_words = framesize_bytes \/ wordSize;\n+\n+  address start = __ pc();\n+  compiled_entry_offset = __ pc() - start;\n+\n+  \/\/ Save return pc and push entry frame\n+  __ mflr(tmp);\n+  __ std(tmp, _abi0(lr), R1_SP);       \/\/ SP->lr = return_pc\n+  __ push_frame(framesize_bytes , R0); \/\/ SP -= frame_size_in_bytes\n+\n+  DEBUG_ONLY(__ block_comment(\"Frame Complete\"));\n+  frame_complete = __ pc() - start;\n+  address last_java_pc = __ pc();\n+\n+  \/\/ This nop must be exactly at the PC we push into the frame info.\n+  \/\/ We use this nop for fast CodeBlob lookup, associate the OopMap\n+  \/\/ with it right away.\n+  __ post_call_nop();\n+  OopMap* map = new OopMap(framesize_bytes \/ VMRegImpl::stack_slot_size, 1);\n+  oop_maps->add_gc_map(last_java_pc - start, map);\n+\n+  __ calculate_address_from_global_toc(tmp, last_java_pc); \/\/ will be relocated\n+  __ set_last_Java_frame(R1_SP, tmp);\n+  __ call_VM_leaf(Continuation::freeze_entry(), R16_thread, R1_SP);\n+  __ reset_last_Java_frame();\n+\n+  Label L_pinned;\n+\n+  __ cmpdi(CCR0, R3_RET, 0);\n+  __ bne(CCR0, L_pinned);\n+\n+  \/\/ Pop frames of continuation including this stub's frame\n+  __ ld_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+  \/\/ The frame pushed by gen_continuation_enter is on top now again\n+  continuation_enter_cleanup(masm);\n+\n+  __ bind(L_pinned); \/\/ pinned -- return to caller\n+\n+  \/\/ Pop frame and return\n+  __ pop_frame();\n+  __ ld(R0, _abi0(lr), R1_SP); \/\/ Return pc\n+  __ mtlr(R0);\n+  __ blr();\n+}\n+\n@@ -1643,0 +2023,59 @@\n+  if (method->is_continuation_native_intrinsic()) {\n+    int exception_offset = -1;\n+    OopMapSet* oop_maps = new OopMapSet();\n+    int frame_complete = -1;\n+    int stack_slots = -1;\n+    int interpreted_entry_offset = -1;\n+    int vep_offset = -1;\n+    if (method->is_continuation_enter_intrinsic()) {\n+      gen_continuation_enter(masm,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      gen_continuation_yield(masm,\n+                             in_regs,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             vep_offset);\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n+\n+#ifdef ASSERT\n+    if (method->is_continuation_enter_intrinsic()) {\n+      assert(interpreted_entry_offset != -1, \"Must be set\");\n+      assert(exception_offset != -1,         \"Must be set\");\n+    } else {\n+      assert(interpreted_entry_offset == -1, \"Must be unset\");\n+      assert(exception_offset == -1,         \"Must be unset\");\n+    }\n+    assert(frame_complete != -1,    \"Must be set\");\n+    assert(stack_slots != -1,       \"Must be set\");\n+    assert(vep_offset != -1,        \"Must be set\");\n+#endif\n+\n+    __ flush();\n+    nmethod* nm = nmethod::new_native_nmethod(method,\n+                                              compile_id,\n+                                              masm->code(),\n+                                              vep_offset,\n+                                              frame_complete,\n+                                              stack_slots,\n+                                              in_ByteSize(-1),\n+                                              in_ByteSize(-1),\n+                                              oop_maps,\n+                                              exception_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      _cont_doYield_stub = nm;\n+    }\n+    return nm;\n+  }\n+\n@@ -2354,1 +2793,1 @@\n-  return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::alignment_in_bytes);\n+  return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::frame_alignment_in_words);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":440,"deletions":1,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+\/\/ Java frames don't have callee saved registers, so we can use a smaller RegisterMap\n@@ -35,3 +35,0 @@\n-private:\n-  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n@@ -45,1 +42,2 @@\n-    Unimplemented();\n+    map->clear();\n+    map->set_include_argument_oops(this->include_argument_oops());\n@@ -52,1 +50,8 @@\n-    Unimplemented();\n+#ifdef ASSERT\n+  for(int i = 0; i < RegisterMap::reg_count; i++) {\n+    VMReg r = VMRegImpl::as_VMReg(i);\n+    if (map->location(r, (intptr_t*)nullptr) != nullptr) {\n+      assert(false, \"Reg: %s\", r->name()); \/\/ Should not reach here\n+    }\n+  }\n+#endif\n@@ -56,2 +61,2 @@\n-    Unimplemented();\n-    return NULL;\n+    assert(false, \"Reg: %s\", reg->name());\n+    return nullptr;\n@@ -60,1 +65,2 @@\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+  \/\/ Should not reach here\n+  inline void set_location(VMReg reg, address loc) { assert(false, \"Reg: %s\", reg->name()); }\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,2 +35,6 @@\n-  Unimplemented();\n-  return true;\n+  assert(!is_done(), \"\");\n+  assert(is_compiled(), \"\");\n+  intptr_t* p = (intptr_t*)p0;\n+  int argsize = (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  int frame_size = _cb->frame_size() + (argsize > 0 ? argsize + frame::metadata_words_at_top : 0);\n+  return (p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size;\n@@ -42,2 +46,6 @@\n-  Unimplemented();\n-  return frame();\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    \/\/ Compiled frames on heap don't have back links. See FreezeBase::patch_pd() and frame::setup().\n+    return frame(sp(), unextended_sp(), Interpreter::contains(pc()) ? fp() : nullptr, pc(), cb(), _oopmap, true);\n+  }\n@@ -48,2 +56,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert(!is_done(), \"\");\n+  return (address)((frame::abi_minframe*) _sp)->lr;\n@@ -54,2 +62,6 @@\n-  Unimplemented();\n-  return NULL;\n+  \/\/ See FreezeBase::patch_pd() and frame::setup()\n+  assert((frame_kind == ChunkFrames::Mixed && is_interpreted()), \"\");\n+  intptr_t* fp_addr = (intptr_t*)&((frame::abi_minframe*)_sp)->callers_sp;\n+  assert(*(intptr_t**)fp_addr != nullptr, \"\");\n+  \/\/ derelativize\n+  return fp_addr + *fp_addr;\n@@ -60,2 +72,3 @@\n-  Unimplemented();\n-  return NULL;\n+  intptr_t* fp = this->fp();\n+  assert(fp != nullptr, \"\");\n+  return fp + fp[offset];\n@@ -66,2 +79,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  return derelativize(ijava_idx(esp)) + 1 - frame::metadata_words; \/\/ On PPC esp points to the next free slot\n@@ -78,1 +91,8 @@\n-  Unimplemented();\n+  assert_is_interpreted_and_frame_type_mixed();\n+  if (derelativize(ijava_idx(locals)) + 1 >= _end) {\n+    _unextended_sp = _end;\n+    _sp = _end;\n+  } else {\n+    _unextended_sp = derelativize(ijava_idx(sender_sp));\n+    _sp = this->fp();\n+  }\n@@ -81,0 +101,60 @@\n+\/\/ Details for the comment on StackChunkFrameStream<frame_kind>::frame_size()\n+\/\/\n+\/\/ Interpreted caller frames get extended even if the callee is also\n+\/\/ interpreted. This is done to accomodate non-parameter locals.\n+\/\/\n+\/\/ The size of a single frame is from the unextended sp to the bottom of the\n+\/\/ locals array. The combined size of caller\/callee is the single size with the\n+\/\/ overlap deducted. The overlap is the size of the call parameters plus the\n+\/\/ size of the metadata at the sp (frame::metadata_words_at_top).\n+\/\/\n+\/\/\n+\/\/ Case 1: no metadata between a frame                      Case 2: metadata is located between\n+\/\/         and its locals                                           a frame and its locals as on ppc64\n+\/\/\n+\/\/       |  | L0 aka P0            |                    |  | L0 aka P0            |\n+\/\/       |  | :      :             |                    |  | :      :             |\n+\/\/       |  | :      Pn            |                    |  | :      Pn            |\n+\/\/       |  | :                    |                    |  | :                    |\n+\/\/       |  | Lm                   |                    |  | Lm                   |\n+\/\/       |  ========================                    |  |----------------------|\n+\/\/    S0 |  | Frame F0             |                    |  | Metadata@top         |\n+\/\/       |  |                      |                 S0 |  |                      |\n+\/\/       |  |                      |                    |  |                      |\n+\/\/       |  |----------------------|                    |  |                      |\n+\/\/       || | L0 aka P0            |                    |  ========================\n+\/\/ over- || | :      :             |                    |  | Frame F0             |\n+\/\/ lap   || | :      Pn            |<- unext. SP        |  |                      |\n+\/\/        | | :                    |                    |  |                      |<- bottom_of_locals\n+\/\/        | | Lm                   |<- SP               |  |----------------------|\n+\/\/        | ========================                    || | L0 aka P0            |\n+\/\/        | | Frame F1             |                    || | :      :             |\n+\/\/     S1 | |                      |              over- || | :      Pn            |<- unext. SP\n+\/\/        | |                      |              lap   || | :                    |   + metadata_words_at_top\n+\/\/        | |----------------------|                    || | Lm                   |\n+\/\/        | | L0 aka P0            |                    || |----------------------|\n+\/\/        | | :      :             |                    || | Metadata@top         |\n+\/\/        | | :      Pn            |<- unext. SP        || |                      |<- unextended SP\n+\/\/          | :                    |                     | |                      |\n+\/\/          | Lm                   |<- SP                | |                      |<- SP\n+\/\/          ========================                     | ========================\n+\/\/                                                       | | Frame F1             |\n+\/\/                                                       | |                      |\n+\/\/                                                       | |                      |\n+\/\/                                                       | |----------------------|\n+\/\/    overlap = size of stackargs                     S1 | | L0 aka P0            |\n+\/\/                                                       | | :      :             |\n+\/\/                                                       | | :      Pn            |<- unext. SP\n+\/\/                                                       | | :                    |   + metadata_words_at_top\n+\/\/                                                       | | Lm                   |\n+\/\/                                                       | |----------------------|\n+\/\/                                                       | | Metadata@top         |\n+\/\/                                                       | |                      |<- unextended SP\n+\/\/                                                         |                      |\n+\/\/                                                         |                      |<- SP\n+\/\/                                                         ========================\n+\/\/\n+\/\/                                           sizeof(Metadata@top) = frame::metadata_words_at_top\n+\/\/                                           bottom_of_locals = unext. sp + sizeof(Metadata@top) + stackargs\n+\/\/                                           overlap = bottom_of_locals - unext. sp\n+\/\/                                                   = stackargs + sizeof(Metadata@top)\n@@ -83,2 +163,4 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n+  intptr_t* bottom = derelativize(ijava_idx(locals)) + 1;\n+  return (int)(bottom - top);\n@@ -87,0 +169,4 @@\n+\/\/ Size of stack args in words (P0..Pn above). Only valid if the caller is also\n+\/\/ interpreted. The function is also called if the caller is compiled but the\n+\/\/ result is not used in that case (same on x86).\n+\/\/ See also setting of sender_sp in ContinuationHelper::InterpretedFrame::patch_sender_sp()\n@@ -89,2 +175,7 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  frame::ijava_state* state = (frame::ijava_state*)((uintptr_t)fp() - frame::ijava_state_size);\n+  int diff = (int)(state->locals - (state->sender_sp + frame::metadata_words_at_top) + 1);\n+  assert(diff == -frame::metadata_words_at_top || ((Method*)state->method)->size_of_parameters() == diff,\n+         \"size_of_parameters(): %d diff: %d sp: \" PTR_FORMAT \" fp:\" PTR_FORMAT,\n+         ((Method*)state->method)->size_of_parameters(), diff, p2i(sp()), p2i(fp()));\n+  return diff;\n@@ -95,2 +186,9 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  ResourceMark rm;\n+  InterpreterOopMap mask;\n+  frame f = to_frame();\n+  f.interpreted_frame_oop_map(&mask);\n+  return  mask.num_oops()\n+        + 1 \/\/ for the mirror oop\n+        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n+            - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n@@ -102,1 +200,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do (no non-volatile registers in java calling convention)\n@@ -108,1 +206,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do (no non-volatile registers in java calling convention)\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":119,"deletions":21,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/frame.inline.hpp\"\n+\n@@ -29,1 +31,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_offset_fp(relativize_address(fr.fp()));\n+  }\n@@ -33,1 +37,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_fp(derelativize_address(fr.offset_fp()));\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkOop_ppc.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -326,0 +328,1 @@\n+      __ pop_cont_fastpath();\n@@ -4504,1 +4507,1 @@\n-  address generate_cont_thaw() {\n+  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n@@ -4506,2 +4509,83 @@\n-    Unimplemented();\n-    return nullptr;\n+\n+    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n+    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+\n+    StubCodeMark mark(this, \"StubRoutines\", label);\n+\n+    Register tmp1 = R10_ARG8;\n+    Register tmp2 = R9_ARG7;\n+    Register tmp3 = R8_ARG6;\n+    Register nvtmp = R15_esp;   \/\/ nonvolatile tmp register\n+    FloatRegister nvftmp = F20; \/\/ nonvolatile fp tmp register\n+\n+    address start = __ pc();\n+\n+    if (return_barrier) {\n+      __ mr(nvtmp, R3_RET); __ fmr(nvftmp, F1_RET); \/\/ preserve possible return value from a method returning to the return barrier\n+      DEBUG_ONLY(__ ld_ptr(tmp1, _abi0(callers_sp), R1_SP);)\n+      __ ld_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+#ifdef ASSERT\n+      __ ld_ptr(tmp2, _abi0(callers_sp), R1_SP);\n+      __ cmpd(CCR0, tmp1, tmp2);\n+      __ asm_assert_eq(FILE_AND_LINE \": callers sp is corrupt\");\n+#endif\n+    }\n+#ifdef ASSERT\n+    __ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread);\n+    __ cmpd(CCR0, R1_SP, tmp1);\n+    __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+    __ li(R4_ARG2, return_barrier ? 1 : 0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), R16_thread, R4_ARG2);\n+\n+#ifdef ASSERT\n+    DEBUG_ONLY(__ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread));\n+    DEBUG_ONLY(__ cmpd(CCR0, R1_SP, tmp1));\n+    __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+    \/\/ R3_RET contains the size of the frames to thaw, 0 if overflow or no more frames\n+    Label thaw_success;\n+    __ cmpdi(CCR0, R3_RET, 0);\n+    __ bne(CCR0, thaw_success);\n+    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ mtctr(tmp1); __ bctr();\n+    __ bind(thaw_success);\n+\n+    __ addi(R3_RET, R3_RET, frame::abi_reg_args_size); \/\/ Large abi required for C++ calls.\n+    __ neg(R3_RET, R3_RET);\n+    \/\/ align down resulting in a smaller negative offset\n+    __ clrrdi(R3_RET, R3_RET, exact_log2(frame::alignment_in_bytes));\n+    DEBUG_ONLY(__ mr(tmp1, R1_SP);)\n+    __ resize_frame(R3_RET, tmp2);  \/\/ make room for the thawed frames\n+\n+    __ li(R4_ARG2, kind);\n+    __ call_VM_leaf(Continuation::thaw_entry(), R16_thread, R4_ARG2);\n+    __ mr(R1_SP, R3_RET); \/\/ R3_RET contains the SP of the thawed top frame\n+\n+    if (return_barrier) {\n+      \/\/ we're now in the caller of the frame that returned to the barrier\n+      __ mr(R3_RET, nvtmp); __ fmr(F1_RET, nvftmp); \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+    } else {\n+      \/\/ we're now on the yield frame (which is in an address above us b\/c rsp has been pushed down)\n+      __ li(R3_RET, 0); \/\/ return 0 (success) from doYield\n+    }\n+\n+    if (return_barrier_exception) {\n+      Register ex_pc = R17_tos;   \/\/ nonvolatile register\n+      __ ld(ex_pc, _abi0(lr), R1_SP); \/\/ LR\n+      __ mr(nvtmp, R3_RET); \/\/ save return value containing the exception oop\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, ex_pc);\n+      __ mtlr(R3_RET); \/\/ the exception handler\n+      \/\/ See OptoRuntime::generate_exception_blob for register arguments\n+      __ mr(R3_ARG1, nvtmp); \/\/ exception oop\n+      __ mr(R4_ARG2, ex_pc); \/\/ exception pc\n+    } else {\n+      \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n+      __ ld(R0, _abi0(lr), R1_SP); \/\/ LR\n+      __ mtlr(R0);\n+    }\n+    __ blr();\n+\n+    return start;\n@@ -4510,0 +4594,6 @@\n+  address generate_cont_thaw() {\n+    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+  }\n+\n+  \/\/ TODO: will probably need multiple return barriers depending on return type\n+\n@@ -4511,3 +4601,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n+    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n@@ -4517,3 +4605,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n+    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n@@ -4528,0 +4614,3 @@\n+    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n+\n@@ -4530,6 +4619,0 @@\n-    int insts_size = 512;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n@@ -4560,0 +4643,1 @@\n+    OopMapSet* oop_maps = new OopMapSet();\n@@ -4564,1 +4648,2 @@\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code, frame_complete,\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":101,"deletions":16,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -634,3 +634,1 @@\n-  __ restore_interpreter_state(R11_scratch1); \/\/ Sets R11_scratch1 = fp.\n-  __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-  __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+  __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -705,0 +703,1 @@\n+  __ push_cont_fastpath();\n@@ -706,0 +705,1 @@\n+  __ pop_cont_fastpath();\n@@ -1946,3 +1946,1 @@\n-    __ restore_interpreter_state(R11_scratch1); \/\/ Sets R11_scratch1 = fp.\n-    __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-    __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+    __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -2039,0 +2037,1 @@\n+    __ pop_cont_fastpath();\n@@ -2050,3 +2049,2 @@\n-    __ restore_interpreter_state(R11_scratch1);\n-    __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-    __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+    __ pop_cont_fastpath();\n+    __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -2111,0 +2109,1 @@\n+    __ pop_cont_fastpath();\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2149,0 +2149,1 @@\n+    __ push_cont_fastpath();\n@@ -2150,0 +2151,1 @@\n+    __ pop_cont_fastpath();\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n+#define CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -95,0 +95,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_CONTINUATIONENTRY_S390_HPP\n+#define CPU_S390_CONTINUATIONENTRY_S390_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_S390_CONTINUATIONENTRY_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/continuationEntry_s390.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -548,3 +548,5 @@\n-    pc_return_offset =  0,\n-    metadata_words   = 0,\n-    frame_alignment  = 16,\n+    pc_return_offset         = 0,\n+    metadata_words           = 0,\n+    metadata_words_at_bottom = 0,\n+    metadata_words_at_top    = 0,\n+    frame_alignment          = 16,\n@@ -552,1 +554,1 @@\n-    align_wiggle     =  1\n+    align_wiggle             =  1\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_CONTINUATIONENTRY_X86_HPP\n+#define CPU_X86_CONTINUATIONENTRY_X86_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_X86_CONTINUATIONENTRY_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -196,0 +196,6 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  \/\/ Fast path depends on !PreserveFramePointer. See can_thaw_fast().\n+  assert(!PreserveFramePointer, \"Frame pointers need to be fixed\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -100,1 +100,9 @@\n-    \/\/ compiled frame alignment, in bytes\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n+    \/\/ size, in words, of frame metadata at the frame top that needs\n+    \/\/ to be reserved for callee functions in the runtime\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n+#define CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/continuationEntry_zero.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,39 +53,45 @@\n-                   +-------------------+\n-                   |                   |\n-                   |  oop bitmap       |\n-                   |                   |\n-                   | ----------------- |\n-                   |                   |\n-                   |  [empty]          |\n-                   |                   |\n-                  -|===================|\n-                \/  |                   |\n-               |   | caller stack args |  argsize\n-               |   |                   |  words\n-               |   | ----------------- |\n-               |   |                   |\n-         ^     |   | frame             |\n-         |     |   |                   |\n-         |   size  | ----------------- |\n-         |   words |                   |\n-         |     |   | frame             |\n-         |     |   |                   |\n- Address |     |   | ----------------- |\n-         |     |   |                   |\n-         |     |   | frame             |\n-         |     |   |                   |\n-         |     |   | callee stack args |\n-         |     |   | ----------------- |<--\\\n-         |     |   | pc                |   |\n-         |     |   | rbp               |   |\n-         |     |   |                   |   |\n-         |     |   | [empty]           |   |\n-         |     \\   |                   |   |\n-                 - |===================|   |\n-                   | int maxSize       |   |\n-                   | long pc           |   |\n-            header | byte flags        |   |\n-                   | int argsize       |   |\n-                   | int sp            +---\/\n-                   | int size          |\n-                   +-------------------+\n+                   +--------------------------------+\n+                   |                                |\n+                   |  oop bitmap                    |\n+                   |                                |\n+                   | ------------------------------ |\n+                   |                                |\n+                   |  [empty]                       |\n+                   |                                |\n+                  -|================================|\n+                \/  |                                |\n+               |   | caller stack args              |   argsize\n+               |   | [metadata at frame top (1)]    | + frame::metadata_words_at_top\n+               |   | ------------------------------ |   words\n+               |   | [metadata at frame bottom (2)] |\n+         ^     |   | frame                          |\n+         |     |   |                                |\n+         |   size  | ------------------------------ |\n+         |   words |                                |\n+         |     |   | frame                          |\n+         |     |   |                                |\n+ Address |     |   | ------------------------------ |\n+         |     |   |                                |\n+         |     |   | frame                          |\n+         |     |   |                                |\n+         |     |   | callee stack args              |\n+         |     |   | [metadata at frame top (1)]    |<--\\\n+         |     |   | ------------------------------ |   |\n+         |     |   | [metadata at frame bottom (2)  |   |\n+         |     |   |  i.e. rbp, pc]                 |   |\n+         |     |   |                                |   |\n+         |     |   | [empty]                        |   |\n+         |     \\   |                                |   |\n+                 - |================================|   |\n+                   | int maxSize                    |   |\n+                   | long pc                        |   |\n+            header | byte flags                     |   |\n+                   | int argsize                    |   |\n+                   | int sp                         +---\/\n+                   | int size                       |\n+                   +--------------------------------+\n+\n+ (1) Metadata at frame top (see frame::metadata_words_at_top)\n+     Used on ppc64, empty on x86_64, aarch64\n+ (2) Metadata at the frame bottom (see frame::metadata_words_at_bottom)\n+     Used on x86_64 (saved rbp, ret.addr.), aarch64, empty on ppc64\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.hpp","additions":45,"deletions":39,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    intptr_t* start = chunk->sp_address() - frame::metadata_words;\n+    intptr_t* start = chunk->sp_address() - frame::metadata_words_at_bottom;\n@@ -126,1 +126,1 @@\n-    oop_oop_iterate_stack_with_bitmap<T>(chunk, closure, chunk->sp_address() - frame::metadata_words, chunk->end_address());\n+    oop_oop_iterate_stack_with_bitmap<T>(chunk, closure, chunk->sp_address() - frame::metadata_words_at_bottom, chunk->end_address());\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-    _argsize   = f.stack_argsize();\n+    _argsize   = f.stack_argsize() + frame::metadata_words_at_top;\n@@ -605,1 +605,1 @@\n-    assert(argsize() == closure._argsize,\n+    assert(argsize() == closure._argsize - (closure._num_frames > 0 ? frame::metadata_words_at_top : 0),\n@@ -636,1 +636,1 @@\n-                       bit_index_for((narrowOop*)(sp_address() - frame::metadata_words)),\n+                       bit_index_for((narrowOop*)(sp_address() - frame::metadata_words_at_bottom)),\n@@ -642,1 +642,1 @@\n-                       bit_index_for((oop*)(sp_address() - frame::metadata_words)),\n+                       bit_index_for((oop*)(sp_address() - frame::metadata_words_at_bottom)),\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize(); }\n+inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize() - frame::metadata_words_at_top; }\n@@ -126,1 +126,1 @@\n-  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize()),\n+  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize() - frame::metadata_words_at_top),\n@@ -138,2 +138,2 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n-  HeapWord* start = (HeapWord*)start_address() + sp() - frame::sender_sp_offset;\n+#if (defined(X86) || defined(AARCH64) || defined(PPC64)) && !defined(ZERO)\n+  HeapWord* start = (HeapWord*)start_address() + sp() - frame::metadata_words_at_bottom;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n+#if (defined(X86) || defined(AARCH64) || defined(PPC64)) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include CPU_HEADER(continuationEntry)\n+\n@@ -40,0 +42,1 @@\n+  ContinuationEntryPD _pd;\n@@ -69,0 +72,2 @@\n+  \/\/ Size in words of the stack arguments of the bottom frame on stack if compiled 0 otherwise.\n+  \/\/ The caller (if there is one) is the still frozen top frame in the StackChunk.\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,3 @@\n-  intptr_t* sp = entry_sp() - argsize();\n+  \/\/ the entry frame is extended if the bottom frame has stack arguments\n+  int entry_frame_extension = argsize() > 0 ? argsize() + frame::metadata_words_at_top : 0;\n+  intptr_t* sp = entry_sp() - entry_frame_extension;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-    return chunk->sp() >= chunk->stack_size() - chunk->argsize();\n+    return chunk->sp() >= chunk->stack_size() - chunk->argsize() - frame::metadata_words_at_top;\n@@ -471,1 +471,1 @@\n-  _bottom_address = _cont.entrySP() - _cont.argsize();\n+  _bottom_address = _cont.entrySP() - _cont.entry_frame_extension();\n@@ -487,1 +487,2 @@\n-  static const int doYield_stub_frame_size = frame::metadata_words;\n+  static const int doYield_stub_frame_size = NOT_PPC64(frame::metadata_words)\n+                                             PPC64_ONLY(frame::abi_reg_args_size >> LogBytesPerWord);\n@@ -492,1 +493,2 @@\n-  _cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+  _cont_stack_bottom = _cont.entrySP() + (_cont.argsize() == 0 ? frame::metadata_words_at_top : 0)\n+      - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n@@ -557,2 +559,0 @@\n-  assert(SharedRuntime::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n-\n@@ -560,1 +560,0 @@\n-\n@@ -568,1 +567,1 @@\n-    total_size_needed -= _cont.argsize();\n+    total_size_needed -= _cont.argsize() + frame::metadata_words_at_top;\n@@ -571,1 +570,1 @@\n-  int chunk_free_room = chunk_sp - frame::metadata_words;\n+  int chunk_free_room = chunk_sp - frame::metadata_words_at_bottom;\n@@ -591,1 +590,2 @@\n-    const int chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    const int chunk_start_sp = chunk->sp() + _cont.argsize() + frame::metadata_words_at_top;\n@@ -595,1 +595,1 @@\n-    chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size() - _cont.argsize());\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size() - _cont.argsize() - frame::metadata_words_at_top);\n@@ -597,1 +597,1 @@\n-    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize();\n+    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize() - frame::metadata_words_at_top;\n@@ -674,3 +674,3 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words;\n-  intptr_t* to   = chunk_top - frame::metadata_words;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words);\n+  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n+  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n+  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n@@ -680,1 +680,1 @@\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize();\n+  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize() - frame::metadata_words_at_top;\n@@ -786,0 +786,1 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n@@ -815,0 +816,2 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n@@ -863,1 +866,4 @@\n-freeze_result FreezeBase::finalize_freeze(const frame& callee, frame& caller, int argsize) {\n+\/\/ The parameter argsize_md includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n+freeze_result FreezeBase::finalize_freeze(const frame& callee, frame& caller, int argsize_md) {\n+  int argsize = argsize_md - frame::metadata_words_at_top;\n@@ -892,1 +898,1 @@\n-        overlap = argsize;\n+        overlap = argsize_md;\n@@ -939,1 +945,1 @@\n-    int sp = chunk->stack_size() - argsize;\n+    int sp = chunk->stack_size() - argsize_md;\n@@ -947,1 +953,1 @@\n-      int sp = chunk->stack_size() - argsize;\n+      int sp = chunk->stack_size() - argsize_md;\n@@ -980,1 +986,2 @@\n-  DEBUG_ONLY(_last_write = caller.unextended_sp() + (empty_chunk ? argsize : overlap);)\n+  DEBUG_ONLY(_last_write = caller.unextended_sp() + (empty_chunk ? argsize_md : overlap);)\n+\n@@ -1017,1 +1024,1 @@\n-    ContinuationHelper::InterpretedFrame::patch_sender_sp(hf, caller.unextended_sp());\n+    ContinuationHelper::InterpretedFrame::patch_sender_sp(hf, caller);\n@@ -1042,0 +1049,2 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n@@ -1043,1 +1052,1 @@\n-                                                                    int callee_argsize,\n+                                                                    int callee_argsize \/* incl. metadata *\/,\n@@ -1058,1 +1067,2 @@\n-  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f);\n+  \/\/ including metadata between f and its args\n+  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f) + frame::metadata_words_at_top;\n@@ -1076,1 +1086,1 @@\n-  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n+  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment on AArch64\/PPC64\n@@ -1101,1 +1111,5 @@\n-freeze_result FreezeBase::recurse_freeze_compiled_frame(frame& f, frame& caller, int callee_argsize, bool callee_interpreted) {\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n+freeze_result FreezeBase::recurse_freeze_compiled_frame(frame& f, frame& caller,\n+                                                        int callee_argsize \/* incl. metadata *\/,\n+                                                        bool callee_interpreted) {\n@@ -1105,1 +1119,2 @@\n-  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f);\n+  \/\/ including metadata between f and its stackargs\n+  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n@@ -1665,0 +1680,1 @@\n+  inline void patch_caller_links(intptr_t* sp, intptr_t* bottom);\n@@ -1687,1 +1703,2 @@\n-  ReconstructedStack(intptr_t* base, int thaw_size, int argsize) : _base(base), _thaw_size(thaw_size), _argsize(argsize) {\n+  ReconstructedStack(intptr_t* base, int thaw_size, int argsize)\n+  : _base(base), _thaw_size(thaw_size - (argsize == 0 ? frame::metadata_words_at_top : 0)), _argsize(argsize) {\n@@ -1691,1 +1708,1 @@\n-    assert(_base - 1 <= top() + total_size() + frame::metadata_words, \"missed entry frame\");\n+    assert(_base - 1 <= top() + total_size() + frame::metadata_words_at_bottom, \"missed entry frame\");\n@@ -1696,0 +1713,1 @@\n+  int entry_frame_extension() const { return _argsize + (_argsize > 0 ? frame::metadata_words_at_top : 0); }\n@@ -1699,1 +1717,1 @@\n-  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - _argsize); }\n+  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - entry_frame_extension()); }\n@@ -1703,2 +1721,2 @@\n-  intptr_t* top() const { return sp() - frame::metadata_words;  }\n-  int total_size() const { return _thaw_size + frame::metadata_words; }\n+  intptr_t* top() const { return sp() - frame::metadata_words_at_bottom;  }\n+  int total_size() const { return _thaw_size + frame::metadata_words_at_bottom; }\n@@ -1739,1 +1757,1 @@\n-  return frame_size + argsize;\n+  return frame_size + argsize + frame::metadata_words_at_top;\n@@ -1800,2 +1818,2 @@\n-  log_develop_trace(continuations)(\"thaw_fast partial: %d is_last: %d empty: %d size: %d argsize: %d\",\n-                              partial, is_last, empty, thaw_size, argsize);\n+  log_develop_trace(continuations)(\"thaw_fast partial: %d is_last: %d empty: %d size: %d argsize: %d entrySP: \" PTR_FORMAT,\n+                              partial, is_last, empty, thaw_size, argsize, p2i(_cont.entrySP()));\n@@ -1805,2 +1823,2 @@\n-  \/\/ also copy metadata words\n-  copy_from_chunk(chunk_sp - frame::metadata_words, rs.top(), rs.total_size());\n+  \/\/ also copy metadata words at frame bottom\n+  copy_from_chunk(chunk_sp - frame::metadata_words_at_bottom, rs.top(), rs.total_size());\n@@ -1816,0 +1834,3 @@\n+  \/\/ insert the back links from callee to caller frames\n+  patch_caller_links(rs.top(), rs.top() + rs.total_size());\n+\n@@ -2002,1 +2023,1 @@\n-    ContinuationHelper::InterpretedFrame::patch_sender_sp(f, caller.unextended_sp());\n+    ContinuationHelper::InterpretedFrame::patch_sender_sp(f, caller);\n@@ -2033,1 +2054,1 @@\n-  intptr_t* const stack_frame_top = f.sp();\n+  intptr_t* const stack_frame_top = f.sp() + frame::metadata_words_at_top;\n@@ -2035,1 +2056,1 @@\n-  intptr_t* const heap_frame_top = hf.unextended_sp();\n+  intptr_t* const heap_frame_top = hf.unextended_sp() + frame::metadata_words_at_top;\n@@ -2044,1 +2065,1 @@\n-  \/\/ on AArch64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n+  \/\/ on AArch64\/PPC64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n@@ -2104,3 +2125,4 @@\n-  intptr_t* from = heap_frame_top - frame::metadata_words;\n-  intptr_t* to   = stack_frame_top - frame::metadata_words;\n-  int sz = fsize + frame::metadata_words;\n+  intptr_t* from = heap_frame_top - frame::metadata_words_at_bottom;\n+  intptr_t* to   = stack_frame_top - frame::metadata_words_at_bottom;\n+  \/\/ copy metadata, except the metadata at the top of the (unextended) entry frame\n+  int sz = fsize + frame::metadata_words_at_bottom + (is_bottom_frame && added_argsize == 0 ? 0 : frame::metadata_words_at_top);\n@@ -2140,1 +2162,1 @@\n-    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf), added_argsize);\n+    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top, added_argsize);\n@@ -2213,1 +2235,1 @@\n-  if ((intptr_t)f.sp() % frame::frame_alignment != 0) {\n+  if (!is_aligned(f.sp(), frame::frame_alignment)) {\n@@ -2215,1 +2237,1 @@\n-    f.set_sp(f.sp() - 1);\n+    f.set_sp(align_down(f.sp(), frame::frame_alignment));\n@@ -2243,1 +2265,1 @@\n-  assert(f.sp() - frame::metadata_words >= _top_stack_address, \"overwrote past thawing space\"\n+  assert(f.sp() - frame::metadata_words_at_bottom >= _top_stack_address, \"overwrote past thawing space\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":70,"deletions":48,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  static void patch_sender_sp(frame& f, intptr_t* sp);\n+  static void patch_sender_sp(frame& f, const frame& caller);\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,5 @@\n+  int entry_frame_extension() const {\n+    \/\/ the entry frame is extended if the bottom frame has stack arguments\n+    assert(_entry->argsize() >= 0, \"\");\n+    return _entry->argsize() == 0 ? _entry->argsize() : _entry->argsize() + frame::metadata_words_at_top;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1632,1 +1632,8 @@\n-          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))) {\n+#if !defined(PPC64)\n+          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))\n+#else  \/\/ !defined(PPC64)\n+          && (strcmp(fv.description, \"sender_sp\") == 0 || strcmp(fv.description, \"top_frame_sp\") == 0 ||\n+              strcmp(fv.description, \"esp\") == 0 || strcmp(fv.description, \"monitors\") == 0 ||\n+              strcmp(fv.description, \"locals\") == 0 || strstr(fv.description, \" method \"))\n+#endif \/\/!defined(PPC64)\n+          ) {\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3123,1 +3123,1 @@\n-        buffer.initialize_stubs_size(128);\n+        buffer.initialize_stubs_size(128 PPC64_ONLY(+ 32));\n@@ -3129,1 +3129,1 @@\n-#if defined(AARCH64)\n+#if defined(AARCH64) || defined(PPC64)\n@@ -3133,1 +3133,5 @@\n-      buffer.initialize_consts_size(8);\n+      \/\/ On PPC64 the continuation enter intrinsic needs the constant pool for the compiled\n+      \/\/ static java call that is resolved in the runtime.\n+      if (PPC64_ONLY(method->is_continuation_enter_intrinsic() &&) true) {\n+        buffer.initialize_consts_size(8 PPC64_ONLY(+ 24));\n+      }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,0 +126,50 @@\n+\/\/ StackChunkFrameStream<frame_kind>::frame_size() returns the words required to\n+\/\/ store the given frame as the only frame in a StackChunk. This is the size of the\n+\/\/ frame itself plus its stack arguments plus metadata at the caller's frame top (1)\n+\/\/\n+\/\/ |====================|          ---\n+\/\/ | F0's stackargs     |           ^\n+\/\/ |                    |           |\n+\/\/ |--------------------|           |\n+\/\/ | metadata@top       | <- caller's sp\n+\/\/ |====================|           |\n+\/\/ | metadata@bottom(2) |           |\n+\/\/ |--------------------|\n+\/\/ |                    |       size S0\n+\/\/ | Frame F0           |                 ---     |====================|          ---\n+\/\/ |                    |           |      ^      | F1's stackargs     |           ^\n+\/\/ |                    |           |      |      |                    |           |\n+\/\/ |--------------------|           |   overlap   |--------------------|           |\n+\/\/ | metadata@top(1)    |<- sp      v      v      | metadata@top       | <- caller's sp\n+\/\/ |====================|          ---    ---     |====================|           |\n+\/\/                                                | metadata@bottom    |           |\n+\/\/           |                                    |--------------------|\n+\/\/           |                                    | Frame F1           |       size S1\n+\/\/      Stack Growth                              | (F0's callee)      |\n+\/\/           |                                    |                    |           |\n+\/\/           |                                    |                    |           |\n+\/\/           v                                    |--------------------|           |\n+\/\/                                                | metadata@top       |<- sp      v\n+\/\/                                                |====================|          ---\n+\/\/\n+\/\/ 2 frames of the same kind (interpreted or compiled) overlap. So the total\n+\/\/ size required in the StackChunk is S0 + S1 - overlap, where the overlap is\n+\/\/ the size of F1's stackargs plus frame::metadata_words_at_top.\n+\/\/\n+\/\/ The callers of frame_size() are supposed to deduct the overlap.  The bottom\n+\/\/ frame in the StackChunk obviously does not overlap with it's caller, as it is\n+\/\/ in the parent chunk.\n+\/\/\n+\/\/ There is no overlap if caller\/callee are of different kinds. In that case the\n+\/\/ caller is extended to accomodate the callee's stack arguments. The extension\n+\/\/ is not counted though in the caller's size, so there is indeed no overlap.\n+\/\/\n+\/\/ See ppc implementation of StackChunkFrameStream<frame_kind>::interpreter_frame_size()\n+\/\/ for more details.\n+\/\/\n+\/\/ (1) Metadata at frame top (see frame::metadata_words_at_top)\n+\/\/     Part of the overlap. Used on ppc64, empty on x86_64, aarch64\n+\/\/ (2) Metadata at the frame bottom (see frame::metadata_words_at_bottom)\n+\/\/     Not part of the overlap.\n+\/\/     Used on x86_64 (saved rbp, ret. addr.), aarch64. Empty on ppc64.\n+\/\/\n@@ -129,1 +179,1 @@\n-                          : cb()->frame_size() + stack_argsize();\n+                          : cb()->frame_size() + stack_argsize() + frame::metadata_words_at_top;\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,976 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=all-policies-no-system-gc\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 0 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-1-gc-after-yield\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 1 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-2-gc-after-yield\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 2 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-3-gc-after-yield\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 3 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-4-gc-after-yield\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 4 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-5-gc-after-yield\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExp 5 1\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationScope;\n+import static jdk.test.lib.Asserts.*;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class BasicExp {\n+    static final ContinuationScope THE_SCOPE = new ContinuationScope() {};\n+\n+    public static final Pattern COMP_NONE  = Pattern.compile(\"COMP_NONE\");\n+    public static final Pattern COMP_ALL   = Pattern.compile(\"COMP_ALL\");\n+    public static final Pattern CONT_METHS = Pattern.compile(\"^(enter|enter0|yield|yield0)$\");\n+\n+    public static int compPolicySelection;\n+    public static boolean callSystemGC;\n+    public static int compLevel;\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    enum TestCaseVariants {\n+        NO_VARIANT,\n+        \/\/ Exception\n+        THROW_HANDLED_EXCEPTION,\n+        THROW_UNHANDLED_EXCEPTION,\n+        \/\/ Synchronization\n+        ALLOC_MONITOR,\n+        \/\/ There are values on the expression stack that are not call parameters\n+        EXPR_STACK_NOT_EMPTY,\n+    }\n+\n+    public static class HandledException extends Exception { }\n+    public static class UnhandledException extends Error { }\n+\n+    public static void main(String[] args) {\n+        try {\n+            \/\/ Run tests with C2 compilations\n+            compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+            \/\/ \/\/ Run tests with C1 compilations\n+            \/\/ compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_PROFILE;\n+\n+            compPolicySelection =  Integer.parseInt(args[0]);\n+            callSystemGC = Integer.parseInt(args[1]) == 1;\n+            runTests();\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+    }\n+\n+    public static void runTests() {\n+        \/\/ TODO: enable\n+        System.out.println(\"$$$0 Running test cases with the following settings:\");\n+        System.out.println(\"compLevel=\" + compLevel);\n+        System.out.println(\"callSystemGC=\" + callSystemGC);\n+        System.out.println();\n+\n+        WB.deoptimizeAll();\n+\n+        boolean all = compPolicySelection == 0;\n+        if (compPolicySelection == 1 || all) runTests(new CompilationPolicy(7 \/*warmup*\/, COMP_NONE, COMP_NONE \/*Cont. pattern*\/));\n+        if (compPolicySelection == 2 || all) runTests(new CompilationPolicy(7 \/*warmup*\/, 1 \/* length comp. window *\/));\n+        if (compPolicySelection == 3 || all) runTests(new CompilationPolicy(7 \/*warmup*\/, 2 \/* length comp. window *\/));\n+        if (compPolicySelection == 4 || all) runTests(new CompilationPolicy(7 \/*warmup*\/, 3 \/* length comp. window *\/));\n+        if (compPolicySelection == 5 || all) runTests(new CompilationPolicy(7 \/*warmup*\/, COMP_ALL, CONT_METHS \/*Cont. pattern*\/));\n+        if (compPolicySelection >= 6) throw new Error(\"CompilationPolicy with number \" + compPolicySelection + \" does not exist\");\n+    }\n+\n+    public static void runTests(CompilationPolicy compPolicy) {\n+        System.out.println(\"$$$1 Running test cases with the following policy:\");\n+        compPolicy.print(); System.out.println();\n+\n+        new ContinuationRunYieldRunTest().runTestCase(3, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.NO_VARIANT).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.THROW_HANDLED_EXCEPTION).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.THROW_UNHANDLED_EXCEPTION).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.ALLOC_MONITOR).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.EXPR_STACK_NOT_EMPTY).runTestCase(4, compPolicy);\n+        new ContinuationRunYieldRunTest().runTestCase( 1, compPolicy);\n+        new ContinuationYieldEnlargeStackYield().runTestCase(1, compPolicy);\n+        new ContinuationYieldReduceStackYield().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs_3c0().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs_3c4().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs().runTestCase(1, compPolicy);\n+        new ContinuationDeepRecursion().runTestCase(3, compPolicy);\n+        new ContinuationDeepRecursionStackargs().runTestCase(3, compPolicy);\n+    }\n+\n+    public static class CompilationPolicy {\n+        public int warmupIterations;\n+        public Pattern methodPattern;\n+        public Pattern contMethPattern;\n+\n+        public CompWindowMode compWindowMode;\n+        public int winPos;\n+        public int winLen;\n+\n+        public Method[] methods;\n+\n+        public enum CompWindowMode {\n+            NO_COMP_WINDOW, COMP_WINDOW, DEOPT_WINDOW\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, 0, methodPattern, contMethPattern, CompWindowMode.NO_COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, windowLength, methodPattern, contMethPattern, CompWindowMode.COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength, Pattern methodPattern, Pattern contMethPattern,\n+                                 CompWindowMode startMode) {\n+            this.warmupIterations = warmupIterations;\n+            this.methodPattern = methodPattern;\n+            this.contMethPattern = contMethPattern;\n+            this.winPos = 0;\n+            this.winLen = windowLength;\n+            this.compWindowMode = startMode;\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength) {\n+            this(warmupIterations, windowLength, COMP_ALL, CONT_METHS);\n+        }\n+\n+        public int warmupIterations() {\n+            return this.warmupIterations;\n+        }\n+\n+        public boolean compileMethods() {\n+            boolean newCompilation = false;\n+            log(\"@@ Compiling test methods according to compilation policy\");\n+            print();\n+            for (int i = 0; i < methods.length; i++) {\n+                Method meth = methods[i];\n+                boolean inWindow = i >= winPos && i < (winPos+winLen);\n+                boolean shouldBeCompiled = compWindowMode == CompWindowMode.NO_COMP_WINDOW\n+                    || (inWindow && compWindowMode == CompWindowMode.COMP_WINDOW)\n+                    || (!inWindow && compWindowMode == CompWindowMode.DEOPT_WINDOW);\n+                boolean isCompiled = WB.isMethodCompiled(meth);\n+                log(\"methods[\"+i+\"] inWindow=\"+inWindow + \" isCompiled=\"+isCompiled+\" shouldBeCompiled=\"+shouldBeCompiled+\" method=`\"+meth+\"`\");\n+                if (isCompiled != shouldBeCompiled) {\n+                    if (shouldBeCompiled) {\n+                        log(\"           Compiling methods[\"+i+\"]\");\n+                        enqForCompilation(meth);\n+                        newCompilation = true;\n+                        assertTrue(WB.isMethodCompiled(meth), \"Run with -Xbatch\");\n+                    } else {\n+                        assertFalse(WB.isMethodQueuedForCompilation(meth), \"Run with -Xbatch\");\n+                        log(\"           Deoptimizing methods[\"+i+\"]\");\n+                        WB.deoptimizeMethod(meth);\n+                    }\n+                }\n+            }\n+            return newCompilation;\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean enqForCompilation(Method meth) {\n+            return WB.enqueueMethodForCompilation(meth, compLevel);\n+        }\n+\n+        public void log(String m) {\n+            System.out.println(m);\n+        }\n+\n+        public void print() {\n+            log(\"warmupIterations=\" + warmupIterations);\n+            log(\"methodPattern=\" + methodPattern);\n+            log(\"continuationMethPattern=\" + contMethPattern);\n+            log(\"compWindowMode=\" + compWindowMode);\n+            log(\"winLen=\" + winLen);\n+        }\n+\n+        public void setMethods(Method[] methods) {\n+            this.methods = methods;\n+            if (compWindowMode == CompWindowMode.NO_COMP_WINDOW) {\n+                winLen = methods.length;\n+            }\n+        }\n+\n+        public boolean shiftWindow() {\n+            if(compWindowMode == CompWindowMode.NO_COMP_WINDOW) return false;\n+            if (++winPos == methods.length) {\n+                winPos = 0;\n+                if (compWindowMode == CompWindowMode.DEOPT_WINDOW) {\n+                    compWindowMode = CompWindowMode.COMP_WINDOW;\n+                    return false; \/\/ we're done\n+                }\n+                compWindowMode = CompWindowMode.DEOPT_WINDOW;\n+            }\n+            return true; \/\/ continue\n+        }\n+    }\n+\n+    \/**\n+     * Base class for test cases\n+     *\/\n+    public static abstract class TestCaseBase implements Runnable {\n+        public int yieldCalls;\n+        public int warmUpCount;\n+        public CompilationPolicy compPolicy;\n+        public final TestCaseVariants testVariant;\n+\n+        public TestCaseBase() {\n+            testVariant = TestCaseVariants.NO_VARIANT;\n+        }\n+\n+        public TestCaseBase(TestCaseVariants excBehav) {\n+            this.testVariant = excBehav;\n+        }\n+\n+        public void log_dontjit() {\n+            System.out.println();\n+        }\n+\n+        public void log_dontjit(String m) {\n+            if (warmUpCount > 0) {\n+                System.out.print(\"[\" + warmUpCount + \"] \");\n+            }\n+            System.out.println(m);\n+        }\n+\n+        public void runTestCase(int yieldCalls, CompilationPolicy compPolicy) {\n+            this.yieldCalls = yieldCalls;\n+            log_dontjit(\">>>> Executing test case \" + getClass().getName() + \" (yieldCalls=\" + yieldCalls + \", \" + \"testVariant=\" + testVariant + \")\");\n+            init(compPolicy);\n+            try {\n+                log_dontjit(\"Warm-up test case\");\n+                setup_dontjit(true \/* for warmup *\/);\n+                for(warmUpCount = 1; warmUpCount <= compPolicy.warmupIterations(); warmUpCount++) {\n+                    testEntry_dontinline();\n+                }\n+                warmUpCount = 0;\n+                log_dontjit(\"Warm-up test case DONE\");\n+\n+                setup_dontjit(false \/* for warmup *\/);\n+                do {\n+                    compPolicy.compileMethods();\n+                    do {\n+                        log_dontjit(\"Running test case (Reresolve Call Sites)\");\n+                        testEntry_dontinline();\n+                        log_dontjit(\"Running test case DONE  (Reresolve Call Sites)\");\n+                    } while(compPolicy.compileMethods());\n+\n+                    log_dontjit(\"Running test case BEGIN\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE\");\n+                } while(compPolicy.shiftWindow());\n+            } finally {\n+                log_dontjit(\"<<<< Finished test case \" + getClass().getName()); log_dontjit();\n+            }\n+        }\n+\n+        public void setup_dontjit(boolean warmup) {\n+        }\n+\n+        public void init(CompilationPolicy compPolicy) {\n+            this.compPolicy = compPolicy;\n+            ArrayList<Method> selectedMethods = new ArrayList<Method>();\n+            Pattern p = compPolicy.methodPattern;\n+            if (p != COMP_NONE) {\n+                Class<? extends TestCaseBase> c = getClass();\n+                Method methods[] = c.getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p == COMP_ALL || p.matcher(meth.getName()).matches()) {\n+                        if (!meth.getName().contains(\"dontjit\")) {\n+                            selectedMethods.add(meth);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            p = compPolicy.contMethPattern;\n+            if (compPolicy.contMethPattern != COMP_NONE) {\n+                Class<?> c = Continuation.class;\n+                Method methods[] = c .getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p.matcher(meth.getName()).matches()) {\n+                        selectedMethods.add(meth);\n+                    }\n+                }\n+            }\n+            \/\/ Sort in caller\/callee order\n+            selectedMethods.sort(new Comparator<Method>() {\n+                    @Override\n+                    public int compare(Method m1, Method m2) {\n+                        String n1 = m1.getName();\n+                        String n2 = m2.getName();\n+                        \/\/ log_dontjit(\"n1=\" + n1 + \" n2=\" + n2);\n+                        int p1 = -1;\n+                        int p2 = -1;\n+                        int i = n1.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p1 = Integer.parseInt(n1.substring(i+3, i+6));\n+                        }\n+                        i = n2.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p2 = Integer.parseInt(n2.substring(i+3, i+6));\n+                        }\n+                        if (p1 < 0) p1 = getScoreKnownMethods(n1);\n+                        if (p2 < 0) p2 = getScoreKnownMethods(n2);\n+                        assertFalse(p1 == -1 || p2 == -1, \"Cannot compare \" + n1 + \" with \" + n2);\n+                        return p1 - p2;\n+                    }\n+\n+                    private int getScoreKnownMethods(String n) {\n+                        int p = -1;\n+                        if (n.equals(\"enter\"))  p = 20;   \/\/ Continuation.enter\n+                        if (n.equals(\"enter0\")) p = 30;   \/\/ Continuation.enter0\n+                        if (n.equals(\"run\"))    p = 50;   \/\/ Called by Continuation.enter0\n+                        if (n.equals(\"yield\"))  p = 1000; \/\/ caller of yield0\n+                        if (n.equals(\"yield0\")) p = 2000; \/\/ top frame\n+                        return p;\n+                    }\n+                });\n+            compPolicy.setMethods(selectedMethods.toArray(new Method[selectedMethods.size()]));\n+        }\n+\n+        public void testEntry_dontinline() {\n+            Continuation cont = new Continuation(THE_SCOPE, this);\n+            do {\n+                try {\n+                    cont.run();\n+                } catch(UnhandledException e) {\n+                    log_dontjit(\"Exc: \" + e);\n+                }\n+                if (callSystemGC) System.gc();\n+                checkFrames_dontjit(cont);\n+            } while (!cont.isDone());\n+        }\n+\n+        public void checkFrames_dontjit(Continuation cont) {\n+        } \/\/ Override in subclass as appropriate\n+\n+        @Override\n+        public void run() {\n+            fail(\"Should not call TestCaseBase::run\");\n+        }\n+\n+        public void sleep(Duration d) {\n+            try { Thread.sleep(d); }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        static final long i1=1; static final long i2=2; static final long i3=3;\n+        static final long i4=4; static final long i5=5; static final long i6=6; static final long i7=7;\n+        static final long i8=8; static final long i9=9; static final long i10=10; static final long i11=11; static final long i12=12;\n+        static final long i13=13; static final long i14=14; static final long i15=15; static final long i16=16;\n+    }\n+\n+    \/**\n+     * Trivial run\/yield\/run test\n+     *\/\n+    public static class ContinuationRunYieldRunTest extends TestCaseBase {\n+        public String sField;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            for(int i = 0; i < yieldCalls; i++) {\n+                log_dontjit(\"Yield #\" + i);\n+                String s1 = \"str1\";\n+                Continuation.yield(THE_SCOPE);\n+                String s2 = s1+\"str2\";\n+                sField = s2;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Yield, make continuation (stack) larger, yield again.\n+     *\/\n+    public static class ContinuationYieldEnlargeStackYield extends TestCaseBase {\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back from 1st yield. Now call a method to make the stack larger.\");\n+            ord101_callYieldWithLargerStackAgain_dontinline();\n+        }\n+\n+        private void ord101_callYieldWithLargerStackAgain_dontinline() {\n+            log_dontjit(\"Now there's a new frame on stack. Call yield again.\");\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back again after 2nd yield.\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Yield, make continuation (stack) larger, yield again.\n+     *\/\n+    public static class ContinuationYieldReduceStackYield extends TestCaseBase {\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            ord101_methodWithFirstYield_dontinline();\n+            log_dontjit(\"The frame of ord101_methodWithFirstYield_dontinline has been removed now. Call yield again.\");\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back again after 2nd yield.\");\n+        }\n+\n+        public void ord101_methodWithFirstYield_dontinline() {\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back from 1st yield. Now return to reduce stack size.\");\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw 3 compiled frames.\n+     *\/\n+    public static class Continuation3Frames extends TestCaseBase {\n+        public int yieldCount;\n+        public long resLong;\n+        public volatile String putOnExprStack;\n+\n+        public Continuation3Frames(TestCaseVariants excBehav) {\n+            super(excBehav);\n+        }\n+\n+        @Override\n+        public void run() {\n+            for(int i = 0; i < yieldCalls; i++) {\n+                Throwable caughtException = null;\n+                putOnExprStack = \"exprStckVal \";\n+                resLong = 0;\n+                try {\n+                    String s1 = \"str1\";\n+                    String result = ord101_testMethod_dontinline(i1, i2, i3, s1);\n+                    assertEQ(resLong, testVariant == TestCaseVariants.ALLOC_MONITOR ? 7L : 6L);\n+                    assertEQ(result, testVariant == TestCaseVariants.EXPR_STACK_NOT_EMPTY ? \"exprStckVal str1str2str3\" : \"str1str2str3\");\n+                } catch (HandledException e) {\n+                    caughtException = e;\n+                }\n+                assertTrue(testVariant != TestCaseVariants.THROW_HANDLED_EXCEPTION || (caughtException instanceof HandledException),\n+                           \"Exception handling error\");\n+            }\n+        }\n+\n+        public String ord101_testMethod_dontinline(long a1, long a2, long a3, String s1) throws HandledException {\n+            String s2 = s1+\"str2\";\n+            return ord102_testMethod_dontinline(a1, a2, a3, s2);\n+        }\n+\n+        public String ord102_testMethod_dontinline(long a1, long a2, long a3, String s2) throws HandledException {\n+            if (testVariant == TestCaseVariants.ALLOC_MONITOR) {\n+                synchronized (this) {\n+                    resLong++;\n+                }\n+            }\n+            if (testVariant == TestCaseVariants.EXPR_STACK_NOT_EMPTY) {\n+                return putOnExprStack_testMethod_dontjit_dontinline()\n+                    + ord103_testMethod_dontinline(a1, a2, a3, s2);\n+            } else {\n+                return ord103_testMethod_dontinline(a1, a2, a3, s2);\n+            }\n+        }\n+\n+        public String ord103_testMethod_dontinline(long a1, long a2, long a3, String s2) throws HandledException {\n+            return ord104_testMethod_dontinline(a1, a2, a3, s2);\n+        }\n+\n+        public String ord104_testMethod_dontinline(long a1, long a2, long a3, String s2) throws HandledException {\n+            long res = a2;\n+            String s3 = s2+\"str3\";\n+            log_dontjit(\"Yield #\" + yieldCount++); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount);\n+            if (testVariant == TestCaseVariants.THROW_HANDLED_EXCEPTION) {\n+                log_dontjit(\"Exc: throw handled\");\n+                throw new HandledException();\n+            }\n+            if (testVariant == TestCaseVariants.THROW_UNHANDLED_EXCEPTION) {\n+                log_dontjit(\"Exc: throw unhandled\");\n+                throw new UnhandledException();\n+            }\n+            resLong += res+a1+a3;\n+            return s3;\n+        }\n+\n+        public String putOnExprStack_testMethod_dontjit_dontinline() {\n+            return putOnExprStack;\n+        }\n+\n+        @Override\n+        public void checkFrames_dontjit(Continuation cont) {\n+            List<String> frames = cont.stackWalker().walk(fs -> fs.map(StackWalker.StackFrame::getMethodName).collect(Collectors.toList()));\n+            assertEquals(frames, cont.isDone() ? List.of()\n+                         : Arrays.asList(\"yield\", \"ord104_testMethod_dontinline\", \"ord103_testMethod_dontinline\",\n+                                         \"ord102_testMethod_dontinline\", \"ord101_testMethod_dontinline\", \"run\", \"enter0\", \"enter\"));\n+        }\n+    }\n+\n+    \/**\n+     * Deep recursion to exercise fast freezing into non-empty chunk\n+     *\/\n+    public static class ContinuationDeepRecursion extends TestCaseBase {\n+        public int limit;\n+        public int yield1_depth;\n+        public int yield2_depth;\n+\n+        @Override\n+        public void setup_dontjit(boolean warmup) {\n+            if (warmup) {\n+                limit = 10;\n+                yield1_depth = 7;\n+                yield2_depth = 3;\n+            } else {\n+                limit = 100;\n+                yield1_depth = 70;\n+                yield2_depth = 60;\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            ord101_recurse_dontinline(0);\n+        }\n+\n+        public void ord101_recurse_dontinline(int depth) {\n+            if (depth >= limit) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0);\n+                log_dontjit(\"After yield at depth \" + depth);\n+                return;\n+            }\n+            ord101_recurse_dontinline(depth + 1);\n+            if (depth == yield1_depth || depth == yield2_depth) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0);\n+                log_dontjit(\"After yield at depth \" + depth);\n+            }\n+        }\n+\n+        \/\/ Add a few frames before yield\n+        public void ord102_yield_dontinline(int depth) {\n+            if (depth >= 2) {\n+                Continuation.yield(THE_SCOPE);\n+                return;\n+            }\n+            ord102_yield_dontinline(depth + 1);\n+        }\n+    }\n+\n+    \/**\n+     * Deep recursion to exercise fast freezing into non-empty chunk.\n+     * nmethods have stack arguments.\n+     *\/\n+    public static class ContinuationDeepRecursionStackargs extends TestCaseBase {\n+        public int limit;\n+        public int yield1_depth;\n+        public int yield2_depth;\n+\n+        @Override\n+        public void setup_dontjit(boolean warmup) {\n+            if (warmup) {\n+                limit = 10;\n+                yield1_depth = 7;\n+                yield2_depth = 3;\n+            } else {\n+                limit = 100;\n+                yield1_depth = 70;\n+                yield2_depth = 60;\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            long res = ord101_recurse_dontinline(0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n+            if (res != i1+i2+i3+i4+i5+i6+i7+i8+i9+i10+i11) {\n+                throw new Error();\n+            }\n+        }\n+\n+        public long ord101_recurse_dontinline(int depth, long l1, long l2, long l3, long l4, long l5, long l6, long l7, long l8, long l9, long l10, long l11) {\n+            if (depth >= limit) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+                log_dontjit(\"After yield at depth \" + depth);\n+                return l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11;\n+            }\n+            long res = ord101_recurse_dontinline(depth + 1, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+            if (res != l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11) {\n+                throw new Error();\n+            }\n+            if (depth == yield1_depth || depth == yield2_depth) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                long res1 = ord102_yield_dontinline(0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+                if (res1 != l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11) {\n+                    throw new Error();\n+                }\n+                log_dontjit(\"After yield at depth \" + depth);\n+            }\n+            return res;\n+        }\n+\n+        \/\/ Add a few frames before yield\n+        public long ord102_yield_dontinline(int depth, long l1, long l2, long l3, long l4, long l5, long l6, long l7, long l8, long l9, long l10, long l11) {\n+            if (depth >= 2) {\n+                Continuation.yield(THE_SCOPE);\n+                return l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11;\n+            }\n+            long res = ord102_yield_dontinline(depth + 1, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+            if (res != l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11) {\n+                throw new Error();\n+            }\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with a few stack arguments\n+     * icj is a call with i incoming stack parameters and j outgoing stack parameters.\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs_3c0 extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline();\n+            assertEQ(result, 136L);\n+        }\n+\n+        public long ord101_testMethod_dontinline() {\n+            long res = ord102_testMethod_dontinline(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord102_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8,\n+                                                 long a9, long a10, long a11) {\n+            long res = a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+i12+i13+i14+i15+i16;\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with a few stack arguments, incoming _and_ outgoing\n+     * icj is a call with i incoming stack parameters and j outgoing stack parameters.\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs_3c4 extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline();\n+            assertEQ(result, 136L);\n+        }\n+\n+        public long ord101_testMethod_dontinline() {\n+            long res = ord102_testMethod_dontinline(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord102_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8,\n+                                                 long a9, long a10, long a11, long a12, long a13, long a14) {\n+            long res = ord103_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, i15);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord103_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7,\n+                                                 long a8, long a9, long a10, long a11, long a12, long a13, long a14, long a15) {\n+            long res = a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15+i16;\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with many stack arguments\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline(i1);\n+            assertEQ(result, 136L);\n+        }\n+\n+       public long ord101_testMethod_dontinline(long a1) {\n+           long res = ord102_testMethod_dontinline(a1, i2);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord102_testMethod_dontinline(long a1, long a2) {\n+           long res = ord103_testMethod_dontinline(a1, a2, i3);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord103_testMethod_dontinline(long a1, long a2, long a3) {\n+           long res = ord104_testMethod_dontinline(a1, a2, a3, i4);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord104_testMethod_dontinline(long a1, long a2, long a3, long a4) {\n+           long res = ord105_testMethod_dontinline(a1, a2, a3, a4, i5);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord105_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5) {\n+           long res = ord106_testMethod_dontinline(a1, a2, a3, a4, a5, i6);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord106_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6) {\n+           long res = ord107_testMethod_dontinline(a1, a2, a3, a4, a5, a6, i7);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+        public long ord107_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7) {\n+            long res = ord108_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, i8);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord108_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8) {\n+            long res = ord109_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, i9);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord109_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9) {\n+            long res = ord110_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, i10);\n+            Continuation.yield(THE_SCOPE);\n+            return res;\n+        }\n+\n+       public long ord110_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10) {\n+           long res = ord111_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, i11);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord111_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11) {\n+           long res = ord112_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, i12);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord112_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11, long a12) {\n+           long res = ord113_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, i13);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord113_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11, long a12, long a13) {\n+           long res = ord114_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, i14);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord114_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11, long a12, long a13, long a14) {\n+           long res = ord115_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, i15);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord115_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11, long a12, long a13, long a14, long a15) {\n+           long res = ord116_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, i16);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+        public long ord116_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8, long a9, long a10, long a11, long a12, long a13, long a14, long a15, long a16) {\n+            long res = a2+a4+a6+a8+a10+a12+a14+a16;\n+            log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+            res += a1+a3+a5+a7+a9+a11+a13+a15;\n+            return res;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/BasicExp.java","additions":976,"deletions":0,"binary":false,"changes":976,"status":"added"}]}