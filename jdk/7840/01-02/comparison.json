{"files":[{"patch":"@@ -65,3 +65,0 @@\n-    protected static final String NEW_INVOKE_SPECIAL_CLASS_NAME = \"java\/lang\/invoke\/NewInvokeSpecialCallSite\";\n-    protected static final String NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE = \"(\" + fd(JLI_METHODHANDLES_LOOKUP) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")V\";\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenFullCP.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,30 +47,0 @@\n-    \/**\n-     * Creates static init method, which constructs a call site object, which refers to the target method\n-     * and invokes Dummy.setMH() on this call site\n-     * @param cw Class writer object\n-     *\/\n-    @Override\n-    protected void createClassInitMethod(ClassWriter cw) {\n-        MethodVisitor mw = cw.visitMethod(\n-                Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC,\n-                STATIC_INIT_METHOD_NAME, INIT_METHOD_SIGNATURE,\n-                null,\n-                new String[0]);\n-\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODHANDLES, \"lookup\", \"()\" + fd(JLI_METHODHANDLES_LOOKUP));\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitLdcInsn(TARGET_METHOD_NAME);\n-        mw.visitLdcInsn(TARGET_METHOD_SIGNATURE);\n-        mw.visitLdcInsn(Type.getObjectType(fullClassName));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + fd(JL_CLASSLOADER));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, JLI_METHODTYPE,\n-                \"fromMethodDescriptorString\", \"(\" + fd(JL_STRING) + fd(JL_CLASSLOADER) + \")\" + fd(JLI_METHODTYPE));\n-        mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JLI_METHODHANDLES_LOOKUP,\n-                \"findStatic\", \"(\" + fd(JL_CLASS) + fd(JL_STRING) + fd(JLI_METHODTYPE) + \")\" + fd(JLI_METHODHANDLE));\n-        mw.visitMethodInsn(Opcodes.INVOKESTATIC, NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                \"setMH\", \"(\" + fd(JLI_METHODHANDLE) + \")V\");\n-\n-        finishMethodCode(mw);\n-    }\n-\n@@ -95,12 +65,4 @@\n-        Handle bsm;\n-        if (Env.getRNG().nextBoolean()) {\n-            bsm = new Handle(Opcodes.H_NEWINVOKESPECIAL,\n-                    NEW_INVOKE_SPECIAL_CLASS_NAME,\n-                    INIT_METHOD_NAME,\n-                    NEW_INVOKE_SPECIAL_BOOTSTRAP_METHOD_SIGNATURE);\n-        } else {\n-            bsm = new Handle(Opcodes.H_INVOKESTATIC,\n-                    this.fullClassName,\n-                    BOOTSTRAP_METHOD_NAME,\n-                    BOOTSTRAP_METHOD_SIGNATURE);\n-        }\n+        Handle bsm = new Handle(Opcodes.H_INVOKESTATIC,\n+                this.fullClassName,\n+                BOOTSTRAP_METHOD_NAME,\n+                BOOTSTRAP_METHOD_SIGNATURE);\n@@ -111,0 +73,2 @@\n+\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/cp\/share\/GenManyIndyCorrectBootstrap.java","additions":6,"deletions":42,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-\/**\n- * This is a CallSite, which constructor can be used as bootstrap method (via REF_newInvokeSpecial reference kind).\n- *\n- * This call site always calls MethodHandle set with {@link #setMH(MethodHandle)} method (no lookup by method name\/type is performed!)\n- * <p>Since we can't extend the java.lang.invoke.CallSite from package other than java.lang.invoke, we use system package name\n- * for this class.\n- *\/\n-public final class NewInvokeSpecialCallSite extends CallSite {\n-\n-    private static MethodHandle mh;\n-\n-    \/**\n-     * Sets method handle, which will be used for CallSite target\n-     *\/\n-    public static void setMH(MethodHandle newMH) {\n-        mh = newMH;\n-    }\n-\n-    \/**\n-     * Constructs a CallSite. This constructor has special signature, which can be used for bootstrap method target\n-     * of REF_newInvokeSpecial reference kind.\n-     * @param lookup Ignored.\n-     * @param name Ignored.\n-     * @param type Ignored.\n-     *\/\n-    public NewInvokeSpecialCallSite(MethodHandles.Lookup lookup, String name, MethodType type) {\n-        super(mh);\n-    }\n-\n-    \/**\n-     * This method is no-op. Use {@link #setMH(MethodHandle)} for setting the target\n-     *\/\n-    public final void setTarget(MethodHandle newMH) {\n-        \/\/ No-op\n-    }\n-\n-    \/**\n-     * Always returns method handle set with {@link #setMH(MethodHandle)} method\n-     *\/\n-    public final MethodHandle getTarget() {\n-        return mh;\n-    }\n-\n-    public final MethodHandle dynamicInvoker() {\n-        return makeDynamicInvoker();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/patches\/java.base\/java\/lang\/invoke\/NewInvokeSpecialCallSite.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"}]}