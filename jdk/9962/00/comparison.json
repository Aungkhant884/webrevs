{"files":[{"patch":"@@ -96,2 +96,12 @@\n-#define SYM_NAME_LENGTH 30\n-static char symbol_name[SYM_NAME_LENGTH];\n+TEST_VM(SymbolTable, test_symbol_refcount_parallel) {\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[30];\n+  \/\/ Find a symbol where there will probably be only one instance.\n+  for (int i = 0; i < 100; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n+    TempNewSymbol ts = SymbolTable::new_symbol(symbol_name);\n+    if (ts->refcount() == 1) {\n+      EXPECT_TRUE(ts->refcount() == 1) << \"Symbol is just created\";\n+      break;  \/\/ found a unique symbol\n+    }\n+  }\n@@ -99,5 +109,2 @@\n-class SymbolThread : public JavaTestThread {\n-  public:\n-  SymbolThread(Semaphore* post) : JavaTestThread(post) {}\n-  virtual ~SymbolThread() {}\n-  void main_run() {\n+  constexpr int symTestThreadCount = 5;\n+  auto symbolThread= [&](Thread* _current, int _ig) {\n@@ -109,38 +116,5 @@\n-  }\n-};\n-\n-#define SYM_TEST_THREAD_COUNT 5\n-\n-class DriverSymbolThread : public JavaTestThread {\n-public:\n-  Semaphore _done;\n-  DriverSymbolThread(Semaphore* post) : JavaTestThread(post) { };\n-  virtual ~DriverSymbolThread(){}\n-\n-  void main_run() {\n-    Semaphore done(0);\n-\n-    \/\/ Find a symbol where there will probably be only one instance.\n-    for (int i = 0; i < 100; i++) {\n-       os::snprintf(symbol_name, SYM_NAME_LENGTH, \"some_symbol%d\", i);\n-       TempNewSymbol ts = SymbolTable::new_symbol(symbol_name);\n-       if (ts->refcount() == 1) {\n-         EXPECT_TRUE(ts->refcount() == 1) << \"Symbol is just created\";\n-         break;  \/\/ found a unique symbol\n-       }\n-    }\n-\n-    SymbolThread* st[SYM_TEST_THREAD_COUNT];\n-    for (int i = 0; i < SYM_TEST_THREAD_COUNT; i++) {\n-      st[i] = new SymbolThread(&done);\n-      st[i]->doit();\n-    }\n-\n-    for (int i = 0; i < SYM_TEST_THREAD_COUNT; i++) {\n-      done.wait();\n-    }\n-  }\n-};\n-\n-TEST_VM(SymbolTable, test_symbol_refcount_parallel) {\n-  mt_test_doer<DriverSymbolThread>();\n+  };\n+  TestThreadGroup<decltype(symbolThread), int, symTestThreadCount>\n+    ttg(symbolThread, []() { return 0; });\n+  ttg.doit();\n+  ttg.join();\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":19,"deletions":45,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,61 @@\n+\n+  void join() {\n+    _post->wait();\n+  }\n+};\n+\n+\/\/ Calls a single-argument function of type F with state of type S as its input\n+\/\/ in a new thread when doit() is run.\n+template<typename F, typename S>\n+class BasicTestThread : public JavaTestThread {\n+private:\n+  F _fun;\n+  S _state;\n+\n+public:\n+  BasicTestThread(F fun, S state, Semaphore* sem)\n+    : JavaTestThread(sem),\n+      _fun(fun),\n+      _state(state) {\n+  }\n+\n+  virtual ~BasicTestThread(){};\n+\n+  void main_run() override {\n+    _fun(this, _state);\n+  }\n+};\n+\n+\/\/ A TestThreadGroup tracks multiple threads running the same function.\n+template<typename F, typename S, int N>\n+class TestThreadGroup {\n+private:\n+  VMThreadBlocker* _blocker;\n+  BasicTestThread<F, S>* _threads[N];\n+  Semaphore _sem;\n+\n+public:\n+  NONCOPYABLE(TestThreadGroup);\n+\n+  \/\/ Use state_fun to generate varying state of type S for each function F.\n+  template<typename StateGenerator>\n+  TestThreadGroup(F fun, StateGenerator state_fun)\n+    : _sem() {\n+    for (int i = 0; i < N; i++) {\n+      _threads[i] = new BasicTestThread<F, S>(fun, state_fun(), &_sem);\n+    }\n+  }\n+  ~TestThreadGroup() {}\n+\n+  void doit() {\n+    _blocker = VMThreadBlocker::start();\n+    for (int i = 0; i < N; i++) {\n+      _threads[i]->doit();\n+    }\n+  }\n+  void join() {\n+    for (int i = 0; i < N; i++) {\n+      _sem.wait();\n+    }\n+    _blocker->release();\n+  }\n","filename":"test\/hotspot\/gtest\/threadHelper.inline.hpp","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"threadHelper.inline.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"threadHelper.inline.hpp\"\n@@ -31,2 +31,2 @@\n-#define GOOD_VALUE 1337\n-#define BAD_VALUE  4711\n+constexpr const int good_value = 1337;\n+constexpr const int bad_value =  4711;\n@@ -38,16 +38,14 @@\n-class RCUReaderThread : public JavaTestThread {\n-public:\n-  static volatile bool _exit;\n-  volatile TestData** _test;\n-  Semaphore* _wrt_start;\n-  RCUReaderThread(Semaphore* post, volatile TestData** test, Semaphore* wrt_start)\n-    : JavaTestThread(post), _test(test), _wrt_start(wrt_start) {};\n-  virtual ~RCUReaderThread(){}\n-  void main_run() {\n-    _wrt_start->signal();\n-    while (!_exit) {\n-      GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(this);\n-      volatile TestData* test = Atomic::load_acquire(_test);\n-      long value = Atomic::load_acquire(&test->test_value);\n-      ASSERT_EQ(value, GOOD_VALUE);\n-      GlobalCounter::critical_section_end(this, cs_context);\n+TEST_VM(GlobalCounter, critical_section) {\n+  constexpr int number_of_readers = 4;\n+  volatile bool rt_exit = false;\n+  Semaphore wrt_start;\n+  volatile TestData* test = nullptr;\n+\n+  auto rcu_reader = [&](Thread* current, volatile TestData** _test) {\n+    wrt_start.signal();\n+    while (!rt_exit) {\n+      GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(current);\n+      volatile TestData* read_test = Atomic::load_acquire(_test);\n+      long value = Atomic::load_acquire(&read_test->test_value);\n+      ASSERT_EQ(value, good_value);\n+      GlobalCounter::critical_section_end(current, cs_context);\n@@ -55,1 +53,1 @@\n-        GlobalCounter::CriticalSection cs(this);\n+        GlobalCounter::CriticalSection cs(current);\n@@ -58,1 +56,1 @@\n-        ASSERT_EQ(value, GOOD_VALUE);\n+        ASSERT_EQ(value, good_value);\n@@ -61,8 +59,0 @@\n-  }\n-};\n-\n-volatile bool RCUReaderThread::_exit = false;\n-\n-class RCUWriterThread : public JavaTestThread {\n-public:\n-  RCUWriterThread(Semaphore* post) : JavaTestThread(post) {\n@@ -70,11 +60,0 @@\n-  virtual ~RCUWriterThread(){}\n-  void main_run() {\n-    static const int NUMBER_OF_READERS = 4;\n-    Semaphore post;\n-    Semaphore wrt_start;\n-    volatile TestData* test = NULL;\n-\n-    RCUReaderThread* reader1 = new RCUReaderThread(&post, &test, &wrt_start);\n-    RCUReaderThread* reader2 = new RCUReaderThread(&post, &test, &wrt_start);\n-    RCUReaderThread* reader3 = new RCUReaderThread(&post, &test, &wrt_start);\n-    RCUReaderThread* reader4 = new RCUReaderThread(&post, &test, &wrt_start);\n@@ -82,3 +61,4 @@\n-    TestData* tmp = new TestData();\n-    tmp->test_value = GOOD_VALUE;\n-    Atomic::release_store_fence(&test, tmp);\n+  TestThreadGroup<decltype(rcu_reader), volatile TestData**, number_of_readers> ttg(rcu_reader,\n+                                                                                    [&]() {\n+                                                                                      return &test;\n+                                                                                    });\n@@ -86,24 +66,9 @@\n-    reader1->doit();\n-    reader2->doit();\n-    reader3->doit();\n-    reader4->doit();\n-\n-    int nw = NUMBER_OF_READERS;\n-    while (nw > 0) {\n-      wrt_start.wait();\n-      --nw;\n-    }\n-    jlong stop_ms = os::javaTimeMillis() + 1000; \/\/ 1 seconds max test time\n-    for (int i = 0; i < 100000 && stop_ms > os::javaTimeMillis(); i++) {\n-      volatile TestData* free_tmp = test;\n-      tmp = new TestData();\n-      tmp->test_value = GOOD_VALUE;\n-      Atomic::release_store(&test, tmp);\n-      GlobalCounter::write_synchronize();\n-      free_tmp->test_value = BAD_VALUE;\n-      delete free_tmp;\n-    }\n-    RCUReaderThread::_exit = true;\n-    for (int i = 0; i < NUMBER_OF_READERS; i++) {\n-      post.wait();\n-    }\n+  TestData* tmp = new TestData();\n+  tmp->test_value = good_value;\n+  Atomic::release_store(&test, tmp);\n+  rt_exit = false;\n+  ttg.doit();\n+  int nw = number_of_readers;\n+  while (nw > 0) {\n+    wrt_start.wait();\n+    --nw;\n@@ -111,5 +76,12 @@\n-};\n-\n-TEST_VM(GlobalCounter, critical_section) {\n-  RCUReaderThread::_exit = false;\n-  mt_test_doer<RCUWriterThread>();\n+  jlong stop_ms = os::javaTimeMillis() + 1000; \/\/ 1 seconds max test time\n+  for (int i = 0; i < 100000 && stop_ms > os::javaTimeMillis(); i++) {\n+    volatile TestData* free_tmp = test;\n+    tmp = new TestData();\n+    tmp->test_value = good_value;\n+    Atomic::release_store(&test, tmp);\n+    GlobalCounter::write_synchronize();\n+    free_tmp->test_value = bad_value;\n+    delete free_tmp;\n+  }\n+  rt_exit = true;\n+  ttg.join();\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalCounter.cpp","additions":45,"deletions":73,"binary":false,"changes":118,"status":"modified"}]}