{"files":[{"patch":"@@ -590,0 +590,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax and for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -782,0 +786,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    get_interpreterState()->set_thread(thread->as_Java_thread());\n+    get_interpreterState()->set_thread(JavaThread::cast(thread));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -166,1 +165,1 @@\n-      const char* name = (javathread)->get_thread_name();                  \\\n+      const char* name = (javathread)->name();                             \\\n@@ -187,20 +186,1 @@\n-\/\/ Support for forcing alignment of thread objects for biased locking\n-  if (UseBiasedLocking) {\n-    const size_t alignment = markWord::biased_lock_alignment;\n-    size_t aligned_size = size + (alignment - sizeof(intptr_t));\n-    void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)\n-                                          : AllocateHeap(aligned_size, flags, CURRENT_PC,\n-                                                         AllocFailStrategy::RETURN_NULL);\n-    void* aligned_addr     = align_up(real_malloc_addr, alignment);\n-    assert(((uintptr_t) aligned_addr + (uintptr_t) size) <=\n-           ((uintptr_t) real_malloc_addr + (uintptr_t) aligned_size),\n-           \"JavaThread alignment code overflowed allocated storage\");\n-    if (aligned_addr != real_malloc_addr) {\n-      log_info(biasedlocking)(\"Aligned thread \" INTPTR_FORMAT \" to \" INTPTR_FORMAT,\n-                              p2i(real_malloc_addr),\n-                              p2i(aligned_addr));\n-    }\n-    ((Thread*) aligned_addr)->_real_malloc_address = real_malloc_addr;\n-    return aligned_addr;\n-  } else {\n-    return throw_excpt? AllocateHeap(size, flags, CURRENT_PC)\n+  return throw_excpt ? AllocateHeap(size, flags, CURRENT_PC)\n@@ -209,1 +189,0 @@\n-  }\n@@ -213,5 +192,1 @@\n-  if (UseBiasedLocking) {\n-    FreeHeap(((Thread*) p)->_real_malloc_address);\n-  } else {\n-    FreeHeap(p);\n-  }\n+  FreeHeap(p);\n@@ -291,8 +266,0 @@\n-#ifdef ASSERT\n-  if (UseBiasedLocking) {\n-    assert(is_aligned(this, markWord::biased_lock_alignment), \"forced alignment of thread object failed\");\n-    assert(this == _real_malloc_address ||\n-           this == align_up(_real_malloc_address, markWord::biased_lock_alignment),\n-           \"bug in forced alignment of thread objects\");\n-  }\n-#endif \/\/ ASSERT\n@@ -352,1 +319,1 @@\n-    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n+    JavaThread::cast(this)->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -464,2 +431,2 @@\n-         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n-         !thread->as_Java_thread()->on_thread_list() ||\n+         JavaThread::cast(thread)->is_handshake_safe_for(Thread::current()) ||\n+         !JavaThread::cast(thread)->on_thread_list() ||\n@@ -467,1 +434,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(JavaThread::cast(thread)),\n@@ -482,0 +449,7 @@\n+  \/\/ If the target hasn't been started yet then it is trivially\n+  \/\/ \"protected\". We assume the caller is the thread that will do\n+  \/\/ the starting.\n+  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+    return true;\n+  }\n+\n@@ -539,1 +513,1 @@\n-    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+    java_lang_Thread::set_thread_status(JavaThread::cast(thread)->threadObj(),\n@@ -645,9 +619,1 @@\n-  if (is_VM_thread())                 { st->print(\"VMThread\"); }\n-  else if (is_GC_task_thread())       { st->print(\"GCTaskThread\"); }\n-  else if (is_Watcher_thread())       { st->print(\"WatcherThread\"); }\n-  else if (is_ConcurrentGC_thread())  { st->print(\"ConcurrentGCThread\"); }\n-  else                                { st->print(\"Thread\"); }\n-\n-  if (is_Named_thread()) {\n-    st->print(\" \\\"%s\\\"\", name());\n-  }\n+  st->print(\"%s \\\"%s\\\"\", type_name(), name());\n@@ -706,1 +672,1 @@\n-  return os::create_main_thread(this->as_Java_thread());\n+  return os::create_main_thread(JavaThread::cast(this));\n@@ -1082,1 +1048,0 @@\n-  _cached_monitor_info(nullptr),\n@@ -1302,1 +1267,1 @@\n-      this->set_native_thread_name(this->get_thread_name());\n+      this->set_native_thread_name(this->name());\n@@ -1381,1 +1346,1 @@\n-                    get_thread_name());\n+                    name());\n@@ -1486,1 +1451,1 @@\n-    thread_name = os::strdup(get_thread_name());\n+    thread_name = os::strdup(name());\n@@ -1554,1 +1519,1 @@\n-    return thread->as_Java_thread();\n+    return JavaThread::cast(thread);\n@@ -1558,1 +1523,1 @@\n-    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n+    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n@@ -1716,1 +1681,1 @@\n-    JavaThread* target = thr->as_Java_thread();\n+    JavaThread* target = JavaThread::cast(thr);\n@@ -2096,1 +2061,1 @@\n-  st->print_raw(get_thread_name());\n+  st->print_raw(name());\n@@ -2134,1 +2099,1 @@\n-  st->print(\"JavaThread \\\"%s\\\"\", get_thread_name_string(buf, buflen));\n+  st->print(\"%s \\\"%s\\\"\", type_name(), get_thread_name_string(buf, buflen));\n@@ -2182,1 +2147,1 @@\n-const char* JavaThread::get_thread_name() const {\n+const char* JavaThread::name() const  {\n@@ -2193,1 +2158,1 @@\n-\/\/ descriptive string if there is no set name\n+\/\/ descriptive string if there is no set name.\n@@ -2208,1 +2173,1 @@\n-      name_str = Thread::name();\n+      name_str = \"<un-named>\";\n@@ -2217,0 +2182,13 @@\n+\/\/ Helper to extract the name from the thread oop for logging.\n+const char* JavaThread::name_for(oop thread_obj) {\n+  assert(thread_obj != NULL, \"precondition\");\n+  oop name = java_lang_Thread::name(thread_obj);\n+  const char* name_str;\n+  if (name != NULL) {\n+    name_str = java_lang_String::as_utf8_string(name);\n+  } else {\n+    name_str = \"<un-named>\";\n+  }\n+  return name_str;\n+}\n+\n@@ -3059,2 +3037,0 @@\n-  BiasedLocking::init();\n-\n@@ -3307,1 +3283,1 @@\n-  \/\/ it will cause MetaspaceShared::link_and_cleanup_shared_classes to\n+  \/\/ it will cause MetaspaceShared::link_shared_classes to\n@@ -3318,1 +3294,1 @@\n-    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n+    DynamicArchive::prepare_for_dynamic_dumping();\n@@ -3949,0 +3925,78 @@\n+\n+\/\/ Helper function to create the java.lang.Thread object for a\n+\/\/ VM-internal thread. The thread will have the given name, be\n+\/\/ part of the System ThreadGroup and if is_visible is true will be\n+\/\/ discoverable via the system ThreadGroup.\n+Handle JavaThread::create_system_thread_object(const char* name,\n+                                               bool is_visible, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(name, CHECK_NH);\n+\n+  \/\/ Initialize thread_oop to put it into the system threadGroup.\n+  \/\/ This is done by calling the Thread(ThreadGroup tg, String name)\n+  \/\/ constructor, which adds the new thread to the group as an unstarted\n+  \/\/ thread.\n+  Handle thread_group(THREAD, Universe::system_thread_group());\n+  Handle thread_oop =\n+    JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n+                                      vmSymbols::threadgroup_string_void_signature(),\n+                                      thread_group,\n+                                      string,\n+                                      CHECK_NH);\n+\n+  \/\/ If the Thread is intended to be visible then we have to mimic what\n+  \/\/ Thread.start() would do, by adding it to its ThreadGroup: tg.add(t).\n+  if (is_visible) {\n+    Klass* group = vmClasses::ThreadGroup_klass();\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_special(&result,\n+                            thread_group,\n+                            group,\n+                            vmSymbols::add_method_name(),\n+                            vmSymbols::thread_void_signature(),\n+                            thread_oop,\n+                            CHECK_NH);\n+  }\n+\n+  return thread_oop;\n+}\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadObj(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":121,"deletions":67,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -167,3 +166,0 @@\n-  \/\/ Support for forcing alignment of thread objects for biased locking\n-  void*       _real_malloc_address;\n-\n@@ -358,3 +354,5 @@\n-  \/\/ Casts\n-  inline JavaThread* as_Java_thread();\n-  inline const JavaThread* as_Java_thread() const;\n+  \/\/ All threads are given names. For singleton subclasses we can\n+  \/\/ just hard-wire the known name of the instance. JavaThreads and\n+  \/\/ NamedThreads support multiple named instances, and dynamic\n+  \/\/ changing of the name of an instance.\n+  virtual const char* name() const { return \"Unknown thread\"; }\n@@ -362,1 +360,3 @@\n-  virtual char* name() const { return (char*)\"Unknown thread\"; }\n+  \/\/ A thread's type name is also made available for debugging\n+  \/\/ and logging.\n+  virtual const char* type_name() const { return \"Thread\"; }\n@@ -578,0 +578,1 @@\n+  \/\/ Basic, non-virtual, printing support that is simple and always safe.\n@@ -1359,0 +1360,3 @@\n+  \/\/ factor out low-level mechanics for use in both normal and error cases\n+  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+\n@@ -1378,1 +1382,4 @@\n-  char* name() const { return (char*)get_thread_name(); }\n+  const char* name() const;\n+  const char* type_name() const { return \"JavaThread\"; }\n+  static const char* name_for(oop thread_obj);\n+\n@@ -1386,5 +1393,1 @@\n-  const char* get_thread_name() const;\n- protected:\n-  \/\/ factor out low-level mechanics for use in both normal and error cases\n-  virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n- public:\n+\n@@ -1425,1 +1428,4 @@\n-  static inline JavaThread* current();\n+  static JavaThread* current() {\n+    return JavaThread::cast(Thread::current());\n+  }\n+\n@@ -1429,0 +1435,11 @@\n+  \/\/ Casts\n+  static JavaThread* cast(Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to JavaThread\");\n+    return static_cast<JavaThread*>(t);\n+  }\n+\n+  static const JavaThread* cast(const Thread* t) {\n+    assert(t->is_Java_thread(), \"incorrect cast to const JavaThread\");\n+    return static_cast<const JavaThread*>(t);\n+  }\n+\n@@ -1558,6 +1575,0 @@\n-  \/\/ Biased locking support\n- private:\n-  GrowableArray<MonitorInfo*>* _cached_monitor_info;\n-  GrowableArray<MonitorInfo*>* cached_monitor_info() { return _cached_monitor_info; }\n-  void set_cached_monitor_info(GrowableArray<MonitorInfo*>* info) { _cached_monitor_info = info; }\n-\n@@ -1591,5 +1602,5 @@\n-};\n-\/\/ Inline implementation of JavaThread::current\n-inline JavaThread* JavaThread::current() {\n-  return Thread::current()->as_Java_thread();\n-}\n+  \/\/ Helper function to create the java.lang.Thread object for a\n+  \/\/ VM-internal thread. The thread will have the given name, be\n+  \/\/ part of the System ThreadGroup and if is_visible is true will be\n+  \/\/ discoverable via the system ThreadGroup.\n+  static Handle create_system_thread_object(const char* name, bool is_visible, TRAPS);\n@@ -1598,4 +1609,4 @@\n-inline JavaThread* JavaThread::current_or_null() {\n-  Thread* current = Thread::current_or_null();\n-  return current != nullptr ? current->as_Java_thread() : nullptr;\n-}\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n@@ -1603,4 +1614,4 @@\n-inline JavaThread* Thread::as_Java_thread() {\n-  assert(is_Java_thread(), \"incorrect cast to JavaThread\");\n-  return static_cast<JavaThread*>(this);\n-}\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+};\n@@ -1608,3 +1619,3 @@\n-inline const JavaThread* Thread::as_Java_thread() const {\n-  assert(is_Java_thread(), \"incorrect cast to const JavaThread\");\n-  return static_cast<const JavaThread*>(this);\n+inline JavaThread* JavaThread::current_or_null() {\n+  Thread* current = Thread::current_or_null();\n+  return current != nullptr ? JavaThread::cast(current) : nullptr;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":48,"deletions":37,"binary":false,"changes":85,"status":"modified"}]}