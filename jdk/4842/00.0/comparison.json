{"files":[{"patch":"@@ -319,41 +319,0 @@\n-void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n-  __ block_comment(\"{ save_java_frame_anchor \");\n-  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} save_java_frame_anchor \");\n-}\n-\n-void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n-  __ block_comment(\"{ restore_java_frame_anchor \");\n-  \/\/ thread->_last_Java_sp = NULL\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n-\n-  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n-  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-\n-  \/\/_thread->frame_anchor()->copy(&_anchor);\n-\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n-\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n-\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} restore_java_frame_anchor \");\n-}\n-\n@@ -445,0 +404,54 @@\n+static int compute_res_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  return result_size;\n+}\n+\n+static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ save java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, offset), reg->as_Register());\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} save java result \");\n+}\n+\n+static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ restore java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, offset));\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} restore java result \");\n+}\n+\n@@ -577,6 +590,0 @@\n-struct AuxiliarySaves {\n-  JavaFrameAnchor jfa;\n-  uintptr_t thread;\n-  bool should_detach;\n-};\n-\n@@ -611,0 +618,1 @@\n+  int res_save_area_size = compute_res_save_area_size(conv);\n@@ -616,1 +624,2 @@\n-  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + res_save_area_size;\n@@ -618,6 +627,2 @@\n-  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n-\n-  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n-  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n-  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n@@ -634,2 +639,2 @@\n-  \/\/      | AuxiliarySaves      |\n-  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n@@ -643,0 +648,3 @@\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n@@ -653,1 +661,0 @@\n-  Label call_return;\n@@ -669,1 +676,1 @@\n-  __ block_comment(\"{ get_thread\");\n+  __ block_comment(\"{ on_entry\");\n@@ -671,1 +678,1 @@\n-  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n@@ -673,1 +680,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n@@ -676,40 +683,1 @@\n-  __ movptr(Address(rsp, thread_offset), r15_thread);\n-  __ block_comment(\"} get_thread\");\n-\n-  \/\/ TODO:\n-  \/\/ We expect not to be coming from JNI code, but we might be.\n-  \/\/ We should figure out what our stance is on supporting that and then maybe add\n-  \/\/ some more handling here for:\n-  \/\/   - handle blocks\n-  \/\/   - check for active exceptions (and emit an error)\n-\n-  __ block_comment(\"{ safepoint poll\");\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  if (os::is_MP()) {\n-    __ membar(Assembler::Membar_mask_bits(\n-                Assembler::LoadLoad  | Assembler::StoreLoad |\n-                Assembler::LoadStore | Assembler::StoreStore));\n-   }\n-\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n-  Label L_after_safepoint_poll;\n-  Label L_safepoint_poll_slow_path;\n-\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n-\n-  __ bind(L_after_safepoint_poll);\n-  __ block_comment(\"} safepoint poll\");\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n-\n-  __ block_comment(\"{ reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n-  __ block_comment(\"} reguard stack check\");\n+  __ block_comment(\"} on_entry\");\n@@ -731,0 +699,10 @@\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  save_java_result(_masm, conv, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n@@ -732,0 +710,1 @@\n+  __ block_comment(\"} on_exit\");\n@@ -733,2 +712,1 @@\n-  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n-  __ reset_last_Java_frame(r15_thread, true);\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n@@ -736,1 +714,1 @@\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n+  restore_java_result(_masm, conv, res_save_area_offset);\n@@ -738,0 +716,1 @@\n+  \/\/ return value shuffle\n@@ -764,21 +743,0 @@\n-  __ bind(call_return);\n-\n-  \/\/ also sets last Java frame\n-  __ movptr(r15_thread, Address(rsp, thread_offset));\n-  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n-  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n-\n-  __ block_comment(\"{ maybe_detach_thread\");\n-  Label L_after_detach;\n-  __ cmpb(Address(rsp, should_detach_offset), 0);\n-  __ jcc(Assembler::equal, L_after_detach);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n-  __ reinit_heapbase();\n-  __ bind(L_after_detach);\n-  __ block_comment(\"} maybe_detach_thread\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n@@ -790,23 +748,0 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -842,1 +777,1 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":83,"deletions":148,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-Thread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n-  Thread* thread = Thread::current_or_null();\n+JavaThread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n+  JavaThread* thread = JavaThread::current_or_null();\n@@ -62,1 +62,2 @@\n-    thread = Thread::current();\n+    thread = JavaThread::current();\n+    assert(!thread->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n@@ -69,1 +70,1 @@\n-void ProgrammableUpcallHandler::detach_thread(Thread* thread) {\n+void ProgrammableUpcallHandler::detach_current_thread() {\n@@ -74,0 +75,79 @@\n+\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n+JavaThread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = maybe_attach_and_get_thread(&context->should_detach);\n+  context->thread = thread;\n+\n+  assert(thread->can_call_java(), \"must be able to call Java\");\n+\n+  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n+  \/\/ since it can potentially block.\n+  context->new_handles = JNIHandleBlock::allocate_block(thread);\n+\n+  \/\/ After this, we are officially in Java Code. This needs to be done before we change any of the thread local\n+  \/\/ info, since we cannot find oops before the new information is set up completely.\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java);\n+\n+  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n+  \/\/ in OptimizedEntryBlob::FrameData. This way, we can decide if we need to do any pd actions\n+  \/\/ to prepare for stop\/suspend (cache sp, or other state).\n+  bool clear_pending_exception = true;\n+  if (thread->has_special_runtime_exit_condition()) {\n+    thread->handle_special_runtime_exit_condition();\n+    if (thread->has_pending_exception()) {\n+      clear_pending_exception = false;\n+    }\n+  }\n+\n+  context->old_handles = thread->active_handles();\n+\n+  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n+  \/\/ the (platform specific) state.\n+\n+  context->jfa.copy(thread->frame_anchor());\n+  thread->frame_anchor()->clear();\n+\n+  debug_only(thread->inc_java_call_counter());\n+  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  if (clear_pending_exception) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n+\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n+void ProgrammableUpcallHandler::on_exit(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = context->thread;\n+  assert(thread == JavaThread::current(), \"must still be the same thread\");\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n+  \/\/ restore previous handle block\n+  thread->set_active_handles(context->old_handles);\n+\n+  thread->frame_anchor()->zap();\n+\n+  debug_only(thread->dec_java_call_counter());\n+\n+  \/\/ Old thread-local info. has been restored. We are now back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  thread->frame_anchor()->copy(&context->jfa);\n+\n+  \/\/ Release handles after we are marked as being in native code again, since this\n+  \/\/ operation might block\n+  JNIHandleBlock::release_block(context->new_handles, thread);\n+\n+  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n+\n+  if (context->should_detach) {\n+    detach_current_thread();\n+  }\n+}\n+\n@@ -76,1 +156,1 @@\n-  Thread* thread = maybe_attach_and_get_thread(&should_detach);\n+  JavaThread* thread = maybe_attach_and_get_thread(&should_detach);\n@@ -80,1 +160,1 @@\n-    upcall_helper(JavaThread::cast(thread), rec, buff);\n+    upcall_helper(thread, rec, buff);\n@@ -84,1 +164,1 @@\n-    detach_thread(thread);\n+    detach_current_thread();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":87,"deletions":7,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1932,0 +1932,9 @@\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n+         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n+}\n+#endif\n+\n@@ -1939,2 +1948,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0), \"wrong java_sp info!\");\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -1988,4 +1996,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  verify_frame_info();\n@@ -1996,4 +2001,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  DEBUG_ONLY(verify_frame_info();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1129,0 +1129,2 @@\n+  DEBUG_ONLY(void verify_frame_info();)\n+\n@@ -1430,0 +1432,3 @@\n+  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  static inline JavaThread* current_or_null();\n+\n@@ -1614,0 +1619,5 @@\n+inline JavaThread* JavaThread::current_or_null() {\n+  Thread* current = Thread::current_or_null();\n+  return current != nullptr ? JavaThread::cast(current) : nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}