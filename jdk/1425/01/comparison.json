{"files":[{"patch":"@@ -33,2 +33,5 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {\n-  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, weak);\n+static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+  if (barrier_data == ZLoadBarrierElided) {\n+    return;\n+  }\n+  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, barrier_data);\n@@ -42,1 +45,1 @@\n-  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, false \/* weak *\/);\n+  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, ZLoadBarrierStrong);\n@@ -53,1 +56,1 @@\n-  predicate(UseZGC && !needs_acquiring_load(n) && (n->as_Load()->barrier_data() == ZLoadBarrierStrong));\n+  predicate(UseZGC && !needs_acquiring_load(n) && (n->as_Load()->barrier_data() != 0));\n@@ -63,23 +66,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch2 \/* tmp *\/, false \/* weak *\/);\n-    }\n-  %}\n-\n-  ins_pipe(iload_reg_mem);\n-%}\n-\n-\/\/ Load Weak Pointer\n-instruct zLoadWeakP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n-%{\n-  match(Set dst (LoadP mem));\n-  predicate(UseZGC && !needs_acquiring_load(n) && (n->as_Load()->barrier_data() == ZLoadBarrierWeak));\n-  effect(TEMP dst, KILL cr);\n-\n-  ins_cost(4 * INSN_COST);\n-\n-  format %{ \"ldr  $dst, $mem\" %}\n-\n-  ins_encode %{\n-    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ ldr($dst$$Register, ref_addr);\n-    z_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch2 \/* tmp *\/, true \/* weak *\/);\n+    z_load_barrier(_masm, this, ref_addr, $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -95,1 +76,1 @@\n-  predicate(UseZGC && needs_acquiring_load(n) && n->as_Load()->barrier_data() == ZLoadBarrierStrong);\n+  predicate(UseZGC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);\n@@ -104,3 +85,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, Address($mem$$Register), $dst$$Register, rscratch2 \/* tmp *\/, false \/* weak *\/);\n-    }\n+    z_load_barrier(_masm, this, Address($mem$$Register), $dst$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -234,1 +213,1 @@\n-  predicate(UseZGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == ZLoadBarrierStrong);\n+  predicate(UseZGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);\n@@ -243,3 +222,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, false \/* weak *\/);\n-    }\n+    z_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n@@ -253,1 +230,1 @@\n-  predicate(UseZGC && needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == ZLoadBarrierStrong));\n+  predicate(UseZGC && needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() != 0));\n@@ -262,3 +239,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, false \/* weak *\/);\n-    }\n+    z_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, rscratch2 \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":14,"deletions":39,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,2 +35,5 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {\n-  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, weak);\n+static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+  if (barrier_data == ZLoadBarrierElided) {\n+    return;\t\t\t\/\/ Elided.\n+  }\n+  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, barrier_data);\n@@ -46,1 +49,1 @@\n-  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, false \/* weak *\/);\n+  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref, tmp, ZLoadBarrierStrong);\n@@ -64,1 +67,1 @@\n-  predicate(UseZGC && n->as_Load()->barrier_data() == ZLoadBarrierStrong);\n+  predicate(UseZGC && n->as_Load()->barrier_data() != 0);\n@@ -74,22 +77,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, $mem$$Address, $dst$$Register, noreg \/* tmp *\/, false \/* weak *\/);\n-    }\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Weak Pointer\n-instruct zLoadWeakP(rRegP dst, memory mem, rFlagsReg cr)\n-%{\n-  predicate(UseZGC && n->as_Load()->barrier_data() == ZLoadBarrierWeak);\n-  match(Set dst (LoadP mem));\n-  effect(KILL cr, TEMP dst);\n-\n-  ins_cost(125);\n-\n-  format %{ \"movq     $dst, $mem\" %}\n-\n-  ins_encode %{\n-    __ movptr($dst$$Register, $mem$$Address);\n-    z_load_barrier(_masm, this, $mem$$Address, $dst$$Register, noreg \/* tmp *\/, true \/* weak *\/);\n+    z_load_barrier(_masm, this, $mem$$Address, $dst$$Register, noreg \/* tmp *\/, barrier_data());\n@@ -110,1 +92,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n+    if (barrier_data() != ZLoadBarrierElided) { \/\/ barrier could be elided by ZBarrierSetC2::analyze_dominating_barriers()\n@@ -115,0 +97,1 @@\n+\n@@ -140,1 +123,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n+    if (barrier_data() != ZLoadBarrierElided) { \/\/ barrier could be elided by ZBarrierSetC2::analyze_dominating_barriers()\n@@ -145,0 +128,1 @@\n+\n@@ -163,1 +147,1 @@\n-  predicate(UseZGC && n->as_LoadStore()->barrier_data() == ZLoadBarrierStrong);\n+  predicate(UseZGC && n->as_LoadStore()->barrier_data() != 0);\n@@ -170,3 +154,1 @@\n-    if (barrier_data() != ZLoadBarrierElided) {\n-      z_load_barrier(_masm, this, Address(noreg, 0), $newval$$Register, noreg \/* tmp *\/, false \/* weak *\/);\n-    }\n+    z_load_barrier(_masm, this, Address(noreg, 0), $newval$$Register, noreg \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -393,0 +393,2 @@\n+  do_intrinsic(_Reference_refersTo0,     java_lang_ref_Reference, refersTo0_name, object_boolean_signature, F_R)        \\\n+  do_intrinsic(_PhantomReference_refersTo0, java_lang_ref_PhantomReference, refersTo0_name, object_boolean_signature, F_R) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+  template(refersTo0_name,                            \"refersTo0\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -607,0 +607,1 @@\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n@@ -608,0 +609,1 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n@@ -621,2 +623,2 @@\n-  bool need_read_barrier = in_heap && (on_weak ||\n-                                       (unknown && offset != top && obj != top));\n+  bool need_read_barrier = (((on_weak || on_phantom) && !no_keepalive) ||\n+                            (in_heap && unknown && offset != top && obj != top));\n@@ -632,1 +634,1 @@\n-  if (on_weak) {\n+  if (on_weak || on_phantom) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -999,3 +999,7 @@\n-    assert(!is_narrow, \"phantom access cannot be narrow\");\n-    calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n-    name = \"load_reference_barrier_phantom\";\n+    if (is_narrow) {\n+      calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom_narrow);\n+      name = \"load_reference_barrier_phantom_narrow\";\n+    } else {\n+      calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n+      name = \"load_reference_barrier_phantom\";\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,0 +80,4 @@\n+\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_phantom_narrow(oopDesc * src, narrowOop* load_addr))\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_PHANTOM_OOP_REF, narrowOop>(oop(src), load_addr);\n+JRT_END\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  static oopDesc* load_reference_barrier_phantom_narrow(oopDesc* src, narrowOop* load_addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,2 +67,1 @@\n-    if (mach->barrier_data() != ZLoadBarrierStrong &&\n-        mach->barrier_data() != ZLoadBarrierWeak) {\n+    if (mach->barrier_data() == ZLoadBarrierElided) {\n@@ -87,2 +86,2 @@\n-ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) {\n-  ZLoadBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, weak);\n+ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+  ZLoadBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZLoadBarrierStubC2(node, ref_addr, ref, tmp, barrier_data);\n@@ -96,1 +95,1 @@\n-ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak) :\n+ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) :\n@@ -101,1 +100,1 @@\n-    _weak(weak),\n+    _barrier_data(barrier_data),\n@@ -121,1 +120,13 @@\n-  const DecoratorSet decorators = _weak ? ON_WEAK_OOP_REF : ON_STRONG_OOP_REF;\n+  DecoratorSet decorators = DECORATORS_NONE;\n+  if (_barrier_data & ZLoadBarrierStrong) {\n+    decorators |= ON_STRONG_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierWeak) {\n+    decorators |= ON_WEAK_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierPhantom) {\n+    decorators |= ON_PHANTOM_OOP_REF;\n+  }\n+  if (_barrier_data & ZLoadBarrierNoKeepalive) {\n+    decorators |= AS_NO_KEEPALIVE;\n+  }\n@@ -321,0 +332,8 @@\n+        if ((mach->barrier_data() & ZLoadBarrierStrong) != 0) {\n+          barrier_loads.push(mach);\n+        }\n+        if ((mach->barrier_data() & (ZLoadBarrierStrong | ZLoadBarrierNoKeepalive)) ==\n+            ZLoadBarrierStrong) {\n+          mem_ops.push(mach);\n+        }\n+        break;\n@@ -324,1 +343,1 @@\n-        if (mach->barrier_data() == ZLoadBarrierStrong) {\n+        if ((mach->barrier_data() & ZLoadBarrierStrong) != 0) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,3 +32,5 @@\n-const uint8_t ZLoadBarrierStrong = 1;\n-const uint8_t ZLoadBarrierWeak   = 2;\n-const uint8_t ZLoadBarrierElided = 3;\n+const uint8_t ZLoadBarrierElided      = 0;\n+const uint8_t ZLoadBarrierStrong      = 1;\n+const uint8_t ZLoadBarrierWeak        = 2;\n+const uint8_t ZLoadBarrierPhantom     = 4;\n+const uint8_t ZLoadBarrierNoKeepalive = 8;\n@@ -42,1 +44,1 @@\n-  const bool      _weak;\n+  const int       _barrier_data;\n@@ -46,1 +48,1 @@\n-  ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak);\n+  ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data);\n@@ -49,1 +51,1 @@\n-  static ZLoadBarrierStubC2* create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak);\n+  static ZLoadBarrierStubC2* create(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data);\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  assert((decorators & AS_NO_KEEPALIVE) == 0, \"Unexpected decorator\");\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,12 @@\n+JRT_LEAF(oopDesc*, ZBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded(oopDesc* o, oop* p))\n+  return ZBarrier::weak_load_barrier_on_oop_field_preloaded(p, o);\n+JRT_END\n+\n+JRT_LEAF(oopDesc*, ZBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded(oopDesc* o, oop* p))\n+  return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(p, o);\n+JRT_END\n+\n+JRT_LEAF(oopDesc*, ZBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded(oopDesc* o, oop* p))\n+  return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+JRT_END\n+\n@@ -51,1 +63,5 @@\n-    return load_barrier_on_phantom_oop_field_preloaded_addr();\n+    if (decorators & AS_NO_KEEPALIVE) {\n+      return weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n+    } else {\n+      return load_barrier_on_phantom_oop_field_preloaded_addr();\n+    }\n@@ -53,1 +69,5 @@\n-    return load_barrier_on_weak_oop_field_preloaded_addr();\n+    if (decorators & AS_NO_KEEPALIVE) {\n+      return weak_load_barrier_on_weak_oop_field_preloaded_addr();\n+    } else {\n+      return load_barrier_on_weak_oop_field_preloaded_addr();\n+    }\n@@ -55,1 +75,5 @@\n-    return load_barrier_on_oop_field_preloaded_addr();\n+    if (decorators & AS_NO_KEEPALIVE) {\n+      return weak_load_barrier_on_oop_field_preloaded_addr();\n+    } else {\n+      return load_barrier_on_oop_field_preloaded_addr();\n+    }\n@@ -71,0 +95,12 @@\n+address ZBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr() {\n+  return reinterpret_cast<address>(weak_load_barrier_on_oop_field_preloaded);\n+}\n+\n+address ZBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr() {\n+  return reinterpret_cast<address>(weak_load_barrier_on_weak_oop_field_preloaded);\n+}\n+\n+address ZBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr() {\n+  return reinterpret_cast<address>(weak_load_barrier_on_phantom_oop_field_preloaded);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.cpp","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+  static oopDesc* weak_load_barrier_on_oop_field_preloaded(oopDesc* o, oop* p);\n+  static oopDesc* weak_load_barrier_on_weak_oop_field_preloaded(oopDesc* o, oop* p);\n+  static oopDesc* weak_load_barrier_on_phantom_oop_field_preloaded(oopDesc* o, oop* p);\n@@ -46,0 +49,3 @@\n+  static address weak_load_barrier_on_oop_field_preloaded_addr();\n+  static address weak_load_barrier_on_weak_oop_field_preloaded_addr();\n+  static address weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -617,0 +617,2 @@\n+  case vmIntrinsics::_Reference_refersTo0:\n+  case vmIntrinsics::_PhantomReference_refersTo0:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -525,0 +525,2 @@\n+  case vmIntrinsics::_Reference_refersTo0:      return inline_reference_refersTo0(false);\n+  case vmIntrinsics::_PhantomReference_refersTo0: return inline_reference_refersTo0(true);\n@@ -5276,1 +5278,1 @@\n-  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*is_exact*\/ false, \/*is_static*\/ true, crc32c_class);\n+  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n@@ -5467,8 +5469,4 @@\n-  const TypeInstPtr* tinst = _gvn.type(reference_obj)->isa_instptr();\n-  assert(tinst != NULL, \"obj is null\");\n-  assert(tinst->klass()->is_loaded(), \"obj is not loaded\");\n-  ciInstanceKlass* referenceKlass = tinst->klass()->as_instance_klass();\n-  ciField* field = referenceKlass->get_field_by_name(ciSymbol::make(\"referent\"),\n-                                                     ciSymbol::make(\"Ljava\/lang\/Object;\"),\n-                                                     false);\n-  assert (field != NULL, \"undefined field\");\n+  DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;\n+  Node* result = load_field_from_object(reference_obj, \"referent\", \"Ljava\/lang\/Object;\",\n+                                        decorators, \/*is_static*\/ false, NULL);\n+  if (result == NULL) return false;\n@@ -5476,2 +5474,3 @@\n-  Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);\n-  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  \/\/ Add memory barrier to prevent commoning reads from this field\n+  \/\/ across safepoint since GC can change its value.\n+  insert_mem_bar(Op_MemBarCPUOrder);\n@@ -5479,2 +5478,18 @@\n-  ciInstanceKlass* klass = env()->Object_klass();\n-  const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);\n+  set_result(result);\n+  return true;\n+}\n+\n+\/\/----------------------------inline_reference_refersTo0----------------------------\n+\/\/ bool java.lang.ref.Reference.refersTo0();\n+\/\/ bool java.lang.ref.PhantomReference.refersTo0();\n+bool LibraryCallKit::inline_reference_refersTo0(bool is_phantom) {\n+  \/\/ Get arguments:\n+  Node* reference_obj = null_check_receiver();\n+  Node* other_obj = argument(1);\n+  if (stopped()) return true;\n+\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent = load_field_from_object(reference_obj, \"referent\", \"Ljava\/lang\/Object;\",\n+                                          decorators, \/*is_static*\/ false, NULL);\n+  if (referent == NULL) return false;\n@@ -5482,2 +5497,0 @@\n-  DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;\n-  Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);\n@@ -5488,1 +5501,18 @@\n-  set_result(result);\n+  Node* cmp = _gvn.transform(new CmpPNode(referent, other_obj));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* if_node = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+  RegionNode* region = new RegionNode(3);\n+  PhiNode* phi = new PhiNode(region, TypeInt::BOOL);\n+\n+  Node* if_true = _gvn.transform(new IfTrueNode(if_node));\n+  region->init_req(1, if_true);\n+  phi->init_req(1, intcon(1));\n+\n+  Node* if_false = _gvn.transform(new IfFalseNode(if_node));\n+  region->init_req(2, if_false);\n+  phi->init_req(2, intcon(0));\n+\n+  set_control(_gvn.transform(region));\n+  record_for_igvn(region);\n+  set_result(_gvn.transform(phi));\n@@ -5493,3 +5523,3 @@\n-Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,\n-                                              bool is_exact=true, bool is_static=false,\n-                                              ciInstanceKlass * fromKls=NULL) {\n+Node* LibraryCallKit::load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString,\n+                                             DecoratorSet decorators = IN_HEAP, bool is_static = false,\n+                                             ciInstanceKlass* fromKls = NULL) {\n@@ -5500,1 +5530,0 @@\n-    assert(!is_exact || tinst->klass_is_exact(), \"klass not exact\");\n@@ -5536,2 +5565,0 @@\n-  DecoratorSet decorators = IN_HEAP;\n-\n@@ -5691,1 +5718,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -5712,1 +5739,1 @@\n-  Node* objRvec = load_field_from_object(cipherBlockChaining_object, \"r\", \"[B\", \/*is_exact*\/ false);\n+  Node* objRvec = load_field_from_object(cipherBlockChaining_object, \"r\", \"[B\");\n@@ -5779,1 +5806,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -5852,1 +5879,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(counterMode_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(counterMode_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -5869,1 +5896,1 @@\n-  Node* obj_counter = load_field_from_object(counterMode_object, \"counter\", \"[B\", \/*is_exact*\/ false);\n+  Node* obj_counter = load_field_from_object(counterMode_object, \"counter\", \"[B\");\n@@ -5873,1 +5900,1 @@\n-  Node* saved_encCounter = load_field_from_object(counterMode_object, \"encryptedCounter\", \"[B\", \/*is_exact*\/ false);\n+  Node* saved_encCounter = load_field_from_object(counterMode_object, \"encryptedCounter\", \"[B\");\n@@ -5897,1 +5924,1 @@\n-  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\", \/*is_exact*\/ false);\n+  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\");\n@@ -5904,1 +5931,1 @@\n-  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\", \/*is_exact*\/ false);\n+  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\");\n@@ -5931,1 +5958,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objCBC, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objCBC, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -5994,1 +6021,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objECB, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objECB, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6054,1 +6081,1 @@\n-  Node* embeddedCipherObj = load_field_from_object(objCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\", \/*is_exact*\/ false);\n+  Node* embeddedCipherObj = load_field_from_object(objCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n@@ -6415,1 +6442,1 @@\n-  Node* digest_state = load_field_from_object(digest_object, \"state\", state_type, \/*is_exact*\/ false);\n+  Node* digest_state = load_field_from_object(digest_object, \"state\", state_type);\n@@ -6426,1 +6453,1 @@\n-  Node* digest_length = load_field_from_object(digest_object, \"digestLength\", \"I\", \/*is_exact*\/ false);\n+  Node* digest_length = load_field_from_object(digest_object, \"digestLength\", \"I\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":62,"deletions":35,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -184,2 +184,2 @@\n-  Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);\n-  Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);\n+  Node* load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, DecoratorSet decorators, bool is_static, ciInstanceKlass* fromKls);\n+  Node* field_address_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass* fromKls);\n@@ -267,0 +267,1 @@\n+  bool inline_reference_refersTo0(bool is_phantom);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-  void set_barrier_data(uint data) { _barrier = data; }\n+  void set_barrier_data(uint8_t data) { _barrier = data; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -69,0 +70,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,0 +362,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256377\n+ * @summary Based on test\/jdk\/java\/lang\/ref\/ReferenceRefersTo.java.\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+\n+public class TestReferenceRefersTo {\n+    private static final void fail(String msg) throws Exception {\n+        throw new RuntimeException(msg);\n+    }\n+\n+    \/\/ Test java.lang.ref.Reference::refersTo0 intrinsic.\n+    private static final void test(Reference ref,\n+                                   Object expectedValue,\n+                                   Object unexpectedValue,\n+                                   String kind) throws Exception {\n+        if ((expectedValue != null) && ref.refersTo(null)) {\n+            fail(kind + \" refers to null\");\n+        }\n+        if (!ref.refersTo(expectedValue)) {\n+            fail(kind + \" doesn't refer to expected value\");\n+        }\n+        if (ref.refersTo(unexpectedValue)) {\n+            fail(kind + \" refers to unexpected value\");\n+        }\n+    }\n+\n+    \/\/ Test java.lang.ref.PhantomReference::refersTo0 intrinsic.\n+    private static final void test_phantom(PhantomReference ref,\n+                                           Object expectedValue,\n+                                           Object unexpectedValue) throws Exception {\n+        String kind = \"phantom\";\n+        if ((expectedValue != null) && ref.refersTo(null)) {\n+            fail(kind + \" refers to null\");\n+        }\n+        if (!ref.refersTo(expectedValue)) {\n+            fail(kind + \" doesn't refer to expected value\");\n+        }\n+        if (ref.refersTo(unexpectedValue)) {\n+            fail(kind + \" refers to unexpected value\");\n+        }\n+\n+    }\n+\n+    private static final void test_weak(WeakReference ref,\n+                                        Object expectedValue,\n+                                        Object unexpectedValue) throws Exception {\n+        test(ref, expectedValue, unexpectedValue, \"weak\");\n+    }\n+\n+    private static final void test_soft(SoftReference ref,\n+                                        Object expectedValue,\n+                                        Object unexpectedValue) throws Exception {\n+        test(ref, expectedValue, unexpectedValue, \"soft\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var queue = new ReferenceQueue<Object>();\n+\n+        var obj0 = new Object();\n+        var obj1 = new Object();\n+        var obj2 = new Object();\n+        var obj3 = new Object();\n+\n+        var pref = new PhantomReference(obj0, queue);\n+        var wref = new WeakReference(obj1);\n+        var sref = new SoftReference(obj2);\n+\n+        System.out.println(\"Warmup\");\n+        for (int i = 0; i < 10000; i++) {\n+            test_phantom(pref, obj0, obj3);\n+            test_weak(wref, obj1, obj3);\n+            test_soft(sref, obj2, obj3);\n+        }\n+\n+        System.out.println(\"Testing starts\");\n+        test_phantom(pref, obj0, obj3);\n+        test_weak(wref, obj1, obj3);\n+        test_soft(sref, obj2, obj3);\n+\n+        System.out.println(\"Cleaning references\");\n+        pref.clear();\n+        wref.clear();\n+        sref.clear();\n+\n+        System.out.println(\"Testing after cleaning\");\n+        test_phantom(pref, null, obj3);\n+        test_weak(wref, null, obj3);\n+        test_soft(sref, null, obj3);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestReferenceRefersTo.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}