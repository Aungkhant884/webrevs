{"files":[{"patch":"@@ -1275,0 +1275,8 @@\n+      if (n->is_Proj()) {\n+        assert(j >= 1, \"a projection cannot be the first instruction in a block\");\n+        Node* pred = block->get_node(j - 1);\n+        Node* parent = n->in(0);\n+        assert(parent != NULL, \"projections must have a parent\");\n+        assert(pred == parent || (pred->is_Proj() && pred->in(0) == parent),\n+               \"projections must follow their parents or other sibling projections\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1393,1 +1393,1 @@\n-  for(uint i4 = 0; i4 < block->_num_succs; i4++ ) {\n+  for (uint i4 = 0; i4 < block->_num_succs; i4++) {\n@@ -1396,5 +1396,4 @@\n-    \/\/ Remove any newly created, but dead, nodes. In this context, a dead node\n-    \/\/ is either a multi-node with all projections unused, or a non-projection\n-    \/\/ single node that is unused. This definition avoids removing unused\n-    \/\/ projections of partially-used multi-nodes.\n-    for( uint j = new_cnt; j > 0; j-- ) {\n+    \/\/ Remove any newly created, but dead, nodes by traversing their schedule\n+    \/\/ backwards. Here, a dead node is a node whose only outputs (if any) are\n+    \/\/ unused projections.\n+    for (uint j = new_cnt; j > 0; j--) {\n@@ -1402,0 +1401,2 @@\n+      \/\/ Individual projections are examined together with all siblings when\n+      \/\/ their parent is visited.\n@@ -1407,2 +1408,3 @@\n-        Node* user = n->fast_out(i);\n-        if (!user->is_Proj() || user->outcnt() > 0) {\n+        Node* out = n->fast_out(i);\n+        \/\/ n is live if it has a non-projection output or a used projection.\n+        if (!out->is_Proj() || out->outcnt() > 0) {\n@@ -1414,5 +1416,7 @@\n-        \/\/ Remove projections if n is a dead multi-node.\n-        for (uint k = j + n->outcnt(); sb->get_node(k)->is_Proj(); k--) {\n-          assert(sb->get_node(k)->in(0) == n,\n-                 \"dead projection should correspond to current node\");\n-          sb->get_node(k)->disconnect_inputs(C);\n+        \/\/ n's only outputs (if any) are unused projections scheduled next to n\n+        \/\/ (see PhaseCFG::select()). Remove these projections backwards.\n+        for (uint k = j + n->outcnt(); k > j; k--) {\n+          Node* proj = sb->get_node(k);\n+          assert(proj->is_Proj() && proj->in(0) == n,\n+                 \"projection should correspond to dead node\");\n+          proj->disconnect_inputs(C);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}