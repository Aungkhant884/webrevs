{"files":[{"patch":"@@ -209,5 +209,6 @@\n-        \/\/ The key is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        byte[] result = key.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        try {\n+            return key.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -229,1 +230,6 @@\n-        return passwd.clone();\n+        try {\n+            return passwd.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -245,3 +251,10 @@\n-        int retval = 0;\n-        for (int i = 1; i < this.key.length; i++) {\n-            retval += this.key[i] * i;\n+        try {\n+            int retval = 0;\n+            for (int i = 1; i < this.key.length; i++) {\n+                retval += this.key[i] * i;\n+            }\n+            return (retval ^= getAlgorithm().toLowerCase\n+                    (Locale.ENGLISH).hashCode());\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n@@ -249,1 +262,0 @@\n-        return(retval ^= getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode());\n@@ -253,2 +265,4 @@\n-        if (obj == this)\n-            return true;\n+        try {\n+            if (obj == this) {\n+                return true;\n+            }\n@@ -256,2 +270,3 @@\n-        if (!(obj instanceof SecretKey))\n-            return false;\n+            if (!(obj instanceof SecretKey)) {\n+                return false;\n+            }\n@@ -259,1 +274,1 @@\n-        SecretKey that = (SecretKey) obj;\n+            SecretKey that = (SecretKey) obj;\n@@ -261,8 +276,14 @@\n-        if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))\n-            return false;\n-        if (!(that.getFormat().equalsIgnoreCase(\"RAW\")))\n-            return false;\n-        byte[] thatEncoded = that.getEncoded();\n-        boolean ret = MessageDigest.isEqual(key, thatEncoded);\n-        Arrays.fill(thatEncoded, (byte)0x00);\n-        return ret;\n+            if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm()))) {\n+                return false;\n+            }\n+            if (!(that.getFormat().equalsIgnoreCase(\"RAW\"))) {\n+                return false;\n+            }\n+            byte[] thatEncoded = that.getEncoded();\n+            boolean ret = MessageDigest.isEqual(key, thatEncoded);\n+            Arrays.fill(thatEncoded, (byte)0x00);\n+            return ret;\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -281,2 +302,7 @@\n-        return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n-                getFormat(), key);\n+        try {\n+            return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n+                    getFormat(), key);\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":51,"deletions":25,"binary":false,"changes":76,"status":"modified"}]}