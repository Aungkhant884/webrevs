{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug InterruptAtExit\n+ * @run main\/othervm InterruptAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"InterruptAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,2 @@\n-            \/\/ ignore because we expect one\n+            \/\/ Ignore because we are testing java.lang.Thread.interrupt()\n+            \/\/ and one may arrive before we leave the 'try { }' block.\n@@ -54,1 +54,11 @@\n-        InterruptAtExit threads[] = new InterruptAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n@@ -56,4 +66,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new InterruptAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            InterruptAtExit thread = new InterruptAtExit();\n+            thread.start();\n@@ -62,7 +77,6 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ The first interrupt() call will break the\n-                \/\/ worker out of the exitSyncObj.await() call\n-                \/\/ and the rest will come in during thread exit.\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].interrupt();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.interrupt() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.interrupt();\n@@ -70,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -80,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.interrupt()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.interrupt() \" +\n-                               \"call after thread exit.\");\n-\n@@ -89,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -93,5 +99,1 @@\n-            threads[i].interrupt();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.interrupt();\n@@ -100,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -106,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/InterruptAtExit.java","additions":49,"deletions":35,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug IsInterruptedAtExit\n+ * @run main\/othervm IsInterruptedAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"IsInterruptedAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -54,1 +53,11 @@\n-        IsInterruptedAtExit threads[] = new IsInterruptedAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n@@ -56,4 +65,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new IsInterruptedAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            IsInterruptedAtExit thread = new IsInterruptedAtExit();\n+            thread.start();\n@@ -62,8 +76,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out of\n-                \/\/ the exitSyncObj.await() call and the isInterrupted()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].isInterrupted();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.isInterrupted() calls will come in during\n+                \/\/ thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.isInterrupted();\n@@ -71,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -81,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.isInterrupted()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.isInterrupted() \" +\n-                               \"call after thread exit.\");\n-\n@@ -90,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -94,5 +99,1 @@\n-            threads[i].isInterrupted();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.isInterrupted();\n@@ -101,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -107,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/IsInterruptedAtExit.java","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8167108\n- * @summary Stress test java.lang.Thread.resume() at thread exit.\n- * @run main\/othervm -Xlog:thread+smr=debug ResumeAtExit\n- *\/\n-\n-import java.util.concurrent.CountDownLatch;\n-\n-public class ResumeAtExit extends Thread {\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n-\n-    public CountDownLatch exitSyncObj = new CountDownLatch(1);\n-    public CountDownLatch startSyncObj = new CountDownLatch(1);\n-\n-    @Override\n-    public void run() {\n-        \/\/ Tell main thread we have started.\n-        startSyncObj.countDown();\n-        try {\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n-            exitSyncObj.await();\n-        } catch (InterruptedException e) {\n-            \/\/ ignore because we expect one\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        ResumeAtExit threads[] = new ResumeAtExit[N_THREADS];\n-\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new ResumeAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n-            try {\n-                \/\/ Wait for the worker thread to get going.\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the resume()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].resume();\n-\n-                    if (!threads[i].isAlive()) {\n-                        \/\/ Done with Thread.resume() calls since\n-                        \/\/ thread is not alive.\n-                        break;\n-                    }\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.resume()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.resume() \" +\n-                               \"call after thread exit.\");\n-\n-            try {\n-                threads[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-            threads[i].resume();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n-        }\n-\n-        String cmd = System.getProperty(\"sun.java.command\");\n-        if (cmd != null && !cmd.startsWith(\"com.sun.javatest.regtest.agent.MainWrapper\")) {\n-            \/\/ Exit with success in a non-JavaTest environment:\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ResumeAtExit.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug SetNameAtExit\n+ * @run main\/othervm SetNameAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"SetNameAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -54,1 +53,11 @@\n-        SetNameAtExit threads[] = new SetNameAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n@@ -56,4 +65,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new SetNameAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            SetNameAtExit thread = new SetNameAtExit();\n+            thread.start();\n@@ -62,8 +76,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the setName()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].setName(\"T\" + i + \"-\" + late_count);\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.setName() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                long late_count = 0;\n+                while (true) {\n+                    thread.setName(\"T\" + count + \"-\" + late_count++);\n@@ -71,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -81,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.setName()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.setName() \" +\n-                               \"call after thread exit.\");\n-\n@@ -90,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -94,5 +99,1 @@\n-            threads[i].setName(\"T\" + i + \"-done\");\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.setName(\"T\" + count + \"-done\");\n@@ -101,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -107,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/SetNameAtExit.java","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug SetPriorityAtExit\n+ * @run main\/othervm SetPriorityAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"SetPriorityAtExit\";\n@@ -37,2 +37,2 @@\n-    final static int MIN = java.lang.Thread.MIN_PRIORITY;\n-    final static int NORM = java.lang.Thread.NORM_PRIORITY;\n+    private final static int MIN = java.lang.Thread.MIN_PRIORITY;\n+    private final static int NORM = java.lang.Thread.NORM_PRIORITY;\n@@ -48,2 +48,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -52,1 +51,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -57,1 +56,11 @@\n-        SetPriorityAtExit threads[] = new SetPriorityAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n@@ -59,0 +68,3 @@\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -60,4 +72,5 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new SetPriorityAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            SetPriorityAtExit thread = new SetPriorityAtExit();\n+            thread.start();\n@@ -66,8 +79,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out of\n-                \/\/ the exitSyncObj.await() call and the setPriority()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].setPriority(prio);\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.setPriority() calls will come in during\n+                \/\/ thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.setPriority(prio);\n@@ -80,1 +92,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -89,8 +101,1 @@\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.setPriority()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.setPriority() \" +\n-                               \"call after thread exit.\");\n+            thread.setPriority(prio);\n@@ -99,1 +104,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -103,5 +108,1 @@\n-            threads[i].setPriority(prio);\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.setPriority(prio);\n@@ -110,0 +111,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -116,0 +120,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/SetPriorityAtExit.java","additions":51,"deletions":38,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug StopAtExit\n+ * @run main\/othervm StopAtExit\n@@ -35,2 +35,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"StopAtExit\";\n@@ -47,2 +47,1 @@\n-                \/\/ Wait for main thread to interrupt us so we\n-                \/\/ can race to exit.\n+                \/\/ Wait for main thread to tell us to race to the exit.\n@@ -51,1 +50,1 @@\n-                \/\/ ignore because we expect one\n+                throw new RuntimeException(\"Unexpected: \" + e);\n@@ -61,1 +60,11 @@\n-        StopAtExit threads[] = new StopAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n@@ -63,4 +72,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new StopAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            StopAtExit thread = new StopAtExit();\n+            thread.start();\n@@ -69,8 +83,6 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the stop()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].stop();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.stop() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.stop();\n@@ -78,1 +90,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -93,8 +105,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.stop()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.stop() \" +\n-                               \"call after thread exit.\");\n-\n@@ -102,1 +106,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -106,5 +110,1 @@\n-            threads[i].stop();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.stop();\n@@ -113,0 +113,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -119,0 +122,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":48,"deletions":36,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+    private final static String AGENT_LIB = \"objmonusage006\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -34,3 +36,0 @@\n-    final static int N_LATE_CHECKS = 1000;\n-    final static int N_THREADS = 10;\n-\n@@ -39,1 +38,1 @@\n-            System.loadLibrary(\"objmonusage006\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -41,1 +40,1 @@\n-            System.err.println(\"Could not load objmonusage006 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -62,0 +61,15 @@\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -63,2 +77,3 @@\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting LockingThread #\" + i + \".\");\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -89,3 +104,1 @@\n-                System.out.println(\"LockingThread #\" + i + \" starting \"\n-                                   + N_LATE_CHECKS + \" late checks.\");\n-                for (int j = 0; j < N_LATE_CHECKS; j++) {\n+                while (true) {\n@@ -95,1 +108,7 @@\n-                        return res;\n+                        break;\n+                    }\n+\n+                    if (!thr.isAlive()) {\n+                        \/\/ Done with JVM\/TI GetObjectMonitorUsage() calls\n+                        \/\/ since thread is not alive.\n+                        break;\n@@ -98,2 +117,6 @@\n-                System.out.println(\"LockingThread #\" + i + \" ran \"\n-                                   + N_LATE_CHECKS + \" late checks.\");\n+            }\n+\n+            try {\n+                thr.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n@@ -103,0 +126,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -106,0 +132,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,0 +40,1 @@\n+ * @requires vm.jvmti\n@@ -42,1 +44,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+    private final static String AGENT_LIB = \"intrpthrd003\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -35,1 +37,1 @@\n-            System.loadLibrary(\"intrpthrd003\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -37,1 +39,1 @@\n-            System.err.println(\"Could not load intrpthrd003 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -44,1 +46,1 @@\n-    native static int check(int ind, Thread thr);\n+    native static int check(long ind, Thread thr);\n@@ -54,34 +56,5 @@\n-    public static int run(String argv[], PrintStream ref) {\n-        intrpthrd003a runn[] = new intrpthrd003a[THREADS_NUMBER];\n-\n-        System.out.println(\"Case 1: JVM\/TI InterruptThread()\");\n-        for (int i = 0; i < THREADS_NUMBER; i++ ) {\n-            runn[i] = new intrpthrd003a();\n-            int late_count = 1;\n-            synchronized (runn[i].syncObject) {\n-                runn[i].start();\n-                try {\n-                    runn[i].syncObject.wait();\n-\n-                    for (; late_count <= N_LATE_CALLS; late_count++) {\n-                        if (check(i, runn[i]) == 2) break;\n-\n-                        if (isThreadNotAliveError()) {\n-                            \/\/ Done with InterruptThread() calls since\n-                            \/\/ thread is not alive.\n-                            break;\n-                        }\n-                    }\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to JVM\/TI InterruptThread()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause an InterruptThread() \" +\n-                               \"call after thread exit.\");\n-\n+    public static int run(String args[], PrintStream ref) {\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n@@ -89,8 +62,4 @@\n-                runn[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-            if (check(i, runn[i]) == 2) break;\n-            if (!isThreadNotAliveError()) {\n-                throw new Error(\"Expected JVMTI_ERROR_THREAD_NOT_ALIVE \" +\n-                                \"after thread #\" + i + \" has been join()'ed\");\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n@@ -100,4 +69,6 @@\n-        int res = getResult();\n-        if (res != 0) {\n-            return res;\n-        }\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -105,6 +76,3 @@\n-        System.out.println(\"Case 2: java.lang.Thread.interrupt()\");\n-        for (int i = 0; i < THREADS_NUMBER; i++ ) {\n-            runn[i] = new intrpthrd003a();\n-            int late_count = 1;\n-            synchronized (runn[i].syncObject) {\n-                runn[i].start();\n+            intrpthrd003a thr = new intrpthrd003a();\n+            synchronized (thr.syncObject) {\n+                thr.start();\n@@ -112,1 +80,1 @@\n-                    runn[i].syncObject.wait();\n+                    thr.syncObject.wait();\n@@ -114,2 +82,2 @@\n-                    for (; late_count <= N_LATE_CALLS; late_count++) {\n-                        runn[i].interrupt();\n+                    while (true) {\n+                        if (check(count, thr) == 2) break;\n@@ -117,2 +85,2 @@\n-                        if (!runn[i].isAlive()) {\n-                            \/\/ Done with Thread.interrupt() calls since\n+                        if (isThreadNotAliveError()) {\n+                            \/\/ Done with InterruptThread() calls since\n@@ -128,8 +96,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.interrupt()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.interrupt() \" +\n-                               \"call after thread exit.\");\n-\n@@ -137,1 +97,1 @@\n-                runn[i].join();\n+                thr.join();\n@@ -141,5 +101,1 @@\n-            runn[i].interrupt();\n-            if (runn[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            if (check(count, thr) == 2) break;\n@@ -148,1 +104,13 @@\n-        return res;\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        return getResult();\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003.java","additions":44,"deletions":76,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -44,0 +45,1 @@\n+ * @requires vm.jvmti\n@@ -47,1 +49,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jni_tools.h\"\n@@ -93,1 +94,1 @@\n-        jint ind, jthread thr) {\n+        jlong ind, jthread thr) {\n@@ -106,1 +107,1 @@\n-            printf(\"(thr#%d) error expected: JVMTI_ERROR_NONE or JVMTI_ERROR_THREAD_NOT_ALIVE,\", ind);\n+            printf(\"(thr#%\" LL \"d) error expected: JVMTI_ERROR_NONE or JVMTI_ERROR_THREAD_NOT_ALIVE,\", ind);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/intrpthrd003.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,3 @@\n+    private final static String AGENT_LIB = \"popframe011\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+\n@@ -49,2 +52,0 @@\n-    static final int N_LATE_CALLS = 100;\n-\n@@ -61,1 +62,1 @@\n-            System.loadLibrary(\"popframe011\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -63,1 +64,1 @@\n-            System.err.println(\"Could not load popframe011 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -84,0 +85,28 @@\n+        int timeMax = 0;\n+        if (argv.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            int argIndex = 0;\n+            int argvLeft = argv.length;\n+            if (argv[0].equals(\"-v\")) {\n+                DEBUG_MODE = true;\n+                argIndex = 1;\n+                argvLeft--;\n+            }\n+            if (argvLeft == 0) {\n+                timeMax = DEF_TIME_MAX;\n+            } else if (argvLeft == 1) {\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(argv[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + argv[argIndex] +\n+                                       \"': invalid timeMax value.\");\n+                    usage();\n+                }\n+            } else {\n+                usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n@@ -87,1 +116,0 @@\n-\n@@ -89,4 +117,0 @@\n-        for (int i = 0; i < argv.length; i++) {\n-            if (argv[i].equals(\"-v\")) \/\/ verbose mode\n-                DEBUG_MODE = true;\n-        }\n@@ -94,4 +118,10 @@\n-        popFrameClsThr = new popFrameCls();\n-        synchronized (barrier) { \/\/ force a child thread to pause\n-            synchronized(readi) {\n-                popFrameClsThr.start(); \/\/ start the child thread\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            popFdone = false;\n+\n+            popFrameClsThr = new popFrameCls();\n+            synchronized (barrier) { \/\/ force a child thread to pause\n+                synchronized(readi) {\n+                    popFrameClsThr.start(); \/\/ start the child thread\n@@ -99,6 +129,7 @@\n-                try {\n-                    readi.wait(); \/\/ wait for the child readiness\n-                } catch (Exception e) {\n-                    out.println(\"TEST FAILURE: waiting for \" +\n-                        popFrameClsThr.toString() + \": caught \" + e);\n-                    return FAILED;\n+                    try {\n+                        readi.wait(); \/\/ wait for the child readiness\n+                    } catch (Exception e) {\n+                        out.println(\"TEST FAILURE: waiting for \" +\n+                            popFrameClsThr.toString() + \": caught \" + e);\n+                        return FAILED;\n+                    }\n@@ -106,1 +137,0 @@\n-            }\n@@ -110,9 +140,9 @@\n-            if (DEBUG_MODE)\n-                totRes = retValue = doPopFrame(1, popFrameClsThr);\n-            else\n-                totRes = retValue = doPopFrame(0, popFrameClsThr);\n-            if (DEBUG_MODE && retValue == PASSED)\n-                out.println(\"Check #1 PASSED:\\n\" +\n-                    \"\\tPopFrame(), being invoked with NULL pointer \" +\n-                    \"to the thread,\\n\" +\n-                    \"\\treturned the appropriate error JVMTI_ERROR_NULL_POINTER\");\n+                if (DEBUG_MODE)\n+                    totRes = retValue = doPopFrame(1, popFrameClsThr);\n+                else\n+                    totRes = retValue = doPopFrame(0, popFrameClsThr);\n+                if (DEBUG_MODE && retValue == PASSED)\n+                    out.println(\"Check #1 PASSED:\\n\" +\n+                        \"\\tPopFrame(), being invoked with NULL pointer \" +\n+                        \"to the thread,\\n\" +\n+                        \"\\treturned the appropriate error JVMTI_ERROR_NULL_POINTER\");\n@@ -123,14 +153,14 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(3, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(2, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #3 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the invalid thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_INVALID_THREAD\");\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(3, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(2, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #3 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the invalid thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_INVALID_THREAD\");\n@@ -141,17 +171,17 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(5, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(4, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #5 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the non suspended thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n-        }\n-        \/\/\n-        \/\/ Original popframe002 test block ends here.\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(5, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(4, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #5 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the non suspended thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+            }\n+            \/\/\n+            \/\/ Original popframe002 test block ends here.\n@@ -159,2 +189,1 @@\n-        int late_count = 1;\n-        for (; late_count <= N_LATE_CALLS; late_count++) {\n+            while (true) {\n@@ -165,16 +194,27 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(7, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(6, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #7 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the non suspended and is exiting thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n-            if (isThreadNotAliveError()) {\n-                \/\/ Done with PopFrame() calls since thread is not alive.\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(7, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(6, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #7 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the non suspended and is exiting thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+                if (isThreadNotAliveError()) {\n+                    \/\/ Done with PopFrame() calls since thread is not alive.\n+                    break;\n+                }\n+            }\n+\n+            try {\n+                popFrameClsThr.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+\n+            if (totRes != PASSED) {\n@@ -185,6 +225,2 @@\n-        out.println(\"INFO: made \" + late_count +\n-                    \" late calls to JVM\/TI PopFrame()\");\n-        out.println(\"INFO: N_LATE_CALLS==\" + N_LATE_CALLS + \" value is \" +\n-                    ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                    \"large enough to cause a PopFrame() call after thread \" +\n-                    \"exit.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -195,0 +231,10 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [-v][time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    -v       ::= verbose mode\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011.java","additions":131,"deletions":85,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,0 +40,1 @@\n+ * @requires vm.jvmti\n@@ -42,1 +44,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+    private final static String AGENT_LIB = \"suspendthrd003\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -33,1 +35,1 @@\n-    final static int N_THREADS = 10;\n+    public static Wicket mainEntrance;\n@@ -37,1 +39,1 @@\n-        System.loadLibrary(\"suspendthrd003\");\n+        System.loadLibrary(AGENT_LIB);\n@@ -70,2 +72,20 @@\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting TestedThread #\" + i + \".\");\n+        String[] args = argHandler.getArguments();\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        int res = -1;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -79,0 +99,1 @@\n+            mainEntrance = new Wicket();\n@@ -85,3 +106,1 @@\n-                if (!thread.checkReady()) {\n-                    throw new Failure(\"Unable to prepare tested thread: \" + thread);\n-                }\n+                mainEntrance.waitFor();\n@@ -125,0 +144,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -127,0 +149,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n@@ -133,1 +164,0 @@\n-    private volatile boolean threadReady = false;\n@@ -145,1 +175,1 @@\n-        threadReady = true;\n+        suspendthrd003.mainEntrance.unlock();\n@@ -160,12 +190,0 @@\n-    \/\/ check if thread is ready\n-    public boolean checkReady() {\n-        try {\n-            while (!threadReady) {\n-                sleep(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(\"Interruption while preparing tested thread: \\n\\t\" + e);\n-        }\n-        return threadReady;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003.java","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -173,0 +174,1 @@\n+ * @requires vm.jvmti\n@@ -176,1 +178,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-#define N_LATE_CALLS    10000\n@@ -57,1 +56,0 @@\n-        int late_count;\n@@ -100,5 +98,1 @@\n-        \/*\n-         * Using printf() instead of NSK_DISPLAY1() in this loop\n-         * in order to slow down the rate of SuspendThread() calls.\n-         *\/\n-        for (late_count = 0; late_count < N_LATE_CALLS; late_count++) {\n+        while (true) {\n@@ -106,1 +100,1 @@\n-            printf(\"INFO: Late suspend thread: %p\\n\", (void*)testedThread);\n+            NSK_DISPLAY1(\"INFO: Late suspend thread: %p\\n\", (void*)testedThread);\n@@ -109,1 +103,4 @@\n-                printf(\"INFO: Late suspend thread err: %d\\n\", l_err);\n+                if (l_err != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                    NSK_DISPLAY1(\"INFO: Late suspend thread err: %d\\n\", l_err);\n+                    nsk_jvmti_setFailStatus();\n+                }\n@@ -119,0 +116,1 @@\n+                break;\n@@ -122,6 +120,0 @@\n-        printf(\"INFO: made %d late calls to JVM\/TI SuspendThread()\\n\",\n-               late_count);\n-        printf(\"INFO: N_LATE_CALLS == %d value is %slarge enough to cause a \"\n-               \"SuspendThread() call after thread exit.\\n\", N_LATE_CALLS,\n-               (late_count == N_LATE_CALLS) ? \"NOT \" : \"\");\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/suspendthrd003.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,4 @@\n-    private static Wicket mainEntrance = new Wicket();\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"issuspended002\";\n+\n+    private static Wicket mainEntrance;\n@@ -33,0 +36,1 @@\n+    private static Object waiter = new Object();\n@@ -39,15 +43,10 @@\n-        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n-        MyThread thread = new MyThread(out);\n-        thread.start();\n-\n-        \/\/ Wait for MyThread to start\n-        mainEntrance.waitFor();\n-\n-        long id = thread.getId();\n-        ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        boolean isSuspended = info.isSuspended();\n-        if (isSuspended) {\n-            out.println(\"Failure 1.\");\n-            out.println(\"ThreadInfo.isSuspended() returned true, before \"\n-                      + \"Thread.suspend() was invoked.\");\n-            testFailed = true;\n+        int timeMax = 0;\n+        if (argv.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(argv[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + argv[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n@@ -56,9 +55,1 @@\n-        thread.suspend();\n-        info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        isSuspended = info.isSuspended();\n-        if (!isSuspended) {\n-            out.println(\"Failure 2.\");\n-            out.println(\"ThreadInfo.isSuspended() returned false, after \"\n-                      + \"Thread.suspend() was invoked.\");\n-            testFailed = true;\n-        }\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n@@ -66,9 +57,12 @@\n-        thread.resume();\n-        info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        isSuspended = info.isSuspended();\n-        if (isSuspended) {\n-            out.println(\"Failure 3.\");\n-            out.println(\"ThreadInfo.isSuspended() returned true, after \"\n-                      + \"Thread.resume() was invoked.\");\n-            testFailed = true;\n-        }\n+        long count = 0;\n+        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            MyThread thread = new MyThread(out);\n+            mainEntrance = new Wicket();\n+            thread.start();\n+\n+            \/\/ Wait for MyThread to start\n+            mainEntrance.waitFor();\n@@ -76,1 +70,10 @@\n-        thread.die = true;\n+            long id = thread.getId();\n+            ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+            boolean isSuspended = info.isSuspended();\n+            if (isSuspended) {\n+                out.println(\"Failure 1.\");\n+                out.println(\"ThreadInfo.isSuspended() returned true, before \"\n+                            + \"Thread.suspend() was invoked.\");\n+                testFailed = true;\n+                break;\n+            }\n@@ -78,2 +81,1 @@\n-        int count = 0;\n-        while (true) {\n+            thread.suspend();\n@@ -81,2 +83,6 @@\n-            if (info == null) {\n-                \/\/ the thread has exited\n+            isSuspended = info.isSuspended();\n+            if (!isSuspended) {\n+                out.println(\"Failure 2.\");\n+                out.println(\"ThreadInfo.isSuspended() returned false, after \"\n+                            + \"Thread.suspend() was invoked.\");\n+                testFailed = true;\n@@ -85,1 +91,3 @@\n-            count++;\n+\n+            thread.resume();\n+            info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n@@ -88,1 +96,1 @@\n-                out.println(\"Failure 4.\");\n+                out.println(\"Failure 3.\");\n@@ -90,1 +98,1 @@\n-                          + \"thread.die was set to true.\");\n+                            + \"Thread.resume() was invoked.\");\n@@ -94,0 +102,21 @@\n+\n+            synchronized (waiter) {\n+                thread.die = true;\n+                waiter.notifyAll();\n+            }\n+\n+            while (true) {\n+                info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+                if (info == null) {\n+                    \/\/ the thread has exited\n+                    break;\n+                }\n+                isSuspended = info.isSuspended();\n+                if (isSuspended) {\n+                    out.println(\"Failure 4.\");\n+                    out.println(\"ThreadInfo.isSuspended() returned true, after \"\n+                                + \"thread.die was set to true.\");\n+                    testFailed = true;\n+                    break;\n+                }\n+            }\n@@ -96,1 +125,2 @@\n-        out.println(\"INFO: made \" + count + \" late getThreadInfo() calls.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -103,0 +133,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n@@ -104,2 +143,1 @@\n-        final static long WAIT_TIME = 500; \/\/ Milliseconds\n-        Object object = new Object();\n+        final static long WAIT_TIME = 10; \/\/ Milliseconds\n@@ -119,1 +157,1 @@\n-                synchronized(object) {\n+                synchronized(waiter) {\n@@ -121,1 +159,1 @@\n-                        object.wait(WAIT_TIME);\n+                        waiter.wait(WAIT_TIME);\n@@ -126,0 +164,1 @@\n+                        break;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":87,"deletions":48,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,1 +40,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,4 @@\n-    private static Wicket mainEntrance = new Wicket();\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"find006\";\n+\n+    private static Wicket mainEntrance;\n@@ -34,0 +37,1 @@\n+    private static Object waiter = new Object();\n@@ -41,0 +45,14 @@\n+\n+        String[] args = argHandler.getArguments();\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                    usage();\n+            }\n+        }\n+\n@@ -63,0 +81,3 @@\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -64,2 +85,3 @@\n-        MyThread thread = new MyThread(out);\n-        thread.start();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -67,3 +89,3 @@\n-        \/\/ Wait for MyThread to start\n-        mainEntrance.waitFor();\n-        id = thread.getId();\n+            MyThread thread = new MyThread(out);\n+            mainEntrance = new Wicket();\n+            thread.start();\n@@ -71,1 +93,3 @@\n-        thread.die = true;\n+            \/\/ Wait for MyThread to start\n+            mainEntrance.waitFor();\n+            id = thread.getId();\n@@ -73,8 +97,18 @@\n-        int count = 0;\n-        while (true) {\n-            ids = monitor.findMonitorDeadlockedThreads();\n-            count++;\n-            ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-            if (info == null) {\n-                \/\/ the thread has exited\n-                break;\n+            synchronized (waiter) {\n+                thread.die = true;\n+                waiter.notifyAll();\n+            }\n+\n+            while (true) {\n+                ids = monitor.findMonitorDeadlockedThreads();\n+                ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+                if (info == null) {\n+                    \/\/ the thread has exited\n+                    break;\n+                }\n+            }\n+\n+            try {\n+                thread.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n@@ -84,1 +118,2 @@\n-        out.println(\"INFO: made \" + count + \" late findMonitorDeadlockedThreads() calls.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -89,0 +124,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max ::= max looping time in seconds\");\n+        System.err.println(\"                 (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n@@ -90,2 +134,1 @@\n-        final static long WAIT_TIME = 500; \/\/ Milliseconds\n-        Object object = new Object();\n+        final static long WAIT_TIME = 10; \/\/ Milliseconds\n@@ -105,1 +148,1 @@\n-                synchronized(object) {\n+                synchronized(waiter) {\n@@ -107,1 +150,1 @@\n-                        object.wait(WAIT_TIME);\n+                        waiter.wait(WAIT_TIME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006.java","additions":64,"deletions":21,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -40,1 +41,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}