{"files":[{"patch":"@@ -64,23 +64,0 @@\n-    \/**\n-     * Given a list of parameters, return a name\/rank number map.\n-     * If the list is null, then null is returned.\n-     * @param params The list of parameters (from type or executable member) to\n-     *               check.\n-     * @return a name-rank number map.\n-     *\/\n-    private static Map<String, String> getRankMap(Utils utils, List<? extends Element> params) {\n-        if (params == null) {\n-            return null;\n-        }\n-        HashMap<String, String> result = new HashMap<>();\n-        int rank = 0;\n-        for (Element e : params) {\n-            String name = utils.isTypeParameterElement(e)\n-                    ? utils.getTypeName(e.asType(), false)\n-                    : utils.getSimpleName(e);\n-            result.put(name, String.valueOf(rank));\n-            rank++;\n-        }\n-        return result;\n-    }\n-\n@@ -91,1 +68,2 @@\n-            input.isTypeVariableParamTag = ((ParamTree) input.docTreeInfo.docTree()).isTypeParameter();\n+            var tag = (ParamTree) input.docTreeInfo.docTree();\n+            input.isTypeVariableParamTag = tag.isTypeParameter();\n@@ -97,1 +75,1 @@\n-            String target = ch.getParameterName(input.docTreeInfo.docTree());\n+            String target = ch.getParameterName(tag);\n@@ -100,1 +78,1 @@\n-                String pname = input.isTypeVariableParamTag\n+                String candidate = input.isTypeVariableParamTag\n@@ -103,2 +81,2 @@\n-                if (pname.contentEquals(target)) {\n-                    input.tagId = String.valueOf(i);\n+                if (candidate.equals(target)) {\n+                    input.tagId = Integer.toString(i);\n@@ -109,5 +87,5 @@\n-        ExecutableElement md = (ExecutableElement) input.element;\n-        CommentHelper ch = utils.getCommentHelper(md);\n-        List<? extends DocTree> tags = input.isTypeVariableParamTag\n-                ? utils.getTypeParamTrees(md)\n-                : utils.getParamTrees(md);\n+        ExecutableElement ee = (ExecutableElement) input.element;\n+        CommentHelper ch = utils.getCommentHelper(ee);\n+        List<ParamTree> tags = input.isTypeVariableParamTag\n+                ? utils.getTypeParamTrees(ee)\n+                : utils.getParamTrees(ee);\n@@ -115,4 +93,4 @@\n-                ? md.getTypeParameters()\n-                : md.getParameters();\n-        Map<String, String> rankMap = getRankMap(utils, parameters);\n-        for (DocTree tag : tags) {\n+                ? ee.getTypeParameters()\n+                : ee.getParameters();\n+        Map<String, String> positionOfName = mapNameToPosition(utils, parameters);\n+        for (ParamTree tag : tags) {\n@@ -120,1 +98,1 @@\n-            if (rankMap.containsKey(paramName) && rankMap.get(paramName).equals((input.tagId))) {\n+            if (positionOfName.containsKey(paramName) && positionOfName.get(paramName).equals(input.tagId)) {\n@@ -129,0 +107,18 @@\n+    \/**\n+     * Given a list of parameter elements, returns a name-position map.\n+     * @param params the list of parameters from a type or an executable member\n+     * @return a name-position map\n+     *\/\n+    private static Map<String, String> mapNameToPosition(Utils utils, List<? extends Element> params) {\n+        Map<String, String> result = new HashMap<>();\n+        int position = 0;\n+        for (Element e : params) {\n+            String name = utils.isTypeParameterElement(e)\n+                    ? utils.getTypeName(e.asType(), false)\n+                    : utils.getSimpleName(e);\n+            result.put(name, Integer.toString(position));\n+            position++;\n+        }\n+        return result;\n+    }\n+\n@@ -134,4 +130,4 @@\n-            Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, member, writer,\n-                    member.getTypeParameters(), utils.getTypeParamTrees(member));\n-            output.add(getTagletOutput(ParamKind.PARAMETER, member, writer,\n-                    member.getParameters(), utils.getParamTrees(member)));\n+            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), writer);\n+            output.add(convertParams(member, ParamKind.PARAMETER,\n+                    utils.getParamTrees(member), member.getParameters(), writer));\n@@ -141,4 +137,4 @@\n-            Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, typeElement, writer,\n-                    typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));\n-            output.add(getTagletOutput(ParamKind.RECORD_COMPONENT, typeElement, writer,\n-                    typeElement.getRecordComponents(), utils.getParamTrees(typeElement)));\n+            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), writer);\n+            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), writer));\n@@ -150,2 +146,2 @@\n-     * Given an array of {@code @param DocTree}s, return its string representation.\n-     * Try to inherit the param tags that are missing.\n+     * Returns a {@code Content} representation of a list of {@code ParamTree}\n+     * of the specified kind.\n@@ -153,4 +149,6 @@\n-     * @param holder            the element that holds the param tags.\n-     * @param writer            the TagletWriter that will write this tag.\n-     * @param formalParameters  The array of parameters (from type or executable\n-     *                          member) to check.\n+     * <p> This method correlates a {@code ParamTree} with a parameter\n+     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n+     * is addressed by the position (index) of the correlated {@code Element}\n+     * in the list of parameter elements. This is needed for documentation\n+     * inheritance because the corresponding parameters in the inheritance\n+     * hierarchy may be named differently.\n@@ -158,43 +156,2 @@\n-     * @return the content representation of these {@code @param DocTree}s.\n-     *\/\n-    private Content getTagletOutput(ParamKind kind,\n-                                    Element holder,\n-                                    TagletWriter writer,\n-                                    List<? extends Element> formalParameters,\n-                                    List<? extends ParamTree> paramTags) {\n-        Content result = writer.getOutputInstance();\n-        result.add(processParamTags(holder, kind, paramTags, formalParameters, writer));\n-        return result;\n-    }\n-\n-    \/**\n-     * Try to get the inherited taglet documentation for a specific parameter.\n-     *\/\n-    private Content getInheritedTagletOutput(ParamKind kind,\n-                                             Element holder,\n-                                             TagletWriter writer,\n-                                             Element param,\n-                                             int rank,\n-                                             boolean isFirst) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n-                Integer.toString(rank), kind == ParamKind.TYPE_PARAMETER);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (!inheritedDoc.inlineTags.isEmpty()) {\n-            String lname = kind != ParamKind.TYPE_PARAMETER\n-                    ? utils.getSimpleName(param)\n-                    : utils.getTypeName(param.asType(), false);\n-            Content content = processParamTag(inheritedDoc.holder, kind, writer,\n-                    (ParamTree) inheritedDoc.holderTag,\n-                    lname, isFirst);\n-            result.add(content);\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Given an array of {@code @param DocTree}s representing this\n-     * tag, return its string representation.  Print a warning for param\n-     * tags that do not map to parameters.  Print a warning for param\n-     * tags that are duplicated.\n+     * <p> This method warns about {@code @param} tags that do not map to\n+     * parameter elements and param tags that are duplicated. <\/p>\n@@ -202,3 +159,1 @@\n-     * @param paramTags the array of {@code @param DocTree} to convert.\n-     * @param writer the TagletWriter that will write this tag.\n-     * @return the Content representation of this {@code @param DocTree}.\n+     * @param kind the kind of <em>all<\/em> parameters in the lists\n@@ -206,6 +161,6 @@\n-    private Content processParamTags(Element e,\n-                                     ParamKind kind,\n-                                     List<? extends ParamTree> paramTags,\n-                                     List<? extends Element> formalParameters,\n-                                     TagletWriter writer) {\n-        Map<String, ParamTree> documented = new HashMap<>();\n+    private Content convertParams(Element e,\n+                                  ParamKind kind,\n+                                  List<ParamTree> tags,\n+                                  List<? extends Element> parameters,\n+                                  TagletWriter writer) {\n+        Map<String, ParamTree> tagOfPosition = new HashMap<>();\n@@ -214,4 +169,4 @@\n-        if (!paramTags.isEmpty()) {\n-            Map<String, String> rankMap = getRankMap(writer.configuration().utils, formalParameters);\n-            for (ParamTree dt : paramTags) {\n-                String name = ch.getParameterName(dt);\n+        if (!tags.isEmpty()) {\n+            Map<String, String> positionOfName = mapNameToPosition(writer.configuration().utils, parameters);\n+            for (ParamTree tag : tags) {\n+                String name = ch.getParameterName(tag);\n@@ -219,1 +174,1 @@\n-                if (!rankMap.containsKey(name)) {\n+                if (!positionOfName.containsKey(name)) {\n@@ -225,1 +180,1 @@\n-                    messages.warning(ch.getDocTreePath(dt), key, paramName);\n+                    messages.warning(ch.getDocTreePath(tag), key, paramName);\n@@ -227,3 +182,3 @@\n-                String rank = rankMap.get(name);\n-                if (rank != null) {\n-                    if (documented.containsKey(rank)) {\n+                String position = positionOfName.get(name);\n+                if (position != null) {\n+                    if (tagOfPosition.containsKey(position)) {\n@@ -235,1 +190,1 @@\n-                        messages.warning(ch.getDocTreePath(dt), key, paramName);\n+                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n@@ -237,1 +192,1 @@\n-                        documented.put(rank, dt);\n+                        tagOfPosition.put(position, tag);\n@@ -242,1 +197,1 @@\n-        \/\/ Document declared parameters for which taglet documentation is available\n+        \/\/ Document declared parameters for which tag documentation is available\n@@ -245,5 +200,5 @@\n-        for (int i = 0; i < formalParameters.size(); i++) {\n-            ParamTree dt = documented.get(String.valueOf(i));\n-            if (dt != null) {\n-                result.add(processParamTag(e, kind, writer, dt,\n-                        ch.getParameterName(dt), result.isEmpty()));\n+        for (int i = 0; i < parameters.size(); i++) {\n+            ParamTree tag = tagOfPosition.get(Integer.toString(i));\n+            if (tag != null) {\n+                result.add(convertParam(e, kind, writer, tag,\n+                        ch.getParameterName(tag), result.isEmpty()));\n@@ -252,1 +207,1 @@\n-                        formalParameters.get(i), i, result.isEmpty()));\n+                        parameters.get(i), i, result.isEmpty()));\n@@ -255,2 +210,2 @@\n-        if (paramTags.size() > documented.size()) {\n-            \/\/ Generate documentation for remaining taglets that do not match a declared parameter.\n+        if (tags.size() > tagOfPosition.size()) {\n+            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n@@ -258,4 +213,4 @@\n-            for (ParamTree dt : paramTags) {\n-                if (!documented.containsValue(dt)) {\n-                    result.add(processParamTag(e, kind, writer, dt,\n-                            ch.getParameterName(dt), result.isEmpty()));\n+            for (ParamTree tag : tags) {\n+                if (!tagOfPosition.containsValue(tag)) {\n+                    result.add(convertParam(e, kind, writer, tag,\n+                            ch.getParameterName(tag), result.isEmpty()));\n@@ -269,11 +224,29 @@\n-     * Convert the individual ParamTag into Content.\n-     *\n-     * @param e               the owner element\n-     * @param kind            the kind of param tag\n-     * @param writer          the taglet writer for output writing.\n-     * @param paramTag        the tag whose inline tags will be printed.\n-     * @param name            the name of the parameter.  We can't rely on\n-     *                        the name in the param tag because we might be\n-     *                        inheriting documentation.\n-     * @param isFirstParam    true if this is the first param tag being printed.\n-     *\n+     * Tries to inherit documentation for a specific parameter (element).\n+     * If unsuccessful, the returned content is empty.\n+     *\/\n+    private Content getInheritedTagletOutput(ParamKind kind,\n+                                             Element holder,\n+                                             TagletWriter writer,\n+                                             Element param,\n+                                             int position,\n+                                             boolean isFirst) {\n+        Utils utils = writer.configuration().utils;\n+        Content result = writer.getOutputInstance();\n+        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n+                Integer.toString(position), kind == ParamKind.TYPE_PARAMETER);\n+        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n+        if (!inheritedDoc.inlineTags.isEmpty()) {\n+            String name = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = convertParam(inheritedDoc.holder, kind, writer,\n+                    (ParamTree) inheritedDoc.holderTag,\n+                    name, isFirst);\n+            result.add(content);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts an individual {@code ParamTree} to {@code Content}, which is\n+     * prepended with the header if the parameter is first in the list.\n@@ -281,6 +254,6 @@\n-    private Content processParamTag(Element e,\n-                                    ParamKind kind,\n-                                    TagletWriter writer,\n-                                    ParamTree paramTag,\n-                                    String name,\n-                                    boolean isFirstParam) {\n+    private Content convertParam(Element e,\n+                                 ParamKind kind,\n+                                 TagletWriter writer,\n+                                 ParamTree paramTag,\n+                                 String name,\n+                                 boolean isFirstParam) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":118,"deletions":145,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -56,1 +57,2 @@\n- * A taglet that represents the {@code @throws} tag.\n+ * A taglet that processes {@link ThrowsTree}, which represents tags like\n+ * {@code @throws} and {@code @exception}.\n@@ -67,1 +69,1 @@\n-        Element exception;\n+        Element target;\n@@ -70,5 +72,5 @@\n-            exception = input.docTreeInfo.docTree() instanceof ThrowsTree tt\n-                    ? ch.getException(tt) : null;\n-            input.tagId = exception == null\n-                    ? ch.getExceptionName(input.docTreeInfo.docTree()).getSignature()\n-                    : utils.getFullyQualifiedName(exception);\n+            var tag = (ThrowsTree) input.docTreeInfo.docTree();\n+            target = ch.getException(tag);\n+            input.tagId = target == null\n+                    ? ch.getExceptionName(tag).getSignature()\n+                    : utils.getFullyQualifiedName(target);\n@@ -76,1 +78,1 @@\n-            exception = input.utils.findClass(input.element, input.tagId);\n+            target = input.utils.findClass(input.element, input.tagId);\n@@ -79,4 +81,6 @@\n-        for (ThrowsTree tt : input.utils.getThrowsTrees(input.element)) {\n-            Element exc = ch.getException(tt);\n-            if (exc != null && (input.tagId.equals(utils.getSimpleName(exc)) ||\n-                    (input.tagId.equals(utils.getFullyQualifiedName(exc))))) {\n+        \/\/ TODO warn if target == null as we cannot guarantee type-match, but at most FQN-match.\n+\n+        for (ThrowsTree tag : input.utils.getThrowsTrees(input.element)) {\n+            Element candidate = ch.getException(tag);\n+            if (candidate != null && (input.tagId.equals(utils.getSimpleName(candidate)) ||\n+                    (input.tagId.equals(utils.getFullyQualifiedName(candidate))))) {\n@@ -84,1 +88,1 @@\n-                output.holderTag = tt;\n+                output.holderTag = tag;\n@@ -86,5 +90,5 @@\n-                output.tagList.add(tt);\n-            } else if (exception != null && exc != null &&\n-                    utils.isTypeElement(exc) && utils.isTypeElement(exception) &&\n-                    utils.isSubclassOf((TypeElement) exc, (TypeElement) exception)) {\n-                output.tagList.add(tt);\n+                output.tagList.add(tag);\n+            } else if (target != null && candidate != null &&\n+                    utils.isTypeElement(candidate) && utils.isTypeElement(target) &&\n+                    utils.isSubclassOf((TypeElement) candidate, (TypeElement) target)) {\n+                output.tagList.add(tag);\n@@ -95,62 +99,0 @@\n-    \/**\n-     * Add links for exceptions that are declared but not documented.\n-     *\/\n-    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n-                                                         Set<String> alreadyDocumented,\n-                                                         TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        \/\/Add links to the exceptions declared but not documented.\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            TypeElement te = utils.asTypeElement(declaredExceptionType);\n-            if (te != null &&\n-                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n-                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n-                if (alreadyDocumented.isEmpty()) {\n-                    result.add(writer.getThrowsHeader());\n-                }\n-                result.add(writer.throwsTagOutput(declaredExceptionType));\n-                alreadyDocumented.add(utils.getSimpleName(te));\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Inherit throws documentation for exceptions that were declared but not\n-     * documented.\n-     *\/\n-    private Content inheritThrowsDocumentation(Element holder,\n-                                               List<? extends TypeMirror> declaredExceptionTypes,\n-                                               Set<String> alreadyDocumented,\n-                                               Map<String, TypeMirror> typeSubstitutions,\n-                                               TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        if (utils.isMethod(holder)) {\n-            Map<List<? extends ThrowsTree>, ExecutableElement> declaredExceptionTags = new LinkedHashMap<>();\n-            for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-                Input input = new DocFinder.Input(utils, holder, this,\n-                        utils.getTypeName(declaredExceptionType, false));\n-                DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-                if (inheritedDoc.tagList.isEmpty()) {\n-                    String typeName = utils.getTypeName(declaredExceptionType, true);\n-                    input = new DocFinder.Input(utils, holder, this, typeName);\n-                    inheritedDoc = DocFinder.search(writer.configuration(), input);\n-                }\n-                if (!inheritedDoc.tagList.isEmpty()) {\n-                    if (inheritedDoc.holder == null) {\n-                        inheritedDoc.holder = holder;\n-                    }\n-                    List<? extends ThrowsTree> inheritedTags = inheritedDoc.tagList.stream()\n-                            .map(t -> (ThrowsTree) t)\n-                            .toList();\n-                    declaredExceptionTags.put(inheritedTags, (ExecutableElement) inheritedDoc.holder);\n-                }\n-            }\n-            result.add(throwsTagsOutput(declaredExceptionTags, writer, alreadyDocumented,\n-                    typeSubstitutions, false));\n-        }\n-        return result;\n-    }\n-\n@@ -160,1 +102,1 @@\n-        ExecutableElement execHolder = (ExecutableElement) holder;\n+        var executable = (ExecutableElement) holder;\n@@ -162,1 +104,1 @@\n-                writer.getCurrentPageElement(), (ExecutableElement) holder);\n+                writer.getCurrentPageElement(), executable);\n@@ -166,1 +108,1 @@\n-                ((ExecutableElement) holder).getThrownTypes(),\n+                executable.getThrownTypes(),\n@@ -168,2 +110,2 @@\n-        Map<List<? extends ThrowsTree>, ExecutableElement> tagsMap = new LinkedHashMap<>();\n-        tagsMap.put(utils.getThrowsTrees(execHolder), execHolder);\n+        Map<List<ThrowsTree>, ExecutableElement> tagsMap = new LinkedHashMap<>();\n+        tagsMap.put(utils.getThrowsTrees(executable), executable);\n@@ -171,6 +113,3 @@\n-        HashSet<String> alreadyDocumented = new HashSet<>();\n-        if (!tagsMap.isEmpty()) {\n-            result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, typeSubstitutions, true));\n-        }\n-        result.add(inheritThrowsDocumentation(holder,\n-                thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n+        Set<String> alreadyDocumented = new HashSet<>();\n+        result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, typeSubstitutions, true));\n+        result.add(inheritThrowsDocumentation(executable, thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n@@ -181,0 +120,26 @@\n+    \/**\n+     * Returns a map of substitutions for a list of thrown types with the original type-variable\n+     * name as a key and the instantiated type as a value. If no types need to be substituted\n+     * an empty map is returned.\n+     * @param declaredThrownTypes the originally declared thrown types.\n+     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n+     * @return map of declared to instantiated thrown types or an empty map.\n+     *\/\n+    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                              List<? extends TypeMirror> declaredThrownTypes,\n+                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n+        if (!declaredThrownTypes.equals(instantiatedThrownTypes)) {\n+            Map<String, TypeMirror> map = new HashMap<>();\n+            Iterator<? extends TypeMirror> i1 = declaredThrownTypes.iterator();\n+            Iterator<? extends TypeMirror> i2 = instantiatedThrownTypes.iterator();\n+            while (i1.hasNext() && i2.hasNext()) {\n+                TypeMirror t1 = i1.next();\n+                TypeMirror t2 = i2.next();\n+                if (!types.isSameType(t1, t2))\n+                    map.put(t1.toString(), t2);\n+            }\n+            return map;\n+        }\n+        return Map.of();\n+    }\n+\n@@ -184,1 +149,1 @@\n-     * @param throwTags         the collection of tags to be converted\n+     * @param throwsTags        the collection of tags to be converted\n@@ -190,1 +155,1 @@\n-    protected Content throwsTagsOutput(Map<List<? extends ThrowsTree>, ExecutableElement> throwTags,\n+    protected Content throwsTagsOutput(Map<List<ThrowsTree>, ExecutableElement> throwsTags,\n@@ -197,25 +162,23 @@\n-        if (!throwTags.isEmpty()) {\n-            for (Entry<List<? extends ThrowsTree>, ExecutableElement> entry : throwTags.entrySet()) {\n-                CommentHelper ch = utils.getCommentHelper(entry.getValue());\n-                Element e = entry.getValue();\n-                for (ThrowsTree dt : entry.getKey()) {\n-                    Element te = ch.getException(dt);\n-                    String excName = ch.getExceptionName(dt).toString();\n-                    TypeMirror substituteType = typeSubstitutions.get(excName);\n-                    if ((!allowDuplicates) &&\n-                            (alreadyDocumented.contains(excName) ||\n-                                    (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))) ||\n-                            (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n-                        continue;\n-                    }\n-                    if (alreadyDocumented.isEmpty()) {\n-                        result.add(writer.getThrowsHeader());\n-                    }\n-                    result.add(writer.throwsTagOutput(e, dt, substituteType));\n-                    if (substituteType != null) {\n-                        alreadyDocumented.add(substituteType.toString());\n-                    } else {\n-                        alreadyDocumented.add(te != null\n-                                ? utils.getFullyQualifiedName(te, false)\n-                                : excName);\n-                    }\n+        for (Entry<List<ThrowsTree>, ExecutableElement> entry : throwsTags.entrySet()) {\n+            Element e = entry.getValue();\n+            CommentHelper ch = utils.getCommentHelper(e);\n+            for (ThrowsTree tag : entry.getKey()) {\n+                Element te = ch.getException(tag);\n+                String excName = ch.getExceptionName(tag).toString();\n+                TypeMirror substituteType = typeSubstitutions.get(excName);\n+                if ((!allowDuplicates) &&\n+                        (alreadyDocumented.contains(excName) ||\n+                                (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))) ||\n+                        (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n+                    continue;\n+                }\n+                if (alreadyDocumented.isEmpty()) {\n+                    result.add(writer.getThrowsHeader());\n+                }\n+                result.add(writer.throwsTagOutput(e, tag, substituteType));\n+                if (substituteType != null) {\n+                    alreadyDocumented.add(substituteType.toString());\n+                } else {\n+                    alreadyDocumented.add(te != null\n+                            ? utils.getFullyQualifiedName(te, false)\n+                            : excName);\n@@ -229,6 +192,2 @@\n-     * Returns a map of substitutions for a list of thrown types with the original type-variable\n-     * name as key and the instantiated type as value. If no types need to be substituted\n-     * an empty map is returned.\n-     * @param declaredThrownTypes the originally declared thrown types.\n-     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n-     * @return map of declared to instantiated thrown types or an empty map.\n+     * Inherit throws documentation for exceptions that were declared but not\n+     * documented.\n@@ -236,12 +195,33 @@\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n-                                                              List<? extends TypeMirror> declaredThrownTypes,\n-                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n-        if (!instantiatedThrownTypes.equals(declaredThrownTypes)) {\n-            Map<String, TypeMirror> map = new HashMap<>();\n-            Iterator<? extends TypeMirror> i1 = instantiatedThrownTypes.iterator();\n-            Iterator<? extends TypeMirror> i2 = declaredThrownTypes.iterator();\n-            while (i1.hasNext() && i2.hasNext()) {\n-                TypeMirror t1 = i1.next();\n-                TypeMirror t2 = i2.next();\n-                if (!types.isSameType(t1, t2))\n-                    map.put(t2.toString(), t1);\n+    private Content inheritThrowsDocumentation(ExecutableElement holder,\n+                                               List<? extends TypeMirror> declaredExceptionTypes,\n+                                               Set<String> alreadyDocumented,\n+                                               Map<String, TypeMirror> typeSubstitutions,\n+                                               TagletWriter writer) {\n+        Content result = writer.getOutputInstance();\n+        if (holder.getKind() != ElementKind.METHOD) {\n+            \/\/ (Optimization.)\n+            \/\/ Of all executable elements, only methods and constructors are documented.\n+            \/\/ Of these two, only methods inherit documentation.\n+            \/\/ Don't waste time on constructors.\n+            assert holder.getKind() == ElementKind.CONSTRUCTOR : holder.getKind();\n+            return result;\n+        }\n+        Utils utils = writer.configuration().utils;\n+        Map<List<ThrowsTree>, ExecutableElement> declaredExceptionTags = new LinkedHashMap<>();\n+        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n+            Input input = new DocFinder.Input(utils, holder, this,\n+                    utils.getTypeName(declaredExceptionType, false));\n+            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n+            if (inheritedDoc.tagList.isEmpty()) {\n+                String typeName = utils.getTypeName(declaredExceptionType, true);\n+                input = new DocFinder.Input(utils, holder, this, typeName);\n+                inheritedDoc = DocFinder.search(writer.configuration(), input);\n+            }\n+            if (!inheritedDoc.tagList.isEmpty()) {\n+                if (inheritedDoc.holder == null) {\n+                    inheritedDoc.holder = holder;\n+                }\n+                List<ThrowsTree> inheritedTags = inheritedDoc.tagList.stream()\n+                        .map(t -> (ThrowsTree) t)\n+                        .toList();\n+                declaredExceptionTags.put(inheritedTags, (ExecutableElement) inheritedDoc.holder);\n@@ -249,1 +229,0 @@\n-            return map;\n@@ -251,1 +230,24 @@\n-        return Map.of();\n+        result.add(throwsTagsOutput(declaredExceptionTags, writer, alreadyDocumented,\n+                typeSubstitutions, false));\n+        return result;\n+    }\n+\n+    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n+                                                         Set<String> alreadyDocumented,\n+                                                         TagletWriter writer) {\n+        \/\/ TODO: assert declaredExceptionTypes are instantiated\n+        Utils utils = writer.configuration().utils;\n+        Content result = writer.getOutputInstance();\n+        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n+            TypeElement te = utils.asTypeElement(declaredExceptionType);\n+            if (te != null &&\n+                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n+                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n+                if (alreadyDocumented.isEmpty()) {\n+                    result.add(writer.getThrowsHeader());\n+                }\n+                result.add(writer.throwsTagOutput(declaredExceptionType));\n+                alreadyDocumented.add(utils.getSimpleName(te));\n+            }\n+        }\n+        return result;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":140,"deletions":138,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -128,13 +128,2 @@\n-    public boolean isTypeParameter(DocTree dtree) {\n-        if (dtree.getKind() == PARAM) {\n-            return ((ParamTree)dtree).isTypeParameter();\n-        }\n-        return false;\n-    }\n-\n-    public String getParameterName(DocTree dtree) {\n-        if (dtree.getKind() == PARAM) {\n-            return ((ParamTree) dtree).getName().getName().toString();\n-        } else {\n-            return null;\n-        }\n+    public String getParameterName(ParamTree p) {\n+        return p.getName().getName().toString();\n@@ -561,4 +550,2 @@\n-    public ReferenceTree getExceptionName(DocTree dtree) {\n-        return (dtree.getKind() == THROWS || dtree.getKind() == EXCEPTION)\n-                ? ((ThrowsTree)dtree).getExceptionName()\n-                : null;\n+    public ReferenceTree getExceptionName(ThrowsTree tt) {\n+        return tt.getExceptionName();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2233,1 +2233,1 @@\n-    public <T extends DocTree> List<? extends T> getBlockTags(Element element, Predicate<DocTree> filter, Class<T> tClass) {\n+    public <T extends DocTree> List<T> getBlockTags(Element element, Predicate<DocTree> filter, Class<T> tClass) {\n@@ -2480,1 +2480,1 @@\n-    public List<? extends ThrowsTree> getThrowsTrees(Element element) {\n+    public List<ThrowsTree> getThrowsTrees(Element element) {\n@@ -2486,1 +2486,1 @@\n-    public List<? extends ParamTree> getTypeParamTrees(Element element) {\n+    public List<ParamTree> getTypeParamTrees(Element element) {\n@@ -2490,1 +2490,1 @@\n-    public List<? extends ParamTree> getParamTrees(Element element) {\n+    public List<ParamTree> getParamTrees(Element element) {\n@@ -2494,1 +2494,1 @@\n-    private  List<? extends ParamTree> getParamTrees(Element element, boolean isTypeParameters) {\n+    private  List<ParamTree> getParamTrees(Element element, boolean isTypeParameters) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}