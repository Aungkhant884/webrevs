{"files":[{"patch":"@@ -64,23 +64,0 @@\n-    \/**\n-     * Given a list of parameters, return a name\/rank number map.\n-     * If the list is null, then null is returned.\n-     * @param params The list of parameters (from type or executable member) to\n-     *               check.\n-     * @return a name-rank number map.\n-     *\/\n-    private static Map<String, String> getRankMap(Utils utils, List<? extends Element> params) {\n-        if (params == null) {\n-            return null;\n-        }\n-        HashMap<String, String> result = new HashMap<>();\n-        int rank = 0;\n-        for (Element e : params) {\n-            String name = utils.isTypeParameterElement(e)\n-                    ? utils.getTypeName(e.asType(), false)\n-                    : utils.getSimpleName(e);\n-            result.put(name, String.valueOf(rank));\n-            rank++;\n-        }\n-        return result;\n-    }\n-\n@@ -91,1 +68,2 @@\n-            input.isTypeVariableParamTag = ((ParamTree) input.docTreeInfo.docTree()).isTypeParameter();\n+            var tag = (ParamTree) input.docTreeInfo.docTree();\n+            input.isTypeVariableParamTag = tag.isTypeParameter();\n@@ -97,1 +75,1 @@\n-            String target = ch.getParameterName(input.docTreeInfo.docTree());\n+            String target = ch.getParameterName(tag);\n@@ -100,1 +78,1 @@\n-                String pname = input.isTypeVariableParamTag\n+                String candidate = input.isTypeVariableParamTag\n@@ -103,2 +81,2 @@\n-                if (pname.contentEquals(target)) {\n-                    input.tagId = String.valueOf(i);\n+                if (candidate.equals(target)) {\n+                    input.tagId = Integer.toString(i);\n@@ -109,5 +87,5 @@\n-        ExecutableElement md = (ExecutableElement) input.element;\n-        CommentHelper ch = utils.getCommentHelper(md);\n-        List<? extends DocTree> tags = input.isTypeVariableParamTag\n-                ? utils.getTypeParamTrees(md)\n-                : utils.getParamTrees(md);\n+        ExecutableElement ee = (ExecutableElement) input.element;\n+        CommentHelper ch = utils.getCommentHelper(ee);\n+        List<? extends ParamTree> tags = input.isTypeVariableParamTag\n+                ? utils.getTypeParamTrees(ee)\n+                : utils.getParamTrees(ee);\n@@ -115,4 +93,4 @@\n-                ? md.getTypeParameters()\n-                : md.getParameters();\n-        Map<String, String> rankMap = getRankMap(utils, parameters);\n-        for (DocTree tag : tags) {\n+                ? ee.getTypeParameters()\n+                : ee.getParameters();\n+        Map<String, String> positionOfName = mapNameToPosition(utils, parameters);\n+        for (ParamTree tag : tags) {\n@@ -120,1 +98,1 @@\n-            if (rankMap.containsKey(paramName) && rankMap.get(paramName).equals((input.tagId))) {\n+            if (positionOfName.containsKey(paramName) && positionOfName.get(paramName).equals(input.tagId)) {\n@@ -129,0 +107,18 @@\n+    \/**\n+     * Given a list of parameters, returns a name-position map.\n+     * @param params the list of parameters from a type or an executable member\n+     * @return a name-position map\n+     *\/\n+    private static Map<String, String> mapNameToPosition(Utils utils, List<? extends Element> params) {\n+        Map<String, String> result = new HashMap<>();\n+        int position = 0;\n+        for (Element e : params) {\n+            String name = utils.isTypeParameterElement(e)\n+                    ? utils.getTypeName(e.asType(), false)\n+                    : utils.getSimpleName(e);\n+            result.put(name, Integer.toString(position));\n+            position++;\n+        }\n+        return result;\n+    }\n+\n@@ -134,4 +130,4 @@\n-            Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, member, writer,\n-                    member.getTypeParameters(), utils.getTypeParamTrees(member));\n-            output.add(getTagletOutput(ParamKind.PARAMETER, member, writer,\n-                    member.getParameters(), utils.getParamTrees(member)));\n+            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), writer);\n+            output.add(convertParams(member, ParamKind.PARAMETER,\n+                    utils.getParamTrees(member), member.getParameters(), writer));\n@@ -141,4 +137,4 @@\n-            Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, typeElement, writer,\n-                    typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));\n-            output.add(getTagletOutput(ParamKind.RECORD_COMPONENT, typeElement, writer,\n-                    typeElement.getRecordComponents(), utils.getParamTrees(typeElement)));\n+            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), writer);\n+            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), writer));\n@@ -150,2 +146,1 @@\n-     * Given an array of {@code @param DocTree}s, return its string representation.\n-     * Try to inherit the param tags that are missing.\n+     * Returns a {@code Content} representation of a list of {@code ParamTree}.\n@@ -153,4 +148,5 @@\n-     * @param holder            the element that holds the param tags.\n-     * @param writer            the TagletWriter that will write this tag.\n-     * @param formalParameters  The array of parameters (from type or executable\n-     *                          member) to check.\n+     * <p> This method correlates {@code ParamTree} with {@code Element} by\n+     * name. Once it's done, a particular {@code ParamTree} is addressed by the\n+     * position (index) of the correlated {@code Element} in the list of formal\n+     * parameter elements. This is needed for documentation inheritance as\n+     * an inherited parameter may be named differently. <\/p>\n@@ -158,43 +154,2 @@\n-     * @return the content representation of these {@code @param DocTree}s.\n-     *\/\n-    private Content getTagletOutput(ParamKind kind,\n-                                    Element holder,\n-                                    TagletWriter writer,\n-                                    List<? extends Element> formalParameters,\n-                                    List<? extends ParamTree> paramTags) {\n-        Content result = writer.getOutputInstance();\n-        result.add(processParamTags(holder, kind, paramTags, formalParameters, writer));\n-        return result;\n-    }\n-\n-    \/**\n-     * Try to get the inherited taglet documentation for a specific parameter.\n-     *\/\n-    private Content getInheritedTagletOutput(ParamKind kind,\n-                                             Element holder,\n-                                             TagletWriter writer,\n-                                             Element param,\n-                                             int rank,\n-                                             boolean isFirst) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n-                Integer.toString(rank), kind == ParamKind.TYPE_PARAMETER);\n-        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n-        if (!inheritedDoc.inlineTags.isEmpty()) {\n-            String lname = kind != ParamKind.TYPE_PARAMETER\n-                    ? utils.getSimpleName(param)\n-                    : utils.getTypeName(param.asType(), false);\n-            Content content = processParamTag(inheritedDoc.holder, kind, writer,\n-                    (ParamTree) inheritedDoc.holderTag,\n-                    lname, isFirst);\n-            result.add(content);\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Given an array of {@code @param DocTree}s representing this\n-     * tag, return its string representation.  Print a warning for param\n-     * tags that do not map to parameters.  Print a warning for param\n-     * tags that are duplicated.\n+     * <p> This method warns about {@code @param} tags that do not map to\n+     * parameter elements and param tags that are duplicated. <\/p>\n@@ -202,3 +157,1 @@\n-     * @param paramTags the array of {@code @param DocTree} to convert.\n-     * @param writer the TagletWriter that will write this tag.\n-     * @return the Content representation of this {@code @param DocTree}.\n+     * @param kind the kind of <em>all<\/em> parameters in the lists\n@@ -206,6 +159,6 @@\n-    private Content processParamTags(Element e,\n-                                     ParamKind kind,\n-                                     List<? extends ParamTree> paramTags,\n-                                     List<? extends Element> formalParameters,\n-                                     TagletWriter writer) {\n-        Map<String, ParamTree> documented = new HashMap<>();\n+    private Content convertParams(Element e,\n+                                  ParamKind kind,\n+                                  List<? extends ParamTree> paramTags,\n+                                  List<? extends Element> formalParameters,\n+                                  TagletWriter writer) {\n+        Map<String, ParamTree> tagOfPosition = new HashMap<>();\n@@ -215,1 +168,1 @@\n-            Map<String, String> rankMap = getRankMap(writer.configuration().utils, formalParameters);\n+            Map<String, String> positionOfName = mapNameToPosition(writer.configuration().utils, formalParameters);\n@@ -219,1 +172,1 @@\n-                if (!rankMap.containsKey(name)) {\n+                if (!positionOfName.containsKey(name)) {\n@@ -227,3 +180,3 @@\n-                String rank = rankMap.get(name);\n-                if (rank != null) {\n-                    if (documented.containsKey(rank)) {\n+                String position = positionOfName.get(name);\n+                if (position != null) {\n+                    if (tagOfPosition.containsKey(position)) {\n@@ -237,1 +190,1 @@\n-                        documented.put(rank, dt);\n+                        tagOfPosition.put(position, dt);\n@@ -242,1 +195,1 @@\n-        \/\/ Document declared parameters for which taglet documentation is available\n+        \/\/ Document declared parameters for which tag documentation is available\n@@ -246,1 +199,1 @@\n-            ParamTree dt = documented.get(String.valueOf(i));\n+            ParamTree dt = tagOfPosition.get(Integer.toString(i));\n@@ -248,1 +201,1 @@\n-                result.add(processParamTag(e, kind, writer, dt,\n+                result.add(convertParam(e, kind, writer, dt,\n@@ -255,2 +208,2 @@\n-        if (paramTags.size() > documented.size()) {\n-            \/\/ Generate documentation for remaining taglets that do not match a declared parameter.\n+        if (paramTags.size() > tagOfPosition.size()) {\n+            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n@@ -259,2 +212,2 @@\n-                if (!documented.containsValue(dt)) {\n-                    result.add(processParamTag(e, kind, writer, dt,\n+                if (!tagOfPosition.containsValue(dt)) {\n+                    result.add(convertParam(e, kind, writer, dt,\n@@ -269,11 +222,29 @@\n-     * Convert the individual ParamTag into Content.\n-     *\n-     * @param e               the owner element\n-     * @param kind            the kind of param tag\n-     * @param writer          the taglet writer for output writing.\n-     * @param paramTag        the tag whose inline tags will be printed.\n-     * @param name            the name of the parameter.  We can't rely on\n-     *                        the name in the param tag because we might be\n-     *                        inheriting documentation.\n-     * @param isFirstParam    true if this is the first param tag being printed.\n-     *\n+     * Tries to inherit documentation for a specific parameter (element).\n+     * If unsuccessful, the returned content is empty.\n+     *\/\n+    private Content getInheritedTagletOutput(ParamKind kind,\n+                                             Element holder,\n+                                             TagletWriter writer,\n+                                             Element param,\n+                                             int position,\n+                                             boolean isFirst) {\n+        Utils utils = writer.configuration().utils;\n+        Content result = writer.getOutputInstance();\n+        Input input = new DocFinder.Input(writer.configuration().utils, holder, this,\n+                Integer.toString(position), kind == ParamKind.TYPE_PARAMETER);\n+        DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n+        if (!inheritedDoc.inlineTags.isEmpty()) {\n+            String name = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = convertParam(inheritedDoc.holder, kind, writer,\n+                    (ParamTree) inheritedDoc.holderTag,\n+                    name, isFirst);\n+            result.add(content);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts an individual {@code ParamTree} to {@code Content}, which is\n+     * prepended with the header if the parameter is first in the list.\n@@ -281,6 +252,6 @@\n-    private Content processParamTag(Element e,\n-                                    ParamKind kind,\n-                                    TagletWriter writer,\n-                                    ParamTree paramTag,\n-                                    String name,\n-                                    boolean isFirstParam) {\n+    private Content convertParam(Element e,\n+                                 ParamKind kind,\n+                                 TagletWriter writer,\n+                                 ParamTree paramTag,\n+                                 String name,\n+                                 boolean isFirstParam) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":105,"deletions":134,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n- * A taglet that represents the {@code @throws} tag.\n+ * A taglet that processes {@link ThrowsTree}, which represents tags like\n+ * {@code @throws} and {@code @exception}.\n@@ -67,1 +68,1 @@\n-        Element exception;\n+        Element target;\n@@ -70,5 +71,5 @@\n-            exception = input.docTreeInfo.docTree() instanceof ThrowsTree tt\n-                    ? ch.getException(tt) : null;\n-            input.tagId = exception == null\n-                    ? ch.getExceptionName(input.docTreeInfo.docTree()).getSignature()\n-                    : utils.getFullyQualifiedName(exception);\n+            var tag = (ThrowsTree) input.docTreeInfo.docTree();\n+            target = ch.getException(tag);\n+            input.tagId = target == null\n+                    ? ch.getExceptionName(tag).getSignature()\n+                    : utils.getFullyQualifiedName(target);\n@@ -76,1 +77,1 @@\n-            exception = input.utils.findClass(input.element, input.tagId);\n+            target = input.utils.findClass(input.element, input.tagId);\n@@ -79,4 +80,6 @@\n-        for (ThrowsTree tt : input.utils.getThrowsTrees(input.element)) {\n-            Element exc = ch.getException(tt);\n-            if (exc != null && (input.tagId.equals(utils.getSimpleName(exc)) ||\n-                    (input.tagId.equals(utils.getFullyQualifiedName(exc))))) {\n+        \/\/ TODO warn if target == null as we cannot guarantee type-match, but at most FQN-match.\n+\n+        for (ThrowsTree tag : input.utils.getThrowsTrees(input.element)) {\n+            Element candidate = ch.getException(tag);\n+            if (candidate != null && (input.tagId.equals(utils.getSimpleName(candidate)) ||\n+                    (input.tagId.equals(utils.getFullyQualifiedName(candidate))))) {\n@@ -84,1 +87,1 @@\n-                output.holderTag = tt;\n+                output.holderTag = tag;\n@@ -86,5 +89,5 @@\n-                output.tagList.add(tt);\n-            } else if (exception != null && exc != null &&\n-                    utils.isTypeElement(exc) && utils.isTypeElement(exception) &&\n-                    utils.isSubclassOf((TypeElement) exc, (TypeElement) exception)) {\n-                output.tagList.add(tt);\n+                output.tagList.add(tag);\n+            } else if (target != null && candidate != null &&\n+                    utils.isTypeElement(candidate) && utils.isTypeElement(target) && \/\/ FIXME: can they be anything else other than type elements?\n+                    utils.isSubclassOf((TypeElement) candidate, (TypeElement) target)) {\n+                output.tagList.add(tag);\n@@ -95,0 +98,21 @@\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+        Utils utils = writer.configuration().utils;\n+        ExecutableElement execHolder = (ExecutableElement) holder;\n+        ExecutableType instantiatedType = utils.asInstantiatedMethodType(\n+                writer.getCurrentPageElement(), (ExecutableElement) holder);\n+        List<? extends TypeMirror> thrownTypes = instantiatedType.getThrownTypes();\n+        Map<String, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n+                writer.configuration().utils.typeUtils,\n+                ((ExecutableElement) holder).getThrownTypes(),\n+                thrownTypes);\n+        Map<List<? extends ThrowsTree>, ExecutableElement> tagsMap = new LinkedHashMap<>();\n+        tagsMap.put(utils.getThrowsTrees(execHolder), execHolder);\n+        Content result = writer.getOutputInstance();\n+        Set<String> alreadyDocumented = new HashSet<>();\n+        result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, typeSubstitutions, true));\n+        result.add(inheritThrowsDocumentation(holder, thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n+        result.add(linkToUndocumentedDeclaredExceptions(thrownTypes, alreadyDocumented, writer));\n+        return result;\n+    }\n+\n@@ -96,1 +120,6 @@\n-     * Add links for exceptions that are declared but not documented.\n+     * Returns a map of substitutions for a list of thrown types with the original type-variable\n+     * name as a key and the instantiated type as a value. If no types need to be substituted\n+     * an empty map is returned.\n+     * @param declaredThrownTypes the originally declared thrown types.\n+     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n+     * @return map of declared to instantiated thrown types or an empty map.\n@@ -98,3 +127,32 @@\n-    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n-                                                         Set<String> alreadyDocumented,\n-                                                         TagletWriter writer) {\n+    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                              List<? extends TypeMirror> declaredThrownTypes,\n+                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n+        if (!declaredThrownTypes.equals(instantiatedThrownTypes)) {\n+            Map<String, TypeMirror> map = new HashMap<>();\n+            Iterator<? extends TypeMirror> i1 = declaredThrownTypes.iterator();\n+            Iterator<? extends TypeMirror> i2 = instantiatedThrownTypes.iterator();\n+            while (i1.hasNext() && i2.hasNext()) {\n+                TypeMirror t1 = i1.next();\n+                TypeMirror t2 = i2.next();\n+                if (!types.isSameType(t1, t2))\n+                    map.put(t1.toString(), t2);\n+            }\n+            return map;\n+        }\n+        return Map.of();\n+    }\n+\n+    \/**\n+     * Returns the generated content for a collection of {@code @throws} tags.\n+     *\n+     * @param throwsTags        the collection of tags to be converted\n+     * @param writer            the taglet-writer used by the doclet\n+     * @param alreadyDocumented the set of exceptions that have already been documented\n+     * @param allowDuplicates   {@code true} if we allow duplicate tags to be documented\n+     * @return the generated content for the tags\n+     *\/\n+    protected Content throwsTagsOutput(Map<List<? extends ThrowsTree>, ExecutableElement> throwsTags,\n+                                       TagletWriter writer,\n+                                       Set<String> alreadyDocumented,\n+                                       Map<String, TypeMirror> typeSubstitutions,\n+                                       boolean allowDuplicates) {\n@@ -103,6 +161,13 @@\n-        \/\/Add links to the exceptions declared but not documented.\n-        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n-            TypeElement te = utils.asTypeElement(declaredExceptionType);\n-            if (te != null &&\n-                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n-                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n+        for (Entry<List<? extends ThrowsTree>, ExecutableElement> entry : throwsTags.entrySet()) {\n+            Element e = entry.getValue();\n+            CommentHelper ch = utils.getCommentHelper(e);\n+            for (ThrowsTree dt : entry.getKey()) {\n+                Element te = ch.getException(dt);\n+                String excName = ch.getExceptionName(dt).toString();\n+                TypeMirror substituteType = typeSubstitutions.get(excName);\n+                if ((!allowDuplicates) &&\n+                        (alreadyDocumented.contains(excName) ||\n+                                (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))) ||\n+                        (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n+                    continue;\n+                }\n@@ -112,2 +177,8 @@\n-                result.add(writer.throwsTagOutput(declaredExceptionType));\n-                alreadyDocumented.add(utils.getSimpleName(te));\n+                result.add(writer.throwsTagOutput(e, dt, substituteType));\n+                if (substituteType != null) {\n+                    alreadyDocumented.add(substituteType.toString());\n+                } else {\n+                    alreadyDocumented.add(te != null\n+                            ? utils.getFullyQualifiedName(te, false)\n+                            : excName);\n+                }\n@@ -148,1 +219,1 @@\n-                    declaredExceptionTags.put(inheritedTags, (ExecutableElement) inheritedDoc.holder);\n+                    ExecutableElement r = declaredExceptionTags.put(inheritedTags, (ExecutableElement) inheritedDoc.holder);\n@@ -157,38 +228,4 @@\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        ExecutableElement execHolder = (ExecutableElement) holder;\n-        ExecutableType instantiatedType = utils.asInstantiatedMethodType(\n-                writer.getCurrentPageElement(), (ExecutableElement) holder);\n-        List<? extends TypeMirror> thrownTypes = instantiatedType.getThrownTypes();\n-        Map<String, TypeMirror> typeSubstitutions = getSubstitutedThrownTypes(\n-                writer.configuration().utils.typeUtils,\n-                ((ExecutableElement) holder).getThrownTypes(),\n-                thrownTypes);\n-        Map<List<? extends ThrowsTree>, ExecutableElement> tagsMap = new LinkedHashMap<>();\n-        tagsMap.put(utils.getThrowsTrees(execHolder), execHolder);\n-        Content result = writer.getOutputInstance();\n-        HashSet<String> alreadyDocumented = new HashSet<>();\n-        if (!tagsMap.isEmpty()) {\n-            result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, typeSubstitutions, true));\n-        }\n-        result.add(inheritThrowsDocumentation(holder,\n-                thrownTypes, alreadyDocumented, typeSubstitutions, writer));\n-        result.add(linkToUndocumentedDeclaredExceptions(thrownTypes, alreadyDocumented, writer));\n-        return result;\n-    }\n-\n-    \/**\n-     * Returns the generated content for a collection of {@code @throws} tags.\n-     *\n-     * @param throwTags         the collection of tags to be converted\n-     * @param writer            the taglet-writer used by the doclet\n-     * @param alreadyDocumented the set of exceptions that have already been documented\n-     * @param allowDuplicates   {@code true} if we allow duplicate tags to be documented\n-     * @return the generated content for the tags\n-     *\/\n-    protected Content throwsTagsOutput(Map<List<? extends ThrowsTree>, ExecutableElement> throwTags,\n-                                       TagletWriter writer,\n-                                       Set<String> alreadyDocumented,\n-                                       Map<String, TypeMirror> typeSubstitutions,\n-                                       boolean allowDuplicates) {\n+    private Content linkToUndocumentedDeclaredExceptions(List<? extends TypeMirror> declaredExceptionTypes,\n+                                                         Set<String> alreadyDocumented,\n+                                                         TagletWriter writer) {\n+        \/\/ TODO: assert declaredExceptionTypes are instantiated\n@@ -197,25 +234,7 @@\n-        if (!throwTags.isEmpty()) {\n-            for (Entry<List<? extends ThrowsTree>, ExecutableElement> entry : throwTags.entrySet()) {\n-                CommentHelper ch = utils.getCommentHelper(entry.getValue());\n-                Element e = entry.getValue();\n-                for (ThrowsTree dt : entry.getKey()) {\n-                    Element te = ch.getException(dt);\n-                    String excName = ch.getExceptionName(dt).toString();\n-                    TypeMirror substituteType = typeSubstitutions.get(excName);\n-                    if ((!allowDuplicates) &&\n-                            (alreadyDocumented.contains(excName) ||\n-                                    (te != null && alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))) ||\n-                            (substituteType != null && alreadyDocumented.contains(substituteType.toString()))) {\n-                        continue;\n-                    }\n-                    if (alreadyDocumented.isEmpty()) {\n-                        result.add(writer.getThrowsHeader());\n-                    }\n-                    result.add(writer.throwsTagOutput(e, dt, substituteType));\n-                    if (substituteType != null) {\n-                        alreadyDocumented.add(substituteType.toString());\n-                    } else {\n-                        alreadyDocumented.add(te != null\n-                                ? utils.getFullyQualifiedName(te, false)\n-                                : excName);\n-                    }\n+        for (TypeMirror declaredExceptionType : declaredExceptionTypes) {\n+            TypeElement te = utils.asTypeElement(declaredExceptionType);\n+            if (te != null &&\n+                    !alreadyDocumented.contains(declaredExceptionType.toString()) &&\n+                    !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {\n+                if (alreadyDocumented.isEmpty()) {\n+                    result.add(writer.getThrowsHeader());\n@@ -223,0 +242,2 @@\n+                result.add(writer.throwsTagOutput(declaredExceptionType));\n+                alreadyDocumented.add(utils.getSimpleName(te));\n@@ -227,26 +248,0 @@\n-\n-    \/**\n-     * Returns a map of substitutions for a list of thrown types with the original type-variable\n-     * name as key and the instantiated type as value. If no types need to be substituted\n-     * an empty map is returned.\n-     * @param declaredThrownTypes the originally declared thrown types.\n-     * @param instantiatedThrownTypes the thrown types in the context of the current type.\n-     * @return map of declared to instantiated thrown types or an empty map.\n-     *\/\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n-                                                              List<? extends TypeMirror> declaredThrownTypes,\n-                                                              List<? extends TypeMirror> instantiatedThrownTypes) {\n-        if (!instantiatedThrownTypes.equals(declaredThrownTypes)) {\n-            Map<String, TypeMirror> map = new HashMap<>();\n-            Iterator<? extends TypeMirror> i1 = instantiatedThrownTypes.iterator();\n-            Iterator<? extends TypeMirror> i2 = declaredThrownTypes.iterator();\n-            while (i1.hasNext() && i2.hasNext()) {\n-                TypeMirror t1 = i1.next();\n-                TypeMirror t2 = i2.next();\n-                if (!types.isSameType(t1, t2))\n-                    map.put(t2.toString(), t1);\n-            }\n-            return map;\n-        }\n-        return Map.of();\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":115,"deletions":120,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -128,13 +128,2 @@\n-    public boolean isTypeParameter(DocTree dtree) {\n-        if (dtree.getKind() == PARAM) {\n-            return ((ParamTree)dtree).isTypeParameter();\n-        }\n-        return false;\n-    }\n-\n-    public String getParameterName(DocTree dtree) {\n-        if (dtree.getKind() == PARAM) {\n-            return ((ParamTree) dtree).getName().getName().toString();\n-        } else {\n-            return null;\n-        }\n+    public String getParameterName(ParamTree p) {\n+        return p.getName().getName().toString();\n@@ -561,4 +550,2 @@\n-    public ReferenceTree getExceptionName(DocTree dtree) {\n-        return (dtree.getKind() == THROWS || dtree.getKind() == EXCEPTION)\n-                ? ((ThrowsTree)dtree).getExceptionName()\n-                : null;\n+    public ReferenceTree getExceptionName(ThrowsTree tt) {\n+        return tt.getExceptionName();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"}]}