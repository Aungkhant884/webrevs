{"files":[{"patch":"@@ -61,2 +61,1 @@\n-  _dirty_card_queue_set(&_dirty_card_queue_buffer_allocator),\n-  _shared_dirty_card_queue(&_dirty_card_queue_set)\n+  _dirty_card_queue_set(&_dirty_card_queue_buffer_allocator)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1SharedDirtyCardQueue.hpp\"\n@@ -46,1 +45,0 @@\n-  G1SharedDirtyCardQueue _shared_dirty_card_queue;\n@@ -97,4 +95,0 @@\n-  static G1SharedDirtyCardQueue& shared_dirty_card_queue() {\n-    return g1_barrier_set()->_shared_dirty_card_queue;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -549,2 +549,0 @@\n-\n-  G1BarrierSet::shared_dirty_card_queue().reset();\n@@ -574,1 +572,0 @@\n-  G1BarrierSet::shared_dirty_card_queue().flush();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"gc\/g1\/g1SharedDirtyCardQueue.hpp\"\n@@ -1691,4 +1690,15 @@\n-  \/\/ Re-dirty the card and enqueue in the *shared* queue.  Can't use\n-  \/\/ the thread-local queue, because that might be the queue that is\n-  \/\/ being processed by us; we could be a Java thread conscripted to\n-  \/\/ perform refinement on our queue's current buffer.\n+  enqueue_for_reprocessing(card_ptr);\n+}\n+\n+\/\/ Re-dirty and re-enqueue the card to retry refinement later.\n+\/\/ This is used to deal with a rare race condition in concurrent refinement.\n+void G1RemSet::enqueue_for_reprocessing(CardValue* card_ptr) {\n+  \/\/ We can't use the thread-local queue, because that might be the queue\n+  \/\/ that is being processed by us; we could be a Java thread conscripted to\n+  \/\/ perform refinement on our queue's current buffer.  This situation only\n+  \/\/ arises from rare race condition, so it's not worth any significant\n+  \/\/ development effort or clever lock-free queue implementation.  Instead\n+  \/\/ we use brute force, allocating and enqueuing an entire buffer for just\n+  \/\/ this card.  Since buffers are processed in FIFO order and we try to\n+  \/\/ keep some in the queue, it is likely that the racing state will have\n+  \/\/ resolved by the time this card comes up for reprocessing.\n@@ -1696,1 +1706,5 @@\n-  G1BarrierSet::shared_dirty_card_queue().enqueue(card_ptr);\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  void** buffer = dcqs.allocate_buffer();\n+  size_t index = dcqs.buffer_size() - 1;\n+  buffer[index] = card_ptr;\n+  dcqs.enqueue_completed_buffer(BufferNode::make_node_from_buffer(buffer, index));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+public:\n+  typedef CardTable::CardValue CardValue;\n+\n@@ -75,1 +78,0 @@\n-public:\n@@ -77,1 +79,1 @@\n-  typedef CardTable::CardValue CardValue;\n+  void enqueue_for_reprocessing(CardValue* card_ptr);\n@@ -79,0 +81,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1DirtyCardQueue.hpp\"\n-#include \"gc\/g1\/g1SharedDirtyCardQueue.hpp\"\n-#include \"gc\/shared\/ptrQueue.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-\n-G1SharedDirtyCardQueue::G1SharedDirtyCardQueue(G1DirtyCardQueueSet* qset) :\n-  _qset(qset),\n-  _buffer(NULL),\n-  _index(0)\n-{}\n-\n-G1SharedDirtyCardQueue::~G1SharedDirtyCardQueue() {\n-  flush();\n-}\n-\n-void G1SharedDirtyCardQueue::enqueue(void* card_ptr) {\n-  MutexLocker ml(Shared_DirtyCardQ_lock, Mutex::_no_safepoint_check_flag);\n-  if (_index == 0) {\n-    flush();\n-    _buffer = _qset->allocate_buffer();\n-    _index = _qset->buffer_size();\n-    assert(_index != 0, \"invariant\");\n-  }\n-  _buffer[--_index] = card_ptr;\n-}\n-\n-void G1SharedDirtyCardQueue::flush() {\n-  if (_buffer != NULL) {\n-    BufferNode* node = BufferNode::make_node_from_buffer(_buffer, _index);\n-    _buffer = NULL;\n-    _index = 0;\n-    if (node->index() == _qset->buffer_size()) {\n-      _qset->deallocate_buffer(node);\n-    } else {\n-      _qset->enqueue_completed_buffer(node);\n-    }\n-  }\n-  assert(_index == 0, \"invariant\");\n-}\n-\n-void G1SharedDirtyCardQueue::reset() {\n-  if (_buffer == NULL) {\n-    _index = 0;\n-  } else {\n-    _index = _qset->buffer_size();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SharedDirtyCardQueue.cpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1SHAREDDIRTYCARDQUEUE_HPP\n-#define SHARE_GC_G1_G1SHAREDDIRTYCARDQUEUE_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class G1DirtyCardQueueSet;\n-\n-\/\/ A dirty card queue providing thread-safe enqueue.  A shared global\n-\/\/ instance can be used for cases where a thread-local dirty card can't\n-\/\/ be used.\n-class G1SharedDirtyCardQueue {\n-  G1DirtyCardQueueSet* const _qset;\n-  void** _buffer;\n-  size_t _index;\n-\n-  NONCOPYABLE(G1SharedDirtyCardQueue);\n-\n-public:\n-  G1SharedDirtyCardQueue(G1DirtyCardQueueSet* qset);\n-  ~G1SharedDirtyCardQueue();    \/\/ flushes the queue.\n-\n-  \/\/ Thread-safe addition to shared logging buffer.\n-  void enqueue(void* card_ptr);\n-\n-  \/\/ Flush any pending entries to the qset and remove the buffer.\n-  \/\/ Not thread-safe.\n-  void flush();\n-\n-  \/\/ Discard any pending entries.\n-  \/\/ Not thread-safe.\n-  void reset();\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1SHAREDDIRTYCARDQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SharedDirtyCardQueue.hpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -77,1 +77,0 @@\n-Mutex*   Shared_DirtyCardQ_lock       = NULL;\n@@ -220,2 +219,0 @@\n-    def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  _safepoint_check_never);\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-extern Mutex*   Shared_DirtyCardQ_lock;          \/\/ Lock protecting dirty card\n-                                                 \/\/ queue shared by\n-                                                 \/\/ non-Java threads.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}