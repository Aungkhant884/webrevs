{"files":[{"patch":"@@ -145,2 +145,1 @@\n-        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_neon.ad \\\n-        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_sve.ad \\\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_vector.ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,4 +182,0 @@\n-  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n-  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n-  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n-  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n@@ -191,4 +187,0 @@\n-  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n-  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n-  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n-  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n@@ -200,4 +192,0 @@\n-  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n-  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n-  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n-  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n@@ -209,4 +197,0 @@\n-  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n-  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n-  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n-  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n@@ -218,4 +202,0 @@\n-  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n-  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n-  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n-  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n@@ -227,4 +207,0 @@\n-  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n-  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n-  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n-  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n@@ -236,4 +212,0 @@\n-  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n-  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n-  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n-  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n@@ -245,4 +217,0 @@\n-  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n-  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n-  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n-  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n@@ -254,4 +222,0 @@\n-  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n-  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n-  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n-  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n@@ -263,4 +227,0 @@\n-  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n-  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n-  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n-  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n@@ -272,4 +232,0 @@\n-  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n-  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n-  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n-  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n@@ -281,4 +237,0 @@\n-  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n-  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n-  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n-  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n@@ -290,4 +242,0 @@\n-  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n-  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n-  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n-  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n@@ -299,4 +247,0 @@\n-  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n-  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n-  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n-  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n@@ -308,4 +252,0 @@\n-  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n-  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n-  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n-  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n@@ -317,4 +257,0 @@\n-  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n-  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n-  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n-  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n@@ -326,4 +262,0 @@\n-  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n-  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n-  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n-  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n@@ -335,4 +267,0 @@\n-  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n-  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n-  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n-  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n@@ -344,4 +272,0 @@\n-  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n-  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n-  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n-  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n@@ -353,4 +277,0 @@\n-  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n-  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n-  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n-  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n@@ -362,4 +282,0 @@\n-  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n-  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n-  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n-  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n@@ -371,4 +287,0 @@\n-  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n-  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n-  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n-  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n@@ -380,4 +292,0 @@\n-  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n-  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n-  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n-  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n@@ -389,4 +297,0 @@\n-  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n-  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n-  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n-  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n@@ -398,4 +302,0 @@\n-  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n-  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n-  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n-  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n@@ -407,4 +307,0 @@\n-  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n-  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n-  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n-  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n@@ -416,4 +312,0 @@\n-  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n-  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n-  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n-  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n@@ -425,4 +317,0 @@\n-  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n-  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n-  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n-  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n@@ -434,4 +322,0 @@\n-  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n-  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n-  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n-  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n@@ -443,4 +327,0 @@\n-  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n-  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n-  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n-  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n@@ -452,4 +332,0 @@\n-  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n-  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n-  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n-  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n@@ -461,5 +337,0 @@\n-  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n-  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n-  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n-  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n-\n@@ -553,16 +424,16 @@\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -571,8 +442,8 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n@@ -581,8 +452,8 @@\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n@@ -903,32 +774,32 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -1317,3 +1188,0 @@\n-  \/\/ Assert that the given node is not a variable shift.\n-  bool assert_not_var_shift(const Node* n);\n-\n@@ -1734,6 +1602,0 @@\n-\/\/ Assert that the given node is not a variable shift.\n-bool assert_not_var_shift(const Node* n) {\n-  assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n-  return true;\n-}\n-\n@@ -2435,12 +2297,0 @@\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n-    case Op_MaskAll:\n-    case Op_AndVMask:\n-    case Op_OrVMask:\n-    case Op_XorVMask:\n-      if (UseSVE == 0) {\n-        ret_value = false;\n-      }\n-      break;\n@@ -2452,76 +2302,0 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n-  if (UseSVE == 0) {\n-    \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n-    \/\/ NEON instructions support them. But the match rule support for them is profitable for\n-    \/\/ Vector API intrinsics.\n-    if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n-        (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n-      return false;\n-    }\n-  }\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode)) {\n-    return false;\n-  }\n-  int bit_size = vlen * type2aelembytes(bt) * 8;\n-  if (UseSVE == 0 && bit_size > 128) {\n-    return false;\n-  }\n-  if (UseSVE > 0) {\n-    return op_sve_supported(opcode, vlen, bt);\n-  } else { \/\/ NEON\n-    \/\/ Special cases\n-    switch (opcode) {\n-    case Op_VectorMaskCmp:\n-      if (vlen < 2 || bit_size < 64) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulAddVS2VI:\n-      if (bit_size < 128) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulVL:\n-    case Op_PopulateIndex:\n-      return false;\n-    case Op_VectorLoadShuffle:\n-    case Op_VectorRearrange:\n-      if (vlen < 4) {\n-        return false;\n-      }\n-      break;\n-    case Op_VectorMaskGen:\n-    case Op_LoadVectorGather:\n-    case Op_StoreVectorScatter:\n-    case Op_CompressV:\n-    case Op_CompressM:\n-    case Op_ExpandV:\n-    case Op_VectorLongToMask:\n-      return false;\n-    default:\n-      break;\n-    }\n-  }\n-  return vector_size_supported(bt, vlen);\n-}\n-\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  \/\/ Only SVE supports masked operations.\n-  if (UseSVE == 0) {\n-    return false;\n-  }\n-  return match_rule_supported(opcode) &&\n-         masked_op_sve_supported(opcode, vlen, bt);\n-}\n-\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  \/\/ Only SVE has partial vector operations\n-  return (UseSVE > 0) && partial_op_sve_needed(node, vt);\n-}\n-\n@@ -2594,1 +2368,1 @@\n-  if (UseSVE > 0 && 2 <= len && len <= 256) {\n+  if (UseSVE > 0 && 16 < len && len <= 256) {\n@@ -2608,2 +2382,8 @@\n-MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {\n-  ShouldNotReachHere(); \/\/ generic vector operands not supported\n+MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {\n+  assert(Matcher::is_generic_vector(generic_opnd), \"not generic\");\n+  switch (ideal_reg) {\n+    case Op_VecA: return new vecAOper();\n+    case Op_VecD: return new vecDOper();\n+    case Op_VecX: return new vecXOper();\n+  }\n+  ShouldNotReachHere();\n@@ -2614,1 +2394,0 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n@@ -2619,2 +2398,1 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n-  return false;\n+  return opnd->opcode() == VREG;\n@@ -3208,1 +2986,1 @@\n-  enc_class aarch64_enc_ldrvH(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvH(vReg dst, memory mem) %{\n@@ -3214,1 +2992,1 @@\n-  enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvS(vReg dst, memory mem) %{\n@@ -3220,1 +2998,1 @@\n-  enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvD(vReg dst, memory mem) %{\n@@ -3226,1 +3004,1 @@\n-  enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvQ(vReg dst, memory mem) %{\n@@ -3232,1 +3010,1 @@\n-  enc_class aarch64_enc_strvH(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvH(vReg src, memory mem) %{\n@@ -3238,1 +3016,1 @@\n-  enc_class aarch64_enc_strvS(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvS(vReg src, memory mem) %{\n@@ -3244,1 +3022,1 @@\n-  enc_class aarch64_enc_strvD(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvD(vReg src, memory mem) %{\n@@ -3250,1 +3028,1 @@\n-  enc_class aarch64_enc_strvQ(vecX src, memory mem) %{\n+  enc_class aarch64_enc_strvQ(vReg src, memory mem) %{\n@@ -4372,40 +4150,0 @@\n-operand immI_31()\n-%{\n-  predicate(n->get_int() == 31);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_2()\n-%{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_4()\n-%{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_8()\n-%{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5460,2 +5198,1 @@\n-\/\/ all vector operands, including NEON and SVE,\n-\/\/ but currently only used for SVE VecA.\n+\/\/ all vector operands, including NEON and SVE.\n@@ -5463,0 +5200,12 @@\n+%{\n+  constraint(ALLOC_IN_RC(dynamic));\n+  match(VecA);\n+  match(VecD);\n+  match(VecX);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vecA()\n@@ -5466,0 +5215,1 @@\n+\n@@ -6770,284 +6520,0 @@\n-pipe_class vmul64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmul128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdop64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vdop128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vlogical64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vlogical128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift64(vecD dst, vecD src, vecX shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift128(vecX dst, vecX src, vecX shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift64_imm(vecD dst, vecD src, immI shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift128_imm(vecX dst, vecX src, immI shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdop_fp64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdop_fp128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmuldiv_fp64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmuldiv_fp128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vsqrt_fp128(vecX dst, vecX src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vunop_fp64(vecD dst, vecD src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vunop_fp128(vecX dst, vecX src)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdup_reg_reg64(vecD dst, iRegI src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_reg128(vecX dst, iRegI src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_freg64(vecD dst, vRegF src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_freg128(vecX dst, vRegF src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vdup_reg_dreg128(vecX dst, vRegD src)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vmovi_reg_imm64(vecD dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vmovi_reg_imm128(vecX dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vload_reg_mem64(vecD dst, vmem8 mem)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  mem    : ISS(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vload_reg_mem128(vecX dst, vmem16 mem)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  mem    : ISS(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vstore_reg_mem64(vecD src, vmem8 mem)\n-%{\n-  single_instruction;\n-  mem    : ISS(read);\n-  src    : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vstore_reg_mem128(vecD src, vmem16 mem)\n-%{\n-  single_instruction;\n-  mem    : ISS(read);\n-  src    : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n@@ -9186,22 +8652,0 @@\n-instruct castVVD(vecD dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct castVVX(vecX dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n@@ -16957,0 +16401,2 @@\n+\/\/ Intrisics for String.compareTo()\n+\n@@ -17032,0 +16478,96 @@\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -17196,0 +16738,32 @@\n+instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, true \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, false \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":226,"deletions":652,"binary":false,"changes":878,"status":"modified"},{"patch":"@@ -1,6099 +0,0 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-\/\/ This file is automatically generated by running \"m4 aarch64_neon_ad.m4\". Do not edit ----\n-\n-\/\/ AArch64 NEON Architecture Description File\n-\n-\/\/ ====================VECTOR INSTRUCTIONS==================================\n-\n-\/\/ ------------------------------ Load\/store\/reinterpret -----------------------\n-\n-\/\/ Load Vector (16 bits)\n-instruct loadV2(vecD dst, vmem2 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 2);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrh   $dst,$mem\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (32 bits)\n-instruct loadV4(vecD dst, vmem4 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 4);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrs   $dst,$mem\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (64 bits)\n-instruct loadV8(vecD dst, vmem8 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 8);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrd   $dst,$mem\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (128 bits)\n-instruct loadV16(vecX dst, vmem16 mem)\n-%{\n-  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrq   $dst,$mem\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n-  ins_pipe(vload_reg_mem128);\n-%}\n-\n-\/\/ Store Vector (16 bits)\n-instruct storeV2(vecD src, vmem2 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 2);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strh   $mem,$src\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_strvH(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (32 bits)\n-instruct storeV4(vecD src, vmem4 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 4);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strs   $mem,$src\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_strvS(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (64 bits)\n-instruct storeV8(vecD src, vmem8 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 8);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strd   $mem,$src\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_strvD(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (128 bits)\n-instruct storeV16(vecX src, vmem16 mem)\n-%{\n-  predicate(n->as_StoreVector()->memory_size() == 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strq   $mem,$src\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_strvQ(src, mem) );\n-  ins_pipe(vstore_reg_mem128);\n-%}\n-\n-instruct reinterpretD(vecD dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretX(vecX dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretD2X(vecX dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# D to X\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct reinterpretX2D(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X to D\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct reinterpretS2X(vecX dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S to X\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretX2S(vecD dst, vecX src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# X to S\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretS2D(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# S to D\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretD2S(vecD dst, vecD src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 4 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# D to S\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-\n-instruct vcvt8Bto8S(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\t# convert 8B to 8S vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Bto4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\t# convert 4B to 4S vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt8Sto8B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\t# convert 8S to 8B vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\t# convert 4S to 4B vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl  $dst, T4S, $src, T4H\\t# convert 4S to 4I vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# convert 4I to 4S vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Ito2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"sxtl  $dst, T2D, $src, T2S\\t# convert 2I to 2L vector\" %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastL2X src));\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# convert 2L to 2I vector\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# convert 4I to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Bto4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl  $dst, T4S, $dst, T4H\\t# convert 4B to 4I vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2F(vecD dst, vecX src, vRegF tmp)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   rscratch1, $src, D, 0\\n\\t\"\n-            \"scvtfs $dst, rscratch1\\n\\t\"\n-            \"umov   rscratch1, $src, D, 1\\n\\t\"\n-            \"scvtfs $tmp, rscratch1\\n\\t\"\n-            \"ins    $dst, S, $tmp, 1, 0\\t# convert 2L to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-    __ scvtfs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ scvtfs(as_FloatRegister($tmp$$reg), rscratch1);\n-    __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg), 1, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Ito2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"scvtfv  T2S, $dst, $src\\t# convert 2I to 2F vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T2S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Ito4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"scvtfv  T4S, $dst, $src\\t# convert 4I to 4F vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Lto2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastL2X src));\n-  format %{ \"scvtfv  T2D, $dst, $src\\t# convert 2L to 2D vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Sto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastS2X src));\n-  format %{ \"sxtl    $dst, T4S, $src, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4S to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Ito2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  format %{ \"sxtl    $dst, T2D, $src, T2S\\n\\t\"\n-            \"scvtfv  T2D, $dst, $dst\\t# convert 2I to 2D vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ scvtfv(__ T2D, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Bto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4B to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl   $dst, T2D, $src, T2S\\n\\t\"\n-            \"fcvtzs  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T2S, $src\\t# convert 2F to 2I vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Fto4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\t# convert 4F to 4I vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Dto2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastD2X src));\n-  format %{ \"fcvtzs  $dst, T2D, $src\\t# convert 2D to 2L vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt4Fto4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\t# convert 4F to 4S vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Dto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n-            \"fcvtzdw  rscratch1, $src\\n\\t\"\n-            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n-            \"fmovs    $dst, rscratch1\\n\\t\"\n-            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n-    \/\/ saturation arithmetic. See JDK-8276151.\n-    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n-    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n-    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Fto4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\n\\t\"\n-            \"xtn     $dst, T8B, $dst, T8H\\t# convert 4F to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2D(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl  $dst, T2D, $src, T2S\\t# convert 2F to 2D vector\" %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vcvt2Dto2F(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  format %{ \"fcvtn  $dst, T2S, $src, T2D\\t# convert 2D to 2F vector\" %}\n-  ins_encode %{\n-    __ fcvtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\n-instruct vroundvecD2Fto2I(vecD dst, vecD src, vecD tmp1, vecD tmp2, vecD tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T2S, $src\\t# round vecD 2F to 2I vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T2S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundvecX4Fto4I(vecX dst, vecX src, vecX tmp1, vecX tmp2, vecX tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T4S, $src\\t# round vecX 4F to 4I vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundvecX2Dto2L(vecX dst, vecX src, vecX tmp1, vecX tmp2, vecX tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (RoundVD src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, T2D, $src\\t# round vecX 2D to 2L vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Reduction -------------------------------\n-\n-instruct reduce_add8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# add reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\t# add reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ smaxv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T16B, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T8H, $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T8H, as_FloatRegister($vsrc$$reg));\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminv $tmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ sminv(as_FloatRegister($tmp$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"smaxp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc GT\\t# max reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ smaxp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"sminp $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc LT\\t# min reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ sminp(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp GT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp GT\\t# max reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::GT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_min2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp LT\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp LT\\t# min reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::LT);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxp $dst, $vsrc, S\\n\\t\"\n-            \"fmaxs $dst, $dst, $fsrc\\t# max reduction2F\" %}\n-  ins_encode %{\n-    __ fmaxp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ S);\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxv $dst,  T4S, $vsrc\\n\\t\"\n-            \"fmaxs $dst, $dst, $fsrc\\t# max reduction4F\" %}\n-  ins_encode %{\n-    __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fmaxp $dst, $vsrc, D\\n\\t\"\n-            \"fmaxd $dst, $dst, $dsrc\\t# max reduction2D\" %}\n-  ins_encode %{\n-    __ fmaxp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ D);\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminp $dst, $vsrc, S\\n\\t\"\n-            \"fmins $dst, $dst, $fsrc\\t# min reduction2F\" %}\n-  ins_encode %{\n-    __ fminp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ S);\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminv $dst,  T4S, $vsrc\\n\\t\"\n-            \"fmins $dst, $dst, $fsrc\\t# min reduction4F\" %}\n-  ins_encode %{\n-    __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"fminp $dst, $vsrc, D\\n\\t\"\n-            \"fmind $dst, $dst, $dsrc\\t# min reduction2D\" %}\n-  ins_encode %{\n-    __ fminp(as_FloatRegister($dst$$reg), as_FloatRegister($vsrc$$reg), __ D);\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_and8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"andw   $dst, $dst, $tmp\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# and reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"orrw   $dst, $dst, $tmp\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# orr reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"eorw   $dst, $dst, $tmp\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# eor reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# and reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# orr reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# eor reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"andw   $dst, $dst, $tmp\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# and reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"orrw   $dst, $dst, $tmp\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# orr reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"eorw   $dst, $dst, $tmp\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# eor reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# and reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# orr reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# eor reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"andw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"andw  $dst, $tmp, $dst\\t# and reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ andw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ andw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"orrw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"orrw  $dst, $tmp, $dst\\t# orr reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ orrw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ orrw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"eorw  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"eorw  $dst, $tmp, $dst\\t# eor reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ eorw($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ eorw($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"andr   $dst, $dst, $tmp\\n\\t\"\n-            \"andr   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"andw   $dst, $isrc, $dst\\t# and reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ andr($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ andw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"orr    $dst, $dst, $tmp\\n\\t\"\n-            \"orr    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"orrw   $dst, $isrc, $dst\\t# orr reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ orr ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ orrw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"eor    $dst, $dst, $tmp\\n\\t\"\n-            \"eor    $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"eorw   $dst, $isrc, $dst\\t# eor reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ eor ($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ eorw($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_and2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"andr  $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"andr  $dst, $dst, $tmp\\t# and reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ andr($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ andr($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orr2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"orr   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"orr   $dst, $dst, $tmp\\t# orr reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ orr ($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ orr ($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eor2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"eor   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"eor   $dst, $dst, $tmp\\t# eor reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ eor ($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ eor ($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertID(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertIX(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2L(vecX dst, vecX src, iRegL val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D,\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2F(vecD dst, vecD src, vRegF val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insert into vector(2F)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert4F(vecX dst, vecX src, vRegF val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insert into vector(4F)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2D(vecX dst, vecX src, vRegD val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insert into vector(2D)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-\n-instruct extract8B(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, B, $idx\\t# extract from vector(8B)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract16B(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 16);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, B, $idx\\t# extract from vector(16B)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4S(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, H, $idx\\t# extract from vector(4S)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract8S(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov    $dst, $src, H, $idx\\t# extract from vector(8S)\" %}\n-  ins_encode %{\n-    __ smov($dst$$Register, as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2I(iRegINoSp dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, S, $idx\\t# extract from vector(2I)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4I(iRegINoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, S, $idx\\t# extract from vector(4I)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2L(iRegLNoSp dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractL src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov    $dst, $src, D, $idx\\t# extract from vector(2L)\" %}\n-  ins_encode %{\n-    __ umov($dst$$Register, as_FloatRegister($src$$reg), __ D, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2F(vRegF dst, vecD src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, S, $src, 0, $idx\\t# extract from vector(2F)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ S,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract4F(vRegF dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 4);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, S, $src, 0, $idx\\t# extract from vector(4F)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ S,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extract2D(vRegD dst, vecX src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == 2);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, D, $src, 0, $idx\\t# extract from vector(2D)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ D,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector comparison ---------------------------------\n-\n-instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(type2aelembytes(bt) != 8, \"not supported\");\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ ------------------------------ Vector mul -----------------------------------\n-\n-instruct vmul2L(vecX dst, vecX src1, vecX src2, iRegLNoSp tmp1, iRegLNoSp tmp2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVL src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"umov   $tmp1, $src1, D, 0\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 0\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   0, $tmp2\\t# insert into vector(2L)\\n\\t\"\n-            \"umov   $tmp1, $src1, D, 1\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 1\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   1, $tmp2\\t# insert into vector(2L)\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 0);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 0);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 1);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 1);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- Vector not --------------------------------\n-\n-instruct vnot2I(vecD dst, vecD src, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T8B, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vnot4I(vecX dst, vecX src, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vnot2L(vecX dst, vecX src, immL_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src (ReplicateL m1)));\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector and_not -------------------------------\n-\n-instruct vand_not2I(vecD dst, vecD src1, vecD src2, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vand_not4I(vecX dst, vecX src1, vecX src2, immI_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vand_not2L(vecX dst, vecX src1, vecX src2, immL_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ------------------------------ Vector max\/min -------------------------------\n-\n-instruct vmax8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmax4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T4H, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T8H, $src1, $src2\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmax2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T2S, $src1, $src2\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmax4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"maxv  $dst, T4S, $src1, $src2\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ maxv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T8B, $src1, $src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T4H, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T8H, $src1, $src2\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T2S, $src1, $src2\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vmin4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"minv  $dst, T4S, $src1, $src2\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ minv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\n-instruct vmax2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $src1, $src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vmin2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $src2, $src1\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ --------------------------------- blend (bsl) ----------------------------\n-\n-instruct vbsl8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T8B, $src2, $src1\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vbsl16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T16B, $src2, $src1\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- Load\/store Mask ----------------------------\n-\n-instruct loadmask8B(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T8B, $src\\t# load mask (8B to 8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadmask16B(vecX dst, vecX src  )\n-%{\n-  predicate(n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T16B, $src\\t# load mask (16B to 16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct storemask8B(vecD dst, vecD src , immI_1 size)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T8B, $src\\t# store mask (8B to 8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct storemask16B(vecX dst, vecX src , immI_1 size)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T16B, $src\\t# store mask (16B to 16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadmask4S(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"negr  $dst, T8H, $dst\\t# load mask (4B to 4H)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask8S(vecX dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 8 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\n\\t\"\n-            \"negr  $dst, T8H, $dst\\t# load mask (8B to 8H)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask4S(vecD dst, vecD src , immI_2 size)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\n\\t\"\n-            \"negr  $dst, T8B, $dst\\t# store mask (4H to 4B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask8S(vecD dst, vecX src , immI_2 size)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T8B, $src, T8H\\n\\t\"\n-            \"negr  $dst, T8B, $dst\\t# store mask (8H to 8B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask2I(vecD dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2H\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2H to 2S\\n\\t\"\n-            \"negr   $dst, T4S, $dst\\t# load mask (2B to 2S)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask4I(vecX dst, vecD src  )\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadMask src ));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\\n\\t\"\n-            \"negr   $dst, T4S, $dst\\t# load mask (4B to 4S)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2I(vecD dst, vecD src , immI_4 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# 2S to 2H\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2H to 2B\\n\\t\"\n-            \"negr   $dst, T8B, $dst\\t# store mask (2S to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask4I(vecD dst, vecX src , immI_4 size)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T4H, $src, T4S\\t# 4S to 4H\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 4H to 4B\\n\\t\"\n-            \"negr   $dst, T8B, $dst\\t# store mask (4S to 4B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadmask2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2S\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2S to 2I\\n\\t\"\n-            \"uxtl  $dst, T2D, $dst, T2S\\t# 2I to 2L\\n\\t\"\n-            \"neg   $dst, T2D, $dst\\t# load mask (2B to 2L)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2L(vecD dst, vecX src, immI_8 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# 2L to 2I\\n\\t\"\n-            \"xtn  $dst, T4H, $dst, T4S\\t# 2I to 2S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2S to 2B\\n\\t\"\n-            \"neg  $dst, T8B, $dst\\t# store mask (2L to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask cast\n-\n-instruct vmaskcastD(vecD dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcastX(vecX dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-\/\/-------------------------------- LOAD_IOTA_INDICES----------------------------------\n-\n-instruct loadcon8B(vecD dst, immI0 src)\n-%{\n-  predicate(UseSVE == 0 &&\n-           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8) &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldrd(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct loadcon16B(vecX dst, immI0 src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldrq(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/-------------------------------- LOAD_SHUFFLE ----------------------------------\n-\n-instruct loadshuffle8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T8B, $src\\t# get 8B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T16B, $src\\t# get 16B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle8S(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 8B to 8H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct loadshuffle4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H \\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Rearrange -------------------------------------\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-instruct rearrange8B(vecD dst, vecD src, vecD shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T8B, {$dst}, $shuffle\\t# rearrange 8B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange16B(vecX dst, vecX src, vecX shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T16B, {$dst}, $shuffle\\t# rearrange 16B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange4S(vecD dst, vecD src, vecD shuffle, vecD tmp0, vecD tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T8B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T4H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T4H, T4H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T8B, T8B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T8B, {$src}, 1, $dst\\t# rearrange 4S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T8B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange8S(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T8H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T8H, T8H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 8S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T8H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrange4I(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0404040404040404\\n\\t\"\n-            \"mov   $tmp1, T4S, CONSTANT\\t# constant 0x0302010003020100\\n\\t\"\n-            \"mulv  $dst, T4S, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 4I\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x04);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4S, 0x03020100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Anytrue\/alltrue -----------------------------\n-\n-instruct anytrue_in_mask8B(iRegINoSp dst, vecD src1, vecD src2, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T8B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue 8B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct anytrue_in_mask16B(iRegINoSp dst, vecX src1, vecX src2, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T16B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue 16B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct alltrue_in_mask8B(iRegINoSp dst, vecD src1, vecD src2, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T8B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue 8B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct alltrue_in_mask16B(iRegINoSp dst, vecX src1, vecX src2, vecX tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T16B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue 16B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- ABS --------------------------------------\n-\n-instruct vabs8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T8B, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T16B, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T4H, $src\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs8S(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T8H, $src\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T2S, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T4S, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, T2D, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T2S, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabs4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T4S, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabs2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst, T2D, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-\/\/ --------------------------------- FABS DIFF --------------------------------\n-\n-instruct vabd2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF (SubVF src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T2S, $src1, $src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabd4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF (SubVF src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T4S, $src1, $src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabd2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD (SubVD src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabd  $dst, T2D, $src1, $src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabd(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct replicate8B(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4));\n-  match(Set dst (ReplicateB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate16B(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n-  match(Set dst (ReplicateB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate8B_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4));\n-  match(Set dst (ReplicateB con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T8B, $con$$constant & 0xff);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate16B_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n-  match(Set dst (ReplicateB con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T16B, $con$$constant & 0xff);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate4S(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2));\n-  match(Set dst (ReplicateS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate8S(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (8S)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate4S_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2));\n-  match(Set dst (ReplicateS con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T4H, $con$$constant & 0xffff);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate8S_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n-  match(Set dst (ReplicateS con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T8H, $con$$constant & 0xffff);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2I(vecD dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct replicate4I(vecX dst, iRegIorL2I src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate2I_imm(vecD dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (2I)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T2S, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm64);\n-%}\n-\n-instruct replicate4I_imm(vecX dst, immI con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (4I)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T4S, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2L(vecX dst, iRegL src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2D, as_Register($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct replicate2L_imm(vecX dst, immL con)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateL con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, $con$$constant);\n-  %}\n-  ins_pipe(vmovi_reg_imm128);\n-%}\n-\n-instruct replicate2F(vecD dst, vRegF src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_freg64);\n-%}\n-\n-instruct replicate4F(vecX dst, vRegF src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (4F)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_freg128);\n-%}\n-\n-instruct replicate2D(vecX dst, vRegD src)\n-%{\n-  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n-  match(Set dst (ReplicateD src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vdup_reg_dreg128);\n-%}\n-\n-\/\/ ====================REDUCTION ARITHMETIC====================================\n-\n-instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ \"addv  $vtmp, T4S, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp, TEMP dst);\n-  format %{ \"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (AddReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fadds $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\t# add reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fadds $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fadds $dst, $dst, $tmp\\t# add reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fadds(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction2F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuls $dst, $fsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"fmuls $dst, $dst, $tmp\\t# mul reduction4F\"\n-  %}\n-  ins_encode %{\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ fmuls(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_add2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"faddd $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"faddd $dst, $dst, $tmp\\t# add reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ faddd(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ faddd(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (MulReductionVD dsrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"fmuld $dst, $dsrc, $vsrc\\n\\t\"\n-            \"ins   $tmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"fmuld $dst, $dst, $tmp\\t# mul reduction2D\"\n-  %}\n-  ins_encode %{\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ fmuld(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ====================VECTOR ARITHMETIC=======================================\n-\n-\/\/ --------------------------------- ADD --------------------------------------\n-\n-instruct vadd8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vadd4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"addv  $dst,$src1,$src2\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vadd2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vadd4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vadd2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  match(Set dst (AddVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fadd  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fadd(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-\/\/ --------------------------------- SUB --------------------------------------\n-\n-instruct vsub8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vsub4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2L(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"subv  $dst,$src1,$src2\\t# vector (2L)\" %}\n-  ins_encode %{\n-    __ subv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vsub2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vsub4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vsub2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fsub  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fsub(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-\/\/ --------------------------------- MUL --------------------------------------\n-\n-instruct vmul8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (MulVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (MulVB src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (MulVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (MulVS src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul64);\n-%}\n-\n-instruct vmul4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (MulVI src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"mulv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul128);\n-%}\n-\n-instruct vmul2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-instruct vmul4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-instruct vmul2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmul  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmul(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- MLA --------------------------------------\n-\n-instruct vmla4S(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmla8S(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-instruct vmla2I(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmla4I(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlav  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mlav(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVF  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 4);\n-  match(Set dst (FmaVF  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ dst + src1 * src2\n-instruct vmla2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVD  dst (Binary src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmla  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmla(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- MLS --------------------------------------\n-\n-instruct vmls4S(vecD dst, vecD src1, vecD src2) %{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n-  match(Set dst (SubVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmls8S(vecX dst, vecX src1, vecX src2) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (SubVS dst (MulVS src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-instruct vmls2I(vecD dst, vecD src1, vecD src2) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SubVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla64);\n-%}\n-\n-instruct vmls4I(vecX dst, vecX src1, vecX src2) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SubVI dst (MulVI src1 src2)));\n-  ins_cost(INSN_COST);\n-  format %{ \"mlsv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ mlsv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmla128);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls2F(vecD dst, vecD src1, vecD src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVF  dst (Binary (NegVF src1) src2)));\n-  match(Set dst (FmaVF  dst (Binary src1 (NegVF src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls4F(vecX dst, vecX src1, vecX src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 4);\n-  match(Set dst (FmaVF  dst (Binary (NegVF src1) src2)));\n-  match(Set dst (FmaVF  dst (Binary src1 (NegVF src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ dst - src1 * src2\n-instruct vmls2D(vecX dst, vecX src1, vecX src2) %{\n-  predicate(UseFMA && n->as_Vector()->length() == 2);\n-  match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));\n-  match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmls  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmls(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------- Vector Multiply-Add Shorts into Integer --------------------\n-\n-instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulAddVS2VI src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"smullv  $tmp, $src1, $src2\\t# vector (4H)\\n\\t\"\n-            \"smullv  $dst, $src1, $src2\\t# vector (8H)\\n\\t\"\n-            \"addpv   $dst, $tmp, $dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ smullv(as_FloatRegister($tmp$$reg), __ T4H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ smullv(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ addpv(as_FloatRegister($dst$$reg), __ T4S,\n-             as_FloatRegister($tmp$$reg),\n-             as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- DIV --------------------------------------\n-\n-instruct vdiv2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (DivVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp64);\n-%}\n-\n-instruct vdiv4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (DivVF src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-instruct vdiv2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (DivVD src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fdiv  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fdiv(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- SQRT -------------------------------------\n-\n-instruct vsqrt2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SqrtVF src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vsqrt4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (SqrtVF src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (4F)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vsqrt_fp128);\n-%}\n-\n-instruct vsqrt2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (SqrtVD src));\n-  format %{ \"fsqrt  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fsqrt(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vsqrt_fp128);\n-%}\n-\n-\/\/ --------------------------------- NEG --------------------------------------\n-\n-instruct vnegID(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() < 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vnegIX(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vneg4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (NegVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vneg2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (NegVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fneg  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fneg(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-\/\/ --------------------------------- AND --------------------------------------\n-\n-instruct vand8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"and  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ andr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vand16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"and  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ andr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- OR ---------------------------------------\n-\n-instruct vor8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vor16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ --------------------------------- XOR --------------------------------------\n-\n-instruct vxor8B(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 4 ||\n-            n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"xor  $dst,$src1,$src2\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vxor16B(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"xor  $dst,$src1,$src2\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-\/\/ ------------------------------ Shift ---------------------------------------\n-\n-\/\/ Vector shift count\n-\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n-\/\/         treat it as ints or bytes here.\n-\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n-\/\/         on vsra8B rule for more details.\n-\n-instruct vslcnt8B(vecD dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n-                            n->as_Vector()->length_in_bytes() == 8));\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector (8B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct vslcnt16B(vecX dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector (16B)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct vsrcnt8B(vecD dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n-                            n->as_Vector()->length_in_bytes() == 8));\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector (8B)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T8B, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg64);\n-%}\n-\n-instruct vsrcnt16B(vecX dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector (16B)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T16B, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg128);\n-%}\n-\n-instruct vsll8B(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);\n-  match(Set dst (LShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (LShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-\/\/ Right shifts with vector shift count on aarch64 SIMD are implemented\n-\/\/ as left shift by negative shift count.\n-\/\/ There are two cases for vector shift count.\n-\/\/\n-\/\/ Case 1: The vector shift count is from replication.\n-\/\/        |            |\n-\/\/    LoadVector  RShiftCntV\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ Case 2: The vector shift count is from loading.\n-\/\/ This case isn't supported by middle-end now. But it's supported by\n-\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n-\/\/        |            |\n-\/\/    LoadVector  LoadVector\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n-\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n-\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n-\/\/ to outer loop and merged into one neg instruction.\n-\/\/\n-\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n-\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n-\/\/ i.e. case 1).\n-\n-instruct vsra8B(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra8B_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra16B_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl8B(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl8B_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl16B(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl16B_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVB src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T8B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll4S(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);\n-  match(Set dst (LShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (LShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra4S(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra4S_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra8S_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl4S(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl4S_var(vecD dst, vecD src, vecD shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl8S(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl8S_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVS src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T4H,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T8H,\n-             as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n-            assert_not_var_shift(n));\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T4H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (LShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsll4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (LShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra2I_var(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsra4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra4I_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2I(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl2I_var(vecD dst, vecD src, vecD shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift64);\n-%}\n-\n-instruct vsrl4I(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl4I_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVI src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T4S,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsra4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrl4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsll2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (LShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsra2L_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (RShiftVL src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2L(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVL src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsrl2L_var(vecX dst, vecX src, vecX shift) %{\n-  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n-  match(Set dst (URShiftVL src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift128);\n-%}\n-\n-instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (LShiftVL src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ shl(as_FloatRegister($dst$$reg), __ T2D,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsra2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (RShiftVL src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ sshr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrl2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n-  match(Set dst (URShiftVL src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ushr(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src$$reg), sh);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsraa4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsraa2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ ssra(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla8B_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (8B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T8B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla16B_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (16B)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla4S_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (4H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T4H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla8S_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (8H)\" %}\n-  ins_encode %{\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src$$reg), sh);\n-    }\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla2I_imm(vecD dst, vecD src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift64_imm);\n-%}\n-\n-instruct vsrla4I_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vsrla2L_imm(vecX dst, vecX src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ usra(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);\n-  %}\n-  ins_pipe(vshift128_imm);\n-%}\n-\n-instruct vmax2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vmax4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmax2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmax  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmax(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmin2F(vecD dst, vecD src1, vecD src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (2F)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp64);\n-%}\n-\n-instruct vmin4F(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vmin2D(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinV src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"fmin  $dst,$src1,$src2\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fmin(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"frint  $dst, $src, $rmode\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ frintn(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ frintm(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ frintp(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-\n-instruct vpopcountID(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() < 16);\n-  match(Set dst (PopCountVI src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"vpopcountI  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg));\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vpopcountIX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (PopCountVI src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"vpopcountI  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountLX\" rule.\n-instruct vpopcountLD(vecD dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() < 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vpopcountL  $dst, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($dst$$reg), __ T2D);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vpopcountLX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vpopcountL  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ vector mask reductions\n-\n-instruct vmask_truecount8B(iRegINoSp dst, vecD src, vecD tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_truecount16B(iRegINoSp dst, vecX src, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_LT8B(iRegINoSp dst, vecD src, rFlagsReg cr) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  ins_cost(7 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (4I\/4S\/2I)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() == 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(6 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label FIRST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, zr);\n-    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8);\n-\n-    \/\/ Reverse the bits and count the leading zero bytes.\n-    __ bind(FIRST_TRUE_INDEX);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by counting the leading zero bytes and\n-    \/\/ subtracting it by 7 (VLENGTH - 1).\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ movw(rscratch1, 7);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label LAST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 16 - 1);\n-    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8 - 1);\n-\n-    \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n-    __ bind(LAST_TRUE_INDEX);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong8B(iRegLNoSp dst, vecD src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ fmovd(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n-    __ bytemask_compress(as_Register($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong16B(iRegLNoSp dst, vecX src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(11 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, 0);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ bytemask_compress(as_Register($dst$$reg));\n-    __ bytemask_compress(rscratch1);\n-    __ orr(as_Register($dst$$reg), as_Register($dst$$reg),\n-           rscratch1, Assembler::LSL, 8);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------- CountLeadingZerosV -----------------------------\n-\n-instruct countLeadingZerosVD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"countLeadingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct countLeadingZerosVX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"countLeadingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------- CountTrailingZerosV ----------------------------\n-\n-instruct countTrailingZerosVD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"countTrailingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct countTrailingZerosVX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(3 * INSN_COST);\n-  format %{ \"countTrailingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/------------------------------ ReverseV -----------------------------------\n-\n-instruct vreverseD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (ReverseV src));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"ReverseV $dst, $src\\t# vector (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vreverseX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (ReverseV src));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"ReverseV $dst, $src\\t# vector (X)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/---------------------------- ReverseBytesV --------------------------------\n-\n-instruct vreverseBytesD(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ReverseBytesV $dst, $src\\t# vector (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vreverseBytesX(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ReverseBytesV $dst, $src\\t# vector (X)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":0,"deletions":6099,"binary":false,"changes":6099,"status":"deleted"},{"patch":"@@ -1,2749 +0,0 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-dnl Generate the warning\n-\/\/ This file is automatically generated by running \"m4 aarch64_neon_ad.m4\". Do not edit ----\n-dnl\n-\n-\/\/ AArch64 NEON Architecture Description File\n-\n-dnl\n-define(`ORL2I', `ifelse($1,I,orL2I)')dnl\n-dnl\n-define(`error', `__program__:__file__:__line__: Invalid argument ``$1''m4exit(`1')')dnl\n-dnl\n-define(`iTYPE2SIMD',\n-`ifelse($1, `B', `B',\n-        $1, `S', `H',\n-        $1, `I', `S',\n-        $1, `L', `D',\n-        `error($1)')')dnl\n-dnl\n-define(`fTYPE2SIMD',\n-`ifelse($1, `F', `S',\n-        $1, `D', `D',\n-        `error($1)')')dnl\n-dnl\n-define(`TYPE2DATATYPE',\n-`ifelse($1, `B', `BYTE',\n-        $1, `S', `SHORT',\n-        $1, `I', `INT',\n-        $1, `L', `LONG',\n-        $1, `F', `FLOAT',\n-        $1, `D', `DOUBLE',\n-        `error($1)')')dnl\n-dnl\n-\/\/ ====================VECTOR INSTRUCTIONS==================================\n-\n-\/\/ ------------------------------ Load\/store\/reinterpret -----------------------\n-define(`VLoadStore', `\n-\/\/ ifelse(load, $3, Load, Store) Vector ($6 bits)\n-instruct $3V$4`'(vec$5 $7, vmem$4 mem)\n-%{\n-  predicate($8`n->as_'ifelse(load, $3, Load, Store)Vector()->memory_size() == $4);\n-  match(Set ifelse(load, $3, dst (LoadVector mem), mem (StoreVector mem src)));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"$1   ifelse(load, $3, `$dst,$mem', `$mem,$src')\\t# vector ($6 bits)\" %}\n-  ins_encode( `aarch64_enc_'ifelse(load, $3, ldr, str)v$2($7, mem) );\n-  ins_pipe(v$3`_reg_mem'ifelse(eval($4 * 8), 128, 128, 64));\n-%}')dnl\n-dnl        $1    $2 $3     $4  $5 $6   $7   $8\n-VLoadStore(ldrh, H, load,  2,  D, 16,  dst, UseSVE == 0 && )\n-VLoadStore(ldrs, S, load,  4,  D, 32,  dst, UseSVE == 0 && )\n-VLoadStore(ldrd, D, load,  8,  D, 64,  dst, UseSVE == 0 && )\n-VLoadStore(ldrq, Q, load, 16,  X, 128, dst, UseSVE == 0 && )\n-VLoadStore(strh, H, store, 2,  D, 16,  src, )\n-VLoadStore(strs, S, store, 4,  D, 32,  src, )\n-VLoadStore(strd, D, store, 8,  D, 64,  src, )\n-VLoadStore(strq, Q, store, 16, X, 128, src, )\n-dnl\n-define(`REINTERPRET', `\n-instruct reinterpret$1`'(vec$1 dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2);\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \" # reinterpret $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}')dnl\n-dnl         $1 $2\n-REINTERPRET(D, 8)\n-REINTERPRET(X, 16)\n-dnl\n-define(`REINTERPRET_DX', `\n-instruct reinterpret$1`'2$2`'(vec$2 dst, vec$1 src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $3 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $4);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n-  ins_encode %{\n-    \/\/ The higher 64-bits of the \"dst\" register must be cleared to zero.\n-    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-           as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}')dnl\n-dnl            $1 $2 $3  $4\n-REINTERPRET_DX(D, X, 16, 8)\n-REINTERPRET_DX(X, D, 8,  16)\n-dnl\n-define(`REINTERPRET_SX', `\n-instruct reinterpret$1`'2$2`'(vec$3 dst, vec$4 src)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $5 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $6);\n-  match(Set dst (VectorReinterpret src));\n-  ins_cost(INSN_COST);\n-  format %{ \" # reinterpret $dst,$src\\t# $1 to $2\" %}\n-  ins_encode %{\n-    \/\/ The higher bits of the \"dst\" register must be cleared to zero.\n-    __ dup(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl            $1 $2 $3 $4 $5  $6\n-REINTERPRET_SX(S, X, X, D, 16, 4)\n-REINTERPRET_SX(X, S, D, X, 4,  16)\n-REINTERPRET_SX(S, D, D, D, 8,  4)\n-REINTERPRET_SX(D, S, D, D, 4,  8)\n-dnl\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-dnl\n-define(`VECTOR_CAST_I2I', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"$6  $dst, T$8, $src, T$7\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$8, as_FloatRegister($src$$reg), __ T$7);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5 $6    $7  $8\n-VECTOR_CAST_I2I(8, B, S, X, D, sxtl, 8B, 8H)\n-VECTOR_CAST_I2I(4, B, S, D, D, sxtl, 8B, 8H)\n-VECTOR_CAST_I2I(8, S, B, D, X, xtn,  8H, 8B)\n-VECTOR_CAST_I2I(4, S, B, D, D, xtn,  8H, 8B)\n-VECTOR_CAST_I2I(4, S, I, X, D, sxtl, 4H, 4S)\n-VECTOR_CAST_I2I(4, I, S, D, X, xtn,  4S, 4H)\n-VECTOR_CAST_I2I(2, I, L, X, D, sxtl, 2S, 2D)\n-VECTOR_CAST_I2I(2, L, I, D, X, xtn,  2D, 2S)\n-dnl\n-define(`VECTOR_CAST_I2I_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"$6  $dst, T$8, $src, T$7\\n\\t\"\n-            \"$6  $dst, T$10, $dst, T$9\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$8, as_FloatRegister($src$$reg), __ T$7);\n-    __ $6(as_FloatRegister($dst$$reg), __ T$10, as_FloatRegister($dst$$reg), __ T$9);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6    $7  $8  $9  $10\n-VECTOR_CAST_I2I_L(4, I, B, D, X, xtn,  4S, 4H, 8H, 8B)\n-VECTOR_CAST_I2I_L(4, B, I, X, D, sxtl, 8B, 8H, 4H, 4S)\n-dnl\n-\n-instruct vcvt2Lto2F(vecD dst, vecX src, vRegF tmp)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   rscratch1, $src, D, 0\\n\\t\"\n-            \"scvtfs $dst, rscratch1\\n\\t\"\n-            \"umov   rscratch1, $src, D, 1\\n\\t\"\n-            \"scvtfs $tmp, rscratch1\\n\\t\"\n-            \"ins    $dst, S, $tmp, 1, 0\\t# convert 2L to 2F vector\"\n-  %}\n-  ins_encode %{\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n-    __ scvtfs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ scvtfs(as_FloatRegister($tmp$$reg), rscratch1);\n-    __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg), 1, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_I2F', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"scvtfv  T$5, $dst, $src\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ scvtfv(__ T$5, as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5\n-VECTOR_CAST_I2F(2, I, F, D, 2S)\n-VECTOR_CAST_I2F(4, I, F, X, 4S)\n-VECTOR_CAST_I2F(2, L, D, X, 2D)\n-dnl\n-define(`VECTOR_CAST_I2F_L', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$5 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"sxtl    $dst, T$7, $src, T$6\\n\\t\"\n-            \"scvtfv  T$7, $dst, $dst\\t# convert $1$2 to $1$3 vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($src$$reg), __ T$6);\n-    __ scvtfv(__ T$7, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1 $2 $3 $4 $5 $6  $7\n-VECTOR_CAST_I2F_L(4, S, F, X, D, 4H, 4S)\n-VECTOR_CAST_I2F_L(2, I, D, X, D, 2S, 2D)\n-dnl\n-\n-instruct vcvt4Bto4F(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  format %{ \"sxtl    $dst, T8H, $src, T8B\\n\\t\"\n-            \"sxtl    $dst, T4S, $dst, T4H\\n\\t\"\n-            \"scvtfv  T4S, $dst, $dst\\t# convert 4B to 4F vector\"\n-  %}\n-  ins_encode %{\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ sxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ scvtfv(__ T4S, as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Fto2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtl   $dst, T2D, $src, T2S\\n\\t\"\n-            \"fcvtzs  $dst, T2D, $dst\\t# convert 2F to 2L vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg), __ T2S);\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_F2I', `\n-instruct vcvt$1$2to$1$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst (VectorCast$2`'2X src));\n-  format %{ \"fcvtzs  $dst, T$5, $src\\t# convert $1$2 to $1$3 vector\" %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T$5, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5\n-VECTOR_CAST_F2I(2, F, I, D, 2S)\n-VECTOR_CAST_F2I(4, F, I, X, 4S)\n-VECTOR_CAST_F2I(2, D, L, X, 2D)\n-\n-instruct vcvt4Fto4S(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\t# convert 4F to 4S vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt2Dto2I(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"ins      $dst, D, $src, 0, 1\\n\\t\"\n-            \"fcvtzdw  rscratch1, $src\\n\\t\"\n-            \"fcvtzdw  rscratch2, $dst\\n\\t\"\n-            \"fmovs    $dst, rscratch1\\n\\t\"\n-            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n-    \/\/ saturation arithmetic. See JDK-8276151.\n-    __ fcvtzdw(rscratch1, as_FloatRegister($src$$reg));\n-    __ fcvtzdw(rscratch2, as_FloatRegister($dst$$reg));\n-    __ fmovs(as_FloatRegister($dst$$reg), rscratch1);\n-    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvt4Fto4B(vecD dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  format %{ \"fcvtzs  $dst, T4S, $src\\n\\t\"\n-            \"xtn     $dst, T4H, $dst, T4S\\n\\t\"\n-            \"xtn     $dst, T8B, $dst, T8H\\t# convert 4F to 4B vector\"\n-  %}\n-  ins_encode %{\n-    __ fcvtzs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`VECTOR_CAST_F2F', `\n-instruct vcvt2$1to2$2`'(vec$3 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  format %{ \"$5  $dst, T$7, $src, T$6\\t# convert 2$1 to 2$2 vector\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ T$7, as_FloatRegister($src$$reg), __ T$6);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1 $2 $3 $4 $5     $6  $7\n-VECTOR_CAST_F2F(F, D, X, D, fcvtl, 2S, 2D)\n-VECTOR_CAST_F2F(D, F, D, X, fcvtn, 2D, 2S)\n-dnl\n-\n-define(`VECTOR_JAVA_FROUND', `\n-instruct vround$7$2to$5$3($7 dst, $7 src, $7 tmp1, $7 tmp2, $7 tmp3)\n-%{\n-  predicate(UseSVE == 0 &&\n-            n->as_Vector()->length() == $5 && n->bottom_type()->is_vect()->element_basic_type() == T_$6);\n-  match(Set dst (RoundV$1 src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  format %{ \"vround  $dst, $4, $src\\t# round $7 $2 to $5$3 vector\" %}\n-  ins_encode %{\n-    __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                         as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                         as_FloatRegister($tmp3$$reg), __ $4);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl           $1  $2  $3   $4 $5    $6    $7\n-VECTOR_JAVA_FROUND(F, 2F,  I, T2S, 2,  INT, vecD)\n-VECTOR_JAVA_FROUND(F, 4F,  I, T4S, 4,  INT, vecX)\n-VECTOR_JAVA_FROUND(D, 2D,  L, T2D, 2, LONG, vecX)\n-\n-\/\/ ------------------------------ Reduction -------------------------------\n-dnl\n-define(`REDUCE_ADD_BORS', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addv  $tmp, T$1`'iTYPE2SIMD($2), $vsrc\\n\\t\"\n-            \"smov  $dst, $tmp, iTYPE2SIMD($2), 0\\n\\t\"\n-            \"addw  $dst, $dst, $isrc\\n\\t\"\n-            \"sxt$4  $dst, $dst\\t# add reduction$1$2\"\n-  %}\n-  ins_encode %{\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1`'iTYPE2SIMD($2), as_FloatRegister($vsrc$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($2), 0);\n-    __ addw($dst$$Register, $dst$$Register, $isrc$$Register);\n-    __ sxt$4($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2 $3 $4\n-REDUCE_ADD_BORS(8,  B, D, b)\n-REDUCE_ADD_BORS(16, B, X, b)\n-REDUCE_ADD_BORS(4,  S, D, h)\n-REDUCE_ADD_BORS(8,  S, X, h)\n-dnl\n-\n-instruct reduce_add2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, vecX tmp)\n-%{\n-  match(Set dst (AddReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"addpd $tmp, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add   $dst, $isrc, $dst\\t# add reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ addpd(as_FloatRegister($tmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp1, vecD vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"ins   $vtmp2, H, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T8B, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxtb  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, B, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxtb  $dst, $dst\\t# mul reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ H,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T8B,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ B, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp, TEMP itmp);\n-  format %{ \"ins   $vtmp, S, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T4H, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T4H,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp1, vecX vtmp2, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP itmp);\n-  format %{ \"ins   $vtmp1, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp1, T4H, $vtmp1, $vsrc\\n\\t\"\n-            \"ins   $vtmp2, S, $vtmp1, 0, 1\\n\\t\"\n-            \"mulv  $vtmp2, T4H, $vtmp2, $vtmp1\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 0\\n\\t\"\n-            \"mulw  $dst, $itmp, $isrc\\n\\t\"\n-            \"sxth  $dst, $dst\\n\\t\"\n-            \"umov  $itmp, $vtmp2, H, 1\\n\\t\"\n-            \"mulw  $dst, $itmp, $dst\\n\\t\"\n-            \"sxth  $dst, $dst\\t# mul reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ ins(as_FloatRegister($vtmp1$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp1$$reg), __ T4H,\n-            as_FloatRegister($vtmp1$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($vtmp2$$reg), __ S,\n-           as_FloatRegister($vtmp1$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp2$$reg), __ T4H,\n-            as_FloatRegister($vtmp2$$reg), as_FloatRegister($vtmp1$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 0);\n-    __ mulw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp2$$reg), __ H, 1);\n-    __ mulw($dst$$Register, $itmp$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mul2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  match(Set dst (MulReductionVL isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"mul   $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"mul   $dst, $dst, $tmp\\t# mul reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ mul($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ mul($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-define(`REDUCE_MAX_MIN_INT', `\n-instruct reduce_$1$2$3`'(iRegINoSp dst, iRegIorL2I isrc, vec$4 vsrc, vec$4 tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n-  match(Set dst ($5ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1v $tmp, T$2`'iTYPE2SIMD($3), $vsrc\\n\\t\"\n-            \"$6mov  $dst, $tmp, iTYPE2SIMD($3), 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $7\\t# $1 reduction$2$3\"\n-  %}\n-  ins_encode %{\n-    __ s$1v(as_FloatRegister($tmp$$reg), __ T$2`'iTYPE2SIMD($3), as_FloatRegister($vsrc$$reg));\n-    __ $6mov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ iTYPE2SIMD($3), 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$7);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6 $7\n-REDUCE_MAX_MIN_INT(max, 8,  B, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 16, B, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  S, D, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 8,  S, X, Max, s, GT)\n-REDUCE_MAX_MIN_INT(max, 4,  I, X, Max, u, GT)\n-REDUCE_MAX_MIN_INT(min, 8,  B, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 16, B, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  S, D, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 8,  S, X, Min, s, LT)\n-REDUCE_MAX_MIN_INT(min, 4,  I, X, Min, u, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, vecD tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"s$1p $tmp, T2S, $vsrc, $vsrc\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $isrc\\n\\t\"\n-            \"cselw $dst, $dst, $isrc $3\\t# $1 reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ s$1p(as_FloatRegister($tmp$$reg), __ T2S, as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ cmpw(as_Register($dst$$reg), as_Register($isrc$$reg));\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($isrc$$reg), Assembler::$3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2I(max, Max, GT)\n-REDUCE_MAX_MIN_2I(min, Min, LT)\n-dnl\n-define(`REDUCE_MAX_MIN_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp, rFlagsReg cr)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"cmp   $isrc,$tmp\\n\\t\"\n-            \"csel  $dst, $isrc, $tmp $3\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"cmp   $dst, $tmp\\n\\t\"\n-            \"csel  $dst, $dst, $tmp $3\\t# $1 reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ cmp(as_Register($isrc$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($isrc$$reg), as_Register($tmp$$reg), Assembler::$3);\n-    __ umov(as_Register($tmp$$reg), as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ cmp(as_Register($dst$$reg), as_Register($tmp$$reg));\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($tmp$$reg), Assembler::$3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl               $1   $2   $3\n-REDUCE_MAX_MIN_2L(max, Max, GT)\n-REDUCE_MAX_MIN_2L(min, Min, LT)\n-dnl\n-define(`REDUCE_MINMAX_FORD', `\n-instruct reduce_$1$4$5(vReg$5 dst, vReg$5 $6src, vec$7 vsrc) %{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_`'ifelse($5, F, FLOAT, DOUBLE));\n-  match(Set dst (ifelse($1, max, Max, Min)ReductionV $6src vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"$2 $dst, ifelse($4, 2, $vsrc`, 'ifelse($5, F, S, D), ` T4S, $vsrc')\\n\\t\"\n-            \"$3 $dst, $dst, $$6src\\t# $1 reduction$4$5\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), ifelse($4, 4, `__ T4S, as_FloatRegister($vsrc$$reg))',\n-                                              $4$5, 2F, `as_FloatRegister($vsrc$$reg), __ S)',\n-                                              $4$5, 2D, `as_FloatRegister($vsrc$$reg), __ D)');\n-    __ $3(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($$6src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                $1   $2     $3     $4 $5 $6 $7\n-REDUCE_MINMAX_FORD(max, fmaxp, fmaxs, 2, F, f, D)\n-REDUCE_MINMAX_FORD(max, fmaxv, fmaxs, 4, F, f, X)\n-REDUCE_MINMAX_FORD(max, fmaxp, fmaxd, 2, D, d, X)\n-REDUCE_MINMAX_FORD(min, fminp, fmins, 2, F, f, D)\n-REDUCE_MINMAX_FORD(min, fminv, fmins, 4, F, f, X)\n-REDUCE_MINMAX_FORD(min, fminp, fmind, 2, D, d, X)\n-dnl\n-define(`REDUCE_LOGIC_OP_8B', `\n-instruct reduce_$1`'8B(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"$1w   $dst, $dst, $tmp\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# $1 reduction8B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_8B(and, And)\n-REDUCE_LOGIC_OP_8B(orr, Or)\n-REDUCE_LOGIC_OP_8B(eor, Xor)\n-define(`REDUCE_LOGIC_OP_16B', `\n-instruct reduce_$1`'16B(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #8\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxtb   $dst, $dst\\t# $1 reduction16B\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 8);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                 $1   $2   $3\n-REDUCE_LOGIC_OP_16B(and, And, andr)\n-REDUCE_LOGIC_OP_16B(orr, Or,  orr )\n-REDUCE_LOGIC_OP_16B(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_4S', `\n-instruct reduce_$1`'4S(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, S, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, S, 1\\n\\t\"\n-            \"$1w   $dst, $dst, $tmp\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# $1 reduction4S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_4S(and, And)\n-REDUCE_LOGIC_OP_4S(orr, Or)\n-REDUCE_LOGIC_OP_4S(eor, Xor)\n-dnl\n-define(`REDUCE_LOGIC_OP_8S', `\n-instruct reduce_$1`'8S(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $dst, $dst, LSR #16\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\n\\t\"\n-            \"sxth   $dst, $dst\\t# $1 reduction8S\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 16);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_8S(and, And, andr)\n-REDUCE_LOGIC_OP_8S(orr, Or,  orr )\n-REDUCE_LOGIC_OP_8S(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_2I', `\n-instruct reduce_$1`'2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"$1w  $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"$1w  $dst, $tmp, $dst\\t# $1 reduction2I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ $1w($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ $1w($dst$$Register, $tmp$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2\n-REDUCE_LOGIC_OP_2I(and, And)\n-REDUCE_LOGIC_OP_2I(orr, Or)\n-REDUCE_LOGIC_OP_2I(eor, Xor)\n-dnl\n-define(`REDUCE_LOGIC_OP_4I', `\n-instruct reduce_$1`'4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, iRegINoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov   $tmp, $vsrc, D, 0\\n\\t\"\n-            \"umov   $dst, $vsrc, D, 1\\n\\t\"\n-            \"$3   $dst, $dst, $tmp\\n\\t\"\n-            \"$3   $dst, $dst, $dst, LSR #32\\n\\t\"\n-            \"$1w   $dst, $isrc, $dst\\t# $1 reduction4I\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ umov($dst$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-    __ $3($dst$$Register, $dst$$Register, $dst$$Register, Assembler::LSR, 32);\n-    __ $1w($dst$$Register, $isrc$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_4I(and, And, andr)\n-REDUCE_LOGIC_OP_4I(orr, Or,  orr )\n-REDUCE_LOGIC_OP_4I(eor, Xor, eor )\n-dnl\n-define(`REDUCE_LOGIC_OP_2L', `\n-instruct reduce_$1`'2L(iRegLNoSp dst, iRegL isrc, vecX vsrc, iRegLNoSp tmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2ReductionV isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"umov  $tmp, $vsrc, D, 0\\n\\t\"\n-            \"$3  $dst, $isrc, $tmp\\n\\t\"\n-            \"umov  $tmp, $vsrc, D, 1\\n\\t\"\n-            \"$3  $dst, $dst, $tmp\\t# $1 reduction2L\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 0);\n-    __ $3($dst$$Register, $isrc$$Register, $tmp$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ D, 1);\n-    __ $3($dst$$Register, $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1   $2   $3\n-REDUCE_LOGIC_OP_2L(and, And, andr)\n-REDUCE_LOGIC_OP_2L(orr, Or,  orr )\n-REDUCE_LOGIC_OP_2L(eor, Xor, eor )\n-dnl\n-\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-dnl VECTOR_INSERT_I($1,        $2,                     $3,          $4,   $5)\n-dnl VECTOR_INSERT_I(rule_name, vector_length_in_bytes, reg_variant, vreg, ireg)\n-define(`VECTOR_INSERT_I', `\n-instruct $1($4 dst, $4 src, $5 val, immI idx)\n-%{\n-  predicate(ifelse($3, D, n->bottom_type()->is_vect()->element_basic_type() == T_LONG,\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT)));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T$2B, $src, $src\\n\\t\"\n-            \"mov    $dst, $3, $idx, $val\\t`#' insert into vector ($3)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T$2B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ ifelse($3, D, D, elemType_to_regVariant(Matcher::vector_element_basic_type(this))),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1        $2  $3     $4    $5\n-VECTOR_INSERT_I(insertID, 8,  B\/H\/S, vecD, iRegIorL2I)\n-VECTOR_INSERT_I(insertIX, 16, B\/H\/S, vecX, iRegIorL2I)\n-VECTOR_INSERT_I(insert2L, 16, D,     vecX, iRegL)\n-dnl\n-define(`VECTOR_INSERT_F', `\n-instruct insert$3`'(vec$2 dst, vec$2 src, vReg$1 val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, ifelse($2, D, T8B, T16B), $src, $src\\n\\t\"\n-            \"ins    $dst, ifelse($1, F, S, D), $val, $idx, 0\\t# insert into vector($3)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ ifelse($2, D, T8B, T16B),\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ ifelse($1, F, S, D),\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1 $2 $3\n-VECTOR_INSERT_F(F, D, 2F)\n-VECTOR_INSERT_F(F, X, 4F)\n-VECTOR_INSERT_F(D, X, 2D)\n-dnl\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-define(`VECTOR_EXTRACT_I', `\n-instruct extract$1$2`'(iReg$3NoSp dst, vec$4 src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == $1);\n-  match(Set dst (Extract$2 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"$5mov    $dst, $src, $6, $idx\\t# extract from vector($1$2)\" %}\n-  ins_encode %{\n-    __ $5mov($dst$$Register, as_FloatRegister($src$$reg), __ $6, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1   $2 $3 $4 $5 $6\n-VECTOR_EXTRACT_I(8,  B, I, D, s, B)\n-VECTOR_EXTRACT_I(16, B, I, X, s, B)\n-VECTOR_EXTRACT_I(4,  S, I, D, s, H)\n-VECTOR_EXTRACT_I(8,  S, I, X, s, H)\n-VECTOR_EXTRACT_I(2,  I, I, D, u, S)\n-VECTOR_EXTRACT_I(4,  I, I, X, u, S)\n-VECTOR_EXTRACT_I(2,  L, L, X, u, D)\n-dnl\n-define(`VECTOR_EXTRACT_F', `\n-instruct extract$1$2`'(vReg$2 dst, vec$3 src, immI idx)\n-%{\n-  predicate(n->in(1)->bottom_type()->is_vect()->length() == $1);\n-  match(Set dst (Extract$2 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ins   $dst, $4, $src, 0, $idx\\t# extract from vector($1$2)\" %}\n-  ins_encode %{\n-    if ((0 == $idx$$constant) &&\n-        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ ifelse($2, F, fmovs, fmovd)(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else {\n-      __ ins(as_FloatRegister($dst$$reg), __ $4,\n-             as_FloatRegister($src$$reg), 0, $idx$$constant);\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl             $1  $2 $3 $4\n-VECTOR_EXTRACT_F(2, F, D, S)\n-VECTOR_EXTRACT_F(4, F, X, S)\n-VECTOR_EXTRACT_F(2, D, X, D)\n-dnl\n-\n-\/\/ ------------------------------ Vector comparison ---------------------------------\n-\n-instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(type2aelembytes(bt) != 8, \"not supported\");\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n-                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-\/\/ ------------------------------ Vector mul -----------------------------------\n-\n-instruct vmul2L(vecX dst, vecX src1, vecX src2, iRegLNoSp tmp1, iRegLNoSp tmp2)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (MulVL src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"umov   $tmp1, $src1, D, 0\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 0\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   0, $tmp2\\t# insert into vector(2L)\\n\\t\"\n-            \"umov   $tmp1, $src1, D, 1\\n\\t\"\n-            \"umov   $tmp2, $src2, D, 1\\n\\t\"\n-            \"mul    $tmp2, $tmp2, $tmp1\\n\\t\"\n-            \"mov    $dst,  T2D,   1, $tmp2\\t# insert into vector(2L)\"\n-  %}\n-  ins_encode %{\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 0);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 0);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n-    __ umov($tmp1$$Register, as_FloatRegister($src1$$reg), __ D, 1);\n-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ D, 1);\n-    __ mul(as_Register($tmp2$$reg), as_Register($tmp2$$reg), as_Register($tmp1$$reg));\n-    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ --------------------------------- Vector not --------------------------------\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));',\n-`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n-dnl\n-define(`VECTOR_NOT', `\n-instruct vnot$1$2`'(vec$3 dst, vec$3 src, imm$2_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $4);\n-  MATCH_RULE($2)\n-  ins_cost(INSN_COST);\n-  format %{ \"not  $dst, T$5, $src\\t# vector ($5)\" %}\n-  ins_encode %{\n-    __ notr(as_FloatRegister($dst$$reg), __ T$5,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl        $1 $2 $3 $4  $5\n-VECTOR_NOT(2, I, D, 8,  8B)\n-VECTOR_NOT(4, I, X, 16, 16B)\n-VECTOR_NOT(2, L, X, 16, 16B)\n-undefine(MATCH_RULE)\n-\/\/ ------------------------------ Vector and_not -------------------------------\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT', `\n-instruct vand_not$1$2`'(vec$3 dst, vec$3 src1, vec$3 src2, imm$2_M1 m1)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $4);\n-  MATCH_RULE($2)\n-  ins_cost(INSN_COST);\n-  format %{ \"bic  $dst, T$5, $src1, $src2\\t# vector ($5)\" %}\n-  ins_encode %{\n-    __ bic(as_FloatRegister($dst$$reg), __ T$5,\n-           as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3 $4  $5\n-VECTOR_AND_NOT(2, I, D, 8,  8B)\n-VECTOR_AND_NOT(4, I, X, 16, 16B)\n-VECTOR_AND_NOT(2, L, X, 16, 16B)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ ------------------------------ Vector max\/min -------------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, 8B,\n-`predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n-             n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_$3);')')dnl\n-dnl\n-define(`VECTOR_MAX_MIN_INT', `\n-instruct v$1$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{\n-  PREDICATE(`$2$3', $2, TYPE2DATATYPE($3))\n-  match(Set dst ($5V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1v  $dst, T$2`'iTYPE2SIMD($3), $src1, $src2\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ $1v(as_FloatRegister($dst$$reg), __ T$2`'iTYPE2SIMD($3),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop$6);\n-%}')dnl\n-dnl                $1   $2  $3 $4 $5   $6\n-VECTOR_MAX_MIN_INT(max, 8,  B, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 16, B, X, Max, 128)\n-VECTOR_MAX_MIN_INT(max, 4,  S, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 8,  S, X, Max, 128)\n-VECTOR_MAX_MIN_INT(max, 2,  I, D, Max, 64)\n-VECTOR_MAX_MIN_INT(max, 4,  I, X, Max, 128)\n-VECTOR_MAX_MIN_INT(min, 8,  B, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 16, B, X, Min, 128)\n-VECTOR_MAX_MIN_INT(min, 4,  S, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 8,  S, X, Min, 128)\n-VECTOR_MAX_MIN_INT(min, 2,  I, D, Min, 64)\n-VECTOR_MAX_MIN_INT(min, 4,  I, X, Min, 128)\n-undefine(PREDICATE)\n-dnl\n-define(`VECTOR_MAX_MIN_LONG', `\n-instruct v$1`'2L`'(vecX dst, vecX src1, vecX src2)\n-%{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2V src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP dst);\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector (2L)\\n\\t\"\n-            \"bsl   $dst, T16B, $$3, $$4\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ bsl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($$3$$reg), as_FloatRegister($$4$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}')dnl\n-dnl                 $1   $2   $3    $4\n-VECTOR_MAX_MIN_LONG(max, Max, src1, src2)\n-VECTOR_MAX_MIN_LONG(min, Min, src2, src1)\n-dnl\n-\n-\/\/ --------------------------------- blend (bsl) ----------------------------\n-dnl\n-define(`VECTOR_BSL', `\n-instruct vbsl$1B`'(vec$2 dst, vec$2 src1, vec$2 src2)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() == $1);\n-  match(Set dst (VectorBlend (Binary src1 src2) dst));\n-  ins_cost(INSN_COST);\n-  format %{ \"bsl  $dst, T$1B, $src2, $src1\\t# vector ($1B)\" %}\n-  ins_encode %{\n-    __ bsl(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vlogical$3);\n-%}')dnl\n-dnl        $1  $2 $3\n-VECTOR_BSL(8,  D, 64)\n-VECTOR_BSL(16, X, 128)\n-dnl\n-\n-\/\/ --------------------------------- Load\/store Mask ----------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_B', `\n-instruct $1mask$2B`'(vec$3 dst, vec$3 src $5 $6)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$4Mask src $6));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, T$2B, $src\\t# $1 mask ($2B to $2B)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T$2B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                      $1     $2  $3 $4     $5      $6\n-VECTOR_LOAD_STORE_MASK_B(load,  8,  D, Load)\n-VECTOR_LOAD_STORE_MASK_B(load,  16, X, Load)\n-VECTOR_LOAD_STORE_MASK_B(store, 8,  D, Store, `, immI_1', size)\n-VECTOR_LOAD_STORE_MASK_B(store, 16, X, Store, `, immI_1', size)\n-undefine(PREDICATE)dnl\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_S', `\n-instruct $1mask$2S`'(vec$3 dst, vec$4 src $9 $10)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$5Mask src $10));\n-  ins_cost(INSN_COST);\n-  format %{ \"$6  $dst, T8$8, $src, T8$7\\n\\t\"\n-            \"negr  $dst, T8$8, $dst\\t# $1 mask ($2$7 to $2$8)\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T8$8, as_FloatRegister($src$$reg), __ T8$7);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8$8, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                      $1     $2 $3 $4 $5     $6    $7 $8    $9       $10\n-VECTOR_LOAD_STORE_MASK_S(load,  4, D, D, Load,  uxtl, B, H)\n-VECTOR_LOAD_STORE_MASK_S(load,  8, X, D, Load,  uxtl, B, H)\n-VECTOR_LOAD_STORE_MASK_S(store, 4, D, D, Store, xtn,  H, B, `, immI_2', size)\n-VECTOR_LOAD_STORE_MASK_S(store, 8, D, X, Store, xtn,  H, B, `, immI_2', size)\n-undefine(PREDICATE)dnl\n-dnl\n-define(`PREDICATE', `ifelse($1, load,\n-`predicate(n->as_Vector()->length() == $2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));',\n-`predicate(n->as_Vector()->length() == $2);')')dnl\n-dnl\n-define(`VECTOR_LOAD_STORE_MASK_I', `\n-instruct $1mask$2I`'(vec$3 dst, vec$4 src $12 $13)\n-%{\n-  PREDICATE($1, $2)\n-  match(Set dst (Vector$5Mask src $13));\n-  ins_cost(INSN_COST);\n-  format %{ \"$6  $dst, T$10$8, $src, T$10$7\\t# $2$7 to $2$8\\n\\t\"\n-            \"$6  $dst, T$11$9, $dst, T$11$8\\t# $2$8 to $2$9\\n\\t\"\n-            \"negr   $dst, T$11$9, $dst\\t# $1 mask ($2$7 to $2$9)\" %}\n-  ins_encode %{\n-    __ $6(as_FloatRegister($dst$$reg), __ T$10$8, as_FloatRegister($src$$reg), __ T$10$7);\n-    __ $6(as_FloatRegister($dst$$reg), __ T$11$9, as_FloatRegister($dst$$reg), __ T$11$8);\n-    __ negr(as_FloatRegister($dst$$reg), __ T$11$9, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                      $1     $2 $3 $4 $5     $6    $7 $8 $9 $10$11   $12      $13\n-VECTOR_LOAD_STORE_MASK_I(load,  2, D, D, Load,  uxtl, B, H, S, 8, 4)\n-VECTOR_LOAD_STORE_MASK_I(load,  4, X, D, Load,  uxtl, B, H, S, 8, 4)\n-VECTOR_LOAD_STORE_MASK_I(store, 2, D, D, Store, xtn,  S, H, B, 4, 8, `, immI_4', size)\n-VECTOR_LOAD_STORE_MASK_I(store, 4, D, X, Store, xtn,  S, H, B, 4, 8, `, immI_4', size)\n-undefine(PREDICATE)\n-dnl\n-instruct loadmask2L(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 2B to 2S\\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 2S to 2I\\n\\t\"\n-            \"uxtl  $dst, T2D, $dst, T2S\\t# 2I to 2L\\n\\t\"\n-            \"neg   $dst, T2D, $dst\\t# load mask (2B to 2L)\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg), __ T2S);\n-    __ negr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storemask2L(vecD dst, vecX src, immI_8 size)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(INSN_COST);\n-  format %{ \"xtn  $dst, T2S, $src, T2D\\t# 2L to 2I\\n\\t\"\n-            \"xtn  $dst, T4H, $dst, T4S\\t# 2I to 2S\\n\\t\"\n-            \"xtn  $dst, T8B, $dst, T8H\\t# 2S to 2B\\n\\t\"\n-            \"neg  $dst, T8B, $dst\\t# store mask (2L to 2B)\" %}\n-  ins_encode %{\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg), __ T2D);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($dst$$reg), __ T4S);\n-    __ xtn(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg), __ T8H);\n-    __ negr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask cast\n-dnl\n-define(`VECTOR_MASK_CAST', `\n-instruct vmaskcast$1`'(vec$1 dst)\n-%{\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n-  match(Set dst (VectorMaskCast dst));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst\\t# empty\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}')dnl\n-dnl              $1 $2\n-VECTOR_MASK_CAST(D, 8)\n-VECTOR_MASK_CAST(X, 16)\n-dnl\n-\n-\/\/-------------------------------- LOAD_IOTA_INDICES----------------------------------\n-dnl\n-define(`PREDICATE', `ifelse($1, 8,\n-`predicate(UseSVE == 0 &&\n-           (n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8) &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);',\n-`predicate(UseSVE == 0 && n->as_Vector()->length() == 16 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);')')dnl\n-dnl\n-define(`VECTOR_LOAD_CON', `\n-instruct loadcon$1B`'(vec$2 dst, immI0 src)\n-%{\n-  PREDICATE($1)\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(INSN_COST);\n-  format %{ \"ldr $dst, CONSTANT_MEMORY\\t# load iota indices\" %}\n-  ins_encode %{\n-    __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n-    __ ldr$3(as_FloatRegister($dst$$reg), rscratch1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl             $1  $2 $3\n-VECTOR_LOAD_CON(8,  D, d)\n-VECTOR_LOAD_CON(16, X, q)\n-undefine(PREDICATE)\n-dnl\n-\/\/-------------------------------- LOAD_SHUFFLE ----------------------------------\n-dnl\n-define(`VECTOR_LOAD_SHUFFLE_B', `\n-instruct loadshuffle$1B`'(vec$2 dst, vec$2 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"mov  $dst, T$1B, $src\\t# get $1B shuffle\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                   $1  $2\n-VECTOR_LOAD_SHUFFLE_B(8,  D)\n-VECTOR_LOAD_SHUFFLE_B(16, X)\n-dnl\n-define(`VECTOR_LOAD_SHUFFLE_S', `\n-instruct loadshuffle$1S`'(vec$2 dst, vec$3 src)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# $1B to $1H\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                   $1 $2 $3\n-VECTOR_LOAD_SHUFFLE_S(4, D, D)\n-VECTOR_LOAD_SHUFFLE_S(8, X, D)\n-dnl\n-\n-instruct loadshuffle4I(vecX dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(INSN_COST);\n-  format %{ \"uxtl  $dst, T8H, $src, T8B\\t# 4B to 4H \\n\\t\"\n-            \"uxtl  $dst, T4S, $dst, T4H\\t# 4H to 4S\" %}\n-  ins_encode %{\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg), __ T8B);\n-    __ uxtl(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($dst$$reg), __ T4H);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Rearrange -------------------------------------\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-define(`VECTOR_REARRANGE_B', `\n-instruct rearrange$1B`'(vec$2 dst, vec$2 src, vec$2 shuffle)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"tbl $dst, T$1B, {$dst}, $shuffle\\t# rearrange $1B\" %}\n-  ins_encode %{\n-    __ tbl(as_FloatRegister($dst$$reg), __ T$1B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1  $2\n-VECTOR_REARRANGE_B(8,  D)\n-VECTOR_REARRANGE_B(16, X)\n-dnl\n-define(`VECTOR_REARRANGE_S', `\n-instruct rearrange$1S`'(vec$2 dst, vec$2 src, vec$2 shuffle, vec$2 tmp0, vec$2 tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T$3B, CONSTANT\\t# constant 0x0202020202020202\\n\\t\"\n-            \"mov   $tmp1, T$1H, CONSTANT\\t# constant 0x0100010001000100\\n\\t\"\n-            \"mulv  $dst, T$1H, T$1H, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T$3B, T$3B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T$3B, {$src}, 1, $dst\\t# rearrange $1S\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T$3B, 0x02);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T$1H, 0x0100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T$1H,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T$3B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T$3B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                $1 $2 $3\n-VECTOR_REARRANGE_S(4, D, 8)\n-VECTOR_REARRANGE_S(8, X, 16)\n-\n-instruct rearrange4I(vecX dst, vecX src, vecX shuffle, vecX tmp0, vecX tmp1)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp0, TEMP tmp1);\n-  format %{ \"mov   $tmp0, T16B, CONSTANT\\t# constant 0x0404040404040404\\n\\t\"\n-            \"mov   $tmp1, T4S, CONSTANT\\t# constant 0x0302010003020100\\n\\t\"\n-            \"mulv  $dst, T4S, $shuffle, $tmp0\\n\\t\"\n-            \"addv  $dst, T16B, $dst, $tmp1\\n\\t\"\n-            \"tbl   $dst, T16B, {$src}, 1, $dst\\t# rearrange 4I\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($tmp0$$reg), __ T16B, 0x04);\n-    __ mov(as_FloatRegister($tmp1$$reg), __ T4S, 0x03020100);\n-    __ mulv(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($shuffle$$reg), as_FloatRegister($tmp0$$reg));\n-    __ addv(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($dst$$reg), as_FloatRegister($tmp1$$reg));\n-    __ tbl(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), 1, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/-------------------------------- Anytrue\/alltrue -----------------------------\n-dnl\n-define(`ANYTRUE_IN_MASK', `\n-instruct anytrue_in_mask$1B`'(iRegINoSp dst, vec$2 src1, vec$2 src2, vec$2 tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"addv  $tmp, T$1B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\\t# anytrue $1B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, zr);\n-    __ csetw($dst$$Register, Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2\n-ANYTRUE_IN_MASK(8,  D)\n-ANYTRUE_IN_MASK(16, X)\n-dnl\n-define(`ALLTRUE_IN_MASK', `\n-instruct alltrue_in_mask$1B`'(iRegINoSp dst, vec$2 src1, vec$2 src2, vec$2 tmp, rFlagsReg cr)\n-%{\n-  predicate(static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, KILL cr);\n-  format %{ \"uminv $tmp, T$1B, $src1\\n\\t\"\n-            \"umov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmp   $dst, 0xff\\n\\t\"\n-            \"cset  $dst\\t# alltrue $1B\" %}\n-  ins_encode %{\n-    \/\/ No need to use src2.\n-    __ uminv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($src1$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, 0xff);\n-    __ csetw($dst$$Register, Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl             $1  $2\n-ALLTRUE_IN_MASK(8,  D)\n-ALLTRUE_IN_MASK(16, X)\n-\n-\/\/ --------------------------------- ABS --------------------------------------\n-dnl\n-define(`VABS', `\n-instruct vabs$3$4`'(vec$5 dst, vec$5 src)\n-%{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 || )n->as_Vector()->length() == $3);\n-  match(Set dst (AbsV$4 src));\n-  ins_cost(ifelse($4, F, INSN_COST * 3, $4, D, INSN_COST * 3, INSN_COST));\n-  format %{ \"$1  $dst, T$3$6, $src\\t# vector ($3$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$6, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(ifelse($4, F, vunop_fp$7, $4, D, vunop_fp$7, vlogical$7));\n-%}')dnl\n-dnl  $1    $2    $3  $4 $5 $6 $7\n-VABS(abs,  absr, 8,  B, D, B, 64)\n-VABS(abs,  absr, 16, B, X, B, 128)\n-VABS(abs,  absr, 4,  S, D, H, 64)\n-VABS(abs,  absr, 8,  S, X, H, 128)\n-VABS(abs,  absr, 2,  I, D, S, 64)\n-VABS(abs,  absr, 4,  I, X, S, 128)\n-VABS(abs,  absr, 2,  L, X, D, 128)\n-VABS(fabs, fabs, 2,  F, D, S, 64)\n-VABS(fabs, fabs, 4,  F, X, S, 128)\n-VABS(fabs, fabs, 2,  D, X, D, 128)\n-\n-\/\/ --------------------------------- FABS DIFF --------------------------------\n-dnl\n-define(`VFABD', `\n-instruct vabd$3$4`'(vec$5 dst, vec$5 src1, vec$5 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $3);\n-  match(Set dst (AbsV$4 (SubV$4 src1 src2)));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"$1  $dst, T$3$6, $src1, $src2\\t# vector ($3$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$6,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vunop_fp$7);\n-%}')dnl\n-dnl   $1    $2    $3 $4 $5 $6 $7\n-VFABD(fabd, fabd, 2, F, D, S, 64)\n-VFABD(fabd, fabd, 4, F, X, S, 128)\n-VFABD(fabd, fabd, 2, D, X, D, 128)\n-dnl\n-define(`VREPLICATE_REG', `\n-instruct replicate$2$3`'(vec$4 dst, $5 src)\n-%{\n-  predicate(UseSVE == 0 && ifelse($2$3, 8B,\n-                                  `(n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4)',\n-                                  $2$3, 4S,\n-                                  `(n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2)',\n-                            n->as_Vector()->length() == $2));\n-  match(Set dst (Replicate$3 src));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $src\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T$2$1, $6($src$$reg));\n-  %}\n-  ins_pipe(ifelse($5, iRegIorL2I, vdup_reg_reg,\n-                  $5, iRegL, vdup_reg_reg,\n-                  $3, F, vdup_reg_freg, vdup_reg_dreg)`'ifelse($4, X, 128, 64));\n-%}')dnl\n-define(`VREPLICATE_IMM', `\n-instruct replicate$2$3_imm`'(vec$4 dst, $5 con)\n-%{\n-  predicate(UseSVE == 0 && ifelse($2$3, 8B,\n-                                  `(n->as_Vector()->length() == 8 ||\n-                            n->as_Vector()->length() == 4)',\n-                                  $2$3, 4S,\n-                                  `(n->as_Vector()->length() == 4 ||\n-                            n->as_Vector()->length() == 2)',\n-                            n->as_Vector()->length() == $2));\n-  match(Set dst (Replicate$3 con));\n-  ins_cost(INSN_COST);\n-  format %{ \"movi  $dst, $con\\t`#' vector ($2`'ifelse($3, S, H, $3))\" %}\n-  ins_encode %{\n-    __ mov(as_FloatRegister($dst$$reg), __ T$2`'iTYPE2SIMD($3), $con$$constant`'$6);\n-  %}\n-  ins_pipe(vmovi_reg_imm`'ifelse($4, X, 128, 64));\n-%}')dnl\n-dnl            $1 $2  $3 $4 $5          $6\n-VREPLICATE_REG(B, 8,  B, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(B, 16, B, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(B, 8,  B, D, immI, ` & 0xff')\n-VREPLICATE_IMM(B, 16, B, X, immI, ` & 0xff')\n-VREPLICATE_REG(H, 4,  S, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(H, 8,  S, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(H, 4,  S, D, immI, ` & 0xffff')\n-VREPLICATE_IMM(H, 8,  S, X, immI, ` & 0xffff')\n-VREPLICATE_REG(S, 2,  I, D, iRegIorL2I, as_Register)\n-VREPLICATE_REG(S, 4,  I, X, iRegIorL2I, as_Register)\n-VREPLICATE_IMM(S, 2,  I, D, immI)\n-VREPLICATE_IMM(S, 4,  I, X, immI)\n-VREPLICATE_REG(D, 2,  L, X, iRegL,      as_Register)\n-VREPLICATE_IMM(D, 2,  L, X, immL)\n-VREPLICATE_REG(S, 2,  F, D, vRegF,      as_FloatRegister)\n-VREPLICATE_REG(S, 4,  F, X, vRegF,      as_FloatRegister)\n-VREPLICATE_REG(D, 2,  D, X, vRegD,      as_FloatRegister)\n-dnl\n-\n-\/\/ ====================REDUCTION ARITHMETIC====================================\n-dnl\n-define(`REDUCE_ADD_INT', `\n-instruct reduce_add$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, vec$3 vtmp, iRegINoSp itmp)\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (AddReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP vtmp, TEMP itmp);\n-  format %{ ifelse($1, 2, `\"addpv  $vtmp, T2S, $vsrc, $vsrc\\n\\t\"',`\"addv  $vtmp, T4S, $vsrc\\n\\t\"')\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"addw  $dst, $itmp, $isrc\\t# add reduction$1I\"\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ addpv(as_FloatRegister($vtmp$$reg), __ T2S,\n-             as_FloatRegister($vsrc$$reg), as_FloatRegister($vsrc$$reg));', `__ addv(as_FloatRegister($vtmp$$reg), __ T4S,\n-            as_FloatRegister($vsrc$$reg));')\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_ADD_INT(2, I, D)\n-REDUCE_ADD_INT(4, I, X)\n-dnl\n-define(`REDUCE_MUL_INT', `\n-instruct reduce_mul$1$2`'(iRegINoSp dst, iRegIorL2I isrc, vec$3 vsrc, ifelse($1, 2, iRegINoSp tmp`)', vecX vtmp`,' iRegINoSp itmp`)')\n-%{\n-  predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (MulReductionVI isrc vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP ifelse($1, 2, tmp, vtmp), TEMP ifelse($1, 2, dst, itmp`,' TEMP dst));\n-  format %{ ifelse($1, 2, `\"umov  $tmp, $vsrc, S, 0\\n\\t\"\n-            \"mul   $dst, $tmp, $isrc\\n\\t\"\n-            \"umov  $tmp, $vsrc, S, 1\\n\\t\"\n-            \"mul   $dst, $tmp, $dst\\t# mul reduction2I\"',`\"ins   $vtmp, D, $vsrc, 0, 1\\n\\t\"\n-            \"mulv  $vtmp, T2S, $vtmp, $vsrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 0\\n\\t\"\n-            \"mul   $dst, $itmp, $isrc\\n\\t\"\n-            \"umov  $itmp, $vtmp, S, 1\\n\\t\"\n-            \"mul   $dst, $itmp, $dst\\t# mul reduction4I\"')\n-  %}\n-  ins_encode %{\n-    ifelse($1, 2, `__ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);\n-    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);\n-    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);\n-    __ mul($dst$$Register, $tmp$$Register, $dst$$Register);', `__ ins(as_FloatRegister($vtmp$$reg), __ D,\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,\n-            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);\n-    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);\n-    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);\n-    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl            $1 $2 $3\n-REDUCE_MUL_INT(2, I, D)\n-REDUCE_MUL_INT(4, I, X)\n-dnl\n-define(`REDUCE_MULORADD_FORD', `\n-instruct reduce_$6$2$3`'(vReg$3 dst, vReg$3 $4src, vec$5 vsrc, vec$5 tmp)\n-%{\n-  match(Set dst (ifelse($6, add, Add, Mul)ReductionV$3 $4src vsrc));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp, TEMP dst);\n-  format %{ \"$1 $dst, $$4src, $vsrc\\n\\t\"\n-            \"ins   $tmp, ifelse($3, F, S, D), $vsrc, 0, 1\\n\\t\"\n-            ifelse($2, 2, `\"$1 $dst, $dst, $tmp\\t# $6 reduction$2$3\"',\n-            `\"$1 $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 2\\n\\t\"\n-            \"$1 $dst, $dst, $tmp\\n\\t\"\n-            \"ins   $tmp, S, $vsrc, 0, 3\\n\\t\"\n-            \"$1 $dst, $dst, $tmp\\t# $6 reduction4F\"')\n-  %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($$4src$$reg), as_FloatRegister($vsrc$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ ifelse($3, F, S, D),\n-           as_FloatRegister($vsrc$$reg), 0, 1);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));ifelse($2, 4, `\n-    __ ins(as_FloatRegister($tmp$$reg), __ ifelse($3, F, S, D),\n-           as_FloatRegister($vsrc$$reg), 0, 2);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ ins(as_FloatRegister($tmp$$reg), __ S,\n-           as_FloatRegister($vsrc$$reg), 0, 3);\n-    __ $1(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                  $1     $2 $3 $4 $5 $6\n-REDUCE_MULORADD_FORD(fadds, 2, F, f, D, add)\n-REDUCE_MULORADD_FORD(fadds, 4, F, f, X, add)\n-REDUCE_MULORADD_FORD(fmuls, 2, F, f, D, mul)\n-REDUCE_MULORADD_FORD(fmuls, 4, F, f, X, mul)\n-REDUCE_MULORADD_FORD(faddd, 2, D, d, X, add)\n-REDUCE_MULORADD_FORD(fmuld, 2, D, d, X, mul)\n-\n-\/\/ ====================VECTOR ARITHMETIC=======================================\n-\n-\/\/ --------------------------------- ADD --------------------------------------\n-define(`VADD', `\n-instruct vadd$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',\n-         $2$5, 2D, , `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (AddV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop`'ifelse($3, F, _fp, $3, D, _fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VADD(addv, 8,  B, D, B)\n-VADD(addv, 16, B, X, B)\n-VADD(addv, 4,  S, D, H)\n-VADD(addv, 8,  S, X, H)\n-VADD(addv, 2,  I, D, S)\n-VADD(addv, 4,  I, X, S)\n-VADD(addv, 2,  L, X, L)\n-VADD(fadd, 2,  F, D, S)\n-VADD(fadd, 4,  F, X, S)\n-VADD(fadd, 2,  D, X, D)\n-\n-\/\/ --------------------------------- SUB --------------------------------------\n-define(`VSUB', `\n-instruct vsub$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',`\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (SubV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop`'ifelse($3, F, _fp, $3, D, _fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VSUB(subv, 8,  B, D, B)\n-VSUB(subv, 16, B, X, B)\n-VSUB(subv, 4,  S, D, H)\n-VSUB(subv, 8,  S, X, H)\n-VSUB(subv, 2,  I, D, S)\n-VSUB(subv, 4,  I, X, S)\n-VSUB(subv, 2,  L, X, L)\n-VSUB(fsub, 2,  F, D, S)\n-VSUB(fsub, 4,  F, X, S)\n-VSUB(fsub, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MUL --------------------------------------\n-define(`VMUL', `\n-instruct vmul$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 8B, `\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);',\n-         $2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);',`\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (MulV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmul`'ifelse($3, F, div_fp, $3, D, div_fp)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VMUL(mulv, 8,  B, D, B)\n-VMUL(mulv, 16, B, X, B)\n-VMUL(mulv, 4,  S, D, H)\n-VMUL(mulv, 8,  S, X, H)\n-VMUL(mulv, 2,  I, D, S)\n-VMUL(mulv, 4,  I, X, S)\n-VMUL(fmul, 2,  F, D, S)\n-VMUL(fmul, 4,  F, X, S)\n-VMUL(fmul, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MLA --------------------------------------\n-define(`VMLA', `ifelse($1, fmla, `\n-\/\/ dst + src1 * src2')\n-instruct vmla$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{ifelse($2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);', $1, fmla, `\n-  predicate(UseFMA && n->as_Vector()->length() == $2);', `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (ifelse($1, mlav, `AddV'$3` dst (MulV$3 src1 src2)', FmaV$3  `dst (Binary src1 src2)')));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vm`'ifelse($3, F, uldiv_fp, $3, D, uldiv_fp, la)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1   $2  $3 $4 $5\n-VMLA(mlav, 4,  S, D, H)\n-VMLA(mlav, 8,  S, X, H)\n-VMLA(mlav, 2,  I, D, S)\n-VMLA(mlav, 4,  I, X, S)\n-VMLA(fmla, 2,  F, D, S)\n-VMLA(fmla, 4,  F, X, S)\n-VMLA(fmla, 2,  D, X, D)\n-\n-\/\/ --------------------------------- MLS --------------------------------------\n-define(`VMLS', `ifelse($1, fmls, `\n-\/\/ dst - src1 * src2')\n-instruct vmls$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2) %{ifelse($2$3, 4S, `\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);', $1, fmls, `\n-  predicate(UseFMA && n->as_Vector()->length() == $2);', `\n-  predicate(n->as_Vector()->length() == $2);')\n-  match(Set dst (ifelse($1, mlsv, `SubV'$3` dst (MulV$3 src1 src2)', FmaV$3  `dst (Binary (NegV'$3 `src1) src2)));\n-  match(Set dst (FmaV$3  dst (Binary src1 (NegV'$3 `src2))')));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vm`'ifelse($3, F, uldiv_fp, $3, D, uldiv_fp, la)`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1   $2  $3 $4 $5\n-VMLS(mlsv, 4,  S, D, H)\n-VMLS(mlsv, 8,  S, X, H)\n-VMLS(mlsv, 2,  I, D, S)\n-VMLS(mlsv, 4,  I, X, S)\n-VMLS(fmls, 2,  F, D, S)\n-VMLS(fmls, 4,  F, X, S)\n-VMLS(fmls, 2,  D, X, D)\n-\n-\/\/ --------------- Vector Multiply-Add Shorts into Integer --------------------\n-\n-instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (MulAddVS2VI src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"smullv  $tmp, $src1, $src2\\t# vector (4H)\\n\\t\"\n-            \"smullv  $dst, $src1, $src2\\t# vector (8H)\\n\\t\"\n-            \"addpv   $dst, $tmp, $dst\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ smullv(as_FloatRegister($tmp$$reg), __ T4H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ smullv(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($src1$$reg),\n-              as_FloatRegister($src2$$reg));\n-    __ addpv(as_FloatRegister($dst$$reg), __ T4S,\n-             as_FloatRegister($tmp$$reg),\n-             as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp128);\n-%}\n-\n-\/\/ --------------------------------- DIV --------------------------------------\n-define(`VDIV', `\n-instruct vdiv$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (DivV$3 src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2`'ifelse($5, L, D, $5),\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vmuldiv_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VDIV(fdiv, 2,  F, D, S)\n-VDIV(fdiv, 4,  F, X, S)\n-VDIV(fdiv, 2,  D, X, D)\n-\n-\/\/ --------------------------------- SQRT -------------------------------------\n-define(`VSQRT', `\n-instruct vsqrt$2$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (SqrtV$3 src));\n-  format %{ \"$1  $dst, $src\\t# vector ($2$3)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2$5, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(v`'ifelse($2$3, 2F, unop, sqrt)_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl   $1     $2  $3 $4 $5\n-VSQRT(fsqrt, 2,  F, D, S)\n-VSQRT(fsqrt, 4,  F, X, S)\n-VSQRT(fsqrt, 2,  D, X, D)\n-\n-\/\/ --------------------------------- NEG --------------------------------------\n-define(`VNEGI', `\n-instruct vnegI$1(vec$1 dst, vec$1 src)\n-%{\n-  predicate(n->as_Vector()->length_in_bytes() ifelse($1, D, <, ==) 16);\n-  match(Set dst (NegVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"negr  $dst, $src\\t# vector ($2)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), ifelse($1, D, false, true));\n-    __ negr(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp`'ifelse($1, D, 64, 128));\n-%}')dnl\n-dnl  $1  $2\n-VNEGI(D, 8B\/4H\/2S)\n-VNEGI(X, 16B\/8H\/4S)\n-dnl\n-define(`VNEG', `\n-instruct vneg$2$3`'(vec$4 dst, vec$4 src)\n-%{\n-  predicate(n->as_Vector()->length() == $2);\n-  match(Set dst (NegV$3 src));\n-  ins_cost(INSN_COST`'ifelse($3, L, `',` * 3'));\n-  format %{ \"$1  $dst,$src\\t# vector ($2$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($dst$$reg), __ T$2$5,\n-            as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl  $1    $2  $3 $4 $5\n-VNEG(negr, 2,  L, X, D)\n-VNEG(fneg, 2,  F, D, S)\n-VNEG(fneg, 4,  F, X, S)\n-VNEG(fneg, 2,  D, X, D)\n-dnl\n-define(`VLOGICAL', `\n-instruct v$3$5$6`'(vec$7 dst, vec$7 src1, vec$7 src2)\n-%{\n-  predicate(ifelse($5, 8, n->as_Vector()->length_in_bytes() == 4 ||`\n-            ')n->as_Vector()->length_in_bytes() == $5);\n-  match(Set dst ($4V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1  $dst,$src1,$src2\\t# vector ($5$6)\" %}\n-  ins_encode %{\n-    __ $2(as_FloatRegister($dst$$reg), __ T$5$6,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vlogical`'ifelse($7, D, 64, 128));\n-%}')dnl\n-\n-\/\/ --------------------------------- AND --------------------------------------\n-dnl      $1   $2    $3   $4   $5  $6 $7\n-VLOGICAL(and, andr, and, And, 8,  B, D)\n-VLOGICAL(and, andr, and, And, 16, B, X)\n-\n-\/\/ --------------------------------- OR ---------------------------------------\n-VLOGICAL(orr, orr,  or,  Or,  8,  B, D)\n-VLOGICAL(orr, orr,  or,  Or,  16, B, X)\n-\n-\/\/ --------------------------------- XOR --------------------------------------\n-VLOGICAL(xor, eor,  xor, Xor, 8,  B, D)\n-VLOGICAL(xor, eor,  xor, Xor, 16, B, X)\n-\n-\/\/ ------------------------------ Shift ---------------------------------------\n-dnl\n-define(`VSLCNT', `\n-instruct vslcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && ifelse($1, 8,\n-                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n-                            'n->as_Vector()->length_in_bytes() == $1),\n-                                  n->as_Vector()->length_in_bytes() == $1));\n-  match(Set dst (LShiftCntV cnt));\n-  ins_cost(INSN_COST);\n-  format %{ \"dup  $dst, $cnt\\t# shift count vector ($1$2)\" %}\n-  ins_encode %{\n-    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRCNT', `\n-instruct vsrcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && ifelse($1, 8,\n-                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n-                            'n->as_Vector()->length_in_bytes() == $1),\n-                                  n->as_Vector()->length_in_bytes() == $1));\n-  match(Set dst (RShiftCntV cnt));\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"negw  rscratch1, $cnt\\t\"\n-            \"dup   $dst, rscratch1\\t# shift count vector ($1$2)\" %}\n-  ins_encode %{\n-    __ negw(rscratch1, as_Register($cnt$$reg));\n-    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, rscratch1);\n-  %}\n-  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n-%}')dnl\n-dnl\n-\n-\/\/ Vector shift count\n-\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n-\/\/         treat it as ints or bytes here.\n-\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n-\/\/         on vsra8B rule for more details.\n-dnl    $1  $2 $3\n-VSLCNT(8,  B, D)\n-VSLCNT(16, B, X)\n-VSRCNT(8,  B, D)\n-VSRCNT(16, B, X)\n-dnl\n-define(`PREDICATE',\n-`ifelse($1, 8B,\n-            ifelse($3, `', `predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);',\n-                           `predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&`\n-            '$3);'),\n-        $1, 4S,\n-            ifelse($3, `', `predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);',\n-                           `predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&`\n-            '$3);'),\n-        ifelse($3, `', `predicate(n->as_Vector()->length() == $2);',\n-                       `predicate(n->as_Vector()->length() == $2 && $3);'))')dnl\n-dnl\n-define(`VSLL', `\n-instruct vsll$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, )\n-  match(Set dst (LShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRA', `\n-instruct vsra$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n-  match(Set dst (RShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRA_VAR', `\n-instruct vsra$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n-  match(Set dst (RShiftV$2 src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"sshl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n-            as_FloatRegister($shift$$reg));\n-    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRL', `\n-instruct vsrl$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n-  match(Set dst (URShiftV$2 src shift));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSRL_VAR', `\n-instruct vsrl$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n-  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n-  match(Set dst (URShiftV$2 src shift));\n-  ins_cost(INSN_COST * 2);\n-  effect(TEMP_DEF dst);\n-  format %{ \"negr  $dst,$shift\\t\"\n-            \"ushl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n-  ins_encode %{\n-    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n-            as_FloatRegister($shift$$reg));\n-    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n-%}')dnl\n-dnl\n-define(`VSLL_IMM', `\n-instruct vsll$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (LShiftV$2 src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"shl  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-             as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-             as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n-           as_FloatRegister($src$$reg),\n-           (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRA_IMM', `\n-instruct vsra$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (RShiftV$2 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"sshr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', `\n-    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRL_IMM', `\n-instruct vsrl$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n-  match(Set dst (URShiftV$2 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"ushr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) {\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    } else {\n-      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRLA_IMM', `\n-instruct vsrla$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == $1);\n-  match(Set dst (AddV$2 dst (URShiftV$2 src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"usra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh < 8) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh < 16) {\n-      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-              as_FloatRegister($src$$reg), sh);\n-    }', `\n-    __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-define(`VSRAA_IMM', `\n-instruct vsraa$1$2_imm`'(vec$4 dst, vec$4 src, immI_positive shift) %{\n-  predicate(n->as_Vector()->length() == $1);\n-  match(Set dst (AddV$2 dst (RShiftV$2 src (RShiftCntV shift))));\n-  ins_cost(INSN_COST);\n-  format %{ \"ssra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n-  ins_encode %{ifelse($2, B,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 8) sh = 7;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', $2, S,`\n-    int sh = (int)$shift$$constant;\n-    if (sh >= 16) sh = 15;\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg), sh);', `\n-    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n-            as_FloatRegister($src$$reg),\n-            (int)$shift$$constant);')\n-  %}\n-  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n-%}')dnl\n-dnl\n-undefine(PREDICATE)dnl\n-dnl\n-dnl  $1  $2 $3 $4\n-VSLL(8,  B, B, D)\n-VSLL(16, B, B, X)\n-\n-\/\/ Right shifts with vector shift count on aarch64 SIMD are implemented\n-\/\/ as left shift by negative shift count.\n-\/\/ There are two cases for vector shift count.\n-\/\/\n-\/\/ Case 1: The vector shift count is from replication.\n-\/\/        |            |\n-\/\/    LoadVector  RShiftCntV\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ Case 2: The vector shift count is from loading.\n-\/\/ This case isn't supported by middle-end now. But it's supported by\n-\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n-\/\/        |            |\n-\/\/    LoadVector  LoadVector\n-\/\/        |       \/\n-\/\/     RShiftVI\n-\/\/\n-\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n-\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n-\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n-\/\/ to outer loop and merged into one neg instruction.\n-\/\/\n-\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n-\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n-\/\/ i.e. case 1).\n-dnl  $1  $2 $3 $4\n-VSRA(8,  B, B, D)\n-VSRA_VAR(8,  B, B, D)\n-VSRA(16, B, B, X)\n-VSRA_VAR(16, B, B, X)\n-VSRL(8,  B, B, D)\n-VSRL_VAR(8,  B, B, D)\n-VSRL(16, B, B, X)\n-VSRL_VAR(16, B, B, X)\n-VSLL_IMM(8,  B, B, D)\n-VSLL_IMM(16, B, B, X)\n-VSRA_IMM(8,  B, B, D)\n-VSRA_IMM(16, B, B, X)\n-VSRL_IMM(8,  B, B, D)\n-VSRL_IMM(16, B, B, X)\n-VSLL(4,  S, H, D)\n-VSLL(8,  S, H, X)\n-VSRA(4,  S, H, D)\n-VSRA_VAR(4,  S, H, D)\n-VSRA(8,  S, H, X)\n-VSRA_VAR(8,  S, H, X)\n-VSRL(4,  S, H, D)\n-VSRL_VAR(4,  S, H, D)\n-VSRL(8,  S, H, X)\n-VSRL_VAR(8,  S, H, X)\n-VSLL_IMM(4,  S, H, D)\n-VSLL_IMM(8,  S, H, X)\n-VSRA_IMM(4,  S, H, D)\n-VSRA_IMM(8,  S, H, X)\n-VSRL_IMM(4,  S, H, D)\n-VSRL_IMM(8,  S, H, X)\n-VSLL(2,  I, S, D)\n-VSLL(4,  I, S, X)\n-VSRA(2,  I, S, D)\n-VSRA_VAR(2,  I, S, D)\n-VSRA(4,  I, S, X)\n-VSRA_VAR(4,  I, S, X)\n-VSRL(2,  I, S, D)\n-VSRL_VAR(2,  I, S, D)\n-VSRL(4,  I, S, X)\n-VSRL_VAR(4,  I, S, X)\n-VSLL_IMM(2,  I, S, D)\n-VSLL_IMM(4,  I, S, X)\n-VSRA_IMM(2,  I, S, D)\n-VSRA_IMM(4,  I, S, X)\n-VSRL_IMM(2,  I, S, D)\n-VSRL_IMM(4,  I, S, X)\n-VSLL(2,  L, D, X)\n-VSRA(2,  L, D, X)\n-VSRA_VAR(2,  L, D, X)\n-VSRL(2,  L, D, X)\n-VSRL_VAR(2,  L, D, X)\n-VSLL_IMM(2,  L, D, X)\n-VSRA_IMM(2,  L, D, X)\n-VSRL_IMM(2,  L, D, X)\n-VSRAA_IMM(8,  B, B, D)\n-VSRAA_IMM(16, B, B, X)\n-VSRAA_IMM(4,  S, H, D)\n-VSRAA_IMM(8,  S, H, X)\n-VSRAA_IMM(2,  I, S, D)\n-VSRAA_IMM(4,  I, S, X)\n-VSRAA_IMM(2,  L, D, X)\n-VSRLA_IMM(8,  B, B, D)\n-VSRLA_IMM(16, B, B, X)\n-VSRLA_IMM(4,  S, H, D)\n-VSRLA_IMM(8,  S, H, X)\n-VSRLA_IMM(2,  I, S, D)\n-VSRLA_IMM(4,  I, S, X)\n-VSRLA_IMM(2,  L, D, X)\n-dnl\n-define(`VMINMAX', `\n-instruct v$1$3`'ifelse($5, S, F, D)`'(vec$6 dst, vec$6 src1, vec$6 src2)\n-%{\n-  predicate(n->as_Vector()->length() == $3 && n->bottom_type()->is_vect()->element_basic_type() == T_`'ifelse($5, S, FLOAT, DOUBLE));\n-  match(Set dst ($2V src1 src2));\n-  ins_cost(INSN_COST);\n-  format %{ \"f$1  $dst,$src1,$src2\\t# vector ($3$4)\" %}\n-  ins_encode %{\n-    __ f$1(as_FloatRegister($dst$$reg), __ T$3$5,\n-            as_FloatRegister($src1$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop_fp`'ifelse($6, D, 64, 128));\n-%}')dnl\n-dnl     $1   $2   $3 $4 $5 $6\n-VMINMAX(max, Max, 2, F, S, D)\n-VMINMAX(max, Max, 4, S, S, X)\n-VMINMAX(max, Max, 2, D, D, X)\n-VMINMAX(min, Min, 2, F, S, D)\n-VMINMAX(min, Min, 4, S, S, X)\n-VMINMAX(min, Min, 2, D, D, X)\n-\n-instruct vround2D_reg(vecX dst, vecX src, immI rmode) %{\n-  predicate(n->as_Vector()->length() == 2 && n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"frint  $dst, $src, $rmode\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ frintn(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ frintm(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ frintp(as_FloatRegister($dst$$reg), __ T2D,\n-                  as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(vdop_fp128);\n-%}\n-dnl\n-define(`VPOPCOUNT', `dnl\n-ifelse($1$2, `LD', `\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountLX\" rule.', `')\n-instruct vpopcount$1$2`'(vec$2 dst, vec$3 src) %{\n-  predicate(n->as_Vector()->length_in_bytes() $4 16`'ifelse($1$2, `LD', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT', $1$2, `LX', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst (PopCountV$1 src));\n-  ins_cost($5 * INSN_COST);\n-  format %{ \"vpopcount$1  $dst, $src\\t# vector ($6)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ cnt(as_FloatRegister($dst$$reg), __ T`'ifelse($3, D, 8, 16)B,\n-           as_FloatRegister($src$$reg));dnl\n-ifelse($1, `L', `\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n-              as_FloatRegister($dst$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n-              as_FloatRegister($dst$$reg));', `\n-    if (bt == T_SHORT || bt == T_INT) {\n-      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 8, 16)B,\n-                as_FloatRegister($dst$$reg));\n-      if (bt == T_INT) {\n-        __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 4, 8)H,\n-                  as_FloatRegister($dst$$reg));\n-      }\n-    }')dnl\n-ifelse($1$2, `LD', `\n-    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n-           as_FloatRegister($dst$$reg), __ T2D);', `')\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl       $1 $2 $3 $4  $5 $6\n-VPOPCOUNT(I, D, D, <,  3, 8B\/4H\/2S)\n-VPOPCOUNT(I, X, X, ==, 3, 16B\/8H\/4S)\n-VPOPCOUNT(L, D, X, <,  5, 2S)\n-VPOPCOUNT(L, X, X, ==, 4, 2D)\n-dnl\n-dnl VMASK_TRUECOUNT($1,     $2 )\n-dnl VMASK_TRUECOUNT(suffix, reg)\n-define(`VMASK_TRUECOUNT', `\n-instruct vmask_truecount$1(iRegINoSp dst, $2 src, $2 tmp) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskTrueCount src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"addv $tmp, $src\\n\\t\"\n-            \"umov $dst, $tmp, B, 0\\t# vector ($1)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n-    \/\/ 0x00\/0x01 as element values.\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1, as_FloatRegister($src$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-define(`ARGLIST',\n-`ifelse($1, `_LT8B', `iRegINoSp dst, vecD src, rFlagsReg cr', `iRegINoSp dst, vecD src')')\n-dnl\n-dnl VMASK_FIRSTTRUE_D($1,     $2,   $3,   $4  )\n-dnl VMASK_FIRSTTRUE_D(suffix, cond, cost, size)\n-define(`VMASK_FIRSTTRUE_D', `\n-instruct vmask_firsttrue$1(ARGLIST($1)) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN &&\n-            n->in(1)->bottom_type()->is_vect()->length() $2 8);\n-  match(Set dst (VectorMaskFirstTrue src));dnl\n-ifelse($1, `_LT8B', `\n-  effect(KILL cr);')\n-  ins_cost($3 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector ($4)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);dnl\n-ifelse(`$1', `_LT8B', `\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-undefine(ARGLIST)dnl\n-dnl\n-\/\/ vector mask reductions\n-VMASK_TRUECOUNT(8B,  vecD)\n-VMASK_TRUECOUNT(16B, vecX)\n-VMASK_FIRSTTRUE_D(_LT8B, <,  7, 4I\/4S\/2I)\n-VMASK_FIRSTTRUE_D(8B,    ==, 4, 8B)\n-\n-instruct vmask_firsttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  ins_cost(6 * INSN_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or 16 (VLENGTH) if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label FIRST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, zr);\n-    __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8);\n-\n-    \/\/ Reverse the bits and count the leading zero bytes.\n-    __ bind(FIRST_TRUE_INDEX);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue8B(iRegINoSp dst, vecD src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by counting the leading zero bytes and\n-    \/\/ subtracting it by 7 (VLENGTH - 1).\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ movw(rscratch1, 7);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue16B(iRegINoSp dst, vecX src) %{\n-  predicate(n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n-  match(Set dst (VectorMaskLastTrue src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the last active lane of the\n-    \/\/ vector mask, or -1 if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    Label LAST_TRUE_INDEX;\n-\n-    \/\/ Try to compute the result from higher 64 bits.\n-    __ fmovhid($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 16 - 1);\n-    __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n-\n-    \/\/ Compute the result from the lower 64 bits.\n-    __ fmovd($dst$$Register, as_FloatRegister($src$$reg));\n-    __ movw(rscratch1, 8 - 1);\n-\n-    \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n-    __ bind(LAST_TRUE_INDEX);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong8B(iRegLNoSp dst, vecD src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (8B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ fmovd(as_Register($dst$$reg), as_FloatRegister($src$$reg));\n-    __ bytemask_compress(as_Register($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong16B(iRegLNoSp dst, vecX src) %{\n-  match(Set dst (VectorMaskToLong src));\n-  ins_cost(11 * INSN_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# convert mask to long (16B)\" %}\n-  ins_encode %{\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, 0);\n-    __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n-    __ bytemask_compress(as_Register($dst$$reg));\n-    __ bytemask_compress(rscratch1);\n-    __ orr(as_Register($dst$$reg), as_Register($dst$$reg),\n-           rscratch1, Assembler::LSL, 8);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl CLTZ_D($1     )\n-dnl CLTZ_D(op_name)\n-define(`CLTZ_D', `\n-instruct count$1D(vecD dst, vecD src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 8);\n-  match(Set dst (Count$1 src));\n-  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n-  format %{ \"count$1 $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);dnl\n-ifelse($1, `TrailingZerosV', `\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);', `')\n-    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl CLTZ_X($1     )\n-dnl CLTZ_X(op_name)\n-define(`CLTZ_X', `\n-instruct count$1X(vecX dst, vecX src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == 16);\n-  match(Set dst (Count$1 src));\n-  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n-  format %{ \"count$1 $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);dnl\n-ifelse($1, `TrailingZerosV', `\n-    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);', `')\n-    if (bt != T_LONG) {\n-      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n-    } else {\n-      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 0);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n-      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 1);\n-      __ clz(rscratch1, rscratch1);\n-      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/------------------------- CountLeadingZerosV -----------------------------\n-CLTZ_D(LeadingZerosV)\n-CLTZ_X(LeadingZerosV)\n-\n-\/\/------------------------- CountTrailingZerosV ----------------------------\n-CLTZ_D(TrailingZerosV)\n-CLTZ_X(TrailingZerosV)\n-\n-dnl\n-dnl REVERSE($1,        $2,      $3,   $4  )\n-dnl REVERSE(insn_name, op_name, type, insn)\n-define(`REVERSE', `\n-instruct $1(vec$3 dst, vec$3 src) %{\n-  predicate(n->as_Vector()->length_in_bytes() == ifelse($3, D, 8, 16));\n-  match(Set dst ($2 src));\n-  ins_cost(ifelse($2, `ReverseV', `2 * ', `')INSN_COST);\n-  format %{ \"$2 $dst, $src\\t# vector ($3)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ $4(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, ifelse($3, D, false, true));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/------------------------------ ReverseV -----------------------------------\n-REVERSE(vreverseD, ReverseV, D, neon_reverse_bits)\n-REVERSE(vreverseX, ReverseV, X, neon_reverse_bits)\n-\n-\/\/---------------------------- ReverseBytesV --------------------------------\n-REVERSE(vreverseBytesD, ReverseBytesV, D, neon_reverse_bytes)\n-REVERSE(vreverseBytesX, ReverseBytesV, X, neon_reverse_bytes)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":0,"deletions":2749,"binary":false,"changes":2749,"status":"deleted"},{"patch":"@@ -1,5922 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n-\n-\/\/ AArch64 SVE Architecture Description File\n-\n-\n-\/\/ 4 bit signed offset -- for predicated load\/store\n-\n-operand vmemA_immIOffset4()\n-%{\n-  \/\/ (esize \/ msize) = 1\n-  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n-            Matcher::scalable_vector_reg_size(T_BYTE)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand vmemA_immLOffset4()\n-%{\n-  \/\/ (esize \/ msize) = 1\n-  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n-            Matcher::scalable_vector_reg_size(T_BYTE)));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n-\/\/ size equals to memory element (load from\/store to) size.\n-opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n-\n-source_hpp %{\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt);\n-%}\n-\n-source %{\n-\n-  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n-                                                             PRegister Pg, const Address &adr);\n-\n-  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n-                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n-                                    int opcode, Register base, int index, int size, int disp) {\n-    sve_mem_insn_predicate insn;\n-    int mesize = type2aelembytes(mem_elem_bt);\n-    if (index == -1) {\n-      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n-      switch(mesize) {\n-      case 1:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n-        break;\n-      case 2:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n-        break;\n-      case 4:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n-        break;\n-      case 8:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n-        break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-      }\n-      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n-    } else {\n-      assert(false, \"unimplemented\");\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    int length_in_bytes = vlen * type2aelembytes(bt);\n-    switch (opcode) {\n-      case Op_MulAddVS2VI:\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_ExtractC:\n-      case Op_ExtractUB:\n-        return false;\n-      \/\/ Vector API specific\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        return vlen >= 4 && length_in_bytes <= MaxVectorSize;\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        return Matcher::vector_size_supported(bt, vlen);\n-      case Op_ExpandV:\n-        if (UseSVE < 2 || is_subword_type(bt)) return false;\n-      case Op_VectorMaskToLong:\n-        if (vlen > 64) return false;\n-      case Op_VectorLongToMask:\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n-      default:\n-        break;\n-    }\n-    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n-    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n-  }\n-\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    switch(opcode) {\n-      case Op_VectorRearrange:\n-        return false;\n-      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n-      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n-      \/\/ same as vector store\/gather\/scatter.\n-      case Op_LoadVector:\n-        opcode = Op_LoadVectorMasked;\n-        break;\n-      case Op_StoreVector:\n-        opcode = Op_StoreVectorMasked;\n-        break;\n-      case Op_LoadVectorGather:\n-        opcode = Op_LoadVectorGatherMasked;\n-        break;\n-      case Op_StoreVectorScatter:\n-        opcode = Op_StoreVectorScatterMasked;\n-        break;\n-      default:\n-        break;\n-    }\n-    return op_sve_supported(opcode, vlen, bt);\n-  }\n-\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt) {\n-    switch(node->Opcode()) {\n-      case Op_VectorLoadMask:\n-      case Op_VectorMaskCmp:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_AddReductionVI:\n-      case Op_AddReductionVL:\n-      case Op_AddReductionVF:\n-      case Op_AddReductionVD:\n-      case Op_MinReductionV:\n-      case Op_MaxReductionV:\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n-      \/\/ input predicate is all-false, the result should be the vector length\n-      \/\/ instead of the vector register size.\n-      case Op_VectorMaskFirstTrue:\n-        return true;\n-      case Op_MaskAll:\n-        return !node->in(1)->is_Con();\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n-      default:\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n-        return false;\n-    }\n-  }\n-%}\n-\n-definitions %{\n-  int_def SVE_COST             (200, 200);\n-%}\n-\n-\n-\/\/ All SVE instructions\n-\n-\/\/ vector load\/store\n-\n-\/\/ Unpredicated vector load\/store\n-instruct loadV(vReg dst, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV(vReg src, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister src_reg = as_FloatRegister($src$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Load Vector (16 bits)\n-instruct loadV2_vreg(vReg dst, vmem2 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 2);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrh   $dst,$mem\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (16 bits)\n-instruct storeV2_vreg(vReg src, vmem2 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 2);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strh   $mem,$src\\t# vector (16 bits)\" %}\n-  ins_encode( aarch64_enc_strvH(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (32 bits)\n-instruct loadV4_vreg(vReg dst, vmem4 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 4);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrs   $dst,$mem\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (32 bits)\n-instruct storeV4_vreg(vReg src, vmem4 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 4);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strs   $mem,$src\\t# vector (32 bits)\" %}\n-  ins_encode( aarch64_enc_strvS(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (64 bits)\n-instruct loadV8_vreg(vReg dst, vmem8 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 8);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrd   $dst,$mem\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n-  ins_pipe(vload_reg_mem64);\n-%}\n-\n-\/\/ Store Vector (64 bits)\n-instruct storeV8_vreg(vReg src, vmem8 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 8);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strd   $mem,$src\\t# vector (64 bits)\" %}\n-  ins_encode( aarch64_enc_strvD(src, mem) );\n-  ins_pipe(vstore_reg_mem64);\n-%}\n-\n-\/\/ Load Vector (128 bits)\n-instruct loadV16_vreg(vReg dst, vmem16 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"ldrq   $dst,$mem\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n-  ins_pipe(vload_reg_mem128);\n-%}\n-\n-\/\/ Store Vector (128 bits)\n-instruct storeV16_vreg(vReg src, vmem16 mem)\n-%{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"strq   $mem,$src\\t# vector (128 bits)\" %}\n-  ins_encode( aarch64_enc_strvQ(src, mem) );\n-  ins_pipe(vstore_reg_mem128);\n-%}\n-\n-\/\/ vector load\/store - predicated\n-\n-instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ mask logical and\/or\/xor\n-\n-instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_and(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (OrVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (XorVMask pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ mask logical and_not\n-\n-instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector reinterpret\n-\n-instruct reinterpret(vReg dst) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n-    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n-    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n-                                  length_in_bytes_src : length_in_bytes_dst;\n-    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n-           \"invalid vector length\");\n-    __ sve_gen_mask_imm(as_PRegister($pgtmp$$reg), T_BYTE, length_in_bytes_resize);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask reinterpret\n-\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorReinterpret dst_src));\n-  ins_cost(0);\n-  format %{ \"# vmask_reinterpret $dst_src\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() != n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"# vmask_reinterpret $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), from_size, as_PRegister($src$$reg), -1, false);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector abs\n-\n-instruct vabsB(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVB src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsS(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVS src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (AbsVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector abs - predicated\n-\n-instruct vabsB_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVB dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsS_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVS dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_abs $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_abs(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vabsD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AbsVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fabs $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fabs(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add\n-\n-instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVB src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVS src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVI src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVL src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add - predicated\n-\n-instruct vaddB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_add(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadd $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fadd(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reg imm (unpredicated)\n-\n-instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ B, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ B, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ H, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ H, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ S, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ S, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ D, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ D, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector binary op reg imm (unpredicated)\n-\n-instruct vandB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vandD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AndV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vorD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (OrV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorB(vReg dst_src, immBLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateB con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ B,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorH(vReg dst_src, immSLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateS con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ H,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorS(vReg dst_src, immILog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateI con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ S,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vxorD(vReg dst_src, immLLog con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV dst_src (ReplicateL con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst_src$$reg), __ D,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\/\/ vector and\n-\n-instruct vand(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_and(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or\n-\n-instruct vor(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (OrV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor\n-\n-instruct vxor(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ sve_eor(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and - predicated\n-\n-instruct vand_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_and $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_and(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or - predicated\n-\n-instruct vor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (OrV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orr $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_orr(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor - predicated\n-\n-instruct vxor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (XorV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eor $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_eor(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector not\n-\n-instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (XorV src (ReplicateL m1)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector not - predicated\n-\n-instruct vnotI_masked(vReg dst_src, immI_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnotL_masked(vReg dst_src, immL_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and_not\n-\n-instruct vand_notI(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vand_notL(vReg dst, vReg src1, vReg src2, immL_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and_not - predicated\n-\n-instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) B\/H\/S\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) D\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector float div\n-\n-instruct vdivF(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVF dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vdivD(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVD dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector float div - predicated\n-\n-instruct vfdivF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vfdivD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min\/max\n-\n-instruct vmin(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MinV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_min $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmax(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MaxV dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_max $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min\/max - predicated\n-\n-instruct vmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MinV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_min $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MaxV (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_max $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmla\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmad - predicated\n-\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmls\n-\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmlsF1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmlsF2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmlsD1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmlsD2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fmsb - predicated\n-\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmla\n-\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlaF1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlaF2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlaD1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlaD2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmad - predicated\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmadF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmadD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmls\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector fnmsb - predicated\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegVF must not be predicated.\n-instruct vfnmsbF_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegVD must not be predicated.\n-instruct vfnmsbD_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mla\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaB(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaS(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaI(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaL(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mla - predicated\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmlaL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mls\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsB(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsS(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsI(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsL(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mls - predicated\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsB_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsS_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsI_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmlsL_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mul\n-\n-instruct vmulB(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVB dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulS(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVS dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulI(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVI dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulL(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVL dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MulVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MulVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mul - predicated\n-\n-instruct vmulB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmulD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmul $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fmul(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector neg\n-\n-instruct vnegI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_neg(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (NegVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector neg - predicated\n-\n-instruct vnegI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_neg(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_neg $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_neg(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vnegD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (NegVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fneg $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fneg(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector popcount\n-\n-instruct vpopcountI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (PopCountVI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vpopcountL(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (PopCountVL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\n\\t\"\n-            \"sve_dup $vtmp, #0\\n\\t\"\n-            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector popcount - predicated\n-\n-instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (PopCountVI dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst_src (PopCountVL dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ D,\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector blend\n-\n-instruct vblend(vReg dst, vReg src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorBlend (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sel $dst, $pg, $src2, $src1\\t# vector blend (sve)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size =\n-               __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n-    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector store mask\n-\n-instruct vstoremaskB(vReg dst, pRegGov src, immI_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, as_PRegister($src$$reg), 1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n-                                      vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg2, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg2, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the \"pg2\" used in VectorLoadMask.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg2$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg2$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeV_vstoremask(indirect mem, pRegGov src, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, vReg vtmp,\n-                                  immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector store with boolean type. But the predicate used in\n-    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n-    \/\/ is the full-sized predicate (ptrue) here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp,\n-                                        immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n-    \/\/ vector store with boolean type. But the predicate used in the narrowing\n-    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n-    \/\/ here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reduction\n-\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector add reduction - predicated\n-\n-instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVI (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addI $dst, $src1, $pg, $src2\\t# addI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (AddReductionVL (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addL $dst, $src1, $pg, $src2\\t# addL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF_masked(vRegF src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVF (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addF $src1_dst, $pg, $src2\\t# addF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD_masked(vRegD src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst (AddReductionVD (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_addD $src1_dst, $pg, $src2\\t# addD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and reduction\n-\n-instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector and reduction - predicated\n-\n-instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andI $dst, $src1, $pg, $src2\\t# andI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_andL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (AndReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_andL $dst, $src1, $pg, $src2\\t# andL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or reduction\n-\n-instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector or reduction - predicated\n-\n-instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orI $dst, $src1, $pg, $src2\\t# orI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (OrReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_orL $dst, $src1, $pg, $src2\\t# orL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor reduction\n-\n-instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# eorI reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# eorL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector xor reduction - predicated\n-\n-instruct reduce_eorI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorI $dst, $src1, $pg, $src2\\t# eorI reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (XorReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_eorL $dst, $src1, $pg, $src2\\t# eorL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector max reduction\n-\n-instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxI $dst, $src1, $src2\\t# maxI reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxL $dst, $src1, $src2\\t# maxL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxF $dst, $src1, $src2\\t# maxF reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxD $dst, $src1, $src2\\t# maxD reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector max reduction - predicated\n-\n-instruct reduce_maxI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxI $dst, $src1, $pg, $src2\\t# maxI reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_maxL $dst, $src1, $pg, $src2\\t# maxL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxF_masked(vRegF dst, vRegF src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxF $dst, $src1, $pg, $src2\\t# maxF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxD_masked(vRegD dst, vRegD src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MaxReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_maxD $dst, $src1, $pg, $src2\\t# maxD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min reduction\n-\n-instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minI $dst, $src1, $src2\\t# minI reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minL $dst, $src1, $src2\\t# minL reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minF $dst, $src1, $src2\\t# minF reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minD $dst, $src1, $src2\\t# minD reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector min reduction - predicated\n-\n-instruct reduce_minI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minI $dst, $src1, $pg, $src2\\t# minI reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minL_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_minL $dst, $src1, $pg, $src2\\t# minL reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minF_masked(vRegF dst, vRegF src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minF $dst, $src1, $pg, $src2\\t# minF reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ S, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minD_masked(vRegD dst, vRegD src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (MinReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_minD $dst, $src1, $pg, $src2\\t# minD reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector Math.rint, floor, ceil\n-\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vroundFtoI(vReg dst, vReg src, vReg tmp1, vReg tmp2, vReg tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundVF src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, S, $src\\t# round F to I vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ S);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vroundDtoL(vReg dst, vReg src, vReg tmp1, vReg tmp2, vReg tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundVD src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, D, $src\\t# round D to L vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ D);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ vector replicate\n-\n-instruct replicateB(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateB src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateS src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI(vReg dst, iRegIorL2I src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateI src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateL(vReg dst, iRegL src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateL src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateB_imm8(vReg dst, immI8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateB con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateS con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateI con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateL con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateF(vReg dst, vRegF src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct replicateD(vReg dst, vRegD src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ReplicateD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector shift\n-\n-instruct vasrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVB dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVS dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVI dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVL dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVB src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) con = 7;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVS src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) con = 15;\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVI src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RShiftVL src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVB src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVS src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVI src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (URShiftVL src (RShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVB src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVS src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVI src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LShiftVL src (LShiftCntV shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector shift - predicated\n-\n-instruct vasrB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (RShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_asr(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (LShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsl(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (URShiftVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_lsr(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vasrL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_asr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_asr(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlsrL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsr $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con > 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_lsr(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslB_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 8, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ B, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslS_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 16, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ H, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslI_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 32, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ S, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vlslL_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_lsl $dst_src, $pg, $dst_src, $shift\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con >= 0 && con < 64, \"invalid shift immediate\");\n-    __ sve_lsl(as_FloatRegister($dst_src$$reg), __ D, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sqrt\n-\n-instruct vsqrtF(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (SqrtVF src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (SqrtVD src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sqrt - predicated\n-\n-instruct vsqrtF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (SqrtVF dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst_src, $pg, $dst_src\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst_src$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsqrtD_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (SqrtVD dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsqrt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsqrt(as_FloatRegister($dst_src$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub\n-\n-instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVB src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVS src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVI src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVL src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVF src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (SubVD src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector sub - predicated\n-\n-instruct vsubB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVB (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ B,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVS (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (H)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ H,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVI (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVL (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_sub(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVF (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst_src1$$reg), __ S,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vsubD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVD (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fsub $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fsub(as_FloatRegister($dst_src1$$reg), __ D,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector mask cast --------------------------\n-\n-instruct vmaskcast(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorMaskCast dst_src));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst_src\\t# empty (sve)\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcast_extend(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcast_narrow(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-\n-instruct vcvtBtoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoF(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2f  $dst, $src\\t# convert I to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastL2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_l2d  $dst, $src\\t# convert L to D vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST * 2);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastD2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_d2l  $dst, $src\\t# convert D to L vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n-  ins_encode %{\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 16);\n-  match(Set dst (ExtractB src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ B, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 8);\n-  match(Set dst (ExtractS src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ H, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 4);\n-  match(Set dst (ExtractI src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ S, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 2);\n-  match(Set dst (ExtractL src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ D, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ false, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractB_LT16(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 16);\n-  match(Set dst (ExtractB src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ B, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractS_LT8(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 8);\n-  match(Set dst (ExtractS src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ H, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractI_LT4(iRegINoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 4);\n-  match(Set dst (ExtractI src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"smov $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n-  ins_encode %{\n-    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ S, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractL_LT2(iRegLNoSp dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 2);\n-  match(Set dst (ExtractL src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"umov $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n-  ins_encode %{\n-    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct extractF(vRegF dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant < 4) {\n-      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractD(vRegD dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant == 1) {\n-      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------- VectorTest ----------------------------------\n-\n-instruct vtest_alltrue(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eors $ptmp, $src1, $src2\\t# $src2 is all true mask\\n\"\n-            \"csetw $dst, EQ\\t# VectorTest (sve) - alltrue\" %}\n-  ins_encode %{\n-    __ sve_eors(as_PRegister($ptmp$$reg), ptrue,\n-                as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vtest_anytrue(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptest $src1\\n\\t\"\n-            \"csetw $dst, NE\\t# VectorTest (sve) - anytrue\" %}\n-  ins_encode %{\n-    \/\/ \"src2\" is not used for sve.\n-    __ sve_ptest(ptrue, as_PRegister($src1$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n-      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (L) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (L)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n-            \"sve_dup $dst, S, $idx\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (D) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (D)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                   as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n-                           as_FloatRegister($src$$reg), __ B);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector rearrange -------------------------------\n-\n-instruct rearrange(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather ---------------------------------\n-\n-instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGather mem idx));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n-                       as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather Predicated -------------------------------\n-\n-instruct gatherI_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (S)\" %}\n-  ins_encode %{\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter -------------------------------\n-\n-instruct scatterI(indirect mem, vReg src, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter Predicated -------------------------------\n-\n-instruct scatterI_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicate (S)\" %}\n-  ins_encode %{\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Const -------------------------------\n-\n-instruct loadconB(vReg dst, immI0 src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------- Populate Index to a Vector --------------------------\n-\n-instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopulateIndex src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_index(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                 as_Register($src1$$reg), $src2$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ----------------------------- String Intrinsics -------------------------------\n-\n-\/\/ Intrisics for String.indexOf(char)\n-\n-\n-instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), true \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), false \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-\n-instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::LU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UL);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::UU);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ ---------------------------- Vector mask reductions ---------------------------\n-instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskTrueCount src));\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Return the index of the first mask lane that is set, or vector length if none of\n-\/\/ them are set.\n-instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskFirstTrue src pg));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $pg, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pg$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n-  ins_encode %{\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n-  match(Set dst (VectorLongToMask src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(10 * SVE_COST);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n-  ins_encode %{\n-    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n-\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n-\/\/ are cleared with zero when the vector length is less than the full size of\n-\/\/ hardware vector register width.\n-\n-\n-\/\/ maskAll\n-\n-instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    int con = (int)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    long con = (long)$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ maskAll - predicated\n-\n-instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $pg, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $pg, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask gen\n-\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen (ConvI2L src)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_whilelow $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_whilelow(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_whilelo $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_whilelo(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct vmask_gen_imm(pRegGov pd, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_gen_imm $pd, $src\\t# vector mask gen with imm (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_gen_mask_imm(as_PRegister($pd$$reg), bt, (uint) $src$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n-\n-instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (CompressM pg));\n-  effect(KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n-            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n-    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (CompressV src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n-                    pReg ptmp, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n-  ins_encode %{\n-    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n-                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n-                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(38 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n-  ins_encode %{\n-    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n-  match(Set dst (ExpandV src pg));\n-  effect(TEMP_DEF dst);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n-            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n-            \"sve_sub $dst, S\/D, 1\\n\\t\"\n-            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n-    \/\/                  pg    = 1 0 0 1 1 0 1 1\n-    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n-\n-    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n-    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n-    \/\/ for TBL whose value is used to select the indexed element from src vector.\n-\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    \/\/ dst = 0 0 0 0 0 0 0 0\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n-    \/\/ dst = 5 0 0 4 3 0 2 1\n-    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n-    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n-    \/\/ dst = 4 0 0 5 6 0 7 8\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n-               as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n-\n-instruct vcountLeadingZeros(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (CountLeadingZerosV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_clz $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (CountLeadingZerosV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_clz $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n-\n-instruct vcountTrailingZeros(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (CountTrailingZerosV src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_rbit $dst, $src\\n\\t\"\n-            \"sve_clz  $dst, $dst\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (CountTrailingZerosV dst_src pg));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n-            \"sve_clz  $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------------- ReverseV ------------------------------------\n-\n-instruct vreverse(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (ReverseV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_rbit $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (ReverseV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------------- ReverseBytesV ---------------------------------\n-\n-instruct vreverseBytes(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst (ReverseBytesV src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_revb $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_revb(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (ReverseBytesV dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_revb $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (bt == T_BYTE) {\n-      \/\/ do nothing\n-    } else {\n-      __ sve_revb(as_FloatRegister($dst_src$$reg), size,\n-          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":0,"deletions":5922,"binary":false,"changes":5922,"status":"deleted"},{"patch":"@@ -1,3470 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-dnl Generate the warning\n-\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n-dnl\n-\n-\/\/ AArch64 SVE Architecture Description File\n-\n-dnl\n-define(`TYPE2DATATYPE',\n-`ifelse($1, `B', `BYTE',\n-        $1, `S', `SHORT',\n-        $1, `I', `INT',\n-        $1, `L', `LONG',\n-        $1, `F', `FLOAT',\n-        $1, `D', `DOUBLE',\n-        `error($1)')')dnl\n-dnl\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3       $4   )\n-dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len, scale)\n-define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n-operand vmemA_imm$1Offset$3()\n-%{\n-  \/\/ (esize \/ msize) = $4\n-  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), $3,\n-            Matcher::scalable_vector_reg_size(T_BYTE)ifelse($4, `1', `', ` \/ $4')));\n-  match(Con$1);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}')dnl\n-\n-\/\/ 4 bit signed offset -- for predicated load\/store\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4, 1)\n-OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4, 1)\n-dnl\n-dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1,            $2     )\n-dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr, imm_len)\n-define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n-operand vmemA_indOff$1$2$3(iRegP reg, vmemA_imm$1Offset$2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    `index'(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}')dnl\n-OPERAND_VMEMORYA_INDIRECT_OFFSET(I, 4)\n-OPERAND_VMEMORYA_INDIRECT_OFFSET(L, 4)\n-\n-\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n-\/\/ size equals to memory element (load from\/store to) size.\n-opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n-\n-source_hpp %{\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt);\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt);\n-%}\n-\n-source %{\n-\n-  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n-                                                             PRegister Pg, const Address &adr);\n-\n-  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n-  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n-                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n-                                    int opcode, Register base, int index, int size, int disp) {\n-    sve_mem_insn_predicate insn;\n-    int mesize = type2aelembytes(mem_elem_bt);\n-    if (index == -1) {\n-      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n-      switch(mesize) {\n-      case 1:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n-        break;\n-      case 2:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n-        break;\n-      case 4:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n-        break;\n-      case 8:\n-        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n-        break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-      }\n-      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n-      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n-    } else {\n-      assert(false, \"unimplemented\");\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  bool op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    int length_in_bytes = vlen * type2aelembytes(bt);\n-    switch (opcode) {\n-      case Op_MulAddVS2VI:\n-      \/\/ No multiply reduction instructions\n-      case Op_MulReductionVD:\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVI:\n-      case Op_MulReductionVL:\n-      \/\/ Others\n-      case Op_ExtractC:\n-      case Op_ExtractUB:\n-        return false;\n-      \/\/ Vector API specific\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        return vlen >= 4 && length_in_bytes <= MaxVectorSize;\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        return Matcher::vector_size_supported(bt, vlen);\n-      case Op_ExpandV:\n-        if (UseSVE < 2 || is_subword_type(bt)) return false;\n-      case Op_VectorMaskToLong:\n-        if (vlen > 64) return false;\n-      case Op_VectorLongToMask:\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) return false;\n-      default:\n-        break;\n-    }\n-    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n-    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n-  }\n-\n-  bool masked_op_sve_supported(int opcode, int vlen, BasicType bt) {\n-    switch(opcode) {\n-      case Op_VectorRearrange:\n-        return false;\n-      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n-      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n-      \/\/ same as vector store\/gather\/scatter.\n-      case Op_LoadVector:\n-        opcode = Op_LoadVectorMasked;\n-        break;\n-      case Op_StoreVector:\n-        opcode = Op_StoreVectorMasked;\n-        break;\n-      case Op_LoadVectorGather:\n-        opcode = Op_LoadVectorGatherMasked;\n-        break;\n-      case Op_StoreVectorScatter:\n-        opcode = Op_StoreVectorScatterMasked;\n-        break;\n-      default:\n-        break;\n-    }\n-    return op_sve_supported(opcode, vlen, bt);\n-  }\n-\n-  bool partial_op_sve_needed(Node* node, const TypeVect* vt) {\n-    switch(node->Opcode()) {\n-      case Op_VectorLoadMask:\n-      case Op_VectorMaskCmp:\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-      case Op_AddReductionVI:\n-      case Op_AddReductionVL:\n-      case Op_AddReductionVF:\n-      case Op_AddReductionVD:\n-      case Op_MinReductionV:\n-      case Op_MaxReductionV:\n-      case Op_AndReductionV:\n-      case Op_OrReductionV:\n-      case Op_XorReductionV:\n-      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n-      \/\/ input predicate is all-false, the result should be the vector length\n-      \/\/ instead of the vector register size.\n-      case Op_VectorMaskFirstTrue:\n-        return true;\n-      case Op_MaskAll:\n-        return !node->in(1)->is_Con();\n-      case Op_LoadVector:\n-      case Op_StoreVector:\n-        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n-        return vt->length_in_bytes() > 16;\n-      default:\n-        \/\/ For other ops whose vector size is smaller than the max vector size, a\n-        \/\/ full-sized unpredicated operation does not impact the final vector result.\n-        return false;\n-    }\n-  }\n-%}\n-\n-definitions %{\n-  int_def SVE_COST             (200, 200);\n-%}\n-\n-dnl\n-dnl ELEMENT_SHORT_CHART($1, $2)\n-dnl ELEMENT_SHORT_CHART(etype, node)\n-define(`ELEMENT_SHORT_CHAR',`ifelse(`$1', `T_SHORT',\n-  `($2->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-            ($2->bottom_type()->is_vect()->element_basic_type() == T_CHAR))',\n-   `($2->bottom_type()->is_vect()->element_basic_type() == $1)')')dnl\n-dnl\n-\n-\/\/ All SVE instructions\n-\n-\/\/ vector load\/store\n-\n-\/\/ Unpredicated vector load\/store\n-instruct loadV(vReg dst, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16);\n-  match(Set dst (LoadVector mem));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV(vReg src, vmemA mem) %{\n-  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16);\n-  match(Set mem (StoreVector mem src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    FloatRegister src_reg = as_FloatRegister($src$$reg);\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n-                          bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}dnl\n-\n-dnl\n-define(`VLoadStore', `\n-\/\/ ifelse(load, $3, Load, Store) Vector ($6 bits)\n-instruct $3V$4_vreg`'(vReg $7, vmem$4 mem)\n-%{\n-  predicate(UseSVE > 0 && `n->as_'ifelse(load, $3, Load, Store)Vector()->memory_size() == $4);\n-  match(Set ifelse(load, $3, dst (LoadVector mem), mem (StoreVector mem src)));\n-  ins_cost(4 * INSN_COST);\n-  format %{ \"$1   ifelse(load, $3, `$dst,$mem', `$mem,$src')\\t# vector ($6 bits)\" %}\n-  ins_encode( `aarch64_enc_'ifelse(load, $3, ldr, str)v$2($7, mem) );\n-  ins_pipe(v$3`_reg_mem'ifelse(eval($4 * 8), 128, 128, 64));\n-%}')dnl\n-dnl        $1    $2 $3     $4  $5 $6   $7\n-VLoadStore(ldrh, H, load,  2,  D, 16,  dst)\n-VLoadStore(strh, H, store, 2,  D, 16,  src)\n-VLoadStore(ldrs, S, load,  4,  D, 32,  dst)\n-VLoadStore(strs, S, store, 4,  D, 32,  src)\n-VLoadStore(ldrd, D, load,  8,  D, 64,  dst)\n-VLoadStore(strd, D, store, 8,  D, 64,  src)\n-VLoadStore(ldrq, Q, load, 16,  X, 128, dst)\n-VLoadStore(strq, Q, store, 16, X, 128, src)\n-\n-\/\/ vector load\/store - predicated\n-\n-instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (LoadVectorMasked mem pg));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_ldr $dst, $pg, $mem\\t# load vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($dst$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_str $mem, $pg, $src\\t# store vector predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($src$$reg),\n-                          as_PRegister($pg$$reg), bt, bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl MASK_LOGICAL_OP($1,        $2,      $3  )\n-dnl MASK_LOGICAL_OP(insn_name, op_name, insn)\n-define(`MASK_LOGICAL_OP', `\n-instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd ($2 pn pm));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3 $pd, $pn, $pm\\t# predicate (sve)\" %}\n-  ins_encode %{\n-    __ $3(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ mask logical and\/or\/xor\n-MASK_LOGICAL_OP(and, AndVMask, sve_and)\n-MASK_LOGICAL_OP(or, OrVMask, sve_orr)\n-MASK_LOGICAL_OP(xor, XorVMask, sve_eor)\n-\n-dnl\n-dnl MASK_LOGICAL_AND_NOT($1,   $2  )\n-dnl MASK_LOGICAL_AND_NOT(type, size)\n-define(`MASK_LOGICAL_AND_NOT', `\n-instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $pd, $pn, $pm\\t# predciate (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_bic(as_PRegister($pd$$reg), ptrue,\n-               as_PRegister($pn$$reg), as_PRegister($pm$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ mask logical and_not\n-MASK_LOGICAL_AND_NOT(I, B\/H\/S)\n-MASK_LOGICAL_AND_NOT(L, D)\n-\n-\/\/ vector reinterpret\n-\n-instruct reinterpret(vReg dst) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n-  match(Set dst (VectorReinterpret dst));\n-  ins_cost(0);\n-  format %{ \"# reinterpret $dst\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=\n-                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"reinterpretResize $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n-    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n-    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n-                                  length_in_bytes_src : length_in_bytes_dst;\n-    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n-           \"invalid vector length\");\n-    __ sve_gen_mask_imm(as_PRegister($pgtmp$$reg), T_BYTE, length_in_bytes_resize);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector mask reinterpret\n-\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorReinterpret dst_src));\n-  ins_cost(0);\n-  format %{ \"# vmask_reinterpret $dst_src\\t# do nothing\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->as_Vector()->length() != n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->as_Vector()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"# vmask_reinterpret $dst, $src\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_cpy(as_FloatRegister($tmp$$reg), from_size, as_PRegister($src$$reg), -1, false);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($dst$$reg), to_size, ptrue, as_FloatRegister($tmp$$reg), -1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl UNARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4  )\n-dnl UNARY_OP_TRUE_PREDICATE(insn_name, op_name, size, insn)\n-define(`UNARY_OP_TRUE_PREDICATE', `\n-instruct $1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst, $src\\t# vector (sve) ($3)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `vnegI', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ $4(as_FloatRegister($dst$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\n-\/\/ vector abs\n-UNARY_OP_TRUE_PREDICATE(vabsB, AbsVB, B, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsS, AbsVS, H, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsI, AbsVI, S, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsL, AbsVL, D, sve_abs)\n-UNARY_OP_TRUE_PREDICATE(vabsF, AbsVF, S, sve_fabs)\n-UNARY_OP_TRUE_PREDICATE(vabsD, AbsVD, D, sve_fabs)\n-\n-dnl UNARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n-dnl UNARY_OP_PREDICATE(insn_name, op_name, size, insn)\n-define(`UNARY_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst_src, $pg, $dst_src\\t# vector (sve) ($3)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `vnegI', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ $4(as_FloatRegister($dst_src$$reg), ifelse($1, `vnegI', `__ elemType_to_regVariant(bt)', `__ $3'),\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\/\/ vector abs - predicated\n-UNARY_OP_PREDICATE(vabsB, AbsVB, B, sve_abs)\n-UNARY_OP_PREDICATE(vabsS, AbsVS, H, sve_abs)\n-UNARY_OP_PREDICATE(vabsI, AbsVI, S, sve_abs)\n-UNARY_OP_PREDICATE(vabsL, AbsVL, D, sve_abs)\n-UNARY_OP_PREDICATE(vabsF, AbsVF, S, sve_fabs)\n-UNARY_OP_PREDICATE(vabsD, AbsVD, D, sve_fabs)\n-\n-dnl\n-dnl BINARY_OP_UNPREDICATE($1,        $2       $3,   $4           $5  )\n-dnl BINARY_OP_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`BINARY_OP_UNPREDICATE', `\n-instruct $1(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst, $src1, $src2\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl BINARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n-dnl BINARY_OP_PREDICATE(insn_name, op_name, size, insn)\n-define(`BINARY_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $4(as_FloatRegister($dst_src1$$reg), __ $3,\n-            as_PRegister($pg$$reg),\n-            as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector add\n-BINARY_OP_UNPREDICATE(vaddB, AddVB, B, 16, sve_add)\n-BINARY_OP_UNPREDICATE(vaddS, AddVS, H, 8,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddI, AddVI, S, 4,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddL, AddVL, D, 2,  sve_add)\n-BINARY_OP_UNPREDICATE(vaddF, AddVF, S, 4,  sve_fadd)\n-BINARY_OP_UNPREDICATE(vaddD, AddVD, D, 2,  sve_fadd)\n-\n-\/\/ vector add - predicated\n-BINARY_OP_PREDICATE(vaddB, AddVB, B, sve_add)\n-BINARY_OP_PREDICATE(vaddS, AddVS, H, sve_add)\n-BINARY_OP_PREDICATE(vaddI, AddVI, S, sve_add)\n-BINARY_OP_PREDICATE(vaddL, AddVL, D, sve_add)\n-BINARY_OP_PREDICATE(vaddF, AddVF, S, sve_fadd)\n-BINARY_OP_PREDICATE(vaddD, AddVD, D, sve_fadd)\n-dnl\n-dnl ADD_IMM($1,          $2,   $3      )\n-dnl ADD_IMM(name_suffix, size, imm_type)\n-define(`ADD_IMM', `\n-instruct vaddImm$1(vReg dst_src, $3 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    int32_t val = $con$$constant;\n-    if (val > 0){\n-      __ sve_add(as_FloatRegister($dst_src$$reg), __ $2, val);\n-    } else if (val < 0){\n-      __ sve_sub(as_FloatRegister($dst_src$$reg), __ $2, -val);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector add reg imm (unpredicated)\n-ADD_IMM(B, B, immBAddSubV)\n-ADD_IMM(S, H, immIAddSubV)\n-ADD_IMM(I, S, immIAddSubV)\n-ADD_IMM(L, D, immLAddSubV)\n-dnl\n-dnl BITWISE_OP_IMM($1,        $2        $3,   $4    $5      )\n-dnl BITWISE_OP_IMM(insn_name, op_name1, size, type, op_name2)\n-define(`BITWISE_OP_IMM', `\n-instruct $1(vReg dst_src, imm$4Log con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src (Replicate$4 con)));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst_src, $dst_src, $con\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst_src$$reg), __ $3,\n-         (uint64_t)($con$$constant));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector binary op reg imm (unpredicated)\n-BITWISE_OP_IMM(vandB, AndV, B, B, sve_and)\n-BITWISE_OP_IMM(vandH, AndV, H, S, sve_and)\n-BITWISE_OP_IMM(vandS, AndV, S, I, sve_and)\n-BITWISE_OP_IMM(vandD, AndV, D, L, sve_and)\n-BITWISE_OP_IMM(vorB,  OrV,  B, B, sve_orr)\n-BITWISE_OP_IMM(vorH,  OrV,  H, S, sve_orr)\n-BITWISE_OP_IMM(vorS,  OrV,  S, I, sve_orr)\n-BITWISE_OP_IMM(vorD,  OrV,  D, L, sve_orr)\n-BITWISE_OP_IMM(vxorB, XorV, B, B, sve_eor)\n-BITWISE_OP_IMM(vxorH, XorV, H, S, sve_eor)\n-BITWISE_OP_IMM(vxorS, XorV, S, I, sve_eor)\n-BITWISE_OP_IMM(vxorD, XorV, D, L, sve_eor)\n-dnl\n-dnl\n-dnl BINARY_OP_UNSIZED($1,        $2,      $3  )\n-dnl BINARY_OP_UNSIZED(insn_name, op_name, insn)\n-define(`BINARY_OP_UNSIZED', `\n-instruct $1(vReg dst, vReg src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3  $dst, $src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    __ $3(as_FloatRegister($dst$$reg),\n-         as_FloatRegister($src1$$reg),\n-         as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector and\n-BINARY_OP_UNSIZED(vand, AndV, sve_and)\n-\n-\/\/ vector or\n-BINARY_OP_UNSIZED(vor, OrV, sve_orr)\n-\n-\/\/ vector xor\n-BINARY_OP_UNSIZED(vxor, XorV, sve_eor)\n-\n-dnl BINARY_LOGIC_OP_PREDICATE($1,        $2,      $3  )\n-dnl BINARY_LOGIC_OP_PREDICATE(insn_name, op_name, insn)\n-define(`BINARY_LOGIC_OP_PREDICATE', `\n-instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$3 $dst_src1, $pg, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ $3(as_FloatRegister($dst_src1$$reg), size,\n-          as_PRegister($pg$$reg),\n-          as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector and - predicated\n-BINARY_LOGIC_OP_PREDICATE(vand, AndV, sve_and)\n-\n-\/\/ vector or - predicated\n-BINARY_LOGIC_OP_PREDICATE(vor, OrV, sve_orr)\n-\n-\/\/ vector xor - predicated\n-BINARY_LOGIC_OP_PREDICATE(vxor, XorV, sve_eor)\n-\n-\/\/ vector not\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (XorV src (ReplicateB m1)));\n-  match(Set dst (XorV src (ReplicateS m1)));\n-  match(Set dst (XorV src (ReplicateI m1)));',\n-`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n-dnl\n-define(`VECTOR_NOT', `\n-instruct vnot$1`'(vReg dst, vReg src, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst, $src\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    __ sve_not(as_FloatRegister($dst$$reg), __ D,\n-               ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl        $1,$2\n-VECTOR_NOT(I, B\/H\/S)\n-VECTOR_NOT(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector not - predicated\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n-  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));',\n-`match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));')')dnl\n-dnl\n-define(`VECTOR_NOT_PREDICATE', `\n-instruct vnot$1_masked`'(vReg dst_src, imm$1_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_not $dst_src, $pg, $dst_src\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_not(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                 $1, $2\n-VECTOR_NOT_PREDICATE(I, B\/H\/S)\n-VECTOR_NOT_PREDICATE(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector and_not\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n-  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n-`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT', `\n-instruct vand_not$1`'(vReg dst, vReg src1, vReg src2, imm$1_M1 m1) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst, $src1, $src2\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    __ sve_bic(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src1$$reg),\n-               as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl            $1,$2\n-VECTOR_AND_NOT(I, B\/H\/S)\n-VECTOR_AND_NOT(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-\/\/ vector and_not - predicated\n-dnl\n-define(`MATCH_RULE', `ifelse($1, I,\n-`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n-  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));',\n-`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));')')dnl\n-dnl\n-define(`VECTOR_AND_NOT_PREDICATE', `\n-instruct vand_not$1_masked`'(vReg dst_src1, vReg src2, imm$1_M1 m1, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  MATCH_RULE($1)\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_bic $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve) $2\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_bic(as_FloatRegister($dst_src1$$reg), __ elemType_to_regVariant(bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl                     $1, $2\n-VECTOR_AND_NOT_PREDICATE(I, B\/H\/S)\n-VECTOR_AND_NOT_PREDICATE(L, D)\n-undefine(MATCH_RULE)\n-dnl\n-dnl VDIVF($1,          $2  , $3         )\n-dnl VDIVF(name_suffix, size, min_vec_len)\n-define(`VDIVF', `\n-instruct vdiv$1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivV$1 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector float div\n-VDIVF(F, S, 4)\n-VDIVF(D, D, 2)\n-\n-\/\/ vector float div - predicated\n-BINARY_OP_PREDICATE(vfdivF, DivVF, S, sve_fdiv)\n-BINARY_OP_PREDICATE(vfdivD, DivVD, D, sve_fdiv)\n-\n-dnl\n-dnl VMINMAX($1     , $2, $3   , $4  )\n-dnl VMINMAX(op_name, op, finsn, insn)\n-define(`VMINMAX', `\n-instruct v$1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_$1 $dst_src1, $dst_src1, $src2\\t # vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ $3(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ $4(as_FloatRegister($dst_src1$$reg), size,\n-                  ptrue, as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector min\/max\n-VMINMAX(min, MinV, sve_fmin, sve_smin)\n-VMINMAX(max, MaxV, sve_fmax, sve_smax)\n-\n-dnl\n-dnl VMINMAX_PREDICATE($1     , $2, $3   , $4  )\n-dnl VMINMAX_PREDICATE(op_name, op, finsn, insn)\n-define(`VMINMAX_PREDICATE', `\n-instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_$1 $dst_src1, $pg, $dst_src1, $src2\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    if (is_floating_point_type(bt)) {\n-      __ $3(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    } else {\n-      assert(is_integral_type(bt), \"unsupported type\");\n-      __ $4(as_FloatRegister($dst_src1$$reg), size,\n-                  as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector min\/max - predicated\n-VMINMAX_PREDICATE(min, MinV, sve_fmin, sve_smin)\n-VMINMAX_PREDICATE(max, MaxV, sve_fmax, sve_smax)\n-\n-dnl\n-dnl VFMLA($1           $2  )\n-dnl VFMLA(name_suffix, size)\n-define(`VFMLA', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vfmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmla\n-VFMLA(F, S)\n-VFMLA(D, D)\n-\n-dnl\n-dnl VFMAD_PREDICATE($1           $2  )\n-dnl VFMAD_PREDICATE(name_suffix, size)\n-define(`VFMAD_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 * src2 + src3\n-instruct vfmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0);\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 src2) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmad $dst_src1, $pg, $src2, $src3\\t# vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmad(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmad - predicated\n-VFMAD_PREDICATE(F, S)\n-VFMAD_PREDICATE(D, D)\n-\n-dnl\n-dnl VFMLS1($1           $2  )\n-dnl VFMLS1(name_suffix, size)\n-define(`VFMLS1', `\n-\/\/ dst_src1 = dst_src1 + -src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmls`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary (NegV$1 src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VFMLS2($1           $2  )\n-dnl VFMLS2(name_suffix, size)\n-define(`VFMLS2', `\n-\/\/ dst_src1 = dst_src1 + src2 * -src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmls`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 (NegV$1 src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmls\n-VFMLS1(F, S)\n-VFMLS2(F, S)\n-VFMLS1(D, D)\n-VFMLS2(D, D)\n-\n-dnl\n-dnl VFMSB_PREDICATE($1           $2  )\n-dnl VFMSB_PREDICATE(name_suffix, size)\n-define(`VFMSB_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 * -src2 + src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary src3 pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fmsb - predicated\n-VFMSB_PREDICATE(F, S)\n-VFMSB_PREDICATE(D, D)\n-\n-dnl\n-dnl VFNMLA1($1           $2  )\n-dnl VFNMLA1(name_suffix, size)\n-define(`VFNMLA1', `\n-\/\/ dst_src1 = -dst_src1 + -src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmla`$1'1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary (NegV$1 src2) src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VFNMLA2($1           $2  )\n-dnl VFNMLA2(name_suffix, size)\n-define(`VFNMLA2', `\n-\/\/ dst_src1 = -dst_src1 + src2 * -src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmla`$1'2(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 (NegV$1 src3))));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmla\n-VFNMLA1(F, S)\n-VFNMLA2(F, S)\n-VFNMLA1(D, D)\n-VFNMLA2(D, D)\n-\n-dnl\n-dnl VFNMAD_PREDICATE($1           $2  )\n-dnl VFNMAD_PREDICATE(name_suffix, size)\n-define(`VFNMAD_PREDICATE', `\n-\/\/ dst_src1 = -src3 + dst_src1 * -src2\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmad$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 (NegV$1 src2)) (Binary (NegV$1 src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmad $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmad(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmad - predicated\n-VFNMAD_PREDICATE(F, S)\n-VFNMAD_PREDICATE(D, D)\n-\n-dnl\n-dnl VFNMLS($1           $2  )\n-dnl VFNMLS(name_suffix, size)\n-define(`VFNMLS', `\n-\/\/ dst_src1 = -dst_src1 + src2 * src3\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ $2,\n-         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmls\n-VFNMLS(F, S)\n-VFNMLS(D, D)\n-\n-dnl\n-dnl VFNMSB_PREDICATE($1           $2  )\n-dnl VFNMSB_PREDICATE(name_suffix, size)\n-define(`VFNMSB_PREDICATE', `\n-\/\/ dst_src1 = -src3 + dst_src1 * src2\n-\/\/ The NegV$1 must not be predicated.\n-instruct vfnmsb$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n-  predicate(UseFMA && UseSVE > 0 &&\n-            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n-  match(Set dst_src1 (FmaV$1 (Binary dst_src1 src2) (Binary (NegV$1 src3) pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fnmsb $dst_src1, $pg, $src2, $src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_fnmsb(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector fnmsb - predicated\n-VFNMSB_PREDICATE(F, S)\n-VFNMSB_PREDICATE(D, D)\n-\n-dnl\n-dnl VMLA($1           $2  )\n-dnl VMLA(name_suffix, size)\n-define(`VMLA', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmla$1(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddV$1 dst_src1 (MulV$1 src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mla\n-VMLA(B, B)\n-VMLA(S, H)\n-VMLA(I, S)\n-VMLA(L, D)\n-\n-dnl\n-dnl VMLA_PREDICATE($1           $2  )\n-dnl VMLA_PREDICATE(name_suffix, size)\n-define(`VMLA_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 + src2 * src3\n-instruct vmla$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mla $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mla - predicated\n-VMLA_PREDICATE(B, B)\n-VMLA_PREDICATE(S, H)\n-VMLA_PREDICATE(I, S)\n-VMLA_PREDICATE(L, D)\n-\n-dnl\n-dnl VMLS($1           $2  )\n-dnl VMLS(name_suffix, size)\n-define(`VMLS', `\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmls$1(vReg dst_src1, vReg src2, vReg src3)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubV$1 dst_src1 (MulV$1 src2 src3)));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2,\n-      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mls\n-VMLS(B, B)\n-VMLS(S, H)\n-VMLS(I, S)\n-VMLS(L, D)\n-\n-dnl\n-dnl VMLS_PREDICATE($1           $2  )\n-dnl VMLS_PREDICATE(name_suffix, size)\n-define(`VMLS_PREDICATE', `\n-\/\/ dst_src1 = dst_src1 - src2 * src3\n-instruct vmls$1_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubV$1 (Binary dst_src1 (MulV$1 src2 src3)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_mls $dst_src1, $pg, src2, src3\\t # vector (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2, as_PRegister($pg$$reg),\n-         as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mls - predicated\n-VMLS_PREDICATE(B, B)\n-VMLS_PREDICATE(S, H)\n-VMLS_PREDICATE(I, S)\n-VMLS_PREDICATE(L, D)\n-\n-dnl\n-dnl BINARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl BINARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`BINARY_OP_TRUE_PREDICATE', `\n-instruct $1(vReg dst_src1, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 dst_src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst_src1$$reg), __ $3,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector mul\n-BINARY_OP_TRUE_PREDICATE(vmulB, MulVB, B, 16, sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulS, MulVS, H, 8,  sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulI, MulVI, S, 4,  sve_mul)\n-BINARY_OP_TRUE_PREDICATE(vmulL, MulVL, D, 2,  sve_mul)\n-BINARY_OP_UNPREDICATE(vmulF, MulVF, S, 4, sve_fmul)\n-BINARY_OP_UNPREDICATE(vmulD, MulVD, D, 2, sve_fmul)\n-\n-\/\/ vector mul - predicated\n-BINARY_OP_PREDICATE(vmulB, MulVB, B, sve_mul)\n-BINARY_OP_PREDICATE(vmulS, MulVS, H, sve_mul)\n-BINARY_OP_PREDICATE(vmulI, MulVI, S, sve_mul)\n-BINARY_OP_PREDICATE(vmulL, MulVL, D, sve_mul)\n-BINARY_OP_PREDICATE(vmulF, MulVF, S, sve_fmul)\n-BINARY_OP_PREDICATE(vmulD, MulVD, D, sve_fmul)\n-\n-\/\/ vector neg\n-UNARY_OP_TRUE_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n-UNARY_OP_TRUE_PREDICATE(vnegL, NegVL, D, sve_neg)\n-UNARY_OP_TRUE_PREDICATE(vnegF, NegVF, S, sve_fneg)\n-UNARY_OP_TRUE_PREDICATE(vnegD, NegVD, D, sve_fneg)\n-\n-\/\/ vector neg - predicated\n-UNARY_OP_PREDICATE(vnegI, NegVI, B\/H\/S, sve_neg)\n-UNARY_OP_PREDICATE(vnegL, NegVL, D, sve_neg)\n-UNARY_OP_PREDICATE(vnegF, NegVF, S, sve_fneg)\n-UNARY_OP_PREDICATE(vnegD, NegVD, D, sve_fneg)\n-\n-dnl\n-dnl VPOPCOUNT($1,          $2  )\n-dnl VPOPCOUNT(name_suffix, size)\n-define(`VPOPCOUNT', `\n-instruct vpopcount$1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector()`'ifelse($1, `L', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst (PopCountV$1 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) ($2)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ sve_cnt(as_FloatRegister($dst$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector popcount\n-VPOPCOUNT(I, B\/H\/S)\n-VPOPCOUNT(L, D)\n-\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cnt $dst, $src\\n\\t\"\n-            \"sve_dup $vtmp, #0\\n\\t\"\n-            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src$$reg));\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl VPOPCOUNT_PREDICATE($1,          $2  )\n-dnl VPOPCOUNT_PREDICATE(name_suffix, size)\n-define(`VPOPCOUNT_PREDICATE', `\n-instruct vpopcount$1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0`'ifelse($1, `L', ` &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n-  match(Set dst_src (PopCountV$1 dst_src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) ($2)\" %}\n-  ins_encode %{dnl\n-ifelse($1, `I', `\n-    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n-    __ sve_cnt(as_FloatRegister($dst_src$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n-         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\/\/ vector popcount - predicated\n-VPOPCOUNT_PREDICATE(I, B\/H\/S)\n-VPOPCOUNT_PREDICATE(L, D)\n-\n-\/\/ vector blend\n-\n-instruct vblend(vReg dst, vReg src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorBlend (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sel $dst, $pg, $src2, $src1\\t# vector blend (sve)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size =\n-               __ elemType_to_regVariant(Matcher::vector_element_basic_type(this));\n-    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector store mask\n-\n-instruct vstoremaskB(vReg dst, pRegGov src, immI_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  ins_cost(SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, as_PRegister($src$$reg), 1, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               ptrue, as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n-                                      vReg vtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);\n-  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n-  effect(TEMP vtmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_ld1b $vtmp, $pg2, $mem\\n\\t\"\n-            \"sve_cmpne $dst, $pg2, $vtmp, 0\\t# load vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Load valid mask values which are boolean type, and extend them to the\n-    \/\/ defined vector element type. Convert the vector to predicate.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n-    \/\/ for the vector load with boolean type. But the predicate used in\n-    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n-    \/\/ which is the \"pg2\" used in VectorLoadMask.\n-    BasicType to_vect_bt = Matcher::vector_element_basic_type(this);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($pg2$$reg), T_BOOLEAN, to_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ elemType_to_regVariant(to_vect_bt),\n-               as_PRegister($pg2$$reg), as_FloatRegister($vtmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeV_vstoremask(indirect mem, pRegGov src, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, vReg vtmp,\n-                                  immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp, immI_gt_1 esize) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_st1b $vtmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n-    \/\/ for the vector store with boolean type. But the predicate used in\n-    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n-    \/\/ is the full-sized predicate (ptrue) here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, \"unsupported type.\");\n-    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is lower than the MaxVectorSize.\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, vReg vtmp,\n-                                        immI_gt_1 esize, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n-  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n-  effect(TEMP vtmp, TEMP ptmp, KILL cr);\n-  format %{ \"sve_cpy $vtmp, $src, 1\\n\\t\"\n-            \"sve_ptrue $ptmp, vector_length\\n\\t\"\n-            \"sve_st1b $vtmp, $ptmp, $mem\\t# store vector mask (sve) (H\/S\/D)\" %}\n-  ins_cost(3 * SVE_COST);\n-  ins_encode %{\n-    \/\/ Convert the valid src predicate to vector, and store the vector elements\n-    \/\/ as boolean values.\n-    \/\/\n-    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n-    \/\/ vector store with boolean type. But the predicate used in the narrowing\n-    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n-    \/\/ here.\n-    BasicType from_vect_bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(from_vect_bt);\n-    __ sve_cpy(as_FloatRegister($vtmp$$reg), size, as_PRegister($src$$reg), 1, false);\n-    __ sve_gen_mask_imm(as_PRegister($ptmp$$reg), from_vect_bt, Matcher::vector_length(this, $src));\n-    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, as_FloatRegister($vtmp$$reg),\n-                          as_PRegister($ptmp$$reg), T_BOOLEAN, from_vect_bt, $mem->opcode(),\n-                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl REDUCE_I($1,        $2     )\n-dnl REDUCE_I(insn_name, op_name)\n-define(`REDUCE_I', `\n-instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  ifelse($2, AddReductionVI,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);')\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# $1I reduction (sve) (may extend)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_L($1,        $2    )\n-dnl REDUCE_L(insn_name, op_name)\n-define(`REDUCE_L', `\n-instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  ifelse($2, AddReductionVL,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);')\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# $1L reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF', `\n-instruct reduce_$1($3 src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst ($2 src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-dnl REDUCE_I_PREDICATE($1,        $2     )\n-dnl REDUCE_I_PREDICATE(insn_name, op_name)\n-define(`REDUCE_I_PREDICATE', `\n-instruct reduce_$1I_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  ifelse($2, AddReductionVI,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated (sve) (may extend)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_L_PREDICATE($1,        $2    )\n-dnl REDUCE_L_PREDICATE(insn_name, op_name)\n-define(`REDUCE_L_PREDICATE', `\n-instruct reduce_$1L_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, pRegGov pg) %{\n-  ifelse($2, AddReductionVL,\n-       `predicate(UseSVE > 0);',\n-       `predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);')\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_ADDF_PREDICATE($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF_PREDICATE(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF_PREDICATE', `\n-instruct reduce_$1_masked($3 src1_dst, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set src1_dst ($2 (Binary src1_dst src2) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1 $src1_dst, $pg, $src2\\t# $1 reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-                 as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-\/\/ vector add reduction\n-REDUCE_I(add, AddReductionVI)\n-REDUCE_L(add, AddReductionVL)\n-REDUCE_ADDF(addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF(addD, AddReductionVD, vRegD, D)\n-\n-\/\/ vector add reduction - predicated\n-REDUCE_I_PREDICATE(add, AddReductionVI)\n-REDUCE_L_PREDICATE(add, AddReductionVL)\n-REDUCE_ADDF_PREDICATE(addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF_PREDICATE(addD, AddReductionVD, vRegD, D)\n-\n-\/\/ vector and reduction\n-REDUCE_I(and, AndReductionV)\n-REDUCE_L(and, AndReductionV)\n-\n-\/\/ vector and reduction - predicated\n-REDUCE_I_PREDICATE(and, AndReductionV)\n-REDUCE_L_PREDICATE(and, AndReductionV)\n-\n-\/\/ vector or reduction\n-REDUCE_I(or, OrReductionV)\n-REDUCE_L(or, OrReductionV)\n-\n-\/\/ vector or reduction - predicated\n-REDUCE_I_PREDICATE(or, OrReductionV)\n-REDUCE_L_PREDICATE(or, OrReductionV)\n-\n-\/\/ vector xor reduction\n-REDUCE_I(eor, XorReductionV)\n-REDUCE_L(eor, XorReductionV)\n-\n-\/\/ vector xor reduction - predicated\n-REDUCE_I_PREDICATE(eor, XorReductionV)\n-REDUCE_L_PREDICATE(eor, XorReductionV)\n-\n-dnl\n-dnl REDUCE_MAXMIN_I($1,        $2     )\n-dnl REDUCE_MAXMIN_I(insn_name, op_name)\n-define(`REDUCE_MAXMIN_I', `\n-instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# $1I reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_L($1,        $2     )\n-dnl REDUCE_MAXMIN_L(insn_name, op_name)\n-define(`REDUCE_MAXMIN_L', `\n-instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# $1L reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           ptrue, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_I_PREDICATE($1     , $2     )\n-dnl REDUCE_MAXMIN_I_PREDICATE(min_max, op_name)\n-define(`REDUCE_MAXMIN_I_PREDICATE', `\n-instruct reduce_$1I_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp,\n-                           pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n-            is_integral_type(n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type()));\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1I $dst, $src1, $pg, $src2\\t# $1I reduction predicated (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src2);\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_MAXMIN_L_PREDICATE($1     , $2     )\n-dnl REDUCE_MAXMIN_L_PREDICATE(min_max, op_name)\n-define(`REDUCE_MAXMIN_L_PREDICATE', `\n-instruct reduce_$1L_masked(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp,\n-                          pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst ($2 (Binary src1 src2) pg));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_reduce_$1L $dst, $src1, $pg, $src2\\t# $1L reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n-                           $src1$$Register, as_FloatRegister($src2$$reg),\n-                           as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX', `\n-instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3);\n-  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_$1$2 $dst, $src1, $src2\\t# $1$2 reduction (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src2) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_FMINMAX_PREDICATE($1,      $2,          $3,           $4,   $5         )\n-dnl REDUCE_FMINMAX_PREDICATE(min_max, name_suffix, element_type, size, reg_src_dst)\n-define(`REDUCE_FMINMAX_PREDICATE', `\n-instruct reduce_$1$2_masked($5 dst, $5 src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(2)->bottom_type()->is_vect()->element_basic_type() == $3);\n-  match(Set dst (translit($1, `m', `M')ReductionV (Binary src1 src2) pg));\n-  ins_cost(SVE_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_reduce_$1$2 $dst, $src1, $pg, $src2\\t# $1$2 reduction predicated (sve)\" %}\n-  ins_encode %{\n-    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4, as_PRegister($pg$$reg), as_FloatRegister($src2$$reg));\n-    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ vector max reduction\n-REDUCE_MAXMIN_I(max, MaxReductionV)\n-REDUCE_MAXMIN_L(max, MaxReductionV)\n-REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector max reduction - predicated\n-REDUCE_MAXMIN_I_PREDICATE(max, MaxReductionV)\n-REDUCE_MAXMIN_L_PREDICATE(max, MaxReductionV)\n-REDUCE_FMINMAX_PREDICATE(max, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE(max, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector min reduction\n-REDUCE_MAXMIN_I(min, MinReductionV)\n-REDUCE_MAXMIN_L(min, MinReductionV)\n-REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector min reduction - predicated\n-REDUCE_MAXMIN_I_PREDICATE(min, MinReductionV)\n-REDUCE_MAXMIN_L_PREDICATE(min, MinReductionV)\n-REDUCE_FMINMAX_PREDICATE(min, F, T_FLOAT,  S, vRegF)\n-REDUCE_FMINMAX_PREDICATE(min, D, T_DOUBLE, D, vRegD)\n-\n-\/\/ vector Math.rint, floor, ceil\n-\n-instruct vroundD(vReg dst, vReg src, immI rmode) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (RoundDoubleModeV src rmode));\n-  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    switch ($rmode$$constant) {\n-      case RoundDoubleModeNode::rmode_rint:\n-        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_floor:\n-        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-      case RoundDoubleModeNode::rmode_ceil:\n-        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n-             ptrue, as_FloatRegister($src$$reg));\n-        break;\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-define(`VECTOR_JAVA_FROUND', `\n-instruct vround$1to$3($7 dst, $7 src, $7 tmp1, $7 tmp2, $7 tmp3, pRegGov ptmp)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (RoundV$1 src));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp);\n-  format %{ \"sve_vround  $dst, $4, $src\\t# round $1 to $3 vector\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    int vlen = Matcher::vector_length_in_bytes(this);\n-    if (vlen > 16) {\n-      __ vector_round_sve(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                          as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                          as_PRegister($ptmp$$reg), __ $4);\n-    } else {\n-      __ vector_round_neon(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                           as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg),\n-                           as_FloatRegister($tmp3$$reg),\n-                           __ esize2arrangement(type2aelembytes(bt),\n-                              \/*isQ*\/ vlen == 16));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl           $1  $2  $3 $4 $5    $6    $7\n-VECTOR_JAVA_FROUND(F, 8F,  I, S, 8,  INT, vReg)\n-VECTOR_JAVA_FROUND(D, 4D,  L, D, 4, LONG, vReg)\n-dnl\n-dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n-dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n-define(`REPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n-dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n-define(`REPLICATE_IMM8', `\n-instruct $1(vReg dst, $3 con) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 con));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl FREPLICATE($1,        $2,      $3,        $4)\n-dnl FREPLICATE(insn_name, op_name, reg_src, size)\n-define(`FREPLICATE', `\n-instruct $1(vReg dst, $3 src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector replicate\n-REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n-REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n-REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n-REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n-REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n-REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n-REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n-REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n-FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n-FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n-dnl\n-dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n-define(`VSHIFT_TRUE_PREDICATE', `\n-instruct $1(vReg dst, vReg shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 dst shift));\n-  ins_cost(SVE_COST);\n-  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n-  ins_encode %{\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n-         ptrue, as_FloatRegister($shift$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VSHIFT_IMM_UNPREDICATED($1,        $2,      $3,       $4,   $5,          $6  )\n-dnl VSHIFT_IMM_UNPREDICATED(insn_name, op_name, op_name2, size, min_vec_len, insn)\n-define(`VSHIFT_IMM_UNPREDICATED', `\n-instruct $1(vReg dst, vReg src, immI shift) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst ($2 src ($3 shift)));\n-  ins_cost(SVE_COST);\n-  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;dnl\n-ifelse(eval(index(`$1', `vasr') == 0 || index(`$1', `vlsr') == 0), 1, `\n-    if (con == 0) {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')dnl\n-ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n-    if (con >= 8) con = 7;')ifelse(eval(index(`$4', `H') == 0), 1, `\n-    if (con >= 16) con = 15;')')dnl\n-ifelse(eval(index(`$1', `vlsl') == 0  || index(`$1', `vlsr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n-    if (con >= 8) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')ifelse(eval(index(`$4', `H') == 0), 1, `\n-    if (con >= 16) {\n-      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-           as_FloatRegister($src$$reg));\n-      return;\n-    }')')\n-    __ $6(as_FloatRegister($dst$$reg), __ $4,\n-         as_FloatRegister($src$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl VSHIFT_COUNT($1,        $2,   $3,          $4  )\n-dnl VSHIFT_COUNT(insn_name, size, min_vec_len, type)\n-define(`VSHIFT_COUNT', `\n-instruct $1(vReg dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE > 0 &&\n-            ELEMENT_SHORT_CHAR($4, n));\n-  match(Set dst (LShiftCntV cnt));\n-  match(Set dst (RShiftCntV cnt));\n-  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) ($2)\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $2, as_Register($cnt$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-\/\/ vector shift\n-VSHIFT_TRUE_PREDICATE(vasrB, RShiftVB,  B, 16, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrS, RShiftVS,  H,  8, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrI, RShiftVI,  S,  4, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vasrL, RShiftVL,  D,  2, sve_asr)\n-VSHIFT_TRUE_PREDICATE(vlslB, LShiftVB,  B, 16, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslS, LShiftVS,  H,  8, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslI, LShiftVI,  S,  4, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlslL, LShiftVL,  D,  2, sve_lsl)\n-VSHIFT_TRUE_PREDICATE(vlsrB, URShiftVB, B, 16, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrS, URShiftVS, H,  8, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrI, URShiftVI, S,  4, sve_lsr)\n-VSHIFT_TRUE_PREDICATE(vlsrL, URShiftVL, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vasrB_imm, RShiftVB,  RShiftCntV, B, 16, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrS_imm, RShiftVS,  RShiftCntV, H,  8, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrI_imm, RShiftVI,  RShiftCntV, S,  4, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vasrL_imm, RShiftVL,  RShiftCntV, D,  2, sve_asr)\n-VSHIFT_IMM_UNPREDICATED(vlsrB_imm, URShiftVB, RShiftCntV, B, 16, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrS_imm, URShiftVS, RShiftCntV, H,  8, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrI_imm, URShiftVI, RShiftCntV, S,  4, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlsrL_imm, URShiftVL, RShiftCntV, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATED(vlslB_imm, LShiftVB,  LShiftCntV, B, 16, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslS_imm, LShiftVS,  LShiftCntV, H,  8, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslI_imm, LShiftVI,  LShiftCntV, S,  4, sve_lsl)\n-VSHIFT_IMM_UNPREDICATED(vlslL_imm, LShiftVL,  LShiftCntV, D,  2, sve_lsl)\n-VSHIFT_COUNT(vshiftcntB, B, 16, T_BYTE)\n-VSHIFT_COUNT(vshiftcntS, H,  8, T_SHORT)\n-VSHIFT_COUNT(vshiftcntI, S,  4, T_INT)\n-VSHIFT_COUNT(vshiftcntL, D,  2, T_LONG)\n-\n-\/\/ vector shift - predicated\n-BINARY_OP_PREDICATE(vasrB, RShiftVB,  B, sve_asr)\n-BINARY_OP_PREDICATE(vasrS, RShiftVS,  H, sve_asr)\n-BINARY_OP_PREDICATE(vasrI, RShiftVI,  S, sve_asr)\n-BINARY_OP_PREDICATE(vasrL, RShiftVL,  D, sve_asr)\n-BINARY_OP_PREDICATE(vlslB, LShiftVB,  B, sve_lsl)\n-BINARY_OP_PREDICATE(vlslS, LShiftVS,  H, sve_lsl)\n-BINARY_OP_PREDICATE(vlslI, LShiftVI,  S, sve_lsl)\n-BINARY_OP_PREDICATE(vlslL, LShiftVL,  D, sve_lsl)\n-BINARY_OP_PREDICATE(vlsrB, URShiftVB, B, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrS, URShiftVS, H, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrI, URShiftVI, S, sve_lsr)\n-BINARY_OP_PREDICATE(vlsrL, URShiftVL, D, sve_lsr)\n-dnl\n-dnl VSHIFT_IMM_PREDICATED($1,        $2,      $3,       $4,   $5,   $6  )\n-dnl VSHIFT_IMM_PREDICATED(insn_name, op_name, op_name2, type, size, insn)\n-define(`VSHIFT_IMM_PREDICATED', `\n-instruct $1_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 (Binary dst_src ($3 shift)) pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"$6 $dst_src, $pg, $dst_src, $shift\\t# vector (sve) ($4)\" %}\n-  ins_encode %{\n-    int con = (int)$shift$$constant;\n-    assert(con ifelse(index(`$1', `vlsl'), 0, `>=', `>') 0 && con < $5, \"invalid shift immediate\");\n-    __ $6(as_FloatRegister($dst_src$$reg), __ $4, as_PRegister($pg$$reg), con);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-VSHIFT_IMM_PREDICATED(vasrB, RShiftVB,  RShiftCntV, B, 8,  sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrS, RShiftVS,  RShiftCntV, H, 16, sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrI, RShiftVI,  RShiftCntV, S, 32, sve_asr)\n-VSHIFT_IMM_PREDICATED(vasrL, RShiftVL,  RShiftCntV, D, 64, sve_asr)\n-VSHIFT_IMM_PREDICATED(vlsrB, URShiftVB, RShiftCntV, B, 8,  sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrS, URShiftVS, RShiftCntV, H, 16, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrI, URShiftVI, RShiftCntV, S, 32, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlsrL, URShiftVL, RShiftCntV, D, 64, sve_lsr)\n-VSHIFT_IMM_PREDICATED(vlslB, LShiftVB,  LShiftCntV, B, 8,  sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslS, LShiftVS,  LShiftCntV, H, 16, sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslI, LShiftVI,  LShiftCntV, S, 32, sve_lsl)\n-VSHIFT_IMM_PREDICATED(vlslL, LShiftVL,  LShiftCntV, D, 64, sve_lsl)\n-\n-\/\/ vector sqrt\n-UNARY_OP_TRUE_PREDICATE(vsqrtF, SqrtVF, S, sve_fsqrt)\n-UNARY_OP_TRUE_PREDICATE(vsqrtD, SqrtVD, D, sve_fsqrt)\n-\n-\/\/ vector sqrt - predicated\n-UNARY_OP_PREDICATE(vsqrtF, SqrtVF, S, sve_fsqrt)\n-UNARY_OP_PREDICATE(vsqrtD, SqrtVD, D, sve_fsqrt)\n-\n-\/\/ vector sub\n-BINARY_OP_UNPREDICATE(vsubB, SubVB, B, 16, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubS, SubVS, H, 8, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubI, SubVI, S, 4, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubL, SubVL, D, 2, sve_sub)\n-BINARY_OP_UNPREDICATE(vsubF, SubVF, S, 4, sve_fsub)\n-BINARY_OP_UNPREDICATE(vsubD, SubVD, D, 2, sve_fsub)\n-\n-\/\/ vector sub - predicated\n-BINARY_OP_PREDICATE(vsubB, SubVB, B, sve_sub)\n-BINARY_OP_PREDICATE(vsubS, SubVS, H, sve_sub)\n-BINARY_OP_PREDICATE(vsubI, SubVI, S, sve_sub)\n-BINARY_OP_PREDICATE(vsubL, SubVL, D, sve_sub)\n-BINARY_OP_PREDICATE(vsubF, SubVF, S, sve_fsub)\n-BINARY_OP_PREDICATE(vsubD, SubVD, D, sve_fsub)\n-\n-\/\/ ------------------------------ Vector mask cast --------------------------\n-\n-instruct vmaskcast(pRegGov dst_src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n-            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n-  match(Set dst_src (VectorMaskCast dst_src));\n-  ins_cost(0);\n-  format %{ \"vmaskcast $dst_src\\t# empty (sve)\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct vmaskcast_extend(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcast_narrow(pRegGov dst, pReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n-             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n-  match(Set dst (VectorMaskCast src));\n-  ins_cost(SVE_COST * 3);\n-  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n-  ins_encode %{\n-    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n-                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-\n-\/\/ ------------------------------ Vector cast -------------------------------\n-dnl\n-dnl\n-define(`VECTOR_CAST_X2X', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_$5  $dst, $src\\t# convert $1 to $2 vector\" %}\n-  ins_encode %{\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-\n-dnl\n-dnl Start of vector cast rules\n-dnl\n-instruct vcvtBtoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastS2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoX_extend(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n-    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n-      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n-  ins_encode %{\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n-                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtItoF\n-VECTOR_CAST_X2X(I, F, scvtf, S, i2f)\n-\n-instruct vcvtItoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n-  ins_encode %{\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtLtoD\n-VECTOR_CAST_X2X(L, D, scvtf, D, l2d)\n-\n-instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(SVE_COST * 2);\n-  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n-  ins_encode %{\n-    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n-  ins_encode %{\n-    BasicType to_bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-dnl vcvtDtoL\n-VECTOR_CAST_X2X(D, L, fcvtzs, D, d2l)\n-\n-instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n-  ins_encode %{\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n-                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl\n-\/\/ ------------------------------ Vector extract ---------------------------------\n-dnl\n-define(`VECTOR_EXTRACT_I', `\n-instruct extract$1`'($3 dst, vReg src, immI idx, vReg vtmp)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= $2);\n-  match(Set dst (Extract$1 src idx));\n-  effect(TEMP vtmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_integral $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n-  ins_encode %{\n-    __ sve_extract_integral(as_Register($dst$$reg), __ $4, as_FloatRegister($src$$reg),\n-                            (int)($idx$$constant), \/* is_signed *\/ ifelse($1, L, false, true), as_FloatRegister($vtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl              $1 $2  $3         $4\n-VECTOR_EXTRACT_I(B, 16, iRegINoSp, B)\n-VECTOR_EXTRACT_I(S, 8,  iRegINoSp, H)\n-VECTOR_EXTRACT_I(I, 4,  iRegINoSp, S)\n-VECTOR_EXTRACT_I(L, 2,  iRegLNoSp, D)\n-dnl\n-define(`VECTOR_EXTRACT_I_LT', `\n-instruct extract$1_LT$2`'($3 dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < $2);\n-  match(Set dst (Extract$1 src idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"ifelse($4, D, umov, smov) $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n-  ins_encode %{\n-    __ ifelse($4, D, umov, smov)(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ $4, $idx$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl                 $1  $2  $3         $4\n-VECTOR_EXTRACT_I_LT(B,  16, iRegINoSp, B)\n-VECTOR_EXTRACT_I_LT(S,  8,  iRegINoSp, H)\n-VECTOR_EXTRACT_I_LT(I,  4,  iRegINoSp, S)\n-VECTOR_EXTRACT_I_LT(L,  2,  iRegLNoSp, D)\n-\n-instruct extractF(vRegF dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractF src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant < 4) {\n-      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct extractD(vRegD dst, vReg src, immI idx)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (ExtractD src idx));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n-      \/* empty *\/\n-    } else if ($idx$$constant == 0) {\n-      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n-    } else if ($idx$$constant == 1) {\n-      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n-    } else {\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------- VectorTest ----------------------------------\n-\n-instruct vtest_alltrue(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eors $ptmp, $src1, $src2\\t# $src2 is all true mask\\n\"\n-            \"csetw $dst, EQ\\t# VectorTest (sve) - alltrue\" %}\n-  ins_encode %{\n-    __ sve_eors(as_PRegister($ptmp$$reg), ptrue,\n-                as_PRegister($src1$$reg), as_PRegister($src2$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::EQ);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vtest_anytrue(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptest $src1\\n\\t\"\n-            \"csetw $dst, NE\\t# VectorTest (sve) - anytrue\" %}\n-  ins_encode %{\n-    \/\/ \"src2\" is not used for sve.\n-    __ sve_ptest(ptrue, as_PRegister($src1$$reg));\n-    __ csetw(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-dnl\n-\/\/ ------------------------------ Vector insert ---------------------------------\n-\n-instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n-  predicate(UseSVE > 0 &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n-           $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ block_comment(\"insert into vector (B\/H\/S) {\");\n-      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n-      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (B\/H\/S)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (L) {\");\n-      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), $val$$Register);\n-    __ block_comment(\"} insert into vector (L)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n-            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n-            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n-            \"sve_dup $dst, S, $idx\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (F) {\");\n-      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (F)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n-  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(2 * INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n-  ins_encode %{\n-    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($val$$reg), $idx$$constant, 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            Matcher::vector_length_in_bytes(n) > 16 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n-  ins_encode %{\n-    __ block_comment(\"insert into vector (D) {\");\n-      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n-    __ block_comment(\"} insert into vector (D)\");\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n-                   as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n-                           as_FloatRegister($src$$reg), __ B);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector rearrange -------------------------------\n-\n-instruct rearrange(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather ---------------------------------\n-\n-instruct gatherI(vReg dst, indirect mem, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGather mem idx));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t# vector load gather (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n-                       as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Gather Predicated -------------------------------\n-\n-instruct gatherI_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  ins_cost(SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (S)\" %}\n-  ins_encode %{\n-    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct gatherL_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"load_vector_gather $dst, $pg, $mem, $idx\\t# vector load gather predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pg$$reg),\n-                       as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter -------------------------------\n-\n-instruct scatterI(indirect mem, vReg src, vReg idx) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (S)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL(indirect mem, vReg src, vReg idx, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t# vector store scatter (D)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue,\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Store Scatter Predicated -------------------------------\n-\n-instruct scatterI_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  ins_cost(SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicate (S)\" %}\n-  ins_encode %{\n-    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($idx$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct scatterL_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n-  predicate(UseSVE > 0 &&\n-            (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n-  effect(TEMP tmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"store_vector_scatter $mem, $pg, $idx, $src\\t# vector store scatter predicated (D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($idx$$reg));\n-    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                        as_Register($mem$$base), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ------------------------------ Vector Load Const -------------------------------\n-\n-instruct loadconB(vReg dst, immI0 src) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadConst src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, 0, 1\\t# generate iota indices\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($dst$$reg), __ B, 0, 1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ -------------------------- Populate Index to a Vector --------------------------\n-\n-instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopulateIndex src1 src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_index $dst, $src1, $src2\\t # populate index (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_index(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n-                 as_Register($src1$$reg), $src2$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ----------------------------- String Intrinsics -------------------------------\n-\n-\/\/ Intrisics for String.indexOf(char)\n-\n-dnl\n-define(`STRING_INDEXOF_CHAR', `\n-instruct string$1_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n-                                  iRegI_R0 result, vReg ztmp1, vReg ztmp2,\n-                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr)\n-%{\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  predicate((UseSVE > 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n-\n-  format %{ \"String$2 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n-\n-  ins_encode %{\n-    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                               as_FloatRegister($ztmp1$$reg), as_FloatRegister($ztmp2$$reg),\n-                               as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg), $3 \/* isL *\/);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl                 $1 $2      $3\n-STRING_INDEXOF_CHAR(L, Latin1, true)\n-STRING_INDEXOF_CHAR(U, UTF16,  false)\n-\n-\/\/ Intrisics for String.compareTo()\n-\n-\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n-\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n-\/\/ string_compare can be shared with all variants.\n-\n-dnl\n-define(`STRING_COMPARETO', `\n-instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n-                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n-                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n-                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n-%{\n-  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n-         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n-  ins_encode %{\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$Register, $tmp2$$Register,\n-                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n-                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n-                      StrIntrinsicNode::$1);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}')dnl\n-dnl              $1\n-STRING_COMPARETO(LL)\n-STRING_COMPARETO(LU)\n-STRING_COMPARETO(UL)\n-STRING_COMPARETO(UU)\n-\n-\/\/ ---------------------------- Vector mask reductions ---------------------------\n-instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskTrueCount src));\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Return the index of the first mask lane that is set, or vector length if none of\n-\/\/ them are set.\n-instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this, $src) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskFirstTrue src pg));\n-  effect(TEMP ptmp);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $pg, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pg$$reg), as_PRegister($src$$reg), false);\n-    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskLastTrue src));\n-  effect(TEMP ptmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskToLong src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n-  ins_encode %{\n-    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg vtmp1, vReg vtmp2) %{\n-  match(Set dst (VectorLongToMask src));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  ins_cost(10 * SVE_COST);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector mask fromlong (sve2)\" %}\n-  ins_encode %{\n-    __ sve_vmask_fromlong(as_PRegister($dst$$reg), as_Register($src$$reg),\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ---------------------------- Vector mask generation ---------------------------\n-\/\/ The rules below set predicate registers. They can guarantee the high bits of dst\n-\/\/ are cleared with zero when the vector length is less than the full size of\n-\/\/ hardware vector register width.\n-\n-define(`MASKALL_IMM', `\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    ifelse($1, `I', int, long) con = (ifelse($1, `I', int, long))$src$$constant;\n-    if (con == 0) {\n-      __ sve_pfalse(as_PRegister($dst$$reg));\n-    } else {\n-      assert(con == -1, \"invalid constant value for mask\");\n-      BasicType bt = Matcher::vector_element_basic_type(this);\n-      __ sve_gen_mask_imm(as_PRegister($dst$$reg), bt, Matcher::vector_length(this));\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl\n-define(`MASKALL', `\n-instruct vmaskAll$1(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector());\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl\n-define(`MASKALL_PREDICATE', `\n-instruct vmaskAll$1_masked(pRegGov dst, ifelse($1, `I', iRegIorL2I, iRegL) src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (MaskAll src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_dup $tmp, $src\\n\\t\"\n-            \"sve_cmpne $dst, $pg, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), size, as_Register($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\n-\/\/ maskAll\n-MASKALL_IMM(I, B\/H\/S)\n-MASKALL(I, B\/H\/S)\n-MASKALL_IMM(L, D)\n-MASKALL(L, D)\n-\n-\/\/ maskAll - predicated\n-MASKALL_PREDICATE(I, B\/H\/S)\n-MASKALL_PREDICATE(L, D)\n-\n-\/\/ vector mask compare\n-\n-instruct vmaskcmp(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    assert(Matcher::vector_length_in_bytes(this) == MaxVectorSize, \"invalid vector length\");\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_cmp $dst, $pg, $src1, $src2\\t# vector mask cmp (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_compare(as_PRegister($dst$$reg), bt, as_PRegister($pg$$reg), as_FloatRegister($src1$$reg),\n-                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ vector load mask\n-\n-instruct vloadmaskB(pRegGov dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               ptrue, as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n-            n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vloadmaskB $dst, $pg, $src\\t# vector load mask (sve) (B)\" %}\n-  ins_encode %{\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ B,\n-               as_PRegister($pg$$reg), as_FloatRegister($src$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n-  match(Set dst (VectorLoadMask src pg));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vloadmask $dst, $pg, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n-               as_PRegister($pg$$reg), as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl VMASK_GEN($1,        $2,       $3,        $4  )\n-dnl VMASK_GEN(insn_name, src_type, src_match, insn)\n-define(`VMASK_GEN', `\n-instruct $1(pRegGov pd, $2 src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen $3));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"$4 $pd, zr, $src\\t# vector mask gen (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ $4(as_PRegister($pd$$reg), size, zr, as_Register($src$$reg));\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}')dnl\n-dnl\n-\/\/ vector mask gen\n-VMASK_GEN(vmask_gen_I, iRegIorL2I, (ConvI2L src), sve_whilelow)\n-VMASK_GEN(vmask_gen_L, iRegL, src, sve_whilelo)\n-\n-instruct vmask_gen_imm(pRegGov pd, immL src, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set pd (VectorMaskGen src));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vmask_gen_imm $pd, $src\\t# vector mask gen with imm (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ sve_gen_mask_imm(as_PRegister($pd$$reg), bt, (uint) $src$$constant);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n-\n-instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (CompressM pg));\n-  effect(KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n-            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n-    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (CompressV src pg));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n-                    pReg ptmp, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(13 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n-  ins_encode %{\n-    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n-                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n-                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n-  match(Set dst (CompressV src pg));\n-  ins_cost(38 * SVE_COST);\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n-  ins_encode %{\n-    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n-                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n-  match(Set dst (ExpandV src pg));\n-  effect(TEMP_DEF dst);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n-            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n-            \"sve_sub $dst, S\/D, 1\\n\\t\"\n-            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n-  ins_encode %{\n-    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n-    \/\/                  pg    = 1 0 0 1 1 0 1 1\n-    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n-\n-    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n-    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n-    \/\/ for TBL whose value is used to select the indexed element from src vector.\n-\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    \/\/ dst = 0 0 0 0 0 0 0 0\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n-    \/\/ dst = 5 0 0 4 3 0 2 1\n-    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n-                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n-    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n-    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n-    \/\/ dst = 4 0 0 5 6 0 7 8\n-    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n-               as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-dnl\n-dnl BITWISE_UNARY($1,        $2,      $3  )\n-dnl BITWISE_UNARY(insn_name, op_name, insn)\n-define(`BITWISE_UNARY', `\n-instruct $1(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 &&\n-            !n->as_Vector()->is_predicated_vector());\n-  match(Set dst ($2 src));\n-  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n-  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst, $src\\n\\t\"\n-            \"$3  $dst, $dst', `\"$3 $dst, $src')\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n-ifelse($2, `CountTrailingZerosV', `\n-    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));', `')dnl\n-ifelse($2, `ReverseBytesV', `\n-    if (bt == T_BYTE) {\n-      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-      }\n-    } else {\n-      __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n-    }', `\n-    __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($ifelse($2, `CountTrailingZerosV', dst, src)$$reg));')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl BITWISE_UNARY_PREDICATE($1,        $2,      $3  )\n-dnl BITWISE_UNARY_PREDICATE(insn_name, op_name, insn)\n-define(`BITWISE_UNARY_PREDICATE', `\n-\/\/ The dst and src should use the same register to make sure the\n-\/\/ inactive lanes in dst save the same elements as src.\n-instruct $1_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src ($2 dst_src pg));\n-  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n-  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n-            \"$3  $dst_src, $pg, $dst_src', `\"$3 $dst_src, $pg, $dst_src')\\t# vector (sve)\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n-ifelse($2, `CountTrailingZerosV', `\n-    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));', `')dnl\n-ifelse($2, `ReverseBytesV', `\n-    if (bt == T_BYTE) {\n-      \/\/ do nothing\n-    } else {\n-      __ $3(as_FloatRegister($dst_src$$reg), size,\n-          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n-    }', `\n-    __ $3(as_FloatRegister($dst_src$$reg), size,\n-        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));')\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n-BITWISE_UNARY(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n-BITWISE_UNARY_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n-\n-\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n-BITWISE_UNARY(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n-BITWISE_UNARY_PREDICATE(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n-\n-\/\/ ---------------------------------- ReverseV ------------------------------------\n-BITWISE_UNARY(vreverse, ReverseV, sve_rbit)\n-BITWISE_UNARY_PREDICATE(vreverse, ReverseV, sve_rbit)\n-\n-\/\/ -------------------------------- ReverseBytesV ---------------------------------\n-BITWISE_UNARY(vreverseBytes, ReverseBytesV, sve_revb)\n-BITWISE_UNARY_PREDICATE(vreverseBytes, ReverseBytesV, sve_revb)\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":0,"deletions":3470,"binary":false,"changes":3470,"status":"deleted"},{"patch":"@@ -0,0 +1,6361 @@\n+\/\/\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ This file is automatically generated by running \"m4 aarch64_vector_ad.m4\". Do not edit!\n+\n+\/\/ AArch64 VECTOR Architecture Description File\n+\n+\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+\n+operand vmemA_immIOffset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_immLOffset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n);\n+%}\n+\n+source %{\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    int mesize = type2aelembytes(mem_elem_bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(mesize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    if (UseSVE == 0) {\n+      \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n+      \/\/ NEON instructions support them. But the match rule support for them is profitable for\n+      \/\/ Vector API intrinsics.\n+      if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n+          (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n+        return false;\n+      }\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n+  \/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!match_rule_supported(opcode)) {\n+      return false;\n+    }\n+\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (UseSVE == 0 && length_in_bytes > 16) {\n+      return false;\n+    }\n+\n+    \/\/ Check whether specific Op is supported.\n+    \/\/ Fail fast, otherwise fall through to common vector_size_supported() check.\n+    switch (opcode) {\n+      case Op_MulVL:\n+      case Op_AndVMask:\n+      case Op_OrVMask:\n+      case Op_XorVMask:\n+      case Op_MaskAll:\n+      case Op_VectorMaskGen:\n+      case Op_LoadVectorMasked:\n+      case Op_StoreVectorMasked:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_LoadVectorGatherMasked:\n+      case Op_StoreVectorScatterMasked:\n+      case Op_PopulateIndex:\n+      case Op_CompressM:\n+      case Op_CompressV:\n+        if (UseSVE == 0) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulAddVS2VI:\n+        if (length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ No vector multiply reduction instructions, but we do\n+        \/\/ emit scalar instructions for 64\/128-bit vectors.\n+        if (length_in_bytes != 8 && length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskCmp:\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLoadShuffle:\n+      case Op_VectorRearrange:\n+        if (vlen < 4) {\n+          return false;\n+        }\n+        break;\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+        if (UseSVE > 0 && vlen > 64) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+          return false;\n+        }\n+        break;\n+      default:\n+        break;\n+    }\n+    return vector_size_supported(bt, vlen);\n+  }\n+\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    \/\/ Only SVE supports masked operations.\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    \/\/ If an opcode does not support the masked version,\n+    \/\/ unpredicated node with VectorBlend node will be used instead.\n+    switch(opcode) {\n+      case Op_VectorRearrange:\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return false;\n+      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n+      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n+      \/\/ same as vector store\/gather\/scatter.\n+      case Op_LoadVector:\n+        opcode = Op_LoadVectorMasked;\n+        break;\n+      case Op_StoreVector:\n+        opcode = Op_StoreVectorMasked;\n+        break;\n+      case Op_LoadVectorGather:\n+        opcode = Op_LoadVectorGatherMasked;\n+        break;\n+      case Op_StoreVectorScatter:\n+        opcode = Op_StoreVectorScatterMasked;\n+        break;\n+      default:\n+        break;\n+    }\n+\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    \/\/ Only SVE has partial vector operations\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    switch(node->Opcode()) {\n+      case Op_VectorLoadMask:\n+      case Op_VectorMaskCmp:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_AddReductionVF:\n+      case Op_AddReductionVD:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n+      \/\/ input predicate is all-false, the result should be the vector length\n+      \/\/ instead of the vector register size.\n+      case Op_VectorMaskFirstTrue:\n+        return true;\n+      case Op_MaskAll:\n+        return !node->in(1)->is_Con();\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n+        return vt->length_in_bytes() > 16;\n+      case Op_AddReductionVI:\n+      case Op_AddReductionVL:\n+        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n+        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n+        \/\/ instructions rather than SVE partial operations.\n+        return vt->element_basic_type() == T_LONG ||\n+               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      default:\n+        \/\/ For other ops whose vector size is smaller than the max vector size, a\n+        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        return false;\n+    }\n+  }\n+\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n) {\n+    assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+    return true;\n+  }\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n) {\n+    BasicType bt = Matcher::vector_element_basic_type(n);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(n);\n+    return Assembler::esize2arrangement((uint)type2aelembytes(bt),\n+                                        \/* isQ *\/ length_in_bytes == 16);\n+  }\n+%}\n+\n+\n+\/\/ All VECTOR instructions\n+\n+\/\/ ------------------------------ Vector load\/store ----------------------------\n+\n+\/\/ Load Vector (16 bits)\n+instruct loadV2(vReg dst, vmem2 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 2);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV2 $dst, $mem\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvH(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (16 bits)\n+instruct storeV2(vReg src, vmem2 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 2);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV2 $mem, $src\\t# vector (16 bits)\" %}\n+  ins_encode( aarch64_enc_strvH(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (32 bits)\n+instruct loadV4(vReg dst, vmem4 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 4);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV4 $dst, $mem\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvS(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (32 bits)\n+instruct storeV4(vReg src, vmem4 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 4);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV4 $mem, $src\\t# vector (32 bits)\" %}\n+  ins_encode( aarch64_enc_strvS(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (64 bits)\n+instruct loadV8(vReg dst, vmem8 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 8);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV8 $dst, $mem\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvD(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (64 bits)\n+instruct storeV8(vReg src, vmem8 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 8);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV8 $mem, $src\\t# vector (64 bits)\" %}\n+  ins_encode( aarch64_enc_strvD(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (128 bits)\n+instruct loadV16(vReg dst, vmem16 mem) %{\n+  predicate(n->as_LoadVector()->memory_size() == 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV16 $dst, $mem\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_ldrvQ(dst, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (128 bits)\n+instruct storeV16(vReg src, vmem16 mem) %{\n+  predicate(n->as_StoreVector()->memory_size() == 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV16 $mem, $src\\t# vector (128 bits)\" %}\n+  ins_encode( aarch64_enc_strvQ(src, mem) );\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Load Vector (> 128 bits)\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(n->as_LoadVector()->memory_size() > 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV $dst, $mem\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+                          $dst$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (> 128 bits)\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(n->as_StoreVector()->memory_size() > 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+                          $src$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load\/store - predicated\n+\n+instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LoadVectorMasked mem pg));\n+  format %{ \"loadV_masked $dst, $pg, $mem\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n+  format %{ \"storeV_masked $mem, $pg, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load const\n+\n+instruct vloadconB(vReg dst, immI0 src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      if (length_in_bytes == 16) {\n+        __ ldrq($dst$$FloatRegister, rscratch1);\n+      } else {\n+        __ ldrd($dst$$FloatRegister, rscratch1);\n+      }\n+    } else {\n+      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector add -----------------------------------\n+\n+\/\/ vector add\n+\n+instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVB src1 src2));\n+  format %{ \"vaddB $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ B, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVS src1 src2));\n+  format %{ \"vaddS $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVI src1 src2));\n+  format %{ \"vaddI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVL src1 src2));\n+  format %{ \"vaddL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ addv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_add($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVF src1 src2));\n+  format %{ \"vaddF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVD src1 src2));\n+  format %{ \"vaddD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add - predicated\n+\n+instruct vaddB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 src2) pg));\n+  format %{ \"vaddB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVS (Binary dst_src1 src2) pg));\n+  format %{ \"vaddS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVI (Binary dst_src1 src2) pg));\n+  format %{ \"vaddI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVL (Binary dst_src1 src2) pg));\n+  format %{ \"vaddL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_add($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVF (Binary dst_src1 src2) pg));\n+  format %{ \"vaddF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVD (Binary dst_src1 src2) pg));\n+  format %{ \"vaddD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add reg imm (unpredicated)\n+\n+instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n+  format %{ \"vaddImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ B, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ B, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n+  format %{ \"vaddImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ H, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ H, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n+  format %{ \"vaddImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ S, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ S, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n+  format %{ \"vaddImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ D, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ D, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector sub -----------------------------------\n+\n+\/\/ vector sub\n+\n+instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVB src1 src2));\n+  format %{ \"vsubB $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ B, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVS src1 src2));\n+  format %{ \"vsubS $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVI src1 src2));\n+  format %{ \"vsubI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVL src1 src2));\n+  format %{ \"vsubL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ subv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_sub($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVF src1 src2));\n+  format %{ \"vsubF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVD src1 src2));\n+  format %{ \"vsubD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sub - predicated\n+\n+instruct vsubB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 src2) pg));\n+  format %{ \"vsubB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVS (Binary dst_src1 src2) pg));\n+  format %{ \"vsubS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVI (Binary dst_src1 src2) pg));\n+  format %{ \"vsubI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVL (Binary dst_src1 src2) pg));\n+  format %{ \"vsubL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_sub($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVD (Binary dst_src1 src2) pg));\n+  format %{ \"vsubD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mul -----------------------------------\n+\n+\/\/ vector mul - BYTE, CHAR, SHORT, INT\n+\n+instruct vmulB_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVB src1 src2));\n+  format %{ \"vmulB_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulB_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVB dst_src1 src2));\n+  format %{ \"vmulB_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ B, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVS src1 src2));\n+  format %{ \"vmulS_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVS dst_src1 src2));\n+  format %{ \"vmulS_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MulVI src1 src2));\n+  format %{ \"vmulI_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ mulv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MulVI dst_src1 src2));\n+  format %{ \"vmulI_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_mul($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - LONG\n+\n+instruct vmulL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (MulVL src1 src2));\n+  format %{ \"vmulL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 16, \"must be\");\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 0);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 0);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 0, rscratch2);\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 1);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 1);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  format %{ \"vmulL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - floating-point\n+\n+instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVF src1 src2));\n+  format %{ \"vmulF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ S, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVD src1 src2));\n+  format %{ \"vmulD $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - predicated\n+\n+instruct vmulB_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVB (Binary dst_src1 src2) pg));\n+  format %{ \"vmulB_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ B, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVS (Binary dst_src1 src2) pg));\n+  format %{ \"vmulS_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVI (Binary dst_src1 src2) pg));\n+  format %{ \"vmulI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL (Binary dst_src1 src2) pg));\n+  format %{ \"vmulL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVD (Binary dst_src1 src2) pg));\n+  format %{ \"vmulD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector float div -----------------------------\n+\n+\/\/ vector float div\n+\n+instruct vdivF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVF src1 src2));\n+  format %{ \"vdivF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVF dst_src1 src2));\n+  format %{ \"vdivF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVD src1 src2));\n+  format %{ \"vdivD_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVD dst_src1 src2));\n+  format %{ \"vdivD_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector float div - predicated\n+\n+instruct vdivF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ S, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVD (Binary dst_src1 src2) pg));\n+  format %{ \"vdivD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ D, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector and -----------------------------------\n+\n+\/\/ vector and\n+\n+instruct vand(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AndV src1 src2));\n+  format %{ \"vand $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ andr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_and($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and - predicated\n+\n+instruct vand_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 src2) pg));\n+  format %{ \"vand_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_and($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and reg imm (unpredicated)\n+\n+instruct vandImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateB con)));\n+  format %{ \"vandImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateS con)));\n+  format %{ \"vandImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateI con)));\n+  format %{ \"vandImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateL con)));\n+  format %{ \"vandImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_and($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector or ------------------------------------\n+\n+\/\/ vector or\n+\n+instruct vor(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (OrV src1 src2));\n+  format %{ \"vor $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or - predicated\n+\n+instruct vor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (OrV (Binary dst_src1 src2) pg));\n+  format %{ \"vor_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_orr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or reg imm (unpredicated)\n+\n+instruct vorImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateB con)));\n+  format %{ \"vorImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateS con)));\n+  format %{ \"vorImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateI con)));\n+  format %{ \"vorImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateL con)));\n+  format %{ \"vorImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_orr($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector xor -----------------------------------\n+\n+\/\/ vector xor\n+\n+instruct vxor(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (XorV src1 src2));\n+  format %{ \"vxor $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_eor($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor - predicated\n+\n+instruct vxor_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (XorV (Binary dst_src1 src2) pg));\n+  format %{ \"vxor_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_eor($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor reg imm (unpredicated)\n+\n+instruct vxorImmB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateB con)));\n+  format %{ \"vxorImmB $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ B, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmS(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateS con)));\n+  format %{ \"vxorImmS $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ H, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmI(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateI con)));\n+  format %{ \"vxorImmI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ S, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorImmL(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateL con)));\n+  format %{ \"vxorImmL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ sve_eor($dst_src$$FloatRegister, __ D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector not -----------------------------------\n+\n+\/\/ vector not\n+\n+instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n+  match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));\n+  format %{ \"vnotI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n+  match(Set dst (XorV src (ReplicateL m1)));\n+  format %{ \"vnotL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector not - predicated\n+\n+instruct vnotI_masked(vReg dst_src, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));\n+  format %{ \"vnotI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL_masked(vReg dst_src, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));\n+  format %{ \"vnotL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+\n+\/\/ vector and_not\n+\n+instruct vand_notI(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));\n+  format %{ \"vand_notI $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL(vReg dst, vReg src1, vReg src2, immL_M1 m1) %{\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));\n+  format %{ \"vand_notL $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and_not - predicated\n+\n+instruct vand_notI_masked(vReg dst_src1, vReg src2, immI_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));\n+  format %{ \"vand_notI_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_masked(vReg dst_src1, vReg src2, immL_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));\n+  format %{ \"vand_notL_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector abs -----------------------------------\n+\n+\/\/ vector abs\n+\n+instruct vabsB(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVB src));\n+  format %{ \"vabsB $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVS src));\n+  format %{ \"vabsS $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVI src));\n+  format %{ \"vabsI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVL src));\n+  format %{ \"vabsL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ absr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_abs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVF src));\n+  format %{ \"vabsF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (AbsVD src));\n+  format %{ \"vabsD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector abs - predicated\n+\n+instruct vabsB_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVB dst_src pg));\n+  format %{ \"vabsB_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ B, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVS dst_src pg));\n+  format %{ \"vabsS_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVI dst_src pg));\n+  format %{ \"vabsI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVL dst_src pg));\n+  format %{ \"vabsL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_abs($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVF dst_src pg));\n+  format %{ \"vabsF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVD dst_src pg));\n+  format %{ \"vabsD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector fabd ----------------------------------\n+\n+\/\/ vector fabs diff\n+\n+instruct vfabd(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AbsVF (SubVF src1 src2)));\n+  match(Set dst (AbsVD (SubVD src1 src2)));\n+  format %{ \"vfabd $dst, $src1, $src2\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ fabd($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector neg -----------------------------------\n+\n+\/\/ vector neg\n+\n+instruct vnegI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVI src));\n+  format %{ \"vnegI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_neg($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVL src));\n+  format %{ \"vnegL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_neg($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVF src));\n+  format %{ \"vnegF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVD src));\n+  format %{ \"vnegD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector neg - predicated\n+\n+instruct vnegI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVI dst_src pg));\n+  format %{ \"vnegI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_neg($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVL dst_src pg));\n+  format %{ \"vnegL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_neg($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVF dst_src pg));\n+  format %{ \"vnegF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVD dst_src pg));\n+  format %{ \"vnegD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector sqrt ----------------------------------\n+\n+\/\/ vector sqrt\n+\n+instruct vsqrtF(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (SqrtVF src));\n+  format %{ \"vsqrtF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (SqrtVD src));\n+  format %{ \"vsqrtD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sqrt - predicated\n+\n+instruct vsqrtF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (SqrtVF dst_src pg));\n+  format %{ \"vsqrtF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fsqrt($dst_src$$FloatRegister, __ S, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (SqrtVD dst_src pg));\n+  format %{ \"vsqrtD_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fsqrt($dst_src$$FloatRegister, __ D, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector min -----------------------------------\n+\n+\/\/ vector min - LONG\n+\n+instruct vminL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (MinV src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vminL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  format %{ \"vminL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_smin($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min - B\/S\/I\/F\/D\n+\n+instruct vmin_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinV src1 src2));\n+  format %{ \"vmin_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ fmin($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ minv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmin_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  format %{ \"vmin_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ sve_smin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min - predicated\n+\n+instruct vmin_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MinV (Binary dst_src1 src2) pg));\n+  format %{ \"vmin_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ sve_smin($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector max -----------------------------------\n+\n+\/\/ vector max - LONG\n+\n+instruct vmaxL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (MaxV src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vmaxL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  format %{ \"vmaxL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_smax($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max - B\/S\/I\/F\/D\n+\n+instruct vmax_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxV src1 src2));\n+  format %{ \"vmax_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ fmax($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ maxv($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmax_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  format %{ \"vmax_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ sve_smax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max - predicated\n+\n+instruct vmax_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MaxV (Binary dst_src1 src2) pg));\n+  format %{ \"vmax_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ sve_fmax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ sve_smax($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ MLA RELATED ----------------------------------\n+\n+\/\/ vector mla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlav does not accept T2D arrangement.\n+      __ mlav($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vfmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  format %{ \"vfmla $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmla($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmad - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n+  format %{ \"vfmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+\n+instruct vmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlsv does not accept T2D arrangement.\n+      __ mlsv($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  format %{ \"vfmls1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  format %{ \"vfmls2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmsb - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n+  format %{ \"vfmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  format %{ \"vfnmla1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  format %{ \"vfnmla2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmad - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  format %{ \"vfnmls $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmsb - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ MulAddVS2VI\n+\/\/ Vector Multiply-Add Shorts into Integer\n+\n+instruct vmuladdS2I(vReg dst, vReg src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);\n+  match(Set dst (MulAddVS2VI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmuladdS2I $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ smullv($tmp$$FloatRegister, __ T4H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ smullv($dst$$FloatRegister, __ T8H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ addpv($dst$$FloatRegister, __ T4S, $tmp$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shift ---------------------------------\n+\n+\/\/ Vector right shift in AArch64 ASIMD\n+\/\/\n+\/\/ Right shifts with vector shift count on AArch64 ASIMD are implemented\n+\/\/ as left shift by negative shift count.\n+\/\/ There are two cases for vector shift count.\n+\/\/\n+\/\/ Case 1: The vector shift count is from replication.\n+\/\/        |            |\n+\/\/    LoadVector  RShiftCntV\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ Case 2: The vector shift count is from loading.\n+\/\/ This case isn't supported by middle-end now. But it's supported by\n+\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n+\/\/        |            |\n+\/\/    LoadVector  LoadVector\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n+\n+\/\/ vector shift count\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (LShiftCntV cnt));\n+  format %{ \"vshiftcntL $dst, $cnt\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $cnt$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntR(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"vshiftcntR $dst, $cnt\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ negw(rscratch1, $cnt$$Register);\n+      __ dup($dst$$FloatRegister, get_arrangement(this), rscratch1);\n+    } else {\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift left\n+\n+instruct vlsl_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVL src shift));\n+  format %{ \"vlsl_neon $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsl_sve(vReg dst_src, vReg shift) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src (LShiftVB dst_src shift));\n+  match(Set dst_src (LShiftVS dst_src shift));\n+  match(Set dst_src (LShiftVI dst_src shift));\n+  match(Set dst_src (LShiftVL dst_src shift));\n+  format %{ \"vlsl_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift right (arithmetic)\n+\n+instruct vasr_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVL src shift));\n+  format %{ \"vasr_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vasr_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (RShiftVB dst_src shift));\n+  match(Set dst_src (RShiftVS dst_src shift));\n+  match(Set dst_src (RShiftVI dst_src shift));\n+  match(Set dst_src (RShiftVL dst_src shift));\n+  format %{ \"vasr_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_asr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift right (logical)\n+\n+instruct vlsr_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVL src shift));\n+  format %{ \"vlsr_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ ushl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vlsr_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ ushl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (URShiftVB dst_src shift));\n+  match(Set dst_src (URShiftVS dst_src shift));\n+  match(Set dst_src (URShiftVI dst_src shift));\n+  match(Set dst_src (URShiftVL dst_src shift));\n+  format %{ \"vlsr_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift with imm\n+\n+instruct vlsl_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n+  format %{ \"vlsl_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ shl($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsl($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+  format %{ \"vasr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ sshr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_asr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+  format %{ \"vlsr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ ushr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ shift right add with imm (vector length <= 128 bits only)\n+\n+instruct vasra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  format %{ \"vasra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    __ ssra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  format %{ \"vlsra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) { \/\/ for B\/H\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con < esize_in_bits) {\n+        __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+      }\n+    } else { \/\/ for S\/D\n+      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, \"unsupported type\");\n+      __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift - predicated\n+\n+instruct vlsl_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (LShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (LShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vlsl_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (RShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (RShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vasr_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_asr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (URShiftVB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 (URShiftVL (Binary dst_src1 src2) pg));\n+  format %{ \"vlsr_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsr($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift with imm - predicated\n+\n+instruct vlsl_imm_masked(vReg dst_src, immI shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (LShiftVB (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVS (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVI (Binary dst_src (LShiftCntV shift)) pg));\n+  match(Set dst_src (LShiftVL (Binary dst_src (LShiftCntV shift)) pg));\n+  format %{ \"vlsl_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con >= 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm_masked(vReg dst_src, immI_positive shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (RShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (RShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n+  format %{ \"vasr_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con > 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_asr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm_masked(vReg dst_src, immI_positive shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (URShiftVB (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVS (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVI (Binary dst_src (RShiftCntV shift)) pg));\n+  match(Set dst_src (URShiftVL (Binary dst_src (RShiftCntV shift)) pg));\n+  format %{ \"vlsr_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con > 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ sve_lsr($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction add -------------------------\n+\n+\/\/ reduction addI\n+\n+instruct reduce_addI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addL\n+\n+instruct reduce_addL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addF\n+\n+instruct reduce_addF_neon(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addF_neon $dst, $fsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ fadds($dst$$FloatRegister, $fsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 1);\n+    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    if (length_in_bytes == 16) {\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 2);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 3);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_sve(vRegF dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVF dst_src1 src2));\n+  format %{ \"reduce_addF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ S, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction addD\n+\n+instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ faddd($dst$$FloatRegister, $dsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ D, $vsrc$$FloatRegister, 0, 1);\n+    __ faddd($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_sve(vRegD dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVD dst_src1 src2));\n+  format %{ \"reduce_addD_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction add - predicated\n+\n+instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVI (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVL (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF_masked(vRegF dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVF (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_addF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ S,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD_masked(vRegD dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionVD (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_addD_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ D,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction mul -------------------------\n+\n+instruct reduce_mulI(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                     vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 8 ||\n+            Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_mulI $dst, $isrc, $vsrc\\t# vector (64\/128 bits). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_integral($dst$$Register, bt, $isrc$$Register,\n+                                $vsrc$$FloatRegister, length_in_bytes,\n+                                $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulL(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_mulL $dst, $isrc, $vsrc\\t# 2L\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_integral($dst$$Register, T_LONG, $isrc$$Register,\n+                                $vsrc$$FloatRegister, 16, fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulF(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) <= 16);\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulF $dst, $fsrc, $vsrc\\t# 2F\/4F. KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_FLOAT, $fsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulD(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulD $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_DOUBLE, $dsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, 16, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction and -------------------------\n+\n+\/\/ reduction andI\n+\n+instruct reduce_andI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_andI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction andL\n+\n+instruct reduce_andL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_andL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction and - predicated\n+\n+instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (AndReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_andL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (AndReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_andL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction or --------------------------\n+\n+\/\/ reduction orI\n+\n+instruct reduce_orI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_orI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction orL\n+\n+instruct reduce_orL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_orL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction or - predicated\n+\n+instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (OrReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_orL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (OrReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_orL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction xor -------------------------\n+\n+\/\/ reduction xorI\n+\n+instruct reduce_xorI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_xorI_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorI_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction xorL\n+\n+instruct reduce_xorL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_xorL_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorL_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction xor - predicated\n+\n+instruct reduce_xorI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) != T_LONG);\n+  match(Set dst (XorReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_xorL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (XorReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_xorL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction max -------------------------\n+\n+\/\/ reduction maxI\n+\n+instruct reduce_maxI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxL\n+\n+instruct reduce_maxL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_maxL_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxL_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxF\n+\n+instruct reduce_maxF(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxF $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ fmaxp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ fmaxv($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fmaxv($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmaxs($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction maxD\n+\n+instruct reduce_maxD(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxD $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmaxp($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fmaxv($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmaxd($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction max - predicated\n+\n+instruct reduce_maxI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));\n+  match(Set dst (MaxReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (MaxReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_maxL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxF_masked(vRegF dst, vRegF fsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_FLOAT);\n+  match(Set dst (MaxReductionV (Binary fsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxF_masked $dst, $fsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fmaxv($dst$$FloatRegister, __ S, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmaxs($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD_masked(vRegD dst, vRegD dsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_DOUBLE);\n+  match(Set dst (MaxReductionV (Binary dsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_maxD_masked $dst, $dsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fmaxv($dst$$FloatRegister, __ D, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmaxd($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reduction min -------------------------\n+\n+\/\/ reduction minI\n+\n+instruct reduce_minI_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minI_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minL\n+\n+instruct reduce_minL_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_minL_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minL_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minF\n+\n+instruct reduce_minF(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minF $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ fminp($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ fminv($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fminv($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmins($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction minD\n+\n+instruct reduce_minD(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minD $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fminp($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ sve_fminv($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ fmind($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ reduction min - predicated\n+\n+instruct reduce_minI_masked(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));\n+  match(Set dst (MinReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minI_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minL_masked(iRegLNoSp dst, iRegL isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);\n+  match(Set dst (MinReductionV (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_minL_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minF_masked(vRegF dst, vRegF fsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_FLOAT);\n+  match(Set dst (MinReductionV (Binary fsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minF_masked $dst, $fsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fminv($dst$$FloatRegister, __ S, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmins($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD_masked(vRegD dst, vRegD dsrc, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_DOUBLE);\n+  match(Set dst (MinReductionV (Binary dsrc vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_minD_masked $dst, $dsrc, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ sve_fminv($dst$$FloatRegister, __ D, $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ fmind($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n+\n+instruct reinterpret_same_size(vReg dst_src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"reinterpret_same_size $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpret_resize_le128b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <= 16);\n+  match(Set dst (VectorReinterpret src));\n+  format %{ \"reinterpret_resize_le128b $dst, $src\\t# vector <= 128 bits.\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    \/\/ The higher bits in \"dst\" register must be cleared to zero.\n+    if ((length_in_bytes_src == 4 && length_in_bytes_dst == 8) ||\n+        (length_in_bytes_src == 8 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 64 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 4 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 128 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 8 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 8)) {\n+      \/\/ Reinterpret between 64 bits and 128 bits\n+      __ orr($dst$$FloatRegister, __ T8B, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(false, \"invalid vector length\");\n+      ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpret_resize_gt128b(vReg dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) > 16 ||\n+             Matcher::vector_length_in_bytes(n->in(1)) > 16));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"reinterpret_resize_gt128b $dst, $src\\t# vector > 128 bits. KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_gen_mask_imm($ptmp$$PRegister, T_BYTE, length_in_bytes_resize);\n+    __ sve_dup($dst$$FloatRegister, __ B, 0);\n+    __ sve_sel($dst$$FloatRegister, __ B, $ptmp$$PRegister,\n+               $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector cast ----------------------------------\n+\n+\/\/ VectorCastB2X\n+\n+instruct vcvtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vcvtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I\/4F, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : bt,\n+                            length_in_bytes, $src$$FloatRegister, T_BYTE);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ B);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastS2X\n+\n+instruct vcvtStoB_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoB_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4S\/8S to 4B\/8B\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_BYTE,\n+                          $src$$FloatRegister, T_SHORT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoB_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  format %{ \"vcvtStoB_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $src$$FloatRegister, __ H, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoX_extend $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\/4F\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ H);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastI2X\n+\n+instruct vcvtItoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtItoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4I to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $src$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtItoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastI2X src));\n+  format %{ \"vcvtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_FLOAT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I\/4I to 2F\/4F\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(type2aelembytes(bt) == 8, \"unsupported type\");\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I to 2L\/2D\n+        __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                              $src$$FloatRegister, T_INT);\n+        if (bt == T_DOUBLE) {\n+          __ scvtfv(__ T2D, $dst$$FloatRegister, $dst$$FloatRegister);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        if (bt == T_DOUBLE) {\n+          __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ D);\n+        }\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastL2X\n+\n+instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2I\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+                          $src$$FloatRegister, T_LONG, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n+             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_neon(vReg dst, vReg src, vRegF tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_neon $dst, $src\\t# 2L to 2F. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2F\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+    __ scvtfs($dst$$FloatRegister, rscratch1);\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+    __ scvtfs($tmp$$FloatRegister, rscratch1);\n+    __ ins($dst$$FloatRegister, __ S, $tmp$$FloatRegister, 1, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2L to 2D\n+      __ scvtfv(__ T2D, $dst$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2X\n+\n+instruct vcvtFtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtFtoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $dst$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vcvtFtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_INT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2F\/4F to 2I\/4I\n+        __ fcvtzs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        \/\/ 2F to 2L\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+        __ fcvtzs($dst$$FloatRegister, __ T2D, $dst$$FloatRegister);\n+      } else {\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(bt == T_DOUBLE, \"unsupported type\");\n+      if (length_in_bytes == 16) {\n+        \/\/ 2F to 2D\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+      } else {\n+        assert(UseSVE > 0 && length_in_bytes > 16, \"must be\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastD2X\n+\n+instruct vcvtDtoI_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2I\n+    __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, $src$$FloatRegister);\n+    __ fcvtzdw(rscratch2, $dst$$FloatRegister);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n+    __ mov($dst$$FloatRegister, __ S, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2D to 2L\n+      __ fcvtzs($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_64b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) == 8);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoF_64b $dst, $src\\t# 2D to 2F\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2F\n+    __ fcvtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_gt64b(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoF_gt64b $dst, $src\\t# vector > 64 bits. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Replicate ------------------------------------\n+\n+\/\/ replicate from reg\n+\n+instruct replicateB(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateB src));\n+  format %{ \"replicateB $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ B, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateS src));\n+  format %{ \"replicateS $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ H, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI(vReg dst, iRegIorL2I src) %{\n+  match(Set dst (ReplicateI src));\n+  format %{ \"replicateI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ S, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL(vReg dst, iRegL src) %{\n+  match(Set dst (ReplicateL src));\n+  format %{ \"replicateL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ D, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateF(vReg dst, vRegF src) %{\n+  match(Set dst (ReplicateF src));\n+  format %{ \"replicateF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateD(vReg dst, vRegD src) %{\n+  match(Set dst (ReplicateD src));\n+  format %{ \"replicateD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ replicate from imm\n+\n+instruct replicateI_imm_le128b(vReg dst, immI con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int imm = (int)$con$$constant;\n+    if (type2aelembytes(bt) == 1) {\n+      \/\/ Refine imm for B\n+      imm = imm & 0xff;\n+    } else if (type2aelembytes(bt) == 2) {\n+      \/\/ Refine imm for S\n+      imm = imm & 0xffff;\n+    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateB_imm8_gt128b(vReg dst, immI8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateB con));\n+  format %{ \"replicateB_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ B, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateS con));\n+  format %{ \"replicateS_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm_128b(vReg dst, immL con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm_128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ T2D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ D, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_le128b(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertI_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+           (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx,\n+                            vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 31. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp$$FloatRegister, size, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_ge32(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1,\n+                            vReg tmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp1$$FloatRegister, size, 0, 1);\n+    __ sve_dup($tmp2$$FloatRegister, size, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_128b(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertL_128b $dst, $src, $val, $idx\\t# 2L\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ D, (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_gt128b(vReg dst, vReg src, iRegL val, immI idx,\n+                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertL_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_le128b(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertF_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ S, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, vRegF val, immI idx,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 32. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ S, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_ge32(vReg dst, vReg src, vRegF val, immI idx, vReg tmp,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ S, 0, 1);\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $tmp$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_128b(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertD_128b $dst, $src, $val, $idx\\t# 2D\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ D, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_gt128b(vReg dst, vReg src, vRegD val, immI idx,\n+                        pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertD_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Extract --------------------------------------\n+\/\/ BYTE\n+\n+instruct extractB_index_lt16(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractB src idx));\n+  format %{ \"extractB_index_lt16 $dst, $src, $idx\\t# index < 16\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ B, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractB_index_ge16(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 16);\n+  match(Set dst (ExtractB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractB_index_ge16 $dst, $src, $idx\\t# index >=16. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_BYTE, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ SHORT\n+\n+instruct extractS_index_lt8(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 8);\n+  match(Set dst (ExtractS src idx));\n+  format %{ \"extractS_index_lt8 $dst, $src, $idx\\t# index < 8\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractS_index_ge8(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 8);\n+  match(Set dst (ExtractS src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractS_index_ge8 $dst, $src, $idx\\t# index >=8. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_SHORT, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ INT\n+\n+instruct extractI_index_lt4(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 4);\n+  match(Set dst (ExtractI src idx));\n+  format %{ \"extractI_index_lt4 $dst, $src, $idx\\t# index < 4\" %}\n+  ins_encode %{\n+    __ umov($dst$$Register, $src$$FloatRegister, __ S, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractI_index_ge4(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 4);\n+  match(Set dst (ExtractI src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractI_index_ge4 $dst, $src, $idx\\t# index >=4. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_INT, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct extractL_index_lt2(iRegLNoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 2);\n+  match(Set dst (ExtractL src idx));\n+  format %{ \"extractL_index_lt2 $dst, $src, $idx\\t# index < 2\" %}\n+  ins_encode %{\n+    __ umov($dst$$Register, $src$$FloatRegister, __ D, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractL_index_ge2(iRegLNoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 2);\n+  match(Set dst (ExtractL src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractL_index_ge2 $dst, $src, $idx\\t# index >=2. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_LONG, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct extractF(vRegF dst, vReg src, immI idx) %{\n+  match(Set dst (ExtractF src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extractF $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ fmovs($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < 4) {\n+      __ ins($dst$$FloatRegister, __ S, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << 2);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct extractD(vRegD dst, vReg src, immI idx) %{\n+  match(Set dst (ExtractD src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extractD $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ fmovd($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < 2) {\n+      __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask load\/store -----------------------\n+\n+\/\/ vector load mask\n+\n+instruct vloadmask_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorLoadMask src ));\n+  format %{ \"vloadmask_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+      if (type2aelembytes(bt) >= 4) {\n+        __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+      }\n+      if (type2aelembytes(bt) == 8) {\n+        __ uxtl($dst$$FloatRegister, __ T2D, $dst$$FloatRegister, __ T2S);\n+      }\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_sve $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               ptrue, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_sve $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_masked $dst, $pg, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               $pg$$PRegister, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - neon\n+\n+instruct vstoremaskB_neon(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_neon $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_neon(vReg dst, vReg src, immI_gt_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremask_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    int esize = (int)$size$$constant;\n+    if (esize == 2) {\n+      __ xtn($dst$$FloatRegister, __ T8B, $src$$FloatRegister, __ T8H);\n+    } else if (esize == 4) {\n+      __ xtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(esize == 8, \"must be\");\n+      __ xtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    }\n+    __ negr($dst$$FloatRegister, __ T8B, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - sve\n+\n+instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_cpy($dst$$FloatRegister, __ B, $src$$PRegister, 1, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vstoremask_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy($dst$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $dst$$FloatRegister, size, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+                                vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV_masked $dst, $pg, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+                                      vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked_masked $dst, $pg2, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the \"pg2\" used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg2$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg2$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  format %{ \"storeV_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+                                  vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeV_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp);\n+  format %{ \"storeVMasked_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector store with boolean type. But the predicate used in\n+    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n+    \/\/ is the full-sized predicate (ptrue) here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+                                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeVMasked_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n+    \/\/ vector store with boolean type. But the predicate used in the narrowing\n+    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n+    \/\/ here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask basic OPs ------------------------\n+\n+\/\/ vector mask logical ops: and\/or\/xor\/and_not\n+\n+instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn pm));\n+  format %{ \"vmask_and $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_and($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (OrVMask pn pm));\n+  format %{ \"vmask_or $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_orr($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (XorVMask pn pm));\n+  format %{ \"vmask_xor $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_eor($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_notI $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_notL $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp_neon(vReg dst, vReg src1, vReg src2, immI cond) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  format %{ \"vmaskcmp_neon $dst, $src1, $src2, $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_sve $dst, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_compare($dst$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+                         pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_masked $dst, $pg, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare($dst$$PRegister, bt, $pg$$PRegister, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast_same_esize_neon(vReg dst_src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_neon $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_sve $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst == 2 * length_in_bytes_src ||\n+           length_in_bytes_dst == 4 * length_in_bytes_src ||\n+           length_in_bytes_dst == 8 * length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_extend($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst * 2 == length_in_bytes_src ||\n+           length_in_bytes_dst * 4 == length_in_bytes_src ||\n+           length_in_bytes_dst * 8 == length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_narrow($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask reinterpret\n+\n+instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) != Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmask_reinterpret_diff_esize $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_cpy($tmp$$FloatRegister, from_size, $src$$PRegister, -1, false);\n+    __ sve_cmp(Assembler::EQ, $dst$$PRegister, to_size, ptrue, $tmp$$FloatRegister, -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount_neon(iRegINoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_truecount_neon $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_sve(iRegINoSp dst, pReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount_sve $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt),\n+                ptrue, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length(n->in(1)) < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    __ fmovd($dst$$Register, $src$$FloatRegister);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, Matcher::vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+  match(Set dst (VectorMaskFirstTrue src));\n+  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes == 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ lsrw($dst$$Register, $dst$$Register, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label FIRST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, zr);\n+      __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8);\n+\n+      \/\/ Reverse the bits and count the leading zero bytes.\n+      __ bind(FIRST_TRUE_INDEX);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_brkb($ptmp$$PRegister, ptrue, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskFirstTrue src pg));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_masked $dst, $pg, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_brkb($ptmp$$PRegister, $pg$$PRegister, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+instruct vmask_lasttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      \/\/ Computed by counting the leading zero bytes and\n+      \/\/ subtracting it by 7 (VLENGTH - 1).\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ movw(rscratch1, 7);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label LAST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 16 - 1);\n+      __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8 - 1);\n+\n+      \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n+      __ bind(LAST_TRUE_INDEX);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_lasttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, $src$$PRegister, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong_neon(iRegLNoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ bytemask_compress($dst$$Register);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      __ umov($dst$$Register, $src$$FloatRegister, __ D, 0);\n+      __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+      __ bytemask_compress($dst$$Register);\n+      __ bytemask_compress(rscratch1);\n+      __ orr($dst$$Register, $dst$$Register, rscratch1, Assembler::LSL, 8);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask generation -----------------------\n+\n+\/\/ maskAll\n+\n+instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_immI $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    int con = (int)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllI $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllI_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_immL $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    long con = (long)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllL $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAllL_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vetcor mask generation\n+\n+instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (ConvI2L src)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_I $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelow($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen src));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_L $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen con));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_imm $pd, $con\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_gen_mask_imm($pd$$PRegister, bt, (uint)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+\/\/ vector popcount - INT\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVI src));\n+  format %{ \"vpopcountI $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_cnt($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT, \"unsupported\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                  $dst$$FloatRegister);\n+        if (bt == T_INT) {\n+          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n+                    $dst$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_cnt($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - LONG\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  format %{ \"vpopcountL $dst, $src\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+\n+instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+\n+instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (PopCountVI dst_src pg));\n+  format %{ \"vpopcountI_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  format %{ \"vpopcountL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_cnt($dst_src$$FloatRegister, __ D,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector blend ---------------------------------\n+\n+instruct vblend_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) dst));\n+  format %{ \"vblend_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vblend_sve(vReg dst, vReg src1, vReg src2, pReg pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) pg));\n+  format %{ \"vblend_sve $dst, $pg, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector round ---------------------------------\n+\n+\/\/ vector Math.round\n+\n+instruct vround_le128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       vReg tmp3, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"vround_le128b $dst, $src\\t# vector <= 128 bits. KILL $tmp1, $tmp2, $tmp3, cr\" %}\n+  ins_encode %{\n+    __ vector_round_neon($dst$$FloatRegister, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_gt128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"vround_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_round_sve($dst$$FloatRegister, $src$$FloatRegister,\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                        $pgtmp$$PRegister, __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ RoundDouble ----------------------------------\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"vroundD $dst, $src, $rmode\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ frintn($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ frintm($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ frintp($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ sve_frintn($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ sve_frintm($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ sve_frintp($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ VectorTest -----------------------------------\n+\n+\/\/ anytrue\n+\n+instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, zr);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(KILL cr);\n+  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    __ sve_ptest(ptrue, $src1$$PRegister);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ uminv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, 0xff);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    __ sve_eors($ptmp$$PRegister, ptrue, $src1$$PRegister, $src2$$PRegister);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -----------------------------\n+\n+\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n+\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n+\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n+\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n+\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n+\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+\/\/   6. Use Vm as index register, and use V1 as table register.\n+\/\/      Then get V2 as the result by tbl NEON instructions.\n+\/\/ Notes:\n+\/\/   Step 1 matches VectorLoadConst.\n+\/\/   Step 3 matches VectorLoadShuffle.\n+\/\/   Step 4, 5, 6 match VectorRearrange.\n+\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n+\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n+\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n+\/\/   to implement rearrange.\n+\n+instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n+              Matcher::vector_length_in_bytes(n) == 16)));\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_SHORT) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n+      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n+      __ mov($tmp1$$FloatRegister, size1, 0x02);\n+      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n+      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    } else {\n+      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n+      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n+      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n+      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n+  format %{ \"rearrange $dst, $src, $shuffle\" %}\n+  ins_encode %{\n+    BasicType bt_dst = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt_dst == T_BYTE && VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt_src = Matcher::vector_element_basic_type(this, $src);\n+      __ sve_tbl($dst$$FloatRegister, __ elemType_to_regVariant(bt_src),\n+                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGather mem idx));\n+  format %{ \"gather_loadS $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1w_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD $dst, $mem, $idx\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, ptrue, as_Register($mem$$base),\n+                       $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  format %{ \"gather_loadS_masked $dst, $pg, $mem, $idx\" %}\n+  ins_encode %{\n+    __ sve_ld1w_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD_masked $dst, $pg, $mem, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_storeS(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  format %{ \"scatter_storeS $mem, $idx, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_st1w_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD $mem, $idx, $src\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeS_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  format %{ \"scatter_storeS_masked $mem, $pg, $idx, $src\" %}\n+  ins_encode %{\n+    __ sve_st1w_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD_masked $mem, $pg, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountLeadingZerosV ---------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"vcountLeadingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+      } else {\n+        __ sve_clz($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_clz($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+\n+instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountLeadingZerosV dst_src pg));\n+  format %{ \"vcountLeadingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_clz($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  format %{ \"vcountTrailingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, __ B, ptrue, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+        if (bt != T_LONG) {\n+          __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+        } else {\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 0);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 1);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+        }\n+      } else {\n+        Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+        __ sve_rbit($dst$$FloatRegister, size, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  format %{ \"vcountTrailingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit($dst_src$$FloatRegister, size,\n+                $pg$$PRegister, $dst_src$$FloatRegister);\n+    __ sve_clz($dst_src$$FloatRegister, size,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseV -------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  format %{ \"vreverse $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+      } else {\n+        __ sve_rbit($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+\n+instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseV dst_src pg));\n+  format %{ \"vreverse_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_rbit($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseBytesV --------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  format %{ \"vreverseBytes $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ neon_reverse_bytes($dst$$FloatRegister, $src$$FloatRegister,\n+                              bt, \/* isQ *\/ length_in_bytes == 16);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_revb($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  format %{ \"vreverseBytes_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $dst_src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  format %{ \"populateindex $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_index($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $src1$$Register, (int)($src2$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  format %{ \"mcompress $dst, $pg\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, $pg$$PRegister);\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompress $dst, $src, $pg\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compact($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   $src$$FloatRegister, $pg$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressS $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_short($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vexpand $dst, $pg, $src\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup($dst$$FloatRegister, size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt($dst$$FloatRegister, size, $pg$$PRegister,\n+                   $dst$$FloatRegister, $dst$$FloatRegister);\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub($dst$$FloatRegister, size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":6361,"deletions":0,"binary":false,"changes":6361,"status":"added"},{"patch":"@@ -0,0 +1,4701 @@\n+\/\/\n+\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+dnl Generate the warning\n+\/\/ This file is automatically generated by running \"m4 aarch64_vector_ad.m4\". Do not edit!\n+dnl\n+\n+\/\/ AArch64 VECTOR Architecture Description File\n+\n+\n+dnl\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2      )\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type)\n+define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n+operand vmemA_imm$1Offset4() %{\n+  \/\/ (esize \/ msize) = 1\n+  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(Con$1);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}')dnl\n+dnl\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1           )\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr)\n+define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n+operand vmemA_indOff$1`'4(iRegP reg, vmemA_imm$1Offset4 off) %{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    `index'(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}')dnl\n+dnl\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int)\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(I)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(L)\n+\n+\/\/ The indOff of vmemA is valid only when the vector element (load to\/store from)\n+\/\/ size equals to memory element (load from\/store to) size.\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n);\n+%}\n+\n+source %{\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,\n+                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,\n+                                    int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    int mesize = type2aelembytes(mem_elem_bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(mesize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      int imm4 = disp \/ mesize \/ Matcher::scalable_vector_reg_size(vector_elem_bt);\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+    if (UseSVE == 0) {\n+      \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n+      \/\/ NEON instructions support them. But the match rule support for them is profitable for\n+      \/\/ Vector API intrinsics.\n+      if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n+          (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n+        return false;\n+      }\n+    }\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  \/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n+  \/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n+  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+    if (!match_rule_supported(opcode)) {\n+      return false;\n+    }\n+\n+    int length_in_bytes = vlen * type2aelembytes(bt);\n+    if (UseSVE == 0 && length_in_bytes > 16) {\n+      return false;\n+    }\n+\n+    \/\/ Check whether specific Op is supported.\n+    \/\/ Fail fast, otherwise fall through to common vector_size_supported() check.\n+    switch (opcode) {\n+      case Op_MulVL:\n+      case Op_AndVMask:\n+      case Op_OrVMask:\n+      case Op_XorVMask:\n+      case Op_MaskAll:\n+      case Op_VectorMaskGen:\n+      case Op_LoadVectorMasked:\n+      case Op_StoreVectorMasked:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_LoadVectorGatherMasked:\n+      case Op_StoreVectorScatterMasked:\n+      case Op_PopulateIndex:\n+      case Op_CompressM:\n+      case Op_CompressV:\n+        if (UseSVE == 0) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulAddVS2VI:\n+        if (length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ No vector multiply reduction instructions, but we do\n+        \/\/ emit scalar instructions for 64\/128-bit vectors.\n+        if (length_in_bytes != 8 && length_in_bytes != 16) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskCmp:\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLoadShuffle:\n+      case Op_VectorRearrange:\n+        if (vlen < 4) {\n+          return false;\n+        }\n+        break;\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorMaskToLong:\n+        if (UseSVE > 0 && vlen > 64) {\n+          return false;\n+        }\n+        break;\n+      case Op_VectorLongToMask:\n+        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+          return false;\n+        }\n+        break;\n+      default:\n+        break;\n+    }\n+    return vector_size_supported(bt, vlen);\n+  }\n+\n+  const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+    \/\/ Only SVE supports masked operations.\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    \/\/ If an opcode does not support the masked version,\n+    \/\/ unpredicated node with VectorBlend node will be used instead.\n+    switch(opcode) {\n+      case Op_VectorRearrange:\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        return false;\n+      \/\/ We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.\n+      \/\/ Hence we turn to check whether Op_LoadVectorMasked is supported. The\n+      \/\/ same as vector store\/gather\/scatter.\n+      case Op_LoadVector:\n+        opcode = Op_LoadVectorMasked;\n+        break;\n+      case Op_StoreVector:\n+        opcode = Op_StoreVectorMasked;\n+        break;\n+      case Op_LoadVectorGather:\n+        opcode = Op_LoadVectorGatherMasked;\n+        break;\n+      case Op_StoreVectorScatter:\n+        opcode = Op_StoreVectorScatterMasked;\n+        break;\n+      default:\n+        break;\n+    }\n+\n+    return match_rule_supported_vector(opcode, vlen, bt);\n+  }\n+\n+  const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+    \/\/ Only SVE has partial vector operations\n+    if (UseSVE == 0) {\n+      return false;\n+    }\n+\n+    switch(node->Opcode()) {\n+      case Op_VectorLoadMask:\n+      case Op_VectorMaskCmp:\n+      case Op_LoadVectorGather:\n+      case Op_StoreVectorScatter:\n+      case Op_AddReductionVF:\n+      case Op_AddReductionVD:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      \/\/ Mask is needed for partial Op_VectorMaskFirstTrue, because when the\n+      \/\/ input predicate is all-false, the result should be the vector length\n+      \/\/ instead of the vector register size.\n+      case Op_VectorMaskFirstTrue:\n+        return true;\n+      case Op_MaskAll:\n+        return !node->in(1)->is_Con();\n+      case Op_LoadVector:\n+      case Op_StoreVector:\n+        \/\/ We use NEON load\/store instructions if the vector length is <= 128 bits.\n+        return vt->length_in_bytes() > 16;\n+      case Op_AddReductionVI:\n+      case Op_AddReductionVL:\n+        \/\/ We may prefer using NEON instructions rather than SVE partial operations.\n+        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ For BYTE\/SHORT\/INT\/FLOAT\/DOUBLE types, we may prefer using NEON\n+        \/\/ instructions rather than SVE partial operations.\n+        return vt->element_basic_type() == T_LONG ||\n+               !VM_Version::use_neon_for_vector(vt->length_in_bytes());\n+      default:\n+        \/\/ For other ops whose vector size is smaller than the max vector size, a\n+        \/\/ full-sized unpredicated operation does not impact the final vector result.\n+        return false;\n+    }\n+  }\n+\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n) {\n+    assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+    return true;\n+  }\n+\n+  Assembler::SIMD_Arrangement get_arrangement(const Node* n) {\n+    BasicType bt = Matcher::vector_element_basic_type(n);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(n);\n+    return Assembler::esize2arrangement((uint)type2aelembytes(bt),\n+                                        \/* isQ *\/ length_in_bytes == 16);\n+  }\n+%}\n+\n+\n+\/\/ All VECTOR instructions\n+\n+\/\/ ------------------------------ Vector load\/store ----------------------------\n+dnl\n+dnl VECTOR_LOAD_STORE($1,   $2,     $3,       $4,    $5  )\n+dnl VECTOR_LOAD_STORE(type, nbytes, arg_name, nbits, size)\n+define(`VECTOR_LOAD_STORE', `\n+\/\/ ifelse(load, $1, Load, Store) Vector ($4 bits)\n+instruct $1V$2(vReg $3, vmem$2 mem) %{\n+  predicate(`n->as_'ifelse(load, $1, Load, Store)Vector()->memory_size() == $2);\n+  match(Set ifelse(load, $1, dst (LoadVector mem), mem (StoreVector mem src)));\n+  format %{ \"$1V$2 ifelse(load, $1, `$dst, $mem', `$mem, $src')\\t# vector ($4 bits)\" %}\n+  ins_encode( `aarch64_enc_'ifelse(load, $1, ldr, str)v$5($3, mem) );\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VECTOR_LOAD_STORE(load,  2,  dst, 16,  H)\n+VECTOR_LOAD_STORE(store, 2,  src, 16,  H)\n+VECTOR_LOAD_STORE(load,  4,  dst, 32,  S)\n+VECTOR_LOAD_STORE(store, 4,  src, 32,  S)\n+VECTOR_LOAD_STORE(load,  8,  dst, 64,  D)\n+VECTOR_LOAD_STORE(store, 8,  src, 64,  D)\n+VECTOR_LOAD_STORE(load,  16, dst, 128, Q)\n+VECTOR_LOAD_STORE(store, 16, src, 128, Q)\n+\n+\/\/ Load Vector (> 128 bits)\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(n->as_LoadVector()->memory_size() > 16);\n+  match(Set dst (LoadVector mem));\n+  format %{ \"loadV $dst, $mem\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false,\n+                          $dst$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Store Vector (> 128 bits)\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(n->as_StoreVector()->memory_size() > 16);\n+  match(Set mem (StoreVector mem src));\n+  format %{ \"storeV $mem, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true,\n+                          $src$$FloatRegister, ptrue, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load\/store - predicated\n+\n+instruct loadV_masked(vReg dst, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (LoadVectorMasked mem pg));\n+  format %{ \"loadV_masked $dst, $pg, $mem\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ false, $dst$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV_masked(vReg src, vmemA mem, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set mem (StoreVectorMasked mem (Binary src pg)));\n+  format %{ \"storeV_masked $mem, $pg, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), \/* is_store *\/ true, $src$$FloatRegister,\n+                          $pg$$PRegister, bt, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector load const\n+\n+instruct vloadconB(vReg dst, immI0 src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadConst src));\n+  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      if (length_in_bytes == 16) {\n+        __ ldrq($dst$$FloatRegister, rscratch1);\n+      } else {\n+        __ ldrd($dst$$FloatRegister, rscratch1);\n+      }\n+    } else {\n+      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl BINARY_OP($1,        $2,      $3,        $4,       $5  )\n+dnl BINARY_OP(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`BINARY_OP', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, __ $5, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BINARY_OP_PREDICATE($1,        $2,      $3,   $4  )\n+dnl BINARY_OP_PREDICATE(rule_name, op_name, insn, size)\n+define(`BINARY_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst_src1$$FloatRegister, __ $4, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VADD_IMM($1,   $2,       $3  )\n+dnl VADD_IMM(type, imm_type, size)\n+define(`VADD_IMM', `\n+instruct vaddImm$1(vReg dst_src, $2 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n+  format %{ \"vaddImm$1 $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    int val = (int)$con$$constant;\n+    if (val > 0) {\n+      __ sve_add($dst_src$$FloatRegister, __ $3, val);\n+    } else {\n+      __ sve_sub($dst_src$$FloatRegister, __ $3, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector add -----------------------------------\n+\n+\/\/ vector add\n+BINARY_OP(vaddB, AddVB, addv, sve_add,  B)\n+BINARY_OP(vaddS, AddVS, addv, sve_add,  H)\n+BINARY_OP(vaddI, AddVI, addv, sve_add,  S)\n+BINARY_OP(vaddL, AddVL, addv, sve_add,  D)\n+BINARY_OP(vaddF, AddVF, fadd, sve_fadd, S)\n+BINARY_OP(vaddD, AddVD, fadd, sve_fadd, D)\n+\n+\/\/ vector add - predicated\n+BINARY_OP_PREDICATE(vaddB, AddVB, sve_add,  B)\n+BINARY_OP_PREDICATE(vaddS, AddVS, sve_add,  H)\n+BINARY_OP_PREDICATE(vaddI, AddVI, sve_add,  S)\n+BINARY_OP_PREDICATE(vaddL, AddVL, sve_add,  D)\n+BINARY_OP_PREDICATE(vaddF, AddVF, sve_fadd, S)\n+BINARY_OP_PREDICATE(vaddD, AddVD, sve_fadd, D)\n+\n+\/\/ vector add reg imm (unpredicated)\n+VADD_IMM(B, immBAddSubV, B)\n+VADD_IMM(S, immIAddSubV, H)\n+VADD_IMM(I, immIAddSubV, S)\n+VADD_IMM(L, immLAddSubV, D)\n+\n+\/\/ ------------------------------ Vector sub -----------------------------------\n+\n+\/\/ vector sub\n+BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n+BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n+BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n+BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n+BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n+BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+\n+\/\/ vector sub - predicated\n+BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+\n+dnl\n+dnl BINARY_OP_NEON_SVE_PAIRWISE($1,        $2,      $3,        $4,       $5  )\n+dnl BINARY_OP_NEON_SVE_PAIRWISE(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`BINARY_OP_NEON_SVE_PAIRWISE', `\n+instruct $1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct $1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"$1_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ $4($dst_src1$$FloatRegister, __ $5, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector mul -----------------------------------\n+\n+\/\/ vector mul - BYTE, CHAR, SHORT, INT\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulB, MulVB, mulv, sve_mul, B)\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulS, MulVS, mulv, sve_mul, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vmulI, MulVI, mulv, sve_mul, S)\n+\n+\/\/ vector mul - LONG\n+\n+instruct vmulL_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (MulVL src1 src2));\n+  format %{ \"vmulL_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 16, \"must be\");\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 0);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 0);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 0, rscratch2);\n+    __ umov(rscratch1, $src1$$FloatRegister, __ D, 1);\n+    __ umov(rscratch2, $src2$$FloatRegister, __ D, 1);\n+    __ mul(rscratch2, rscratch2, rscratch1);\n+    __ mov($dst$$FloatRegister, __ D, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  format %{ \"vmulL_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_mul($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mul - floating-point\n+BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n+BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+\n+\/\/ vector mul - predicated\n+BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+\n+\/\/ ------------------------------ Vector float div -----------------------------\n+\n+\/\/ vector float div\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+\n+\/\/ vector float div - predicated\n+BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+dnl\n+dnl BITWISE_OP($1,        $2,      $3,        $4      )\n+dnl BITWISE_OP(rule_name, op_name, insn_neon, insn_sve)\n+define(`BITWISE_OP', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_OP_PREDICATE($1,        $2,      $3  )\n+dnl BITWISE_OP_PREDICATE(rule_name, op_name, insn)\n+define(`BITWISE_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_OP_IMM($1,        $2,   $3,      $4,   $5  )\n+dnl BITWISE_OP_IMM(rule_name, type, op_name, insn, size)\n+define(`BITWISE_OP_IMM', `\n+instruct $1(vReg dst_src, imm$2Log con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($3 dst_src (Replicate$2 con)));\n+  format %{ \"$1 $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ $4($dst_src$$FloatRegister, __ $5, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\n+\/\/ ------------------------------ Vector and -----------------------------------\n+\n+\/\/ vector and\n+BITWISE_OP(vand, AndV, andr, sve_and)\n+\n+\/\/ vector and - predicated\n+BITWISE_OP_PREDICATE(vand, AndV, sve_and)\n+\n+\/\/ vector and reg imm (unpredicated)\n+BITWISE_OP_IMM(vandImmB, B, AndV, sve_and, B)\n+BITWISE_OP_IMM(vandImmS, S, AndV, sve_and, H)\n+BITWISE_OP_IMM(vandImmI, I, AndV, sve_and, S)\n+BITWISE_OP_IMM(vandImmL, L, AndV, sve_and, D)\n+\n+\/\/ ------------------------------ Vector or ------------------------------------\n+\n+\/\/ vector or\n+BITWISE_OP(vor, OrV, orr, sve_orr)\n+\n+\/\/ vector or - predicated\n+BITWISE_OP_PREDICATE(vor, OrV, sve_orr)\n+\n+\/\/ vector or reg imm (unpredicated)\n+BITWISE_OP_IMM(vorImmB, B, OrV, sve_orr, B)\n+BITWISE_OP_IMM(vorImmS, S, OrV, sve_orr, H)\n+BITWISE_OP_IMM(vorImmI, I, OrV, sve_orr, S)\n+BITWISE_OP_IMM(vorImmL, L, OrV, sve_orr, D)\n+\n+\/\/ ------------------------------ Vector xor -----------------------------------\n+\n+\/\/ vector xor\n+BITWISE_OP(vxor, XorV, eor, sve_eor)\n+\n+\/\/ vector xor - predicated\n+BITWISE_OP_PREDICATE(vxor, XorV, sve_eor)\n+\n+\/\/ vector xor reg imm (unpredicated)\n+BITWISE_OP_IMM(vxorImmB, B, XorV, sve_eor, B)\n+BITWISE_OP_IMM(vxorImmS, S, XorV, sve_eor, H)\n+BITWISE_OP_IMM(vxorImmI, I, XorV, sve_eor, S)\n+BITWISE_OP_IMM(vxorImmL, L, XorV, sve_eor, D)\n+\n+\/\/ ------------------------------ Vector not -----------------------------------\n+\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (XorV src (ReplicateB m1)));\n+  match(Set dst (XorV src (ReplicateS m1)));\n+  match(Set dst (XorV src (ReplicateI m1)));',\n+`match(Set dst (XorV src (ReplicateL m1)));')')dnl\n+dnl\n+dnl VECTOR_NOT($1  )\n+dnl VECTOR_NOT(type)\n+define(`VECTOR_NOT', `\n+instruct vnot$1`'(vReg dst, vReg src, imm$1_M1 m1) %{\n+  MATCH_RULE($1)\n+  format %{ \"vnot$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ notr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_not($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector not\n+VECTOR_NOT(I)\n+VECTOR_NOT(L)\n+undefine(MATCH_RULE)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateB m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateS m1)) pg));\n+  match(Set dst_src (XorV (Binary dst_src (ReplicateI m1)) pg));',\n+`match(Set dst_src (XorV (Binary dst_src (ReplicateL m1)) pg));')')dnl\n+dnl\n+dnl VECTOR_NOT_PREDICATE($1  )\n+dnl VECTOR_NOT_PREDICATE(type)\n+define(`VECTOR_NOT_PREDICATE', `\n+instruct vnot$1_masked`'(vReg dst_src, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  format %{ \"vnot$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_not($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector not - predicated\n+VECTOR_NOT_PREDICATE(I)\n+VECTOR_NOT_PREDICATE(L)\n+undefine(MATCH_RULE)\n+dnl\n+\/\/ ------------------------------ Vector and_not -------------------------------\n+\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateB m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateS m1))));\n+  match(Set dst (AndV src1 (XorV src2 (ReplicateI m1))));',\n+`match(Set dst (AndV src1 (XorV src2 (ReplicateL m1))));')')dnl\n+dnl\n+dnl VECTOR_AND_NOT($1  )\n+dnl VECTOR_AND_NOT(type)\n+define(`VECTOR_AND_NOT', `\n+instruct vand_not$1`'(vReg dst, vReg src1, vReg src2, imm$1_M1 m1) %{\n+  MATCH_RULE($1)\n+  format %{ \"vand_not$1 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ bic($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_bic($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector and_not\n+VECTOR_AND_NOT(I)\n+VECTOR_AND_NOT(L)\n+undefine(MATCH_RULE)\n+dnl\n+define(`MATCH_RULE', `ifelse($1, I,\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateB m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateS m1))) pg));\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateI m1))) pg));',\n+`match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (ReplicateL m1))) pg));')')dnl\n+dnl\n+dnl VECTOR_AND_NOT_PREDICATE($1  )\n+dnl VECTOR_AND_NOT_PREDICATE(type)\n+define(`VECTOR_AND_NOT_PREDICATE', `\n+instruct vand_not$1_masked`'(vReg dst_src1, vReg src2, imm$1_M1 m1, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  MATCH_RULE($1)\n+  format %{ \"vand_not$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_bic($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector and_not - predicated\n+VECTOR_AND_NOT_PREDICATE(I)\n+VECTOR_AND_NOT_PREDICATE(L)\n+undefine(MATCH_RULE)\n+dnl\n+dnl UNARY_OP($1,        $2,      $3,        $4,       $5  )\n+dnl UNARY_OP(rule_name, op_name, insn_neon, insn_sve, size)\n+define(`UNARY_OP', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst ($2 src));\n+  format %{ \"$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ $4($dst$$FloatRegister, __ $5, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl UNARY_OP_PREDICATE($1,        $2,      $3  )\n+dnl UNARY_OP_PREDICATE(rule_name, op_name, insn)\n+define(`UNARY_OP_PREDICATE', `\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  format %{ \"$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl UNARY_OP_PREDICATE_WITH_SIZE($1,        $2,      $3,   $4  )\n+dnl UNARY_OP_PREDICATE_WITH_SIZE(rule_name, op_name, insn, size)\n+define(`UNARY_OP_PREDICATE_WITH_SIZE', `\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  format %{ \"$1_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ $3($dst_src$$FloatRegister, __ $4, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector abs -----------------------------------\n+\n+\/\/ vector abs\n+UNARY_OP(vabsB, AbsVB, absr, sve_abs,  B)\n+UNARY_OP(vabsS, AbsVS, absr, sve_abs,  H)\n+UNARY_OP(vabsI, AbsVI, absr, sve_abs,  S)\n+UNARY_OP(vabsL, AbsVL, absr, sve_abs,  D)\n+UNARY_OP(vabsF, AbsVF, fabs, sve_fabs, S)\n+UNARY_OP(vabsD, AbsVD, fabs, sve_fabs, D)\n+\n+\/\/ vector abs - predicated\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsB, AbsVB, sve_abs,  B)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsS, AbsVS, sve_abs,  H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsI, AbsVI, sve_abs,  S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsL, AbsVL, sve_abs,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsF, AbsVF, sve_fabs, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsD, AbsVD, sve_fabs, D)\n+\n+\/\/ ------------------------------ Vector fabd ----------------------------------\n+\n+\/\/ vector fabs diff\n+\n+instruct vfabd(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AbsVF (SubVF src1 src2)));\n+  match(Set dst (AbsVD (SubVD src1 src2)));\n+  format %{ \"vfabd $dst, $src1, $src2\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    __ fabd($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector neg -----------------------------------\n+\n+\/\/ vector neg\n+\n+instruct vnegI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (NegVI src));\n+  format %{ \"vnegI $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_neg($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+UNARY_OP(vnegL, NegVL, negr, sve_neg,  D)\n+UNARY_OP(vnegF, NegVF, fneg, sve_fneg, S)\n+UNARY_OP(vnegD, NegVD, fneg, sve_fneg, D)\n+\n+\/\/ vector neg - predicated\n+UNARY_OP_PREDICATE(vnegI, NegVI, sve_neg)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegL, NegVL, sve_neg,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegF, NegVF, sve_fneg, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegD, NegVD, sve_fneg, D)\n+\n+\/\/ ------------------------------ Vector sqrt ----------------------------------\n+\n+\/\/ vector sqrt\n+UNARY_OP(vsqrtF, SqrtVF, fsqrt, sve_fsqrt, S)\n+UNARY_OP(vsqrtD, SqrtVD, fsqrt, sve_fsqrt, D)\n+\n+\/\/ vector sqrt - predicated\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtF, SqrtVF, sve_fsqrt, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vsqrtD, SqrtVD, sve_fsqrt, D)\n+\n+dnl\n+dnl VMINMAX_L_NEON($1,   $2     )\n+dnl VMINMAX_L_NEON(type, op_name)\n+define(`VMINMAX_L_NEON', `\n+instruct v$1L_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"v$1L_neon $dst, $src1, $src2\\t# 2L\" %}\n+  ins_encode %{\n+    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ bsl($dst$$FloatRegister, __ T16B, ifelse(min, $1, $src2, $src1)$$FloatRegister, ifelse(min, $1, $src1, $src2)$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_L_SVE($1,   $2,      $3  )\n+dnl VMINMAX_L_SVE(type, op_name, insn)\n+define(`VMINMAX_L_SVE', `\n+instruct v$1L_sve(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"v$1L_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ $3($dst_src1$$FloatRegister, __ D, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_NEON($1,   $2,      $3,      $4           )\n+dnl VMINMAX_NEON(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_NEON', `\n+instruct v$1_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"v$1_neon $dst, $src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ $4($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_SVE($1,   $2,      $3,      $4           )\n+dnl VMINMAX_SVE(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_SVE', `\n+instruct v$1_sve(vReg dst_src1, vReg src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_LONG &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"v$1_sve $dst_src1, $dst_src1, $src2\\t# B\/S\/I\/F\/D\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt) && bt != T_LONG, \"unsupported type\");\n+      __ $4($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMINMAX_PREDICATE($1,   $2,      $3,      $4           )\n+dnl VMINMAX_PREDICATE(type, op_name, insn_fp, insn_integral)\n+define(`VMINMAX_PREDICATE', `\n+instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n+  format %{ \"v$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(bt)) {\n+      __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(is_integral_type(bt), \"unsupported type\");\n+      __ $4($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector min -----------------------------------\n+\n+\/\/ vector min - LONG\n+VMINMAX_L_NEON(min, MinV)\n+VMINMAX_L_SVE(min, MinV, sve_smin)\n+\n+\/\/ vector min - B\/S\/I\/F\/D\n+VMINMAX_NEON(min, MinV, fmin, minv)\n+VMINMAX_SVE(min, MinV, sve_fmin, sve_smin)\n+\n+\/\/ vector min - predicated\n+VMINMAX_PREDICATE(min, MinV, sve_fmin, sve_smin)\n+\n+\/\/ ------------------------------ Vector max -----------------------------------\n+\n+\/\/ vector max - LONG\n+VMINMAX_L_NEON(max, MaxV)\n+VMINMAX_L_SVE(max, MaxV, sve_smax)\n+\n+\/\/ vector max - B\/S\/I\/F\/D\n+VMINMAX_NEON(max, MaxV, fmax, maxv)\n+VMINMAX_SVE(max, MaxV, sve_fmax, sve_smax)\n+\n+\/\/ vector max - predicated\n+VMINMAX_PREDICATE(max, MaxV, sve_fmax, sve_smax)\n+\n+\/\/ ------------------------------ MLA RELATED ----------------------------------\n+\n+\/\/ vector mla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmla $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlav does not accept T2D arrangement.\n+      __ mlav($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmla_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (AddVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (AddVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (AddVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmla_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+\n+instruct vfmla(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  format %{ \"vfmla $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmla($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmad - predicated\n+\/\/ dst_src1 = dst_src1 * src2 + src3\n+\n+instruct vfmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0);\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary src3 pg)));\n+  format %{ \"vfmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+\n+instruct vmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  format %{ \"vmls $dst_src1, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes) && bt != T_LONG) {\n+      \/\/ NEON mlsv does not accept T2D arrangement.\n+      __ mlsv($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmls_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVB (Binary dst_src1 (MulVB src2 src3)) pg));\n+  match(Set dst_src1 (SubVS (Binary dst_src1 (MulVS src2 src3)) pg));\n+  match(Set dst_src1 (SubVI (Binary dst_src1 (MulVI src2 src3)) pg));\n+  match(Set dst_src1 (SubVL (Binary dst_src1 (MulVL src2 src3)) pg));\n+  format %{ \"vmls_masked $dst_src1, $pg, src2, src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_mls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  format %{ \"vfmls1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmls2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  format %{ \"vfmls2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmls($dst_src1$$FloatRegister, get_arrangement(this),\n+              $src2$$FloatRegister, $src3$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_fmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmsb - predicated\n+\n+\/\/ dst_src1 = dst_src1 * -src2 + src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary src3 pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary src3 pg)));\n+  format %{ \"vfmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  format %{ \"vfnmla1 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmla2(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(2)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  format %{ \"vfnmla2 $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmla($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmad - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * -src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmad_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->in(2)->as_Vector()->is_predicated_vector() &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 (NegVF src2)) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 (NegVD src2)) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmad_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmad($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls (sve)\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmls(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  format %{ \"vfnmls $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmls($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 ptrue, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmsb - predicated\n+\n+\/\/ dst_src1 = -src3 + dst_src1 * src2\n+\/\/ The NegVF\/NegVD must not be predicated.\n+instruct vfnmsb_masked(vReg dst_src1, vReg src2, vReg src3, pRegGov pg) %{\n+  predicate(UseFMA && UseSVE > 0 &&\n+            !n->in(2)->in(1)->as_Vector()->is_predicated_vector());\n+  match(Set dst_src1 (FmaVF (Binary dst_src1 src2) (Binary (NegVF src3) pg)));\n+  match(Set dst_src1 (FmaVD (Binary dst_src1 src2) (Binary (NegVD src3) pg)));\n+  format %{ \"vfnmsb_masked $dst_src1, $pg, $src2, $src3\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fnmsb($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $pg$$PRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ MulAddVS2VI\n+\/\/ Vector Multiply-Add Shorts into Integer\n+\n+instruct vmuladdS2I(vReg dst, vReg src1, vReg src2, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);\n+  match(Set dst (MulAddVS2VI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmuladdS2I $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ smullv($tmp$$FloatRegister, __ T4H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ smullv($dst$$FloatRegister, __ T8H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ addpv($dst$$FloatRegister, __ T4S, $tmp$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shift ---------------------------------\n+\n+\/\/ Vector right shift in AArch64 ASIMD\n+\/\/\n+\/\/ Right shifts with vector shift count on AArch64 ASIMD are implemented\n+\/\/ as left shift by negative shift count.\n+\/\/ There are two cases for vector shift count.\n+\/\/\n+\/\/ Case 1: The vector shift count is from replication.\n+\/\/        |            |\n+\/\/    LoadVector  RShiftCntV\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ Case 2: The vector shift count is from loading.\n+\/\/ This case isn't supported by middle-end now. But it's supported by\n+\/\/ panama\/vectorIntrinsics(JEP 338: Vector API).\n+\/\/        |            |\n+\/\/    LoadVector  LoadVector\n+\/\/        |       \/\n+\/\/     RShiftVI\n+\/\/\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n+\n+\/\/ vector shift count\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (LShiftCntV cnt));\n+  format %{ \"vshiftcntL $dst, $cnt\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $cnt$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntR(vReg dst, iRegIorL2I cnt) %{\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"vshiftcntR $dst, $cnt\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes <= 16, \"must be\");\n+      __ negw(rscratch1, $cnt$$Register);\n+      __ dup($dst$$FloatRegister, get_arrangement(this), rscratch1);\n+    } else {\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_dup($dst$$FloatRegister, __ elemType_to_regVariant(bt), $cnt$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift left\n+\n+instruct vlsl_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVL src shift));\n+  format %{ \"vlsl_neon $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sshl($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsl_sve(vReg dst_src, vReg shift) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src (LShiftVB dst_src shift));\n+  match(Set dst_src (LShiftVS dst_src shift));\n+  match(Set dst_src (LShiftVI dst_src shift));\n+  match(Set dst_src (LShiftVL dst_src shift));\n+  format %{ \"vlsl_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_lsl($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl VRSHIFT_NEON($1,   $2,      $3  )\n+dnl VRSHIFT_NEON(type, op_name, insn)\n+define(`VRSHIFT_NEON', `\n+instruct v$1_neon(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && !n->as_ShiftV()->is_var_shift());\n+  match(Set dst ($2VB src shift));\n+  match(Set dst ($2VS src shift));\n+  match(Set dst ($2VI src shift));\n+  match(Set dst ($2VL src shift));\n+  format %{ \"v$1_neon $dst, $src, $shift\\t# not variable shift\" %}\n+  ins_encode %{\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VRSHIFT_NEON_VAR($1,   $2,      $3  )\n+dnl VRSHIFT_NEON_VAR(type, op_name, insn)\n+define(`VRSHIFT_NEON_VAR', `\n+instruct v$1_neon_var(vReg dst, vReg src, vReg shift) %{\n+  predicate(UseSVE == 0 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst ($2VB src shift));\n+  match(Set dst ($2VS src shift));\n+  match(Set dst ($2VI src shift));\n+  match(Set dst ($2VL src shift));\n+  effect(TEMP_DEF dst);\n+  format %{ \"v$1_neon_var $dst, $src, $shift\\t# variable shift\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $shift$$FloatRegister);\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VRSHIFT_SVE($1,   $2,      $3  )\n+dnl VRSHIFT_SVE(type, op_name, insn)\n+define(`VRSHIFT_SVE', `\n+instruct v$1_sve(vReg dst_src, vReg shift) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2VB dst_src shift));\n+  match(Set dst_src ($2VS dst_src shift));\n+  match(Set dst_src ($2VI dst_src shift));\n+  match(Set dst_src ($2VL dst_src shift));\n+  format %{ \"v$1_sve $dst_src, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $shift$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector shift right (arithmetic)\n+VRSHIFT_NEON(asr, RShift, sshl)\n+VRSHIFT_NEON_VAR(asr, RShift, sshl)\n+VRSHIFT_SVE(asr, RShift, sve_asr)\n+\n+\/\/ vector shift right (logical)\n+VRSHIFT_NEON(lsr, URShift, ushl)\n+VRSHIFT_NEON_VAR(lsr, URShift, ushl)\n+VRSHIFT_SVE(lsr, URShift, sve_lsr)\n+\n+\/\/ vector shift with imm\n+\n+instruct vlsl_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n+  format %{ \"vlsl_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ shl($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsl($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n+  format %{ \"vasr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ sshr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_asr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsr_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(assert_not_var_shift(n));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n+  format %{ \"vlsr_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Optimize for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ eor($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_eor($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+        return;\n+      }\n+    }\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ ushr($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_lsr($dst$$FloatRegister, __ elemType_to_regVariant(bt), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ shift right add with imm (vector length <= 128 bits only)\n+\n+instruct vasra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  format %{ \"vasra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) {\n+      \/\/ Refine con for B\/S\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con >= esize_in_bits) con = esize_in_bits - 1;\n+    }\n+    __ ssra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsra_imm(vReg dst, vReg src, immI_positive shift) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  format %{ \"vlsra_imm $dst, $src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int con = (int)$shift$$constant;\n+    if (is_subword_type(bt)) { \/\/ for B\/H\n+      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+      if (con < esize_in_bits) {\n+        __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+      }\n+    } else { \/\/ for S\/D\n+      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, \"unsupported type\");\n+      __ usra($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister, con);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl VSHIFT_PREDICATE($1,   $2,      $3  )\n+dnl VSHIFT_PREDICATE(type, op_name, insn)\n+define(`VSHIFT_PREDICATE', `\n+instruct v$1_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 ($2VB (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VS (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VI (Binary dst_src1 src2) pg));\n+  match(Set dst_src1 ($2VL (Binary dst_src1 src2) pg));\n+  format %{ \"v$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $3($dst_src1$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_IMM_PREDICATE($1,   $2,       $3,       $4,       $5  )\n+dnl VSHIFT_IMM_PREDICATE(type, arg_type, op_name1, op_name2, insn)\n+define(`VSHIFT_IMM_PREDICATE', `\n+instruct v$1_imm_masked(vReg dst_src, $2 shift, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($3VB (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VS (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VI (Binary dst_src ($4 shift)) pg));\n+  match(Set dst_src ($3VL (Binary dst_src ($4 shift)) pg));\n+  format %{ \"v$1_imm_masked $dst_src, $pg, $dst_src, $shift\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;\n+    int con = (int)$shift$$constant;\n+    assert(con ifelse($1, lsl, >=, >) 0 && con < esize_in_bits, \"invalid shift immediate\");\n+    __ $5($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector shift - predicated\n+VSHIFT_PREDICATE(lsl, LShift,  sve_lsl)\n+VSHIFT_PREDICATE(asr, RShift,  sve_asr)\n+VSHIFT_PREDICATE(lsr, URShift, sve_lsr)\n+\n+\/\/ vector shift with imm - predicated\n+VSHIFT_IMM_PREDICATE(lsl, immI,          LShift,  LShiftCntV, sve_lsl)\n+VSHIFT_IMM_PREDICATE(asr, immI_positive, RShift,  RShiftCntV, sve_asr)\n+VSHIFT_IMM_PREDICATE(lsr, immI_positive, URShift, RShiftCntV, sve_lsr)\n+\n+\/\/ ------------------------------ Vector reduction add -------------------------\n+\n+dnl\n+dnl REDUCE_ADD_INT_NEON_SVE_PAIRWISE($1,   $2      )\n+dnl REDUCE_ADD_INT_NEON_SVE_PAIRWISE(type, arg_type)\n+define(`REDUCE_ADD_INT_NEON_SVE_PAIRWISE', `\n+instruct reduce_add$1_neon(iReg$1NoSp dst, $2 isrc, vReg vsrc, vReg tmp) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionV$1 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_neon $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_add_integral($dst$$Register, bt,\n+                                $isrc$$Register, $vsrc$$FloatRegister,\n+                                length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_add$1_sve(iReg$1NoSp dst, $2 isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))));\n+  match(Set dst (AddReductionV$1 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ reduction addI\n+REDUCE_ADD_INT_NEON_SVE_PAIRWISE(I, iRegIorL2I)\n+\n+\/\/ reduction addL\n+REDUCE_ADD_INT_NEON_SVE_PAIRWISE(L, iRegL)\n+\n+\/\/ reduction addF\n+\n+instruct reduce_addF_neon(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addF_neon $dst, $fsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ fadds($dst$$FloatRegister, $fsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 1);\n+    __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    if (length_in_bytes == 16) {\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 2);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ ins($tmp$$FloatRegister, __ S, $vsrc$$FloatRegister, 0, 3);\n+      __ fadds($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl REDUCE_ADD_FP_SVE($1,   $2  )\n+dnl REDUCE_ADD_FP_SVE(type, size)\n+define(`REDUCE_ADD_FP_SVE', `\n+instruct reduce_add$1_sve(vReg$1 dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionV$1 dst_src1 src2));\n+  format %{ \"reduce_add$1_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src2);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_fadda($dst_src1$$FloatRegister, __ $2, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+REDUCE_ADD_FP_SVE(F, S)\n+\n+\/\/ reduction addD\n+\n+instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ faddd($dst$$FloatRegister, $dsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    __ ins($tmp$$FloatRegister, __ D, $vsrc$$FloatRegister, 0, 1);\n+    __ faddd($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+REDUCE_ADD_FP_SVE(D, D)\n+\n+\/\/ reduction add - predicated\n+dnl\n+dnl REDUCE_ADD_INT_PREDICATE($1,        $2     )\n+dnl REDUCE_ADD_INT_PREDICATE(insn_name, op_name)\n+define(`REDUCE_ADD_INT_PREDICATE', `\n+instruct reduce_add$1_masked(iReg$1NoSp dst, $2 isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionV$1 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_add$1_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_ADD_FP_PREDICATE($1,        $2     )\n+dnl REDUCE_ADD_FP_PREDICATE(insn_name, op_name)\n+define(`REDUCE_ADD_FP_PREDICATE', `\n+instruct reduce_add$1_masked(vReg$1 dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddReductionV$1 (Binary dst_src1 src2) pg));\n+  format %{ \"reduce_add$1_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadda($dst_src1$$FloatRegister, __ $2,\n+                 $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+REDUCE_ADD_INT_PREDICATE(I, iRegIorL2I)\n+REDUCE_ADD_INT_PREDICATE(L, iRegL)\n+REDUCE_ADD_FP_PREDICATE(F, S)\n+REDUCE_ADD_FP_PREDICATE(D, D)\n+\n+\/\/ ------------------------------ Vector reduction mul -------------------------\n+\n+instruct reduce_mulI(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                     vReg tmp1, vReg tmp2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 8 ||\n+            Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVI isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_mulI $dst, $isrc, $vsrc\\t# vector (64\/128 bits). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_integral($dst$$Register, bt, $isrc$$Register,\n+                                $vsrc$$FloatRegister, length_in_bytes,\n+                                $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulL(iRegLNoSp dst, iRegL isrc, vReg vsrc) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVL isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_mulL $dst, $isrc, $vsrc\\t# 2L\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_integral($dst$$Register, T_LONG, $isrc$$Register,\n+                                $vsrc$$FloatRegister, 16, fnoreg, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulF(vRegF dst, vRegF fsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) <= 16);\n+  match(Set dst (MulReductionVF fsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulF $dst, $fsrc, $vsrc\\t# 2F\/4F. KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_FLOAT, $fsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_mulD(vRegD dst, vRegD dsrc, vReg vsrc, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(2)) == 16);\n+  match(Set dst (MulReductionVD dsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_mulD $dst, $dsrc, $vsrc\\t# 2D. KILL $tmp\" %}\n+  ins_encode %{\n+    __ neon_reduce_mul_fp($dst$$FloatRegister, T_DOUBLE, $dsrc$$FloatRegister,\n+                          $vsrc$$FloatRegister, 16, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl REDUCE_BITWISE_OP_NEON($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_NEON(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_NEON', `\n+instruct reduce_$1$2_neon(iReg$2NoSp dst, $3 isrc, vReg vsrc) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 isrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1$2_neon $dst, $isrc, $vsrc\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_logical(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_BITWISE_OP_SVE($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_SVE(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_SVE', `\n+instruct reduce_$1$2_sve(iReg$2NoSp dst, $3 isrc, vReg vsrc, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_$1$2_sve $dst, $isrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_BITWISE_OP_PREDICATE($1,        $2       $3    $4     )\n+dnl REDUCE_BITWISE_OP_PREDICATE(insn_name, is_long, type, op_name)\n+define(`REDUCE_BITWISE_OP_PREDICATE', `\n+instruct reduce_$1$2_masked(iReg$2NoSp dst, $3 isrc, vReg vsrc, pRegGov pg, vRegD tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) ifelse($2, L, ==, !=) T_LONG);\n+  match(Set dst ($4 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"reduce_$1$2_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector reduction and -------------------------\n+\n+\/\/ reduction andI\n+REDUCE_BITWISE_OP_NEON(and, I, iRegIorL2I, AndReductionV)\n+REDUCE_BITWISE_OP_SVE(and, I, iRegIorL2I, AndReductionV)\n+\n+\/\/ reduction andL\n+REDUCE_BITWISE_OP_NEON(and, L, iRegL, AndReductionV)\n+REDUCE_BITWISE_OP_SVE(and, L, iRegL, AndReductionV)\n+\n+\/\/ reduction and - predicated\n+REDUCE_BITWISE_OP_PREDICATE(and, I, iRegIorL2I, AndReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(and, L, iRegL,      AndReductionV)\n+\n+\/\/ ------------------------------ Vector reduction or --------------------------\n+\n+\/\/ reduction orI\n+REDUCE_BITWISE_OP_NEON(or, I, iRegIorL2I, OrReductionV)\n+REDUCE_BITWISE_OP_SVE(or, I, iRegIorL2I, OrReductionV)\n+\n+\/\/ reduction orL\n+REDUCE_BITWISE_OP_NEON(or, L, iRegL, OrReductionV)\n+REDUCE_BITWISE_OP_SVE(or, L, iRegL, OrReductionV)\n+\n+\/\/ reduction or - predicated\n+REDUCE_BITWISE_OP_PREDICATE(or, I, iRegIorL2I, OrReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(or, L, iRegL,      OrReductionV)\n+\n+\/\/ ------------------------------ Vector reduction xor -------------------------\n+\n+\/\/ reduction xorI\n+REDUCE_BITWISE_OP_NEON(xor, I, iRegIorL2I, XorReductionV)\n+REDUCE_BITWISE_OP_SVE(xor, I, iRegIorL2I, XorReductionV)\n+\n+\/\/ reduction xorL\n+REDUCE_BITWISE_OP_NEON(xor, L, iRegL, XorReductionV)\n+REDUCE_BITWISE_OP_SVE(xor, L, iRegL, XorReductionV)\n+\n+\/\/ reduction xor - predicated\n+REDUCE_BITWISE_OP_PREDICATE(xor, I, iRegIorL2I, XorReductionV)\n+REDUCE_BITWISE_OP_PREDICATE(xor, L, iRegL,      XorReductionV)\n+\n+dnl\n+dnl REDUCE_MAXMIN_I_NEON($1,   $2     )\n+dnl REDUCE_MAXMIN_I_NEON(type, op_name)\n+define(`REDUCE_MAXMIN_I_NEON', `\n+instruct reduce_$1I_neon(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                          vReg tmp, rFlagsReg cr) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1I_neon $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   length_in_bytes, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_I_SVE($1,   $2     )\n+dnl REDUCE_MAXMIN_I_SVE(type, op_name)\n+define(`REDUCE_MAXMIN_I_SVE', `\n+instruct reduce_$1I_sve(iRegINoSp dst, iRegIorL2I isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) &&\n+            (Matcher::vector_element_basic_type(n->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(2)) == T_INT));\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1I_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L_NEON($1,   $2     )\n+dnl REDUCE_MAXMIN_L_NEON(type, op_name)\n+define(`REDUCE_MAXMIN_L_NEON', `\n+instruct reduce_$1L_neon(iRegLNoSp dst, iRegL isrc, vReg vsrc, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"reduce_$1L_neon $dst, $isrc, $vsrc\\t# 2L. KILL cr\" %}\n+  ins_encode %{\n+    __ neon_reduce_minmax_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                                   $isrc$$Register, $vsrc$$FloatRegister,\n+                                   \/* vector_length_in_bytes *\/ 16, fnoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L_SVE($1,   $2     )\n+dnl REDUCE_MAXMIN_L_SVE(type, op_name)\n+define(`REDUCE_MAXMIN_L_SVE', `\n+instruct reduce_$1L_sve(iRegLNoSp dst, iRegL isrc, vReg vsrc,\n+                         vRegD tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(2)) == T_LONG);\n+  match(Set dst ($2 isrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1L_sve $dst, $isrc, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, T_LONG,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           ptrue, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_F($1,   $2,      $3,    $4,    $5,    $6   )\n+dnl REDUCE_MAXMIN_F(type, op_name, insn1, insn2, insn3, insn4)\n+define(`REDUCE_MAXMIN_F', `\n+instruct reduce_$1F(vRegF dst, vRegF fsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT);\n+  match(Set dst ($2 fsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1F $dst, $fsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      if (length_in_bytes == 8) {\n+        __ $3($dst$$FloatRegister, $vsrc$$FloatRegister, __ S);\n+      } else {\n+        __ $4($dst$$FloatRegister, __ T4S, $vsrc$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ $5($dst$$FloatRegister, __ S, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ $6($dst$$FloatRegister, $dst$$FloatRegister, $fsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_D($1,   $2,      $3,    $4,    $5   )\n+dnl REDUCE_MAXMIN_D(type, op_name, insn1, insn2, insn3)\n+define(`REDUCE_MAXMIN_D', `\n+instruct reduce_$1D(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE);\n+  match(Set dst ($2 dsrc vsrc));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1D $dst, $dsrc, $vsrc\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ $3($dst$$FloatRegister, $vsrc$$FloatRegister, __ D);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+      __ $4($dst$$FloatRegister, __ D, ptrue, $vsrc$$FloatRegister);\n+    }\n+    __ $5($dst$$FloatRegister, $dst$$FloatRegister, $dsrc$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_INT_PREDICATE($1,   $2,      $3,       $4     )\n+dnl REDUCE_MAXMIN_INT_PREDICATE(type, is_long, arg_type, op_name)\n+define(`REDUCE_MAXMIN_INT_PREDICATE', `\n+instruct reduce_$1$2_masked(iReg$2NoSp dst, $3 isrc, vReg vsrc, pRegGov pg,\n+                            vRegD tmp, rFlagsReg cr) %{\n+  ifelse($2, I,\n+       `predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_INT));',\n+       `predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == T_LONG);')\n+  match(Set dst ($4 (Binary isrc vsrc) pg));\n+  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  format %{ \"reduce_$1$2_masked $dst, $isrc, $pg, $vsrc\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $vsrc);\n+    __ sve_reduce_integral(this->ideal_Opcode(), $dst$$Register, bt,\n+                           $isrc$$Register, $vsrc$$FloatRegister,\n+                           $pg$$PRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_FP_PREDICATE($1,   $2,       $3,       $4,      $5,    $6   )\n+dnl REDUCE_MAXMIN_FP_PREDICATE(type, is_float, arg_name, op_name, insn1, insn2)\n+define(`REDUCE_MAXMIN_FP_PREDICATE', `\n+instruct reduce_$1$2_masked(vReg$2 dst, vReg$2 $3, vReg vsrc, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n->in(1)->in(2)) == ifelse($2, F, T_FLOAT, T_DOUBLE));\n+  match(Set dst ($4 (Binary $3 vsrc) pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"reduce_$1$2_masked $dst, $$3, $pg, $vsrc\" %}\n+  ins_encode %{\n+    __ $5($dst$$FloatRegister, __ ifelse($2, F, S, D), $pg$$PRegister, $vsrc$$FloatRegister);\n+    __ $6($dst$$FloatRegister, $dst$$FloatRegister, $$3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ Vector reduction max -------------------------\n+\n+\/\/ reduction maxI\n+REDUCE_MAXMIN_I_NEON(max, MaxReductionV)\n+REDUCE_MAXMIN_I_SVE(max, MaxReductionV)\n+\n+\/\/ reduction maxL\n+REDUCE_MAXMIN_L_NEON(max, MaxReductionV)\n+REDUCE_MAXMIN_L_SVE(max, MaxReductionV)\n+\n+\/\/ reduction maxF\n+REDUCE_MAXMIN_F(max, MaxReductionV, fmaxp, fmaxv, sve_fmaxv, fmaxs)\n+\n+\/\/ reduction maxD\n+REDUCE_MAXMIN_D(max, MaxReductionV, fmaxp, sve_fmaxv, fmaxd)\n+\n+\/\/ reduction max - predicated\n+REDUCE_MAXMIN_INT_PREDICATE(max, I, iRegIorL2I, MaxReductionV)\n+REDUCE_MAXMIN_INT_PREDICATE(max, L, iRegL,      MaxReductionV)\n+REDUCE_MAXMIN_FP_PREDICATE(max, F, fsrc, MaxReductionV, sve_fmaxv, fmaxs)\n+REDUCE_MAXMIN_FP_PREDICATE(max, D, dsrc, MaxReductionV, sve_fmaxv, fmaxd)\n+\n+\/\/ ------------------------------ Vector reduction min -------------------------\n+\n+\/\/ reduction minI\n+REDUCE_MAXMIN_I_NEON(min, MinReductionV)\n+REDUCE_MAXMIN_I_SVE(min, MinReductionV)\n+\n+\/\/ reduction minL\n+REDUCE_MAXMIN_L_NEON(min, MinReductionV)\n+REDUCE_MAXMIN_L_SVE(min, MinReductionV)\n+\n+\/\/ reduction minF\n+REDUCE_MAXMIN_F(min, MinReductionV, fminp, fminv, sve_fminv, fmins)\n+\n+\/\/ reduction minD\n+REDUCE_MAXMIN_D(min, MinReductionV, fminp, sve_fminv, fmind)\n+\n+\/\/ reduction min - predicated\n+REDUCE_MAXMIN_INT_PREDICATE(min, I, iRegIorL2I, MinReductionV)\n+REDUCE_MAXMIN_INT_PREDICATE(min, L, iRegL,      MinReductionV)\n+REDUCE_MAXMIN_FP_PREDICATE(min, F, fsrc, MinReductionV, sve_fminv, fmins)\n+REDUCE_MAXMIN_FP_PREDICATE(min, D, dsrc, MinReductionV, sve_fminv, fmind)\n+\n+\/\/ ------------------------------ Vector reinterpret ---------------------------\n+\n+instruct reinterpret_same_size(vReg dst_src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"reinterpret_same_size $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpret_resize_le128b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) <= 16);\n+  match(Set dst (VectorReinterpret src));\n+  format %{ \"reinterpret_resize_le128b $dst, $src\\t# vector <= 128 bits.\" %}\n+  ins_encode %{\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    \/\/ The higher bits in \"dst\" register must be cleared to zero.\n+    if ((length_in_bytes_src == 4 && length_in_bytes_dst == 8) ||\n+        (length_in_bytes_src == 8 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 64 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 4 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 4)) {\n+      \/\/ Reinterpret between 32 bits and 128 bits\n+      __ dup($dst$$FloatRegister, __ S, $src$$FloatRegister);\n+    } else if ((length_in_bytes_src == 8 && length_in_bytes_dst == 16) ||\n+               (length_in_bytes_src == 16 && length_in_bytes_dst == 8)) {\n+      \/\/ Reinterpret between 64 bits and 128 bits\n+      __ orr($dst$$FloatRegister, __ T8B, $src$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(false, \"invalid vector length\");\n+      ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpret_resize_gt128b(vReg dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) > 16 ||\n+             Matcher::vector_length_in_bytes(n->in(1)) > 16));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);\n+  format %{ \"reinterpret_resize_gt128b $dst, $src\\t# vector > 128 bits. KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                                  length_in_bytes_src : length_in_bytes_dst;\n+    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,\n+           \"invalid vector length\");\n+    __ sve_gen_mask_imm($ptmp$$PRegister, T_BYTE, length_in_bytes_resize);\n+    __ sve_dup($dst$$FloatRegister, __ B, 0);\n+    __ sve_sel($dst$$FloatRegister, __ B, $ptmp$$PRegister,\n+               $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector cast ----------------------------------\n+\n+\/\/ VectorCastB2X\n+\n+instruct vcvtBtoX(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vcvtBtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4B to 4S\/4I\/4F, 8B to 8S\n+      __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : bt,\n+                            length_in_bytes, $src$$FloatRegister, T_BYTE);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ B);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastS2X\n+\n+instruct vcvtStoB_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoB_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4S\/8S to 4B\/8B\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_BYTE,\n+                          $src$$FloatRegister, T_SHORT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoB_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  format %{ \"vcvtStoB_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $src$$FloatRegister, __ H, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastS2X src));\n+  format %{ \"vcvtStoX_extend $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4S to 4I\/4F\n+      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+                            $src$$FloatRegister, T_SHORT);\n+      if (bt == T_FLOAT) {\n+        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_vector_extend($dst$$FloatRegister, size, $src$$FloatRegister, __ H);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastI2X\n+\n+instruct vcvtItoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtItoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4I to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $src$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n+            !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtItoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtItoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastI2X src));\n+  format %{ \"vcvtItoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_FLOAT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I\/4I to 2F\/4F\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(type2aelembytes(bt) == 8, \"unsupported type\");\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2I to 2L\/2D\n+        __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+                              $src$$FloatRegister, T_INT);\n+        if (bt == T_DOUBLE) {\n+          __ scvtfv(__ T2D, $dst$$FloatRegister, $dst$$FloatRegister);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        if (bt == T_DOUBLE) {\n+          __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ D);\n+        }\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastL2X\n+\n+instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2I\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+                          $src$$FloatRegister, T_LONG, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n+             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $src$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_neon(vReg dst, vReg src, vRegF tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_neon $dst, $src\\t# 2L to 2F. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ 2L to 2F\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+    __ scvtfs($dst$$FloatRegister, rscratch1);\n+    __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+    __ scvtfs($tmp$$FloatRegister, rscratch1);\n+    __ ins($dst$$FloatRegister, __ S, $tmp$$FloatRegister, 1, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtLtoF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_scvtf($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtLtoD(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastL2X src));\n+  format %{ \"vcvtLtoD $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2L to 2D\n+      __ scvtfv(__ T2D, $dst$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_scvtf($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2X\n+\n+instruct vcvtFtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtFtoX_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4B\/4S\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n+                          $dst$$FloatRegister, T_INT, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoX(vReg dst, vReg src) %{\n+  predicate(type2aelembytes(Matcher::vector_element_basic_type(n)) >= 4);\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vcvtFtoX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (bt == T_INT) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 2F\/4F to 2I\/4I\n+        __ fcvtzs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ S);\n+      }\n+    } else if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        \/\/ 2F to 2L\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+        __ fcvtzs($dst$$FloatRegister, __ T2D, $dst$$FloatRegister);\n+      } else {\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    } else {\n+      assert(bt == T_DOUBLE, \"unsupported type\");\n+      if (length_in_bytes == 16) {\n+        \/\/ 2F to 2D\n+        __ fcvtl($dst$$FloatRegister, __ T2D, $src$$FloatRegister, __ T2S);\n+      } else {\n+        assert(UseSVE > 0 && length_in_bytes > 16, \"must be\");\n+        __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ S);\n+        __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ S);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastD2X\n+\n+instruct vcvtDtoI_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2I\n+    __ ins($dst$$FloatRegister, __ D, $src$$FloatRegister, 0, 1);\n+    \/\/ We can't use fcvtzs(vector, integer) instruction here because we need\n+    \/\/ saturation arithmetic. See JDK-8276151.\n+    __ fcvtzdw(rscratch1, $src$$FloatRegister);\n+    __ fcvtzdw(rscratch2, $dst$$FloatRegister);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n+    __ mov($dst$$FloatRegister, __ S, 1, rscratch2);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoI_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoL $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 2D to 2L\n+      __ fcvtzs($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fcvtzs($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister, __ D);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_64b(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) == 8);\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vcvtDtoF_64b $dst, $src\\t# 2D to 2F\" %}\n+  ins_encode %{\n+    \/\/ 2D to 2F\n+    __ fcvtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtDtoF_gt64b(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT &&\n+            Matcher::vector_length_in_bytes(n) > 8);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoF_gt64b $dst, $src\\t# vector > 64 bits. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Replicate ------------------------------------\n+\n+dnl REPLICATE_INT($1,   $2,       $3  )\n+dnl REPLICATE_INT(type, arg_type, size)\n+define(`REPLICATE_INT', `\n+instruct replicate$1(vReg dst, $2 src) %{\n+  match(Set dst (Replicate$1 src));\n+  format %{ \"replicate$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$Register);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ $3, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_FP($1,   $2  )\n+dnl REPLICATE_FP(type, size)\n+define(`REPLICATE_FP', `\n+instruct replicate$1(vReg dst, vReg$1 src) %{\n+  match(Set dst (Replicate$1 src));\n+  format %{ \"replicate$1 $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ $2, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_IMM_SVE($1,   $2,       $3  )\n+dnl REPLICATE_IMM_SVE(type, arg_type, size)\n+define(`REPLICATE_IMM_SVE', `\n+instruct replicate$1_imm8_gt128b(vReg dst, $2 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate$1 con));\n+  format %{ \"replicate$1_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ $3, (int)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ replicate from reg\n+REPLICATE_INT(B, iRegIorL2I, B)\n+REPLICATE_INT(S, iRegIorL2I, H)\n+REPLICATE_INT(I, iRegIorL2I, S)\n+REPLICATE_INT(L, iRegL,      D)\n+REPLICATE_FP(F, S)\n+REPLICATE_FP(D, D)\n+\n+\/\/ replicate from imm\n+\n+instruct replicateI_imm_le128b(vReg dst, immI con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n+  match(Set dst (ReplicateI con));\n+  format %{ \"replicateI_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int imm = (int)$con$$constant;\n+    if (type2aelembytes(bt) == 1) {\n+      \/\/ Refine imm for B\n+      imm = imm & 0xff;\n+    } else if (type2aelembytes(bt) == 2) {\n+      \/\/ Refine imm for S\n+      imm = imm & 0xffff;\n+    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+REPLICATE_IMM_SVE(B, immI8,        B)\n+REPLICATE_IMM_SVE(S, immI8_shift8, H)\n+REPLICATE_IMM_SVE(I, immI8_shift8, S)\n+\n+instruct replicateL_imm_128b(vReg dst, immL con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16);\n+  match(Set dst (ReplicateL con));\n+  format %{ \"replicateL_imm_128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ T2D, (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+REPLICATE_IMM_SVE(L, immL8_shift8, D)\n+\n+\/\/ ------------------------------ Vector insert --------------------------------\n+\n+\/\/ BYTE, SHORT, INT\n+\n+instruct insertI_le128b(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertI_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+           (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx,\n+                            vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 31. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp$$FloatRegister, size, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_index_ge32(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1,\n+                            vReg tmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            (Matcher::vector_element_basic_type(n) == T_BYTE ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             Matcher::vector_element_basic_type(n) == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"insertI_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index($tmp1$$FloatRegister, size, 0, 1);\n+    __ sve_dup($tmp2$$FloatRegister, size, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, size, ptrue,\n+               $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, size, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ LONG\n+\n+instruct insertL_128b(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  format %{ \"insertL_128b $dst, $src, $val, $idx\\t# 2L\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ mov($dst$$FloatRegister, __ D, (int)($idx$$constant), $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL_gt128b(vReg dst, vReg src, iRegL val, immI idx,\n+                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertL_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $tmp$$FloatRegister, (int)($idx$$constant) - 16);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ FLOAT\n+\n+instruct insertF_le128b(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertF_le128b $dst, $src, $val, $idx\\t# vector <= 128 bits\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ S, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_lt32(vReg dst, vReg src, vRegF val, immI idx,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_lt32 $dst, $src, $val, $idx\\t# vector > 128 bits, index < 32. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ S, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_index_ge32(vReg dst, vReg src, vRegF val, immI idx, vReg tmp,\n+                            pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_element_basic_type(n) == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"insertF_index_ge32 $dst, $src, $val, $idx\\t# index >= 32. KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($tmp$$FloatRegister, __ S, 0, 1);\n+    __ sve_dup($dst$$FloatRegister, __ S, (int)($idx$$constant));\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ S, ptrue,\n+               $tmp$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ S, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ DOUBLE\n+\n+instruct insertD_128b(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(Matcher::vector_length_in_bytes(n) == 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"insertD_128b $dst, $src, $val, $idx\\t# 2D\" %}\n+  ins_encode %{\n+    if ($dst$$FloatRegister != $src$$FloatRegister) {\n+      __ orr($dst$$FloatRegister, __ T16B, $src$$FloatRegister, $src$$FloatRegister);\n+    }\n+    __ ins($dst$$FloatRegister, __ D, $val$$FloatRegister, (int)($idx$$constant), 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_gt128b(vReg dst, vReg src, vRegD val, immI idx,\n+                        pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16 &&\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  format %{ \"insertD_gt128b $dst, $src, $val, $idx\\t# vector > 128 bits. KILL $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_index($dst$$FloatRegister, __ D, -16, 1);\n+    __ sve_cmp(Assembler::EQ, $pgtmp$$PRegister, __ D, ptrue,\n+               $dst$$FloatRegister, (int)($idx$$constant) - 16);\n+    __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+    __ sve_cpy($dst$$FloatRegister, __ D, $pgtmp$$PRegister, $val$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Extract --------------------------------------\n+dnl\n+dnl EXTRACT_INT_SMALL($1,   $2,    $3,       $4,   $5  )\n+dnl EXTRACT_INT_SMALL(type, index, arg_type, insn, size)\n+define(`EXTRACT_INT_SMALL', `\n+instruct extract$1_index_lt$2($3 dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < $2);\n+  match(Set dst (Extract$1 src idx));\n+  format %{ \"extract$1_index_lt$2 $dst, $src, $idx\\t# index < $2\" %}\n+  ins_encode %{\n+    __ $4($dst$$Register, $src$$FloatRegister, __ $5, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl\n+dnl EXTRACT_INT_LARGE($1,   $2,    $3,       $4       )\n+dnl EXTRACT_INT_LARGE(type, index, arg_type, data_type)\n+define(`EXTRACT_INT_LARGE', `\n+instruct extract$1_index_ge$2($3 dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= $2);\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extract$1_index_ge$2 $dst, $src, $idx\\t# index >=$2. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, $4, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ BYTE\n+EXTRACT_INT_SMALL(B, 16, iRegINoSp, smov, B)\n+EXTRACT_INT_LARGE(B, 16, iRegINoSp, T_BYTE)\n+\n+\/\/ SHORT\n+EXTRACT_INT_SMALL(S, 8, iRegINoSp, smov, H)\n+EXTRACT_INT_LARGE(S, 8, iRegINoSp, T_SHORT)\n+\n+\/\/ INT\n+EXTRACT_INT_SMALL(I, 4, iRegINoSp, umov, S)\n+EXTRACT_INT_LARGE(I, 4, iRegINoSp, T_INT)\n+\n+\/\/ LONG\n+EXTRACT_INT_SMALL(L, 2, iRegLNoSp, umov, D)\n+EXTRACT_INT_LARGE(L, 2, iRegLNoSp, T_LONG)\n+\n+dnl\n+dnl EXTRACT_FP($1,   $2,   $3,    $4,   $5   )\n+dnl EXTRACT_FP(type, insn, index, size, shift)\n+define(`EXTRACT_FP', `\n+instruct extract$1(vReg$1 dst, vReg src, immI idx) %{\n+  match(Set dst (Extract$1 src idx));\n+  effect(TEMP_DEF dst);\n+  format %{ \"extract$1 $dst, $src, $idx\" %}\n+  ins_encode %{\n+    int index = (int)$idx$$constant;\n+    if (index == 0) {\n+      __ $2($dst$$FloatRegister, $src$$FloatRegister);\n+    } else if (index < $3) {\n+      __ ins($dst$$FloatRegister, __ $4, $src$$FloatRegister, 0, index);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+      __ sve_ext($dst$$FloatRegister, $dst$$FloatRegister, index << $5);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ FLOAT\n+EXTRACT_FP(F, fmovs, 4, S, 2)\n+\n+\/\/ DOUBLE\n+EXTRACT_FP(D, fmovd, 2, D, 3)\n+\n+\/\/ ------------------------------ Vector mask load\/store -----------------------\n+\n+\/\/ vector load mask\n+\n+instruct vloadmask_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorLoadMask src ));\n+  format %{ \"vloadmask_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+              $src$$FloatRegister);\n+    } else {\n+      __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+      if (type2aelembytes(bt) >= 4) {\n+        __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+      }\n+      if (type2aelembytes(bt) == 8) {\n+        __ uxtl($dst$$FloatRegister, __ T2D, $dst$$FloatRegister, __ T2S);\n+      }\n+      __ negr($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_sve $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               ptrue, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_sve $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(KILL cr);\n+  format %{ \"vloadmaskB_masked $dst, $pg, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ B,\n+               $pg$$PRegister, $src$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n+  match(Set dst (VectorLoadMask src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_extend_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend($tmp$$FloatRegister, size, $src$$FloatRegister, __ B);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - neon\n+\n+instruct vstoremaskB_neon(vReg dst, vReg src, immI_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_neon $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ negr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_neon(vReg dst, vReg src, immI_gt_1 size) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremask_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    int esize = (int)$size$$constant;\n+    if (esize == 2) {\n+      __ xtn($dst$$FloatRegister, __ T8B, $src$$FloatRegister, __ T8H);\n+    } else if (esize == 4) {\n+      __ xtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    } else {\n+      assert(esize == 8, \"must be\");\n+      __ xtn($dst$$FloatRegister, __ T2S, $src$$FloatRegister, __ T2D);\n+      __ xtn($dst$$FloatRegister, __ T4H, $dst$$FloatRegister, __ T4S);\n+      __ xtn($dst$$FloatRegister, __ T8B, $dst$$FloatRegister, __ T8H);\n+    }\n+    __ negr($dst$$FloatRegister, __ T8B, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector store mask - sve\n+\n+instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  format %{ \"vstoremaskB_sve $dst, $src\" %}\n+  ins_encode %{\n+    __ sve_cpy($dst$$FloatRegister, __ B, $src$$PRegister, 1, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorStoreMask src size));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vstoremask_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy($dst$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ B,\n+                         $dst$$FloatRegister, size, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask load when the vector element type is not T_BYTE\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVector, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+                                vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVector mem) pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadV_masked $dst, $pg, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is unpredicated.\n+instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector() &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg)));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked $dst, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the full-sized predicate (ptrue) used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorLoadMask+LoadVectorMasked, and the VectorLoadMask is predicated.\n+instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+                                      vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 1);\n+  match(Set dst (VectorLoadMask (LoadVectorMasked mem pg1) pg2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vloadmask_loadVMasked_masked $dst, $pg2, $mem\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Load valid mask values which are boolean type, and extend them to the\n+    \/\/ defined vector element type. Convert the vector to predicate.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg1\" here, since it is the predicate used\n+    \/\/ for the vector load with boolean type. But the predicate used in\n+    \/\/ the extending \"sve_ld1b\" is based on the final extended vector type,\n+    \/\/ which is the \"pg2\" used in VectorLoadMask.\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, $tmp$$FloatRegister,\n+                          $pg2$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, __ elemType_to_regVariant(bt),\n+               $pg2$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rules for vector mask store when the vector element type is not T_BYTE\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp);\n+  format %{ \"storeV_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVector+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+                                  vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVector mem (VectorStoreMask src esize)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeV_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is equal to the MaxVectorSize.\n+instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) == MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp);\n+  format %{ \"storeVMasked_vstoremask $mem, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used\n+    \/\/ for the vector store with boolean type. But the predicate used in\n+    \/\/ the narrowing \"sve_st1b\" is based on the \"src\" vector type, which\n+    \/\/ is the full-sized predicate (ptrue) here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(type2aelembytes(bt) == (int)$esize$$constant, \"unsupported type.\");\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant($esize$$constant);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          ptrue, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ StoreVectorMasked+VectorStoreMask, and the vector size of \"src\" is less than the MaxVectorSize.\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+                                        vReg tmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n->as_StoreVector()->in(MemNode::ValueIn)->in(1)) < MaxVectorSize);\n+  match(Set mem (StoreVectorMasked mem (Binary (VectorStoreMask src esize) pg)));\n+  effect(TEMP tmp, TEMP pgtmp, KILL cr);\n+  format %{ \"storeVMasked_vstoremask_masked $mem, $src\\t# KILL $tmp, $pgtmp, cr\" %}\n+  ins_encode %{\n+    \/\/ Convert the valid src predicate to vector, and store the vector elements\n+    \/\/ as boolean values.\n+    \/\/\n+    \/\/ Note that we cannot use \"pg\" here, since it is the predicate used for the\n+    \/\/ vector store with boolean type. But the predicate used in the narrowing\n+    \/\/ \"sve_st1b\" is based on the \"src\" vector type, which needed to be generated\n+    \/\/ here.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cpy($tmp$$FloatRegister, size, $src$$PRegister, 1, false);\n+    __ sve_gen_mask_imm($pgtmp$$PRegister, bt, Matcher::vector_length(this, $src));\n+    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, $tmp$$FloatRegister,\n+                          $pgtmp$$PRegister, T_BOOLEAN, bt, $mem->opcode(),\n+                          as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask basic OPs ------------------------\n+\n+dnl\n+dnl VMASK_BITWISE_OP($1,   $2,      $3  )\n+dnl VMASK_BITWISE_OP(type, op_name, insn)\n+define(`VMASK_BITWISE_OP', `\n+instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd ($2 pn pm));\n+  format %{ \"vmask_$1 $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ $3($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASK_AND_NOT($1  )\n+dnl VMASK_AND_NOT(type)\n+define(`VMASK_AND_NOT', `\n+instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (AndVMask pn (XorVMask pm (MaskAll m1))));\n+  format %{ \"vmask_and_not$1 $pd, $pn, $pm\" %}\n+  ins_encode %{\n+    __ sve_bic($pd$$PRegister, ptrue, $pn$$PRegister, $pm$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mask logical ops: and\/or\/xor\/and_not\n+VMASK_BITWISE_OP(and, AndVMask, sve_and)\n+VMASK_BITWISE_OP(or,  OrVMask,  sve_orr)\n+VMASK_BITWISE_OP(xor, XorVMask, sve_eor)\n+VMASK_AND_NOT(I)\n+VMASK_AND_NOT(L)\n+\n+\/\/ vector mask compare\n+\n+instruct vmaskcmp_neon(vReg dst, vReg src1, vReg src2, immI cond) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 ||\n+             Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  format %{ \"vmaskcmp_neon $dst, $src1, $src2, $cond\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_sve $dst, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_compare($dst$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+                         pRegGov pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) (Binary cond pg)));\n+  effect(KILL cr);\n+  format %{ \"vmaskcmp_masked $dst, $pg, $src1, $src2, $cond\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compare($dst$$PRegister, bt, $pg$$PRegister, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast_same_esize_neon(vReg dst_src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_neon $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorMaskCast dst_src));\n+  ins_cost(0);\n+  format %{ \"vmaskcast_same_esize_sve $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst == 2 * length_in_bytes_src ||\n+           length_in_bytes_dst == 4 * length_in_bytes_src ||\n+           length_in_bytes_dst == 8 * length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_extend($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes_dst * 2 == length_in_bytes_src ||\n+           length_in_bytes_dst * 4 == length_in_bytes_src ||\n+           length_in_bytes_dst * 8 == length_in_bytes_src, \"invalid vector length\");\n+    __ sve_vmaskcast_narrow($dst$$PRegister, $src$$PRegister,\n+                            length_in_bytes_dst, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mask reinterpret\n+\n+instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst_src (VectorReinterpret dst_src));\n+  ins_cost(0);\n+  format %{ \"vmask_reinterpret_same_esize $dst_src\\t# do nothing\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length(n) != Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmask_reinterpret_diff_esize $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType from_bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_cpy($tmp$$FloatRegister, from_size, $src$$PRegister, -1, false);\n+    __ sve_cmp(Assembler::EQ, $dst$$PRegister, to_size, ptrue, $tmp$$FloatRegister, -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask reductions -----------------------\n+\n+\/\/ true count\n+\n+instruct vmask_truecount_neon(iRegINoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_truecount_neon $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as bytes with\n+    \/\/ 0x00\/0x01 as element values.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+            $src$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_sve(iRegINoSp dst, pReg src) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskTrueCount src));\n+  format %{ \"vmask_truecount_sve $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt),\n+                ptrue, $src$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ first true\n+\n+instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length(n->in(1)) < 8);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(KILL cr);\n+  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    __ fmovd($dst$$Register, $src$$FloatRegister);\n+    __ rbit($dst$$Register, $dst$$Register);\n+    __ clz($dst$$Register, $dst$$Register);\n+    __ lsrw($dst$$Register, $dst$$Register, 3);\n+    __ movw(rscratch1, Matcher::vector_length(this, $src));\n+    __ cmpw($dst$$Register, rscratch1);\n+    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+  match(Set dst (VectorMaskFirstTrue src));\n+  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the first active lane of the\n+    \/\/ vector mask, or VLENGTH if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/\n+    \/\/ Computed by reversing the bits and counting the leading\n+    \/\/ zero bytes.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes == 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ lsrw($dst$$Register, $dst$$Register, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label FIRST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, zr);\n+      __ cbnz($dst$$Register, FIRST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8);\n+\n+      \/\/ Reverse the bits and count the leading zero bytes.\n+      __ bind(FIRST_TRUE_INDEX);\n+      __ rbit($dst$$Register, $dst$$Register);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ addw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Return the index of the first mask lane that is set, or vector length if none of\n+\/\/ them are set.\n+\n+instruct vmask_firsttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_brkb($ptmp$$PRegister, ptrue, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskFirstTrue src pg));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_firsttrue_masked $dst, $pg, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_brkb($ptmp$$PRegister, $pg$$PRegister, $src$$PRegister, false);\n+    __ sve_cntp($dst$$Register, __ elemType_to_regVariant(bt), ptrue, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ last true\n+\n+instruct vmask_lasttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  format %{ \"vmask_lasttrue_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Returns the index of the last active lane of the\n+    \/\/ vector mask, or -1 if no lane is active.\n+    \/\/\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    assert(bt == T_BOOLEAN, \"unsupported type\");\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      \/\/ Computed by counting the leading zero bytes and\n+      \/\/ subtracting it by 7 (VLENGTH - 1).\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ movw(rscratch1, 7);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      Label LAST_TRUE_INDEX;\n+\n+      \/\/ Try to compute the result from higher 64 bits.\n+      __ fmovhid($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 16 - 1);\n+      __ cbnz($dst$$Register, LAST_TRUE_INDEX);\n+\n+      \/\/ Compute the result from the lower 64 bits.\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ movw(rscratch1, 8 - 1);\n+\n+      \/\/ Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).\n+      __ bind(LAST_TRUE_INDEX);\n+      __ clz($dst$$Register, $dst$$Register);\n+      __ subw($dst$$Register, rscratch1, $dst$$Register, Assembler::LSR, 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue_sve(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp);\n+  format %{ \"vmask_lasttrue_sve $dst, $src\\t# KILL $ptmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, $src$$PRegister, $ptmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ tolong\n+\n+instruct vmask_tolong_neon(iRegLNoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskToLong src));\n+  format %{ \"vmask_tolong_neon $dst, $src\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    if (length_in_bytes <= 8) {\n+      __ fmovd($dst$$Register, $src$$FloatRegister);\n+      __ bytemask_compress($dst$$Register);\n+    } else {\n+      assert(length_in_bytes == 16, \"must be\");\n+      __ umov($dst$$Register, $src$$FloatRegister, __ D, 0);\n+      __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+      __ bytemask_compress($dst$$Register);\n+      __ bytemask_compress(rscratch1);\n+      __ orr($dst$$Register, $dst$$Register, rscratch1, Assembler::LSL, 8);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ fromlong\n+\n+instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP tmp1, TEMP tmp2);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n+                          Matcher::vector_element_basic_type(this),\n+                          Matcher::vector_length(this),\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector mask generation -----------------------\n+\n+\/\/ maskAll\n+dnl\n+dnl VMASKALL_IMM($1,   $2      )\n+dnl VMASKALL_IMM(type, var_type)\n+define(`VMASKALL_IMM', `\n+instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src));\n+  effect(KILL cr);\n+  format %{ \"vmaskAll_imm$1 $dst, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    $2 con = ($2)$src$$constant;\n+    if (con == 0) {\n+      __ sve_pfalse($dst$$PRegister);\n+    } else {\n+      assert(con == -1, \"invalid constant value for mask\");\n+      BasicType bt = Matcher::vector_element_basic_type(this);\n+      __ sve_gen_mask_imm($dst$$PRegister, bt, Matcher::vector_length(this));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASKALL($1,   $2      )\n+dnl VMASKALL(type, arg_type)\n+define(`VMASKALL', `\n+instruct vmaskAll$1(pRegGov dst, $2 src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && !n->is_predicated_vector());\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAll$1 $dst, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size, ptrue, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VMASKALL_PREDICATE($1,   $2      )\n+dnl VMASKALL_PREDICATE(type, arg_type)\n+define(`VMASKALL_PREDICATE', `\n+instruct vmaskAll$1_masked(pRegGov dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (MaskAll src pg));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vmaskAll$1_masked $dst, $pg, $src\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_dup($tmp$$FloatRegister, size, $src$$Register);\n+    __ sve_cmp(Assembler::NE, $dst$$PRegister, size,\n+               $pg$$PRegister, $tmp$$FloatRegister, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+VMASKALL_IMM(I, int)\n+VMASKALL(I, iRegIorL2I)\n+VMASKALL_PREDICATE(I, iRegIorL2I)\n+VMASKALL_IMM(L, long)\n+VMASKALL(L, iRegL)\n+VMASKALL_PREDICATE(L, iRegL)\n+\n+\/\/ vetcor mask generation\n+\n+instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen (ConvI2L src)));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_I $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelow($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen src));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_L $pd, $src\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_whilelo($pd$$PRegister, __ elemType_to_regVariant(bt), zr, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pd (VectorMaskGen con));\n+  effect(KILL cr);\n+  format %{ \"vmask_gen_imm $pd, $con\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_gen_mask_imm($pd$$PRegister, bt, (uint)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+\/\/ vector popcount - INT\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVI src));\n+  format %{ \"vpopcountI $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_cnt($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT, \"unsupported\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+               $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                  $dst$$FloatRegister);\n+        if (bt == T_INT) {\n+          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n+                    $dst$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_cnt($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - LONG\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  format %{ \"vpopcountL $dst, $src\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+\n+instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    if (UseSVE == 0) {\n+      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n+      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n+      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n+    } else {\n+      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n+                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+UNARY_OP_PREDICATE(vpopcountI, PopCountVI, sve_cnt)\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  format %{ \"vpopcountL_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_cnt($dst_src$$FloatRegister, __ D,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector blend ---------------------------------\n+\n+instruct vblend_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) dst));\n+  format %{ \"vblend_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vblend_sve(vReg dst, vReg src1, vReg src2, pReg pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorBlend (Binary src1 src2) pg));\n+  format %{ \"vblend_sve $dst, $pg, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pg$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector round ---------------------------------\n+\n+\/\/ vector Math.round\n+\n+instruct vround_le128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       vReg tmp3, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  format %{ \"vround_le128b $dst, $src\\t# vector <= 128 bits. KILL $tmp1, $tmp2, $tmp3, cr\" %}\n+  ins_encode %{\n+    __ vector_round_neon($dst$$FloatRegister, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister, get_arrangement(this));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_gt128b(vReg dst, vReg src, vReg tmp1, vReg tmp2,\n+                       pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (RoundVF src));\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp, KILL cr);\n+  format %{ \"vround_gt128b $dst, $src\\t# vector > 128 bits. KILL $tmp1, $tmp2, $pgtmp, cr\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_round_sve($dst$$FloatRegister, $src$$FloatRegister,\n+                        $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                        $pgtmp$$PRegister, __ elemType_to_regVariant(bt));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ RoundDouble ----------------------------------\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"vroundD $dst, $src, $rmode\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ frintn($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ frintm($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ frintp($dst$$FloatRegister, __ T2D, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      switch ($rmode$$constant) {\n+        case RoundDoubleModeNode::rmode_rint:\n+          __ sve_frintn($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_floor:\n+          __ sve_frintm($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        case RoundDoubleModeNode::rmode_ceil:\n+          __ sve_frintp($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+          break;\n+        default:\n+          assert(false, \"unsupported\");\n+          ShouldNotReachHere();\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ VectorTest -----------------------------------\n+\n+\/\/ anytrue\n+\n+instruct vtest_anytrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_anytrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ addv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, zr);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(KILL cr);\n+  format %{ \"vtest_anytrue_sve $dst, $src1\\t# KILL cr\" %}\n+  ins_encode %{\n+    \/\/ \"src2\" is not used for sve.\n+    __ sve_ptest(ptrue, $src1$$PRegister);\n+    __ csetw($dst$$Register, Assembler::NE);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ alltrue\n+\n+instruct vtest_alltrue_neon(iRegINoSp dst, vReg src1, vReg src2, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE == 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP tmp, KILL cr);\n+  format %{ \"vtest_alltrue_neon $dst, $src1\\t# KILL $tmp, cr\" %}\n+  ins_encode %{\n+    \/\/ No need to use src2.\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src1);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ uminv($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B, $src1$$FloatRegister);\n+    __ umov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+    __ cmpw($dst$$Register, 0xff);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2));\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"vtest_alltrue_sve $dst, $src1, $src2\\t# KILL $ptmp, cr\" %}\n+  ins_encode %{\n+    __ sve_eors($ptmp$$PRegister, ptrue, $src1$$PRegister, $src2$$PRegister);\n+    __ csetw($dst$$Register, Assembler::EQ);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"loadshuffle $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if ($dst$$FloatRegister != $src$$FloatRegister) {\n+        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        } else {\n+          assert(UseSVE > 0, \"must be sve\");\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        \/\/ 4S\/8S, 4I, 4F\n+        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n+        if (type2aelembytes(bt) == 4) {\n+          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n+        }\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n+                             $src$$FloatRegister, __ B);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector rearrange -----------------------------\n+\n+\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n+\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n+\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n+\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n+\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n+\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+\/\/   6. Use Vm as index register, and use V1 as table register.\n+\/\/      Then get V2 as the result by tbl NEON instructions.\n+\/\/ Notes:\n+\/\/   Step 1 matches VectorLoadConst.\n+\/\/   Step 3 matches VectorLoadShuffle.\n+\/\/   Step 4, 5, 6 match VectorRearrange.\n+\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n+\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n+\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n+\/\/   to implement rearrange.\n+\n+instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n+             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n+              Matcher::vector_length_in_bytes(n) == 16)));\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_SHORT) {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n+      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n+      __ mov($tmp1$$FloatRegister, size1, 0x02);\n+      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n+      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    } else {\n+      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n+      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n+      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n+      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n+      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n+      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  match(Set dst (VectorRearrange src shuffle));\n+  format %{ \"rearrange $dst, $src, $shuffle\" %}\n+  ins_encode %{\n+    BasicType bt_dst = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt_dst == T_BYTE && VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      BasicType bt_src = Matcher::vector_element_basic_type(this, $src);\n+      __ sve_tbl($dst$$FloatRegister, __ elemType_to_regVariant(bt_src),\n+                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Load Gather ---------------------------\n+\n+instruct gather_loadS(vReg dst, indirect mem, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGather mem idx));\n+  format %{ \"gather_loadS $dst, $mem, $idx\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_ld1w_gather($dst$$FloatRegister, ptrue,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+ %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD(vReg dst, indirect mem, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD $dst, $mem, $idx\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, ptrue, as_Register($mem$$base),\n+                       $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadS_masked(vReg dst, indirect mem, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  format %{ \"gather_loadS_masked $dst, $pg, $mem, $idx\" %}\n+  ins_encode %{\n+    __ sve_ld1w_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gather_loadD_masked(vReg dst, indirect mem, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) == 8);\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx pg)));\n+  effect(TEMP tmp);\n+  format %{ \"gather_loadD_masked $dst, $pg, $mem, $idx\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_ld1d_gather($dst$$FloatRegister, $pg$$PRegister,\n+                       as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter -------------------------\n+\n+instruct scatter_storeS(indirect mem, vReg src, vReg idx) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  format %{ \"scatter_storeS $mem, $idx, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_st1w_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD(indirect mem, vReg src, vReg idx, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD $mem, $idx, $src\\t# vector (sve). KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, ptrue,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeS_masked(indirect mem, vReg src, vReg idx, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 4);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  format %{ \"scatter_storeS_masked $mem, $pg, $idx, $src\" %}\n+  ins_encode %{\n+    __ sve_st1w_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $idx$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatter_storeD_masked(indirect mem, vReg src, vReg idx, pRegGov pg, vReg tmp) %{\n+  predicate(UseSVE > 0 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n->in(3)->in(1))) == 8);\n+  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx pg))));\n+  effect(TEMP tmp);\n+  format %{ \"scatter_storeD_masked $mem, $pg, $idx, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    __ sve_uunpklo($tmp$$FloatRegister, __ D, $idx$$FloatRegister);\n+    __ sve_st1d_scatter($src$$FloatRegister, $pg$$PRegister,\n+                        as_Register($mem$$base), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountLeadingZerosV ---------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"vcountLeadingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_LONG) {\n+      if (UseSVE == 0) {\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 0);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+        __ umov(rscratch1, $src$$FloatRegister, __ D, 1);\n+        __ clz(rscratch1, rscratch1);\n+        __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+      } else {\n+        __ sve_clz($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_clz($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+UNARY_OP_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  format %{ \"vcountTrailingZeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+        __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, __ B, ptrue, $dst$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+        if (bt != T_LONG) {\n+          __ clz($dst$$FloatRegister, get_arrangement(this), $dst$$FloatRegister);\n+        } else {\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 0);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 0, rscratch1);\n+          __ umov(rscratch1, $dst$$FloatRegister, __ D, 1);\n+          __ clz(rscratch1, rscratch1);\n+          __ mov($dst$$FloatRegister, __ D, 1, rscratch1);\n+        }\n+      } else {\n+        Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+        __ sve_rbit($dst$$FloatRegister, size, ptrue, $src$$FloatRegister);\n+        __ sve_clz($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  format %{ \"vcountTrailingZeros_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit($dst_src$$FloatRegister, size,\n+                $pg$$PRegister, $dst_src$$FloatRegister);\n+    __ sve_clz($dst_src$$FloatRegister, size,\n+               $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ ReverseV -------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  format %{ \"vreverse $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (bt == T_BYTE) {\n+      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+        __ rbit($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                $src$$FloatRegister);\n+      } else {\n+        assert(UseSVE > 0, \"must be sve\");\n+        __ sve_rbit($dst$$FloatRegister, __ B, ptrue, $src$$FloatRegister);\n+      }\n+    } else {\n+      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported type\");\n+      if (UseSVE == 0) {\n+        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        __ neon_reverse_bits($dst$$FloatRegister, $src$$FloatRegister,\n+                             bt, \/* isQ *\/ length_in_bytes == 16);\n+      } else {\n+        __ sve_rbit($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+UNARY_OP_PREDICATE(vreverse, ReverseV, sve_rbit)\n+\n+\/\/ ------------------------------ ReverseBytesV --------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(!n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  format %{ \"vreverseBytes $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+                 $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ neon_reverse_bytes($dst$$FloatRegister, $src$$FloatRegister,\n+                              bt, \/* isQ *\/ length_in_bytes == 16);\n+      }\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      if (bt == T_BYTE) {\n+        if ($dst$$FloatRegister != $src$$FloatRegister) {\n+          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n+        }\n+      } else {\n+        __ sve_revb($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                    ptrue, $src$$FloatRegister);\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  format %{ \"vreverseBytes_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb($dst_src$$FloatRegister, __ elemType_to_regVariant(bt),\n+                  $pg$$PRegister, $dst_src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Populate Index to a Vector -------------------\n+\n+instruct populateindex(vReg dst, iRegIorL2I src1, immI src2) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (PopulateIndex src1 src2));\n+  format %{ \"populateindex $dst, $src1, $src2\\t # populate index (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_index($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                 $src1$$Register, (int)($src2$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Compress\/Expand Operations -------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  format %{ \"mcompress $dst, $pg\\t# KILL cr\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, $pg$$PRegister);\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            !is_subword_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompress $dst, $src, $pg\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_compact($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                   $src$$FloatRegister, $pg$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2,\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_byte($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  format %{ \"vcompressS $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $pgtmp\" %}\n+  ins_encode %{\n+    __ sve_compress_short($dst$$FloatRegister, $src$$FloatRegister, $pg$$PRegister,\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vexpand $dst, $pg, $src\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup($dst$$FloatRegister, size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt($dst$$FloatRegister, size, $pg$$PRegister,\n+                   $dst$$FloatRegister, $dst$$FloatRegister);\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub($dst$$FloatRegister, size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":4701,"deletions":0,"binary":false,"changes":4701,"status":"added"},{"patch":"@@ -1006,1 +1006,1 @@\n-      sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n+      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n@@ -1110,0 +1110,1 @@\n+\/\/ Clobbers: rflags\n@@ -1147,0 +1148,55 @@\n+\/\/ Extend integer vector src to dst with the same lane count\n+\/\/ but larger element size, e.g. 4B -> 4I\n+void C2_MacroAssembler::neon_vector_extend(FloatRegister dst, BasicType dst_bt, unsigned dst_vlen_in_bytes,\n+                                           FloatRegister src, BasicType src_bt) {\n+  if (src_bt == T_BYTE) {\n+    if (dst_bt == T_SHORT) {\n+      \/\/ 4B\/8B to 4S\/8S\n+      assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+      sxtl(dst, T8H, src, T8B);\n+    } else {\n+      \/\/ 4B to 4I\n+      assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+      sxtl(dst, T8H, src, T8B);\n+      sxtl(dst, T4S, dst, T4H);\n+    }\n+  } else if (src_bt == T_SHORT) {\n+    \/\/ 4S to 4I\n+    assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+    sxtl(dst, T4S, src, T4H);\n+  } else if (src_bt == T_INT) {\n+    \/\/ 2I to 2L\n+    assert(dst_vlen_in_bytes == 16 && dst_bt == T_LONG, \"unsupported\");\n+    sxtl(dst, T2D, src, T2S);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Narrow integer vector src down to dst with the same lane count\n+\/\/ but smaller element size, e.g. 4I -> 4B\n+void C2_MacroAssembler::neon_vector_narrow(FloatRegister dst, BasicType dst_bt,\n+                                           FloatRegister src, BasicType src_bt, unsigned src_vlen_in_bytes) {\n+  if (src_bt == T_SHORT) {\n+    \/\/ 4S\/8S to 4B\/8B\n+    assert(src_vlen_in_bytes == 8 || src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_BYTE, \"unsupported\");\n+    xtn(dst, T8B, src, T8H);\n+  } else if (src_bt == T_INT) {\n+    \/\/ 4I to 4B\/4S\n+    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_BYTE || dst_bt == T_SHORT, \"unsupported\");\n+    xtn(dst, T4H, src, T4S);\n+    if (dst_bt == T_BYTE) {\n+      xtn(dst, T8B, dst, T8H);\n+    }\n+  } else if (src_bt == T_LONG) {\n+    \/\/ 2L to 2I\n+    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_INT, \"unsupported\");\n+    xtn(dst, T2S, src, T2D);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -1259,0 +1315,269 @@\n+\/\/ Vector reduction add for integral type with ASIMD instructions.\n+void C2_MacroAssembler::neon_reduce_add_integral(Register dst, BasicType bt,\n+                                                 Register isrc, FloatRegister vsrc,\n+                                                 unsigned vector_length_in_bytes,\n+                                                 FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_add_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        addv(vtmp, isQ ? T16B : T8B, vsrc);\n+        smov(dst, vtmp, B, 0);\n+        addw(dst, dst, isrc, ext::sxtb);\n+        break;\n+      case T_SHORT:\n+        addv(vtmp, isQ ? T8H : T4H, vsrc);\n+        smov(dst, vtmp, H, 0);\n+        addw(dst, dst, isrc, ext::sxth);\n+        break;\n+      case T_INT:\n+        isQ ? addv(vtmp, T4S, vsrc) : addpv(vtmp, T2S, vsrc, vsrc);\n+        umov(dst, vtmp, S, 0);\n+        addw(dst, dst, isrc);\n+        break;\n+      case T_LONG:\n+        assert(isQ, \"unsupported\");\n+        addpd(vtmp, vsrc);\n+        umov(dst, vtmp, D, 0);\n+        add(dst, dst, isrc);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_add_integral\");\n+}\n+\n+\/\/ Vector reduction multiply for integral type with ASIMD instructions.\n+\/\/ Note: temporary registers vtmp1 and vtmp2 are not used in some cases.\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_reduce_mul_integral(Register dst, BasicType bt,\n+                                                 Register isrc, FloatRegister vsrc,\n+                                                 unsigned vector_length_in_bytes,\n+                                                 FloatRegister vtmp1, FloatRegister vtmp2) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_mul_integral {\");\n+    switch(bt) {\n+      case T_BYTE:\n+        if (isQ) {\n+          \/\/ Multiply the lower half and higher half of vector iteratively.\n+          \/\/ vtmp1 = vsrc[8:15]\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          \/\/ vtmp1[n] = vsrc[n] * vsrc[n + 8], where n=[0, 7]\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+          \/\/ vtmp2 = vtmp1[4:7]\n+          ins(vtmp2, S, vtmp1, 0, 1);\n+          \/\/ vtmp1[n] = vtmp1[n] * vtmp1[n + 4], where n=[0, 3]\n+          mulv(vtmp1, T8B, vtmp2, vtmp1);\n+        } else {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T8B, vtmp1, vsrc);\n+        }\n+        \/\/ vtmp2 = vtmp1[2:3]\n+        ins(vtmp2, H, vtmp1, 0, 1);\n+        \/\/ vtmp2[n] = vtmp1[n] * vtmp1[n + 2], where n=[0, 1]\n+        mulv(vtmp2, T8B, vtmp2, vtmp1);\n+        \/\/ dst = vtmp2[0] * isrc * vtmp2[1]\n+        umov(rscratch1, vtmp2, B, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxtb(dst, dst);\n+        umov(rscratch1, vtmp2, B, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (isQ) {\n+          ins(vtmp2, D, vsrc, 0, 1);\n+          mulv(vtmp2, T4H, vtmp2, vsrc);\n+          ins(vtmp1, S, vtmp2, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vtmp2);\n+        } else {\n+          ins(vtmp1, S, vsrc, 0, 1);\n+          mulv(vtmp1, T4H, vtmp1, vsrc);\n+        }\n+        umov(rscratch1, vtmp1, H, 0);\n+        mulw(dst, rscratch1, isrc);\n+        sxth(dst, dst);\n+        umov(rscratch1, vtmp1, H, 1);\n+        mulw(dst, rscratch1, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (isQ) {\n+          ins(vtmp1, D, vsrc, 0, 1);\n+          mulv(vtmp1, T2S, vtmp1, vsrc);\n+        } else {\n+          vtmp1 = vsrc;\n+        }\n+        umov(rscratch1, vtmp1, S, 0);\n+        mul(dst, rscratch1, isrc);\n+        umov(rscratch1, vtmp1, S, 1);\n+        mul(dst, rscratch1, dst);\n+        break;\n+      case T_LONG:\n+        umov(rscratch1, vsrc, D, 0);\n+        mul(dst, isrc, rscratch1);\n+        umov(rscratch1, vsrc, D, 1);\n+        mul(dst, dst, rscratch1);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_mul_integral\");\n+}\n+\n+\/\/ Vector reduction multiply for floating-point type with ASIMD instructions.\n+void C2_MacroAssembler::neon_reduce_mul_fp(FloatRegister dst, BasicType bt,\n+                                           FloatRegister fsrc, FloatRegister vsrc,\n+                                           unsigned vector_length_in_bytes,\n+                                           FloatRegister vtmp) {\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_mul_fp {\");\n+    switch(bt) {\n+      case T_FLOAT:\n+        fmuls(dst, fsrc, vsrc);\n+        ins(vtmp, S, vsrc, 0, 1);\n+        fmuls(dst, dst, vtmp);\n+        if (isQ) {\n+          ins(vtmp, S, vsrc, 0, 2);\n+          fmuls(dst, dst, vtmp);\n+          ins(vtmp, S, vsrc, 0, 3);\n+          fmuls(dst, dst, vtmp);\n+         }\n+        break;\n+      case T_DOUBLE:\n+        assert(isQ, \"unsupported\");\n+        fmuld(dst, fsrc, vsrc);\n+        ins(vtmp, D, vsrc, 0, 1);\n+        fmuld(dst, dst, vtmp);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_mul_fp\");\n+}\n+\n+\/\/ Helper to select logical instruction\n+void C2_MacroAssembler::neon_reduce_logical_helper(int opc, bool is64, Register Rd,\n+                                                   Register Rn, Register Rm,\n+                                                   enum shift_kind kind, unsigned shift) {\n+  switch(opc) {\n+    case Op_AndReductionV:\n+      is64 ? andr(Rd, Rn, Rm, kind, shift) : andw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    case Op_OrReductionV:\n+      is64 ? orr(Rd, Rn, Rm, kind, shift) : orrw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    case Op_XorReductionV:\n+      is64 ? eor(Rd, Rn, Rm, kind, shift) : eorw(Rd, Rn, Rm, kind, shift);\n+      break;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Vector reduction logical operations And, Or, Xor\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::neon_reduce_logical(int opc, Register dst, BasicType bt,\n+                                            Register isrc, FloatRegister vsrc,\n+                                            unsigned vector_length_in_bytes) {\n+  assert(opc == Op_AndReductionV || opc == Op_OrReductionV || opc == Op_XorReductionV,\n+         \"unsupported\");\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  BLOCK_COMMENT(\"neon_reduce_logical {\");\n+    umov(rscratch1, vsrc, isQ ? D : S, 0);\n+    umov(dst, vsrc, isQ ? D : S, 1);\n+    neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, rscratch1);\n+    switch(bt) {\n+      case T_BYTE:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 16);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 8);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        sxtb(dst, dst);\n+        break;\n+      case T_SHORT:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, dst, dst, Assembler::LSR, 16);\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        sxth(dst, dst);\n+        break;\n+      case T_INT:\n+        if (isQ) {\n+          neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, dst, dst, Assembler::LSR, 32);\n+        }\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ false, dst, isrc, dst);\n+        break;\n+      case T_LONG:\n+        assert(isQ, \"unsupported\");\n+        neon_reduce_logical_helper(opc, \/* is64 *\/ true, dst, isrc, dst);\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_logical\");\n+}\n+\n+\/\/ Vector reduction min\/max for integral type with ASIMD instructions.\n+\/\/ Note: vtmp is not used and expected to be fnoreg for T_LONG case.\n+\/\/ Clobbers: rscratch1, rflags\n+void C2_MacroAssembler::neon_reduce_minmax_integral(int opc, Register dst, BasicType bt,\n+                                                    Register isrc, FloatRegister vsrc,\n+                                                    unsigned vector_length_in_bytes,\n+                                                    FloatRegister vtmp) {\n+  assert(opc == Op_MinReductionV || opc == Op_MaxReductionV, \"unsupported\");\n+  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported\");\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported\");\n+  assert_different_registers(dst, isrc);\n+  bool isQ = vector_length_in_bytes == 16;\n+  bool is_min = opc == Op_MinReductionV;\n+\n+  BLOCK_COMMENT(\"neon_reduce_minmax_integral {\");\n+    if (bt == T_LONG) {\n+      assert(vtmp == fnoreg, \"should be\");\n+      assert(isQ, \"should be\");\n+      umov(rscratch1, vsrc, D, 0);\n+      cmp(isrc, rscratch1);\n+      csel(dst, isrc, rscratch1, is_min ? LT : GT);\n+      umov(rscratch1, vsrc, D, 1);\n+      cmp(dst, rscratch1);\n+      csel(dst, dst, rscratch1, is_min ? LT : GT);\n+    } else {\n+      SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt), isQ);\n+      if (size == T2S) {\n+        is_min ? sminp(vtmp, size, vsrc, vsrc) : smaxp(vtmp, size, vsrc, vsrc);\n+      } else {\n+        is_min ? sminv(vtmp, size, vsrc) : smaxv(vtmp, size, vsrc);\n+      }\n+      if (bt == T_INT) {\n+        umov(dst, vtmp, S, 0);\n+      } else {\n+        smov(dst, vtmp, elemType_to_regVariant(bt), 0);\n+      }\n+      cmpw(dst, isrc);\n+      cselw(dst, dst, isrc, is_min ? LT : GT);\n+    }\n+  BLOCK_COMMENT(\"} neon_reduce_minmax_integral\");\n+}\n+\n+\/\/ Vector reduction for integral type with SVE instruction.\n+\/\/ Supported operations are Add, And, Or, Xor, Max, Min.\n+\/\/ rflags would be clobbered if opc is Op_MaxReductionV or Op_MinReductionV.\n@@ -1269,1 +1594,0 @@\n-      smov(dst, tmp, size, 0);\n@@ -1271,0 +1595,1 @@\n+        smov(dst, tmp, size, 0);\n@@ -1273,0 +1598,1 @@\n+        smov(dst, tmp, size, 0);\n@@ -1275,0 +1601,1 @@\n+        umov(dst, tmp, size, 0);\n@@ -1287,1 +1614,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1289,1 +1616,0 @@\n-        andr(dst, dst, src1);\n@@ -1292,0 +1618,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        andr(dst, dst, src1);\n+      } else {\n@@ -1298,1 +1628,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1300,1 +1630,0 @@\n-        orr(dst, dst, src1);\n@@ -1303,0 +1632,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        orr(dst, dst, src1);\n+      } else {\n@@ -1309,1 +1642,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1311,1 +1644,0 @@\n-        eor(dst, dst, src1);\n@@ -1314,0 +1646,4 @@\n+      }\n+      if (bt == T_LONG) {\n+        eor(dst, dst, src1);\n+      } else {\n@@ -1320,1 +1656,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1322,0 +1658,4 @@\n+      } else {\n+        smov(dst, tmp, size, 0);\n+      }\n+      if (bt == T_LONG) {\n@@ -1325,1 +1665,0 @@\n-        smov(dst, tmp, size, 0);\n@@ -1333,1 +1672,1 @@\n-      if (bt == T_LONG) {\n+      if (bt == T_INT || bt == T_LONG) {\n@@ -1335,0 +1674,4 @@\n+      } else {\n+        smov(dst, tmp, size, 0);\n+      }\n+      if (bt == T_LONG) {\n@@ -1338,1 +1681,0 @@\n-        smov(dst, tmp, size, 0);\n@@ -1575,4 +1917,4 @@\n-void C2_MacroAssembler::sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n-                                             bool is_signed, FloatRegister vtmp) {\n-  assert(UseSVE > 0 && size != Q, \"unsupported\");\n-  assert(!(is_signed && size == D), \"signed extract (D) not supported.\");\n+void C2_MacroAssembler::sve_extract_integral(Register dst, BasicType bt, FloatRegister src,\n+                                             int idx, FloatRegister vtmp) {\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported element type\");\n+  Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n@@ -1580,1 +1922,5 @@\n-    is_signed ? smov(dst, src, size, idx) : umov(dst, src, size, idx);\n+    if (bt == T_INT || bt == T_LONG) {\n+      umov(dst, src, size, idx);\n+    } else {\n+      smov(dst, src, size, idx);\n+    }\n@@ -1584,1 +1930,5 @@\n-    is_signed ? smov(dst, vtmp, size, 0) : umov(dst, vtmp, size, 0);\n+    if (bt == T_INT || bt == T_LONG) {\n+      umov(dst, vtmp, size, 0);\n+    } else {\n+      smov(dst, vtmp, size, 0);\n+    }\n@@ -1590,0 +1940,1 @@\n+\/\/ Clobbers: rscratch1, rflags\n@@ -1591,1 +1942,1 @@\n-                                       FloatRegister tmp2, FloatRegister tmp3, SIMD_Arrangement T) {\n+                                          FloatRegister tmp2, FloatRegister tmp3, SIMD_Arrangement T) {\n@@ -1622,0 +1973,1 @@\n+\/\/ Clobbers: rscratch1, rflags\n@@ -1623,1 +1975,2 @@\n-                                      FloatRegister tmp2, PRegister ptmp, SIMD_RegVariant T) {\n+                                         FloatRegister tmp2, PRegister pgtmp, SIMD_RegVariant T) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n@@ -1634,1 +1987,1 @@\n-      assert(T == S || T == D, \"invalid arrangement\");\n+      assert(T == S || T == D, \"invalid register variant\");\n@@ -1644,1 +1997,1 @@\n-  sve_cmp(HS, ptmp, T, ptrue, tmp2, tmp1);\n+  sve_cmp(HS, pgtmp, T, ptrue, tmp2, tmp1);\n@@ -1647,3 +2000,3 @@\n-    sve_cpy(tmp1, T, ptmp, 0.5);\n-    sve_fadd(tmp1, T, ptmp, src);\n-    sve_frintm(dst, T, ptmp, tmp1);\n+    sve_cpy(tmp1, T, pgtmp, 0.5);\n+    sve_fadd(tmp1, T, pgtmp, src);\n+    sve_frintm(dst, T, pgtmp, tmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":378,"deletions":25,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+ private:\n+\n+  void neon_reduce_logical_helper(int opc, bool sf, Register Rd, Register Rn, Register Rm,\n+                                  enum shift_kind kind = Assembler::LSL, unsigned shift = 0);\n+\n@@ -83,0 +88,7 @@\n+  \/\/ Vector cast\n+  void neon_vector_extend(FloatRegister dst, BasicType dst_bt, unsigned dst_vlen_in_bytes,\n+                          FloatRegister src, BasicType src_bt);\n+\n+  void neon_vector_narrow(FloatRegister dst, BasicType dst_bt,\n+                          FloatRegister src, BasicType src_bt, unsigned src_vlen_in_bytes);\n+\n@@ -95,0 +107,21 @@\n+  \/\/ Vector reduction\n+  void neon_reduce_add_integral(Register dst, BasicType bt,\n+                                Register isrc, FloatRegister vsrc,\n+                                unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_reduce_mul_integral(Register dst, BasicType bt,\n+                                Register isrc, FloatRegister vsrc,\n+                                unsigned vector_length_in_bytes,\n+                                FloatRegister vtmp1, FloatRegister vtmp2);\n+\n+  void neon_reduce_mul_fp(FloatRegister dst, BasicType bt,\n+                          FloatRegister fsrc, FloatRegister vsrc,\n+                          unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n+  void neon_reduce_logical(int opc, Register dst, BasicType bt, Register isrc,\n+                           FloatRegister vsrc, unsigned vector_length_in_bytes);\n+\n+  void neon_reduce_minmax_integral(int opc, Register dst, BasicType bt,\n+                                   Register isrc, FloatRegister vsrc,\n+                                   unsigned vector_length_in_bytes, FloatRegister vtmp);\n+\n@@ -106,2 +139,2 @@\n-  void sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n-                            bool is_signed, FloatRegister vtmp);\n+  void sve_extract_integral(Register dst, BasicType bt, FloatRegister src,\n+                            int idx, FloatRegister vtmp);\n@@ -114,1 +147,1 @@\n-                        FloatRegister tmp2, PRegister ptmp,\n+                        FloatRegister tmp2, PRegister pgtmp,\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ No support for generic vector operands.\n-  static const bool supports_generic_vector_operands = false;\n+  \/\/ aarch64 supports generic vector operands: vReg.\n+  static const bool supports_generic_vector_operands = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    max_slots_per_register = 8,\n+    max_slots_per_register = 4,\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,0 +170,6 @@\n+\n+  \/\/ For common 64\/128-bit unpredicated vector operations, we may prefer\n+  \/\/ emitting NEON instructions rather than the corresponding SVE instructions.\n+  static bool use_neon_for_vector(int vector_length_in_bytes) {\n+    return vector_length_in_bytes <= 16;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2277,0 +2277,3 @@\n+#endif\n+#if defined(AARCH64)\n+    if (strcmp(rep_var,\"$PRegister\") == 0)  return \"as_PRegister\";\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#if defined(AARCH64)\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node) const {\n+    return ::as_PRegister(reg(ra_, node));\n+  }\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node, int idx) const {\n+    return ::as_PRegister(reg(ra_, node, idx));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-         SlotsPerVecA = RISCV_ONLY(4) NOT_RISCV(8),\n+         SlotsPerVecA = 4,\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    @IR(counts = { \"bic\", \" >= 1\" })\n+    @IR(counts = { \"vand_notI\", \" >= 1\" })\n@@ -101,1 +101,1 @@\n-    @IR(counts = { \"bic\", \" >= 1\" })\n+    @IR(counts = { \"and_notL\", \" >= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -240,1 +240,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -253,1 +253,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -266,1 +266,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -279,1 +279,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -292,1 +292,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -305,1 +305,1 @@\n-    @IR(counts = { \"sve_mla\", \">= 1\" })\n+    @IR(counts = { \"vmla_masked\", \">= 1\" })\n@@ -318,1 +318,1 @@\n-    @IR(counts = { \"sve_mls\", \">= 1\" })\n+    @IR(counts = { \"vmls_masked\", \">= 1\" })\n@@ -331,1 +331,1 @@\n-    @IR(counts = { \"sve_fmsb\", \">= 1\" })\n+    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n@@ -344,1 +344,1 @@\n-    @IR(counts = { \"sve_fnmad\", \">= 1\" })\n+    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n@@ -357,1 +357,1 @@\n-    @IR(counts = { \"sve_fnmsb\", \">= 1\" })\n+    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n@@ -370,1 +370,1 @@\n-    @IR(counts = { \"sve_fmsb\", \">= 1\" })\n+    @IR(counts = { \"vfmsb_masked\", \">= 1\" })\n@@ -383,1 +383,1 @@\n-    @IR(counts = { \"sve_fnmad\", \">= 1\" })\n+    @IR(counts = { \"vfnmad_masked\", \">= 1\" })\n@@ -396,1 +396,1 @@\n-    @IR(counts = { \"sve_fnmsb\", \">= 1\" })\n+    @IR(counts = { \"vfnmsb_masked\", \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFusedMultiplyAddSubTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @IR(counts = { \"sve_not\", \">= 1\" })\n+    @IR(counts = { \"vnotI_masked\", \">= 1\" })\n@@ -98,1 +98,1 @@\n-    @IR(counts = { \"sve_not\", \">= 1\" })\n+    @IR(counts = { \"vnotL_masked\", \">= 1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskedNotTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}