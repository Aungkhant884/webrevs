{"files":[{"patch":"@@ -74,3 +74,3 @@\n-        UTF_8.INSTANCE,\n-        ISO_8859_1.INSTANCE,\n-        US_ASCII.INSTANCE\n+            UTF_8.INSTANCE,\n+            ISO_8859_1.INSTANCE,\n+            US_ASCII.INSTANCE\n@@ -79,9 +79,2 @@\n-    private final FileChannel fc;\n-    private final Charset cs;\n-    private final Arena arena;\n-    private final Cleaner.Cleanable cleanupAction;\n-\n-    \/\/ Holds a reference to the parent spliterator to ensure the root's Cleaner\n-    \/\/ is invoked only once itself _and all its splits_ are no longer phantom reachable.\n-    private final FileChannelLinesSpliterator parent;\n-\n+    \/\/ This state is shared across all splits\n+    private final SharedState ss;\n@@ -91,2 +84,0 @@\n-    \/\/ Null before first split, non-null otherwise\n-    private MemorySegment segment;\n@@ -96,4 +87,5 @@\n-    FileChannelLinesSpliterator(FileChannel fc, Charset cs, int index, int fence) {\n-        this.fc = fc;\n-        this.cs = cs;\n-        this.index = index;\n+    FileChannelLinesSpliterator(FileChannel fc,\n+                                Charset cs,\n+                                int fence) {\n+        this.ss = new SharedState(this, fc, cs);\n+        this.index = 0;\n@@ -101,3 +93,0 @@\n-        this.arena = Arena.ofShared();\n-        this.cleanupAction = cleanupAction(this);\n-        this.parent = null; \/\/ No parent for the original Spliterator (root)\n@@ -109,2 +98,1 @@\n-        this.fc = parent.fc;\n-        this.cs = parent.cs;\n+        this.ss = parent.ss;\n@@ -113,4 +101,0 @@\n-        this.segment = parent.segment;\n-        this.arena = parent.arena;\n-        this.cleanupAction = null; \/\/ No cleanupAction for splits\n-        this.parent = parent;\n@@ -157,1 +141,1 @@\n-                    bytesRead = fc.read(dst, index);\n+                    bytesRead = ss.fc.read(dst, index);\n@@ -160,1 +144,1 @@\n-                    bytesRead = fc.read(dst, index);\n+                    bytesRead = ss.fc.read(dst, index);\n@@ -173,1 +157,1 @@\n-                return fc.isOpen();\n+                return ss.fc.isOpen();\n@@ -178,1 +162,1 @@\n-                fc.close();\n+                ss.fc.close();\n@@ -181,1 +165,1 @@\n-        return new BufferedReader(Channels.newReader(rrbc, cs.newDecoder(), -1));\n+        return new BufferedReader(Channels.newReader(rrbc, ss.cs.newDecoder(), -1));\n@@ -196,7 +180,0 @@\n-    private MemorySegment mappedSegment() {\n-        try {\n-            return fc.map(FileChannel.MapMode.READ_ONLY, 0, fence, arena);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n@@ -210,5 +187,2 @@\n-        MemorySegment s;\n-        if ((s = segment) == null) {\n-            s = segment = mappedSegment();\n-        }\n-\n+        \/\/ Only unmapped for the original Spliterator\n+        MemorySegment s = ss.mapIfUnmapped(fence);\n@@ -280,7 +254,0 @@\n-    static Cleaner.Cleanable cleanupAction(FileChannelLinesSpliterator s) {\n-        record Cleanup(Arena arena) implements Runnable {\n-            @Override public void run() { arena.close(); }\n-        }\n-        return CleanerFactory.cleaner().register(s, new Cleanup(s.arena));\n-    }\n-\n@@ -289,1 +256,1 @@\n-        cleanupAction.clean();\n+        ss.cleanupAction.clean();\n@@ -291,0 +258,43 @@\n+\n+    private static final class SharedState {\n+        \/\/ Holds a reference to the original (top-most) spliterator to ensure the original's Cleaner\n+        \/\/ is invoked only once itself _and all its splits_ are no longer phantom reachable.\n+        final FileChannelLinesSpliterator original;\n+        final Cleaner.Cleanable cleanupAction;\n+        final FileChannel fc;\n+        final Charset cs;\n+        final Arena arena;\n+\n+        \/\/ Null before first split, non-null otherwise\n+        MemorySegment segment;\n+\n+        SharedState(FileChannelLinesSpliterator original,\n+                    FileChannel fc,\n+                    Charset cs) {\n+            this.original = original;\n+            this.fc = fc;\n+            this.cs = cs;\n+            this.arena = Arena.ofShared();\n+            this.cleanupAction = cleanupAction();\n+        }\n+\n+        MemorySegment mapIfUnmapped(int fence) {\n+            if (segment != null) {\n+                return segment;\n+            }\n+            try {\n+                return segment = fc.map(FileChannel.MapMode.READ_ONLY, 0, fence, arena);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        Cleaner.Cleanable cleanupAction() {\n+            record Cleanup(Arena arena) implements Runnable {\n+                @Override public void run() { arena.close(); }\n+            }\n+            return CleanerFactory.cleaner().register(original, new Cleanup(arena));\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileChannelLinesSpliterator.java","additions":62,"deletions":52,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -4138,1 +4138,1 @@\n-                    new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n+                    new FileChannelLinesSpliterator(fc, cs,(int) length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}