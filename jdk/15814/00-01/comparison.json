{"files":[{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Unit test for checking parallel use of FileChannelLinesSpliterator\n- * @run junit Parallel\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-public class Parallel {\n-\n-    \/\/ file used by the tests\n-    private Path tmpFile;\n-\n-    @BeforeEach\n-    void setup() throws IOException {\n-        tmpFile = Files.createTempFile(\"text_file\", null);\n-        Files.write(tmpFile, genBytes(20_000), StandardOpenOption.CREATE);\n-    }\n-\n-    @AfterEach\n-    void cleanup() throws IOException {\n-        Files.deleteIfExists(tmpFile);\n-    }\n-\n-    @Test\n-    void basicEquality() throws IOException {\n-        List<String> expected;\n-        List<String> actual;\n-\n-        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n-            expected = lines.toList();\n-        }\n-\n-        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n-            actual = lines.parallel().toList();\n-        }\n-        assertEquals(expected, actual);\n-    }\n-\n-    @Test\n-    \/*\n-     * The objective of this test is to ensure it is very likely the mapped\n-     * memory region in the underlying Spliterator is released in a proper way.\n-     *\n-     * This works by creating parallel streams of various lengths and then\n-     * , at the same time, invoking GC frequently (the mapped memory region can\n-     * be freed both explicitly via the `Stream::close` method and via the GC).\n-     *\/\n-    void fuzzer() throws IOException {\n-\n-        AtomicBoolean ready = new AtomicBoolean();\n-        Thread.ofPlatform().factory().newThread(() -> {\n-            while (!ready.get()) {\n-                System.gc();\n-                \/\/ Hammer GC\n-                LockSupport.parkNanos(1_000);\n-            }\n-        });\n-\n-        int elements;\n-        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n-            elements = Math.toIntExact(lines.count());\n-        }\n-\n-        long cnt = 0;\n-\n-        for (int i = 0; i < 100; i++) {\n-            \/\/ Properly close the Stream\n-            try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n-                List<String> list = lines.parallel()\n-                        .limit(((long) elements * i \/ 100))\n-                        .toList();\n-                cnt += list.size();\n-            }\n-\n-            \/\/ Leave the Stream dangling\n-            List<String> list = Files.lines(tmpFile, StandardCharsets.UTF_8)\n-                    .parallel()\n-                    .limit(((long) elements * i \/ 100))\n-                    .toList();\n-            cnt += list.size();\n-        }\n-\n-        \/\/ Make the background thread exit\n-        ready.set(true);\n-        System.out.println(cnt);\n-    }\n-\n-    \/**\n-     * Returns a byte[] of at least the given size with random content and\n-     * with newlines at random places\n-     *\/\n-    private static byte[] genBytes(int size) {\n-        Random rnd = new Random(42);\n-        int maxLen = 127;\n-        byte[] arr = new byte[size + maxLen + 2];\n-        int c = 0;\n-        while (c < size) {\n-            int lineLen = rnd.nextInt(3, 127);\n-            int end = c + lineLen;\n-            for (; c < end; c++) {\n-                arr[c] = 'a';\n-            }\n-            arr[c++] = '\\r';\n-            arr[c++] = '\\n';\n-        }\n-        \/\/ No harm we might have one or more \\0 at the end\n-        return arr;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/nio\/file\/FileChannelLinesSpliterator\/Parallel.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Unit test for checking parallel use of Files::lines\n+ * @run junit LinesParallel\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LinesParallel {\n+\n+    \/\/ file used by the tests\n+    private Path tmpFile;\n+\n+    @BeforeEach\n+    void setup() throws IOException {\n+        tmpFile = Files.createTempFile(\"text_file\", null);\n+        Files.write(tmpFile, genBytes(20_000), StandardOpenOption.CREATE);\n+    }\n+\n+    @AfterEach\n+    void cleanup() throws IOException {\n+        Files.deleteIfExists(tmpFile);\n+    }\n+\n+    @Test\n+    void basicEquality() throws IOException {\n+        List<String> expected;\n+        List<String> actual;\n+\n+        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n+            expected = lines.toList();\n+        }\n+\n+        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n+            actual = lines.parallel().toList();\n+        }\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+        \/*\n+         * The objective of this test is to ensure it is very likely the mapped\n+         * memory region in the underlying Spliterator is released in a proper way.\n+         *\n+         * This works by creating parallel streams of various lengths and then\n+         * , at the same time, invoking GC frequently (the mapped memory region can\n+         * be freed both explicitly via the `Stream::close` method and via the GC).\n+         *\/\n+    void fuzzer() throws IOException {\n+\n+        AtomicBoolean ready = new AtomicBoolean();\n+        Thread.ofPlatform().factory().newThread(() -> {\n+            while (!ready.get()) {\n+                System.gc();\n+                \/\/ Hammer GC\n+                LockSupport.parkNanos(1_000);\n+            }\n+        });\n+\n+        int elements;\n+        try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n+            elements = Math.toIntExact(lines.count());\n+        }\n+\n+        long cnt = 0;\n+\n+        for (int i = 0; i < 100; i++) {\n+            \/\/ Properly close the Stream\n+            try (var lines = Files.lines(tmpFile, StandardCharsets.UTF_8)) {\n+                List<String> list = lines.parallel()\n+                        .limit(((long) elements * i \/ 100))\n+                        .toList();\n+                cnt += list.size();\n+            }\n+\n+            \/\/ Leave the Stream dangling\n+            List<String> list = Files.lines(tmpFile, StandardCharsets.UTF_8)\n+                    .parallel()\n+                    .limit(((long) elements * i \/ 100))\n+                    .toList();\n+            cnt += list.size();\n+        }\n+\n+        \/\/ Make the background thread exit\n+        ready.set(true);\n+        System.out.println(cnt);\n+    }\n+\n+    \/**\n+     * Returns a byte[] of at least the given size with random content and\n+     * with newlines at random places\n+     *\/\n+    private static byte[] genBytes(int size) {\n+        Random rnd = new Random(42);\n+        int maxLen = 127;\n+        byte[] arr = new byte[size + maxLen + 2];\n+        int c = 0;\n+        while (c < size) {\n+            int lineLen = rnd.nextInt(3, 127);\n+            int end = c + lineLen;\n+            for (; c < end; c++) {\n+                arr[c] = 'a';\n+            }\n+            arr[c++] = '\\r';\n+            arr[c++] = '\\n';\n+        }\n+        \/\/ No harm we might have one or more \\0 at the end\n+        return arr;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/LinesParallel.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}