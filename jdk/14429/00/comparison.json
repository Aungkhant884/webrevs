{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,10 @@\n-  \/\/ flags must be OR'ed from ClassPrinter::Mode for the these two functions\n+  \/\/ Parameters for print_classes() and print_methods():\n+  \/\/\n+  \/\/ - The patterns are matched by StringUtils::is_star_match()\n+  \/\/ - class_name_pattern matches Klass::external_name(). E.g., \"java\/lang\/Object\" or \"*ang\/Object\"\n+  \/\/ - method_pattern may optionally include the signature. E.g., \"wait\", \"wait:()V\" or \"*ai*t:(*)V\"\n+  \/\/ - flags must be OR'ed from ClassPrinter::Mode\n+  \/\/\n+  \/\/   print_classes(\"java\/lang\/Object\", 0x3, os)            -> find j.l.Object and disasm all of its methods\n+  \/\/   print_methods(\"*ang\/Object*\", \"wait\", 0xff, os)       -> detailed disasm of all \"wait\" methods in j.l.Object\n+  \/\/   print_methods(\"*ang\/Object*\", \"wait:(*J*)V\", 0x1, os) -> list all \"wait\" methods in j.l.Object that have a long parameter\n@@ -65,1 +74,1 @@\n-                            const char* method_name_pattern, int flags, outputStream* os);\n+                            const char* method_pattern, int flags, outputStream* os);\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -305,4 +305,10 @@\n-  assert(ConstantPool::is_invokedynamic_index(i), \"not secondary index?\");\n-  i = ConstantPool::decode_invokedynamic_index(i) + ConstantPool::CPCACHE_INDEX_TAG;\n-\n-  return check_cp_cache_index(i, cp_index, st);\n+  ConstantPool* constants = _current_method->constants();\n+  if (constants->cache() == nullptr) {\n+    cp_index = i; \/\/ TODO: This is wrong on little-endian. See JDK-8309811.\n+  } else {\n+    assert(ConstantPool::is_invokedynamic_index(i), \"not secondary index?\");\n+    i = ConstantPool::decode_invokedynamic_index(i);\n+    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(i);\n+    cp_index = indy_entry->constant_pool_index();\n+  }\n+  return true;\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/classPrinter.hpp\"\n@@ -1900,0 +1901,29 @@\n+WB_ENTRY(jobject, WB_printClasses(JNIEnv* env, jobject wb, jstring class_name_pattern, jint flags))\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* c = env->GetStringUTFChars(class_name_pattern, nullptr);\n+  ResourceMark rm;\n+  stringStream st;\n+  {\n+    ThreadInVMfromNative ttvfn(thread); \/\/ back to VM\n+    ClassPrinter::print_classes(c, flags, &st);\n+  }\n+  jstring result = env->NewStringUTF(st.freeze());\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  return result;\n+WB_END\n+\n+WB_ENTRY(jobject, WB_printMethods(JNIEnv* env, jobject wb, jstring class_name_pattern, jstring method_pattern, jint flags))\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* c = env->GetStringUTFChars(class_name_pattern, nullptr);\n+  const char* m = env->GetStringUTFChars(method_pattern, nullptr);\n+  ResourceMark rm;\n+  stringStream st;\n+  {\n+    ThreadInVMfromNative ttvfn(thread); \/\/ back to VM\n+    ClassPrinter::print_methods(c, m, flags, &st);\n+  }\n+  jstring result = env->NewStringUTF(st.freeze());\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  return result;\n+WB_END\n+\n@@ -2740,0 +2770,2 @@\n+  {CC\"printClasses0\",      CC\"(Ljava\/lang\/String;I)Ljava\/lang\/String;\", (void*)&WB_printClasses},\n+  {CC\"printMethods0\",      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;I)Ljava\/lang\/String;\", (void*)&WB_printMethods},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -537,4 +537,1 @@\n-\/\/ - The patterns are matched by StringUtils::is_star_match()\n-\/\/ - class_name_pattern matches Klass::external_name(). E.g., \"java\/lang\/Object\" or \"*ang\/Object\"\n-\/\/ - method_pattern may optionally the signature. E.g., \"wait\", \"wait:()V\" or \"*ai*t:(*)V\"\n-\/\/ - flags must be OR'ed from ClassPrinter::Mode for findclass\/findmethod\n+\/\/   See comments in classPrinter.hpp about the meanings of class_name_pattern, method_pattern and flags.\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8309808 8309811\n+ * @summary Test the output of the HotSpot BytecodeTracer and ClassPrinter classes.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI BytecodeTracerTest\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.FileWriter;\n+import java.io.Serializable;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class BytecodeTracerTest {\n+    public static class Linked {\n+        public static void doit(String args[]) {\n+            System.out.println(\"num args = \" + args.length);\n+        }\n+    }\n+\n+    public static class Unlinked implements Serializable {\n+        public String toString() {\n+            return \"Unlinked\" + this.hashCode();\n+        }\n+    }\n+\n+    static String output;\n+    static int testCount = 0;\n+\n+    static String nextCase(String testName) {\n+        ++ testCount;\n+        return \"======================================================================\\nTest case \"\n+            + testCount + \": \" + testName + \"\\n    \";\n+    }\n+\n+    static void logOutput() throws Exception {\n+        String logFileName = \"log-\" + testCount + \".txt\";\n+        System.out.println(\"Output saved in \" + logFileName);\n+        BufferedWriter writer = new BufferedWriter(new FileWriter(logFileName));\n+        writer.write(output);\n+        writer.close();\n+    }\n+\n+    static void printClasses(String testName, String classNamePattern, int flags) throws Exception {\n+        System.out.println(nextCase(testName) + \"printClasses(\\\"\" + classNamePattern + \"\\\", \" + flags + \")\");\n+        output = WhiteBox.getWhiteBox().printClasses(classNamePattern, flags);\n+        logOutput();\n+    }\n+\n+    static void printMethods(String testName, String classNamePattern, String methodPattern, int flags) throws Exception {\n+        System.out.println(nextCase(testName) + \"printMethods(\\\"\" + classNamePattern + \"\\\", \\\"\" + methodPattern + \"\\\", \" + flags + \")\");\n+        output = WhiteBox.getWhiteBox().printMethods(classNamePattern, methodPattern, flags);\n+        logOutput();\n+    }\n+\n+    static void mustMatch(String pattern) {\n+        Pattern p = Pattern.compile(pattern, Pattern.MULTILINE);\n+        Matcher m = p.matcher(output);\n+        boolean found = m.find();\n+        if (!found) {\n+            System.err.println(\"********* output ********\");\n+            System.err.println(output);\n+            System.err.println(\"*************************\");\n+        }\n+        Asserts.assertTrue(found,\n+                           \"Missing pattern: \\\"\" + pattern + \"\\\"\");\n+        System.out.println(\"Found pattern: \" + pattern);\n+        System.out.println(\"          ==>: \" + m.group());\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        Linked.doit(args); \/\/ Force \"Linked\" class to be linked (and rewritten);\n+\n+        \/\/ ======\n+        printClasses(\"invokedynamic in linked class\",\n+                     \"BytecodeTracerTest$Linked\", 0xff);\n+        mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\");\n+        mustMatch(\"BSM: REF_invokeStatic [0-9]+ <java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants[(]\");\n+\n+        \/\/ ======\n+        if (false) { \/\/ disabled due to JDK-8309811\n+        printMethods(\"invokedynamic in unlinked class\",\n+                     \"BytecodeTracerTest$Unlinked\", \"toString\", 0xff);\n+        mustMatch(\"invokedynamic bsm=[0-9]+ [0-9]+ <makeConcatWithConstants[(]I[)]Ljava\/lang\/String;>\");\n+        mustMatch(\"BSM: REF_invokeStatic [0-9]+ <java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants[(]\");\n+        }\n+    }\n+\n+    public Serializable cast(Unlinked f) {\n+        \/\/ Verifying this method causes the \"Unlinked\" class to be loaded. However\n+        \/\/ the \"Unlinked\" class is never used during the execution of\n+        \/\/ BytecodeTracerTest.main(), so it is not linked by HotSpot.\n+        return f;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/BytecodeTracerTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -166,0 +166,13 @@\n+  private native String printClasses0(String classNamePattern, int flags);\n+  public         String printClasses(String classNamePattern, int flags) {\n+    Objects.requireNonNull(classNamePattern);\n+    return printClasses0(classNamePattern, flags);\n+  }\n+\n+  private native String printMethods0(String classNamePattern, String methodPattern, int flags);\n+  public         String printMethods(String classNamePattern, String methodPattern, int flags) {\n+    Objects.requireNonNull(classNamePattern);\n+    Objects.requireNonNull(methodPattern);\n+    return printMethods0(classNamePattern, methodPattern, flags);\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}