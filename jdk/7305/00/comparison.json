{"files":[{"patch":"@@ -2735,0 +2735,1 @@\n+  beq(flag, cont);\n@@ -2736,1 +2737,2 @@\n-# ifdef ASSERT\n+  \/\/ Check for recursive locking.\n+  cmpd(flag, current_header, R16_thread);\n@@ -2738,7 +2740,6 @@\n-  \/\/ We have acquired the monitor, check some invariants.\n-  addi(\/*monitor=*\/temp, temp, -ObjectMonitor::owner_offset_in_bytes());\n-  \/\/ Invariant 1: _recursions should be 0.\n-  \/\/assert(ObjectMonitor::recursions_size_in_bytes() == 8, \"unexpected size\");\n-  asm_assert_mem8_is_zero(ObjectMonitor::recursions_offset_in_bytes(), temp,\n-                            \"monitor->_recursions should be 0\");\n-# endif\n+\n+  \/\/ Current thread already owns the lock. Just increment recursions.\n+  addi(R0, displaced_header, ObjectMonitor::recursions_offset_in_bytes()-markWord::monitor_value);\n+  ldx(temp, R0);\n+  addi(temp, temp, 1);\n+  stdx(temp, R0);\n@@ -2760,2 +2761,1 @@\n-  Label cont;\n-  Label object_has_monitor;\n+  Label cont, object_has_monitor, notRecursive;\n@@ -2833,3 +2833,2 @@\n-  xorr(temp, R16_thread, temp);      \/\/ Will be 0 if we are the owner.\n-  orr(temp, temp, displaced_header); \/\/ Will be 0 if there are 0 recursions.\n-  cmpdi(flag, temp, 0);\n+\n+  cmpd(flag, temp, R16_thread);\n@@ -2838,0 +2837,6 @@\n+  addic_(displaced_header, displaced_header, -1);\n+  blt(CCR0, notRecursive); \/\/ Not recursive if negative after decrement.\n+  std(displaced_header, ObjectMonitor::recursions_offset_in_bytes(), current_header);\n+  b(cont); \/\/ flag is already EQ here.\n+\n+  bind(notRecursive);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"}]}