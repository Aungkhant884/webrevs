{"files":[{"patch":"@@ -30,1 +30,1 @@\n-void D3DGlyphCache_FlushGlyphVertexCache();\n+static void D3DGlyphCache_FlushGlyphVertexCache();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DGlyphCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,2 @@\n-    AwtCanvas *c = (AwtCanvas*)pData;\n+    AwtCanvas *c;\n+    c = (AwtCanvas*) pData;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Canvas.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6377,2 +6377,4 @@\n-        HWND selfWnd = awtComponent->GetHWnd();\n-        HWND parentWnd = awtParent->GetHWnd();\n+        HWND selfWnd;\n+        HWND parentWnd;\n+        selfWnd = awtComponent->GetHWnd();\n+        parentWnd = awtParent->GetHWnd();\n@@ -6551,1 +6553,2 @@\n-    AwtComponent *component = (AwtComponent *)pData;\n+    AwtComponent *component;\n+    component = (AwtComponent *) pData;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include <awt.h>\n@@ -45,0 +44,4 @@\n+\/\/ Moved here as we don't want to pull in the redefined allocation functions\n+#include \"awt_ole.h\"\n+#include \"awt_DCHolder.h\"\n+\n@@ -46,0 +49,1 @@\n+#include \"awt.h\"\n@@ -57,3 +61,0 @@\n-#include \"awt_ole.h\"\n-#include \"awt_DCHolder.h\"\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"awt_ole.h\"\n@@ -34,1 +35,0 @@\n-#include \"awt_ole.h\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDT.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1350,10 +1350,0 @@\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    f = (AwtFrame *)pData;\n-    HWND hwnd = f->GetHWnd();\n-    if (::IsWindow(hwnd))\n-    {\n-        DASSERT(!IsBadReadPtr(f, sizeof(AwtFrame)));\n-\n-        BOOL iconify = (state & java_awt_Frame_ICONIFIED) != 0;\n-        BOOL zoom = (state & java_awt_Frame_MAXIMIZED_BOTH)\n-                        == java_awt_Frame_MAXIMIZED_BOTH;\n@@ -1361,5 +1351,40 @@\n-        DTRACE_PRINTLN4(\"WFramePeer.setState:%s%s ->%s%s\",\n-                  f->isIconic() ? \" iconic\" : \"\",\n-                  f->isZoomed() ? \" zoomed\" : \"\",\n-                  iconify       ? \" iconic\" : \"\",\n-                  zoom          ? \" zoomed\" : \"\");\n+    {\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        f = (AwtFrame *)pData;\n+        HWND hwnd = f->GetHWnd();\n+        if (::IsWindow(hwnd)) {\n+            DASSERT(!IsBadReadPtr(f, sizeof(AwtFrame)));\n+\n+            BOOL iconify = (state & java_awt_Frame_ICONIFIED) != 0;\n+            BOOL zoom = (state & java_awt_Frame_MAXIMIZED_BOTH)\n+                            == java_awt_Frame_MAXIMIZED_BOTH;\n+\n+            DTRACE_PRINTLN4(\"WFramePeer.setState:%s%s ->%s%s\",\n+                      f->isIconic() ? \" iconic\" : \"\",\n+                      f->isZoomed() ? \" zoomed\" : \"\",\n+                      iconify       ? \" iconic\" : \"\",\n+                      zoom          ? \" zoomed\" : \"\");\n+\n+            if (::IsWindowVisible(hwnd)) {\n+                BOOL focusable = f->IsFocusableWindow();\n+\n+                WINDOWPLACEMENT wp;\n+                ::ZeroMemory(&wp, sizeof(wp));\n+                wp.length = sizeof(wp);\n+                ::GetWindowPlacement(hwnd, &wp);\n+\n+                \/\/ Iconify first.\n+                \/\/ If both iconify & zoom are TRUE, handle this case\n+                \/\/ with wp.flags field below.\n+                if (iconify) {\n+                    wp.showCmd = focusable ? SW_MINIMIZE : SW_SHOWMINNOACTIVE;\n+                } else if (zoom) {\n+                    wp.showCmd = focusable ? SW_SHOWMAXIMIZED : SW_MAXIMIZE;\n+                } else { \/\/ zoom == iconify == FALSE\n+                    wp.showCmd = focusable ? SW_RESTORE : SW_SHOWNOACTIVATE;\n+                }\n+                if (zoom && iconify) {\n+                    wp.flags |= WPF_RESTORETOMAXIMIZED;\n+                } else {\n+                    wp.flags &= ~WPF_RESTORETOMAXIMIZED;\n+                }\n@@ -1367,2 +1392,3 @@\n-        if (::IsWindowVisible(hwnd)) {\n-            BOOL focusable = f->IsFocusableWindow();\n+                if (!zoom) {\n+                    f->m_forceResetZoomed = TRUE;\n+                }\n@@ -1370,4 +1396,4 @@\n-            WINDOWPLACEMENT wp;\n-            ::ZeroMemory(&wp, sizeof(wp));\n-            wp.length = sizeof(wp);\n-            ::GetWindowPlacement(hwnd, &wp);\n+                \/\/ The SetWindowPlacement() causes the WmSize() invocation\n+                \/\/  which, in turn, actually updates the m_iconic & m_zoomed flags\n+                \/\/  as well as sends Java event (WINDOW_STATE_CHANGED.)\n+                ::SetWindowPlacement(hwnd, &wp);\n@@ -1375,12 +1401,1 @@\n-            \/\/ Iconify first.\n-            \/\/ If both iconify & zoom are TRUE, handle this case\n-            \/\/ with wp.flags field below.\n-            if (iconify) {\n-                wp.showCmd = focusable ? SW_MINIMIZE : SW_SHOWMINNOACTIVE;\n-            } else if (zoom) {\n-                wp.showCmd = focusable ? SW_SHOWMAXIMIZED : SW_MAXIMIZE;\n-            } else { \/\/ zoom == iconify == FALSE\n-                wp.showCmd = focusable ? SW_RESTORE : SW_SHOWNOACTIVATE;\n-            }\n-            if (zoom && iconify) {\n-                wp.flags |= WPF_RESTORETOMAXIMIZED;\n+                f->m_forceResetZoomed = FALSE;\n@@ -1388,2 +1403,1 @@\n-                wp.flags &= ~WPF_RESTORETOMAXIMIZED;\n-            }\n+                DTRACE_PRINTLN(\"  not visible, just recording the requested state\");\n@@ -1391,2 +1405,2 @@\n-            if (!zoom) {\n-                f->m_forceResetZoomed = TRUE;\n+                f->setIconic(iconify);\n+                f->setZoomed(zoom);\n@@ -1394,12 +1408,0 @@\n-\n-            \/\/ The SetWindowPlacement() causes the WmSize() invocation\n-            \/\/  which, in turn, actually updates the m_iconic & m_zoomed flags\n-            \/\/  as well as sends Java event (WINDOW_STATE_CHANGED.)\n-            ::SetWindowPlacement(hwnd, &wp);\n-\n-            f->m_forceResetZoomed = FALSE;\n-        } else {\n-            DTRACE_PRINTLN(\"  not visible, just recording the requested state\");\n-\n-            f->setIconic(iconify);\n-            f->setZoomed(zoom);\n@@ -1408,0 +1410,1 @@\n+\n@@ -1580,9 +1583,0 @@\n-    JNI_CHECK_PEER_GOTO(peer, ret);\n-    AwtFrame *f = (AwtFrame *)pData;\n-\n-    \/\/ dialog here may be NULL, for example, if the blocker is a native dialog\n-    \/\/ however, we need to install\/unistall modal hooks anyway\n-    JNI_CHECK_PEER_GOTO(blockerPeer, ret);\n-    AwtDialog *d = (AwtDialog *)pData;\n-\n-    if ((f != NULL) && ::IsWindow(f->GetHWnd()))\n@@ -1590,39 +1584,35 @@\n-        \/\/ get an HWND of the toplevel window this embedded frame is within\n-        HWND fHWnd = f->GetHWnd();\n-        while (::GetParent(fHWnd) != NULL) {\n-            fHWnd = ::GetParent(fHWnd);\n-        }\n-        \/\/ we must get a toplevel hwnd here, however due to some strange\n-        \/\/ behaviour of Java Plugin (a bug?) when running in IE at\n-        \/\/ this moment the embedded frame hasn't been placed into the\n-        \/\/ browser yet and fHWnd is not a toplevel, so we shouldn't install\n-        \/\/ the hook here\n-        if ((::GetWindowLong(fHWnd, GWL_STYLE) & WS_CHILD) == 0) {\n-            \/\/ if this toplevel is created in another thread, we should install\n-            \/\/ the modal hook into it to track window activation and mouse events\n-            DWORD fThread = ::GetWindowThreadProcessId(fHWnd, NULL);\n-            if (fThread != AwtToolkit::GetInstance().MainThread()) {\n-                \/\/ check if this thread has been already blocked\n-                BlockedThreadStruct *blockedThread = (BlockedThreadStruct *)sm_BlockedThreads.get((void *)((intptr_t)fThread));\n-                if (blocked) {\n-                    if (blockedThread == NULL) {\n-                        blockedThread = new BlockedThreadStruct;\n-                        blockedThread->framesCount = 1;\n-                        blockedThread->modalHook = ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtDialog::ModalFilterProc,\n-                                                                      0, fThread);\n-                        blockedThread->mouseHook = ::SetWindowsHookEx(WH_MOUSE, (HOOKPROC)AwtDialog::MouseHookProc_NonTT,\n-                                                                      0, fThread);\n-                        sm_BlockedThreads.put((void *)((intptr_t)fThread), blockedThread);\n-                    } else {\n-                        blockedThread->framesCount++;\n-                    }\n-                } else {\n-                    \/\/ see the comment above: if Java Plugin behaviour when running in IE\n-                    \/\/ was right, blockedThread would be always not NULL here\n-                    if (blockedThread != NULL) {\n-                        DASSERT(blockedThread->framesCount > 0);\n-                        if ((blockedThread->framesCount) == 1) {\n-                            ::UnhookWindowsHookEx(blockedThread->modalHook);\n-                            ::UnhookWindowsHookEx(blockedThread->mouseHook);\n-                            sm_BlockedThreads.remove((void *)((intptr_t)fThread));\n-                            delete blockedThread;\n+        JNI_CHECK_PEER_GOTO(peer, ret);\n+        AwtFrame *f = (AwtFrame *)pData;\n+\n+        \/\/ dialog here may be NULL, for example, if the blocker is a native dialog\n+        \/\/ however, we need to install\/unistall modal hooks anyway\n+        JNI_CHECK_PEER_GOTO(blockerPeer, ret);\n+        AwtDialog *d = (AwtDialog *)pData;\n+\n+        if ((f != NULL) && ::IsWindow(f->GetHWnd())) {\n+            \/\/ get an HWND of the toplevel window this embedded frame is within\n+            HWND fHWnd = f->GetHWnd();\n+            while (::GetParent(fHWnd) != NULL) {\n+                fHWnd = ::GetParent(fHWnd);\n+            }\n+            \/\/ we must get a toplevel hwnd here, however due to some strange\n+            \/\/ behaviour of Java Plugin (a bug?) when running in IE at\n+            \/\/ this moment the embedded frame hasn't been placed into the\n+            \/\/ browser yet and fHWnd is not a toplevel, so we shouldn't install\n+            \/\/ the hook here\n+            if ((::GetWindowLong(fHWnd, GWL_STYLE) & WS_CHILD) == 0) {\n+                \/\/ if this toplevel is created in another thread, we should install\n+                \/\/ the modal hook into it to track window activation and mouse events\n+                DWORD fThread = ::GetWindowThreadProcessId(fHWnd, NULL);\n+                if (fThread != AwtToolkit::GetInstance().MainThread()) {\n+                    \/\/ check if this thread has been already blocked\n+                    BlockedThreadStruct *blockedThread = (BlockedThreadStruct *)sm_BlockedThreads.get((void *)((intptr_t)fThread));\n+                    if (blocked) {\n+                        if (blockedThread == NULL) {\n+                            blockedThread = new BlockedThreadStruct;\n+                            blockedThread->framesCount = 1;\n+                            blockedThread->modalHook = ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtDialog::ModalFilterProc,\n+                                                                          0, fThread);\n+                            blockedThread->mouseHook = ::SetWindowsHookEx(WH_MOUSE, (HOOKPROC)AwtDialog::MouseHookProc_NonTT,\n+                                                                          0, fThread);\n+                            sm_BlockedThreads.put((void *)((intptr_t)fThread), blockedThread);\n@@ -1630,1 +1620,15 @@\n-                            blockedThread->framesCount--;\n+                            blockedThread->framesCount++;\n+                        }\n+                    } else {\n+                        \/\/ see the comment above: if Java Plugin behaviour when running in IE\n+                        \/\/ was right, blockedThread would be always not NULL here\n+                        if (blockedThread != NULL) {\n+                            DASSERT(blockedThread->framesCount > 0);\n+                            if ((blockedThread->framesCount) == 1) {\n+                                ::UnhookWindowsHookEx(blockedThread->modalHook);\n+                                ::UnhookWindowsHookEx(blockedThread->mouseHook);\n+                                sm_BlockedThreads.remove((void *)((intptr_t)fThread));\n+                                delete blockedThread;\n+                            } else {\n+                                blockedThread->framesCount--;\n+                            }\n@@ -1637,0 +1641,1 @@\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":103,"deletions":98,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    static jfieldID AwtPrintDialog::controlID;\n-    static jfieldID AwtPrintDialog::parentID;\n-    static jfieldID AwtPrintDialog::pageID;\n-    static jmethodID AwtPrintDialog::setHWndMID;\n+    static jfieldID controlID;\n+    static jfieldID parentID;\n+    static jfieldID pageID;\n+    static jmethodID setHWndMID;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintDialog.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+jfieldID AwtPrintDialog::pageID;\n+\n@@ -212,1 +214,0 @@\n-jfieldID AwtPrintDialog::pageID;\n@@ -531,13 +532,0 @@\n-    HWND parentID = AwtPrintControl::getParentID(env, self);\n-    if (parentID != NULL && ::IsWindow(parentID)) {\n-        \/\/ windows native modality is requested (used by JavaFX).\n-        setup.hwndOwner = parentID;\n-    }\n-    \/*\n-      Fix for 6488834.\n-      To disable Win32 native parent modality we have to set\n-      hwndOwner field to either NULL or some hidden window. For\n-      parentless dialogs we use NULL to show them in the taskbar,\n-      and for all other dialogs AwtToolkit's HWND is used.\n-    *\/\n-    else if (awtParent != NULL)\n@@ -545,6 +533,20 @@\n-        setup.hwndOwner = AwtToolkit::GetInstance().GetHWnd();\n-    }\n-    else\n-    {\n-        setup.hwndOwner = NULL;\n-    }\n+        HWND parentID = AwtPrintControl::getParentID(env, self);\n+        if (parentID != NULL && ::IsWindow(parentID)) {\n+            \/\/ windows native modality is requested (used by JavaFX).\n+            setup.hwndOwner = parentID;\n+        }\n+        \/*\n+          Fix for 6488834.\n+          To disable Win32 native parent modality we have to set\n+          hwndOwner field to either NULL or some hidden window. For\n+          parentless dialogs we use NULL to show them in the taskbar,\n+          and for all other dialogs AwtToolkit's HWND is used.\n+        *\/\n+        else if (awtParent != NULL)\n+        {\n+            setup.hwndOwner = AwtToolkit::GetInstance().GetHWnd();\n+        }\n+        else\n+        {\n+            setup.hwndOwner = NULL;\n+        }\n@@ -552,26 +554,20 @@\n-    setup.hDevMode = NULL;\n-    setup.hDevNames = NULL;\n-    setup.Flags = PSD_RETURNDEFAULT | PSD_DEFAULTMINMARGINS;\n-    \/\/ setup.ptPaperSize =\n-    \/\/ setup.rtMinMargin =\n-    \/\/ setup.rtMargin =\n-    setup.hInstance = NULL;\n-    setup.lCustData = (LPARAM)peerGlobalRef;\n-    setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n-    setup.lpfnPagePaintHook = NULL;\n-    setup.lpPageSetupTemplateName = NULL;\n-    setup.hPageSetupTemplate = NULL;\n-\n-\n-    \/* Because the return default flag is set, this first call\n-     * will not display the dialog but will return default values, inc\n-     * including hDevMode, hDevName, ptPaperSize, and rtMargin values.\n-     * We can use the devmode to set the orientation of the page\n-     * and the size of the page.\n-     * The units used by the user is also needed.\n-     *\/\n-    if (AwtPrintControl::getPrintHDMode(env, self) == NULL ||\n-        AwtPrintControl::getPrintHDName(env,self) == NULL) {\n-        (void)::PageSetupDlg(&setup);\n-        \/* check if hDevMode and hDevNames are set.\n-         * If both are null, then there is no default printer.\n+        setup.hDevMode = NULL;\n+        setup.hDevNames = NULL;\n+        setup.Flags = PSD_RETURNDEFAULT | PSD_DEFAULTMINMARGINS;\n+        \/\/ setup.ptPaperSize =\n+        \/\/ setup.rtMinMargin =\n+        \/\/ setup.rtMargin =\n+        setup.hInstance = NULL;\n+        setup.lCustData = (LPARAM)peerGlobalRef;\n+        setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n+        setup.lpfnPagePaintHook = NULL;\n+        setup.lpPageSetupTemplateName = NULL;\n+        setup.hPageSetupTemplate = NULL;\n+\n+\n+        \/* Because the return default flag is set, this first call\n+         * will not display the dialog but will return default values, inc\n+         * including hDevMode, hDevName, ptPaperSize, and rtMargin values.\n+         * We can use the devmode to set the orientation of the page\n+         * and the size of the page.\n+         * The units used by the user is also needed.\n@@ -579,11 +575,13 @@\n-        if ((setup.hDevMode == NULL) && (setup.hDevNames == NULL)) {\n-            doIt = JNI_FALSE;\n-            goto done;\n-        }\n-    } else {\n-        int measure = PSD_INTHOUSANDTHSOFINCHES;\n-        int sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, NULL, 0);\n-        if (sz > 0) {\n-          LPTSTR str = (LPTSTR)SAFE_SIZE_ARRAY_ALLOC(safe_Malloc, sizeof(TCHAR), sz);\n-          if (str != NULL) {\n-            sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, str, sz);\n+        if (AwtPrintControl::getPrintHDMode(env, self) == NULL ||\n+            AwtPrintControl::getPrintHDName(env,self) == NULL) {\n+            (void)::PageSetupDlg(&setup);\n+            \/* check if hDevMode and hDevNames are set.\n+             * If both are null, then there is no default printer.\n+             *\/\n+            if ((setup.hDevMode == NULL) && (setup.hDevNames == NULL)) {\n+                doIt = JNI_FALSE;\n+                goto done;\n+            }\n+        } else {\n+            int measure = PSD_INTHOUSANDTHSOFINCHES;\n+            int sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, NULL, 0);\n@@ -591,2 +589,9 @@\n-              if (_tcscmp(TEXT(\"0\"), str) == 0) {\n-                measure = PSD_INHUNDREDTHSOFMILLIMETERS;\n+              LPTSTR str = (LPTSTR)SAFE_SIZE_ARRAY_ALLOC(safe_Malloc, sizeof(TCHAR), sz);\n+              if (str != NULL) {\n+                sz = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, str, sz);\n+                if (sz > 0) {\n+                  if (_tcscmp(TEXT(\"0\"), str) == 0) {\n+                    measure = PSD_INHUNDREDTHSOFMILLIMETERS;\n+                  }\n+                }\n+                free((LPTSTR)str);\n@@ -595,2 +600,3 @@\n-            free((LPTSTR)str);\n-          }\n+            setup.Flags |= measure;\n+            setup.hDevMode = AwtPrintControl::getPrintHDMode(env, self);\n+            setup.hDevNames = AwtPrintControl::getPrintHDName(env, self);\n@@ -598,24 +604,6 @@\n-        setup.Flags |= measure;\n-        setup.hDevMode = AwtPrintControl::getPrintHDMode(env, self);\n-        setup.hDevNames = AwtPrintControl::getPrintHDName(env, self);\n-    }\n-    \/* Move page size and orientation from the PageFormat object\n-     * into the Windows setup structure so that the format can\n-     * be displayed in the dialog.\n-     *\/\n-    pageFormatToSetup(env, self, page, &setup, AwtPrintControl::getPrintDC(env, self));\n-    if (env->ExceptionCheck()) {\n-        doIt = JNI_FALSE;\n-        goto done;\n-    }\n-\n-    setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n-    setup.Flags = PSD_ENABLEPAGESETUPHOOK | PSD_MARGINS;\n-\n-    AwtDialog::CheckInstallModalHook();\n-\n-    BOOL ret = ::PageSetupDlg(&setup);\n-    if (ret) {\n-\n-        jobject paper = getPaper(env, page);\n-        if (paper == NULL) {\n+        \/* Move page size and orientation from the PageFormat object\n+         * into the Windows setup structure so that the format can\n+         * be displayed in the dialog.\n+         *\/\n+        pageFormatToSetup(env, self, page, &setup, AwtPrintControl::getPrintDC(env, self));\n+        if (env->ExceptionCheck()) {\n@@ -625,6 +613,0 @@\n-        int units = setup.Flags & PSD_INTHOUSANDTHSOFINCHES ?\n-                                                MM_HIENGLISH :\n-                                                MM_HIMETRIC;\n-        POINT paperSize;\n-        RECT margins;\n-        jint orientation;\n@@ -632,15 +614,36 @@\n-        \/* The printer may have been changed, and we track that change,\n-         * but then need to get a new DC for the current printer so that\n-         * we validate the paper size correctly\n-         *\/\n-        if (setup.hDevNames != NULL) {\n-            DEVNAMES* names = (DEVNAMES*)::GlobalLock(setup.hDevNames);\n-            if (names != NULL) {\n-                LPTSTR printer = (LPTSTR)names+names->wDeviceOffset;\n-                SAVE_CONTROLWORD\n-                HDC newDC = ::CreateDC(TEXT(\"WINSPOOL\"), printer, NULL, NULL);\n-                RESTORE_CONTROLWORD\n-                if (newDC != NULL) {\n-                    HDC oldDC = AwtPrintControl::getPrintDC(env, self);\n-                    if (oldDC != NULL) {\n-                         ::DeleteDC(oldDC);\n+        setup.lpfnPageSetupHook = reinterpret_cast<LPPAGESETUPHOOK>(pageDlgHook);\n+        setup.Flags = PSD_ENABLEPAGESETUPHOOK | PSD_MARGINS;\n+\n+        AwtDialog::CheckInstallModalHook();\n+\n+        BOOL ret = ::PageSetupDlg(&setup);\n+        if (ret) {\n+\n+            jobject paper = getPaper(env, page);\n+            if (paper == NULL) {\n+                doIt = JNI_FALSE;\n+                goto done;\n+            }\n+            int units = setup.Flags & PSD_INTHOUSANDTHSOFINCHES ?\n+                                                    MM_HIENGLISH :\n+                                                    MM_HIMETRIC;\n+            POINT paperSize;\n+            RECT margins;\n+            jint orientation;\n+\n+            \/* The printer may have been changed, and we track that change,\n+             * but then need to get a new DC for the current printer so that\n+             * we validate the paper size correctly\n+             *\/\n+            if (setup.hDevNames != NULL) {\n+                DEVNAMES* names = (DEVNAMES*)::GlobalLock(setup.hDevNames);\n+                if (names != NULL) {\n+                    LPTSTR printer = (LPTSTR)names+names->wDeviceOffset;\n+                    SAVE_CONTROLWORD\n+                    HDC newDC = ::CreateDC(TEXT(\"WINSPOOL\"), printer, NULL, NULL);\n+                    RESTORE_CONTROLWORD\n+                    if (newDC != NULL) {\n+                        HDC oldDC = AwtPrintControl::getPrintDC(env, self);\n+                        if (oldDC != NULL) {\n+                             ::DeleteDC(oldDC);\n+                        }\n@@ -648,0 +651,1 @@\n+                    AwtPrintControl::setPrintDC(env, self, newDC);\n@@ -649,1 +653,1 @@\n-                AwtPrintControl::setPrintDC(env, self, newDC);\n+                ::GlobalUnlock(setup.hDevNames);\n@@ -651,2 +655,0 @@\n-            ::GlobalUnlock(setup.hDevNames);\n-        }\n@@ -654,4 +656,4 @@\n-        \/* Get the Windows paper and margins description.\n-        *\/\n-        retrievePaperInfo(&setup, &paperSize, &margins, &orientation,\n-                          AwtPrintControl::getPrintDC(env, self));\n+            \/* Get the Windows paper and margins description.\n+            *\/\n+            retrievePaperInfo(&setup, &paperSize, &margins, &orientation,\n+                              AwtPrintControl::getPrintDC(env, self));\n@@ -659,30 +661,31 @@\n-        \/* Convert the Windows' paper and margins description\n-         * and place them into a Paper instance.\n-         *\/\n-        setPaperValues(env, paper, &paperSize, &margins, units);\n-         if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-         }\n-        \/*\n-         * Put the updated Paper instance and the orientation into\n-         * the PageFormat.\n-         *\/\n-        setPaper(env, page, paper);\n-        if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-        }\n-        setPageFormatOrientation(env, page, orientation);\n-        if (env->ExceptionCheck()) {\n-             doIt = JNI_FALSE;\n-             goto done;\n-        }\n-        if (setup.hDevMode != NULL) {\n-            DEVMODE *devmode = (DEVMODE *)::GlobalLock(setup.hDevMode);\n-            if (devmode != NULL) {\n-                if (devmode->dmFields & DM_PAPERSIZE) {\n-                    jboolean err = setPrintPaperSize(env, self, devmode->dmPaperSize);\n-                    if (err) {\n-                        doIt = JNI_FALSE;\n-                        goto done;\n+            \/* Convert the Windows' paper and margins description\n+             * and place them into a Paper instance.\n+             *\/\n+            setPaperValues(env, paper, &paperSize, &margins, units);\n+             if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+             }\n+            \/*\n+             * Put the updated Paper instance and the orientation into\n+             * the PageFormat.\n+             *\/\n+            setPaper(env, page, paper);\n+            if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+            }\n+            setPageFormatOrientation(env, page, orientation);\n+            if (env->ExceptionCheck()) {\n+                 doIt = JNI_FALSE;\n+                 goto done;\n+            }\n+            if (setup.hDevMode != NULL) {\n+                DEVMODE *devmode = (DEVMODE *)::GlobalLock(setup.hDevMode);\n+                if (devmode != NULL) {\n+                    if (devmode->dmFields & DM_PAPERSIZE) {\n+                        jboolean err = setPrintPaperSize(env, self, devmode->dmPaperSize);\n+                        if (err) {\n+                            doIt = JNI_FALSE;\n+                            goto done;\n+                        }\n@@ -691,0 +694,1 @@\n+                ::GlobalUnlock(setup.hDevMode);\n@@ -692,1 +696,1 @@\n-            ::GlobalUnlock(setup.hDevMode);\n+            doIt = JNI_TRUE;\n@@ -694,2 +698,0 @@\n-        doIt = JNI_TRUE;\n-    }\n@@ -697,1 +699,1 @@\n-    AwtDialog::CheckUninstallModalHook();\n+        AwtDialog::CheckUninstallModalHook();\n@@ -699,1 +701,1 @@\n-    AwtDialog::ModalActivateNextWindow(NULL, target, peer);\n+        AwtDialog::ModalActivateNextWindow(NULL, target, peer);\n@@ -701,4 +703,4 @@\n-    HGLOBAL oldG = AwtPrintControl::getPrintHDMode(env, self);\n-    if (setup.hDevMode != oldG) {\n-        AwtPrintControl::setPrintHDMode(env, self, setup.hDevMode);\n-    }\n+        HGLOBAL oldG = AwtPrintControl::getPrintHDMode(env, self);\n+        if (setup.hDevMode != oldG) {\n+            AwtPrintControl::setPrintHDMode(env, self, setup.hDevMode);\n+        }\n@@ -706,3 +708,4 @@\n-    oldG = AwtPrintControl::getPrintHDName(env, self);\n-    if (setup.hDevNames != oldG) {\n-        AwtPrintControl::setPrintHDName(env, self, setup.hDevNames);\n+        oldG = AwtPrintControl::getPrintHDName(env, self);\n+        if (setup.hDevNames != oldG) {\n+            AwtPrintControl::setPrintHDName(env, self, setup.hDevNames);\n+        }\n@@ -922,1 +925,2 @@\n-    JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n+    {\n+        JNI_CHECK_NULL_GOTO(printDC, \"Invalid printDC\", done);\n@@ -924,82 +928,82 @@\n-    \/* We try to mitigate the effects of floating point rounding errors\n-     * by only setting a value if it would differ from the value in the\n-     * target by at least 0.10 points = 1\/720 inches.\n-     * eg if the values present in the target are close to the calculated\n-     * values then we accept the target.\n-     *\/\n-    const double epsilon = 0.10;\n-\n-    jdouble paperWidth, paperHeight;\n-    jboolean err;\n-    WORD dmPaperSize = getPrintPaperSize(env, &err, self);\n-    if (err) goto done;\n-\n-    double ix, iy, iw, ih, pw, ph;\n-\n-    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n-    jmethodID getID;\n-\n-    jclass paperClass = env->GetObjectClass(origPaper);\n-    JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n-    getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n-    pw = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n-    ph = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n-    ix = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n-    iy = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n-    iw = env->CallDoubleMethod(origPaper, getID);\n-    getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n-    JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n-    ih = env->CallDoubleMethod(origPaper, getID);\n-\n-    matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n-                   &paperWidth, &paperHeight, &dmPaperSize);\n-\n-    \/* Validate margins and imageable area *\/\n-\n-    \/\/ pixels per inch in x and y direction\n-    jint xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n-    jint yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n-\n-    \/\/ x & y coord of printable area in pixels\n-    jint xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n-    jint yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n-\n-    \/\/ width & height of printable area in pixels\n-    jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n-    jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n-\n-    \/\/ The DC may be obtained when we first selected the printer as a\n-    \/\/ result of a call to setNativePrintService.\n-    \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n-    \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n-    \/\/ This may happen in other cases too, but was observed for the above.\n-    \/\/ To get a DC compatible with this devmode we should really call\n-    \/\/ CreateDC() again to get a DC for the devmode we are using.\n-    \/\/ The changes for that are a lot more risk, so to minimize that\n-    \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n-    \/\/ devmode says its LANDSCAPE.\n-    \/\/ if the values were obtained from a rotated device, swap.\n-    if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n-        (imgPixelWid > imgPixelHgt)) {\n-      jint tmp;\n-      tmp = xPixelRes;\n-      xPixelRes = yPixelRes;\n-      yPixelRes = tmp;\n-\n-      tmp = xPixelOrg;\n-      xPixelOrg = yPixelOrg;\n-      yPixelOrg = tmp;\n-\n-      tmp = imgPixelWid;\n-      imgPixelWid = imgPixelHgt;\n-      imgPixelHgt = tmp;\n-    }\n+        \/* We try to mitigate the effects of floating point rounding errors\n+         * by only setting a value if it would differ from the value in the\n+         * target by at least 0.10 points = 1\/720 inches.\n+         * eg if the values present in the target are close to the calculated\n+         * values then we accept the target.\n+         *\/\n+        const double epsilon = 0.10;\n+\n+        jdouble paperWidth, paperHeight;\n+        jboolean err;\n+        WORD dmPaperSize = getPrintPaperSize(env, &err, self);\n+        if (err) goto done;\n+\n+        double ix, iy, iw, ih, pw, ph;\n+\n+        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+        jmethodID getID;\n+\n+        jclass paperClass = env->GetObjectClass(origPaper);\n+        JNI_CHECK_NULL_GOTO(paperClass, \"paper class not found\", done);\n+        getID = env->GetMethodID(paperClass, GETWIDTH_STR, GETWIDTH_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getWidth method\", done);\n+        pw = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETHEIGHT_STR, GETHEIGHT_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getHeight method\", done);\n+        ph = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_X_STR, GETIMG_X_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getX method\", done);\n+        ix = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_Y_STR, GETIMG_Y_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getY method\", done);\n+        iy = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_W_STR, GETIMG_W_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getW method\", done);\n+        iw = env->CallDoubleMethod(origPaper, getID);\n+        getID = env->GetMethodID(paperClass, GETIMG_H_STR, GETIMG_H_SIG);\n+        JNI_CHECK_NULL_GOTO(getID, \"no getH method\", done);\n+        ih = env->CallDoubleMethod(origPaper, getID);\n+\n+        matchPaperSize(printDC, hDevMode, hDevNames, pw, ph,\n+                       &paperWidth, &paperHeight, &dmPaperSize);\n+\n+        \/* Validate margins and imageable area *\/\n+\n+        \/\/ pixels per inch in x and y direction\n+        jint xPixelRes = GetDeviceCaps(printDC, LOGPIXELSX);\n+        jint yPixelRes = GetDeviceCaps(printDC, LOGPIXELSY);\n+\n+        \/\/ x & y coord of printable area in pixels\n+        jint xPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETX);\n+        jint yPixelOrg = GetDeviceCaps(printDC, PHYSICALOFFSETY);\n+\n+        \/\/ width & height of printable area in pixels\n+        jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);\n+        jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);\n+\n+        \/\/ The DC may be obtained when we first selected the printer as a\n+        \/\/ result of a call to setNativePrintService.\n+        \/\/ If the Devmode was obtained later on from the DocumentProperties dialog\n+        \/\/ the DC won't have been updated and its settings may be for PORTRAIT.\n+        \/\/ This may happen in other cases too, but was observed for the above.\n+        \/\/ To get a DC compatible with this devmode we should really call\n+        \/\/ CreateDC() again to get a DC for the devmode we are using.\n+        \/\/ The changes for that are a lot more risk, so to minimize that\n+        \/\/ risk, assume its not LANDSCAPE unless width > height, even if the\n+        \/\/ devmode says its LANDSCAPE.\n+        \/\/ if the values were obtained from a rotated device, swap.\n+        if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&\n+            (imgPixelWid > imgPixelHgt)) {\n+          jint tmp;\n+          tmp = xPixelRes;\n+          xPixelRes = yPixelRes;\n+          yPixelRes = tmp;\n+\n+          tmp = xPixelOrg;\n+          xPixelOrg = yPixelOrg;\n+          yPixelOrg = tmp;\n+\n+          tmp = imgPixelWid;\n+          imgPixelWid = imgPixelHgt;\n+          imgPixelHgt = tmp;\n+        }\n@@ -1007,5 +1011,5 @@\n-    \/\/ page imageable area in 1\/72\"\n-    jdouble imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n-    jdouble imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n-    jdouble imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n-    jdouble imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n+        \/\/ page imageable area in 1\/72\"\n+        jdouble imgX = (jdouble)((xPixelOrg * 72)\/(jdouble)xPixelRes);\n+        jdouble imgY = (jdouble)((yPixelOrg * 72)\/(jdouble)yPixelRes);\n+        jdouble imgWid = (jdouble)((imgPixelWid * 72)\/(jdouble)xPixelRes);\n+        jdouble imgHgt = (jdouble)((imgPixelHgt * 72)\/(jdouble)yPixelRes);\n@@ -1013,4 +1017,4 @@\n-    \/* Check each of the individual values is within range.\n-     * Then make sure imageable area is placed within imageable area.\n-     * Allow for a small floating point error in the comparisons\n-     *\/\n+        \/* Check each of the individual values is within range.\n+         * Then make sure imageable area is placed within imageable area.\n+         * Allow for a small floating point error in the comparisons\n+         *\/\n@@ -1018,30 +1022,30 @@\n-    if (ix < 0.0 ) {\n-        ix = 0.0;\n-    }\n-    if (iy < 0.0 ) {\n-        iy = 0.0;\n-    }\n-    if (iw < 0.0) {\n-        iw = 0.0;\n-    }\n-    if (ih < 0.0) {\n-        ih = 0.0;\n-    }\n-    if ((ix + epsilon) < imgX) {\n-         ix = imgX;\n-    }\n-    if ((iy + epsilon) < imgY) {\n-         iy = imgY;\n-    }\n-    if (iw + epsilon > imgWid) {\n-        iw = imgWid;\n-    }\n-    if (ih + epsilon > imgHgt) {\n-        ih = imgHgt;\n-    }\n-    if ((ix + iw + epsilon) > (imgX+imgWid)) {\n-        ix = (imgX+imgWid) - iw;\n-    }\n-    if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n-        iy = (imgY+imgHgt) - ih;\n-    }\n+        if (ix < 0.0 ) {\n+            ix = 0.0;\n+        }\n+        if (iy < 0.0 ) {\n+            iy = 0.0;\n+        }\n+        if (iw < 0.0) {\n+            iw = 0.0;\n+        }\n+        if (ih < 0.0) {\n+            ih = 0.0;\n+        }\n+        if ((ix + epsilon) < imgX) {\n+             ix = imgX;\n+        }\n+        if ((iy + epsilon) < imgY) {\n+             iy = imgY;\n+        }\n+        if (iw + epsilon > imgWid) {\n+            iw = imgWid;\n+        }\n+        if (ih + epsilon > imgHgt) {\n+            ih = imgHgt;\n+        }\n+        if ((ix + iw + epsilon) > (imgX+imgWid)) {\n+            ix = (imgX+imgWid) - iw;\n+        }\n+        if ((iy + ih + epsilon) > (imgY+imgHgt)) {\n+            iy = (imgY+imgHgt) - ih;\n+        }\n@@ -1049,1 +1053,1 @@\n-    DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n+        DASSERT(AwtToolkit::MainThread() != ::GetCurrentThreadId());\n@@ -1051,1 +1055,1 @@\n-    jmethodID setSizeID = env->GetMethodID(paperClass,\n+        jmethodID setSizeID = env->GetMethodID(paperClass,\n@@ -1053,1 +1057,1 @@\n-    JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n+        JNI_CHECK_NULL_GOTO(setSizeID, \"no setSize method\", done);\n@@ -1055,3 +1059,3 @@\n-    jmethodID setImageableID = env->GetMethodID(paperClass,\n-                                        SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n-    JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n+        jmethodID setImageableID = env->GetMethodID(paperClass,\n+                                            SETIMAGEABLE_STR, SETIMAGEABLE_SIG);\n+        JNI_CHECK_NULL_GOTO(setImageableID, \"no setImageable method\", done);\n@@ -1059,2 +1063,3 @@\n-    env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n-    env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n+        env->CallVoidMethod(newPaper, setSizeID, paperWidth, paperHeight);\n+        env->CallVoidMethod(newPaper, setImageableID, ix, iy, iw, ih);\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":290,"deletions":285,"binary":false,"changes":575,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+jmethodID AwtTextComponent::canAccessClipboardMID;\n+AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n+WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n+\n@@ -60,2 +64,0 @@\n-jmethodID AwtTextComponent::canAccessClipboardMID;\n-\n@@ -914,2 +916,0 @@\n-AwtTextComponent::OleCallback AwtTextComponent::sm_oleCallback;\n-\n@@ -1043,2 +1043,0 @@\n-WNDPROC AwtTextComponent::sm_pDefWindowProc = NULL;\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TextComponent.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1025,3 +1025,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -1029,1 +1030,2 @@\n-    window->RepositionSecurityWarning(env);\n+        window->RepositionSecurityWarning(env);\n+    }\n@@ -3126,7 +3128,8 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n-        delete mds;\n-        return;\n-    }\n+    {\n+        JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n+        PDATA pData = JNI_GET_PDATA(self);\n+        if (pData == NULL) {\n+            env->DeleteGlobalRef(self);\n+            delete mds;\n+            return;\n+        }\n@@ -3134,4 +3137,5 @@\n-    window = (AwtWindow *)pData;\n-    windowHWnd = window->GetHWnd();\n-    if (::IsWindow(windowHWnd)) {\n-        AwtWindow::SetAndActivateModalBlocker(windowHWnd, blockerHWnd);\n+        window = (AwtWindow *)pData;\n+        windowHWnd = window->GetHWnd();\n+        if (::IsWindow(windowHWnd)) {\n+            AwtWindow::SetAndActivateModalBlocker(windowHWnd, blockerHWnd);\n+        }\n@@ -3155,6 +3159,7 @@\n-    JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n-    PDATA pData = JNI_GET_PDATA(self);\n-    if (pData == NULL) {\n-        env->DeleteGlobalRef(self);\n-        return;\n-    }\n+    {\n+        JNI_CHECK_NULL_GOTO(self, \"peer\", ret);\n+        PDATA pData = JNI_GET_PDATA(self);\n+        if (pData == NULL) {\n+            env->DeleteGlobalRef(self);\n+            return;\n+        }\n@@ -3162,4 +3167,5 @@\n-    window = (AwtWindow *)pData;\n-    windowHWnd = window->GetHWnd();\n-    if (::IsWindow(windowHWnd)) {\n-        AwtWindow::SetModalBlocker(windowHWnd, NULL);\n+        window = (AwtWindow *)pData;\n+        windowHWnd = window->GetHWnd();\n+        if (::IsWindow(windowHWnd)) {\n+            AwtWindow::SetModalBlocker(windowHWnd, NULL);\n+        }\n@@ -3180,3 +3186,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3184,1 +3191,2 @@\n-    window->SetTranslucency(iOpacity, window->isOpaque());\n+        window->SetTranslucency(iOpacity, window->isOpaque());\n+    }\n@@ -3199,3 +3207,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3203,1 +3212,2 @@\n-    window->SetTranslucency(window->getOpacity(), isOpaque);\n+        window->SetTranslucency(window->getOpacity(), isOpaque);\n+    }\n@@ -3218,3 +3228,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3222,2 +3233,3 @@\n-    window->UpdateWindow(env, data, (int)uws->width, (int)uws->height,\n-                         uws->hBitmap);\n+        window->UpdateWindow(env, data, (int)uws->width, (int)uws->height,\n+                             uws->hBitmap);\n+    }\n@@ -3242,3 +3254,4 @@\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n+    {\n+        PDATA pData;\n+        JNI_CHECK_PEER_GOTO(self, ret);\n+        AwtWindow *window = (AwtWindow *)pData;\n@@ -3246,1 +3259,2 @@\n-    window->setFullScreenExclusiveModeState(state != 0);\n+        window->setFullScreenExclusiveModeState(state != 0);\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":56,"deletions":42,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRole - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1098,1 +1098,1 @@\n-        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ParentWithRoleElseRoot - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1155,1 +1155,1 @@\n-        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", (AccessibleContext)0);\n+        EXCEPTION_CHECK(\"Getting ActiveDescendent - call to CallObjectMethod()\", reinterpret_cast<jobject>((AccessibleContext) 0));\n@@ -1164,1 +1164,1 @@\n-        return (AccessibleContext)0;\n+        return reinterpret_cast<jobject>((AccessibleContext) 0);\n","filename":"src\/jdk.accessibility\/windows\/native\/libjavaaccessbridge\/AccessBridgeJavaEntryPoints.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}