{"files":[{"patch":"@@ -35,9 +35,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -264,11 +255,0 @@\n-\n-    \/\/ If a mask is feeding into a safepoint, then its value should be\n-    \/\/ packed into a boolean\/byte vector first, this will simplify the\n-    \/\/ re-materialization logic for both predicated and non-predicated\n-    \/\/ targets.\n-    bool is_mask = is_vector_mask(iklass);\n-    if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n-      const TypeVect* vt = vec_value->bottom_type()->is_vect();\n-      BasicType bt = vt->element_basic_type();\n-      vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n-    }\n@@ -328,0 +308,8 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -68,2 +68,0 @@\n-  } else if (is_vector_mask(ik)) {\n-    return T_BOOLEAN;\n@@ -91,18 +89,30 @@\n-\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-\/\/ occupies the whole 512-bit vector register when scalarized.\n-\/\/ During scalarization inserting a VectorStoreMask node between mask\n-\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n-\n-void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n-  switch (elem_bt) {\n-    case T_BOOLEAN: arr->  byte_at_put(index,   *(jboolean*)addr); break;\n-    case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n-    case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n-    case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n-    case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n-    case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n-    case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n-\n-    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n+  if (is_mask) {\n+    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+    \/\/ occupies the whole 512-bit vector register when scalarized.\n+    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n+    \/\/\n+    \/\/ TODO: revisit when predicate registers are fully supported.\n+    switch (elem_bt) {\n+      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n+      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n+      case T_INT:    \/\/ fall-through\n+      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n+      case T_LONG:   \/\/ fall-through\n+      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+    }\n+  } else {\n+    switch (elem_bt) {\n+      case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n+      case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n+      case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n+      case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n+      case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n+      case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+    }\n@@ -113,0 +123,2 @@\n+  bool is_mask = is_vector_mask(ik);\n+\n@@ -118,1 +130,1 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n+  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(is_mask ? T_BOOLEAN : elem_bt));\n@@ -131,1 +143,1 @@\n-      init_payload_element(arr, elem_bt, i, elem_addr);\n+      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n@@ -137,1 +149,1 @@\n-      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n+      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static void init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr);\n+  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}