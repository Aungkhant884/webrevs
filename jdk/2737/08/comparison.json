{"files":[{"patch":"@@ -55,0 +55,2 @@\n+JVM_DumpClassListToFile\n+JVM_DumpDynamicArchive\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -780,13 +780,0 @@\n-\/\/ returns true if entry already on class path\n-bool ClassLoader::contains_append_entry(const char* name) {\n-  ClassPathEntry* e = first_append_entry();\n-  while (e != NULL) {\n-    \/\/ assume zip entries have been canonicalized\n-    if (strcmp(name, e->name()) == 0) {\n-      return true;\n-    }\n-    e = e->next();\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -388,3 +388,0 @@\n-  \/\/ indicates if class path already contains a entry (exact match by name)\n-  static bool contains_append_entry(const char* name);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,2 +300,2 @@\n-  template(jdk_internal_misc_CDS, \"jdk\/internal\/misc\/CDS\")                                        \\\n-  template(generateLambdaFormHolderClasses, \"generateLambdaFormHolderClasses\")                    \\\n+  template(jdk_internal_misc_CDS,                     \"jdk\/internal\/misc\/CDS\")                    \\\n+  template(generateLambdaFormHolderClasses,           \"generateLambdaFormHolderClasses\")          \\\n@@ -303,0 +303,2 @@\n+  template(dumpSharedArchive,                         \"dumpSharedArchive\")                        \\\n+  template(dumpSharedArchive_signature,               \"(ZLjava\/lang\/String;)V\")                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -203,0 +203,6 @@\n+JNIEXPORT void JNICALL\n+JVM_DumpClassListToFile(JNIEnv* env, jstring fileName);\n+\n+JNIEXPORT void JNICALL\n+JVM_DumpDynamicArchive(JNIEnv* env, jstring archiveName);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -332,0 +333,30 @@\n+bool DynamicArchive::_has_been_dumped_once = false;\n+\n+void DynamicArchive::dump(const char* archive_name, TRAPS) {\n+  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"already checked in arguments.cpp?\");\n+  assert(ArchiveClassesAtExit == nullptr, \"already checked in arguments.cpp?\");\n+  \/\/ During dynamic archive dumping, some of the data structures are overwritten so\n+  \/\/ we cannot dump the dynamic archive again. TODO: this should be fixed.\n+  if (has_been_dumped_once()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+        \"Dynamic dump has been done, and should only be done once\");\n+  } else {\n+    \/\/ prevent multiple dumps.\n+    set_has_been_dumped_once();\n+  }\n+  assert(ArchiveClassesAtExit == nullptr, \"already checked in arguments.cpp?\");\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n+    dump();\n+  } else {\n+    ArchiveClassesAtExit = nullptr;\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not setup SharedDynamicArchivePath\");\n+  }\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+             \"Could not restore SharedDynamicArchivePath\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static bool _has_been_dumped_once;\n@@ -62,0 +63,1 @@\n+  static void dump(const char* archive_name, TRAPS);\n@@ -63,0 +65,2 @@\n+  static bool has_been_dumped_once() { return _has_been_dumped_once; }\n+  static void set_has_been_dumped_once() { _has_been_dumped_once = true; }\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,0 +147,27 @@\n+class DumpClassListCLDClosure : public CLDClosure {\n+  fileStream *_stream;\n+public:\n+  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (ik->is_shareable()) {\n+          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+void MetaspaceShared::dump_loaded_classes(const char* file_name, TRAPS) {\n+  fileStream stream(file_name, \"w\");\n+  if (stream.is_open()) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    DumpClassListCLDClosure collect_classes(&stream);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n+  } else {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Failed to open file\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+  \/\/ print loaded classes names to file.\n+  static void dump_loaded_classes(const char* file_name, TRAPS);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3641,1 +3641,1 @@\n-  log_to_classlist(cfs);\n+  log_to_classlist();\n@@ -4234,1 +4234,1 @@\n-void InstanceKlass::log_to_classlist(const ClassFileStream* stream) const {\n+bool InstanceKlass::is_shareable() const {\n@@ -4236,0 +4236,22 @@\n+  ClassLoaderData* loader_data = class_loader_data();\n+  if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n+    return false;\n+  }\n+\n+  if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+    return false;\n+  }\n+\n+  if (module()->is_patched()) {\n+    return false;\n+  }\n+\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+void InstanceKlass::log_to_classlist() const {\n+#if INCLUDE_CDS\n+  ResourceMark rm;\n@@ -4242,39 +4264,1 @@\n-    ClassLoaderData* loader_data = class_loader_data();\n-    if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n-      return;\n-    }\n-    bool skip = false;\n-    if (is_shared()) {\n-      assert(stream == NULL, \"shared class with stream\");\n-      if (is_hidden()) {\n-        \/\/ Don't include archived lambda proxy class in the classlist.\n-        assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n-        return;\n-      }\n-    } else {\n-      assert(stream != NULL, \"non-shared class without stream\");\n-      \/\/ skip hidden class and unsafe anonymous class.\n-      if ( is_hidden() || unsafe_anonymous_host() != NULL) {\n-        return;\n-      }\n-      oop class_loader = loader_data->class_loader();\n-      if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {\n-        \/\/ For the boot and platform class loaders, skip classes that are not found in the\n-        \/\/ java runtime image, such as those found in the --patch-module entries.\n-        \/\/ These classes can't be loaded from the archive during runtime.\n-        if (!stream->from_boot_loader_modules_image() && strncmp(stream->source(), \"jrt:\", 4) != 0) {\n-          skip = true;\n-        }\n-\n-        if (class_loader == NULL && ClassLoader::contains_append_entry(stream->source())) {\n-          \/\/ .. but don't skip the boot classes that are loaded from -Xbootclasspath\/a\n-          \/\/ as they can be loaded from the archive during runtime.\n-          skip = false;\n-        }\n-      }\n-    }\n-    ResourceMark rm;\n-    if (skip) {\n-      tty->print_cr(\"skip writing class %s from source %s to classlist file\",\n-                    name()->as_C_string(), stream->source());\n-    } else {\n+    if (is_shareable()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":25,"deletions":41,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+  \/\/ Check if the class can be shared in CDS\n+  bool is_shareable() const;\n+\n@@ -1262,1 +1265,1 @@\n-  void log_to_classlist(const ClassFileStream* cfs) const;\n+  void log_to_classlist() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3656,1 +3656,1 @@\n-    return Arguments::is_dumping_archive();\n+  return Arguments::is_dumping_archive();\n@@ -3660,1 +3660,1 @@\n-    return UseSharedSpaces;\n+  return UseSharedSpaces;\n@@ -3706,0 +3706,18 @@\n+JVM_ENTRY(void, JVM_DumpClassListToFile(JNIEnv *env, jstring listFileName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(listFileName));\n+  char* file_name  = java_lang_String::as_utf8_string(file_handle());\n+  MetaspaceShared::dump_loaded_classes(file_name, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpDynamicArchive(JNIEnv *env, jstring archiveName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(archiveName));\n+  char* archive_name  = java_lang_String::as_utf8_string(file_handle());\n+  DynamicArchive::dump(archive_name, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3117,1 +3117,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3119,0 +3126,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3120,0 +3129,1 @@\n+\n@@ -3500,0 +3510,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1895,0 +1895,3 @@\n+  product(bool, RecordDynamicDumpInfo, false,                               \\\n+          \"Record class info for jcmd VM.cds dynamic_dump\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -1081,0 +1084,64 @@\n+#if INCLUDE_CDS\n+DumpSharedArchiveDCmd::DumpSharedArchiveDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _suboption(\"subcmd\", \"static_dump | dynamic_dump\", \"STRING\", true),\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+{\n+  _dcmdparser.add_dcmd_argument(&_suboption);\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+}\n+\n+void DumpSharedArchiveDCmd::execute(DCmdSource source, TRAPS) {\n+  jboolean is_static;\n+  const char* scmd = _suboption.value();\n+  const char* file = _filename.value();\n+\n+  if (strcmp(scmd, \"static_dump\") == 0) {\n+    is_static = JNI_TRUE;\n+    output()->print_cr(\"Static dump:\");\n+  } else if (strcmp(scmd, \"dynamic_dump\") == 0) {\n+    is_static = JNI_FALSE;\n+    output()->print_cr(\"Dynamic dump:\");\n+    if (!UseSharedSpaces) {\n+      output()->print_cr(\"Dynamic dump is unsupported when base CDS archive is not loaded\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output()->print_cr(\"Dump dynamic should run with -XX:+RecordDynamicDumpInfo\");\n+      return;\n+    }\n+  } else {\n+    output()->print_cr(\"Invalid command for VM.cds, valid input is static_dump or dynamic_dump\");\n+    return;\n+  }\n+\n+  \/\/ call CDS.dumpSharedArchive\n+  Handle fileh;\n+  if (file != NULL) {\n+    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+  }\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+  JavaValue result(T_VOID);\n+  JavaCallArguments args;\n+  args.push_int(is_static);\n+  args.push_oop(fileh);\n+  JavaCalls::call_static(&result,\n+                         cds_klass,\n+                         vmSymbols::dumpSharedArchive(),\n+                         vmSymbols::dumpSharedArchive_signature(),\n+                         &args, CHECK);\n+}\n+\n+int DumpSharedArchiveDCmd::num_arguments() {\n+  ResourceMark rm;\n+  DumpSharedArchiveDCmd* dcmd = new DumpSharedArchiveDCmd(NULL, false);\n+  if (dcmd != NULL) {\n+    DCmdMark mark(dcmd);\n+    return dcmd->_dcmdparser.num_arguments();\n+  } else {\n+    return 0;\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,0 +423,26 @@\n+#if INCLUDE_CDS\n+class DumpSharedArchiveDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _suboption;   \/\/ option of VM.cds\n+  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+public:\n+  DumpSharedArchiveDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.cds\";\n+  }\n+  static const char* description() {\n+    return \"Dump a static or dynamic shared archive including all shareable classes\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of loaded classes\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments();\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.InputStreamReader;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n@@ -29,0 +35,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -66,0 +74,1 @@\n+\n@@ -198,0 +207,119 @@\n+\n+    private static native void dumpClassList(String listFileName);\n+    private static native void dumpDynamicArchive(String archiveFileName);\n+\n+    private static String drainOutput(InputStream stream, long pid, String tail, List<String> cmds) {\n+        String fileName  = \"java_pid\" + pid + \"_\" + tail;\n+        new Thread( ()-> {\n+            try (InputStreamReader isr = new InputStreamReader(stream);\n+                 BufferedReader rdr = new BufferedReader(isr);\n+                 PrintStream prt = new PrintStream(fileName)) {\n+                prt.println(\"Command:\");\n+                for (String s : cmds) {\n+                    prt.print(s + \" \");\n+                }\n+                prt.println(\"\");\n+                String line;\n+                while((line = rdr.readLine()) != null) {\n+                    prt.println(line);\n+                }\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"IOExeption happens during drain stream to file \" +\n+                                           fileName + \": \" + e.getMessage());\n+            }}).start();\n+        return fileName;\n+    }\n+\n+    private static String[] excludeFlags = {\n+         \"-XX:DumpLoadedClassList=\",\n+         \"-XX:+DumpSharedSpaces\",\n+         \"-XX:+DynamicDumpSharedSpaces\",\n+         \"-XX:+RecordDynamicDumpInfo\",\n+         \"-Xshare:\",\n+         \"-XX:SharedClassListFile=\",\n+         \"-XX:SharedArchiveFile=\",\n+         \"-XX:ArchiveClassesAtExit=\",\n+         \"-XX:+UseSharedSpaces\",\n+         \"-XX:+RequireSharedSpaces\"};\n+    private static boolean containsExcludedFlags(String testStr) {\n+       for (String e : excludeFlags) {\n+           if (testStr.contains(e)) {\n+               return true;\n+           }\n+       }\n+       return false;\n+    }\n+\n+    \/**\n+    * called from jcmd VM.cds to dump static or dynamic shared archive\n+    * @param isStatic true for dump static archive or false for dynnamic archive.\n+    * @param fileName user input archive name, can be null.\n+    *\/\n+    private static void dumpSharedArchive(boolean isStatic, String fileName) throws Exception {\n+        String currentPid = String.valueOf(ProcessHandle.current().pid());\n+        String archiveFile =  fileName != null ? fileName :\n+            \"java_pid\" + currentPid + (isStatic ? \"_static.jsa\" : \"_dynamic.jsa\");\n+\n+        \/\/ delete if archive file aready exists\n+        File fileArchive = new File(archiveFile);\n+        if (fileArchive.exists()) {\n+            fileArchive.delete();\n+        }\n+        if (isStatic) {\n+            String listFile = archiveFile + \".classlist\";\n+            File fileList = new File(listFile);\n+            if (fileList.exists()) {\n+                fileList.delete();\n+            }\n+            dumpClassList(listFile);\n+            String jdkHome = System.getProperty(\"java.home\");\n+            String classPath = System.getProperty(\"java.class.path\");\n+            List<String> cmds = new ArrayList<String>();\n+            cmds.add(jdkHome + File.separator + \"bin\" + File.separator + \"java\"); \/\/ java\n+            cmds.add(\"-cp\");\n+            cmds.add(classPath);\n+            cmds.add(\"-Xlog:cds,class+load\");\n+            cmds.add(\"-Xshare:dump\");\n+            cmds.add(\"-XX:SharedClassListFile=\" + listFile);\n+            cmds.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+\n+            \/\/ All runtime args.\n+            String[] vmArgs = VM.getRuntimeArguments();\n+            if (vmArgs != null) {\n+                for (String arg : vmArgs) {\n+                    if (arg != null && !containsExcludedFlags(arg)) {\n+                        cmds.add(arg);\n+                    }\n+                }\n+            }\n+\n+            Process proc = Runtime.getRuntime().exec(cmds.toArray(new String[0]));\n+\n+            \/\/ Drain stdout\/stderr to files in new threads.\n+            String stdOutFile = drainOutput(proc.getInputStream(), proc.pid(), \"stdout\", cmds);\n+            String stdErrFile = drainOutput(proc.getErrorStream(), proc.pid(), \"stderr\", cmds);\n+\n+            proc.waitFor();\n+            \/\/ done, delete classlist file.\n+            if (fileList.exists()) {\n+                fileList.delete();\n+            }\n+            \/\/ Check if archive has been successfully dumped. We won't reach here if exception happens.\n+            \/\/ Throw exception if file is not created.\n+            if (!fileArchive.exists()) {\n+                throw new RuntimeException(\"Archive file \" + archiveFile +\n+                                           \" is not created, please check stdout file \" +\n+                                            stdOutFile + \" or stderr file \" +\n+                                            stdErrFile + \" for more detail\");\n+            }\n+        } else {\n+            dumpDynamicArchive(archiveFile);\n+            if (!fileArchive.exists()) {\n+                throw new RuntimeException(\"Archive file \" + archiveFile +\n+                                           \" is not created, please check process \" +\n+                                           currentPid + \" output for more detail\");\n+            }\n+        }\n+        \/\/ Everyting goes well, print out the file name.\n+        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFile);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":129,"deletions":1,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,10 @@\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpClassList(JNIEnv *env, jclass jcls, jstring fileName) {\n+    JVM_DumpClassListToFile(env, fileName);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpDynamicArchive(JNIEnv *env, jclass jcls, jstring archiveName) {\n+    JVM_DumpDynamicArchive(env, archiveName);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -327,0 +327,1 @@\n+ -runtime\/cds\/appcds\/jcmd\/JCmdTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,4 +86,0 @@\n-                \/\/ skip classes outside of jrt image\n-                output.shouldContain(\"skip writing class java\/lang\/NewClass\");\n-                \/\/ but classes on -Xbootclasspath\/a should not be skipped\n-                output.shouldNotContain(\"skip writing class boot\/append\/Foo\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/DumpClassList.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8259070\n+ * @summary Test jcmd to dump static and dynamic shared archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @modules jdk.jcmd\/sun.tools.common:+open\n+ * @compile ..\/test-classes\/Hello.java\n+ * @build sun.hotspot.WhiteBox\n+ * @build JCmdTestLingeredApp JCmdTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI JCmdTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+\n+public class JCmdTest {\n+    static final String TEST_CLASSES[]      = {\"JCmdTestLingeredApp\",\n+                                               \"jdk\/test\/lib\/apps\/LingeredApp\",\n+                                               \"jdk\/test\/lib\/apps\/LingeredApp$1\"};\n+    static final String BOOT_CLASSES[]      = {\"Hello\"};\n+    static final String SUBCMD_STATIC_DUMP  = \"static_dump\";\n+    static final String SUBCMD_DYNAMIC_DUMP = \"dynamic_dump\";\n+\n+    static final String STATIC_DUMP_FILE    = \"mystatic\";\n+    static final String DYNAMIC_DUMP_FILE   = \"mydynamic\";\n+\n+\n+    static final String[] STATIC_MESSAGES   = {\"JCmdTestLingeredApp source: shared objects file\",\n+                                               \"LingeredApp source: shared objects file\",\n+                                               \"Hello source: shared objects file\"};\n+    static final String[] DYNAMIC_MESSAGES  = {\"JCmdTestLingeredApp source: shared objects file (top)\",\n+                                               \"LingeredApp source: shared objects file (top)\",\n+                                               \"Hello source: shared objects file (top)\"};\n+\n+    static String testJar = null;\n+    static String bootJar = null;\n+    static String allJars = null;\n+\n+    private static void buildJar() throws Exception {\n+        testJar = JarBuilder.build(\"test\", TEST_CLASSES);\n+        bootJar = JarBuilder.build(\"boot\", BOOT_CLASSES);\n+        Path testJarPath = FileSystems.getDefault().getPath(testJar);\n+        Path bootJarPath = FileSystems.getDefault().getPath(bootJar);\n+        System.out.println(\"Jar file created: \" + testJarPath.toString());\n+        System.out.println(\"Jar file created: \" + bootJarPath.toString());\n+        allJars = testJar+ File.pathSeparator + bootJar;\n+    }\n+\n+    private static boolean argsContain(String[] args, String flag) {\n+         for (String s: args) {\n+             if (s.contains(flag)) {\n+                 return true;\n+             }\n+         }\n+         return false;\n+    }\n+\n+    private static boolean argsContainOpts(String[] args, String... opts) {\n+        boolean allIn = true;\n+        for (String f : opts) {\n+            allIn &= argsContain(args, f);\n+            if (!allIn) {\n+                break;\n+            }\n+        }\n+        return allIn;\n+    }\n+\n+    private static LingeredApp createLingeredApp(String... args) throws Exception {\n+        JCmdTestLingeredApp app  = new JCmdTestLingeredApp();\n+        try {\n+            LingeredApp.startAppExactJvmOpts(app, args);\n+        } catch (Exception e) {\n+            \/\/ Check flags used.\n+            if (argsContainOpts(args, new String[] {\"-Xshare:off\", \"-XX:+RecordDynamicDumpInfo\"}) ||\n+                argsContainOpts(args, new String[] {\"-XX:+RecordDynamicDumpInfo\", \"-XX:ArchiveClassesAtExit=\"})) {\n+                \/\/ app exit premature due to incompactible args\n+                return null;\n+            }\n+            Process proc = app.getProcess();\n+            if (e instanceof IOException && proc.exitValue() == 0) {\n+                \/\/ Process started and exit normally.\n+                return null;\n+            }\n+            throw e;\n+        }\n+        return app;\n+\n+    }\n+\n+    private static void runWithArchiveFile(String archiveName, boolean useBoot,  String... messages) throws Exception {\n+        List<String> args = new ArrayList<String>();\n+        if (useBoot) {\n+            args.add(\"-Xbootclasspath\/a:\" + bootJar);\n+        }\n+        args.add(\"-cp\");\n+        if (useBoot) {\n+            args.add(testJar);\n+        } else {\n+            args.add(allJars);\n+        }\n+        args.add(\"-Xshare:on\");\n+        args.add(\"-XX:SharedArchiveFile=\" + archiveName);\n+        args.add(\"-Xlog:class+load\");\n+\n+        LingeredApp app = createLingeredApp(args.toArray(new String[0]));\n+        app.stopApp();\n+        String output = app.getOutput().getStdout();\n+        if (messages != null) {\n+            for (String msg : messages) {\n+                if (!output.contains(msg)) {\n+                    throw new RuntimeException(msg + \" missed from oupt\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(String jcmdSub, String archiveFile,\n+                             long pid, boolean useBoot, boolean expectOK, String... messages) throws Exception {\n+        boolean isStatic = jcmdSub.equals(SUBCMD_STATIC_DUMP);\n+        String fileName = archiveFile != null ? archiveFile :\n+            (\"java_pid\" + pid + (isStatic ? \"_static\" : \"_dynamic\") + \".jsa\");\n+        File file = new File(fileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+\n+        String jcmd = \"VM.cds \" + jcmdSub;\n+        if (archiveFile  != null) {\n+          jcmd +=  \" \" + archiveFile;\n+        }\n+\n+        PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(String.valueOf(pid));\n+        OutputAnalyzer output = cmdExecutor.execute(jcmd, true\/*silent*\/);\n+\n+        if (expectOK) {\n+            output.shouldHaveExitValue(0);\n+            if (!file.exists()) {\n+                throw new RuntimeException(\"Could not create shared archive: \" + fileName);\n+            } else {\n+                runWithArchiveFile(fileName, useBoot, messages);\n+                file.delete();\n+            }\n+        } else {\n+            if (file.exists()) {\n+                throw new RuntimeException(\"Should not create shared archive \" + fileName);\n+            }\n+        }\n+    }\n+\n+    private static void print2ln(String arg) {\n+        System.out.println(\"\\n\" + arg + \"\\n\");\n+    }\n+\n+    \/\/ Those two flags will not create a successful LingeredApp.\n+    private static String[] noDumpFlags  =\n+        {\"-XX:+DumpSharedSpaces\",\n+         \"-Xshare:dump\"};\n+    \/\/ Those flags will be excluded in static dumping,\n+    \/\/ See src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java\n+    private static String[] excludeFlags = {\n+         \"-XX:DumpLoadedClassList=AnyFileName.classlist\",\n+         \/\/ this flag just dump archive, won't run app normally.\n+         \/\/ \"-XX:+DumpSharedSpaces\",\n+         \"-XX:+DynamicDumpSharedSpaces\",\n+         \"-XX:+RecordDynamicDumpInfo\",\n+         \"-Xshare:on\",\n+         \"-Xshare:auto\",\n+         \"-XX:SharedClassListFile=non-exist.classlist\",\n+         \"-XX:SharedArchiveFile=non-exist.jsa\",\n+         \"-XX:ArchiveClassesAtExit=tmp.jsa\",\n+         \"-XX:+UseSharedSpaces\",\n+         \"-XX:+RequireSharedSpaces\"};\n+\n+    \/\/ Times to dump cds against same process.\n+    private static final int ITERATION_TIMES = 2;\n+\n+    private static void test() throws Exception {\n+        LingeredApp app  = null;\n+        long pid;\n+        int  test_count = 1;\n+        final boolean useBoot = true;\n+        final boolean noBoot = !useBoot;\n+        final boolean EXPECT_PASS = true;\n+        final boolean EXPECT_FAIL = !EXPECT_PASS;\n+\n+        \/\/ Static dump with default name multiple times.\n+        print2ln(test_count++ + \" Static dump with default name multiple times.\");\n+        app  = createLingeredApp(\"-cp\", allJars);\n+        pid = app.getPid();\n+        for (int i = 0; i < ITERATION_TIMES; i++) {\n+            test(SUBCMD_STATIC_DUMP, null, pid, noBoot,  EXPECT_PASS, STATIC_MESSAGES);\n+        }\n+        app.stopApp();\n+\n+        \/\/ Test static dump with given file name.\n+        print2ln(test_count++ + \" Test static dump with given file name.\");\n+        app = createLingeredApp(\"-cp\", allJars);\n+        pid = app.getPid();\n+        for (int i = 0; i < ITERATION_TIMES; i++) {\n+            test(SUBCMD_STATIC_DUMP, STATIC_DUMP_FILE + \"0\" + i, pid, noBoot,  EXPECT_PASS, STATIC_MESSAGES);\n+        }\n+        app.stopApp();\n+\n+        \/\/  Test static dump with flags with which dumping should fail\n+        \/\/  This test will result classes.jsa in default server dir if -XX:SharedArchiveFile= not set.\n+        print2ln(test_count++ + \" Test static dump with flags with which dumping should fail.\");\n+        for (String flag : noDumpFlags) {\n+            app = createLingeredApp(\"-cp\", allJars, flag, \"-XX:SharedArchiveFile=tmp.jsa\");\n+            \/\/ Following should not be executed.\n+            if (app != null && app.getProcess().isAlive()) {\n+                pid = app.getPid();\n+                test(SUBCMD_STATIC_DUMP, null, pid, noBoot, EXPECT_FAIL);\n+                app.stopApp();\n+                \/\/ if above executed OK, mean failed.\n+                throw new RuntimeException(\"Should not dump successful with \" + flag);\n+            }\n+        }\n+\n+        \/\/ Test static with -Xbootclasspath\/a:boot.jar\n+        print2ln(test_count++ + \" Test static with -Xbootassath\/a:boot.jar\");\n+        app = createLingeredApp(\"-Xbootclasspath\/a:\" + bootJar, \"-cp\", testJar);\n+        pid = app.getPid();\n+        test(SUBCMD_STATIC_DUMP, null, pid, useBoot, EXPECT_PASS, STATIC_MESSAGES);\n+\n+        \/\/ Test static with limit-modules java.base.\n+        print2ln(test_count++ + \" Test static with --limit-modules java.base.\");\n+        app = createLingeredApp(\"--limit-modules\", \"java.base\", \"-cp\", allJars);\n+        pid = app.getPid();\n+        test(SUBCMD_STATIC_DUMP, null, pid, noBoot, EXPECT_FAIL);\n+\n+        \/\/ Test static dump with flags which will be filtered before dumping.\n+        print2ln(test_count++ + \" Test static dump with flags which will be filtered before dumping.\");\n+        for (String flag : excludeFlags) {\n+            app = createLingeredApp(\"-cp\", allJars, flag);\n+            pid = app.getPid();\n+            test(SUBCMD_STATIC_DUMP, null, pid, noBoot, EXPECT_PASS, STATIC_MESSAGES);\n+            app.stopApp();\n+        }\n+\n+\n+        \/\/ Test static with -Xshare:off will be OK to dump.\n+        print2ln(test_count++ + \" Test static with -Xshare:off will be OK to dump.\");\n+        app = createLingeredApp(\"-Xshare:off\", \"-cp\", allJars);\n+        pid = app.getPid();\n+        test(SUBCMD_STATIC_DUMP, null, pid, noBoot,  EXPECT_PASS, STATIC_MESSAGES);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic dump with -XX:+RecordDynamicDumpInfo.\n+        print2ln(test_count++ + \" Test dynamic dump with -XX:+RecordDynamicDumpInfo.\");\n+        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"01\", pid, noBoot, EXPECT_PASS, DYNAMIC_MESSAGES);\n+\n+        \/\/ Test dynamic dump twice to same process.\n+        print2ln(test_count++ + \" Test dynamic dump second time to the same process.\");\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"02\", pid, noBoot,  EXPECT_FAIL);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic dump with -XX:-RecordDynamicDumpInfo.\n+        print2ln(test_count++ + \" Test dynamic dump with -XX:-RecordDynamicDumpInfo.\");\n+        app = createLingeredApp(\"-cp\", allJars);\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"01\", pid, noBoot, EXPECT_FAIL);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic dump with default archive name (null).\n+        print2ln(test_count++ + \" Test dynamic dump with default archive name (null).\");\n+        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, null, pid, noBoot, EXPECT_PASS, DYNAMIC_MESSAGES);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic dump with flags -XX:+RecordDynamicDumpInfo -XX:-DynamicDumpSharedSpaces.\n+        print2ln(test_count++ + \" Test dynamic dump with flags -XX:+RecordDynamicDumpInfo -XX:-DynamicDumpSharedSpaces.\");\n+        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\", \"-XX:-DynamicDumpSharedSpaces\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, null, pid, noBoot, EXPECT_PASS, DYNAMIC_MESSAGES);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic dump with flags -XX:-DynamicDumpSharedSpaces -XX:+RecordDynamicDumpInfo.\n+        print2ln(test_count++ + \" Test dynamic dump with flags -XX:-DynamicDumpSharedSpaces -XX:+RecordDynamicDumpInfo.\");\n+        app = createLingeredApp(\"-cp\", allJars, \"-XX:-DynamicDumpSharedSpaces\", \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, null, pid, noBoot,  EXPECT_PASS, DYNAMIC_MESSAGES);\n+        app.stopApp();\n+\n+        \/\/ Test dynamic with -Xbootclasspath\/a:boot.jar\n+        print2ln(test_count++ + \" Test dynamic with -Xbootclasspath\/a:boot.jar\");\n+        app = createLingeredApp(\"-cp\", testJar, \"-Xbootclasspath\/a:\" + bootJar, \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, null, pid, useBoot, EXPECT_PASS, DYNAMIC_MESSAGES);\n+\n+        \/\/ Test dynamic dump with -XX:ArchiveClassAtExit will fail.\n+        print2ln(test_count++ + \" Test dynamic dump with -XX:ArchiveClassAtExit will fail.\");\n+        app = createLingeredApp(\"-cp\", allJars,\n+                                \"-Xshare:auto\",\n+                                \"-XX:+RecordDynamicDumpInfo\",\n+                                \"-XX:ArchiveClassesAtExit=AnyName.jsa\");\n+\n+        if (app != null) {\n+            if (app.getProcess().isAlive()) {\n+                throw new RuntimeException(\"The JCmdTestLingeredApp should not start up!\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        boolean cdsEnabled = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseSharedSpaces\");\n+        if (!cdsEnabled) {\n+            throw new SkippedException(\"CDS is not available for this JDK.\");\n+        }\n+        buildJar();\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class JCmdTestLingeredApp extends LingeredApp {\n+    public JCmdTestLingeredApp() {\n+        \/\/ Do not use default test.class.path in class path.\n+        setUseDefaultClasspath(false);\n+    }\n+\n+    public static void main(String args[]) {\n+        try {\n+            Class.forName(\"Hello\");\n+        } catch (Exception e) {\n+            System.out.print(\"Could not load Hello \"+ e);\n+        }\n+        LingeredApp.main(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestLingeredApp.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -92,0 +92,1 @@\n+    private boolean useDefaultClasspath = true;\n@@ -313,4 +314,6 @@\n-        \/\/ Make sure we set correct classpath to run the app\n-        cmd.add(\"-cp\");\n-        String classpath = System.getProperty(\"test.class.path\");\n-        cmd.add((classpath == null) ? \".\" : classpath);\n+        if (useDefaultClasspath()) {\n+            \/\/ Make sure we set correct classpath to run the app\n+            cmd.add(\"-cp\");\n+            String classpath = System.getProperty(\"test.class.path\");\n+            cmd.add((classpath == null) ? \".\" : classpath);\n+        }\n@@ -339,0 +342,3 @@\n+    public boolean useDefaultClasspath() { return useDefaultClasspath; }\n+    public void setUseDefaultClasspath(boolean value) { useDefaultClasspath = value; }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}