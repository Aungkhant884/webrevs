{"files":[{"patch":"@@ -55,0 +55,2 @@\n+JVM_DumpClassListToFile\n+JVM_DumpDynamicArchive\n@@ -87,0 +89,1 @@\n+JVM_GetVMArguments\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -303,0 +303,2 @@\n+  template(dumpSharedArchive, \"dumpSharedArchive\")                                                \\\n+  template(dumpSharedArchive_signature, \"(ZLjava\/lang\/String;)V\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,3 @@\n+JNIEXPORT jobjectArray JNICALL\n+JVM_GetVMArguments(JNIEnv* env);\n+\n@@ -203,0 +206,6 @@\n+JNIEXPORT void JNICALL\n+JVM_DumpClassListToFile(JNIEnv* env, jstring fileName);\n+\n+JNIEXPORT void JNICALL\n+JVM_DumpDynamicArchive(JNIEnv* env, jstring archiveName);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -342,0 +342,1 @@\n+bool DynamicArchive::_has_been_dumped_once = false;\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static bool _has_been_dumped_once;\n@@ -63,0 +64,2 @@\n+  static bool has_been_dumped_once() { return _has_been_dumped_once; }\n+  static void set_has_been_dumped_once() { _has_been_dumped_once = true; }\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/dynamicArchive.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4234,0 +4234,24 @@\n+bool InstanceKlass::is_shareable() const {\n+#if INCLUDE_CDS\n+  ClassLoaderData* loader_data = class_loader_data();\n+  if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n+    return false;\n+  }\n+  if (is_shared()) {\n+    if (is_hidden()) {\n+      \/\/ Don't include archived lambda proxy class in the classlist.\n+      assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n+      return false;\n+    }\n+  } else {\n+    \/\/ skip hidden class and unsafe anonymous class.\n+    if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+      return false;\n+    }\n+  }\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+  \/\/ if can be shared in CDS, used by jcmd VM.cds\n+  bool is_shareable() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -3663,0 +3664,15 @@\n+JVM_ENTRY(jobjectArray, JVM_GetVMArguments(JNIEnv* env))\n+  int num_vm_args = Arguments::num_jvm_args();\n+  if (num_vm_args == 0) {\n+    return NULL;\n+  }\n+\n+  char** vm_args  = Arguments::jvm_args_array();\n+  objArrayHandle h_args = oopFactory::new_objArray_handle(vmClasses::String_klass(), num_vm_args, CHECK_NULL);\n+  for(int i = 0; i < num_vm_args; i++) {\n+    Handle h = java_lang_String::create_from_str(vm_args[i], THREAD);\n+    h_args->obj_at_put(i, h());\n+  }\n+  return (jobjectArray) JNIHandles::make_local(THREAD, h_args());\n+JVM_END\n+\n@@ -3664,1 +3680,1 @@\n-    return Arguments::is_dumping_archive();\n+  return Arguments::is_dumping_archive();\n@@ -3668,1 +3684,1 @@\n-    return UseSharedSpaces;\n+  return UseSharedSpaces;\n@@ -3714,0 +3730,63 @@\n+#if INCLUDE_CDS\n+class DumpClassListCLDClosure : public CLDClosure {\n+  fileStream *_stream;\n+public:\n+  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (ik->is_shareable()) {\n+          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+};\n+#endif\n+\n+JVM_ENTRY(void, JVM_DumpClassListToFile(JNIEnv *env, jstring listFileName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(listFileName));\n+  char* file_name  = java_lang_String::as_utf8_string(file_handle());\n+  fileStream stream(file_name, \"w\");\n+  if (stream.is_open()) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    DumpClassListCLDClosure collect_classes(&stream);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n+  } else {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Failed to open file\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpDynamicArchive(JNIEnv *env, jstring archiveName))\n+#if INCLUDE_CDS\n+  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"Sanity check\");\n+  if (DynamicArchive::has_been_dumped_once()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+        \"Dynamic dump has been done, and should only be done once\");\n+  } else {\n+    \/\/ prevent multiple dumps.\n+    DynamicArchive::set_has_been_dumped_once();\n+  }\n+  assert(ArchiveClassesAtExit == nullptr, \"Sanity check\");\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(archiveName));\n+  char* archive_name  = java_lang_String::as_utf8_string(file_handle());\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n+    DynamicArchive::dump();\n+  } else {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+          \"Could not setup SharedDynamicArchivePath\");\n+  }\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+          \"Could not restore SharedDynamicArchivePath\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":81,"deletions":2,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -3117,1 +3117,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3119,0 +3126,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3120,0 +3129,1 @@\n+\n@@ -3500,0 +3510,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1895,0 +1895,3 @@\n+  product(bool, RecordDynamicDumpInfo, false,                               \\\n+          \"Record class info for jcmd VM.cds dynamic_dump\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -1081,0 +1084,72 @@\n+#if INCLUDE_CDS\n+DumpSharedArchiveDCmd::DumpSharedArchiveDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _suboption(\"subcmd\", \"static_dump | dynamic_dump\", \"STRING\", true),\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+{\n+  _dcmdparser.add_dcmd_argument(&_suboption);\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+}\n+\n+void DumpSharedArchiveDCmd::execute(DCmdSource source, TRAPS) {\n+  jboolean is_static;\n+  const char* scmd = _suboption.value();\n+  const char* file = _filename.value();\n+\n+  if (strcmp(scmd, \"static_dump\") == 0) {\n+    is_static = JNI_TRUE;\n+    output()->print_cr(\"Static dump:\");\n+  } else if (strcmp(scmd, \"dynamic_dump\") == 0) {\n+    is_static = JNI_FALSE;\n+    output()->print_cr(\"Dynamic dump:\");\n+    if (!UseSharedSpaces) {\n+      output()->print_cr(\"CDS is not available for the JDK\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output()->print_cr(\"Dump dynamic should run with -XX:+RecordDynamicDumpInfo\");\n+      return;\n+    }\n+  } else {\n+    output()->print_cr(\"Invalid command for VM.cds, valid input is static_dump or dynamic_dump\");\n+    return;\n+  }\n+\n+  \/\/ call CDS.dumpSharedArchive\n+  Handle fileh;\n+  if (file != NULL) {\n+    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+  }\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_int(is_static);\n+  args.push_oop(fileh);\n+  output()->print_cr(\"Call CDS.dumpSharedArchive(%s, %s)\", scmd, (file == NULL ? \"null\" : file));\n+  JavaCalls::call_static(&result,\n+                         cds_klass,\n+                         vmSymbols::dumpSharedArchive(),\n+                         vmSymbols::dumpSharedArchive_signature(),\n+                         &args, THREAD);\n+  \/\/ Upon exception, show stack trace.\n+  if (HAS_PENDING_EXCEPTION) {\n+    Handle throwable(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    java_lang_Throwable::print_stack_trace(throwable, output());\n+    output()->cr();\n+  }\n+}\n+\n+int DumpSharedArchiveDCmd::num_arguments() {\n+  ResourceMark rm;\n+  DumpSharedArchiveDCmd* dcmd = new DumpSharedArchiveDCmd(NULL, false);\n+  if (dcmd != NULL) {\n+    DCmdMark mark(dcmd);\n+    return dcmd->_dcmdparser.num_arguments();\n+  } else {\n+    return 0;\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -423,0 +423,26 @@\n+#if INCLUDE_CDS\n+class DumpSharedArchiveDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _suboption;   \/\/ option of VM.cds\n+  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+public:\n+  DumpSharedArchiveDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.cds\";\n+  }\n+  static const char* description() {\n+    return \"Dump a static or dynamic shared archive including all shareable classes\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of loaded classes\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments();\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.IOException;\n@@ -29,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +37,3 @@\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+\n@@ -66,0 +73,1 @@\n+    private static native String[] getVMArguments(); \/\/ return commandline args except for executable itself.\n@@ -198,0 +206,109 @@\n+\n+    private static native void dumpClassList(String listFileName);\n+    private static native void dumpDynamicArchive(String archiveFileName);\n+\n+    private static void outputStdStream(InputStream stream) {\n+        String line;\n+        InputStreamReader isr = new InputStreamReader(stream);\n+        BufferedReader rdr = new BufferedReader(isr);\n+        try {\n+            while((line = rdr.readLine()) != null) {\n+                System.out.println(line);\n+            }\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"IOExeption happens during drain stream \" + e.getMessage());\n+        }\n+    }\n+\n+    private static String[] excludeFlags = {\n+         \"-XX:DumpLoadedClassList=\",\n+         \"-XX:+DumpSharedSpaces\",\n+         \"-XX:+DynamicDumpSharedSpaces\",\n+         \"-XX:+RecordDynamicDumpInfo\",\n+         \"-Xshare:\",\n+         \"-XX:SharedClassListFile=\",\n+         \"-XX:SharedArchiveFile=\",\n+         \"-XX:ArchiveClassesAtExit=\",\n+         \"-XX:+UseSharedSpaces\",\n+         \"-XX:+RequireSharedSpaces\"};\n+    private static boolean containsExcludedFlags(String testStr) {\n+       for (String e : excludeFlags) {\n+           if (testStr.contains(e)) {\n+               return true;\n+           }\n+       }\n+       return false;\n+    }\n+\n+    \/**\n+    * called from jcmd VM.cds to dump static or dynamic shared archive\n+    * @param isStatic true for dump static archive or false for dynnamic archive.\n+    * @param fileName user input archive name, can be null.\n+    *\/\n+    private static void dumpSharedArchive(boolean isStatic, String fileName) throws Exception {\n+        String archiveFile =  fileName != null ? fileName :\n+            \"java_pid\" + ProcessHandle.current().pid() + (isStatic ? \"_static.jsa\" : \"_dynamic.jsa\");\n+        System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFile);\n+\n+        \/\/ delete if archive file aready exists\n+        File fileArchive = new File(archiveFile);\n+        if (fileArchive.exists()) {\n+            fileArchive.delete();\n+        }\n+        if (isStatic) {\n+            String listFile = archiveFile + \".classlist\";\n+            File fileList = new File(listFile);\n+            if (fileList.exists()) {\n+                fileList.delete();\n+            }\n+            dumpClassList(listFile);\n+            String jdkHome = System.getProperty(\"java.home\");\n+            ArrayList<String> cmds = new ArrayList<String>();\n+            cmds.add(jdkHome + File.separator + \"bin\" + File.separator + \"java\"); \/\/ java\n+            cmds.add(\"-Xlog:cds\");\n+            cmds.add(\"-Xshare:dump\");\n+            cmds.add(\"-XX:SharedClassListFile=\" + listFile);\n+            cmds.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+            \/\/ All args in command line\n+            String[] vmArgs = getVMArguments();\n+            if (vmArgs != null) {\n+                for (String arg : vmArgs) {\n+                    if (arg != null && !containsExcludedFlags(arg)) {\n+                        cmds.add(arg);\n+                    }\n+                }\n+            }\n+\n+            System.out.println(\"Static dump cmd: \");\n+            for (String s : cmds) {\n+                System.out.print(s + \" \");\n+            }\n+            System.out.println(\"\");\n+\n+            \/\/ Do not take parent env which will cause check error on empty directory if\n+            \/\/ classpath carried in envp.\n+            Process proc = Runtime.getRuntime().exec(cmds.toArray(new String[0]),\n+                               new String[] {\"EnvP=null\"});\n+\n+            \/\/ Drain stdout in a separate thread.\n+            new Thread( ()-> {\n+                    System.out.println(\"Dumping process \" + proc.pid() + \" Stdout: \");\n+                    outputStdStream(proc.getInputStream());\n+                }).start();\n+\n+            \/\/ Drain stderr in a separate thread.\n+            new Thread( ()-> {\n+                    System.out.println(\"Dumping process \" + proc.pid() + \" Stdout: \");\n+                    outputStdStream(proc.getErrorStream());\n+                }).start();\n+\n+            proc.waitFor();\n+        } else {\n+            dumpDynamicArchive(archiveFile);\n+        }\n+        \/\/ Check if archive has been successfully dumped. We won't reach here if exception happens.\n+        \/\/ Throw exception if file is not created.\n+        if (!fileArchive.exists()) {\n+            throw new RuntimeException(\"Archive file \" + archiveFile + \" is not created\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":118,"deletions":1,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,15 @@\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpClassList(JNIEnv *env, jclass jcls, jstring fileName) {\n+    JVM_DumpClassListToFile(env, fileName);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpDynamicArchive(JNIEnv *env, jclass jcls, jstring archiveName) {\n+    JVM_DumpDynamicArchive(env, archiveName);\n+}\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_internal_misc_CDS_getVMArguments(JNIEnv *env, jclass jcls) {\n+    return JVM_GetVMArguments(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8259070\n+ * @summary Test jcmd to dump static and dynamic shared archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @modules jdk.jcmd\/sun.tools.common:+open\n+ * @build sun.hotspot.WhiteBox\n+ * @build LingeredTestApp JCmdTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI JCmdTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+\n+public class JCmdTest {\n+    static final String TEST_CLASS[] = {\"LingeredTestApp\", \"jdk\/test\/lib\/apps\/LingeredApp\"};\n+    static final String TEST_JAR   = \"test.jar\";\n+    static final String SUBCMD_STATIC_DUMP = \"static_dump\";\n+    static final String SUBCMD_DYNAMIC_DUMP= \"dynamic_dump\";\n+\n+    static final String STATIC_DUMP_FILE = \"mystatic\";\n+    static final String DYNAMIC_DUMP_FILE = \"mydynamic\";\n+\n+    static boolean EXPECT_PASS = true;\n+    static boolean EXPECT_FAIL = !EXPECT_PASS;\n+\n+    static String jarFile = null;\n+\n+    private static void buildJar() throws Exception {\n+        jarFile = JarBuilder.build(\"test\", TEST_CLASS);\n+        Path path = FileSystems.getDefault().getPath(jarFile);\n+        System.out.println(\"Jar file created: \" + path.toString());\n+    }\n+\n+    private static boolean argsContain(String[] args, String flag) {\n+         for (String s: args) {\n+             if (s.contains(flag)) {\n+                 return true;\n+             }\n+         }\n+         return false;\n+    }\n+\n+    private static boolean argsContainOpts(String[] args, String... opts) {\n+        boolean allIn = true;\n+        for (String f : opts) {\n+            allIn &= argsContain(args, f);\n+            if (!allIn) {\n+                break;\n+            }\n+        }\n+        return allIn;\n+    }\n+\n+    private static LingeredApp createLingeredApp(String... args) throws Exception {\n+        LingeredTestApp app  = new LingeredTestApp();\n+        try {\n+            LingeredApp.startAppExactJvmOpts(app, args);\n+        } catch (Exception e) {\n+            \/\/ Check flags used.\n+            if (argsContainOpts(args, new String[] {\"-Xshare:off\", \"-XX:+RecordDynamicDumpInfo\"}) ||\n+                argsContainOpts(args, new String[] {\"-XX:+RecordDynamicDumpInfo\", \"-XX:ArchiveClassesAtExit=\"})) {\n+                \/\/ app exit premature due to incompactible args\n+                return null;\n+            }\n+            Process proc = app.getProcess();\n+            if (e instanceof IOException && proc.exitValue() == 0) {\n+                \/\/ Process started and exit normally.\n+                return null;\n+            }\n+            throw e;\n+        }\n+        return app;\n+\n+    }\n+\n+    private static void test(String jcmdSub, String archiveFile,\n+                             long pid, boolean expectOK) throws Exception {\n+        boolean isStatic = jcmdSub.equals(SUBCMD_STATIC_DUMP);\n+        String fileName = archiveFile != null ? archiveFile :\n+            (\"java_pid\" + pid + (isStatic ? \"_static\" : \"_dynamic\") + \".jsa\");\n+        File file = new File(fileName);\n+        if (file.exists()) {\n+            file.delete();\n+        }\n+\n+        String jcmd = \"VM.cds \" + jcmdSub;\n+        if (archiveFile  != null) {\n+          jcmd +=  \" \" + archiveFile;\n+        }\n+\n+        PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(String.valueOf(pid));\n+        OutputAnalyzer output = cmdExecutor.execute(jcmd, true\/*silent*\/);\n+\n+        if (expectOK) {\n+            output.shouldHaveExitValue(0);\n+            if (!file.exists()) {\n+                throw new RuntimeException(\"Could not create shared archive: \" + fileName);\n+            } else {\n+                file.delete();\n+            }\n+        } else {\n+            if (file.exists()) {\n+                throw new RuntimeException(\"Should not create shared archive \" + fileName);\n+            }\n+        }\n+    }\n+\n+    private static void print2ln(String arg) {\n+        System.out.println(\"\\n\" + arg + \"\\n\");\n+    }\n+\n+    \/\/ Those two flags will not create a successful LingeredApp.\n+    private static String[] noDumpFlags  =\n+        {\"-XX:+DumpSharedSpaces\",\n+         \"-Xshare:dump\"};\n+    \/\/ Those flags will be excluded in static dumping.\n+    private static String[] excludeFlags =\n+        {\"-XX:DumpLoadedClassList=AnyFileName.classlist\",\n+         \"-XX:+UseSharedSpaces\",\n+         \"-XX:+RecordDynamicDumpInfo\",\n+         \"-XX:+RequireSharedSpaces\",\n+         \"-XX:+DynamicDumpSharedSpaces\",\n+         \"-XX:ArchiveClassesAtExit=tmp.jsa\",\n+         \"-Xshare:auto\",\n+         \"-Xshare:on\"};\n+\n+    \/\/ Times to dump cds against same process.\n+    private static final int ITERATION_TIMES = 2;\n+\n+    private static void test() throws Exception {\n+        LingeredApp app  = null;\n+        long pid;\n+\n+        \/\/ 1. Static dump with default name multiple times.\n+        print2ln(\"1: Static dump with default name multiple times.\");\n+        app  = createLingeredApp(\"-cp\", jarFile);\n+        pid = app.getPid();\n+        for (int i = 0; i < ITERATION_TIMES; i++) {\n+            test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n+        }\n+        app.stopApp();\n+\n+        \/\/ 2. Test static dump with given file name.\n+        print2ln(\"2. Test static dump with given file name.\");\n+        app = createLingeredApp(\"-cp\", jarFile);\n+        pid = app.getPid();\n+        for (int i = 0; i < ITERATION_TIMES; i++) {\n+            test(SUBCMD_STATIC_DUMP, STATIC_DUMP_FILE + \"0\" + i, pid, EXPECT_PASS);\n+        }\n+        app.stopApp();\n+\n+        \/\/ 3. Test static dump with flags which no dump will happen.\n+        \/\/    This test will result classes.jsa in default server dir if -XX:SharedArchiveFile= not set.\n+        print2ln(\"3. Test static dump with flags which will no dump will happen.\");\n+        for (String flag : noDumpFlags) {\n+            app  = createLingeredApp(\"-cp\", jarFile, flag, \"-XX:SharedArchiveFile=tmp.jsa\");\n+            \/\/ Following should not be executed.\n+            if (app != null && app.getProcess().isAlive()) {\n+                pid = app.getPid();\n+                test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_FAIL);\n+                app.stopApp();\n+                \/\/ if above executed OK, mean failed.\n+                throw new RuntimeException(\"Should not dump successful with \" + flag);\n+            }\n+        }\n+\n+        \/\/ 4. Test static dump with flags which will be filtered before dumping.\n+        print2ln(\"4. Test static dump with flags which will be filtered before dumping.\");\n+        for (String flag : excludeFlags) {\n+            app  = createLingeredApp(\"-cp\", jarFile, flag);\n+            pid = app.getPid();\n+            test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n+            app.stopApp();\n+        }\n+\n+\n+        \/\/ 5. Test static with -Xshare:off will be OK to dump.\n+        print2ln(\"5. Test static with -Xshare:off will be OK to dump.\");\n+        app  = createLingeredApp(\"-Xshare:off\", \"-cp\", jarFile);\n+        pid = app.getPid();\n+        test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n+        app.stopApp();\n+\n+        \/\/ 6. Test dynamic dump with -XX:+RecordDynamicDumpInfo.\n+        print2ln(\"6. Test dynamic dump with -XX:+RecordDynamicDumpInfo.\");\n+        app  = createLingeredApp(\"-cp\", jarFile, \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"01\", pid, EXPECT_PASS);\n+\n+        \/\/ 7. Test dynamic dump twice to same process.\n+        print2ln(\"7. Test dynamic dump second time to the same process.\");\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"02\", pid, EXPECT_FAIL);\n+        app.stopApp();\n+\n+        \/\/ 8. Test dynamic dump with -XX:-RecordDynamicDumpInfo.\n+        print2ln(\"8. Test dynamic dump with -XX:-RecordDynamicDumpInfo.\");\n+        app  = createLingeredApp(\"-cp\", jarFile);\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"01\", pid, EXPECT_FAIL);\n+        app.stopApp();\n+\n+        \/\/ 9. Test dynamic dump with default archive name (null).\n+        print2ln(\"9. Test dynamic dump with default archive name (null).\");\n+        app = createLingeredApp(\"-cp\", jarFile, \"-XX:+RecordDynamicDumpInfo\");\n+        pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, null, pid, EXPECT_PASS);\n+\n+        \/\/ 10. Test dynamic dump with -XX:ArchiveClassAtExit will fail.\n+        print2ln(\"10. Test dynamic dump with -XX:ArchiveClassAtExit will fail.\");\n+        app = createLingeredApp(\"-cp\", jarFile,\n+                                \"-Xshare:auto\",\n+                                \"-XX:+RecordDynamicDumpInfo\",\n+                                \"-XX:ArchiveClassesAtExit=AnyName.jsa\");\n+\n+        if (app != null) {\n+            if (app.getProcess().isAlive()) {\n+                throw new RuntimeException(\"The LingeredTestApp should not start up!\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        boolean cdsEnabled = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseSharedSpaces\");\n+        if (!cdsEnabled) {\n+            throw new SkippedException(\"CDS is not available for this JDK.\");\n+        }\n+        buildJar();\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredTestApp extends LingeredApp {\n+    \/\/ Do not use default test.class.path in class path.\n+    public boolean useDefaultClasspath() { return false; }\n+\n+    public static void main(String args[]) {\n+        LingeredApp.main(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/LingeredTestApp.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -313,4 +313,6 @@\n-        \/\/ Make sure we set correct classpath to run the app\n-        cmd.add(\"-cp\");\n-        String classpath = System.getProperty(\"test.class.path\");\n-        cmd.add((classpath == null) ? \".\" : classpath);\n+        if (useDefaultClasspath()) {\n+            \/\/ Make sure we set correct classpath to run the app\n+            cmd.add(\"-cp\");\n+            String classpath = System.getProperty(\"test.class.path\");\n+            cmd.add((classpath == null) ? \".\" : classpath);\n+        }\n@@ -339,0 +341,2 @@\n+    public boolean useDefaultClasspath() { return true; }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}