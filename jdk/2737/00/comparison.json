{"files":[{"patch":"@@ -342,0 +342,1 @@\n+bool DynamicArchive::_has_been_dumped_once = false;\n@@ -345,1 +346,6 @@\n-    log_warning(cds, dynamic)(\"SharedDynamicArchivePath is not specified\");\n+    if (!RecordDynamicDumpInfo) {\n+      \/\/ If run with -XX:+RecordDynamicDumpInfo, DynamicDumpSharedSpaces will be turned on,\n+      \/\/ but ArchiveClassesAtExit, ie, the shared archive file is not specified. To differ the\n+      \/\/ two cases, silence when RecordDynamicDumpInfo is on.\n+      log_warning(cds, dynamic)(\"SharedDynamicArchivePath is not specified\");\n+    }\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static bool _has_been_dumped_once;\n@@ -63,0 +64,2 @@\n+  static bool has_been_dumped_once() { return _has_been_dumped_once; }\n+  static void set_has_been_dumped_once() { _has_been_dumped_once = true; }\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/dynamicArchive.hpp\"\n@@ -779,0 +780,126 @@\n+void append_strings(char* buffer, size_t buff_len,  const char* arg) {\n+  char* start = buffer + strlen(buffer);\n+  snprintf(start, buff_len, \"%s \", arg);\n+}\n+\n+void MetaspaceShared::cmd_dump_shared_archive(outputStream* output, const char* cmd, const char* file_name,  TRAPS) {\n+  \/\/ The existing file will be overwritten.\n+  char filename[JVM_MAXPATHLEN];\n+  const char* file = file_name;\n+  assert(strcmp(cmd, \"static_dump\") == 0 || strcmp(cmd, \"dynamic_dump\") == 0, \"Sanity check\");\n+  bool is_static = strcmp(cmd, \"static_dump\") == 0;\n+  if (is_static) {\n+    output->print_cr(\"Static dump\");\n+    if (file_name ==nullptr) {\n+      os::snprintf(filename, sizeof(filename), \"java_pid%d_static.jsa\", os::current_process_id());\n+      file = filename;\n+    } else {\n+      if (strstr(file_name, \".jsa\") == nullptr) {\n+        os::snprintf(filename, sizeof(filename), \"%s.jsa\", file_name);\n+        file = filename;\n+      }\n+    }\n+    cmd_dump_static(output, file, THREAD);\n+  } else {\n+    output->print_cr(\"Dynamic dump\");\n+    if (!UseSharedSpaces) {\n+      output->print_cr(\"CDS is not available for this version.\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output->print_cr(\"Please run with -Xshare:auto -XX:+RecordDynamicDumpInfo dumping dynamic archive!\");\n+      return;\n+    }\n+    if (file_name == nullptr) {\n+      os::snprintf(filename, sizeof(filename), \"java_pid%d_dynamic.jsa\", os::current_process_id());\n+      file = filename;\n+    } else {\n+      if (strstr(file_name, \".jsa\") == nullptr) {\n+        os::snprintf(filename, sizeof(filename), \"%s.jsa\", file_name);\n+        file = filename;\n+      }\n+    }\n+    cmd_dump_dynamic(output, file, THREAD);\n+  }\n+}\n+\n+class DumpClassListCLDClosure : public CLDClosure {\n+  fileStream *_stream;\n+public:\n+  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  ~DumpClassListCLDClosure() {\n+    delete _stream; \/\/ The file need close since in child process it will be used.\n+  }\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (ik->is_shareable()) {\n+          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/   To create a static dump, steps:\n+\/\/   1. output a classlist file\n+\/\/   2. fork a new process to dump the shared archive\n+void MetaspaceShared::cmd_dump_static(outputStream* output, const char* file, TRAPS) {\n+  const char* java_home = Arguments::get_java_home();\n+  const char* file_separator = os::file_separator();\n+  const char* app_class_path = Arguments::get_appclasspath();  \/\/ -cp ..\n+  const char* java_command = Arguments::java_command();        \/\/ arguments to app\n+  char exec_path[JVM_MAXPATHLEN]; \/\/ $JAVA_HOME\/bin\/java or %JAVA_HOME%\\\\jre\\bin\\\\java ...\n+  char classlist_name[JVM_MAXPATHLEN];\n+\n+  os::snprintf(classlist_name, sizeof(classlist_name), \"%s.classlist\", file);\n+\n+  ResourceMark rm;\n+  fileStream* stream = new (ResourceObj::C_HEAP, mtInternal) fileStream(classlist_name, \"w\");\n+  if (stream->is_open()) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    DumpClassListCLDClosure collect_classes(stream);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n+  } else {\n+    output->print_cr(\"Error to open %s for write!\", classlist_name);\n+    return;\n+  }\n+  os::snprintf(exec_path, sizeof(exec_path),\n+               \"%s%sbin%sjava -Xshare:dump -XX:SharedClassListFile=%s -XX:SharedArchiveFile=%s \",\n+               java_home, file_separator, file_separator, classlist_name, file);\n+  int num_vm_args = Arguments::num_jvm_args();\n+  char** vm_args  = Arguments::jvm_args_array();\n+  for (int i = 0; i < num_vm_args; i ++) {\n+    append_strings(exec_path, sizeof(exec_path), vm_args[i]);\n+  }\n+  \/\/ Turn off RecordDynamicDumpInfo\n+  if (RecordDynamicDumpInfo) {\n+    append_strings(exec_path, sizeof(exec_path), \"-XX:-RecordDynamicDumpInfo\");\n+  }\n+  char* buff_start = exec_path + strlen(exec_path);\n+  snprintf(buff_start, sizeof(exec_path), \" -cp %s %s\", app_class_path, java_command);\n+  output->print_cr(\"%s\", exec_path);\n+  os::fork_and_exec(exec_path);\n+}\n+\n+void MetaspaceShared::cmd_dump_dynamic(outputStream* output, const char* file, TRAPS) {\n+  if (DynamicArchive::has_been_dumped_once()) {\n+    output->print_cr(\"Dynamic dump has been done, and should only be done once.\");\n+    return;\n+  } else {\n+    \/\/ prevent multiple dumps.\n+    DynamicArchive::set_has_been_dumped_once();\n+  }\n+  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"Sanity check\");\n+  const char* tmp_file = ArchiveClassesAtExit;\n+  ArchiveClassesAtExit = file;\n+  if (Arguments::init_shared_archive_paths()) {\n+    DynamicArchive::dump();\n+  } else {\n+    output->print_cr(\"Could not setup SharedDynamicArchivePath!\");\n+  }\n+  ArchiveClassesAtExit = tmp_file;\n+  Arguments::init_shared_archive_paths();\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -86,0 +86,5 @@\n+  \/\/ those cmd_ functions used for dump cds for jcmd.\n+  static void cmd_dump_shared_archive(outputStream* output, const char* cmd, const char* filename, TRAPS) NOT_CDS_RETURN;\n+  static void cmd_dump_static(outputStream* output, const char* filename, TRAPS) NOT_CDS_RETURN;\n+  static void cmd_dump_dynamic(outputStream* output, const char* filename, TRAPS) NOT_CDS_RETURN;\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4233,0 +4233,24 @@\n+bool InstanceKlass::is_shareable() const {\n+#if INCLUDE_CDS\n+  ClassLoaderData* loader_data = class_loader_data();\n+  if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n+    return false;\n+  }\n+  if (is_shared()) {\n+    if (is_hidden()) {\n+      \/\/ Don't include archived lambda proxy class in the classlist.\n+      assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n+      return false;\n+    }\n+  } else {\n+    \/\/ skip hidden class and unsafe anonymous class.\n+    if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+      return false;\n+    }\n+  }\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+  \/\/ if can be shared in CDS, used by jcmd VM.cds\n+  bool is_shareable() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3128,1 +3128,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3130,0 +3137,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3131,0 +3140,1 @@\n+\n@@ -3511,0 +3521,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1895,0 +1895,3 @@\n+  product(bool, RecordDynamicDumpInfo, false,                               \\\n+          \"Record class info for jcmd Dynamic dump\")                        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/metaspaceShared.hpp\"\n@@ -123,0 +124,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n@@ -1081,0 +1083,28 @@\n+DumpSharedArchiveDCmd::DumpSharedArchiveDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _suboption(\"subcmd\", \"static_dump | dynamic_dump\", \"STRING\", true),\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+{\n+  _dcmdparser.add_dcmd_argument(&_suboption);\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+}\n+\n+void DumpSharedArchiveDCmd::execute(DCmdSource source, TRAPS) {\n+  if (strcmp(_suboption.value(), \"static_dump\") != 0 && strcmp(_suboption.value(), \"dynamic_dump\") != 0) {\n+    output()->print_cr(\"Invalid command for VM.cds, please use static_dump or dynamic_dump\");\n+    return;\n+  }\n+  MetaspaceShared::cmd_dump_shared_archive(output(), _suboption.value(), _filename.value(), THREAD);\n+}\n+\n+int DumpSharedArchiveDCmd::num_arguments() {\n+  ResourceMark rm;\n+  DumpSharedArchiveDCmd* dcmd = new DumpSharedArchiveDCmd(NULL, false);\n+  if (dcmd != NULL) {\n+    DCmdMark mark(dcmd);\n+    return dcmd->_dcmdparser.num_arguments();\n+  } else {\n+    return 0;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -423,0 +423,24 @@\n+class DumpSharedArchiveDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _suboption;   \/\/ option of VM.cds\n+  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+public:\n+  DumpSharedArchiveDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.cds\";\n+  }\n+  static const char* description() {\n+    return \"Dump a static or dynamic shared archive including all shareable classes\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of loaded classes\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments();\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8259070\n+ * @summary Test jcmd to dump static and dynamic shared archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @modules jdk.jcmd\/sun.tools.common:+open\n+ * @build sun.hotspot.WhiteBox\n+ * @build LingeredTestApp JCmdTest\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI JCmdTest\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+public class JCmdTest {\n+    static final String TEST_CLASS[] = {\"LingeredTestApp\", \"jdk\/test\/lib\/apps\/LingeredApp\"};\n+    static final String TEST_JAR   = \"test.jar\";\n+    static final String SUBCMD_STATIC_DUMP = \"static_dump\";\n+    static final String SUBCMD_DYNAMIC_DUMP= \"dynamic_dump\";\n+\n+    static final String STATIC_DUMP_FILE = \"mystatic\";\n+    static final String DYNAMIC_DUMP_FILE = \"mydynamic\";\n+\n+    static boolean EXPECT_PASS = true;\n+    static boolean EXPECT_FAIL = !EXPECT_PASS;\n+    static String jarFile = null;\n+\n+    private static void buildJar() throws Exception {\n+        jarFile = JarBuilder.build(\"test\", TEST_CLASS);\n+        Path path = FileSystems.getDefault().getPath(jarFile);\n+        System.out.println(\"Jar file created: \" + path.toString());\n+    }\n+\n+    private static boolean argsContain(String[] args, String flag) {\n+         for (String s: args) {\n+             if (s.contains(flag)) {\n+                 return true;\n+             }\n+         }\n+         return false;\n+    }\n+\n+    private static boolean argsContainOpts(String[] args, String... opts) {\n+        boolean allIn = true;\n+        for (String f : opts) {\n+            allIn &= argsContain(args, f);\n+            if (!allIn) {\n+                break;\n+            }\n+        }\n+        return allIn;\n+    }\n+\n+    private static LingeredApp createLingeredApp(String... args) throws Exception {\n+        LingeredTestApp app  = new LingeredTestApp();\n+        try {\n+            LingeredApp.startAppExactJvmOpts(app, args);\n+        } catch (Exception e) {\n+            \/\/ Check flags used.\n+            if (argsContainOpts(args, new String[] {\"-Xshare:off\", \"-XX:+RecordDynamicDumpInfo\"}) ||\n+                argsContainOpts(args, new String[] {\"-XX:+RecordDynamicDumpInfo\", \"-XX:ArchiveClassesAtExit=\"})) {\n+                \/\/ app exit premature due to incompactible args\n+                return null;\n+            }\n+            throw e;\n+        }\n+        return app;\n+\n+    }\n+\n+    private static void test(String jcmdSub, String archiveFile, long pid, boolean expectSuccess) throws Exception {\n+\n+        boolean isStatic = jcmdSub.equals(\"static_dump\") ? true : false;\n+\n+        String cdsFileName = archiveFile;\n+        if (cdsFileName == null) {\n+            cdsFileName = \"java_pid\" + pid + \"_\" + (isStatic  ? \"static\" : \"dynamic\") + \".jsa\";\n+        } else {\n+            if (!cdsFileName.endsWith(\".jsa\")) {\n+                cdsFileName = cdsFileName + \".jsa\";\n+            }\n+        }\n+\n+        File file = new File(cdsFileName);\n+        if (file.exists() && file.isFile()) {\n+            file.delete();\n+        }\n+\n+        String jcmd = \"VM.cds \" + jcmdSub + \" \" + cdsFileName;;\n+\n+        PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(\"\" + pid);\n+        System.out.println(\"JCMD: \" + jcmd);\n+        OutputAnalyzer output = cmdExecutor.execute(jcmd, false\/*silent*\/);\n+        output.shouldHaveExitValue(0);\n+\n+        Path path = FileSystems.getDefault().getPath(cdsFileName);\n+        if (expectSuccess) {\n+            if (Files.notExists(path)) {\n+                throw new RuntimeException(\"Could not create shared archive \" + cdsFileName);\n+            }\n+        } else {\n+            if (Files.exists(path)) {\n+                throw new RuntimeException(\"Should not create shared archive \" + cdsFileName);\n+            }\n+        }\n+    }\n+\n+    private static void print2ln(String arg) {\n+        System.out.println(\"\\n\" + arg + \"\\n\");\n+    }\n+\n+    private static void test_static() throws Exception {\n+        ArrayList<String> vmArgs = new ArrayList<String>();\n+        vmArgs.add(\"-cp\");\n+        vmArgs.add(jarFile);\n+        vmArgs.add(\"-Xlog:class+path\");\n+        vmArgs.add(\"-XX:+RecordDynamicDumpInfo\");\n+        LingeredApp app  = null;\n+        app = createLingeredApp(vmArgs.toArray(new String[0]));\n+        long pid = app.getPid();\n+\n+        \/\/ 1. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times\n+        print2ln(\"1. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times.\");\n+        for (int i = 0; i < 3; i++) {\n+            test(SUBCMD_STATIC_DUMP, STATIC_DUMP_FILE + \"0\" + i, pid, EXPECT_PASS);\n+        }\n+        app.stopApp();\n+        vmArgs.clear();\n+        \/\/ 2. Static dump with default name multiple times.\n+        print2ln(\"2: Static dump with default name multiple times.\");\n+        vmArgs.add(\"-cp\");\n+        vmArgs.add(jarFile);\n+        app  = createLingeredApp(vmArgs.toArray(new String[0]));\n+        pid = app.getPid();\n+        for (int i = 0; i < 3; i++) {\n+            test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n+        }\n+        app.stopApp();\n+    }\n+\n+    private static void test_dynamic() throws Exception {\n+        ArrayList<String> vmArgs = new ArrayList<String>();\n+        \/\/ 3. Test dynamic dump with -XX:+RecordDynamicDumpInfo.\n+        print2ln(\"3. Test dynamic dump with -XX:+RecordDynamicDumpInfo.\");\n+        vmArgs.add(\"-cp\");\n+        vmArgs.add(jarFile);\n+        vmArgs.add(\"-XX:+RecordDynamicDumpInfo\");\n+        LingeredApp app  = createLingeredApp(vmArgs.toArray(new String[0]));\n+        long pid = app.getPid();\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"01\", pid, EXPECT_PASS);\n+        \/\/ 4. Test dynamic dump twice to same process\n+        print2ln(\"4. Test dynamic dump second time to the same process.\");\n+        test(SUBCMD_DYNAMIC_DUMP, DYNAMIC_DUMP_FILE + \"02\", pid, EXPECT_FAIL);\n+        app.stopApp();\n+        vmArgs.clear();\n+        \/\/ 5. Test dynamic dump with -XX:ArchiveClassAtExit will fail.\n+        print2ln(\"5. Test dynamic dump with -XX:ArchiveClassAtExit will fail.\");\n+        vmArgs.add(\"-Xshare:auto\");\n+        vmArgs.add(\"-XX:+RecordDynamicDumpInfo\");\n+        vmArgs.add(\"-XX:ArchiveClassesAtExit=noexist.jsa\");\n+        vmArgs.add(\"-cp\");\n+        vmArgs.add(jarFile);\n+        app = createLingeredApp(vmArgs.toArray(new String[0]));\n+\n+        if (app != null) {\n+            if (app.getProcess().isAlive()) {\n+                throw new RuntimeException(\"The LingeredTestApp should not start up!\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        boolean cdsEnabled = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseSharedSpaces\");\n+        if (!cdsEnabled) {\n+            System.out.println(\"CDS is not available for this JDK, skip the test.\");\n+            return;\n+        }\n+        buildJar();\n+        test_static();\n+        test_dynamic();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTest.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredTestApp extends LingeredApp {\n+    \/\/ Do not use default test.class.path in class path.\n+    public boolean useDefaultClasspath() { return false; }\n+\n+    public static void main(String args[]) {\n+        LingeredApp.main(args);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/LingeredTestApp.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -313,4 +313,6 @@\n-        \/\/ Make sure we set correct classpath to run the app\n-        cmd.add(\"-cp\");\n-        String classpath = System.getProperty(\"test.class.path\");\n-        cmd.add((classpath == null) ? \".\" : classpath);\n+        if (useDefaultClasspath()) {\n+            \/\/ Make sure we set correct classpath to run the app\n+            cmd.add(\"-cp\");\n+            String classpath = System.getProperty(\"test.class.path\");\n+            cmd.add((classpath == null) ? \".\" : classpath);\n+        }\n@@ -339,0 +341,2 @@\n+    public boolean useDefaultClasspath() { return true; }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}