{"files":[{"patch":"@@ -55,0 +55,2 @@\n+JVM_DumpClassListToFile\n+JVM_DumpDynamicArchive\n@@ -87,0 +89,1 @@\n+JVM_GetVMArguments\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -303,0 +303,2 @@\n+  template(dumpSharedArchive, \"dumpSharedArchive\")                                                \\\n+  template(dumpSharedArchive_signature, \"(ZLjava\/lang\/String;)V\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,3 @@\n+JNIEXPORT jobjectArray JNICALL\n+JVM_GetVMArguments(JNIEnv* env);\n+\n@@ -203,0 +206,6 @@\n+JNIEXPORT void JNICALL\n+JVM_DumpClassListToFile(JNIEnv* env, jstring fileName);\n+\n+JNIEXPORT void JNICALL\n+JVM_DumpDynamicArchive(JNIEnv* env, jstring archiveName);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -346,6 +346,1 @@\n-    if (!RecordDynamicDumpInfo) {\n-      \/\/ If run with -XX:+RecordDynamicDumpInfo, DynamicDumpSharedSpaces will be turned on,\n-      \/\/ but ArchiveClassesAtExit, ie, the shared archive file is not specified. To differ the\n-      \/\/ two cases, silence when RecordDynamicDumpInfo is on.\n-      log_warning(cds, dynamic)(\"SharedDynamicArchivePath is not specified\");\n-    }\n+    log_warning(cds, dynamic)(\"SharedDynamicArchivePath is not specified\");\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -780,126 +780,0 @@\n-void append_strings(char* buffer, size_t buff_len,  const char* arg) {\n-  char* start = buffer + strlen(buffer);\n-  snprintf(start, buff_len, \"%s \", arg);\n-}\n-\n-void MetaspaceShared::cmd_dump_shared_archive(outputStream* output, const char* cmd, const char* file_name,  TRAPS) {\n-  \/\/ The existing file will be overwritten.\n-  char filename[JVM_MAXPATHLEN];\n-  const char* file = file_name;\n-  assert(strcmp(cmd, \"static_dump\") == 0 || strcmp(cmd, \"dynamic_dump\") == 0, \"Sanity check\");\n-  bool is_static = strcmp(cmd, \"static_dump\") == 0;\n-  if (is_static) {\n-    output->print_cr(\"Static dump\");\n-    if (file_name ==nullptr) {\n-      os::snprintf(filename, sizeof(filename), \"java_pid%d_static.jsa\", os::current_process_id());\n-      file = filename;\n-    } else {\n-      if (strstr(file_name, \".jsa\") == nullptr) {\n-        os::snprintf(filename, sizeof(filename), \"%s.jsa\", file_name);\n-        file = filename;\n-      }\n-    }\n-    cmd_dump_static(output, file, THREAD);\n-  } else {\n-    output->print_cr(\"Dynamic dump\");\n-    if (!UseSharedSpaces) {\n-      output->print_cr(\"CDS is not available for this version.\");\n-      return;\n-    }\n-    if (!RecordDynamicDumpInfo) {\n-      output->print_cr(\"Please run with -Xshare:auto -XX:+RecordDynamicDumpInfo dumping dynamic archive!\");\n-      return;\n-    }\n-    if (file_name == nullptr) {\n-      os::snprintf(filename, sizeof(filename), \"java_pid%d_dynamic.jsa\", os::current_process_id());\n-      file = filename;\n-    } else {\n-      if (strstr(file_name, \".jsa\") == nullptr) {\n-        os::snprintf(filename, sizeof(filename), \"%s.jsa\", file_name);\n-        file = filename;\n-      }\n-    }\n-    cmd_dump_dynamic(output, file, THREAD);\n-  }\n-}\n-\n-class DumpClassListCLDClosure : public CLDClosure {\n-  fileStream *_stream;\n-public:\n-  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n-  ~DumpClassListCLDClosure() {\n-    delete _stream; \/\/ The file need close since in child process it will be used.\n-  }\n-  void do_cld(ClassLoaderData* cld) {\n-    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n-      if (klass->is_instance_klass()) {\n-        InstanceKlass* ik = InstanceKlass::cast(klass);\n-        if (ik->is_shareable()) {\n-          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n-        }\n-      }\n-    }\n-  }\n-};\n-\n-\/\/   To create a static dump, steps:\n-\/\/   1. output a classlist file\n-\/\/   2. fork a new process to dump the shared archive\n-void MetaspaceShared::cmd_dump_static(outputStream* output, const char* file, TRAPS) {\n-  const char* java_home = Arguments::get_java_home();\n-  const char* file_separator = os::file_separator();\n-  const char* app_class_path = Arguments::get_appclasspath();  \/\/ -cp ..\n-  const char* java_command = Arguments::java_command();        \/\/ arguments to app\n-  char exec_path[JVM_MAXPATHLEN]; \/\/ $JAVA_HOME\/bin\/java or %JAVA_HOME%\\\\jre\\bin\\\\java ...\n-  char classlist_name[JVM_MAXPATHLEN];\n-\n-  os::snprintf(classlist_name, sizeof(classlist_name), \"%s.classlist\", file);\n-\n-  ResourceMark rm;\n-  fileStream* stream = new (ResourceObj::C_HEAP, mtInternal) fileStream(classlist_name, \"w\");\n-  if (stream->is_open()) {\n-    MutexLocker lock(ClassLoaderDataGraph_lock);\n-    DumpClassListCLDClosure collect_classes(stream);\n-    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n-  } else {\n-    output->print_cr(\"Error to open %s for write!\", classlist_name);\n-    return;\n-  }\n-  os::snprintf(exec_path, sizeof(exec_path),\n-               \"%s%sbin%sjava -Xshare:dump -XX:SharedClassListFile=%s -XX:SharedArchiveFile=%s \",\n-               java_home, file_separator, file_separator, classlist_name, file);\n-  int num_vm_args = Arguments::num_jvm_args();\n-  char** vm_args  = Arguments::jvm_args_array();\n-  for (int i = 0; i < num_vm_args; i ++) {\n-    append_strings(exec_path, sizeof(exec_path), vm_args[i]);\n-  }\n-  \/\/ Turn off RecordDynamicDumpInfo\n-  if (RecordDynamicDumpInfo) {\n-    append_strings(exec_path, sizeof(exec_path), \"-XX:-RecordDynamicDumpInfo\");\n-  }\n-  char* buff_start = exec_path + strlen(exec_path);\n-  snprintf(buff_start, sizeof(exec_path), \" -cp %s %s\", app_class_path, java_command);\n-  output->print_cr(\"%s\", exec_path);\n-  os::fork_and_exec(exec_path);\n-}\n-\n-void MetaspaceShared::cmd_dump_dynamic(outputStream* output, const char* file, TRAPS) {\n-  if (DynamicArchive::has_been_dumped_once()) {\n-    output->print_cr(\"Dynamic dump has been done, and should only be done once.\");\n-    return;\n-  } else {\n-    \/\/ prevent multiple dumps.\n-    DynamicArchive::set_has_been_dumped_once();\n-  }\n-  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"Sanity check\");\n-  const char* tmp_file = ArchiveClassesAtExit;\n-  ArchiveClassesAtExit = file;\n-  if (Arguments::init_shared_archive_paths()) {\n-    DynamicArchive::dump();\n-  } else {\n-    output->print_cr(\"Could not setup SharedDynamicArchivePath!\");\n-  }\n-  ArchiveClassesAtExit = tmp_file;\n-  Arguments::init_shared_archive_paths();\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":0,"deletions":126,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -86,5 +86,0 @@\n-  \/\/ those cmd_ functions used for dump cds for jcmd.\n-  static void cmd_dump_shared_archive(outputStream* output, const char* cmd, const char* filename, TRAPS) NOT_CDS_RETURN;\n-  static void cmd_dump_static(outputStream* output, const char* filename, TRAPS) NOT_CDS_RETURN;\n-  static void cmd_dump_dynamic(outputStream* output, const char* filename, TRAPS) NOT_CDS_RETURN;\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -3655,0 +3656,15 @@\n+JVM_ENTRY(jobjectArray, JVM_GetVMArguments(JNIEnv* env))\n+  int num_vm_args = Arguments::num_jvm_args();\n+  if (num_vm_args == 0) {\n+    return NULL;\n+  }\n+\n+  char** vm_args  = Arguments::jvm_args_array();\n+  objArrayHandle h_args = oopFactory::new_objArray_handle(vmClasses::String_klass(), num_vm_args, CHECK_NULL);\n+  for(int i = 0; i < num_vm_args; i++) {\n+    Handle h = java_lang_String::create_from_str(vm_args[i], THREAD);\n+    h_args->obj_at_put(i, h());\n+  }\n+  return (jobjectArray) JNIHandles::make_local(THREAD, h_args());\n+JVM_END\n+\n@@ -3656,1 +3672,1 @@\n-    return Arguments::is_dumping_archive();\n+  return Arguments::is_dumping_archive();\n@@ -3660,1 +3676,1 @@\n-    return UseSharedSpaces;\n+  return UseSharedSpaces;\n@@ -3706,0 +3722,63 @@\n+#if INCLUDE_CDS\n+class DumpClassListCLDClosure : public CLDClosure {\n+  fileStream *_stream;\n+public:\n+  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (ik->is_shareable()) {\n+          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+};\n+#endif\n+\n+JVM_ENTRY(void, JVM_DumpClassListToFile(JNIEnv *env, jstring listFileName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(listFileName));\n+  char* file_name  = java_lang_String::as_utf8_string(file_handle());\n+  fileStream stream(file_name, \"w\");\n+  if (stream.is_open()) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    DumpClassListCLDClosure collect_classes(&stream);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n+  } else {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Failed to open file\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpDynamicArchive(JNIEnv *env, jstring archiveName))\n+#if INCLUDE_CDS\n+  assert(UseSharedSpaces && RecordDynamicDumpInfo, \"Sanity check\");\n+  if (DynamicArchive::has_been_dumped_once()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+        \"Dynamic dump has been done, and should only be done once\");\n+  } else {\n+    \/\/ prevent multiple dumps.\n+    DynamicArchive::set_has_been_dumped_once();\n+  }\n+  assert(ArchiveClassesAtExit == nullptr, \"Sanity check\");\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(archiveName));\n+  char* archive_name  = java_lang_String::as_utf8_string(file_handle());\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n+    DynamicArchive::dump();\n+  } else {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+          \"Could not setup SharedDynamicArchivePath\");\n+  }\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+          \"Could not restore SharedDynamicArchivePath\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":81,"deletions":2,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1896,1 +1896,1 @@\n-          \"Record class info for jcmd Dynamic dump\")                        \\\n+          \"Record class info for jcmd VM.cds dynamic_dump\")                 \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -124,1 +123,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n@@ -146,0 +144,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -1083,0 +1084,1 @@\n+#if INCLUDE_CDS\n@@ -1093,2 +1095,20 @@\n-  if (strcmp(_suboption.value(), \"static_dump\") != 0 && strcmp(_suboption.value(), \"dynamic_dump\") != 0) {\n-    output()->print_cr(\"Invalid command for VM.cds, please use static_dump or dynamic_dump\");\n+  jboolean is_static;\n+  const char* scmd = _suboption.value();\n+  const char* file = _filename.value();\n+\n+  if (strcmp(scmd, \"static_dump\") == 0) {\n+    is_static = JNI_TRUE;\n+    output()->print_cr(\"Static dump:\");\n+  } else if (strcmp(scmd, \"dynamic_dump\") == 0) {\n+    is_static = JNI_FALSE;\n+    output()->print_cr(\"Dynamic dump:\");\n+    if (!UseSharedSpaces) {\n+      output()->print_cr(\"CDS is not available for the JDK\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output()->print_cr(\"Dump dynamic should run with -XX:+RecordDynamicDumpInfo\");\n+      return;\n+    }\n+  } else {\n+    output()->print_cr(\"Invalid command for VM.cds, valid input is static_dump or dynamic_dump\");\n@@ -1097,1 +1117,25 @@\n-  MetaspaceShared::cmd_dump_shared_archive(output(), _suboption.value(), _filename.value(), THREAD);\n+\n+  \/\/ call CDS.dumpSharedArchive\n+  Handle fileh;\n+  if (file != NULL) {\n+    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+  }\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_null(cds_name, THREAD);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_int(is_static);\n+  args.push_oop(fileh);\n+  output()->print_cr(\"Call CDS.dumpSharedArchive(%s, %s)\", scmd, (file == NULL ? \"null\" : file));\n+  JavaCalls::call_static(&result,\n+                         cds_klass,\n+                         vmSymbols::dumpSharedArchive(),\n+                         vmSymbols::dumpSharedArchive_signature(),\n+                         &args, THREAD);\n+  \/\/ Upon exception, show stack trace.\n+  if (HAS_PENDING_EXCEPTION) {\n+    Handle throwable(THREAD, PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    java_lang_Throwable::print_stack_trace(throwable, output());\n+    output()->cr();\n+  }\n@@ -1110,0 +1154,1 @@\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":50,"deletions":5,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -423,0 +423,1 @@\n+#if INCLUDE_CDS\n@@ -446,0 +447,1 @@\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.File;\n@@ -29,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +35,3 @@\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+\n@@ -66,0 +71,1 @@\n+    private static native String[] getVMArguments(); \/\/ return commandline args except for executable itself.\n@@ -198,0 +204,75 @@\n+\n+    private static native void dumpClassList(String listFileName);\n+    private static native void dumpDynamicArchive(String archiveFileName);\n+\n+    private static boolean containsExcludedFlags(String testStr) {\n+       return testStr.contains(\"-XX:DumpLoadedClassList=\")     ||\n+              testStr.contains(\"-XX:+DumpSharedSpaces\")        ||\n+              testStr.contains(\"-XX:+DynamicDumpSharedSpaces\") ||\n+              testStr.contains(\"-XX:+RecordDynamicDumpInfo\");\n+    }\n+   \n+    \/**\n+    * called from jcmd VM.cds to dump static or dynamic shared archive\n+    * @param isStatic indicates dump static archive of dynnamic archive.\n+    * @param fileName user input archive name, can be null.\n+    *\/\n+    private static void dumpSharedArchive(boolean isStatic, String fileName) throws Exception {\n+        boolean DEBUG =  System.getProperty(\"CDS.Debug\") == \"true\";\n+        String archiveFile =  fileName != null ? fileName :\n+            \"java_pid\" + ProcessHandle.current().pid() + (isStatic ? \"_static.jsa\" : \"_dynamic.jsa\");\n+        if (DEBUG) {\n+            System.out.println((isStatic ? \"Static\" : \" Dynamic\") + \" dump to file \" + archiveFile);\n+        }\n+        if (isStatic) {\n+            String listFile = archiveFile + \".classlist\";\n+            dumpClassList(listFile);\n+            String jdkHome = System.getProperty(\"java.home\");\n+            ArrayList<String> cmds = new ArrayList<String>();\n+            cmds.add(jdkHome + File.separator + \"bin\" + File.separator + \"java\"); \/\/ java\n+            cmds.add(\"-Xlog:cds\");\n+            cmds.add(\"-Xshare:dump\");\n+            cmds.add(\"-XX:SharedClassListFile=\" + listFile);\n+            cmds.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+            \/\/ All args in command line\n+            String[] vmArgs = getVMArguments();\n+            if (vmArgs != null) {\n+                for (String arg : vmArgs) {\n+                    if (arg != null && !containsExcludedFlags(arg)) { \n+                        cmds.add(arg);\n+                    }\n+                }\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Static dump cmd: \");\n+                for (String s : cmds) {\n+                    System.out.print(s + \" \");\n+                }\n+                System.out.println(\"\");\n+            }\n+\n+            \/\/ Do not take parent env which will cause dumping fail.\n+            Process proc = Runtime.getRuntime().exec(cmds.toArray(new String[0]),\n+                               new String[] {\"EnvP=null\"});\n+            if (DEBUG) {\n+                System.out.println(\"Dumping process \" + proc.pid() + \" Stdout: \");\n+                String line;\n+                InputStreamReader isr = new InputStreamReader(proc.getInputStream());\n+                BufferedReader rdr = new BufferedReader(isr);\n+                while((line = rdr.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+\n+                System.out.println(\"Dumping process \" + proc.pid() + \" Stderr: \");\n+                isr = new InputStreamReader(proc.getErrorStream());\n+                rdr = new BufferedReader(isr);\n+                while((line = rdr.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+            }\n+            proc.waitFor();\n+        } else {\n+            dumpDynamicArchive(archiveFile);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":82,"deletions":1,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,15 @@\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpClassList(JNIEnv *env, jclass jcls, jstring fileName) {\n+    JVM_DumpClassListToFile(env, fileName);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_misc_CDS_dumpDynamicArchive(JNIEnv *env, jclass jcls, jstring archiveName) {\n+    JVM_DumpDynamicArchive(env, archiveName);\n+}\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_internal_misc_CDS_getVMArguments(JNIEnv *env, jclass jcls) {\n+    return JVM_GetVMArguments(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jtreg.SkippedException;\n@@ -52,0 +53,3 @@\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+\n@@ -63,0 +67,1 @@\n+\n@@ -108,15 +113,6 @@\n-    private static void test(String jcmdSub, String archiveFile, long pid, boolean expectSuccess) throws Exception {\n-\n-        boolean isStatic = jcmdSub.equals(\"static_dump\") ? true : false;\n-\n-        String cdsFileName = archiveFile;\n-        if (cdsFileName == null) {\n-            cdsFileName = \"java_pid\" + pid + \"_\" + (isStatic  ? \"static\" : \"dynamic\") + \".jsa\";\n-        } else {\n-            if (!cdsFileName.endsWith(\".jsa\")) {\n-                cdsFileName = cdsFileName + \".jsa\";\n-            }\n-        }\n-\n-        File file = new File(cdsFileName);\n-        if (file.exists() && file.isFile()) {\n+    private static void test(String jcmdSub, String archiveFile, long pid, boolean expectOK) throws Exception {\n+        boolean isStatic = jcmdSub.equals(SUBCMD_STATIC_DUMP);\n+        String fileName = archiveFile != null ? archiveFile :\n+            (\"java_pid\" + pid + (isStatic ? \"_static\" : \"_dynamic\") + \".jsa\");\n+        File file = new File(fileName);\n+        if (file.exists()) {\n@@ -126,1 +122,4 @@\n-        String jcmd = \"VM.cds \" + jcmdSub + \" \" + cdsFileName;;\n+        String jcmd = \"VM.cds \" + jcmdSub;\n+        if (archiveFile  != null) {\n+          jcmd +=  \" \" + archiveFile;\n+        }\n@@ -128,4 +127,2 @@\n-        PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(\"\" + pid);\n-        System.out.println(\"JCMD: \" + jcmd);\n-        OutputAnalyzer output = cmdExecutor.execute(jcmd, false\/*silent*\/);\n-        output.shouldHaveExitValue(0);\n+        PidJcmdExecutor cmdExecutor = new PidJcmdExecutor(String.valueOf(pid));\n+        OutputAnalyzer output = cmdExecutor.execute(jcmd, true\/*silent*\/);\n@@ -133,4 +130,6 @@\n-        Path path = FileSystems.getDefault().getPath(cdsFileName);\n-        if (expectSuccess) {\n-            if (Files.notExists(path)) {\n-                throw new RuntimeException(\"Could not create shared archive \" + cdsFileName);\n+        if (expectOK) {\n+            output.shouldHaveExitValue(0);\n+            if (!file.exists()) {\n+                throw new RuntimeException(\"Could not create shared archive: \" + fileName);\n+            } else {\n+                file.delete();\n@@ -139,2 +138,2 @@\n-            if (Files.exists(path)) {\n-                throw new RuntimeException(\"Should not create shared archive \" + cdsFileName);\n+            if (file.exists()) {\n+                throw new RuntimeException(\"Should not create shared archive \" + fileName);\n@@ -149,1 +148,4 @@\n-    private static void test_static() throws Exception {\n+    private static void testStatic() throws Exception {\n+        LingeredApp app  = null;\n+        long pid;\n+\n@@ -151,0 +153,3 @@\n+\n+        \/\/ 1. Static dump with default name multiple times.\n+        print2ln(\"1: Static dump with default name multiple times.\");\n@@ -153,8 +158,2 @@\n-        vmArgs.add(\"-Xlog:class+path\");\n-        vmArgs.add(\"-XX:+RecordDynamicDumpInfo\");\n-        LingeredApp app  = null;\n-        app = createLingeredApp(vmArgs.toArray(new String[0]));\n-        long pid = app.getPid();\n-\n-        \/\/ 1. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times\n-        print2ln(\"1. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times.\");\n+        app  = createLingeredApp(vmArgs.toArray(new String[0]));\n+        pid = app.getPid();\n@@ -162,1 +161,1 @@\n-            test(SUBCMD_STATIC_DUMP, STATIC_DUMP_FILE + \"0\" + i, pid, EXPECT_PASS);\n+            test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n@@ -166,2 +165,3 @@\n-        \/\/ 2. Static dump with default name multiple times.\n-        print2ln(\"2: Static dump with default name multiple times.\");\n+\n+        \/\/ 2. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times\n+        print2ln(\"2. Test static dump with -XX:+RecordDynamicDumpInfo to create archive multiple times.\");\n@@ -170,1 +170,3 @@\n-        app  = createLingeredApp(vmArgs.toArray(new String[0]));\n+        vmArgs.add(\"-Xlog:class+path\");\n+        vmArgs.add(\"-XX:+RecordDynamicDumpInfo\");\n+        app = createLingeredApp(vmArgs.toArray(new String[0]));\n@@ -172,0 +174,1 @@\n+\n@@ -173,1 +176,1 @@\n-            test(SUBCMD_STATIC_DUMP, null, pid, EXPECT_PASS);\n+            test(SUBCMD_STATIC_DUMP, STATIC_DUMP_FILE + \"0\" + i, pid, EXPECT_PASS);\n@@ -178,1 +181,1 @@\n-    private static void test_dynamic() throws Exception {\n+    private static void testDynamic() throws Exception {\n@@ -212,2 +215,1 @@\n-            System.out.println(\"CDS is not available for this JDK, skip the test.\");\n-            return;\n+            throw new SkippedException(\"CDS is not available for this JDK.\");\n@@ -216,2 +218,2 @@\n-        test_static();\n-        test_dynamic();\n+        testStatic();\n+        testDynamic();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTest.java","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"}]}