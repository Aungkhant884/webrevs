{"files":[{"patch":"@@ -32,1 +32,1 @@\n-const jint ShenandoahEvacOOMHandler::OOM_MARKER_MASK = 0x80000000;\n+const jint ShenandoahEvacOOMCounter::OOM_MARKER_MASK = 0x80000000;\n@@ -34,3 +34,2 @@\n-ShenandoahEvacOOMHandler::ShenandoahEvacOOMHandler() {\n-  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++)\n-    _threads_in_evac[i].bits = 0;\n+ShenandoahEvacOOMCounter::ShenandoahEvacOOMCounter()\n+  : _bits(0) {\n@@ -39,2 +38,71 @@\n-volatile jint *ShenandoahEvacOOMHandler::threads_in_evac_ptr(Thread* t) {\n-  uint64_t key = (uintptr_t)t;\n+void ShenandoahEvacOOMCounter::decrement() {\n+  assert(unmasked_count() > 0, \"sanity\");\n+  \/\/ NOTE: It's ok to simply decrement, even with mask set, because unmasked value is positive.\n+  Atomic::dec(&_bits);\n+}\n+\n+void ShenandoahEvacOOMCounter::clear() {\n+  assert(unmasked_count() == 0, \"sanity\");\n+  Atomic::release_store_fence(&_bits, (jint)0);\n+}\n+\n+void ShenandoahEvacOOMCounter::set_oom_bit(bool decrement) {\n+  jint threads_in_evac = Atomic::load_acquire(&_bits);\n+  while (true) {\n+    jint newval = decrement\n+      ? (threads_in_evac - 1) | OOM_MARKER_MASK\n+      : threads_in_evac | OOM_MARKER_MASK;\n+\n+    jint other = Atomic::cmpxchg(&_bits, threads_in_evac, newval);\n+    if (other == threads_in_evac) {\n+      \/\/ Success: wait for other threads to get out of the protocol and return.\n+      break;\n+    } else {\n+      \/\/ Failure: try again with updated new value.\n+      threads_in_evac = other;\n+    }\n+  }\n+}\n+\n+bool ShenandoahEvacOOMCounter::try_increment()\n+{\n+  jint threads_in_evac = Atomic::load_acquire(&_bits);\n+\n+  while (true) {\n+    \/\/ Cannot enter evacuation if OOM_MARKER_MASK is set.\n+    if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n+      return false;\n+    }\n+\n+    jint other = Atomic::cmpxchg(&_bits, threads_in_evac, threads_in_evac + 1);\n+    if (other == threads_in_evac) {\n+      \/\/ Success: caller may safely enter evacuation\n+      return true;\n+    } else {\n+      threads_in_evac = other;\n+    }\n+  }\n+}\n+\n+ShenandoahEvacOOMHandler::ShenandoahEvacOOMHandler()\n+  : _num_counters(calc_num_counters()) {\n+\n+  assert(_num_counters > 0, \"sanity\");\n+  _threads_in_evac = NEW_C_HEAP_ARRAY(ShenandoahEvacOOMCounter, _num_counters, mtGC);\n+  for (int i = 0; i < _num_counters; i++) {\n+    new (&_threads_in_evac[i]) ShenandoahEvacOOMCounter;\n+  }\n+}\n+\n+int ShenandoahEvacOOMHandler::calc_num_counters() {\n+  \/\/ Scale the number of counter buckets with the number of CPUs to\n+  \/\/ minimise contention.  Also make sure the number is a power of two\n+  \/\/ so we can map hash values to buckets with a simple mask.\n+  const int nproc = os::active_processor_count();\n+  const int clamped = MAX2(1, MIN2(nproc, 128));\n+  return round_up_power_of_2(clamped);\n+}\n+\n+uint64_t ShenandoahEvacOOMHandler::hash_pointer(const void *p) {\n+  \/\/ Bit mixing function from MurmurHash3\n+  uint64_t key = (uintptr_t)p;\n@@ -46,0 +114,2 @@\n+  return key;\n+}\n@@ -47,1 +117,4 @@\n-  return &_threads_in_evac[key % EVAC_COUNTER_BUCKETS].bits;\n+ShenandoahEvacOOMCounter *ShenandoahEvacOOMHandler::counter_for_thread(Thread* t) {\n+  const uint64_t key = hash_pointer(t);\n+  assert(is_power_of_2(_num_counters), \"must be\");\n+  return &_threads_in_evac[key & (_num_counters - 1)];\n@@ -50,1 +123,1 @@\n-void ShenandoahEvacOOMHandler::wait_for_one_counter(volatile jint *ptr) {\n+void ShenandoahEvacOOMHandler::wait_for_one_counter(ShenandoahEvacOOMCounter *ptr) {\n@@ -54,1 +127,1 @@\n-  while (Atomic::load_acquire(ptr) != OOM_MARKER_MASK) {\n+  while (ptr->load_acquire() != ShenandoahEvacOOMCounter::OOM_MARKER_MASK) {\n@@ -62,2 +135,2 @@\n-  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n-    wait_for_one_counter(&_threads_in_evac[i].bits);\n+  for (int i = 0; i < _num_counters; i++) {\n+    wait_for_one_counter(&_threads_in_evac[i]);\n@@ -72,3 +145,0 @@\n-  volatile jint *ptr = threads_in_evac_ptr(thr);\n-  jint threads_in_evac = Atomic::load_acquire(ptr);\n-\n@@ -76,7 +146,0 @@\n-  while (true) {\n-    \/\/ Check for OOM.\n-    \/\/ If offender has OOM_MARKER_MASK, then loop until no more threads in evac\n-    if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n-      wait_for_no_evac_threads();\n-      return;\n-    }\n@@ -84,7 +147,4 @@\n-    jint other = Atomic::cmpxchg(ptr, threads_in_evac, threads_in_evac + 1);\n-    if (other == threads_in_evac) {\n-      \/\/ Success: caller may safely enter evacuation\n-      return;\n-    } else {\n-      threads_in_evac = other;\n-    }\n+  ShenandoahEvacOOMCounter *counter = counter_for_thread(thr);\n+  if (!counter->try_increment()) {\n+    \/\/ Counter has OOM_MARKER_MASK set, loop until no more threads in evac\n+    wait_for_no_evac_threads();\n@@ -96,4 +156,1 @@\n-    volatile jint *ptr = threads_in_evac_ptr(thr);\n-    assert((Atomic::load_acquire(ptr) & ~OOM_MARKER_MASK) > 0, \"sanity\");\n-    \/\/ NOTE: It's ok to simply decrement, even with mask set, because unmasked value is positive.\n-    Atomic::dec(ptr);\n+    counter_for_thread(thr)->decrement();\n@@ -109,18 +166,0 @@\n-void ShenandoahEvacOOMHandler::set_oom_bit(volatile jint *ptr, bool decrement) {\n-  jint threads_in_evac = Atomic::load_acquire(ptr);\n-  while (true) {\n-    jint newval = decrement\n-      ? (threads_in_evac - 1) | OOM_MARKER_MASK\n-      : threads_in_evac | OOM_MARKER_MASK;\n-\n-    jint other = Atomic::cmpxchg(ptr, threads_in_evac, newval);\n-    if (other == threads_in_evac) {\n-      \/\/ Success: wait for other threads to get out of the protocol and return.\n-      break;\n-    } else {\n-      \/\/ Failure: try again with updated new value.\n-      threads_in_evac = other;\n-    }\n-  }\n-}\n-\n@@ -131,2 +170,2 @@\n-  volatile jint *myptr = threads_in_evac_ptr(Thread::current());\n-  assert((Atomic::load_acquire(myptr) & ~OOM_MARKER_MASK) > 0, \"sanity\");\n+  ShenandoahEvacOOMCounter *self = counter_for_thread(Thread::current());\n+  assert(self->unmasked_count() > 0, \"sanity\");\n@@ -134,3 +173,3 @@\n-  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n-    volatile jint *ptr = &_threads_in_evac[i].bits;\n-    set_oom_bit(ptr, ptr == myptr);\n+  for (int i = 0; i < _num_counters; i++) {\n+    ShenandoahEvacOOMCounter *counter = &_threads_in_evac[i];\n+    counter->set_oom_bit(counter == self);\n@@ -144,4 +183,2 @@\n-  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n-    volatile jint *ptr = &_threads_in_evac[i].bits;\n-    assert((Atomic::load_acquire(ptr) & ~OOM_MARKER_MASK) == 0, \"sanity\");\n-    Atomic::release_store_fence(ptr, (jint)0);\n+  for (int i = 0; i < _num_counters; i++) {\n+    _threads_in_evac[i].clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":96,"deletions":59,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -33,0 +33,25 @@\n+\/**\n+ * Striped counter used to implement the OOM protocol described below.\n+ *\/\n+class ShenandoahEvacOOMCounter {\n+private:\n+  \/\/ Combination of a 31-bit counter and 1-bit OOM marker.\n+  volatile jint _bits;\n+\n+  \/\/ This class must be at least a cache line in size to prevent false sharing.\n+  shenandoah_padding_minus_size(0, sizeof(jint));\n+\n+public:\n+  static const jint OOM_MARKER_MASK;\n+\n+  ShenandoahEvacOOMCounter();\n+\n+  void decrement();\n+  bool try_increment();\n+  void clear();\n+  void set_oom_bit(bool decrement);\n+\n+  inline jint unmasked_count();\n+  inline jint load_acquire();\n+};\n+\n@@ -86,3 +111,1 @@\n-  static const jint OOM_MARKER_MASK;\n-\n-  static constexpr jint EVAC_COUNTER_BUCKETS = 64;\n+  const int _num_counters;\n@@ -91,4 +114,1 @@\n-  struct {\n-    volatile jint bits;\n-    shenandoah_padding_minus_size(1, sizeof(jint));\n-  } _threads_in_evac[EVAC_COUNTER_BUCKETS];\n+  ShenandoahEvacOOMCounter *_threads_in_evac;\n@@ -96,1 +116,1 @@\n-  volatile jint *threads_in_evac_ptr(Thread* t);\n+  ShenandoahEvacOOMCounter *counter_for_thread(Thread* t);\n@@ -99,3 +119,1 @@\n-  void wait_for_one_counter(volatile jint *ptr);\n-\n-  void set_oom_bit(volatile jint *ptr, bool decrement);\n+  void wait_for_one_counter(ShenandoahEvacOOMCounter *ptr);\n@@ -103,0 +121,2 @@\n+  static uint64_t hash_pointer(const void *p);\n+  static int calc_num_counters();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.hpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+jint ShenandoahEvacOOMCounter::load_acquire() {\n+  return Atomic::load_acquire(&_bits);\n+}\n+\n+jint ShenandoahEvacOOMCounter::unmasked_count() {\n+  return Atomic::load_acquire(&_bits) & ~OOM_MARKER_MASK;\n+}\n+\n@@ -40,2 +48,2 @@\n-   volatile jint *ptr = threads_in_evac_ptr(thr);\n-   jint threads_in_evac = Atomic::load_acquire(ptr);\n+   ShenandoahEvacOOMCounter *counter = counter_for_thread(thr);\n+   jint threads_in_evac = counter->load_acquire();\n@@ -43,3 +51,2 @@\n-   if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n-     assert((threads_in_evac & ~OOM_MARKER_MASK) > 0, \"sanity\");\n-     Atomic::dec(ptr);\n+   if ((threads_in_evac & ShenandoahEvacOOMCounter::OOM_MARKER_MASK) != 0) {\n+     counter->decrement();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"}]}