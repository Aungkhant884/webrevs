{"files":[{"patch":"@@ -34,2 +34,3 @@\n-ShenandoahEvacOOMHandler::ShenandoahEvacOOMHandler() :\n-  _threads_in_evac(0) {\n+ShenandoahEvacOOMHandler::ShenandoahEvacOOMHandler() {\n+  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++)\n+    _threads_in_evac[i].bits = 0;\n@@ -38,2 +39,16 @@\n-void ShenandoahEvacOOMHandler::wait_for_no_evac_threads() {\n-  while ((Atomic::load_acquire(&_threads_in_evac) & ~OOM_MARKER_MASK) != 0) {\n+volatile jint *ShenandoahEvacOOMHandler::threads_in_evac_ptr(Thread* t) {\n+  uint64_t key = (uintptr_t)t;\n+  key ^= (key >> 33);\n+  key *= UINT64_C(0xff51afd7ed558ccd);\n+  key ^= (key >> 33);\n+  key *= UINT64_C(0xc4ceb9fe1a85ec53);\n+  key ^= (key >> 33);\n+\n+  return &_threads_in_evac[key % EVAC_COUNTER_BUCKETS].bits;\n+}\n+\n+void ShenandoahEvacOOMHandler::wait_for_one_counter(volatile jint *ptr) {\n+  \/\/ We might be racing against handle_out_of_memory_during_evacuation()\n+  \/\/ setting the OOM_MARKER_MASK bit so we must make sure it is set here\n+  \/\/ *and* the counter is zero.\n+  while (Atomic::load_acquire(ptr) != OOM_MARKER_MASK) {\n@@ -42,0 +57,8 @@\n+}\n+\n+void ShenandoahEvacOOMHandler::wait_for_no_evac_threads() {\n+  \/\/ Once the OOM_MARKER_MASK bit is set the counter can only decrease\n+  \/\/ so it's safe to check each bucket in turn.\n+  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n+    wait_for_one_counter(&_threads_in_evac[i].bits);\n+  }\n@@ -49,1 +72,2 @@\n-  jint threads_in_evac = Atomic::load_acquire(&_threads_in_evac);\n+  volatile jint *ptr = threads_in_evac_ptr(thr);\n+  jint threads_in_evac = Atomic::load_acquire(ptr);\n@@ -60,1 +84,1 @@\n-    jint other = Atomic::cmpxchg(&_threads_in_evac, threads_in_evac, threads_in_evac + 1);\n+    jint other = Atomic::cmpxchg(ptr, threads_in_evac, threads_in_evac + 1);\n@@ -72,1 +96,2 @@\n-    assert((Atomic::load_acquire(&_threads_in_evac) & ~OOM_MARKER_MASK) > 0, \"sanity\");\n+    volatile jint *ptr = threads_in_evac_ptr(thr);\n+    assert((Atomic::load_acquire(ptr) & ~OOM_MARKER_MASK) > 0, \"sanity\");\n@@ -74,1 +99,1 @@\n-    Atomic::dec(&_threads_in_evac);\n+    Atomic::dec(ptr);\n@@ -84,5 +109,2 @@\n-void ShenandoahEvacOOMHandler::handle_out_of_memory_during_evacuation() {\n-  assert(ShenandoahThreadLocalData::is_evac_allowed(Thread::current()), \"sanity\");\n-  assert(!ShenandoahThreadLocalData::is_oom_during_evac(Thread::current()), \"TL oom-during-evac must not be set\");\n-\n-  jint threads_in_evac = Atomic::load_acquire(&_threads_in_evac);\n+void ShenandoahEvacOOMHandler::set_oom_bit(volatile jint *ptr, bool decrement) {\n+  jint threads_in_evac = Atomic::load_acquire(ptr);\n@@ -90,1 +112,5 @@\n-    jint other = Atomic::cmpxchg(&_threads_in_evac, threads_in_evac, (threads_in_evac - 1) | OOM_MARKER_MASK);\n+    jint newval = decrement\n+      ? (threads_in_evac - 1) | OOM_MARKER_MASK\n+      : threads_in_evac | OOM_MARKER_MASK;\n+\n+    jint other = Atomic::cmpxchg(ptr, threads_in_evac, newval);\n@@ -93,2 +119,1 @@\n-      wait_for_no_evac_threads();\n-      return;\n+      break;\n@@ -102,0 +127,15 @@\n+void ShenandoahEvacOOMHandler::handle_out_of_memory_during_evacuation() {\n+  assert(ShenandoahThreadLocalData::is_evac_allowed(Thread::current()), \"sanity\");\n+  assert(!ShenandoahThreadLocalData::is_oom_during_evac(Thread::current()), \"TL oom-during-evac must not be set\");\n+\n+  volatile jint *myptr = threads_in_evac_ptr(Thread::current());\n+  assert((Atomic::load_acquire(myptr) & ~OOM_MARKER_MASK) > 0, \"sanity\");\n+\n+  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n+    volatile jint *ptr = &_threads_in_evac[i].bits;\n+    set_oom_bit(ptr, ptr == myptr);\n+  }\n+\n+  wait_for_no_evac_threads();\n+}\n+\n@@ -104,2 +144,5 @@\n-  assert((Atomic::load_acquire(&_threads_in_evac) & ~OOM_MARKER_MASK) == 0, \"sanity\");\n-  Atomic::release_store_fence(&_threads_in_evac, (jint)0);\n+  for (int i = 0; i < EVAC_COUNTER_BUCKETS; i++) {\n+    volatile jint *ptr = &_threads_in_evac[i].bits;\n+    assert((Atomic::load_acquire(ptr) & ~OOM_MARKER_MASK) == 0, \"sanity\");\n+    Atomic::release_store_fence(ptr, (jint)0);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -60,1 +60,3 @@\n- * for current threads to leave, and blocks other threads from entering.\n+ * for current threads to leave, and blocks other threads from entering. The counter state\n+ * is striped across multiple cache lines to reduce contention when many threads attempt\n+ * to enter or leave the protocol at the same time.\n@@ -86,0 +88,2 @@\n+  static constexpr jint EVAC_COUNTER_BUCKETS = 64;\n+\n@@ -87,2 +91,6 @@\n-  volatile jint _threads_in_evac;\n-  shenandoah_padding(1);\n+  struct {\n+    volatile jint bits;\n+    shenandoah_padding_minus_size(1, sizeof(jint));\n+  } _threads_in_evac[EVAC_COUNTER_BUCKETS];\n+\n+  volatile jint *threads_in_evac_ptr(Thread* t);\n@@ -91,0 +99,3 @@\n+  void wait_for_one_counter(volatile jint *ptr);\n+\n+  void set_oom_bit(volatile jint *ptr, bool decrement);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  jint threads_in_evac = Atomic::load_acquire(&_threads_in_evac);\n-\n@@ -42,1 +40,2 @@\n-   jint threads_in_evac = Atomic::load_acquire(&_threads_in_evac);\n+   volatile jint *ptr = threads_in_evac_ptr(thr);\n+   jint threads_in_evac = Atomic::load_acquire(ptr);\n@@ -46,1 +45,1 @@\n-     Atomic::dec(&_threads_in_evac);\n+     Atomic::dec(ptr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+#define shenandoah_padding_minus_size(id, size) \\\n+  DEFINE_PAD_MINUS_SIZE(id, SHENANDOAH_CACHE_LINE_SIZE, size)\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPadding.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}