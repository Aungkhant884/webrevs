{"files":[{"patch":"@@ -73,0 +73,24 @@\n+void MallocMemorySnapshot::copy_to(MallocMemorySnapshot* s) {\n+  \/\/ Need to make sure that mtChunks don't get deallocated while the\n+  \/\/ copy is going on, because their size is adjusted using this\n+  \/\/ buffer in make_adjustment().\n+  ThreadCritical tc;\n+  size_t total_size;\n+  size_t loop_counter = 0;\n+  const size_t loop_limit = 100;\n+  \/\/ It is observed that other threads can allocate during the loop of copying.\n+  \/\/ This results in inconsistent total and sum of parts. So, the while-loop and\n+  \/\/ the local total_size are used to find and try again a limited number of times.\n+  \/\/ Acheiving fully consistent total and sum of parts requires to block all mallooc's during\n+  \/\/ the copy which is a performance obstacle.\n+  do {\n+    total_size = 0;\n+    s->_all_mallocs = _all_mallocs;\n+    for (int index = 0; index < mt_number_of_types; index ++) {\n+      s->_malloc[index] = _malloc[index];\n+      total_size += _malloc[index].malloc_size();\n+    }\n+  } while(s->_all_mallocs.size() != total_size && ++loop_counter < loop_limit);\n+  assert(s->_all_mallocs.size() == total_size, \"Total != sum of parts\");\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -189,10 +189,1 @@\n-  void copy_to(MallocMemorySnapshot* s) {\n-    \/\/ Need to make sure that mtChunks don't get deallocated while the\n-    \/\/ copy is going on, because their size is adjusted using this\n-    \/\/ buffer in make_adjustment().\n-    ThreadCritical tc;\n-    s->_all_mallocs = _all_mallocs;\n-    for (int index = 0; index < mt_number_of_types; index ++) {\n-      s->_malloc[index] = _malloc[index];\n-    }\n-  }\n+  void copy_to(MallocMemorySnapshot* s);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"}]}