{"files":[{"patch":"@@ -0,0 +1,862 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmIntrinsics.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"utilities\/tribool.hpp\"\n+#include \"utilities\/xmlstream.hpp\"\n+\n+\n+\/\/ These are flag-matching functions:\n+inline bool match_F_R(jshort flags) {\n+  const int req = 0;\n+  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+inline bool match_F_Y(jshort flags) {\n+  const int req = JVM_ACC_SYNCHRONIZED;\n+  const int neg = JVM_ACC_STATIC;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+inline bool match_F_RN(jshort flags) {\n+  const int req = JVM_ACC_NATIVE;\n+  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+inline bool match_F_S(jshort flags) {\n+  const int req = JVM_ACC_STATIC;\n+  const int neg = JVM_ACC_SYNCHRONIZED;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+inline bool match_F_SN(jshort flags) {\n+  const int req = JVM_ACC_STATIC | JVM_ACC_NATIVE;\n+  const int neg = JVM_ACC_SYNCHRONIZED;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+inline bool match_F_RNY(jshort flags) {\n+  const int req = JVM_ACC_NATIVE | JVM_ACC_SYNCHRONIZED;\n+  const int neg = JVM_ACC_STATIC;\n+  return (flags & (req | neg)) == req;\n+}\n+\n+static vmIntrinsics::ID wrapper_intrinsic(BasicType type, bool unboxing) {\n+#define TYPE2(type, unboxing) ((int)(type)*2 + ((unboxing) ? 1 : 0))\n+  switch (TYPE2(type, unboxing)) {\n+#define BASIC_TYPE_CASE(type, box, unbox) \\\n+    case TYPE2(type, false):  return vmIntrinsics::box; \\\n+    case TYPE2(type, true):   return vmIntrinsics::unbox\n+    BASIC_TYPE_CASE(T_BOOLEAN, _Boolean_valueOf,   _booleanValue);\n+    BASIC_TYPE_CASE(T_BYTE,    _Byte_valueOf,      _byteValue);\n+    BASIC_TYPE_CASE(T_CHAR,    _Character_valueOf, _charValue);\n+    BASIC_TYPE_CASE(T_SHORT,   _Short_valueOf,     _shortValue);\n+    BASIC_TYPE_CASE(T_INT,     _Integer_valueOf,   _intValue);\n+    BASIC_TYPE_CASE(T_LONG,    _Long_valueOf,      _longValue);\n+    BASIC_TYPE_CASE(T_FLOAT,   _Float_valueOf,     _floatValue);\n+    BASIC_TYPE_CASE(T_DOUBLE,  _Double_valueOf,    _doubleValue);\n+#undef BASIC_TYPE_CASE\n+  }\n+#undef TYPE2\n+  return vmIntrinsics::_none;\n+}\n+\n+vmIntrinsics::ID vmIntrinsics::for_boxing(BasicType type) {\n+  return wrapper_intrinsic(type, false);\n+}\n+vmIntrinsics::ID vmIntrinsics::for_unboxing(BasicType type) {\n+  return wrapper_intrinsic(type, true);\n+}\n+\n+vmIntrinsics::ID vmIntrinsics::for_raw_conversion(BasicType src, BasicType dest) {\n+#define SRC_DEST(s,d) (((int)(s) << 4) + (int)(d))\n+  switch (SRC_DEST(src, dest)) {\n+  case SRC_DEST(T_INT, T_FLOAT):   return vmIntrinsics::_intBitsToFloat;\n+  case SRC_DEST(T_FLOAT, T_INT):   return vmIntrinsics::_floatToRawIntBits;\n+\n+  case SRC_DEST(T_LONG, T_DOUBLE): return vmIntrinsics::_longBitsToDouble;\n+  case SRC_DEST(T_DOUBLE, T_LONG): return vmIntrinsics::_doubleToRawLongBits;\n+  }\n+#undef SRC_DEST\n+\n+  return vmIntrinsics::_none;\n+}\n+\n+bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch(id) {\n+#ifdef JFR_HAVE_INTRINSICS\n+  case vmIntrinsics::_counterTime:\n+#endif\n+  case vmIntrinsics::_currentTimeMillis:\n+  case vmIntrinsics::_nanoTime:\n+  case vmIntrinsics::_floatToRawIntBits:\n+  case vmIntrinsics::_intBitsToFloat:\n+  case vmIntrinsics::_doubleToRawLongBits:\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_getClass:\n+  case vmIntrinsics::_isInstance:\n+  case vmIntrinsics::_currentThread:\n+  case vmIntrinsics::_dabs:\n+  case vmIntrinsics::_fabs:\n+  case vmIntrinsics::_iabs:\n+  case vmIntrinsics::_labs:\n+  case vmIntrinsics::_dsqrt:\n+  case vmIntrinsics::_dsin:\n+  case vmIntrinsics::_dcos:\n+  case vmIntrinsics::_dtan:\n+  case vmIntrinsics::_dlog:\n+  case vmIntrinsics::_dlog10:\n+  case vmIntrinsics::_dexp:\n+  case vmIntrinsics::_dpow:\n+  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Reference_get:\n+  case vmIntrinsics::_updateCRC32:\n+  case vmIntrinsics::_updateBytesCRC32:\n+  case vmIntrinsics::_updateByteBufferCRC32:\n+  case vmIntrinsics::_vectorizedMismatch:\n+  case vmIntrinsics::_fmaD:\n+  case vmIntrinsics::_fmaF:\n+  case vmIntrinsics::_isDigit:\n+  case vmIntrinsics::_isLowerCase:\n+  case vmIntrinsics::_isUpperCase:\n+  case vmIntrinsics::_isWhitespace:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch(id) {\n+#ifdef JFR_HAVE_INTRINSICS\n+  case vmIntrinsics::_counterTime:\n+  case vmIntrinsics::_getClassId:\n+#endif\n+  case vmIntrinsics::_currentTimeMillis:\n+  case vmIntrinsics::_nanoTime:\n+  case vmIntrinsics::_floatToRawIntBits:\n+  case vmIntrinsics::_intBitsToFloat:\n+  case vmIntrinsics::_doubleToRawLongBits:\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_currentThread:\n+  case vmIntrinsics::_dabs:\n+  case vmIntrinsics::_fabs:\n+  case vmIntrinsics::_iabs:\n+  case vmIntrinsics::_labs:\n+  case vmIntrinsics::_dsqrt:\n+  case vmIntrinsics::_dsin:\n+  case vmIntrinsics::_dcos:\n+  case vmIntrinsics::_dtan:\n+  case vmIntrinsics::_dlog:\n+  case vmIntrinsics::_dlog10:\n+  case vmIntrinsics::_dexp:\n+  case vmIntrinsics::_dpow:\n+  case vmIntrinsics::_updateCRC32:\n+  case vmIntrinsics::_updateBytesCRC32:\n+  case vmIntrinsics::_updateByteBufferCRC32:\n+  case vmIntrinsics::_vectorizedMismatch:\n+  case vmIntrinsics::_fmaD:\n+  case vmIntrinsics::_fmaF:\n+    return false;\n+  default:\n+    return true;\n+  }\n+}\n+\n+\/\/ Some intrinsics produce different results if they are not pinned\n+bool vmIntrinsics::should_be_pinned(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch(id) {\n+#ifdef JFR_HAVE_INTRINSICS\n+  case vmIntrinsics::_counterTime:\n+#endif\n+  case vmIntrinsics::_currentTimeMillis:\n+  case vmIntrinsics::_nanoTime:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch(id) {\n+  case vmIntrinsics::_hashCode:\n+  case vmIntrinsics::_clone:\n+    return true;\n+    break;\n+  default:\n+    return false;\n+  }\n+}\n+\n+int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch (id) {\n+  case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:\n+  case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:\n+  case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:\n+  case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:\n+  case vmIntrinsics::_counterMode_AESCrypt:\n+    return 1;\n+  case vmIntrinsics::_digestBase_implCompressMB:\n+    return 4;\n+  default:\n+    return 0;\n+  }\n+}\n+\n+bool vmIntrinsics::disabled_by_jvm_flags(vmIntrinsics::ID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+\n+  \/\/ -XX:-InlineNatives disables nearly all intrinsics except the ones listed in\n+  \/\/ the following switch statement.\n+  if (!InlineNatives) {\n+    switch (id) {\n+    case vmIntrinsics::_indexOfL:\n+    case vmIntrinsics::_indexOfU:\n+    case vmIntrinsics::_indexOfUL:\n+    case vmIntrinsics::_indexOfIL:\n+    case vmIntrinsics::_indexOfIU:\n+    case vmIntrinsics::_indexOfIUL:\n+    case vmIntrinsics::_indexOfU_char:\n+    case vmIntrinsics::_compareToL:\n+    case vmIntrinsics::_compareToU:\n+    case vmIntrinsics::_compareToLU:\n+    case vmIntrinsics::_compareToUL:\n+    case vmIntrinsics::_equalsL:\n+    case vmIntrinsics::_equalsU:\n+    case vmIntrinsics::_equalsC:\n+    case vmIntrinsics::_getCharStringU:\n+    case vmIntrinsics::_putCharStringU:\n+    case vmIntrinsics::_compressStringC:\n+    case vmIntrinsics::_compressStringB:\n+    case vmIntrinsics::_inflateStringC:\n+    case vmIntrinsics::_inflateStringB:\n+    case vmIntrinsics::_getAndAddInt:\n+    case vmIntrinsics::_getAndAddLong:\n+    case vmIntrinsics::_getAndSetInt:\n+    case vmIntrinsics::_getAndSetLong:\n+    case vmIntrinsics::_getAndSetReference:\n+    case vmIntrinsics::_loadFence:\n+    case vmIntrinsics::_storeFence:\n+    case vmIntrinsics::_fullFence:\n+    case vmIntrinsics::_hasNegatives:\n+    case vmIntrinsics::_Reference_get:\n+      break;\n+    default:\n+      return true;\n+    }\n+  }\n+\n+  switch (id) {\n+  case vmIntrinsics::_isInstance:\n+  case vmIntrinsics::_isAssignableFrom:\n+  case vmIntrinsics::_getModifiers:\n+  case vmIntrinsics::_isInterface:\n+  case vmIntrinsics::_isArray:\n+  case vmIntrinsics::_isPrimitive:\n+  case vmIntrinsics::_isHidden:\n+  case vmIntrinsics::_getSuperclass:\n+  case vmIntrinsics::_Class_cast:\n+  case vmIntrinsics::_getLength:\n+  case vmIntrinsics::_newArray:\n+  case vmIntrinsics::_getClass:\n+    if (!InlineClassNatives) return true;\n+    break;\n+  case vmIntrinsics::_currentThread:\n+    if (!InlineThreadNatives) return true;\n+    break;\n+  case vmIntrinsics::_floatToRawIntBits:\n+  case vmIntrinsics::_intBitsToFloat:\n+  case vmIntrinsics::_doubleToRawLongBits:\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_ceil:\n+  case vmIntrinsics::_floor:\n+  case vmIntrinsics::_rint:\n+  case vmIntrinsics::_dabs:\n+  case vmIntrinsics::_fabs:\n+  case vmIntrinsics::_iabs:\n+  case vmIntrinsics::_labs:\n+  case vmIntrinsics::_dsqrt:\n+  case vmIntrinsics::_dsin:\n+  case vmIntrinsics::_dcos:\n+  case vmIntrinsics::_dtan:\n+  case vmIntrinsics::_dlog:\n+  case vmIntrinsics::_dexp:\n+  case vmIntrinsics::_dpow:\n+  case vmIntrinsics::_dlog10:\n+  case vmIntrinsics::_datan2:\n+  case vmIntrinsics::_min:\n+  case vmIntrinsics::_max:\n+  case vmIntrinsics::_floatToIntBits:\n+  case vmIntrinsics::_doubleToLongBits:\n+  case vmIntrinsics::_maxF:\n+  case vmIntrinsics::_minF:\n+  case vmIntrinsics::_maxD:\n+  case vmIntrinsics::_minD:\n+    if (!InlineMathNatives) return true;\n+    break;\n+  case vmIntrinsics::_fmaD:\n+  case vmIntrinsics::_fmaF:\n+    if (!InlineMathNatives || !UseFMA) return true;\n+    break;\n+  case vmIntrinsics::_arraycopy:\n+    if (!InlineArrayCopy) return true;\n+    break;\n+  case vmIntrinsics::_updateCRC32:\n+  case vmIntrinsics::_updateBytesCRC32:\n+  case vmIntrinsics::_updateByteBufferCRC32:\n+    if (!UseCRC32Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_getReference:\n+  case vmIntrinsics::_getBoolean:\n+  case vmIntrinsics::_getByte:\n+  case vmIntrinsics::_getShort:\n+  case vmIntrinsics::_getChar:\n+  case vmIntrinsics::_getInt:\n+  case vmIntrinsics::_getLong:\n+  case vmIntrinsics::_getFloat:\n+  case vmIntrinsics::_getDouble:\n+  case vmIntrinsics::_putReference:\n+  case vmIntrinsics::_putBoolean:\n+  case vmIntrinsics::_putByte:\n+  case vmIntrinsics::_putShort:\n+  case vmIntrinsics::_putChar:\n+  case vmIntrinsics::_putInt:\n+  case vmIntrinsics::_putLong:\n+  case vmIntrinsics::_putFloat:\n+  case vmIntrinsics::_putDouble:\n+  case vmIntrinsics::_getReferenceVolatile:\n+  case vmIntrinsics::_getBooleanVolatile:\n+  case vmIntrinsics::_getByteVolatile:\n+  case vmIntrinsics::_getShortVolatile:\n+  case vmIntrinsics::_getCharVolatile:\n+  case vmIntrinsics::_getIntVolatile:\n+  case vmIntrinsics::_getLongVolatile:\n+  case vmIntrinsics::_getFloatVolatile:\n+  case vmIntrinsics::_getDoubleVolatile:\n+  case vmIntrinsics::_putReferenceVolatile:\n+  case vmIntrinsics::_putBooleanVolatile:\n+  case vmIntrinsics::_putByteVolatile:\n+  case vmIntrinsics::_putShortVolatile:\n+  case vmIntrinsics::_putCharVolatile:\n+  case vmIntrinsics::_putIntVolatile:\n+  case vmIntrinsics::_putLongVolatile:\n+  case vmIntrinsics::_putFloatVolatile:\n+  case vmIntrinsics::_putDoubleVolatile:\n+  case vmIntrinsics::_getReferenceAcquire:\n+  case vmIntrinsics::_getBooleanAcquire:\n+  case vmIntrinsics::_getByteAcquire:\n+  case vmIntrinsics::_getShortAcquire:\n+  case vmIntrinsics::_getCharAcquire:\n+  case vmIntrinsics::_getIntAcquire:\n+  case vmIntrinsics::_getLongAcquire:\n+  case vmIntrinsics::_getFloatAcquire:\n+  case vmIntrinsics::_getDoubleAcquire:\n+  case vmIntrinsics::_putReferenceRelease:\n+  case vmIntrinsics::_putBooleanRelease:\n+  case vmIntrinsics::_putByteRelease:\n+  case vmIntrinsics::_putShortRelease:\n+  case vmIntrinsics::_putCharRelease:\n+  case vmIntrinsics::_putIntRelease:\n+  case vmIntrinsics::_putLongRelease:\n+  case vmIntrinsics::_putFloatRelease:\n+  case vmIntrinsics::_putDoubleRelease:\n+  case vmIntrinsics::_getReferenceOpaque:\n+  case vmIntrinsics::_getBooleanOpaque:\n+  case vmIntrinsics::_getByteOpaque:\n+  case vmIntrinsics::_getShortOpaque:\n+  case vmIntrinsics::_getCharOpaque:\n+  case vmIntrinsics::_getIntOpaque:\n+  case vmIntrinsics::_getLongOpaque:\n+  case vmIntrinsics::_getFloatOpaque:\n+  case vmIntrinsics::_getDoubleOpaque:\n+  case vmIntrinsics::_putReferenceOpaque:\n+  case vmIntrinsics::_putBooleanOpaque:\n+  case vmIntrinsics::_putByteOpaque:\n+  case vmIntrinsics::_putShortOpaque:\n+  case vmIntrinsics::_putCharOpaque:\n+  case vmIntrinsics::_putIntOpaque:\n+  case vmIntrinsics::_putLongOpaque:\n+  case vmIntrinsics::_putFloatOpaque:\n+  case vmIntrinsics::_putDoubleOpaque:\n+  case vmIntrinsics::_getAndAddInt:\n+  case vmIntrinsics::_getAndAddLong:\n+  case vmIntrinsics::_getAndSetInt:\n+  case vmIntrinsics::_getAndSetLong:\n+  case vmIntrinsics::_getAndSetReference:\n+  case vmIntrinsics::_loadFence:\n+  case vmIntrinsics::_storeFence:\n+  case vmIntrinsics::_fullFence:\n+  case vmIntrinsics::_compareAndSetLong:\n+  case vmIntrinsics::_weakCompareAndSetLong:\n+  case vmIntrinsics::_weakCompareAndSetLongPlain:\n+  case vmIntrinsics::_weakCompareAndSetLongAcquire:\n+  case vmIntrinsics::_weakCompareAndSetLongRelease:\n+  case vmIntrinsics::_compareAndSetInt:\n+  case vmIntrinsics::_weakCompareAndSetInt:\n+  case vmIntrinsics::_weakCompareAndSetIntPlain:\n+  case vmIntrinsics::_weakCompareAndSetIntAcquire:\n+  case vmIntrinsics::_weakCompareAndSetIntRelease:\n+  case vmIntrinsics::_compareAndSetReference:\n+  case vmIntrinsics::_weakCompareAndSetReference:\n+  case vmIntrinsics::_weakCompareAndSetReferencePlain:\n+  case vmIntrinsics::_weakCompareAndSetReferenceAcquire:\n+  case vmIntrinsics::_weakCompareAndSetReferenceRelease:\n+  case vmIntrinsics::_compareAndExchangeInt:\n+  case vmIntrinsics::_compareAndExchangeIntAcquire:\n+  case vmIntrinsics::_compareAndExchangeIntRelease:\n+  case vmIntrinsics::_compareAndExchangeLong:\n+  case vmIntrinsics::_compareAndExchangeLongAcquire:\n+  case vmIntrinsics::_compareAndExchangeLongRelease:\n+  case vmIntrinsics::_compareAndExchangeReference:\n+  case vmIntrinsics::_compareAndExchangeReferenceAcquire:\n+  case vmIntrinsics::_compareAndExchangeReferenceRelease:\n+    if (!InlineUnsafeOps) return true;\n+    break;\n+  case vmIntrinsics::_getShortUnaligned:\n+  case vmIntrinsics::_getCharUnaligned:\n+  case vmIntrinsics::_getIntUnaligned:\n+  case vmIntrinsics::_getLongUnaligned:\n+  case vmIntrinsics::_putShortUnaligned:\n+  case vmIntrinsics::_putCharUnaligned:\n+  case vmIntrinsics::_putIntUnaligned:\n+  case vmIntrinsics::_putLongUnaligned:\n+  case vmIntrinsics::_allocateInstance:\n+    if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;\n+    break;\n+  case vmIntrinsics::_hashCode:\n+    if (!InlineObjectHash) return true;\n+    break;\n+  case vmIntrinsics::_aescrypt_encryptBlock:\n+  case vmIntrinsics::_aescrypt_decryptBlock:\n+    if (!UseAESIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:\n+  case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:\n+    if (!UseAESIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:\n+  case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:\n+    if (!UseAESIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_counterMode_AESCrypt:\n+    if (!UseAESCTRIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_md5_implCompress:\n+    if (!UseMD5Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_sha_implCompress:\n+    if (!UseSHA1Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_sha2_implCompress:\n+    if (!UseSHA256Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_sha5_implCompress:\n+    if (!UseSHA512Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_digestBase_implCompressMB:\n+    if (!(UseMD5Intrinsics || UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;\n+    break;\n+  case vmIntrinsics::_ghash_processBlocks:\n+    if (!UseGHASHIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_base64_encodeBlock:\n+    if (!UseBASE64Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_updateBytesCRC32C:\n+  case vmIntrinsics::_updateDirectByteBufferCRC32C:\n+    if (!UseCRC32CIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_vectorizedMismatch:\n+    if (!UseVectorizedMismatchIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_updateBytesAdler32:\n+  case vmIntrinsics::_updateByteBufferAdler32:\n+    if (!UseAdler32Intrinsics) return true;\n+    break;\n+  case vmIntrinsics::_copyMemory:\n+    if (!InlineArrayCopy || !InlineUnsafeOps) return true;\n+    break;\n+#ifdef COMPILER1\n+  case vmIntrinsics::_checkIndex:\n+    if (!InlineNIOCheckIndex) return true;\n+    break;\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+  case vmIntrinsics::_clone:\n+  case vmIntrinsics::_copyOf:\n+  case vmIntrinsics::_copyOfRange:\n+    \/\/ These intrinsics use both the objectcopy and the arraycopy\n+    \/\/ intrinsic mechanism.\n+    if (!InlineObjectCopy || !InlineArrayCopy) return true;\n+    break;\n+  case vmIntrinsics::_compareToL:\n+  case vmIntrinsics::_compareToU:\n+  case vmIntrinsics::_compareToLU:\n+  case vmIntrinsics::_compareToUL:\n+    if (!SpecialStringCompareTo) return true;\n+    break;\n+  case vmIntrinsics::_indexOfL:\n+  case vmIntrinsics::_indexOfU:\n+  case vmIntrinsics::_indexOfUL:\n+  case vmIntrinsics::_indexOfIL:\n+  case vmIntrinsics::_indexOfIU:\n+  case vmIntrinsics::_indexOfIUL:\n+  case vmIntrinsics::_indexOfU_char:\n+    if (!SpecialStringIndexOf) return true;\n+    break;\n+  case vmIntrinsics::_equalsL:\n+  case vmIntrinsics::_equalsU:\n+    if (!SpecialStringEquals) return true;\n+    break;\n+  case vmIntrinsics::_equalsB:\n+  case vmIntrinsics::_equalsC:\n+    if (!SpecialArraysEquals) return true;\n+    break;\n+  case vmIntrinsics::_encodeISOArray:\n+  case vmIntrinsics::_encodeByteISOArray:\n+    if (!SpecialEncodeISOArray) return true;\n+    break;\n+  case vmIntrinsics::_getCallerClass:\n+    if (!InlineReflectionGetCallerClass) return true;\n+    break;\n+  case vmIntrinsics::_multiplyToLen:\n+    if (!UseMultiplyToLenIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_squareToLen:\n+    if (!UseSquareToLenIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_mulAdd:\n+    if (!UseMulAddIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_montgomeryMultiply:\n+    if (!UseMontgomeryMultiplyIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_montgomerySquare:\n+    if (!UseMontgomerySquareIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_bigIntegerRightShiftWorker:\n+  case vmIntrinsics::_bigIntegerLeftShiftWorker:\n+    break;\n+  case vmIntrinsics::_addExactI:\n+  case vmIntrinsics::_addExactL:\n+  case vmIntrinsics::_decrementExactI:\n+  case vmIntrinsics::_decrementExactL:\n+  case vmIntrinsics::_incrementExactI:\n+  case vmIntrinsics::_incrementExactL:\n+  case vmIntrinsics::_multiplyExactI:\n+  case vmIntrinsics::_multiplyExactL:\n+  case vmIntrinsics::_negateExactI:\n+  case vmIntrinsics::_negateExactL:\n+  case vmIntrinsics::_subtractExactI:\n+  case vmIntrinsics::_subtractExactL:\n+    if (!UseMathExactIntrinsics || !InlineMathNatives) return true;\n+    break;\n+  case vmIntrinsics::_isDigit:\n+  case vmIntrinsics::_isLowerCase:\n+  case vmIntrinsics::_isUpperCase:\n+  case vmIntrinsics::_isWhitespace:\n+    if (!UseCharacterCompareIntrinsics) return true;\n+    break;\n+  case vmIntrinsics::_dcopySign:\n+  case vmIntrinsics::_fcopySign:\n+    if (!InlineMathNatives || !UseCopySignIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_dsignum:\n+  case vmIntrinsics::_fsignum:\n+    if (!InlineMathNatives || !UseSignumIntrinsic) return true;\n+    break;\n+#endif \/\/ COMPILER2\n+  default:\n+    return false;\n+  }\n+\n+  return false;\n+}\n+\n+#define VM_INTRINSIC_INITIALIZE(id, klass, name, sig, flags) #id \"\\0\"\n+static const char* vm_intrinsic_name_bodies =\n+  VM_INTRINSICS_DO(VM_INTRINSIC_INITIALIZE,\n+                   VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n+\n+static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];\n+static TriBoolArray<vmIntrinsics::ID_LIMIT, int> vm_intrinsic_control_words;\n+\n+static void init_vm_intrinsic_name_table() {\n+  const char** nt = &vm_intrinsic_name_table[0];\n+  char* string = (char*) &vm_intrinsic_name_bodies[0];\n+  for (int index = vmIntrinsics::FIRST_ID; index < vmIntrinsics::ID_LIMIT; index++) {\n+    nt[index] = string;\n+    string += strlen(string); \/\/ skip string body\n+    string += 1;              \/\/ skip trailing null\n+  }\n+  assert(!strcmp(nt[vmIntrinsics::_hashCode], \"_hashCode\"), \"lined up\");\n+  nt[vmIntrinsics::_none] = \"_none\";\n+}\n+\n+const char* vmIntrinsics::name_at(vmIntrinsics::ID id) {\n+  const char** nt = &vm_intrinsic_name_table[0];\n+  if (nt[_none] == NULL) {\n+    init_vm_intrinsic_name_table();\n+  }\n+\n+  if ((uint)id < (uint)ID_LIMIT)\n+    return vm_intrinsic_name_table[(uint)id];\n+  else\n+    return \"(unknown intrinsic)\";\n+}\n+\n+vmIntrinsics::ID vmIntrinsics::find_id(const char* name) {\n+  const char** nt = &vm_intrinsic_name_table[0];\n+  if (nt[_none] == NULL) {\n+    init_vm_intrinsic_name_table();\n+  }\n+\n+  for (int index = FIRST_ID; index < ID_LIMIT; ++index) {\n+    if (0 == strcmp(name, nt[index])) {\n+      return ID_from(index);\n+    }\n+  }\n+\n+  return _none;\n+}\n+\n+bool vmIntrinsics::is_disabled_by_flags(const methodHandle& method) {\n+  vmIntrinsics::ID id = method->intrinsic_id();\n+  return is_disabled_by_flags(id);\n+}\n+\n+bool vmIntrinsics::is_disabled_by_flags(vmIntrinsics::ID id) {\n+  assert(id > _none && id < ID_LIMIT, \"must be a VM intrinsic\");\n+\n+  \/\/ not initialized yet, process Control\/DisableIntrinsic\n+  if (vm_intrinsic_control_words[_none].is_default()) {\n+    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {\n+      vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);\n+\n+      if (id != vmIntrinsics::_none) {\n+        vm_intrinsic_control_words[id] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n+      }\n+    }\n+\n+    \/\/ Order matters, DisableIntrinsic can overwrite ControlIntrinsic\n+    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != NULL; ++iter) {\n+      vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);\n+\n+      if (id != vmIntrinsics::_none) {\n+        vm_intrinsic_control_words[id] = false;\n+      }\n+    }\n+\n+    vm_intrinsic_control_words[_none] = true;\n+  }\n+\n+  TriBool b = vm_intrinsic_control_words[id];\n+  if (b.is_default()) {\n+    \/\/ unknown yet, query and cache it\n+    b = vm_intrinsic_control_words[id] = !disabled_by_jvm_flags(id);\n+  }\n+\n+  return !b;\n+}\n+\n+\/\/ These are for forming case labels:\n+#define ID3(x, y, z) (( jlong)(z) +                                  \\\n+                      ((jlong)(y) <<    vmSymbols::log2_SID_LIMIT) + \\\n+                      ((jlong)(x) << (2*vmSymbols::log2_SID_LIMIT))  )\n+#define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)\n+\n+vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbols::SID holder,\n+                                            vmSymbols::SID name,\n+                                            vmSymbols::SID sig,\n+                                            jshort flags) {\n+  assert((int)vmSymbols::SID_LIMIT <= (1<<vmSymbols::log2_SID_LIMIT), \"must fit\");\n+\n+  \/\/ Let the C compiler build the decision tree.\n+\n+#define VM_INTRINSIC_CASE(id, klass, name, sig, fcode) \\\n+  case ID3(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig)): \\\n+    if (!match_##fcode(flags))  break; \\\n+    return id;\n+\n+  switch (ID3(holder, name, sig)) {\n+    VM_INTRINSICS_DO(VM_INTRINSIC_CASE,\n+                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n+  }\n+  return vmIntrinsics::_none;\n+\n+#undef VM_INTRINSIC_CASE\n+}\n+\n+\n+const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {\n+  const char* str = name_at(id);\n+#ifndef PRODUCT\n+  const char* kname = vmSymbols::name_for(class_for(id));\n+  const char* mname = vmSymbols::name_for(name_for(id));\n+  const char* sname = vmSymbols::name_for(signature_for(id));\n+  const char* fname = \"\";\n+  switch (flags_for(id)) {\n+  case F_Y:  fname = \"synchronized \";  break;\n+  case F_RN: fname = \"native \";        break;\n+  case F_SN: fname = \"native static \"; break;\n+  case F_S:  fname = \"static \";        break;\n+  case F_RNY:fname = \"native synchronized \"; break;\n+  default:   break;\n+  }\n+  const char* kptr = strrchr(kname, JVM_SIGNATURE_SLASH);\n+  if (kptr != NULL)  kname = kptr + 1;\n+  int len = jio_snprintf(buf, buflen, \"%s: %s%s.%s%s\",\n+                         str, fname, kname, mname, sname);\n+  if (len < buflen)\n+    str = buf;\n+#endif \/\/PRODUCT\n+  return str;\n+}\n+\n+\n+\/\/ These are to get information about intrinsics.\n+\n+#define ID4(x, y, z, f) ((ID3(x, y, z) << vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))\n+\n+static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {\n+#define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \\\n+  ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),\n+\n+  0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,\n+                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n+    0\n+#undef VM_INTRINSIC_INFO\n+};\n+\n+inline jlong intrinsic_info(vmIntrinsics::ID id) {\n+  return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];\n+}\n+\n+vmSymbols::SID vmIntrinsics::class_for(vmIntrinsics::ID id) {\n+  jlong info = intrinsic_info(id);\n+  int shift = 2*vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n+  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1021, \"\");\n+  return vmSymbols::SID( (info >> shift) & mask );\n+}\n+\n+vmSymbols::SID vmIntrinsics::name_for(vmIntrinsics::ID id) {\n+  jlong info = intrinsic_info(id);\n+  int shift = vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n+  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1022, \"\");\n+  return vmSymbols::SID( (info >> shift) & mask );\n+}\n+\n+vmSymbols::SID vmIntrinsics::signature_for(vmIntrinsics::ID id) {\n+  jlong info = intrinsic_info(id);\n+  int shift = log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n+  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1023, \"\");\n+  return vmSymbols::SID( (info >> shift) & mask );\n+}\n+\n+vmIntrinsics::Flags vmIntrinsics::flags_for(vmIntrinsics::ID id) {\n+  jlong info = intrinsic_info(id);\n+  int shift = 0, mask = right_n_bits(log2_FLAG_LIMIT);\n+  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 15, \"\");\n+  return Flags( (info >> shift) & mask );\n+}\n+\n+\n+#ifndef PRODUCT\n+\/\/ verify_method performs an extra check on a matched intrinsic method\n+\n+static bool match_method(Method* m, Symbol* n, Symbol* s) {\n+  return (m->name() == n &&\n+          m->signature() == s);\n+}\n+\n+static vmIntrinsics::ID match_method_with_klass(Method* m, Symbol* mk) {\n+#define VM_INTRINSIC_MATCH(id, klassname, namepart, sigpart, flags) \\\n+  { Symbol* k = vmSymbols::klassname(); \\\n+    if (mk == k) { \\\n+      Symbol* n = vmSymbols::namepart(); \\\n+      Symbol* s = vmSymbols::sigpart(); \\\n+      if (match_method(m, n, s)) \\\n+        return vmIntrinsics::id; \\\n+    } }\n+  VM_INTRINSICS_DO(VM_INTRINSIC_MATCH,\n+                   VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n+  return vmIntrinsics::_none;\n+#undef VM_INTRINSIC_MATCH\n+}\n+\n+void vmIntrinsics::verify_method(ID actual_id, Method* m) {\n+  Symbol* mk = m->method_holder()->name();\n+  ID declared_id = match_method_with_klass(m, mk);\n+\n+  if (declared_id == actual_id)  return; \/\/ success\n+\n+  if (declared_id == _none && actual_id != _none && mk == vmSymbols::java_lang_StrictMath()) {\n+    \/\/ Here are a few special cases in StrictMath not declared in vmSymbols.hpp.\n+    switch (actual_id) {\n+    case _min:\n+    case _max:\n+    case _dsqrt:\n+      declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());\n+      if (declared_id == actual_id)  return; \/\/ acceptable alias\n+      break;\n+    default:\n+        break;\n+    }\n+  }\n+\n+  const char* declared_name = name_at(declared_id);\n+  const char* actual_name   = name_at(actual_id);\n+  m = NULL;\n+  ttyLocker ttyl;\n+  if (xtty != NULL) {\n+    xtty->begin_elem(\"intrinsic_misdeclared actual='%s' declared='%s'\",\n+                     actual_name, declared_name);\n+    xtty->method(m);\n+    xtty->end_elem(\"%s\", \"\");\n+  }\n+  if (PrintMiscellaneous && (WizardMode || Verbose)) {\n+    tty->print_cr(\"*** misidentified method; %s(%d) should be %s(%d):\",\n+                  declared_name, declared_id, actual_name, actual_id);\n+    m->print_short_name(tty);\n+    tty->cr();\n+  }\n+}\n+#endif \/\/PRODUCT\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":862,"deletions":0,"binary":false,"changes":862,"status":"added"},{"patch":"@@ -878,0 +878,2 @@\n+\n+#endif \/\/ SHARE_CLASSFILE_VMINTRINSICS_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,819 +296,0 @@\n-\n-static vmIntrinsics::ID wrapper_intrinsic(BasicType type, bool unboxing) {\n-#define TYPE2(type, unboxing) ((int)(type)*2 + ((unboxing) ? 1 : 0))\n-  switch (TYPE2(type, unboxing)) {\n-#define BASIC_TYPE_CASE(type, box, unbox) \\\n-    case TYPE2(type, false):  return vmIntrinsics::box; \\\n-    case TYPE2(type, true):   return vmIntrinsics::unbox\n-    BASIC_TYPE_CASE(T_BOOLEAN, _Boolean_valueOf,   _booleanValue);\n-    BASIC_TYPE_CASE(T_BYTE,    _Byte_valueOf,      _byteValue);\n-    BASIC_TYPE_CASE(T_CHAR,    _Character_valueOf, _charValue);\n-    BASIC_TYPE_CASE(T_SHORT,   _Short_valueOf,     _shortValue);\n-    BASIC_TYPE_CASE(T_INT,     _Integer_valueOf,   _intValue);\n-    BASIC_TYPE_CASE(T_LONG,    _Long_valueOf,      _longValue);\n-    BASIC_TYPE_CASE(T_FLOAT,   _Float_valueOf,     _floatValue);\n-    BASIC_TYPE_CASE(T_DOUBLE,  _Double_valueOf,    _doubleValue);\n-#undef BASIC_TYPE_CASE\n-  }\n-#undef TYPE2\n-  return vmIntrinsics::_none;\n-}\n-\n-vmIntrinsics::ID vmIntrinsics::for_boxing(BasicType type) {\n-  return wrapper_intrinsic(type, false);\n-}\n-vmIntrinsics::ID vmIntrinsics::for_unboxing(BasicType type) {\n-  return wrapper_intrinsic(type, true);\n-}\n-\n-vmIntrinsics::ID vmIntrinsics::for_raw_conversion(BasicType src, BasicType dest) {\n-#define SRC_DEST(s,d) (((int)(s) << 4) + (int)(d))\n-  switch (SRC_DEST(src, dest)) {\n-  case SRC_DEST(T_INT, T_FLOAT):   return vmIntrinsics::_intBitsToFloat;\n-  case SRC_DEST(T_FLOAT, T_INT):   return vmIntrinsics::_floatToRawIntBits;\n-\n-  case SRC_DEST(T_LONG, T_DOUBLE): return vmIntrinsics::_longBitsToDouble;\n-  case SRC_DEST(T_DOUBLE, T_LONG): return vmIntrinsics::_doubleToRawLongBits;\n-  }\n-#undef SRC_DEST\n-\n-  return vmIntrinsics::_none;\n-}\n-\n-bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-  switch(id) {\n-#ifdef JFR_HAVE_INTRINSICS\n-  case vmIntrinsics::_counterTime:\n-#endif\n-  case vmIntrinsics::_currentTimeMillis:\n-  case vmIntrinsics::_nanoTime:\n-  case vmIntrinsics::_floatToRawIntBits:\n-  case vmIntrinsics::_intBitsToFloat:\n-  case vmIntrinsics::_doubleToRawLongBits:\n-  case vmIntrinsics::_longBitsToDouble:\n-  case vmIntrinsics::_getClass:\n-  case vmIntrinsics::_isInstance:\n-  case vmIntrinsics::_currentThread:\n-  case vmIntrinsics::_dabs:\n-  case vmIntrinsics::_fabs:\n-  case vmIntrinsics::_iabs:\n-  case vmIntrinsics::_labs:\n-  case vmIntrinsics::_dsqrt:\n-  case vmIntrinsics::_dsin:\n-  case vmIntrinsics::_dcos:\n-  case vmIntrinsics::_dtan:\n-  case vmIntrinsics::_dlog:\n-  case vmIntrinsics::_dlog10:\n-  case vmIntrinsics::_dexp:\n-  case vmIntrinsics::_dpow:\n-  case vmIntrinsics::_checkIndex:\n-  case vmIntrinsics::_Reference_get:\n-  case vmIntrinsics::_updateCRC32:\n-  case vmIntrinsics::_updateBytesCRC32:\n-  case vmIntrinsics::_updateByteBufferCRC32:\n-  case vmIntrinsics::_vectorizedMismatch:\n-  case vmIntrinsics::_fmaD:\n-  case vmIntrinsics::_fmaF:\n-  case vmIntrinsics::_isDigit:\n-  case vmIntrinsics::_isLowerCase:\n-  case vmIntrinsics::_isUpperCase:\n-  case vmIntrinsics::_isWhitespace:\n-    return true;\n-  default:\n-    return false;\n-  }\n-}\n-\n-bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-  switch(id) {\n-#ifdef JFR_HAVE_INTRINSICS\n-  case vmIntrinsics::_counterTime:\n-  case vmIntrinsics::_getClassId:\n-#endif\n-  case vmIntrinsics::_currentTimeMillis:\n-  case vmIntrinsics::_nanoTime:\n-  case vmIntrinsics::_floatToRawIntBits:\n-  case vmIntrinsics::_intBitsToFloat:\n-  case vmIntrinsics::_doubleToRawLongBits:\n-  case vmIntrinsics::_longBitsToDouble:\n-  case vmIntrinsics::_currentThread:\n-  case vmIntrinsics::_dabs:\n-  case vmIntrinsics::_fabs:\n-  case vmIntrinsics::_iabs:\n-  case vmIntrinsics::_labs:\n-  case vmIntrinsics::_dsqrt:\n-  case vmIntrinsics::_dsin:\n-  case vmIntrinsics::_dcos:\n-  case vmIntrinsics::_dtan:\n-  case vmIntrinsics::_dlog:\n-  case vmIntrinsics::_dlog10:\n-  case vmIntrinsics::_dexp:\n-  case vmIntrinsics::_dpow:\n-  case vmIntrinsics::_updateCRC32:\n-  case vmIntrinsics::_updateBytesCRC32:\n-  case vmIntrinsics::_updateByteBufferCRC32:\n-  case vmIntrinsics::_vectorizedMismatch:\n-  case vmIntrinsics::_fmaD:\n-  case vmIntrinsics::_fmaF:\n-    return false;\n-  default:\n-    return true;\n-  }\n-}\n-\n-\/\/ Some intrinsics produce different results if they are not pinned\n-bool vmIntrinsics::should_be_pinned(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-  switch(id) {\n-#ifdef JFR_HAVE_INTRINSICS\n-  case vmIntrinsics::_counterTime:\n-#endif\n-  case vmIntrinsics::_currentTimeMillis:\n-  case vmIntrinsics::_nanoTime:\n-    return true;\n-  default:\n-    return false;\n-  }\n-}\n-\n-bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-  switch(id) {\n-  case vmIntrinsics::_hashCode:\n-  case vmIntrinsics::_clone:\n-    return true;\n-    break;\n-  default:\n-    return false;\n-  }\n-}\n-\n-int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-  switch (id) {\n-  case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:\n-  case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:\n-  case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:\n-  case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:\n-  case vmIntrinsics::_counterMode_AESCrypt:\n-    return 1;\n-  case vmIntrinsics::_digestBase_implCompressMB:\n-    return 4;\n-  default:\n-    return 0;\n-  }\n-}\n-\n-bool vmIntrinsics::disabled_by_jvm_flags(vmIntrinsics::ID id) {\n-  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n-\n-  \/\/ -XX:-InlineNatives disables nearly all intrinsics except the ones listed in\n-  \/\/ the following switch statement.\n-  if (!InlineNatives) {\n-    switch (id) {\n-    case vmIntrinsics::_indexOfL:\n-    case vmIntrinsics::_indexOfU:\n-    case vmIntrinsics::_indexOfUL:\n-    case vmIntrinsics::_indexOfIL:\n-    case vmIntrinsics::_indexOfIU:\n-    case vmIntrinsics::_indexOfIUL:\n-    case vmIntrinsics::_indexOfU_char:\n-    case vmIntrinsics::_compareToL:\n-    case vmIntrinsics::_compareToU:\n-    case vmIntrinsics::_compareToLU:\n-    case vmIntrinsics::_compareToUL:\n-    case vmIntrinsics::_equalsL:\n-    case vmIntrinsics::_equalsU:\n-    case vmIntrinsics::_equalsC:\n-    case vmIntrinsics::_getCharStringU:\n-    case vmIntrinsics::_putCharStringU:\n-    case vmIntrinsics::_compressStringC:\n-    case vmIntrinsics::_compressStringB:\n-    case vmIntrinsics::_inflateStringC:\n-    case vmIntrinsics::_inflateStringB:\n-    case vmIntrinsics::_getAndAddInt:\n-    case vmIntrinsics::_getAndAddLong:\n-    case vmIntrinsics::_getAndSetInt:\n-    case vmIntrinsics::_getAndSetLong:\n-    case vmIntrinsics::_getAndSetReference:\n-    case vmIntrinsics::_loadFence:\n-    case vmIntrinsics::_storeFence:\n-    case vmIntrinsics::_fullFence:\n-    case vmIntrinsics::_hasNegatives:\n-    case vmIntrinsics::_Reference_get:\n-      break;\n-    default:\n-      return true;\n-    }\n-  }\n-\n-  switch (id) {\n-  case vmIntrinsics::_isInstance:\n-  case vmIntrinsics::_isAssignableFrom:\n-  case vmIntrinsics::_getModifiers:\n-  case vmIntrinsics::_isInterface:\n-  case vmIntrinsics::_isArray:\n-  case vmIntrinsics::_isPrimitive:\n-  case vmIntrinsics::_isHidden:\n-  case vmIntrinsics::_getSuperclass:\n-  case vmIntrinsics::_Class_cast:\n-  case vmIntrinsics::_getLength:\n-  case vmIntrinsics::_newArray:\n-  case vmIntrinsics::_getClass:\n-    if (!InlineClassNatives) return true;\n-    break;\n-  case vmIntrinsics::_currentThread:\n-    if (!InlineThreadNatives) return true;\n-    break;\n-  case vmIntrinsics::_floatToRawIntBits:\n-  case vmIntrinsics::_intBitsToFloat:\n-  case vmIntrinsics::_doubleToRawLongBits:\n-  case vmIntrinsics::_longBitsToDouble:\n-  case vmIntrinsics::_ceil:\n-  case vmIntrinsics::_floor:\n-  case vmIntrinsics::_rint:\n-  case vmIntrinsics::_dabs:\n-  case vmIntrinsics::_fabs:\n-  case vmIntrinsics::_iabs:\n-  case vmIntrinsics::_labs:\n-  case vmIntrinsics::_dsqrt:\n-  case vmIntrinsics::_dsin:\n-  case vmIntrinsics::_dcos:\n-  case vmIntrinsics::_dtan:\n-  case vmIntrinsics::_dlog:\n-  case vmIntrinsics::_dexp:\n-  case vmIntrinsics::_dpow:\n-  case vmIntrinsics::_dlog10:\n-  case vmIntrinsics::_datan2:\n-  case vmIntrinsics::_min:\n-  case vmIntrinsics::_max:\n-  case vmIntrinsics::_floatToIntBits:\n-  case vmIntrinsics::_doubleToLongBits:\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_minD:\n-    if (!InlineMathNatives) return true;\n-    break;\n-  case vmIntrinsics::_fmaD:\n-  case vmIntrinsics::_fmaF:\n-    if (!InlineMathNatives || !UseFMA) return true;\n-    break;\n-  case vmIntrinsics::_arraycopy:\n-    if (!InlineArrayCopy) return true;\n-    break;\n-  case vmIntrinsics::_updateCRC32:\n-  case vmIntrinsics::_updateBytesCRC32:\n-  case vmIntrinsics::_updateByteBufferCRC32:\n-    if (!UseCRC32Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_getReference:\n-  case vmIntrinsics::_getBoolean:\n-  case vmIntrinsics::_getByte:\n-  case vmIntrinsics::_getShort:\n-  case vmIntrinsics::_getChar:\n-  case vmIntrinsics::_getInt:\n-  case vmIntrinsics::_getLong:\n-  case vmIntrinsics::_getFloat:\n-  case vmIntrinsics::_getDouble:\n-  case vmIntrinsics::_putReference:\n-  case vmIntrinsics::_putBoolean:\n-  case vmIntrinsics::_putByte:\n-  case vmIntrinsics::_putShort:\n-  case vmIntrinsics::_putChar:\n-  case vmIntrinsics::_putInt:\n-  case vmIntrinsics::_putLong:\n-  case vmIntrinsics::_putFloat:\n-  case vmIntrinsics::_putDouble:\n-  case vmIntrinsics::_getReferenceVolatile:\n-  case vmIntrinsics::_getBooleanVolatile:\n-  case vmIntrinsics::_getByteVolatile:\n-  case vmIntrinsics::_getShortVolatile:\n-  case vmIntrinsics::_getCharVolatile:\n-  case vmIntrinsics::_getIntVolatile:\n-  case vmIntrinsics::_getLongVolatile:\n-  case vmIntrinsics::_getFloatVolatile:\n-  case vmIntrinsics::_getDoubleVolatile:\n-  case vmIntrinsics::_putReferenceVolatile:\n-  case vmIntrinsics::_putBooleanVolatile:\n-  case vmIntrinsics::_putByteVolatile:\n-  case vmIntrinsics::_putShortVolatile:\n-  case vmIntrinsics::_putCharVolatile:\n-  case vmIntrinsics::_putIntVolatile:\n-  case vmIntrinsics::_putLongVolatile:\n-  case vmIntrinsics::_putFloatVolatile:\n-  case vmIntrinsics::_putDoubleVolatile:\n-  case vmIntrinsics::_getReferenceAcquire:\n-  case vmIntrinsics::_getBooleanAcquire:\n-  case vmIntrinsics::_getByteAcquire:\n-  case vmIntrinsics::_getShortAcquire:\n-  case vmIntrinsics::_getCharAcquire:\n-  case vmIntrinsics::_getIntAcquire:\n-  case vmIntrinsics::_getLongAcquire:\n-  case vmIntrinsics::_getFloatAcquire:\n-  case vmIntrinsics::_getDoubleAcquire:\n-  case vmIntrinsics::_putReferenceRelease:\n-  case vmIntrinsics::_putBooleanRelease:\n-  case vmIntrinsics::_putByteRelease:\n-  case vmIntrinsics::_putShortRelease:\n-  case vmIntrinsics::_putCharRelease:\n-  case vmIntrinsics::_putIntRelease:\n-  case vmIntrinsics::_putLongRelease:\n-  case vmIntrinsics::_putFloatRelease:\n-  case vmIntrinsics::_putDoubleRelease:\n-  case vmIntrinsics::_getReferenceOpaque:\n-  case vmIntrinsics::_getBooleanOpaque:\n-  case vmIntrinsics::_getByteOpaque:\n-  case vmIntrinsics::_getShortOpaque:\n-  case vmIntrinsics::_getCharOpaque:\n-  case vmIntrinsics::_getIntOpaque:\n-  case vmIntrinsics::_getLongOpaque:\n-  case vmIntrinsics::_getFloatOpaque:\n-  case vmIntrinsics::_getDoubleOpaque:\n-  case vmIntrinsics::_putReferenceOpaque:\n-  case vmIntrinsics::_putBooleanOpaque:\n-  case vmIntrinsics::_putByteOpaque:\n-  case vmIntrinsics::_putShortOpaque:\n-  case vmIntrinsics::_putCharOpaque:\n-  case vmIntrinsics::_putIntOpaque:\n-  case vmIntrinsics::_putLongOpaque:\n-  case vmIntrinsics::_putFloatOpaque:\n-  case vmIntrinsics::_putDoubleOpaque:\n-  case vmIntrinsics::_getAndAddInt:\n-  case vmIntrinsics::_getAndAddLong:\n-  case vmIntrinsics::_getAndSetInt:\n-  case vmIntrinsics::_getAndSetLong:\n-  case vmIntrinsics::_getAndSetReference:\n-  case vmIntrinsics::_loadFence:\n-  case vmIntrinsics::_storeFence:\n-  case vmIntrinsics::_fullFence:\n-  case vmIntrinsics::_compareAndSetLong:\n-  case vmIntrinsics::_weakCompareAndSetLong:\n-  case vmIntrinsics::_weakCompareAndSetLongPlain:\n-  case vmIntrinsics::_weakCompareAndSetLongAcquire:\n-  case vmIntrinsics::_weakCompareAndSetLongRelease:\n-  case vmIntrinsics::_compareAndSetInt:\n-  case vmIntrinsics::_weakCompareAndSetInt:\n-  case vmIntrinsics::_weakCompareAndSetIntPlain:\n-  case vmIntrinsics::_weakCompareAndSetIntAcquire:\n-  case vmIntrinsics::_weakCompareAndSetIntRelease:\n-  case vmIntrinsics::_compareAndSetReference:\n-  case vmIntrinsics::_weakCompareAndSetReference:\n-  case vmIntrinsics::_weakCompareAndSetReferencePlain:\n-  case vmIntrinsics::_weakCompareAndSetReferenceAcquire:\n-  case vmIntrinsics::_weakCompareAndSetReferenceRelease:\n-  case vmIntrinsics::_compareAndExchangeInt:\n-  case vmIntrinsics::_compareAndExchangeIntAcquire:\n-  case vmIntrinsics::_compareAndExchangeIntRelease:\n-  case vmIntrinsics::_compareAndExchangeLong:\n-  case vmIntrinsics::_compareAndExchangeLongAcquire:\n-  case vmIntrinsics::_compareAndExchangeLongRelease:\n-  case vmIntrinsics::_compareAndExchangeReference:\n-  case vmIntrinsics::_compareAndExchangeReferenceAcquire:\n-  case vmIntrinsics::_compareAndExchangeReferenceRelease:\n-    if (!InlineUnsafeOps) return true;\n-    break;\n-  case vmIntrinsics::_getShortUnaligned:\n-  case vmIntrinsics::_getCharUnaligned:\n-  case vmIntrinsics::_getIntUnaligned:\n-  case vmIntrinsics::_getLongUnaligned:\n-  case vmIntrinsics::_putShortUnaligned:\n-  case vmIntrinsics::_putCharUnaligned:\n-  case vmIntrinsics::_putIntUnaligned:\n-  case vmIntrinsics::_putLongUnaligned:\n-  case vmIntrinsics::_allocateInstance:\n-    if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;\n-    break;\n-  case vmIntrinsics::_hashCode:\n-    if (!InlineObjectHash) return true;\n-    break;\n-  case vmIntrinsics::_aescrypt_encryptBlock:\n-  case vmIntrinsics::_aescrypt_decryptBlock:\n-    if (!UseAESIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:\n-  case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:\n-    if (!UseAESIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:\n-  case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:\n-    if (!UseAESIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_counterMode_AESCrypt:\n-    if (!UseAESCTRIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_md5_implCompress:\n-    if (!UseMD5Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_sha_implCompress:\n-    if (!UseSHA1Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_sha2_implCompress:\n-    if (!UseSHA256Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_sha5_implCompress:\n-    if (!UseSHA512Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_digestBase_implCompressMB:\n-    if (!(UseMD5Intrinsics || UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;\n-    break;\n-  case vmIntrinsics::_ghash_processBlocks:\n-    if (!UseGHASHIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_base64_encodeBlock:\n-    if (!UseBASE64Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_updateBytesCRC32C:\n-  case vmIntrinsics::_updateDirectByteBufferCRC32C:\n-    if (!UseCRC32CIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_vectorizedMismatch:\n-    if (!UseVectorizedMismatchIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_updateBytesAdler32:\n-  case vmIntrinsics::_updateByteBufferAdler32:\n-    if (!UseAdler32Intrinsics) return true;\n-    break;\n-  case vmIntrinsics::_copyMemory:\n-    if (!InlineArrayCopy || !InlineUnsafeOps) return true;\n-    break;\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n-#ifdef COMPILER2\n-  case vmIntrinsics::_clone:\n-  case vmIntrinsics::_copyOf:\n-  case vmIntrinsics::_copyOfRange:\n-    \/\/ These intrinsics use both the objectcopy and the arraycopy\n-    \/\/ intrinsic mechanism.\n-    if (!InlineObjectCopy || !InlineArrayCopy) return true;\n-    break;\n-  case vmIntrinsics::_compareToL:\n-  case vmIntrinsics::_compareToU:\n-  case vmIntrinsics::_compareToLU:\n-  case vmIntrinsics::_compareToUL:\n-    if (!SpecialStringCompareTo) return true;\n-    break;\n-  case vmIntrinsics::_indexOfL:\n-  case vmIntrinsics::_indexOfU:\n-  case vmIntrinsics::_indexOfUL:\n-  case vmIntrinsics::_indexOfIL:\n-  case vmIntrinsics::_indexOfIU:\n-  case vmIntrinsics::_indexOfIUL:\n-  case vmIntrinsics::_indexOfU_char:\n-    if (!SpecialStringIndexOf) return true;\n-    break;\n-  case vmIntrinsics::_equalsL:\n-  case vmIntrinsics::_equalsU:\n-    if (!SpecialStringEquals) return true;\n-    break;\n-  case vmIntrinsics::_equalsB:\n-  case vmIntrinsics::_equalsC:\n-    if (!SpecialArraysEquals) return true;\n-    break;\n-  case vmIntrinsics::_encodeISOArray:\n-  case vmIntrinsics::_encodeByteISOArray:\n-    if (!SpecialEncodeISOArray) return true;\n-    break;\n-  case vmIntrinsics::_getCallerClass:\n-    if (!InlineReflectionGetCallerClass) return true;\n-    break;\n-  case vmIntrinsics::_multiplyToLen:\n-    if (!UseMultiplyToLenIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_squareToLen:\n-    if (!UseSquareToLenIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_mulAdd:\n-    if (!UseMulAddIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_montgomeryMultiply:\n-    if (!UseMontgomeryMultiplyIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_montgomerySquare:\n-    if (!UseMontgomerySquareIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_bigIntegerRightShiftWorker:\n-  case vmIntrinsics::_bigIntegerLeftShiftWorker:\n-    break;\n-  case vmIntrinsics::_addExactI:\n-  case vmIntrinsics::_addExactL:\n-  case vmIntrinsics::_decrementExactI:\n-  case vmIntrinsics::_decrementExactL:\n-  case vmIntrinsics::_incrementExactI:\n-  case vmIntrinsics::_incrementExactL:\n-  case vmIntrinsics::_multiplyExactI:\n-  case vmIntrinsics::_multiplyExactL:\n-  case vmIntrinsics::_negateExactI:\n-  case vmIntrinsics::_negateExactL:\n-  case vmIntrinsics::_subtractExactI:\n-  case vmIntrinsics::_subtractExactL:\n-    if (!UseMathExactIntrinsics || !InlineMathNatives) return true;\n-    break;\n-  case vmIntrinsics::_isDigit:\n-  case vmIntrinsics::_isLowerCase:\n-  case vmIntrinsics::_isUpperCase:\n-  case vmIntrinsics::_isWhitespace:\n-    if (!UseCharacterCompareIntrinsics) return true;\n-    break;\n-  case vmIntrinsics::_dcopySign:\n-  case vmIntrinsics::_fcopySign:\n-    if (!InlineMathNatives || !UseCopySignIntrinsic) return true;\n-    break;\n-  case vmIntrinsics::_dsignum:\n-  case vmIntrinsics::_fsignum:\n-    if (!InlineMathNatives || !UseSignumIntrinsic) return true;\n-    break;\n-#endif \/\/ COMPILER2\n-  default:\n-    return false;\n-  }\n-\n-  return false;\n-}\n-\n-#define VM_INTRINSIC_INITIALIZE(id, klass, name, sig, flags) #id \"\\0\"\n-static const char* vm_intrinsic_name_bodies =\n-  VM_INTRINSICS_DO(VM_INTRINSIC_INITIALIZE,\n-                   VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n-\n-static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];\n-static TriBoolArray<vmIntrinsics::ID_LIMIT, int> vm_intrinsic_control_words;\n-\n-static void init_vm_intrinsic_name_table() {\n-  const char** nt = &vm_intrinsic_name_table[0];\n-  char* string = (char*) &vm_intrinsic_name_bodies[0];\n-  for (int index = vmIntrinsics::FIRST_ID; index < vmIntrinsics::ID_LIMIT; index++) {\n-    nt[index] = string;\n-    string += strlen(string); \/\/ skip string body\n-    string += 1;              \/\/ skip trailing null\n-  }\n-  assert(!strcmp(nt[vmIntrinsics::_hashCode], \"_hashCode\"), \"lined up\");\n-  nt[vmIntrinsics::_none] = \"_none\";\n-}\n-\n-const char* vmIntrinsics::name_at(vmIntrinsics::ID id) {\n-  const char** nt = &vm_intrinsic_name_table[0];\n-  if (nt[_none] == NULL) {\n-    init_vm_intrinsic_name_table();\n-  }\n-\n-  if ((uint)id < (uint)ID_LIMIT)\n-    return vm_intrinsic_name_table[(uint)id];\n-  else\n-    return \"(unknown intrinsic)\";\n-}\n-\n-vmIntrinsics::ID vmIntrinsics::find_id(const char* name) {\n-  const char** nt = &vm_intrinsic_name_table[0];\n-  if (nt[_none] == NULL) {\n-    init_vm_intrinsic_name_table();\n-  }\n-\n-  for (int index = FIRST_ID; index < ID_LIMIT; ++index) {\n-    if (0 == strcmp(name, nt[index])) {\n-      return ID_from(index);\n-    }\n-  }\n-\n-  return _none;\n-}\n-\n-bool vmIntrinsics::is_disabled_by_flags(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n-  return is_disabled_by_flags(id);\n-}\n-\n-bool vmIntrinsics::is_disabled_by_flags(vmIntrinsics::ID id) {\n-  assert(id > _none && id < ID_LIMIT, \"must be a VM intrinsic\");\n-\n-  \/\/ not initialized yet, process Control\/DisableIntrinsic\n-  if (vm_intrinsic_control_words[_none].is_default()) {\n-    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {\n-      vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);\n-\n-      if (id != vmIntrinsics::_none) {\n-        vm_intrinsic_control_words[id] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n-      }\n-    }\n-\n-    \/\/ Order matters, DisableIntrinsic can overwrite ControlIntrinsic\n-    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != NULL; ++iter) {\n-      vmIntrinsics::ID id = vmIntrinsics::find_id(*iter);\n-\n-      if (id != vmIntrinsics::_none) {\n-        vm_intrinsic_control_words[id] = false;\n-      }\n-    }\n-\n-    vm_intrinsic_control_words[_none] = true;\n-  }\n-\n-  TriBool b = vm_intrinsic_control_words[id];\n-  if (b.is_default()) {\n-    \/\/ unknown yet, query and cache it\n-    b = vm_intrinsic_control_words[id] = !disabled_by_jvm_flags(id);\n-  }\n-\n-  return !b;\n-}\n-\n-\/\/ These are flag-matching functions:\n-inline bool match_F_R(jshort flags) {\n-  const int req = 0;\n-  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;\n-  return (flags & (req | neg)) == req;\n-}\n-inline bool match_F_Y(jshort flags) {\n-  const int req = JVM_ACC_SYNCHRONIZED;\n-  const int neg = JVM_ACC_STATIC;\n-  return (flags & (req | neg)) == req;\n-}\n-inline bool match_F_RN(jshort flags) {\n-  const int req = JVM_ACC_NATIVE;\n-  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;\n-  return (flags & (req | neg)) == req;\n-}\n-inline bool match_F_S(jshort flags) {\n-  const int req = JVM_ACC_STATIC;\n-  const int neg = JVM_ACC_SYNCHRONIZED;\n-  return (flags & (req | neg)) == req;\n-}\n-inline bool match_F_SN(jshort flags) {\n-  const int req = JVM_ACC_STATIC | JVM_ACC_NATIVE;\n-  const int neg = JVM_ACC_SYNCHRONIZED;\n-  return (flags & (req | neg)) == req;\n-}\n-inline bool match_F_RNY(jshort flags) {\n-  const int req = JVM_ACC_NATIVE | JVM_ACC_SYNCHRONIZED;\n-  const int neg = JVM_ACC_STATIC;\n-  return (flags & (req | neg)) == req;\n-}\n-\n-\/\/ These are for forming case labels:\n-#define ID3(x, y, z) (( jlong)(z) +                                  \\\n-                      ((jlong)(y) <<    vmSymbols::log2_SID_LIMIT) + \\\n-                      ((jlong)(x) << (2*vmSymbols::log2_SID_LIMIT))  )\n-#define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)\n-\n-vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbols::SID holder,\n-                                            vmSymbols::SID name,\n-                                            vmSymbols::SID sig,\n-                                            jshort flags) {\n-  assert((int)vmSymbols::SID_LIMIT <= (1<<vmSymbols::log2_SID_LIMIT), \"must fit\");\n-\n-  \/\/ Let the C compiler build the decision tree.\n-\n-#define VM_INTRINSIC_CASE(id, klass, name, sig, fcode) \\\n-  case ID3(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig)): \\\n-    if (!match_##fcode(flags))  break; \\\n-    return id;\n-\n-  switch (ID3(holder, name, sig)) {\n-    VM_INTRINSICS_DO(VM_INTRINSIC_CASE,\n-                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n-  }\n-  return vmIntrinsics::_none;\n-\n-#undef VM_INTRINSIC_CASE\n-}\n-\n-\n-const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {\n-  const char* str = name_at(id);\n-#ifndef PRODUCT\n-  const char* kname = vmSymbols::name_for(class_for(id));\n-  const char* mname = vmSymbols::name_for(name_for(id));\n-  const char* sname = vmSymbols::name_for(signature_for(id));\n-  const char* fname = \"\";\n-  switch (flags_for(id)) {\n-  case F_Y:  fname = \"synchronized \";  break;\n-  case F_RN: fname = \"native \";        break;\n-  case F_SN: fname = \"native static \"; break;\n-  case F_S:  fname = \"static \";        break;\n-  case F_RNY:fname = \"native synchronized \"; break;\n-  default:   break;\n-  }\n-  const char* kptr = strrchr(kname, JVM_SIGNATURE_SLASH);\n-  if (kptr != NULL)  kname = kptr + 1;\n-  int len = jio_snprintf(buf, buflen, \"%s: %s%s.%s%s\",\n-                         str, fname, kname, mname, sname);\n-  if (len < buflen)\n-    str = buf;\n-#endif \/\/PRODUCT\n-  return str;\n-}\n-\n-\n-\/\/ These are to get information about intrinsics.\n-\n-#define ID4(x, y, z, f) ((ID3(x, y, z) << vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))\n-\n-static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {\n-#define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \\\n-  ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),\n-\n-  0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,\n-                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n-    0\n-#undef VM_INTRINSIC_INFO\n-};\n-\n-inline jlong intrinsic_info(vmIntrinsics::ID id) {\n-  return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];\n-}\n-\n-vmSymbols::SID vmIntrinsics::class_for(vmIntrinsics::ID id) {\n-  jlong info = intrinsic_info(id);\n-  int shift = 2*vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n-  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1021, \"\");\n-  return vmSymbols::SID( (info >> shift) & mask );\n-}\n-\n-vmSymbols::SID vmIntrinsics::name_for(vmIntrinsics::ID id) {\n-  jlong info = intrinsic_info(id);\n-  int shift = vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n-  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1022, \"\");\n-  return vmSymbols::SID( (info >> shift) & mask );\n-}\n-\n-vmSymbols::SID vmIntrinsics::signature_for(vmIntrinsics::ID id) {\n-  jlong info = intrinsic_info(id);\n-  int shift = log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);\n-  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 1023, \"\");\n-  return vmSymbols::SID( (info >> shift) & mask );\n-}\n-\n-vmIntrinsics::Flags vmIntrinsics::flags_for(vmIntrinsics::ID id) {\n-  jlong info = intrinsic_info(id);\n-  int shift = 0, mask = right_n_bits(log2_FLAG_LIMIT);\n-  assert(((ID4(1021,1022,1023,15) >> shift) & mask) == 15, \"\");\n-  return Flags( (info >> shift) & mask );\n-}\n-\n-\n-#ifndef PRODUCT\n-\/\/ verify_method performs an extra check on a matched intrinsic method\n-\n-static bool match_method(Method* m, Symbol* n, Symbol* s) {\n-  return (m->name() == n &&\n-          m->signature() == s);\n-}\n-\n-static vmIntrinsics::ID match_method_with_klass(Method* m, Symbol* mk) {\n-#define VM_INTRINSIC_MATCH(id, klassname, namepart, sigpart, flags) \\\n-  { Symbol* k = vmSymbols::klassname(); \\\n-    if (mk == k) { \\\n-      Symbol* n = vmSymbols::namepart(); \\\n-      Symbol* s = vmSymbols::sigpart(); \\\n-      if (match_method(m, n, s)) \\\n-        return vmIntrinsics::id; \\\n-    } }\n-  VM_INTRINSICS_DO(VM_INTRINSIC_MATCH,\n-                   VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n-  return vmIntrinsics::_none;\n-#undef VM_INTRINSIC_MATCH\n-}\n-\n-void vmIntrinsics::verify_method(ID actual_id, Method* m) {\n-  Symbol* mk = m->method_holder()->name();\n-  ID declared_id = match_method_with_klass(m, mk);\n-\n-  if (declared_id == actual_id)  return; \/\/ success\n-\n-  if (declared_id == _none && actual_id != _none && mk == vmSymbols::java_lang_StrictMath()) {\n-    \/\/ Here are a few special cases in StrictMath not declared in vmSymbols.hpp.\n-    switch (actual_id) {\n-    case _min:\n-    case _max:\n-    case _dsqrt:\n-      declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());\n-      if (declared_id == actual_id)  return; \/\/ acceptable alias\n-      break;\n-    default:\n-        break;\n-    }\n-  }\n-\n-  const char* declared_name = name_at(declared_id);\n-  const char* actual_name   = name_at(actual_id);\n-  m = NULL;\n-  ttyLocker ttyl;\n-  if (xtty != NULL) {\n-    xtty->begin_elem(\"intrinsic_misdeclared actual='%s' declared='%s'\",\n-                     actual_name, declared_name);\n-    xtty->method(m);\n-    xtty->end_elem(\"%s\", \"\");\n-  }\n-  if (PrintMiscellaneous && (WizardMode || Verbose)) {\n-    tty->print_cr(\"*** misidentified method; %s(%d) should be %s(%d):\",\n-                  declared_name, declared_id, actual_name, actual_id);\n-    m->print_short_name(tty);\n-    tty->cr();\n-  }\n-}\n-#endif \/\/PRODUCT\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":0,"deletions":819,"binary":false,"changes":819,"status":"modified"}]}