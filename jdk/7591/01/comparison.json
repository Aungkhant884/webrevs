{"files":[{"patch":"@@ -155,0 +155,1 @@\n+inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+inline bool frame::can_access_link(Thread *thread) const { return true; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+inline bool frame::can_access_link(Thread *thread) const { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,2 @@\n+inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+inline bool frame::can_access_link(Thread *t) const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+  \/\/ is the link accessible (if it is on the stack, is this location really in the thread's stack?)\n+  bool can_access_link(Thread* thread) const;\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1183,2 +1183,1 @@\n-#endif\n-\n+#else\n@@ -1214,0 +1213,17 @@\n+#endif\n+}\n+\n+\/\/ Looks like all platforms can use the same function to check if C\n+\/\/ stack is walkable beyond current frame.\n+\/\/ This version of the method adds more checks that need the thread\n+bool os::is_first_C_frame(frame* fr, Thread *t) {\n+#ifdef _WINDOWS\n+  return true; \/\/ native stack isn't walkable on windows this way.\n+#else\n+  return !fr->can_access_link(t) || os::is_first_C_frame(fr) ||\n+         !t->is_in_full_stack((address)fr->sp()) ||\n+         !t->is_in_full_stack((address)fr->fp()) ||\n+         !t->is_in_full_stack((address)fr->sender_sp()) ||\n+         !t->is_in_full_stack((address)fr->link());\n+\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  \/\/ The following two functions are used by fatal error handler to trace\n+  \/\/ The following three functions are used by fatal error handler to trace\n@@ -724,0 +724,1 @@\n+  static bool is_first_C_frame(frame *fr, Thread *t);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      if (os::is_first_C_frame(&fr)) return invalid;\n+      if (os::is_first_C_frame(&fr, t)) return invalid;\n@@ -342,1 +342,1 @@\n-    if (os::is_first_C_frame(&fr)) return invalid;\n+    if (os::is_first_C_frame(&fr, t)) return invalid;\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}