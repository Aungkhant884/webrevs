{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -153,3 +154,1 @@\n-inline intptr_t* frame::link() const              { return (intptr_t*) *(intptr_t **)addr_at(link_offset); }\n-\n-inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n+inline intptr_t* frame::link() const              { return (intptr_t*) SafeFetchN((intptr_t *)addr_at(link_offset), NULL); }\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -128,3 +129,1 @@\n-inline intptr_t* frame::link() const              { return (intptr_t*) *(intptr_t **)addr_at(link_offset); }\n-\n-inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n+inline intptr_t* frame::link() const              { return (intptr_t*) SafeFetchN((intptr_t *)addr_at(link_offset), NULL); }\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,2 +120,0 @@\n-inline bool frame::can_access_link(Thread *thread) const { return true; }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,2 +158,0 @@\n-inline bool frame::can_access_link(Thread *thread) const { return true; }\n-\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -143,3 +144,1 @@\n-inline intptr_t* frame::link() const              { return (intptr_t*) *(intptr_t **)addr_at(link_offset); }\n-\n-inline bool frame::can_access_link(Thread *thread) const { return thread->is_in_full_stack((address)addr_at(link_offset)); }\n+inline intptr_t* frame::link() const              { return (intptr_t*) SafeFetchN((intptr_t *)addr_at(link_offset), NULL); }\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,5 +85,0 @@\n-inline bool frame::can_access_link(Thread *t) const {\n-  ShouldNotCallThis();\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,3 +212,0 @@\n-  \/\/ is the link accessible (if it is on the stack, is this location really in the thread's stack?)\n-  bool can_access_link(Thread* thread) const;\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1192,1 +1192,1 @@\n-  if ((usp & sp_align_mask) != 0) return true;\n+  if ((usp & sp_align_mask) != 0 || SafeFetchN(fr->sp(), 0) == 0) return true;\n@@ -1195,1 +1195,1 @@\n-  if ((ufp & fp_align_mask) != 0) return true;\n+  if ((ufp & fp_align_mask) != 0 || SafeFetchN(fr->fp(), 0) == 0) return true;\n@@ -1199,1 +1199,1 @@\n-  if (old_sp == 0 || old_sp == (uintptr_t)-1) return true;\n+  if (old_sp == 0 || old_sp == (uintptr_t)-1 || SafeFetchN(fr->sender_sp(), 0) == 0) return true;\n@@ -1202,2 +1202,2 @@\n-  if ((old_fp & fp_align_mask) != 0) return true;\n-  if (old_fp == 0 || old_fp == (uintptr_t)-1 || old_fp == ufp) return true;\n+  if ((old_fp & fp_align_mask) == 0) return true;\n+  if (old_fp == 0 || old_fp == (uintptr_t)-1 || old_fp == ufp || SafeFetchN(fr->link(), 0) == 0) return true;\n@@ -1216,17 +1216,0 @@\n-\/\/ Looks like all platforms can use the same function to check if C\n-\/\/ stack is walkable beyond current frame.\n-\/\/ This version of the method adds more checks that need the thread\n-bool os::is_first_C_frame(frame* fr, Thread *t) {\n-#ifdef _WINDOWS\n-  return true; \/\/ native stack isn't walkable on windows this way.\n-#else\n-  return !fr->can_access_link(t) || os::is_first_C_frame(fr) ||\n-         !t->is_in_full_stack((address)fr->sp()) ||\n-         !t->is_in_full_stack((address)fr->fp()) ||\n-         !t->is_in_full_stack((address)fr->sender_sp()) ||\n-         !t->is_in_full_stack((address)fr->link());\n-\n-#endif\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  \/\/ The following three functions are used by fatal error handler to trace\n+  \/\/ The following two functions are used by fatal error handler to trace\n@@ -724,1 +724,0 @@\n-  static bool is_first_C_frame(frame *fr, Thread *t);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      if (os::is_first_C_frame(&fr, t)) return invalid;\n+      if (os::is_first_C_frame(&fr)) return invalid;\n@@ -342,1 +342,1 @@\n-    if (os::is_first_C_frame(&fr, t)) return invalid;\n+    if (os::is_first_C_frame(&fr)) return invalid;\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}