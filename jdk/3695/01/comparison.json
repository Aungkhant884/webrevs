{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,1 +477,1 @@\n-    ldr(rscratch2, Address(rthread, Thread::polling_word_offset()));\n+    ldr(rscratch2, Address(rthread, JavaThread::polling_word_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-    lea(rscratch1, Address(rthread, Thread::polling_word_offset()));\n+    lea(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n@@ -300,1 +300,1 @@\n-    ldr(rscratch1, Address(rthread, Thread::polling_word_offset()));\n+    ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n@@ -4396,1 +4396,1 @@\n-  ldr(dest, Address(rthread, Thread::polling_page_offset()));\n+  ldr(dest, Address(rthread, JavaThread::polling_page_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -583,1 +583,1 @@\n-    ldr(Rtemp, Address(Rthread, Thread::polling_word_offset()));\n+    ldr(Rtemp, Address(Rthread, JavaThread::polling_word_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1901,1 +1901,1 @@\n-  ldr_u32(tmp1, Address(Rthread, Thread::polling_word_offset()));\n+  ldr_u32(tmp1, Address(Rthread, JavaThread::polling_word_offset()));\n@@ -1907,1 +1907,1 @@\n-  ldr(dest, Address(Rthread, Thread::polling_page_offset()));\n+  ldr(dest, Address(Rthread, JavaThread::polling_page_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1358,1 +1358,1 @@\n-  __ ld(poll_addr, in_bytes(Thread::polling_page_offset()), R16_thread);\n+  __ ld(poll_addr, in_bytes(JavaThread::polling_page_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-      ld(R0, in_bytes(Thread::polling_word_offset()), R16_thread);\n+      ld(R0, in_bytes(JavaThread::polling_word_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3061,1 +3061,1 @@\n-  ld(temp, in_bytes(Thread::polling_word_offset()), R16_thread);\n+  ld(temp, in_bytes(JavaThread::polling_word_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2145,1 +2145,1 @@\n-    __ ld(R11_scratch1, in_bytes(Thread::polling_word_offset()), R16_thread);\n+    __ ld(R11_scratch1, in_bytes(JavaThread::polling_word_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1212,1 +1212,1 @@\n-  __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));\n+  __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::polling_page_offset()));\n@@ -1231,1 +1231,1 @@\n-  __ z_lg(poll_addr, Address(Z_thread, Thread::polling_page_offset()));\n+  __ z_lg(poll_addr, Address(Z_thread, JavaThread::polling_page_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-      const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_word_offset()) + 7 \/* Big Endian *\/);\n+      const Address poll_byte_addr(Z_thread, in_bytes(JavaThread::polling_word_offset()) + 7 \/* Big Endian *\/);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2655,1 +2655,1 @@\n-  const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_word_offset()) + 7 \/* Big Endian *\/);\n+  const Address poll_byte_addr(Z_thread, in_bytes(JavaThread::polling_word_offset()) + 7 \/* Big Endian *\/);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -960,1 +960,1 @@\n-    __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));\n+    __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::polling_page_offset()));\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2322,1 +2322,1 @@\n-    const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_word_offset()) + 7 \/* Big Endian *\/);\n+    const Address poll_byte_addr(Z_thread, in_bytes(JavaThread::polling_word_offset()) + 7 \/* Big Endian *\/);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-  __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));\n+  __ movptr(poll_addr, Address(r15_thread, JavaThread::polling_page_offset()));\n@@ -563,1 +563,1 @@\n-  __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));\n+  __ movptr(poll_addr, Address(poll_addr, in_bytes(JavaThread::polling_page_offset())));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -861,1 +861,1 @@\n-    testb(Address(r15_thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+    testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n@@ -880,1 +880,1 @@\n-    testb(Address(thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+    testb(Address(thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2811,1 +2811,1 @@\n-    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, Thread::polling_word_offset()));\n+    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, JavaThread::polling_word_offset()));\n@@ -2815,1 +2815,1 @@\n-  testb(Address(thread_reg, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  testb(Address(thread_reg, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2608,1 +2608,1 @@\n-    __ testb(Address(r15_thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+    __ testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n@@ -2612,1 +2612,1 @@\n-    __ testb(Address(thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n+    __ testb(Address(thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  _thread->check_for_valid_safepoint_state();\n+  _thread->as_Java_thread()->check_for_valid_safepoint_state();\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-      DEBUG_ONLY(Thread::current()->check_possible_safepoint());\n+      DEBUG_ONLY(JavaThread::current()->check_possible_safepoint());\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n@@ -335,1 +336,0 @@\n-  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-  THREAD->check_possible_safepoint();\n+  THREAD->as_Java_thread()->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  THREAD->check_possible_safepoint();\n+  THREAD->as_Java_thread()->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2282,1 +2282,1 @@\n-  Node *polling_page_load_addr = _gvn.transform(basic_plus_adr(top(), thread, in_bytes(Thread::polling_page_offset())));\n+  Node *polling_page_load_addr = _gvn.transform(basic_plus_adr(top(), thread, in_bytes(JavaThread::polling_page_offset())));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    DEBUG_ONLY(Thread::current()->check_possible_safepoint());\n+    DEBUG_ONLY(JavaThread::current()->check_possible_safepoint());\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    thread->check_for_valid_safepoint_state();\n+    thread->as_Java_thread()->check_for_valid_safepoint_state();\n@@ -422,17 +422,0 @@\n-\/\/ NSV implied with locking allow_vm_block or !safepoint_check locks.\n-void Mutex::no_safepoint_verifier(Thread* thread, bool enable) {\n-  \/\/ The tty_lock is special because it is released for the safepoint by\n-  \/\/ the safepoint mechanism.\n-  if (this == tty_lock) {\n-    return;\n-  }\n-\n-  if (_allow_vm_block) {\n-    if (enable) {\n-      thread->_no_safepoint_count++;\n-    } else {\n-      thread->_no_safepoint_count--;\n-    }\n-  }\n-}\n-\n@@ -466,1 +449,5 @@\n-    no_safepoint_verifier(new_owner, true);\n+    \/\/ The tty_lock is special because it is released for the safepoint by\n+    \/\/ the safepoint mechanism.\n+    if (new_owner->is_Java_thread() && _allow_vm_block && this != tty_lock) {\n+      new_owner->as_Java_thread()->inc_no_safepoint_count();\n+    }\n@@ -501,1 +488,3 @@\n-    no_safepoint_verifier(old_owner, false);\n+    if (old_owner->is_Java_thread() && _allow_vm_block && this != tty_lock) {\n+      old_owner->as_Java_thread()->dec_no_safepoint_count();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  void no_safepoint_verifier   (Thread* thread, bool enable)          NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,3 @@\n-  _thread->_no_safepoint_count++;\n+  if (_thread->is_Java_thread()) {\n+    _thread->as_Java_thread()->inc_no_safepoint_count();\n+  }\n@@ -39,1 +41,3 @@\n-  _thread->_no_safepoint_count--;\n+  if (_thread->is_Java_thread()) {\n+    _thread->as_Java_thread()->dec_no_safepoint_count();\n+  }\n@@ -45,1 +49,3 @@\n-  _nsv->_thread->_no_safepoint_count--;\n+  if (_nsv->_thread->is_Java_thread()) {\n+    _nsv->_thread->as_Java_thread()->dec_no_safepoint_count();\n+  }\n@@ -49,1 +55,3 @@\n-  _nsv->_thread->_no_safepoint_count++;\n+  if (_nsv->_thread->is_Java_thread()) {\n+    _nsv->_thread->as_Java_thread()->inc_no_safepoint_count();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/safepointVerifiers.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-  NOT_PRODUCT(_no_safepoint_count = 0;)\n@@ -272,4 +271,0 @@\n-#ifdef ASSERT\n-  _visited_for_critical_count = false;\n-#endif\n-\n@@ -722,32 +717,0 @@\n-\n-\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n-void Thread::check_possible_safepoint() {\n-  if (!is_Java_thread()) return;\n-\n-  if (_no_safepoint_count > 0) {\n-    print_owned_locks();\n-    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n-  }\n-#ifdef CHECK_UNHANDLED_OOPS\n-  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n-  clear_unhandled_oops();\n-#endif \/\/ CHECK_UNHANDLED_OOPS\n-}\n-\n-void Thread::check_for_valid_safepoint_state() {\n-  if (!is_Java_thread()) return;\n-\n-  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n-  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n-  \/\/ are held.\n-  check_possible_safepoint();\n-\n-  if (this->as_Java_thread()->thread_state() != _thread_in_vm) {\n-    fatal(\"LEAF method calling lock?\");\n-  }\n-\n-  if (GCALotAtAllSafepoints) {\n-    \/\/ We could enter a safepoint here and thus have a gc\n-    InterfaceSupport::check_gc_alot();\n-  }\n-}\n@@ -1046,0 +1009,30 @@\n+#ifdef ASSERT\n+\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n+void JavaThread::check_possible_safepoint() {\n+  if (_no_safepoint_count > 0) {\n+    print_owned_locks();\n+    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n+  }\n+#ifdef CHECK_UNHANDLED_OOPS\n+  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n+  clear_unhandled_oops();\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n+}\n+\n+void JavaThread::check_for_valid_safepoint_state() {\n+  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n+  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n+  \/\/ are held.\n+  check_possible_safepoint();\n+\n+  if (thread_state() != _thread_in_vm) {\n+    fatal(\"LEAF method calling lock?\");\n+  }\n+\n+  if (GCALotAtAllSafepoints) {\n+    \/\/ We could enter a safepoint here and thus have a gc\n+    InterfaceSupport::check_gc_alot();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n@@ -1069,0 +1062,4 @@\n+#ifdef ASSERT\n+  _no_safepoint_count(0),\n+  _visited_for_critical_count(false),\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -295,12 +295,0 @@\n- private:\n-\n-  \/\/ Debug support for checking if code allows safepoints or not.\n-  \/\/ Safepoints in the VM can happen because of allocation, invoking a VM operation, or blocking on\n-  \/\/ mutex, or blocking on an object synchronizer (Java locking).\n-  \/\/ If _no_safepoint_count is non-zero, then an assertion failure will happen in any of\n-  \/\/ the above cases.\n-  \/\/\n-  \/\/ The class NoSafepointVerifier is used to set this counter.\n-  \/\/\n-  NOT_PRODUCT(int _no_safepoint_count;)         \/\/ If 0, thread allow a safepoint to happen\n-\n@@ -312,5 +300,0 @@\n-  friend class NoSafepointVerifier;\n-  friend class PauseNoSafepointVerifier;\n-\n- protected:\n-  SafepointMechanism::ThreadData _poll_data;\n@@ -338,19 +321,0 @@\n-#ifdef ASSERT\n- private:\n-  volatile uint64_t _visited_for_critical_count;\n-\n- public:\n-  void set_visited_for_critical_count(uint64_t safepoint_id) {\n-    assert(_visited_for_critical_count == 0, \"Must be reset before set\");\n-    assert((safepoint_id & 0x1) == 1, \"Must be odd\");\n-    _visited_for_critical_count = safepoint_id;\n-  }\n-  void reset_visited_for_critical_count(uint64_t safepoint_id) {\n-    assert(_visited_for_critical_count == safepoint_id, \"Was not visited\");\n-    _visited_for_critical_count = 0;\n-  }\n-  bool was_visited_for_critical_count(uint64_t safepoint_id) const {\n-    return _visited_for_critical_count == safepoint_id;\n-  }\n-#endif\n-\n@@ -706,5 +670,0 @@\n-  \/\/ These functions check conditions on a JavaThread before possibly going to a safepoint,\n-  \/\/ including NoSafepointVerifier.\n-  void check_for_valid_safepoint_state() NOT_DEBUG_RETURN;\n-  void check_possible_safepoint() NOT_DEBUG_RETURN;\n-\n@@ -727,3 +686,0 @@\n-  static ByteSize polling_word_offset()          { return byte_offset_of(Thread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(Thread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n-\n@@ -882,1 +838,1 @@\n- public:                                         \/\/ Expose _thread_state for SafeFetchInt()\n+ public:                                                        \/\/ Expose _thread_state for SafeFetchInt()\n@@ -885,3 +841,40 @@\n-  ThreadSafepointState* _safepoint_state;        \/\/ Holds information about a thread during a safepoint\n-  address               _saved_exception_pc;     \/\/ Saved pc of instruction where last implicit exception happened\n-  NOT_PRODUCT(bool      _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n+  SafepointMechanism::ThreadData _poll_data;\n+  ThreadSafepointState*          _safepoint_state;              \/\/ Holds information about a thread during a safepoint\n+  address                        _saved_exception_pc;           \/\/ Saved pc of instruction where last implicit exception happened\n+  NOT_PRODUCT(bool               _requires_cross_modify_fence;) \/\/ State used by VerifyCrossModifyFence\n+#ifdef ASSERT\n+  \/\/ Debug support for checking if code allows safepoints or not.\n+  \/\/ Safepoints in the VM can happen because of allocation, invoking a VM operation, or blocking on\n+  \/\/ mutex, or blocking on an object synchronizer (Java locking).\n+  \/\/ If _no_safepoint_count is non-zero, then an assertion failure will happen in any of\n+  \/\/ the above cases. The class NoSafepointVerifier is used to set this counter.\n+  int _no_safepoint_count;                             \/\/ If 0, thread allow a safepoint to happen\n+\n+ public:\n+  void inc_no_safepoint_count() { _no_safepoint_count++; }\n+  void dec_no_safepoint_count() { _no_safepoint_count--; }\n+#endif \/\/ ASSERT\n+ public:\n+  \/\/ These functions check conditions before possibly going to a safepoint.\n+  \/\/ including NoSafepointVerifier.\n+  void check_for_valid_safepoint_state() NOT_DEBUG_RETURN;\n+  void check_possible_safepoint()        NOT_DEBUG_RETURN;\n+\n+#ifdef ASSERT\n+ private:\n+  volatile uint64_t _visited_for_critical_count;\n+\n+ public:\n+  void set_visited_for_critical_count(uint64_t safepoint_id) {\n+    assert(_visited_for_critical_count == 0, \"Must be reset before set\");\n+    assert((safepoint_id & 0x1) == 1, \"Must be odd\");\n+    _visited_for_critical_count = safepoint_id;\n+  }\n+  void reset_visited_for_critical_count(uint64_t safepoint_id) {\n+    assert(_visited_for_critical_count == safepoint_id, \"Was not visited\");\n+    _visited_for_critical_count = 0;\n+  }\n+  bool was_visited_for_critical_count(uint64_t safepoint_id) const {\n+    return _visited_for_critical_count == safepoint_id;\n+  }\n+#endif \/\/ ASSERT\n@@ -1283,0 +1276,2 @@\n+  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n+  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":43,"deletions":48,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -524,1 +524,3 @@\n-  t->check_for_valid_safepoint_state();\n+  if (t->is_Java_thread()) {\n+    t->as_Java_thread()->check_for_valid_safepoint_state();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}