{"files":[{"patch":"@@ -1905,1 +1905,1 @@\n-  assert(expected == obj_args->max_length() || real_target->is_method_handle_intrinsic(), \"missed on arg?\");\n+  assert(expected == obj_args->capacity() || real_target->is_method_handle_intrinsic(), \"missed on arg?\");\n@@ -1916,1 +1916,1 @@\n-  int s = obj_args->max_length();\n+  int s = obj_args->capacity();\n@@ -3971,1 +3971,1 @@\n-        int s = obj_args->max_length();\n+        int s = obj_args->capacity();\n@@ -3973,1 +3973,1 @@\n-        for (int i = args_base+start, j = 0; j < obj_args->max_length() && i < state()->stack_size(); ) {\n+        for (int i = args_base+start, j = 0; j < obj_args->capacity() && i < state()->stack_size(); ) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-\/\/ Given N > 0 and 2^N <= size < 2^(N+1), then capacity = 2^N + k * 2^(N-1)\n+\/\/ Given N > 0 and 2^N <= size < 2^(N+1), then capacity <= 2^N + k * 2^(N-1)\n@@ -62,1 +62,2 @@\n-\/\/ minimally at least size.\n+\/\/ minimally at least size.  When adding an entry and the capacity has been\n+\/\/ reached, capacity is increased to the next of those values.\n@@ -92,1 +93,0 @@\n-  void adjust_capacity(int new_capacity);\n@@ -97,1 +97,1 @@\n-  Bucket(int reserve = 0);\n+  explicit Bucket(int reserve = 0);\n@@ -110,1 +110,1 @@\n-  bool is_empty() const { return _hashes.length() == 0; }\n+  bool is_empty() const { return _hashes.is_empty(); }\n@@ -153,11 +153,0 @@\n-void StringDedup::Table::Bucket::adjust_capacity(int new_capacity) {\n-  GrowableArrayCHeap<uint, mtStringDedup> new_hashes{new_capacity};\n-  GrowableArrayCHeap<TableValue, mtStringDedup> new_values{new_capacity};\n-  while (!_hashes.is_empty()) {\n-    new_hashes.push(_hashes.pop());\n-    new_values.push(_values.pop());\n-  }\n-  _hashes.swap(&new_hashes);\n-  _values.swap(&new_values);\n-}\n-\n@@ -165,2 +154,4 @@\n-  if (_hashes.length() == _hashes.max_length()) {\n-    adjust_capacity(needed_capacity(_hashes.max_length() + 1));\n+  if (_hashes.is_full()) {\n+    int needed = needed_capacity(_hashes.capacity() + 1);\n+    _hashes.reserve(needed);\n+    _values.reserve(needed);\n@@ -171,9 +162,2 @@\n-  if (_hashes.is_empty()) {\n-    _hashes.clear_and_deallocate();\n-    _values.clear_and_deallocate();\n-  } else {\n-    int target = needed_capacity(_hashes.length());\n-    if (target < _hashes.max_length()) {\n-      adjust_capacity(target);\n-    }\n-  }\n+  _hashes.shrink_to_fit();\n+  _values.shrink_to_fit();\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupTable.cpp","additions":11,"deletions":27,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-  for (int i = 0; i < array->max_length(); ++i) {\n+  for (int i = 0; i < array->capacity(); ++i) {\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-  nonstatic_field(GrowableArrayBase,           _max,                                          int)                                   \\\n+  nonstatic_field(GrowableArrayBase,           _capacity,                                     int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  int _max;\n+  int _capacity;\n@@ -81,1 +81,1 @@\n-  GrowableArrayBase(int initial_max, int initial_len) :\n+  GrowableArrayBase(int capacity, int initial_len) :\n@@ -83,2 +83,2 @@\n-      _max(initial_max) {\n-    assert(_len >= 0 && _len <= _max, \"initial_len too big\");\n+      _capacity(capacity) {\n+    assert(_len >= 0 && _len <= _capacity, \"initial_len too big\");\n@@ -91,1 +91,1 @@\n-  int   max_length() const      { return _max; }\n+  int   capacity() const        { return _capacity; }\n@@ -95,1 +95,1 @@\n-  bool  is_full() const         { return _len == _max; }\n+  bool  is_full() const         { return _len == _capacity; }\n@@ -121,2 +121,2 @@\n-  GrowableArrayView<E>(E* data, int initial_max, int initial_len) :\n-      GrowableArrayBase(initial_max, initial_len), _data(data) {}\n+  GrowableArrayView<E>(E* data, int capacity, int initial_len) :\n+      GrowableArrayBase(capacity, initial_len), _data(data) {}\n@@ -160,1 +160,1 @@\n-    assert(_len > 0, \"empty list\");\n+    assert(_len > 0, \"empty\");\n@@ -165,1 +165,1 @@\n-    assert(_len > 0, \"empty list\");\n+    assert(_len > 0, \"empty\");\n@@ -340,1 +340,1 @@\n-    tty->print(\": length %d (_max %d) { \", _len, _max);\n+    tty->print(\": length %d (capacity %d) { \", _len, _capacity);\n@@ -363,0 +363,1 @@\n+  void expand_to(int j);\n@@ -366,3 +367,3 @@\n-  GrowableArrayWithAllocator(E* data, int initial_max) :\n-      GrowableArrayView<E>(data, initial_max, 0) {\n-    for (int i = 0; i < initial_max; i++) {\n+  GrowableArrayWithAllocator(E* data, int capacity) :\n+      GrowableArrayView<E>(data, capacity, 0) {\n+    for (int i = 0; i < capacity; i++) {\n@@ -373,2 +374,2 @@\n-  GrowableArrayWithAllocator(E* data, int initial_max, int initial_len, const E& filler) :\n-      GrowableArrayView<E>(data, initial_max, initial_len) {\n+  GrowableArrayWithAllocator(E* data, int capacity, int initial_len, const E& filler) :\n+      GrowableArrayView<E>(data, capacity, initial_len) {\n@@ -379,1 +380,1 @@\n-    for (; i < initial_max; i++) {\n+    for (; i < capacity; i++) {\n@@ -388,1 +389,1 @@\n-    if (this->_len == this->_max) grow(this->_len);\n+    if (this->_len == this->_capacity) grow(this->_len);\n@@ -406,1 +407,1 @@\n-      if (i >= this->_max) grow(i);\n+      if (i >= this->_capacity) grow(i);\n@@ -417,1 +418,1 @@\n-      if (i >= this->_max) grow(i);\n+      if (i >= this->_capacity) grow(i);\n@@ -428,1 +429,1 @@\n-    if (this->_len == this->_max) grow(this->_len);\n+    if (this->_len == this->_capacity) grow(this->_len);\n@@ -440,1 +441,1 @@\n-    if (new_len >= this->_max) grow(new_len);\n+    if (new_len >= this->_capacity) grow(new_len);\n@@ -484,1 +485,1 @@\n-    ::swap(this->_max, other->_max);\n+    ::swap(this->_capacity, other->_capacity);\n@@ -487,0 +488,6 @@\n+  \/\/ Ensure capacity is at least new_capacity.\n+  void reserve(int new_capacity);\n+\n+  \/\/ Reduce capacity to length.\n+  void shrink_to_fit();\n+\n@@ -491,5 +498,5 @@\n-void GrowableArrayWithAllocator<E, Derived>::grow(int j) {\n-  int old_max = this->_max;\n-  \/\/ grow the array by increasing _max to the first power of two larger than the size we need\n-  this->_max = next_power_of_2((uint32_t)j);\n-  \/\/ j < _max\n+void GrowableArrayWithAllocator<E, Derived>::expand_to(int new_capacity) {\n+  int old_capacity = this->_capacity;\n+  assert(new_capacity > old_capacity,\n+         \"expected growth but %d <= %d\", new_capacity, old_capacity);\n+  this->_capacity = new_capacity;\n@@ -499,2 +506,2 @@\n-  for (     ; i < this->_max; i++) ::new ((void*)&newData[i]) E();\n-  for (i = 0; i < old_max; i++) this->_data[i].~E();\n+  for (     ; i < this->_capacity; i++) ::new ((void*)&newData[i]) E();\n+  for (i = 0; i < old_capacity; i++) this->_data[i].~E();\n@@ -508,7 +515,9 @@\n-void GrowableArrayWithAllocator<E, Derived>::clear_and_deallocate() {\n-  if (this->_data != NULL) {\n-    for (int i = 0; i < this->_max; i++) {\n-      this->_data[i].~E();\n-    }\n-    static_cast<Derived*>(this)->deallocate(this->_data);\n-    this->_data = NULL;\n+void GrowableArrayWithAllocator<E, Derived>::grow(int j) {\n+  \/\/ grow the array by increasing _capacity to the first power of two larger than the size we need\n+  expand_to(next_power_of_2((uint32_t)j));\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::reserve(int new_capacity) {\n+  if (new_capacity > this->_capacity) {\n+    expand_to(new_capacity);\n@@ -516,2 +525,34 @@\n-  this->_len = 0;\n-  this->_max = 0;\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::shrink_to_fit() {\n+  int old_capacity = this->_capacity;\n+  int len = this->_len;\n+  assert(len <= old_capacity, \"invariant\");\n+\n+  \/\/ If already at full capacity, nothing to do.\n+  if (len == old_capacity) {\n+    return;\n+  }\n+\n+  \/\/ If not empty, allocate new, smaller, data, and copy old data to it.\n+  E* old_data = this->_data;\n+  E* new_data = nullptr;\n+  this->_capacity = len;        \/\/ Must preceed allocate().\n+  if (len > 0) {\n+    new_data = static_cast<Derived*>(this)->allocate();\n+    for (int i = 0; i < len; ++i) ::new (&new_data[i]) E(old_data[i]);\n+  }\n+  \/\/ Destroy contents of old data, and deallocate it.\n+  for (int i = 0; i < old_capacity; ++i) old_data[i].~E();\n+  if (old_data != nullptr) {\n+    static_cast<Derived*>(this)->deallocate(old_data);\n+  }\n+  \/\/ Install new data, which might be nullptr.\n+  this->_data = new_data;\n+}\n+\n+template <typename E, typename Derived>\n+void GrowableArrayWithAllocator<E, Derived>::clear_and_deallocate() {\n+  this->clear();\n+  this->shrink_to_fit();\n@@ -664,1 +705,1 @@\n-      return allocate(this->_max);\n+      return allocate(this->_capacity);\n@@ -668,1 +709,1 @@\n-      return allocate(this->_max, _metadata.memflags());\n+      return allocate(this->_capacity, _metadata.memflags());\n@@ -672,1 +713,1 @@\n-    return allocate(this->_max, _metadata.arena());\n+    return allocate(this->_capacity, _metadata.arena());\n@@ -682,1 +723,1 @@\n-  GrowableArray(int initial_max = 2, MEMFLAGS memflags = mtNone) :\n+  GrowableArray(int initial_capacity = 2, MEMFLAGS memflags = mtNone) :\n@@ -684,2 +725,2 @@\n-          allocate(initial_max, memflags),\n-          initial_max),\n+          allocate(initial_capacity, memflags),\n+          initial_capacity),\n@@ -690,1 +731,1 @@\n-  GrowableArray(int initial_max, int initial_len, const E& filler, MEMFLAGS memflags = mtNone) :\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags = mtNone) :\n@@ -692,2 +733,2 @@\n-          allocate(initial_max, memflags),\n-          initial_max, initial_len, filler),\n+          allocate(initial_capacity, memflags),\n+          initial_capacity, initial_len, filler),\n@@ -698,1 +739,1 @@\n-  GrowableArray(Arena* arena, int initial_max, int initial_len, const E& filler) :\n+  GrowableArray(Arena* arena, int initial_capacity, int initial_len, const E& filler) :\n@@ -700,2 +741,2 @@\n-          allocate(initial_max, arena),\n-          initial_max, initial_len, filler),\n+          allocate(initial_capacity, arena),\n+          initial_capacity, initial_len, filler),\n@@ -731,1 +772,1 @@\n-    return allocate(this->_max, F);\n+    return allocate(this->_capacity, F);\n@@ -739,1 +780,1 @@\n-  GrowableArrayCHeap(int initial_max = 0) :\n+  GrowableArrayCHeap(int initial_capacity = 0) :\n@@ -741,2 +782,2 @@\n-          allocate(initial_max, F),\n-          initial_max) {}\n+          allocate(initial_capacity, F),\n+          initial_capacity) {}\n@@ -744,1 +785,1 @@\n-  GrowableArrayCHeap(int initial_max, int initial_len, const E& filler) :\n+  GrowableArrayCHeap(int initial_capacity, int initial_len, const E& filler) :\n@@ -746,2 +787,2 @@\n-          allocate(initial_max, F),\n-          initial_max, initial_len, filler) {}\n+          allocate(initial_capacity, F),\n+          initial_capacity, initial_len, filler) {}\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":100,"deletions":59,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    Type type      = db.lookupType(\"GrowableArrayBase\");\n-    _max_field = new CIntField(type.getCIntegerField(\"_max\"), 0);\n+    Type type = db.lookupType(\"GrowableArrayBase\");\n+    _capacity_field = new CIntField(type.getCIntegerField(\"_capacity\"), 0);\n@@ -50,1 +50,1 @@\n-  private static CIntField _max_field;\n+  private static CIntField _capacity_field;\n@@ -53,2 +53,2 @@\n-  public int max() {\n-    return (int)_max_field.getValue(getAddress());\n+  public int capacity() {\n+    return (int)_capacity_field.getValue(getAddress());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/GenericGrowableArray.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  ASSERT_EQ(a.max_length(), 0);\n+  ASSERT_EQ(a.capacity(), 0);\n@@ -46,1 +46,1 @@\n-  ASSERT_GE(b.max_length(), 10);\n+  ASSERT_GE(b.capacity(), 10);\n@@ -54,1 +54,1 @@\n-  ASSERT_GE(b.max_length(), 10);\n+  ASSERT_GE(b.capacity(), 10);\n@@ -61,1 +61,1 @@\n-  ASSERT_GE(b.max_length(), 10);\n+  ASSERT_GE(b.capacity(), 10);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zArray.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,37 @@\n+  template <typename ArrayClass>\n+  static void test_capacity(ArrayClass* a) {\n+    ASSERT_EQ(a->length(), 0);\n+    a->reserve(50);\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->capacity(), 50);\n+    for (int i = 0; i < 50; ++i) {\n+      a->append(i);\n+    }\n+    ASSERT_EQ(a->length(), 50);\n+    ASSERT_EQ(a->capacity(), 50);\n+    a->append(50);\n+    ASSERT_EQ(a->length(), 51);\n+    int capacity = a->capacity();\n+    ASSERT_GE(capacity, 51);\n+    for (int i = 0; i < 30; ++i) {\n+      a->pop();\n+    }\n+    ASSERT_EQ(a->length(), 21);\n+    ASSERT_EQ(a->capacity(), capacity);\n+    a->shrink_to_fit();\n+    ASSERT_EQ(a->length(), 21);\n+    ASSERT_EQ(a->capacity(), 21);\n+\n+    a->reserve(50);\n+    ASSERT_EQ(a->length(), 21);\n+    ASSERT_EQ(a->capacity(), 50);\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->capacity(), 50);\n+\n+    a->shrink_to_fit();\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->capacity(), 0);\n+  }\n+\n@@ -203,1 +240,2 @@\n-    Iterator,\n+    Capacity,\n+    Iterator\n@@ -217,0 +255,4 @@\n+      case Capacity:\n+        test_capacity(a);\n+        break;\n+\n@@ -405,0 +447,4 @@\n+TEST_VM_F(GrowableArrayTest, capacity) {\n+  with_all_types_all_0(Capacity);\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"}]}