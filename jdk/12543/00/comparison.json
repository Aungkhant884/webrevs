{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,1 @@\n+            Class<?> decl = f.getDeclaringClass();\n@@ -121,2 +122,2 @@\n-                       ? new VarHandleReferences.FieldStaticReadOnly(refc, base, foffset, type)\n-                       : new VarHandleReferences.FieldStaticReadWrite(refc, base, foffset, type));\n+                       ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n+                       : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type));\n@@ -126,2 +127,2 @@\n-                       ? new VarHandleBooleans.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleBooleans.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n@@ -131,2 +132,2 @@\n-                       ? new VarHandleBytes.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleBytes.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n@@ -136,2 +137,2 @@\n-                       ? new VarHandleShorts.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleShorts.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n@@ -141,2 +142,2 @@\n-                       ? new VarHandleChars.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleChars.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n@@ -146,2 +147,2 @@\n-                       ? new VarHandleInts.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleInts.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n@@ -151,2 +152,2 @@\n-                       ? new VarHandleLongs.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleLongs.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n@@ -156,2 +157,2 @@\n-                       ? new VarHandleFloats.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleFloats.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n@@ -161,2 +162,2 @@\n-                       ? new VarHandleDoubles.FieldStaticReadOnly(refc, base, foffset)\n-                       : new VarHandleDoubles.FieldStaticReadWrite(refc, base, foffset));\n+                       ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n@@ -186,1 +187,1 @@\n-    static Field getStaticFieldFromBaseAndOffset(Class<?> receiverType,\n+    static Field getStaticFieldFromBaseAndOffset(Class<?> declaringClass,\n@@ -189,1 +190,1 @@\n-        for (Field f : receiverType.getDeclaredFields()) {\n+        for (Field f : declaringClass.getDeclaredFields()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -385,1 +385,1 @@\n-        final Class<?> receiverType;\n+        final Class<?> declaringClass;\n@@ -392,2 +392,2 @@\n-        FieldStaticReadOnly(Class<?> receiverType, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n@@ -396,1 +396,1 @@\n-        protected FieldStaticReadOnly(Class<?> receiverType, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n@@ -399,1 +399,1 @@\n-            this.receiverType = receiverType;\n+            this.declaringClass = declaringClass;\n@@ -411,1 +411,1 @@\n-                : new FieldStaticReadOnly(receiverType, base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n@@ -418,1 +418,1 @@\n-                : new FieldStaticReadOnly(receiverType, base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n@@ -429,3 +429,3 @@\n-                receiverType, fieldOffset, {#if[Object]?fieldType:$type$.class});\n-            var receiverTypeRef = staticField.getDeclaringClass().describeConstable();\n-            if (!receiverTypeRef.isPresent())\n+                declaringClass, fieldOffset, {#if[Object]?fieldType:$type$.class});\n+            var declaringTypeRef = declaringClass.describeConstable();\n+            if (!declaringTypeRef.isPresent())\n@@ -433,1 +433,1 @@\n-            return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));\n+            return Optional.of(VarHandleDesc.ofStaticField(declaringTypeRef.get(), staticField.getName(), fieldTypeRef.get()));\n@@ -474,2 +474,2 @@\n-        FieldStaticReadWrite(Class<?> receiverType, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(receiverType, base, fieldOffset{#if[Object]?, fieldType}, false);\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -478,1 +478,1 @@\n-        private FieldStaticReadWrite(Class<?> receiverType, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n@@ -480,1 +480,1 @@\n-            super(receiverType, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n@@ -487,1 +487,1 @@\n-                : new FieldStaticReadWrite(receiverType, base, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, true);\n@@ -494,1 +494,1 @@\n-                : new FieldStaticReadWrite(receiverType, base, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8302260\n+ * @build p.C p.D p.I p.q.Q\n+ * @run junit DescribeConstableTest\n+ * @summary Test VarHandle::describeConstable on static fields\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.VarHandleDesc;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DescribeConstableTest {\n+    private static final Lookup LOOKUP = MethodHandles.lookup();\n+    private static Stream<Arguments> testCases() {\n+        return Stream.of(\n+                \/\/ static field defined in p.C only\n+                Arguments.of(p.C.class, \"cString\", String.class, p.C.class, \"CClass\"),\n+                \/\/ static fields defined in both superinterface p.I and superclass p.q.Q\n+                \/\/ resolved to the one defined in the direct superinterface of C\n+                Arguments.of(p.C.class, \"stringField\", String.class, p.I.class, \"I\"),\n+                Arguments.of(p.C.class, \"longField\", long.class, p.I.class, 10L),\n+                \/\/ static fields defined in superclass p.q.Q only\n+                Arguments.of(p.C.class, \"stringField2\", String.class, p.q.Q.class, \"QClass2\"),\n+                Arguments.of(p.C.class, \"longField2\", long.class, p.q.Q.class, 102L),\n+                \/\/ static fields defined in superinterface p.I only\n+                Arguments.of(p.C.class, \"stringField3\", String.class, p.I.class, \"I3\"),\n+                Arguments.of(p.C.class, \"longField3\", long.class, p.I.class, 13L),\n+                \/\/ static fields defined in p.D only\n+                Arguments.of(p.D.class, \"dString\", String.class, p.D.class, \"DClass\"),\n+                Arguments.of(p.D.class, \"dLong\", long.class, p.D.class, 1L),\n+                \/\/ static fields defined in both superinterface p.I and superclass p.q.Q\n+                \/\/ resolved to the one defined in the direct superinterface of D\n+                Arguments.of(p.D.class, \"stringField\", String.class, p.I.class, \"I\"),\n+                Arguments.of(p.D.class, \"longField\", long.class, p.I.class, 10L)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void test(Class<?> refc, String name, Class<?> type, Class<?> declaringClass, Object value) throws Throwable {\n+        var vh = LOOKUP.findStaticVarHandle(refc, name, type);\n+        assertEquals(value, vh.get());\n+\n+        var refcDesc = refc.describeConstable().orElseThrow();\n+        var typeDesc = type.describeConstable().orElseThrow();\n+        var vhd = vh.describeConstable().orElseThrow();\n+        var vhd2 = VarHandleDesc.ofStaticField(refcDesc, name, typeDesc);\n+\n+        assertEquals(value, vhd.resolveConstantDesc(LOOKUP).get());\n+        assertEquals(value, vhd2.resolveConstantDesc(LOOKUP).get());\n+\n+        assertEquals(vhd.toString(), varHandleDescString(declaringClass, name, type, true));\n+    }\n+\n+    static String varHandleDescString(Class<?> declaringClass, String name, Class<?> type, boolean staticField) {\n+        return String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n+                             staticField ? \"static \" : \"\",\n+                             declaringClass.describeConstable().orElseThrow().displayName(), name,\n+                             type.describeConstable().orElseThrow().displayName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/DescribeConstableTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -24,2 +24,5 @@\n-\/\/ Used as a reference type for a field in NoSuchFieldReference.jasm\n-public class TestClass {}\n+package p;\n+\n+public class C extends p.q.Q implements I {\n+    public static String cString =  \"CClass\";\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/C.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/TestClass.java","status":"copied"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+public class D extends p.q.Q implements I {\n+    public static String dString =  \"DClass\";\n+    public static long dLong = 1L;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/D.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+public interface I {\n+    String stringField = \"I\";\n+    long longField = 10l;\n+\n+    String stringField3 = \"I3\";\n+    long longField3 = 13L;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/I.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.q;\n+\n+public class Q {\n+    public static String stringField = \"QClass\";\n+    public static long longField = 100L;\n+\n+    public static String stringField2 = \"QClass2\";\n+    public static long longField2 = 102L;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/describeConstable\/p\/q\/Q.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}