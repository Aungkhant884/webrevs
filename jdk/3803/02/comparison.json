{"files":[{"patch":"@@ -2440,0 +2440,4 @@\n+bool Matcher::supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1002,0 +1002,4 @@\n+bool Matcher::supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2197,0 +2197,4 @@\n+bool Matcher::supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1555,0 +1555,4 @@\n+bool Matcher::supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3861,10 +3861,0 @@\n-void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n-  attributes.reset_is_clear_context();\n-  attributes.set_embedded_opmask_register_specifier(mask);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n-  emit_int24(0x3E, (0xC0 | encode), vcc);\n-}\n-\n@@ -8977,1 +8967,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -8986,1 +8976,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -8990,1 +8981,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9002,1 +8993,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9008,1 +9000,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9017,1 +9009,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9021,1 +9014,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9033,1 +9026,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9039,1 +9033,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9049,1 +9043,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9053,1 +9048,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9066,1 +9061,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n@@ -9072,1 +9068,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9082,1 +9078,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9086,1 +9083,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9099,1 +9096,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1708,1 +1708,0 @@\n-  void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);\n@@ -2449,1 +2448,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2451,1 +2450,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2455,1 +2454,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2457,1 +2456,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2461,1 +2460,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2463,1 +2462,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2467,1 +2466,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2469,1 +2468,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2117,1 +2117,1 @@\n-      evpcmpb(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpb(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2120,1 +2120,1 @@\n-      evpcmpw(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpw(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2124,1 +2124,1 @@\n-      evpcmpd(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpd(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2128,1 +2128,1 @@\n-      evpcmpq(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpq(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2136,0 +2136,78 @@\n+void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n+                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vpackssdw(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpermilps(dst, dst, 8, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+  if (vlen_in_bytes == 16) {\n+    vpermpd(dst, dst, 0x8, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n+    vpackssdw(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpshufd(dst, dst, 8, vlen_enc);\n+    vpermq(dst, dst, 8, vlen_enc);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n+    vpshufd(vtmp3, vtmp3, 8, vlen_enc);\n+    vpermq(vtmp3, vtmp3, 0x80, vlen_enc);\n+    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -143,0 +143,6 @@\n+  \/\/ vector compare\n+  void vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+              XMMRegister vtmp1, XMMRegister vtmp2, Register scratch);\n+  void vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3146,1 +3146,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3148,1 +3148,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3151,1 +3151,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3156,1 +3156,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3158,1 +3158,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3161,1 +3161,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3166,1 +3166,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3168,1 +3168,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3171,1 +3171,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3176,1 +3176,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3178,1 +3178,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3181,1 +3181,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -7861,1 +7861,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n@@ -7911,1 +7911,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1288,1 +1288,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1290,1 +1290,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1292,1 +1292,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1294,1 +1294,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1296,1 +1296,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1298,1 +1298,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1300,1 +1300,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1302,1 +1302,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1277,0 +1277,4 @@\n+static inline bool is_unsigned_booltest_pred(int bt) {\n+  return  ((bt & BoolTest::unsigned_compare) == BoolTest::unsigned_compare);\n+}\n+\n@@ -1876,0 +1880,16 @@\n+bool Matcher::supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+  if ((UseAVX > 2) && (VM_Version::supports_avx512vl() || vlen == 64))\n+    return true;\n+  else {\n+    \/\/ instruction set supports only signed comparison\n+    \/\/ so need to zero extend to higher integral type and perform comparison\n+    \/\/ cannot cast long to higher integral type\n+    \/\/ and on avx1 cannot cast 128 bit integral vectors to higher size\n+\n+    if ((bt != T_LONG)  &&\n+        ((UseAVX >= 2) || (vlen <= 8)))\n+      return true;\n+  }\n+  return false;\n+}\n+\n@@ -2171,6 +2191,16 @@\n-    case BoolTest::eq: return Assembler::eq;\n-    case BoolTest::ne: return Assembler::neq;\n-    case BoolTest::le: return Assembler::le;\n-    case BoolTest::ge: return Assembler::nlt;\n-    case BoolTest::lt: return Assembler::lt;\n-    case BoolTest::gt: return Assembler::nle;\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n@@ -6860,1 +6890,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) && \n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n@@ -6875,2 +6907,23 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n+            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+              $vtmp2$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n@@ -6879,0 +6932,18 @@\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+  predicate(UseAVX > 2 && \n+            (VM_Version::supports_avx512vl() ||  \n+             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n@@ -6884,1 +6955,1 @@\n-    int vlen_enc = Assembler::AVX_512bit;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -6886,0 +6957,1 @@\n+    bool is_unsigned = is_unsigned_booltest_pred($cond$$constant);\n@@ -6892,1 +6964,1 @@\n-        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6897,1 +6969,1 @@\n-        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6902,1 +6974,1 @@\n-        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6907,1 +6979,1 @@\n-        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6911,1 +6983,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":15,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -359,0 +359,3 @@\n+  \/\/ Does the CPU supports vector unsigned comparison instructions for given vector length and type?\n+  static bool supports_vector_comparison_unsigned(int vlen, BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+\/\/ For vector compares, additionally, the 4th bit indicates if the compare is unsigned\n@@ -308,1 +309,5 @@\n-  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9 };\n+  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9,\n+              \/\/ The following values are used with vector compares\n+              \/\/ A BoolTest value should not be constructed for such values\n+              unsigned_compare = 16,\n+              ule = unsigned_compare | le, uge = unsigned_compare | ge, ult = unsigned_compare | lt, ugt = unsigned_compare | gt };\n@@ -310,1 +315,1 @@\n-  BoolTest( mask btm ) : _test(btm) {}\n+  BoolTest( mask btm ) : _test(btm) { assert((btm & unsigned_compare) == 0, \"unsupported\");}\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -550,0 +550,16 @@\n+static bool elem_consistent_with_arr(BasicType elem_bt, const TypeAryPtr* arr_type) {\n+  assert(arr_type != NULL, \"unexpected\");\n+  BasicType arr_elem_bt = arr_type->elem()->array_element_basic_type();\n+  if (elem_bt == arr_elem_bt) {\n+    return true;\n+  } else if (elem_bt == T_SHORT && arr_elem_bt == T_CHAR) {\n+    \/\/ Load\/store of short vector from\/to char[] is supported\n+    return true;\n+  } else if (elem_bt == T_BYTE && arr_elem_bt == T_BOOLEAN) {\n+    \/\/ Load\/store of byte vector from\/to boolean[] is supported\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -628,1 +644,6 @@\n-  if (arr_type != NULL && !using_byte_array && elem_bt != arr_type->elem()->array_element_basic_type() && !is_mask) {\n+  if (arr_type != NULL && !using_byte_array && !is_mask && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_store, is_store ? \"store\" : \"load\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -811,1 +832,6 @@\n-  if (arr_type == NULL || (arr_type != NULL && elem_bt != arr_type->elem()->array_element_basic_type())) {\n+  if (arr_type == NULL || (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type))) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+                    is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -1130,0 +1156,10 @@\n+  if ((cond->get_con() & BoolTest::unsigned_compare) != 0) {\n+    if (!Matcher::supports_vector_comparison_unsigned(num_elem, elem_bt)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+                      cond->get_con() & (BoolTest::unsigned_compare - 1), num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -32,3 +31,0 @@\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n-import java.util.Objects;\n@@ -72,9 +68,18 @@\n-    \/\/ enum BoolTest\n-    public static final int BT_eq = 0;\n-    public static final int BT_ne = 4;\n-    public static final int BT_le = 5;\n-    public static final int BT_ge = 7;\n-    public static final int BT_lt = 3;\n-    public static final int BT_gt = 1;\n-    public static final int BT_overflow = 2;\n-    public static final int BT_no_overflow = 6;\n+    \/\/ See src\/hotspot\/share\/opto\/subnode.hpp\n+    \/\/     struct BoolTest, and enclosed enum mask\n+    public static final int BT_eq = 0;  \/\/ 0000\n+    public static final int BT_ne = 4;  \/\/ 0100\n+    public static final int BT_le = 5;  \/\/ 0101\n+    public static final int BT_ge = 7;  \/\/ 0111\n+    public static final int BT_lt = 3;  \/\/ 0011\n+    public static final int BT_gt = 1;  \/\/ 0001\n+    public static final int BT_overflow = 2;     \/\/ 0010\n+    public static final int BT_no_overflow = 6;  \/\/ 0110\n+    \/\/ never = 8    1000\n+    \/\/ illegal = 9  1001\n+    \/\/ Unsigned comparisons apply to BT_le, BT_ge, BT_lt, BT_gt for integral types\n+    public static final int BT_unsigned_compare = 0b10000;\n+    public static final int BT_ule = BT_le | BT_unsigned_compare;\n+    public static final int BT_uge = BT_ge | BT_unsigned_compare;\n+    public static final int BT_ult = BT_lt | BT_unsigned_compare;\n+    public static final int BT_ugt = BT_gt | BT_unsigned_compare;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -808,0 +808,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -840,0 +840,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -904,0 +904,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -792,0 +792,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -778,0 +778,8 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, byte a, byte b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Byte.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Byte.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Byte.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Byte.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2826,0 +2815,159 @@\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ByteVector zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n@@ -2952,1 +3100,1 @@\n-     * Stores this vector into an array of {@code byte}\n+     * Stores this vector into an array of type {@code byte[]}\n@@ -3068,0 +3216,168 @@\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ByteSpecies vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ByteVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<Byte> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n+    }\n+\n@@ -3174,0 +3490,16 @@\n+\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    ByteVector fromBooleanArray0Template(boolean[] a, int offset) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+\n@@ -3304,0 +3636,11 @@\n+\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":369,"deletions":26,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -776,0 +776,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -780,0 +780,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -788,0 +788,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -773,0 +773,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1683,11 +1669,10 @@\n-    private static\n-    boolean compareWithOp(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, double a, double b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -2733,0 +2718,2 @@\n+\n+\n@@ -2865,1 +2852,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3022,0 +3009,2 @@\n+\n+\n@@ -3128,0 +3117,2 @@\n+\n+\n@@ -3263,0 +3254,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -780,0 +780,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -788,0 +788,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,0 +804,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -776,0 +776,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -773,0 +773,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1695,11 +1681,10 @@\n-    private static\n-    boolean compareWithOp(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, float a, float b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n@@ -2739,0 +2724,2 @@\n+\n+\n@@ -2871,1 +2858,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3009,0 +2996,2 @@\n+\n+\n@@ -3115,0 +3104,2 @@\n+\n+\n@@ -3250,0 +3241,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -784,0 +784,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -792,0 +792,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -808,0 +808,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -780,0 +780,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -789,0 +789,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1769,11 +1755,14 @@\n-    private static\n-    boolean compareWithOp(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, int a, int b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Integer.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Integer.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Integer.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Integer.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2842,0 +2831,2 @@\n+\n+\n@@ -2974,1 +2965,1 @@\n-     * Stores this vector into an array of {@code int}\n+     * Stores this vector into an array of type {@code int[]}\n@@ -3112,0 +3103,2 @@\n+\n+\n@@ -3218,0 +3211,2 @@\n+\n+\n@@ -3353,0 +3348,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -770,0 +770,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -782,0 +782,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -768,0 +768,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -768,0 +768,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1687,11 +1673,14 @@\n-    private static\n-    boolean compareWithOp(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, long a, long b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Long.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Long.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Long.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Long.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2726,0 +2715,2 @@\n+\n+\n@@ -2858,1 +2849,1 @@\n-     * Stores this vector into an array of {@code long}\n+     * Stores this vector into an array of type {@code long[]}\n@@ -3015,0 +3006,2 @@\n+\n+\n@@ -3121,0 +3114,2 @@\n+\n+\n@@ -3256,0 +3251,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -792,0 +792,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -808,0 +808,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -840,0 +840,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -784,0 +784,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -778,0 +778,8 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Short.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Short.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Short.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Short.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n@@ -2826,0 +2815,153 @@\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ShortVector zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Short> m) {\n+        \/\/ FIXME: optimize\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n@@ -2958,1 +3100,1 @@\n-     * Stores this vector into an array of {@code short}\n+     * Stores this vector into an array of type {@code short[]}\n@@ -3074,0 +3216,155 @@\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Short> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n@@ -3180,0 +3477,16 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    ShortVector fromCharArray0Template(char[] a, int offset) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n@@ -3315,0 +3628,11 @@\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":350,"deletions":26,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -243,4 +243,4 @@\n- * {@code VLENGTH}.)  The output resulting from a lane-wise operation\n- * will have a {@code VLENGTH} which is equal to the {@code VLENGTH}\n- * of the input(s) to the operation.  Thus, lane-wise operations are\n- * <em>length-invariant<\/em>, in their basic definitions.\n+ * {@code VLENGTH}.)  For most lane-wise operations, the output resulting\n+ * from a lane-wise operation will have a {@code VLENGTH} which is equal to\n+ * the {@code VLENGTH} of the input(s) to the operation.  Thus, such lane-wise\n+ * operations are <em>length-invariant<\/em>, in their basic definitions.\n@@ -249,1 +249,1 @@\n- * basic principle, that lane-wise operations are always\n+ * basic principle, that most length-invariant lane-wise operations are also\n@@ -802,1 +802,2 @@\n- * <em>length-invariant<\/em>.  Length-invariance simply means that\n+ * <em>length-invariant<\/em>, unless clearly marked otherwise.\n+ * Length-invariance simply means that\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -568,1 +568,20 @@\n-    \/\/ FIXME: add unsigned comparisons\n+    \/** Unsigned compare {@code a<b}.  Integral only.\n+     * @see java.lang.Integer#compareUnsigned\n+     * @see java.lang.Long#compareUnsigned\n+     *\/\n+    public static final Comparison UNSIGNED_LT = compare(\"UNSIGNED_LT\", \"<\",  VectorSupport.BT_ult, VO_NOFP);\n+    \/** Unsigned compare {@code a<=b}.  Integral only.\n+     * @see java.lang.Integer#compareUnsigned\n+     * @see java.lang.Long#compareUnsigned\n+     *\/\n+    public static final Comparison UNSIGNED_LE = compare(\"UNSIGNED_LE\", \"<=\", VectorSupport.BT_ule, VO_NOFP);\n+    \/** Unsigned compare {@code a>b}.  Integral only.\n+     * @see java.lang.Integer#compareUnsigned\n+     * @see java.lang.Long#compareUnsigned\n+     *\/\n+    public static final Comparison UNSIGNED_GT = compare(\"UNSIGNED_GT\", \">\",  VectorSupport.BT_ugt, VO_NOFP);\n+    \/** Unsigned compare {@code a>=b}.  Integral only.\n+     * @see java.lang.Integer#compareUnsigned\n+     * @see java.lang.Long#compareUnsigned\n+     *\/\n+    public static final Comparison UNSIGNED_GE = compare(\"UNSIGNED_GE\", \">=\", VectorSupport.BT_uge, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -386,14 +386,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -2035,11 +2021,16 @@\n-    private static\n-    boolean compareWithOp(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#if[!FP]\n+            case BT_ult -> $Boxtype$.compareUnsigned(a, b) < 0;\n+            case BT_ule -> $Boxtype$.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> $Boxtype$.compareUnsigned(a, b) > 0;\n+            case BT_uge -> $Boxtype$.compareUnsigned(a, b) >= 0;\n+#end[!FP]\n+            default -> throw new AssertionError();\n+        };\n@@ -3366,0 +3357,1 @@\n+#if[short]\n@@ -3367,14 +3359,6 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n@@ -3383,4 +3367,3 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n@@ -3388,2 +3371,1 @@\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n@@ -3394,4 +3376,3 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n@@ -3399,1 +3380,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n@@ -3403,3 +3384,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n@@ -3408,31 +3388,7 @@\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * $Type$Buffer eb = bb.duplicate()\n-     *     .position(offset){#if[byte]?;}\n-#if[!byte]\n-     *     .order(bo).as$Type$Buffer();\n-#end[!byte]\n-     * $type$[] ar = new $type$[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n@@ -3441,3 +3397,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n+     * @param a the array\n+     * @param offset the offset into the array\n@@ -3445,1 +3400,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return the vector loaded from an array\n@@ -3447,2 +3402,1 @@\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n@@ -3454,4 +3408,3 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<$Boxtype$> m) {\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n@@ -3459,1 +3412,1 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n@@ -3461,2 +3414,1 @@\n-            $abstractvectortype$ v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n@@ -3466,4 +3418,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n@@ -3472,1 +3422,40 @@\n-    \/\/ Memory store operations\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n@@ -3475,2 +3464,8 @@\n-     * Stores this vector into an array of type {@code $type$[]}\n-     * starting at an offset.\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n@@ -3479,2 +3474,6 @@\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[offset+N]}.\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n@@ -3482,1 +3481,44 @@\n-     * @param a the array, of type {@code $type$[]}\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+#end[short]\n+\n+#if[byte]\n+    \/**\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     * <p>\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n@@ -3484,0 +3526,1 @@\n+     * @return the vector loaded from an array\n@@ -3489,12 +3532,6 @@\n-    public final\n-    void intoArray($type$[] a, int offset) {\n-        offset = checkFromIndexSize(offset, length(), a.length);\n-        $Type$Species vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, arrayAddress(a, offset),\n-            this,\n-            a, offset,\n-            (arr, off, v)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromBooleanArray0(a, offset);\n@@ -3504,3 +3541,4 @@\n-     * Stores this vector into an array of {@code $type$}\n-     * starting at offset and using a mask.\n-     * <p>\n+     * Loads a vector from an array of type {@code boolean[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n@@ -3508,4 +3546,6 @@\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[offset+N]}.\n-     * If the mask lane at {@code N} is unset then the corresponding\n-     * array element {@code a[offset+N]} is left unchanged.\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first converted to a {@code byte} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n@@ -3513,5 +3553,2 @@\n-     * Array range checking is done for lanes where the mask is set.\n-     * Lanes where the mask is unset are not stored and do not need\n-     * to correspond to legitimate elements of {@code a}.\n-     * That is, unset lanes may correspond to array indexes less than\n-     * zero or beyond the end of the array.\n+     * A {@code boolean} value is converted to a {@code byte} value by applying the\n+     * expression {@code (byte) (b ? 1 : 0)}, where {@code b} is the {@code boolean} value.\n@@ -3519,1 +3556,2 @@\n-     * @param a the array, of type {@code $type$[]}\n+     * @param species species of desired vector\n+     * @param a the array\n@@ -3521,1 +3559,2 @@\n-     * @param m the mask controlling lane storage\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n@@ -3528,10 +3567,8 @@\n-    public final\n-    void intoArray($type$[] a, int offset,\n-                   VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset);\n-        } else {\n-            \/\/ FIXME: optimize\n-            $Type$Species vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = v);\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n@@ -3539,0 +3576,4 @@\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (byte) (a[offset + i] ? 1 : 0));\n@@ -3542,1 +3583,2 @@\n-     * Scatters this vector into an array of type {@code $type$[]}\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n@@ -3550,2 +3592,2 @@\n-     * the lane element at index {@code N} is stored into the array\n-     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n@@ -3555,0 +3597,1 @@\n+     * @param species species of desired vector\n@@ -3556,1 +3599,3 @@\n-     * @param offset an offset to combine with the index map offsets\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n@@ -3559,0 +3604,1 @@\n+     * @return the vector loaded from the indexed elements of the array\n@@ -3567,1 +3613,0 @@\n-#if[byteOrShort]\n@@ -3569,1 +3614,272 @@\n-    public final\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, int offset,\n+                                          int[] indexMap, int mapOffset,\n+                                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+    }\n+#end[byte]\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n+     * fromByteBuffer()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n+     * starting at an offset into the byte buffer\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * $Type$Buffer eb = bb.duplicate()\n+     *     .position(offset){#if[byte]?;}\n+#if[!byte]\n+     *     .order(bo).as$Type$Buffer();\n+#end[!byte]\n+     * $type$[] ar = new $type$[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = eb.get(n);\n+     *     }\n+     * }\n+     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+#if[!byte]\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+#else[!byte]\n+     * The byte order argument is ignored.\n+#end[!byte]\n+     *\n+     * @param species species of desired vector\n+     * @param bb the byte buffer\n+     * @param offset the offset into the byte buffer\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from a byte buffer\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n+                                        ByteBuffer bb, int offset,\n+                                        ByteOrder bo,\n+                                        VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            $abstractvectortype$ v = zero.fromByteBuffer0(bb, offset);\n+            return zero.blend(v.maybeSwap(bo), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n+        ByteBuffer wb = wrapper(bb, bo);\n+        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n+                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code $type$[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code $type$[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code $type$[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code $type$[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+#if[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+#else[byteOrShort]\n+    @ForceInline\n+    public final\n@@ -3572,0 +3888,215 @@\n+        $Type$Species vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+#if[longOrDouble]\n+        if (vsp.laneCount() == 1) {\n+            intoArray(a, offset + indexMap[mapOffset]);\n+            return;\n+        }\n+\n+        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n+        IntVector vix;\n+        if (isp.laneCount() != vsp.laneCount()) {\n+            \/\/ For $Type$MaxVector,  if vector length  is 2048 bits, indexShape\n+            \/\/ of $Type$ species is S_MAX_BIT. and the lane count of $Type$\n+            \/\/ vector is 32. When converting $Type$ species to int species,\n+            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n+            \/\/ is 64. So when loading index vector (IntVector), only lower half\n+            \/\/ of index data is needed.\n+            vix = IntVector\n+                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n+                .add(offset);\n+        } else {\n+            vix = IntVector\n+                .fromArray(isp, indexMap, mapOffset)\n+                .add(offset);\n+        }\n+\n+#else[longOrDouble]\n+        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n+        IntVector vix = IntVector\n+            .fromArray(isp, indexMap, mapOffset)\n+            .add(offset);\n+#end[longOrDouble]\n+\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        VectorSupport.storeWithMap(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            isp.vectorType(),\n+            a, arrayAddress(a, 0), vix,\n+            this,\n+            a, offset, indexMap, mapOffset,\n+            (arr, off, v, map, mo)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> {\n+                          int j = map[mo + i];\n+                          arr[off + j] = e;\n+                      }));\n+    }\n+#end[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+#if[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+#else[byteOrShort]\n+    @ForceInline\n+    public final\n+    void intoArray($type$[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            \/\/ FIXME: Cannot vectorize yet, if there's a mask.\n+            stOp(a, offset, m,\n+                 (arr, off, i, e) -> {\n+                     int j = indexMap[mapOffset + i];\n+                     arr[off + j] = e;\n+                 });\n+        }\n+    }\n+#end[byteOrShort]\n+\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n@@ -3575,1 +4106,1 @@\n-                 arr[off + j] = e;\n+                 arr[off + j] = (char) e;\n@@ -3578,1 +4109,33 @@\n-#else[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n@@ -3581,2 +4144,35 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+#end[short]\n+\n+#if[byte]\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n@@ -3584,6 +4180,10 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset]);\n-            return;\n-        }\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n@@ -3591,12 +4191,34 @@\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of $Type$ species is S_MAX_BIT. and the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n+    \/**\n+     * Stores this vector into an array of type {@code boolean[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoBooleanArray(a, offset);\n@@ -3604,3 +4226,4 @@\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n@@ -3608,0 +4231,1 @@\n+    }\n@@ -3609,21 +4233,41 @@\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (e & 1) != 0;\n+             });\n@@ -3631,1 +4275,0 @@\n-#end[byteOrShort]\n@@ -3634,1 +4277,1 @@\n-     * Scatters this vector into an array of type {@code $type$[]},\n+     * Scatters this vector into an array of type {@code boolean[]},\n@@ -3644,1 +4287,3 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane element at index {@code N}\n+     * is first converted to a {@code boolean} value and then\n+     * stored into the array\n@@ -3648,0 +4293,3 @@\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n@@ -3663,1 +4311,0 @@\n-#if[byteOrShort]\n@@ -3666,3 +4313,4 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n+    void intoBooleanArray(boolean[] a, int offset,\n+                          int[] indexMap, int mapOffset,\n+                          VectorMask<$Boxtype$> m) {\n+        \/\/ FIXME: optimize\n@@ -3672,1 +4320,1 @@\n-                 arr[off + j] = e;\n+                 arr[off + j] = (e & 1) != 0;\n@@ -3675,19 +4323,1 @@\n-#else[byteOrShort]\n-    @ForceInline\n-    public final\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n-        }\n-        else {\n-            \/\/ FIXME: Cannot vectorize yet, if there's a mask.\n-            stOp(a, offset, m,\n-                 (arr, off, i, e) -> {\n-                     int j = indexMap[mapOffset + i];\n-                     arr[off + j] = e;\n-                 });\n-        }\n-    }\n-#end[byteOrShort]\n+#end[byte]\n@@ -3801,0 +4431,34 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n+#if[byte]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromBooleanArray0Template(boolean[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+#end[byte]\n+\n@@ -3938,0 +4602,24 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n+#if[byte]\n+    static final int ARRAY_BOOLEAN_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_BOOLEAN_INDEX_SCALE);\n+    static final long ARRAY_BOOLEAN_BASE =\n+            Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long booleanArrayAddress(boolean[] a, int index) {\n+        return ARRAY_BOOLEAN_BASE + (((long)index) << ARRAY_BOOLEAN_SHIFT);\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":910,"deletions":222,"binary":false,"changes":1132,"status":"modified"},{"patch":"@@ -1066,0 +1066,18 @@\n+#if[short]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[short]\n+\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[byte]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -951,0 +951,90 @@\n+\n+\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n@@ -1045,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1168,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3340,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3360,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3383,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3403,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3426,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3446,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3466,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3489,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3509,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3532,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3552,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3575,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3595,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3618,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3625,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -951,0 +951,90 @@\n+\n+\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n@@ -1045,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1168,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3340,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3360,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3383,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3403,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3426,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3446,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3466,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3489,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3509,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3532,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3552,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3575,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3595,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3618,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3625,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -951,0 +951,90 @@\n+\n+\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n@@ -1045,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1168,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3340,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3360,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3383,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3403,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3426,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3446,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3466,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3489,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3509,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3532,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3552,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3575,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3595,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3618,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3625,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -951,0 +951,90 @@\n+\n+\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n@@ -1045,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1168,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3340,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3360,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3383,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3403,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3426,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3446,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3466,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3489,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3509,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3532,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3552,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3575,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3595,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3618,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3625,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -960,0 +960,90 @@\n+\n+\n+\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -988,0 +988,1 @@\n+                int upper = Math.min(Byte.MAX_VALUE + 1, m);\n@@ -989,1 +990,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n@@ -1050,0 +1051,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1173,0 +1178,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3345,1 +3390,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3365,1 +3410,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3388,1 +3433,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3408,1 +3453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3431,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3451,1 +3496,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3471,1 +3516,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3494,1 +3539,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3514,1 +3559,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3537,1 +3582,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3557,1 +3602,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3580,1 +3625,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3600,1 +3645,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3623,1 +3668,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3630,0 +3768,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n@@ -1177,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1289,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2657,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2677,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2700,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2720,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2743,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2763,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2783,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2806,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2826,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2849,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2869,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2892,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2912,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2935,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2942,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n@@ -1177,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1289,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2657,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2677,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2700,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2720,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2743,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2763,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2783,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2806,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2826,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2849,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2869,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2892,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2912,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2935,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2942,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n@@ -1177,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1289,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2657,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2677,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2700,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2720,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2743,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2763,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2783,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2806,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2826,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2849,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2869,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2892,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2912,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2935,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2942,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n@@ -1177,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1289,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2657,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2677,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2700,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2720,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2743,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2763,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2783,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2806,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2826,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2849,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2869,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2892,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2912,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2935,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2942,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -971,0 +971,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1120,0 +1120,1 @@\n+                int upper = m;\n@@ -1121,1 +1122,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n@@ -1182,0 +1183,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1294,0 +1299,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2662,1 +2692,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2682,1 +2712,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2705,1 +2735,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2725,1 +2755,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2748,1 +2778,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2768,1 +2798,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2788,1 +2818,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2811,1 +2841,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2831,1 +2861,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2854,1 +2884,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2874,1 +2904,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2897,1 +2927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2917,1 +2947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2940,1 +2970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2947,0 +2977,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n@@ -1187,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1299,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2667,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2687,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2710,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2730,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2753,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2773,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2793,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2816,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2836,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2859,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2879,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2902,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2922,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2945,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2952,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n@@ -1187,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1299,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2667,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2687,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2710,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2730,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2753,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2773,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2793,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2816,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2836,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2859,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2879,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2902,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2922,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2945,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2952,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n@@ -1187,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1299,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2667,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2687,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2710,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2730,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2753,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2773,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2793,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2816,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2836,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2859,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2879,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2902,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2922,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2945,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2952,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n@@ -1187,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1299,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2667,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2687,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2710,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2730,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2753,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2773,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2793,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2816,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2836,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2859,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2879,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2902,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2922,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2945,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2952,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -971,0 +971,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1130,0 +1130,1 @@\n+                int upper = m;\n@@ -1131,1 +1132,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n@@ -1192,0 +1193,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1304,0 +1309,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2672,1 +2702,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2692,1 +2722,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2715,1 +2745,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2735,1 +2765,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2758,1 +2788,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2778,1 +2808,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2798,1 +2828,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2821,1 +2851,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2841,1 +2871,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2864,1 +2894,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2884,1 +2914,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2907,1 +2937,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2927,1 +2957,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2950,1 +2980,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2957,0 +2987,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -971,0 +971,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1011,0 +1011,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1134,0 +1138,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3311,1 +3355,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3354,1 +3398,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3397,1 +3441,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3460,1 +3504,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3503,1 +3547,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3546,1 +3590,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3589,1 +3633,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3596,0 +3733,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n@@ -1031,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1150,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3327,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3347,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3370,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3390,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3413,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3433,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3453,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3476,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3496,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3519,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3539,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3562,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3582,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3605,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3612,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n@@ -1031,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1150,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3327,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3347,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3370,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3390,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3413,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3433,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3453,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3476,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3496,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3519,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3539,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3562,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3582,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3605,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3612,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n@@ -1031,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1150,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3327,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3347,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3370,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3390,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3413,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3433,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3453,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3476,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3496,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3519,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3539,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3562,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3582,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3605,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3612,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n@@ -1031,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1150,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3327,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3347,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3370,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3390,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3413,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3433,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3453,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3476,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3496,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3519,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3539,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3562,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3582,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3605,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3612,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -971,0 +971,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -974,0 +974,1 @@\n+                int upper = m;\n@@ -975,1 +976,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n@@ -1036,0 +1037,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1155,0 +1160,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3332,1 +3377,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3352,1 +3397,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3375,1 +3420,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3395,1 +3440,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3418,1 +3463,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3438,1 +3483,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3458,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3481,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3501,1 +3546,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3524,1 +3569,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3544,1 +3589,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3567,1 +3612,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3587,1 +3632,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3610,1 +3655,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3617,0 +3755,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,247 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n@@ -1035,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1158,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3330,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3350,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3373,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3393,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3416,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3436,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3456,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3479,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3499,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3522,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3542,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3565,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3585,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3608,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3615,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,247 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n@@ -1035,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1158,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3330,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3350,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3373,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3393,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3416,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3436,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3456,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3479,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3499,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3522,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3542,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3565,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3585,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3608,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3615,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,247 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n@@ -1035,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1158,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3330,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3350,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3373,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3393,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3416,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3436,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3456,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3479,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3499,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3522,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3542,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3565,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3585,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3608,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3615,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -962,0 +962,247 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n@@ -1035,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1158,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3330,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3350,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3373,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3393,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3416,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3436,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3456,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3479,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3499,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3522,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3542,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3565,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3585,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3608,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3615,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -971,0 +971,247 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -978,0 +978,1 @@\n+                int upper = m;\n@@ -979,1 +980,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n@@ -1040,0 +1041,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1163,0 +1168,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3335,1 +3380,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3355,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3378,1 +3423,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3398,1 +3443,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3421,1 +3466,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3441,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3461,1 +3506,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3484,1 +3529,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3504,1 +3549,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3527,1 +3572,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3547,1 +3592,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3570,1 +3615,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3590,1 +3635,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3613,1 +3658,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3620,0 +3758,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":248,"deletions":15,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -484,6 +484,13 @@\n-gen_compare_op \"LT+lt\" \"<\"\n-gen_compare_op \"GT\" \">\"\n-gen_compare_op \"EQ+eq\" \"==\"\n-gen_compare_op \"NE\" \"!=\"\n-gen_compare_op \"LE\" \"<=\"\n-gen_compare_op \"GE\" \">=\"\n+gen_compare_op \"LT+lt\" \"lt\"\n+gen_compare_op \"GT\" \"gt\"\n+gen_compare_op \"EQ+eq\" \"eq\"\n+gen_compare_op \"NE\" \"neq\"\n+gen_compare_op \"LE\" \"le\"\n+gen_compare_op \"GE\" \"ge\"\n+\n+gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+      args=\"$args -KByteMax\"\n+    fi\n@@ -228,0 +231,3 @@\n+    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+      args=\"$args -KByteMax\"\n+    fi\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] [[TEST_OP]] b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Masked.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] [[TEST_OP]] b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1187,0 +1187,5 @@\n+#if[ByteMax]\n+                int upper = Math.min(Byte.MAX_VALUE + 1, m);\n+#else[ByteMax]\n+                int upper = m;\n+#end[ByteMax]\n@@ -1188,1 +1193,1 @@\n-                    a[i] = ($type$)RAND.nextInt(m);\n+                    a[i] = ($type$)RAND.nextInt(upper);\n@@ -1250,0 +1255,4 @@\n+            withToString(\"$type$[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1396,0 +1405,42 @@\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -994,0 +994,338 @@\n+\n+\n+#if[short]\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Boxtype$> m) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Boxtype$> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+#end[short]\n+\n+#if[byte]\n+    static void assertArraysEquals(boolean[] r, byte[] a) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], (a[i] & 1) == 1);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (a[i] & 1) == 1, \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(boolean[] r, boolean[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] && a[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static boolean[] convertToBooleanArray(byte[] a) {\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            r[i] = (a[i] & 1) == 1;\n+        }\n+\n+        return r;\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadByteStoreBooleanArray(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteProvider\")\n+    static void loadStoreBooleanArray(IntFunction<byte[]> fa) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"byteMaskProvider\")\n+    static void loadStoreMaskBooleanArray(IntFunction<byte[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+        boolean[] r = new boolean[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, vmask);\n+                av.intoBooleanArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                av.intoBooleanArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":338,"deletions":0,"binary":false,"changes":338,"status":"modified"}]}